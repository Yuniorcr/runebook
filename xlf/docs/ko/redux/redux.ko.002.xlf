<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="translated">이 상태를 주어진 시점 (즉, 시간 여행 디버깅)으로 복원 할 수있는 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="translated">Redux 하위 앱 격리</target>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="translated">서브 앱 분리</target>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="translated">더 큰 응용 프로그램에서 Redux 앱을 구성 요소로 격리하면 루트 구성 요소 인스턴스 당 저장소를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="translated">루트 상태 객체에 대한 참조와 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수 에서 반환 된 props 객체의 &lt;em&gt;각 값&lt;/em&gt; 에 대한 참조를 유지하여 변경을 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next(action)&lt;/code&gt; 대신 미들웨어에서 &lt;code&gt;store.dispatch(action)&lt;/code&gt; 을 호출 하면 현재 미들웨어를 포함하여 실제로 미들웨어 체인 전체를 다시 이동시키는 지 확인하는 것은 약간의 속임수 입니다. 이것은 &lt;a href=&quot;asyncactions&quot;&gt;앞에서&lt;/a&gt; 본 것처럼 비동기 미들웨어에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="translated">빌드 시스템이나 뷰 프레임 워크가 필요하지 않으며 ES5와 함께 사용되는 원시 Redux API를 보여주기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="translated">props 객체는 실제로 다음 예제와 같이 prop 이름과 해당 값 (또는 값을 검색하거나 생성하는 데 사용되는 선택기 함수)의 해시이기 때문에 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="translated">객체의 각 값에 대해 개별적으로 얕은 동등성 검사를 수행하여이를 수행하며, 이러한 검사 중 하나가 실패하는 경우에만 다시 렌더링을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="translated">액션 크리에이터는 액션을 &lt;em&gt;반환&lt;/em&gt; 하는 함수이기 때문에 작동하지 않습니다 . 실제로 파견하는 것은 당신에게 달려 있습니다. 서버에서 렌더링하는 앱은 모든 요청에 ​​대해 별도의 Redux 스토어가 필요하기 때문에 정의 중에 액션 생성자를 특정 스토어 인스턴스에 바인딩 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="translated">모든 조치 유형이 한 곳에 모이기 때문에 이름의 일관성을 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="translated">일관성있게 동작하고 다른 환경 (클라이언트, 서버 및 기본)에서 실행되며 테스트하기 쉬운 응용 프로그램을 작성하는 데 도움이됩니다. 또한 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;시간 이동 디버거와 결합 된 라이브 코드 편집과&lt;/a&gt; 같은 훌륭한 개발자 경험을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="translated">리듀서 (또는 플럭스의 스토어)에서 액션을 식별하는 데 도움이되는 상수 유형이 액션에있는 것이 일반적인 규칙입니다. 문자열은 직렬화 가능하고 기호를 사용하면 기록 및 재생을 필요 이상으로 어렵게 만들므로 동작 유형에 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;기호&lt;/a&gt; 가 아닌 문자열을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">저수준 API입니다. 대부분 직접 사용하는 대신 React (또는 다른) 바인딩을 사용합니다. 상태 변경에 반응하기 위해 일반적으로 콜백을 후크로 사용하는 경우 &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;사용자 지정 &lt;code&gt;observeStore&lt;/code&gt; 유틸리티&lt;/a&gt; 를 작성할 수 있습니다 . &lt;code&gt;Store&lt;/code&gt; 또한이다 &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 당신이 할 수 있도록 &lt;code&gt;subscribe&lt;/code&gt; 등의 라이브러리와 변화에 &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="018b00e74a0acae9e7da52a47b45a777f33a4762" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reduxjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">저수준 API입니다. 대부분 직접 사용하는 대신 React (또는 기타) 바인딩을 사용합니다. 일반적으로 콜백을 후크로 사용하여 상태 변경에 대응 &lt;a href=&quot;https://github.com/reduxjs/redux/issues/303#issuecomment-125184409&quot;&gt;하는 경우 사용자 정의 &lt;code&gt;observeStore&lt;/code&gt; 유틸리티&lt;/a&gt; 를 작성하는 것이 좋습니다 . &lt;code&gt;Store&lt;/code&gt; 또한이다 &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 당신이 할 수 있도록 &lt;code&gt;subscribe&lt;/code&gt; 등의 라이브러리와 변화에 &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="translated">동일한 단계에 따라 역순으로 Redux에서 이러한 라이브러리로 마이그레이션 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="translated">단일 최상위 기록을 유지할지 여부는 우리에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="translated">고급 API입니다. 앱이 코드 분할을 구현하고 일부 리듀서를 동적으로로드하려는 경우에 필요할 수 있습니다. Redux에 대한 핫 리로드 메커니즘을 구현하는 경우에도 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="translated">액션을 디스패치하는 장소에 액션 객체를 인라인으로 만드는 대신,이를 생성하는 함수를 만드는 것이 일반적인 관례입니다.</target>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">상점 리듀서가 리턴 한 마지막 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="translated">미들웨어를 연결하는 데 필수적입니다!</target>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="translated">일반 직렬화 가능 오브젝트, 배열 및 기본 요소 만 상점에 배치하는 것이 좋습니다. 그건 &lt;em&gt;기술적으로&lt;/em&gt; 가게에 직렬화 항목을 삽입 할 수 있지만, 물론 시간 여행 디버깅 방해로, 지속 및 상점의 내용을 재수 할 수있는 능력을 깰 수 있도록하고.</target>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="translated">&lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; 또는 &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt; 와 분리하는 것이 중요합니다 . 앱이 점점 복잡 해짐에 따라 하나씩 발생할 수 있지만 사용자 작업과 독립적으로 일부 데이터를 가져오고 싶을 수 있습니다 (예 : 가장 인기있는 하위 레딧을 미리 가져 오거나 오래된 데이터를 한 번에 새로 고치기 위해). 경로 변경에 대한 응답으로 가져 오기를 원할 수도 있습니다. 따라서 가져 오기를 특정 UI 이벤트에 일찍 연결하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="translated">다음 질문에 답하기 위해 주 형태가 변경되어야한다고 제안하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="translated">Redux가 전달한 &lt;code&gt;state&lt;/code&gt; 나 &lt;code&gt;action&lt;/code&gt; 을 수정 하려고합니다. 이러지 마!</target>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="translated">작습니다 (종속성을 포함하여 2kB).</target>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="translated">프로젝트에 대한 규칙을 선택하는 것은 당신에게 달려 있습니다. 인라인 문자열을 사용하여 시작한 다음 나중에 상수로 전환하여 나중에 단일 파일로 그룹화 할 수 있습니다. Redux는 여기에 의견이 없으므로 최선의 판단을하십시오.</target>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="translated">상태 형식을 선택하는 것은 사용자의 책임입니다. 일반 객체 또는 &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; 과 같은 것을 사용할 수 있습니다 . 확실하지 않은 경우 일반 개체로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="40839b1c8a38e69ec4218f19c9a385d95915a832" translate="yes" xml:space="preserve">
          <source>It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</source>
          <target state="translated">미들웨어 유무에 관계없이 몇 가지 옵션을 시도하고 원하는 규칙을 선택한 다음 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="b392f0ed8ea05e547e964224687831827c136e29" translate="yes" xml:space="preserve">
          <source>It is vital that these Prerequisite Concepts are &lt;strong&gt;thoroughly understood&lt;/strong&gt; before moving on to more advanced and Redux-specific techniques. A recommended reading list is available at:</source>
          <target state="translated">보다 고급적이고 Redux 관련 기술로 넘어 가기 전에 이러한 사전 개념을 &lt;strong&gt;철저히 이해&lt;/strong&gt; 하는 것이 중요합니다 . 권장 독서 목록은 다음에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5fa6252549b34d2727aeeb1fe8e3c816a3d8827" translate="yes" xml:space="preserve">
          <source>It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions.</source>
          <target state="translated">서로 다른 유형의 하위 환원 기 기능이 어떻게 보이는지와 기능이 어떻게 조화되는지에 대한 예를 보는 것이 도움이 될 수 있습니다. 큰 단일 감속기 기능을 여러 개의 작은 기능의 구성으로 리팩터링 할 수있는 방법에 대한 데모를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e02627810b718b477472f1f76a7b34ecc56b8eb7" translate="yes" xml:space="preserve">
          <source>It must never return &lt;code&gt;undefined&lt;/code&gt;. It is too easy to do this by mistake via an early &lt;code&gt;return&lt;/code&gt; statement, so &lt;code&gt;combineReducers&lt;/code&gt; throws if you do that instead of letting the error manifest itself somewhere else.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 를 반환해서는 안됩니다 . 초기 &lt;code&gt;return&lt;/code&gt; 문을 통해 실수로이 작업을 수행하는 것은 너무 쉬운 일이므로 , 오류가 발생하는 대신 다른 위치에서 오류를 발생시키는 대신 &lt;code&gt;combineReducers&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1440628c9081aad68267a2e66c7ba0b0ef6cf7d" translate="yes" xml:space="preserve">
          <source>It needs to be rewritten like this:</source>
          <target state="translated">다음과 같이 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2003fb7b90831988d1d806aec866ee85ca010393" translate="yes" xml:space="preserve">
          <source>It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done</source>
          <target state="translated">이전 상태와 전달 된 조치를보고 어떤 종류의 작업을 수행해야하는지 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5761524a50c8fdeeafeab8c5ae63d8a8423998ef" translate="yes" xml:space="preserve">
          <source>It only exposes a subset of the &lt;a href=&quot;../api/store&quot;&gt;store API&lt;/a&gt; to the middleware: &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/store&quot;&gt;상점 API&lt;/a&gt; 의 서브 세트 만 미들웨어 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="c914355546b42c63de745bfcca2aaeb3e2313f74" translate="yes" xml:space="preserve">
          <source>It seems that reducer isn't the right abstraction, but we're very close.</source>
          <target state="translated">감속기가 올바른 추상화는 아니지만, 우리는 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="beb2e2454ed95b3107fe31d45f50cecc81a6856f" translate="yes" xml:space="preserve">
          <source>It then runs a shallow equality check on its reference to the root state object and the state object passed to it, and a separate series of shallow checks on each reference to the props object&amp;rsquo;s values and those that are returned from running the &lt;code&gt;mapStateToProps&lt;/code&gt; function again.</source>
          <target state="translated">그런 다음 루트 상태 객체 및 전달 된 상태 객체에 대한 참조에서 얕은 동등성 검사를 실행하고 props 객체의 값과 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수를 다시 실행하여 반환 된 값에 대한 각 참조에 대해 별도의 일련의 얕은 검사를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="7396f0cc913742a2329483587f6bde1029a53425" translate="yes" xml:space="preserve">
          <source>It will then combine both sets of results into a single state tree:</source>
          <target state="translated">그런 다음 두 결과 집합을 단일 상태 트리로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="fe6fecbba3b0b6d0528af6e5ce21a171dd9d1cfb" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&amp;ldquo;we need to go deeper&amp;rdquo;&lt;/a&gt; kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;currying&lt;/a&gt; easier on eyes:</source>
          <target state="translated">그것은이야 &lt;a href=&quot;http://knowyourmeme.com/memes/we-need-to-go-deeper&quot;&gt;&quot;우리가 더 깊이 갈 필요가&quot;&lt;/a&gt; 이 이해하는 것이 시간이 걸릴 수 있으므로, 어떤 순간의. 캐스케이드 기능은 협박 감을 느낍니다. ES6 화살표 기능을 사용하면 눈에서 이러한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Currying&quot;&gt;커링을&lt;/a&gt; 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53bb5e1d4ed878477f0cfe96c4cca984251e5713" translate="yes" xml:space="preserve">
          <source>It's a good idea to pass as little data in each action as possible. For example, it's better to pass &lt;code&gt;index&lt;/code&gt; than the whole todo object.</source>
          <target state="translated">각 작업에서 가능한 적은 데이터를 전달하는 것이 좋습니다. 예를 들어, 전체 todo 오브젝트보다 &lt;code&gt;index&lt;/code&gt; 를 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="66564241e2f2072f8ffd6342ef4d5f057cfbf2e9" translate="yes" xml:space="preserve">
          <source>It's also important to note that some of these suggestions may or may not be directly applicable based on architectural decisions in a specific application. For example, an application using Immutable.js Maps to store data would likely have its reducer logic structured at least somewhat differently than an application using plain Javascript objects. This documentation primarily assumes use of plain Javascript objects, but many of the principles would still apply if using other tools.</source>
          <target state="translated">이러한 제안 중 일부는 특정 응용 프로그램의 아키텍처 결정에 따라 직접 적용 할 수도 있고 적용되지 않을 수도 있습니다. 예를 들어, 데이터를 저장하기 위해 Immutable.js Maps를 사용하는 응용 프로그램은 일반 Javascript 객체를 사용하는 응용 프로그램과 감속기 논리가 적어도 약간 다르게 구성되었을 것입니다. 이 문서는 주로 일반 자바 스크립트 객체를 사용한다고 가정하지만 다른 도구를 사용하는 경우에도 많은 원칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d8a4e5e3006a924b03ad0f0eb598b2f0f5eaed6" translate="yes" xml:space="preserve">
          <source>It's best not to mix this approach with standard Redux reducer composition. For typical web apps, stick with reducer composition. For &amp;ldquo;product hubs&amp;rdquo;, &amp;ldquo;dashboards&amp;rdquo;, or enterprise software that groups disparate tools into a unified package, give the sub-app approach a try.</source>
          <target state="translated">이 방법을 표준 Redux 감속기 구성과 혼합하지 않는 것이 가장 좋습니다. 일반적인 웹 앱의 경우 감속기 구성을 사용하십시오. 서로 다른 도구를 통합 된 패키지로 그룹화하는 &quot;제품 허브&quot;, &quot;대시 보드&quot;또는 엔터프라이즈 소프트웨어의 경우 하위 앱 접근 방식을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="252a3efbc077a7d5a93fd6d1dbfedaa2d2669df6" translate="yes" xml:space="preserve">
          <source>It's called a reducer because it's the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;. It's very important that the reducer stays pure. Things you should &lt;strong&gt;never&lt;/strong&gt; do inside a reducer:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt; 전달할 함수 유형이므로 감속기라고합니다 . 감속기가 순수한 상태를 유지하는 것이 매우 중요합니다. 감속기 안에서는 &lt;strong&gt;절대로&lt;/strong&gt; 하지 말아야 할 것들 :</target>
        </trans-unit>
        <trans-unit id="6a58a3a8e0f482a446b06f379efada2fd4c57438" translate="yes" xml:space="preserve">
          <source>It's easy to create a store if you have a reducer. In the &lt;a href=&quot;reducers&quot;&gt;previous section&lt;/a&gt;, we used &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; to combine several reducers into one. We will now import it, and pass it to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리듀서가 있으면 상점을 쉽게 만들 수 있습니다. 에서 &lt;a href=&quot;reducers&quot;&gt;이전 섹션&lt;/a&gt; , 우리가 사용하는 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 하나에 여러 개의 감속기를 결합 할 수 있습니다. 이제 가져 와서 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="fb4ae669548f27a4108b547b46fa2c12ac612f32" translate="yes" xml:space="preserve">
          <source>It's for this improvement in performance that Redux uses shallow equality checking.</source>
          <target state="translated">Redux가 얕은 동등성 검사를 사용하는 것은 이러한 성능 향상을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="98dcf0d417fbe43fd9477364b70c4f9d857c65e0" translate="yes" xml:space="preserve">
          <source>It's generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in &lt;code&gt;mapStateToProps&lt;/code&gt; functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</source>
          <target state="translated">일반적으로 선택기를 감속기와 함께 정의하여 내보내고 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수, 비동기 작업 작성자 또는 sagas 와 같은 다른 곳에서 재사용 하여 감속기 파일에서 상태 트리의 실제 모양에 대해 알고있는 모든 코드를 배치하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="9a8921bdd4ecd237805498907dc4327f0981b88e" translate="yes" xml:space="preserve">
          <source>It's important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</source>
          <target state="translated">Redux 스토어에는 실제로 하나의 감속기 기능 만 있습니다. 상점은 현재 상태 및 디스패치 조치를 하나의 감속기 기능으로 전달하고 감속기가 작업을 적절하게 처리 할 수 ​​있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c36768ba51d801006d900629e7ac3f3a13e90bcd" translate="yes" xml:space="preserve">
          <source>It's important to note that you'll only have a single store in a Redux application. When you want to split your data handling logic, you'll use &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt; instead of many stores.</source>
          <target state="translated">Redux 응용 프로그램에는 단일 저장소 만 있다는 점에 유의해야합니다. 데이터 처리 논리를 분할하려는 경우 많은 상점 대신 &lt;a href=&quot;reducers#splitting-reducers&quot;&gt;축소 기 구성을&lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="61d4dad8daf83a3b27a53b849070082ed3ffa990" translate="yes" xml:space="preserve">
          <source>It's important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have &lt;code&gt;state.a.b.c.d&lt;/code&gt;, and you want to make an update to &lt;code&gt;d&lt;/code&gt;, you would also need to return new copies of &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;state&lt;/code&gt;. This &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;state tree mutation diagram&lt;/a&gt; demonstrates how a change deep in a tree requires changes all the way up.</source>
          <target state="translated">중첩 된 값을 업데이트 할 때마다 상태 트리에서 그 위에있는 것의 새 복사본도 반환해야합니다. 당신이있는 경우 &lt;code&gt;state.a.b.c.d&lt;/code&gt; , 그리고 당신에 대한 업데이트 만들고 싶어 &lt;code&gt;d&lt;/code&gt; , 당신은 또한 새로운 사본을 반환해야합니다 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , 및 &lt;code&gt;state&lt;/code&gt; . 이 &lt;a href=&quot;http://arqex.com/wp-content/uploads/2015/02/trees.png&quot;&gt;상태 트리 변이 다이어그램&lt;/a&gt; 은 나무의 깊은 곳에서 변화가 일어나려면 어떻게해야하는지 보여줍니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339b6732e0d2b2a42a0ddd93251b26fe3ad96b4" translate="yes" xml:space="preserve">
          <source>It's more code, but it's exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt;&lt;code&gt;React.addons.update&lt;/code&gt;&lt;/a&gt; to write immutable transformations with a terse syntax:</source>
          <target state="translated">더 많은 코드이지만 Redux를 예측 가능하고 효율적으로 만드는 것입니다. 코드를 &lt;a href=&quot;https://facebook.github.io/react/docs/update.html&quot;&gt; &lt;code&gt;React.addons.update&lt;/code&gt; &lt;/a&gt; 와 같은 도우미를 사용 하여 간결한 구문으로 불변의 변환을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f3ca2b8ee117276e54d75838be64e770429f6ba" translate="yes" xml:space="preserve">
          <source>It's not always immediately clear how these two approaches interact. Fortunately, the process does follow some predictable rules. Here's how the pieces fit together.</source>
          <target state="translated">이 두 접근 방식이 어떻게 상호 작용하는지 항상 명확하지는 않습니다. 다행히도이 프로세스는 예측 가능한 규칙을 따릅니다. 다음은 조각들이 서로 맞는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d0ab78e0353e7cd035a999d2fa8e5af4c2f963ef" translate="yes" xml:space="preserve">
          <source>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</source>
          <target state="translated">조치를 올바르게 전달하고 감속기를 적용하는 것이 가능하지만 해당 상태가 소품으로 올바르게 변환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4543176cfbe02cd87a4507bdb08d9c22f1859120" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose Flux framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can solve this with a single function, as we show below.</source>
          <target state="translated">불행히도 많은 사람들 이 설명서에서 &lt;code&gt;switch&lt;/code&gt; 문을 사용하는지 여부에 따라 여전히 Flux 프레임 워크를 선택 합니다. &lt;code&gt;switch&lt;/code&gt; 가 마음에 들지 않으면 아래에 표시된 것처럼 단일 기능 으로이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e539fa93863f712b20c2f16d75b4287d6434876" translate="yes" xml:space="preserve">
          <source>It's unfortunate that many still choose a framework based on whether it uses &lt;code&gt;switch&lt;/code&gt; statements in the documentation. If you don't like &lt;code&gt;switch&lt;/code&gt;, you can use a custom &lt;code&gt;createReducer&lt;/code&gt; function that accepts a handler map, as shown in &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;reducing boilerplate&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">불행히도 많은 사람들이 여전히 설명서에서 &lt;code&gt;switch&lt;/code&gt; 문을 사용하는지 여부에 따라 프레임 워크를 선택합니다 . &lt;code&gt;switch&lt;/code&gt; 가 마음에 들지 않으면 &lt;a href=&quot;../recipes/reducingboilerplate#reducers&quot;&gt;&amp;ldquo;boilerplate 감소&amp;rdquo;에&lt;/a&gt; 표시된대로 핸들러 맵을 허용하는 사용자 정의 &lt;code&gt;createReducer&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bb2765277319f208309e2db82a727dcbfdec808" translate="yes" xml:space="preserve">
          <source>JavaScript Application Architecture On The Road To 2015</source>
          <target state="translated">2015 년에도 JavaScript 애플리케이션 아키텍처</target>
        </trans-unit>
        <trans-unit id="5663d16ece82a891feaade5f2800177cdbd06bf0" translate="yes" xml:space="preserve">
          <source>JavaScript Immutability presentation (PDF - see slide 12 for benefits)</source>
          <target state="translated">JavaScript 불변성 프레젠테이션 (PDF-혜택은 슬라이드 12 참조)</target>
        </trans-unit>
        <trans-unit id="5686c8f6acca3473e05ae8e791a2b0127eaac9e5" translate="yes" xml:space="preserve">
          <source>JavaScript and Immutability</source>
          <target state="translated">자바 스크립트와 불변성</target>
        </trans-unit>
        <trans-unit id="48e85cf4e700b35b1170cf47611de9569a23efdc" translate="yes" xml:space="preserve">
          <source>JavaScript does not provide immutable data structures. As such, for Immutable.JS to provide its immutable guarantees, your data must be encapsulated within an Immutable.JS object (such as a &lt;code&gt;Map&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;, etc.). Once it&amp;rsquo;s contained in this way, it&amp;rsquo;s hard for that data to then interoperate with other, plain JavaScript objects.</source>
          <target state="translated">JavaScript는 변경 불가능한 데이터 구조를 제공하지 않습니다. 따라서 Immutable.JS가 변경 불가능한 보증을 제공하려면 데이터가 Immutable.JS 오브젝트 (예 : &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 등) 내에 캡슐화되어야합니다 . 이러한 방식으로 포함 된 데이터는 다른 일반 JavaScript 객체와 상호 운용하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="db1e7af6d4d988f37e8c96dfd9be6dd7f8c52667" translate="yes" xml:space="preserve">
          <source>JavaScript was never designed to provide guaranteed immutable operations. Accordingly, there are several issues you need to be aware of if you choose to use it for your immutable operations in your Redux app.</source>
          <target state="translated">JavaScript는 보장 된 불변 작업을 제공하도록 설계되지 않았습니다. 따라서 Redux 앱에서 변경 불가능한 작업에 사용하기로 선택한 경우 알아야 할 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f9a7a1a37cb18678bb27808982a0fab518f2bf" translate="yes" xml:space="preserve">
          <source>Javascript and Immutability</source>
          <target state="translated">자바 스크립트와 불변성</target>
        </trans-unit>
        <trans-unit id="8190845a1ebdd8d76968f6c6f761a6be3b93edae" translate="yes" xml:space="preserve">
          <source>Jing Chen, creator of Flux</source>
          <target state="translated">플럭스 제작자 Jing Chen</target>
        </trans-unit>
        <trans-unit id="951a42e3bc90a6103cf2aad8fcbde2477e07ad4f" translate="yes" xml:space="preserve">
          <source>Join the &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; channel of the &lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord community.</source>
          <target state="translated">&lt;a href=&quot;http://www.reactiflux.com&quot;&gt;Reactiflux&lt;/a&gt; Discord 커뮤니티 의 &lt;a href=&quot;https://discord.gg/0ZcbPKXt5bZ6au5t&quot;&gt;#redux&lt;/a&gt; 채널에 가입하십시오 .</target>
        </trans-unit>
        <trans-unit id="e399f1c349f8769ebbb0daf23b23eccbf46daf27" translate="yes" xml:space="preserve">
          <source>Just like before, we never write directly to &lt;code&gt;state&lt;/code&gt; or its fields, and instead we return new objects. The new &lt;code&gt;todos&lt;/code&gt; is equal to the old &lt;code&gt;todos&lt;/code&gt; concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</source>
          <target state="translated">이전과 마찬가지로 &lt;code&gt;state&lt;/code&gt; 나 필드에 직접 쓰지 않고 대신 새 객체를 반환합니다. 새 &lt;code&gt;todos&lt;/code&gt; 은 끝에있는 하나의 새 항목과 연결된 이전 &lt;code&gt;todos&lt;/code&gt; 과 같습니다 . 새로운 할일은 액션의 데이터를 사용하여 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="4775133d954dab5abc63710e9c6e38a2239ee177" translate="yes" xml:space="preserve">
          <source>Just like in the basic tutorial, you'll need to &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;design the shape of your application's state&lt;/a&gt; before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</source>
          <target state="translated">기본 자습서에서와 같이 구현으로 돌입하기 전에 &lt;a href=&quot;../basics/reducers#designing-the-state-shape&quot;&gt;응용 프로그램 상태의 모양&lt;/a&gt; 을 디자인 해야합니다 . 비동기 코드를 사용하면 처리해야 할 상태가 더 많아 지므로이를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6df178ca4d41674a93e54d6ff850afe3eceb958" translate="yes" xml:space="preserve">
          <source>Laurence Roberts</source>
          <target state="translated">로렌스 로버츠</target>
        </trans-unit>
        <trans-unit id="a8e78fb63e60ac2949bd5cbbb13dfecd20351939" translate="yes" xml:space="preserve">
          <source>Learn Redux from Its Creator</source>
          <target state="translated">창조주로부터 Redux 배우기</target>
        </trans-unit>
        <trans-unit id="815813ef04db0611309243e056689002bfca2f51" translate="yes" xml:space="preserve">
          <source>Learning Functional Programming in Javascript</source>
          <target state="translated">자바 스크립트로 기능 프로그래밍 학습</target>
        </trans-unit>
        <trans-unit id="204c47c7f7b6077c5cc66fb4275cccc654adf5ff" translate="yes" xml:space="preserve">
          <source>Learning Redux</source>
          <target state="translated">학습 Redux</target>
        </trans-unit>
        <trans-unit id="f18ace0f4dc5ebb1cb3f958d948cec6b1bfd54fc" translate="yes" xml:space="preserve">
          <source>Lee Byron on Twitter: &amp;ldquo;Perf tip for #immutablejs&amp;hellip;&amp;rdquo;</source>
          <target state="translated">Lee Byron의 Twitter :&amp;ldquo;#immutablejs를위한 성능 팁&amp;hellip;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0d516f563abbe7f29a4e3ee915a4a5746abb4a29" translate="yes" xml:space="preserve">
          <source>Let's consider a different scenario:</source>
          <target state="translated">다른 시나리오를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="30e9663293d38e3d33c344fc2983eb83f3e158b6" translate="yes" xml:space="preserve">
          <source>Let's create a function named &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; that returns a new copy of the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector each time it is called:</source>
          <target state="translated">&lt;code&gt;getVisibleTodos&lt;/code&gt; 셀렉터가 호출 될 때마다 새 getVisibleTodos 선택기 사본을 리턴하는 &lt;code&gt;makeGetVisibleTodos&lt;/code&gt; 라는 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd130845bbec5d16d12cb399e0c3cbfeb2c430a7" translate="yes" xml:space="preserve">
          <source>Let's define a memoized selector named &lt;code&gt;getVisibleTodos&lt;/code&gt; to replace the non-memoized version above:</source>
          <target state="translated">위의 메모리 화되지 않은 버전을 대체하기 위해 &lt;code&gt;getVisibleTodos&lt;/code&gt; 라는 메모리 화 된 선택기를 정의 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a4dc14b145305dfe293196d07e8aa73560d7a5" translate="yes" xml:space="preserve">
          <source>Let's explore reducer composition more. Can we also extract a reducer managing just &lt;code&gt;visibilityFilter&lt;/code&gt;? We can.</source>
          <target state="translated">감속기 구성에 대해 더 자세히 살펴 보겠습니다. &lt;code&gt;visibilityFilter&lt;/code&gt; 필터 만 관리하는 감속기를 추출 할 수 있습니까 ? 우리는 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d63428074244e2479b8e425262f560268ac5f43" translate="yes" xml:space="preserve">
          <source>Let's recall what the combined reducer does:</source>
          <target state="translated">결합 감속기의 기능을 상기 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="384774d8dbe43962eb49ce001e2d96e26d96ea07" translate="yes" xml:space="preserve">
          <source>Let's revisit the &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../basics/usagewithreact&quot;&gt;Todos List 예제를&lt;/a&gt; 다시 보자 .</target>
        </trans-unit>
        <trans-unit id="ed19a0e0fde116aef33b7018b7a9bbcce6346bdc" translate="yes" xml:space="preserve">
          <source>Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; middleware and adding an early exit:</source>
          <target state="translated">프로토 타입을 검토 한 후 디자이너가 우리에게 다시 와서 최대 3 개의 할 일을 허용해야한다고 가정 해 봅시다. &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; 미들웨어 가 포함 된 콜백 양식에 조치 작성자를 다시 작성하고 초기 종료를 추가 하여이를 시행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d23a5d0451ec5d5abafa771961468240b19ed964" translate="yes" xml:space="preserve">
          <source>Let's say that our initial reducer looks like this:</source>
          <target state="translated">초기 감속기가 다음과 같다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a42244fb104feca9e7eb72186a85fa8a258a8b6f" translate="yes" xml:space="preserve">
          <source>Let's start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</source>
          <target state="translated">예제 앱에서 필요한 몇 가지 동기 동작 유형과 동작 생성자를 정의하여 시작하겠습니다. 여기서 사용자는 표시 할 하위 레딧을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be34e2837216ea61f99fc5d5668808369bc5adc" translate="yes" xml:space="preserve">
          <source>Let's take a look at our new client file:</source>
          <target state="translated">새 클라이언트 파일을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b409b71e81ab2b58978b981a343bc5bce51dcd92" translate="yes" xml:space="preserve">
          <source>Let's talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt;. In our reducer, we will do the following steps to handle these actions:</source>
          <target state="translated">알고리즘을 통해 위에서 설명한 상태 형태를 조작 해 봅시다. 이 상태에서 작동하기 위해 &lt;code&gt;UNDO&lt;/code&gt; 및 &lt;code&gt;REDO&lt;/code&gt; 의 두 가지 조치를 정의 할 수 있습니다 . 감속기에서 이러한 단계를 처리하기 위해 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dd3902ab0d1d59de82883d31a36cdd78b461122c" translate="yes" xml:space="preserve">
          <source>Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our &lt;code&gt;todos&lt;/code&gt; reducers to be defined like this:</source>
          <target state="translated">액션 타입에서 핸들러로 객체 매핑으로 리듀서를 표현할 수있는 함수를 작성해 봅시다. 예를 들어, &lt;code&gt;todos&lt;/code&gt; 감속기를 다음과 같이 정의하려면 :</target>
        </trans-unit>
        <trans-unit id="e72eaffd3ac1dcb5208c2d6ea7b42f2173627e6a" translate="yes" xml:space="preserve">
          <source>Let's write the components! We begin with the presentational components so we don't need to think about binding to Redux yet.</source>
          <target state="translated">컴포넌트를 작성하자! 프리젠 테이션 컴포넌트부터 시작하여 아직 Redux에 바인딩하는 것에 대해 생각할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4642d8e2bbb9a67ffddd44f6258e15948144b9a5" translate="yes" xml:space="preserve">
          <source>Leveling Up with React: Redux</source>
          <target state="translated">React로 레벨 업 : Redux</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef7dd92b3bad02dfcc7661e876c8b68c18ebfc35" translate="yes" xml:space="preserve">
          <source>Limit your use of &lt;code&gt;toJS()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; 사용 제한</target>
        </trans-unit>
        <trans-unit id="83fce8327410848c9eb609acb21732c7c0fec96a" translate="yes" xml:space="preserve">
          <source>Logo</source>
          <target state="translated">Logo</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="17367293ad2021231bf611dd0dd27a355d38e2d6" translate="yes" xml:space="preserve">
          <source>Make sure mapStateToProps is correct</source>
          <target state="translated">mapStateToProps가 올바른지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="9f370227bbf65772938b3d8e358e2ce2218a1a54" translate="yes" xml:space="preserve">
          <source>Make sure that you use &lt;code&gt;Object.assign&lt;/code&gt; correctly. For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; 을 올바르게 사용하십시오 . 예를 들어 감속기에서 &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; 와 같은 것을 반환하는 대신 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; 반환하십시오 . 이렇게하면 이전 &lt;code&gt;state&lt;/code&gt; 재정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5d8418eedd0d6a2db483537e4446820ce1952555" translate="yes" xml:space="preserve">
          <source>Make your entire Redux state tree an Immutable.JS object</source>
          <target state="translated">전체 Redux 상태 트리를 Immutable.JS 객체로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="91529d50836c68b2f85612f8480c39828f101131" translate="yes" xml:space="preserve">
          <source>Managing Normalized Data</source>
          <target state="translated">정규화 된 데이터 관리</target>
        </trans-unit>
        <trans-unit id="b8cfd188b6fb6ef58e95265e7bee55786bad588a" translate="yes" xml:space="preserve">
          <source>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have &lt;strong&gt;lost control over the when, why, and how of its state.&lt;/strong&gt; When a system is opaque and non-deterministic, it's hard to reproduce bugs or add new features.</source>
          <target state="translated">끊임없이 변화하는이 상태를 관리하는 것은 어렵습니다. 모델이 다른 모델을 업데이트 할 수있는 경우 뷰는 모델을 업데이트하여 다른 모델을 업데이트하면 다른 뷰가 업데이트 될 수 있습니다. 어떤 시점에서 더 이상 &lt;strong&gt;언제, 왜, 어떻게 상태에 대한 제어권을 잃어&lt;/strong&gt; 앱에서 어떤 일이 발생하는지 이해하지 못합니다 &lt;strong&gt;. &lt;/strong&gt;시스템이 불투명하고 결정적이지 않은 경우 버그를 재현하거나 새로운 기능을 추가하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="770e69d1c946703f5c3589b40d2b5d1f60424fb5" translate="yes" xml:space="preserve">
          <source>Many applications deal with data that is nested or relational in nature. For example, a blog editor could have many Posts, each Post could have many Comments, and both Posts and Comments would be written by a User. Data for this kind of application might look like:</source>
          <target state="translated">많은 응용 프로그램은 본질적으로 중첩되거나 관계형 인 데이터를 처리합니다. 예를 들어 블로그 편집기에는 많은 게시물이 있고 각 게시물에는 많은 댓글이있을 수 있으며 게시물과 댓글은 모두 사용자가 작성합니다. 이러한 종류의 응용 프로그램에 대한 데이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d062b20c46aa58461072521c5ff06fd5c22eadb2" translate="yes" xml:space="preserve">
          <source>Many users later want to try to share data between two reducers, but find that &lt;code&gt;combineReducers&lt;/code&gt; does not allow them to do so. There are several approaches that can be used:</source>
          <target state="translated">많은 사용자들이 나중에 두 리듀서 사이에서 데이터를 공유하려고하지만 &lt;code&gt;combineReducers&lt;/code&gt; 는 그렇게 할 수 없다는 것을 알게 됩니다. 사용할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7bcd6c888e6b88d0545bc697de285055397b49" translate="yes" xml:space="preserve">
          <source>Maybe we want to be able to run multiple instances of it in the same &amp;ldquo;bigger&amp;rdquo; app and keep it as a complete black box, with Redux being an implementation detail.</source>
          <target state="translated">어쩌면 우리는 동일한 &quot;더 큰&quot;앱에서 여러 인스턴스를 실행하고이를 완전한 블랙 박스로 유지하고 싶을 것입니다. Redux는 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="99890f553cee2767e33647e04645b77191093369" translate="yes" xml:space="preserve">
          <source>Meet Reducer Enhancers</source>
          <target state="translated">감속기 강화 기 만나기</target>
        </trans-unit>
        <trans-unit id="1335c9d05ff6249a581b2af47d8ca262af71f878" translate="yes" xml:space="preserve">
          <source>Meet some of the outstanding companies that made it possible:</source>
          <target state="translated">이를 가능하게 한 뛰어난 회사를 만나보십시오.</target>
        </trans-unit>
        <trans-unit id="eb8978ed84b5906ad4191a0b252828be64701bfa" translate="yes" xml:space="preserve">
          <source>Middleware</source>
          <target state="translated">Middleware</target>
        </trans-unit>
        <trans-unit id="4de8569a40d6be412d5f73fc6d679fbd847a1bc7" translate="yes" xml:space="preserve">
          <source>Middleware functions wrap behavior of &lt;code&gt;dispatch&lt;/code&gt; calls in Redux, so to test this modified behavior we need to mock the behavior of the &lt;code&gt;dispatch&lt;/code&gt; call.</source>
          <target state="translated">미들웨어 함수 는 Redux에서 &lt;code&gt;dispatch&lt;/code&gt; 호출의 동작을 래핑 하므로이 수정 된 동작을 테스트하려면 &lt;code&gt;dispatch&lt;/code&gt; 호출 의 동작을 조롱해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4cfdea7cdd9cbecf25a5a88942621957d5c3dd05" translate="yes" xml:space="preserve">
          <source>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</source>
          <target state="translated">미들웨어는 기능 구성을 사용하여 구성 할 수 있습니다. 작업 로깅, 라우팅과 같은 부작용 수행 또는 비동기 API 호출을 일련의 동기 작업으로 전환하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b3958295af5cb6ac63c96e1bbd5629db43b83e95" translate="yes" xml:space="preserve">
          <source>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; to use it. You may also create your own middleware.</source>
          <target state="translated">미들웨어는 커뮤니티에서 작성하며 기본적으로 Redux와 함께 제공되지 않습니다. &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; 와 같은 패키지를 명시 적으로 설치 하여 사용해야합니다. 자신 만의 미들웨어를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="709ac9c564fa8004f1018815a013faace4ceaf9b" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="translated">미들웨어는 &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; 에&lt;/a&gt; 구워 지지 않았으며 Redux 아키텍처의 기본 부분은 아니지만 핵심에서 바로 지원 될 수있을 정도로 유용하다고 생각합니다. 이런 식으로 생태계에서 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 을 확장하는 단일 표준 방법이 있으며 다른 미들웨어가 표현력과 유틸리티에서 경쟁 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44bb138a9d25525c5ea6b439a580ee67fd5a1ee9" translate="yes" xml:space="preserve">
          <source>Middleware is not baked into &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; in the ecosystem, and different middleware may compete in expressiveness and utility.</source>
          <target state="translated">미들웨어는 &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; 에&lt;/a&gt; 구워 지지 않고 Redux 아키텍처의 기본 부분이 아니지만 코어에서 바로 지원할 수있을만큼 유용하다고 생각합니다. 이런 식으로 생태계에서 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 를 확장하는 단일 표준 방법이 있으며 다양한 미들웨어가 표현력과 유용성에서 경쟁 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c8a7e2c0f9e6b20fe14442f77d182a03eebb64" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="translated">미들웨어는 Redux를 사용자 정의 기능으로 확장하기 위해 제안 된 방법입니다. 미들웨어를 사용하면 상점의 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 방법을 재미와 이익을 위해 랩핑 할 수 있습니다 . 미들웨어의 주요 기능은 컴포저 블이 가능하다는 것입니다. 여러 미들웨어를 함께 결합 할 수 있으며, 각 미들웨어는 체인에서 전후에 무엇이 있는지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="39238a8d7919adb7f2defae4e78aa73bb9a0fc2f" translate="yes" xml:space="preserve">
          <source>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</source>
          <target state="translated">미들웨어는 사용자 정의 기능으로 Redux를 확장하기 위해 제안 된 방법입니다. 미들웨어를 사용하면 상점의 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 방법을 재미와 이익을 위해 포장 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 미들웨어의 핵심 기능은 구성이 가능하다는 것입니다. 여러 미들웨어를 함께 결합 할 수 있으며, 여기서 각 미들웨어는 체인에서 앞뒤로 오는 것에 대한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9772321b9da9e355cae92c8995bc9b6d9b873c30" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="translated">미들웨어는 상점의 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능 만 랩핑합니다 . 기술적으로 미들웨어가 수행 할 수있는 모든 작업은 모든 &lt;code&gt;dispatch&lt;/code&gt; 호출 을 랩핑하여 수동으로 수행 할 수 있지만 한 곳에서이를 관리하고 전체 프로젝트의 규모로 조치 변환을 정의하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="da1c87b8d7e2336732bb5e2c32e20b95e5a52fd5" translate="yes" xml:space="preserve">
          <source>Middleware only wraps the store's &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function. Technically, anything a middleware can do, you can do manually by wrapping every &lt;code&gt;dispatch&lt;/code&gt; call, but it's easier to manage this in a single place and define action transformations on the scale of the whole project.</source>
          <target state="translated">미들웨어는 상점의 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능 만 래핑합니다 . 기술적으로 미들웨어가 수행 할 수있는 모든 작업은 모든 &lt;code&gt;dispatch&lt;/code&gt; 호출 을 래핑하여 수동으로 수행 할 수 있지만 한 곳에서이를 관리하고 전체 프로젝트 규모에 따라 작업 변환을 정의하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="904b42b851f9aa103d834460d3e42948c262c785" translate="yes" xml:space="preserve">
          <source>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you'll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</source>
          <target state="translated">미들웨어는 실제보다 훨씬 더 복잡하게 들립니다. 미들웨어를 실제로 이해하는 유일한 방법은 기존 미들웨어의 작동 방식을보고 직접 작성하는 것입니다. 함수 중첩은 위협적 일 수 있지만 실제로 발견되는 대부분의 미들웨어는 10 개의 라이너이며, 중첩 및 구성 가능성은 미들웨어 시스템을 강력하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9302feee19404010fcac9af350604fe588e01046" translate="yes" xml:space="preserve">
          <source>Migrating to Redux</source>
          <target state="translated">Redux로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="7cc7d31118fe440474864da8b1d74f693cb0f866" translate="yes" xml:space="preserve">
          <source>Modular Reducers and Selectors</source>
          <target state="translated">모듈 형 감속기 및 선택기</target>
        </trans-unit>
        <trans-unit id="4e7b0b1e9c0a61f16b9a2611a1aa537d440279de" translate="yes" xml:space="preserve">
          <source>Monkeypatching is a hack. &amp;ldquo;Replace any method you like&amp;rdquo;, what kind of API is that? Let's figure out the essence of it instead. Previously, our functions replaced &lt;code&gt;store.dispatch&lt;/code&gt;. What if they &lt;em&gt;returned&lt;/em&gt; the new &lt;code&gt;dispatch&lt;/code&gt; function instead?</source>
          <target state="translated">Monkeypatching은 해킹입니다. &amp;ldquo;원하는 방법을 교체하십시오.&amp;rdquo;어떤 종류의 API입니까? 대신 그 본질을 알아 봅시다. 이전에는 함수가 &lt;code&gt;store.dispatch&lt;/code&gt; 를 대체 했습니다 . 그들이 경우 &lt;em&gt;반환&lt;/em&gt; 새로운 &lt;code&gt;dispatch&lt;/code&gt; 하는 대신 기능을?</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="fbb1457de42e260b67aaf3c234080db729e6567f" translate="yes" xml:space="preserve">
          <source>Most applications deal with multiple types of data, which can be broadly divided into three categories:</source>
          <target state="translated">대부분의 응용 프로그램은 여러 유형의 데이터를 처리하며 크게 세 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d03ee4b54b44641100dd50cccd338fa1f41b27" translate="yes" xml:space="preserve">
          <source>Most commonly people consume Redux as a collection of &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; modules. These modules are what you get when you import &lt;code&gt;redux&lt;/code&gt; in a &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;, or a Node environment. If you like to live on the edge and use &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup&lt;/a&gt;, we support that as well.</source>
          <target state="translated">대부분의 사람들은 &lt;a href=&quot;http://webpack.github.io/docs/commonjs.html&quot;&gt;CommonJS&lt;/a&gt; 모듈 모음으로 Redux를 사용 합니다. 이러한 모듈은 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 또는 Node 환경 에서 &lt;code&gt;redux&lt;/code&gt; 를 가져올 때 얻을 수 있는 것입니다. 가장자리에 살고 &lt;a href=&quot;http://rollupjs.org&quot;&gt;Rollup을&lt;/a&gt; 사용하고 싶다면 우리도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09f0cc4aec4d47d93c4e8a96edd682217c9476ac" translate="yes" xml:space="preserve">
          <source>Most likely you'll never write a store enhancer, but you may use the one provided by the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;developer tools&lt;/a&gt;. It is what makes time travel possible without the app being aware it is happening. Amusingly, the &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux middleware implementation&lt;/a&gt; is itself a store enhancer.</source>
          <target state="translated">상점 확장기를 작성하지는 않지만 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;개발자 도구에서&lt;/a&gt; 제공하는 기능을 사용할 수 있습니다 . 앱이 발생하고 있음을 인식하지 않고도 시간 여행을 가능하게합니다. 흥미롭게도 &lt;a href=&quot;api/applymiddleware&quot;&gt;Redux 미들웨어 구현&lt;/a&gt; 은 그 자체로 점포 향상제입니다.</target>
        </trans-unit>
        <trans-unit id="390f7c239e26365aa378c0e0495e19cfea627097" translate="yes" xml:space="preserve">
          <source>Most likely, you'll also need &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;the React bindings&lt;/a&gt; and &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;.</source>
          <target state="translated">아마도 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React 바인딩&lt;/a&gt; 과 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;개발자 도구&lt;/a&gt; 가 필요할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7e3a3d184b0b6d4dfa96e5964033c932e00274c5" translate="yes" xml:space="preserve">
          <source>Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store. This and the design brief below do not imply container components must be near the top of the component tree. If a container component becomes too complex (i.e. it has heavily nested presentional components with countless callbacks being passed down), introduce another container within the component tree as noted in the &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ&lt;/a&gt;.</source>
          <target state="translated">우리가 작성할 대부분의 컴포넌트는 프레젠테이션 용이지만 Redux 스토어에 연결하려면 컨테이너 컴포넌트를 몇 개 생성해야합니다. 아래의 디자인 요약은 컨테이너 구성 요소가 구성 요소 트리의 상단 근처에 있어야 함을 의미하지 않습니다. 컨테이너 구성 요소가 너무 복잡해지면 (즉, 셀 수없이 많은 콜백이 전달되는 프리젠 테이션 구성 요소가 많이 중첩 된 경우) &lt;a href=&quot;../faq/reactredux#react-multiple-components&quot;&gt;FAQ에 설명 된&lt;/a&gt; 대로 구성 요소 트리 내에 다른 컨테이너를 도입하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fd704d00a4e5a0c3b40b38e9218c4cbbf210bcc" translate="yes" xml:space="preserve">
          <source>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don't complement each other.</source>
          <target state="translated">Baobab이 제공하는 대부분의 기능은 커서로 데이터를 업데이트하는 것과 관련이 있지만 Redux는 데이터를 업데이트하는 유일한 방법은 작업을 전달하는 것입니다. 따라서 동일한 문제를 다르게 해결하며 서로 보완하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="723bf632acd68a56f2a8abd2cb40c71cceac0c0d" translate="yes" xml:space="preserve">
          <source>Motivation for Memoized Selectors</source>
          <target state="translated">기억 된 선택자를위한 동기 부여</target>
        </trans-unit>
        <trans-unit id="552b006eca5b663e553068321aa1dddaf3b1befb" translate="yes" xml:space="preserve">
          <source>Mozilla's experimental browser testbed</source>
          <target state="translated">모질라 실험 브라우저 테스트 베드</target>
        </trans-unit>
        <trans-unit id="d88a4a071f039297bbb69db92ff026e19cea735d" translate="yes" xml:space="preserve">
          <source>Mutability vs immutability</source>
          <target state="translated">돌연변이 성 대 불변성</target>
        </trans-unit>
        <trans-unit id="efd8a68660022a43293fd5a672afacaf4b2ee1a5" translate="yes" xml:space="preserve">
          <source>Mutate its arguments;</source>
          <target state="translated">그 주장을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="654f242c8a1a04fd78d46a2eed456576101047e8" translate="yes" xml:space="preserve">
          <source>Mutation is discouraged because it generally breaks time-travel debugging, and React Redux's &lt;code&gt;connect&lt;/code&gt; function:</source>
          <target state="translated">돌연변이는 일반적으로 시간 이동 디버깅과 React Redux의 &lt;code&gt;connect&lt;/code&gt; 기능을 중단하기 때문에 권장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="14131d656db4b7bdd8f8e3f363d86fcd460046b5" translate="yes" xml:space="preserve">
          <source>My journey towards a maintainable project structure for React/Redux</source>
          <target state="translated">React / Redux의 유지 관리 가능한 프로젝트 구조를 향한 여정</target>
        </trans-unit>
        <trans-unit id="7b24ea7fdf4c6ff696c569545bd59b1ddc1a2075" translate="yes" xml:space="preserve">
          <source>Navigating with React Router</source>
          <target state="translated">React Router로 탐색</target>
        </trans-unit>
        <trans-unit id="ffb832014d4614f14ecdf3023143c63e959c339a" translate="yes" xml:space="preserve">
          <source>Nested data means that the corresponding reducer logic has to be more nested or more complex. In particular, trying to update a deeply nested field can become very ugly very fast.</source>
          <target state="translated">중첩 된 데이터는 해당 감속기 논리가 더 중첩되거나 더 복잡해야 함을 의미합니다. 특히 깊게 중첩 된 필드를 업데이트하려고하면 매우 못 생기게됩니다.</target>
        </trans-unit>
        <trans-unit id="80a420ddf85790605c162653ce53a583b0952bbf" translate="yes" xml:space="preserve">
          <source>Never let a plain JavaScript object contain Immutable.JS properties. Equally, never let an Immutable.JS object contain a plain JavaScript object.</source>
          <target state="translated">일반 JavaScript 객체에 Immutable.JS 속성이 포함되지 않도록하십시오. 마찬가지로 Immutable.JS 객체에 일반 JavaScript 객체를 포함시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a430ed54fb612f337f2ab8273ec4cbf9b6644bd7" translate="yes" xml:space="preserve">
          <source>Never mix plain JavaScript objects with Immutable.JS</source>
          <target state="translated">일반 JavaScript 객체를 Immutable.JS와 혼합하지 마십시오</target>
        </trans-unit>
        <trans-unit id="5a34cbfaae2d3943f4277799da4593a9d4e8866b" translate="yes" xml:space="preserve">
          <source>Never mutate reducer arguments</source>
          <target state="translated">감속기 인수를 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="d5c80dd926f59c776bb8a92ea2761368f2163c20" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">사용하지 마십시오 &lt;code&gt;toJS()&lt;/code&gt; 에서 &lt;code&gt;mapStateToProps&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="880eef8459e455b9917669c0f642e566841426d2" translate="yes" xml:space="preserve">
          <source>Never use Immutable.JS in your Dumb Components</source>
          <target state="translated">Dumb 구성 요소에 Immutable.JS를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="0264cc83b356bb6ea59a462a975e062d839151d9" translate="yes" xml:space="preserve">
          <source>Next, we can split each specific case into its own function:</source>
          <target state="translated">다음으로, 각 특정 사례를 자체 기능으로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841e4eea113da2949d5aa791e51d64a552200a40" translate="yes" xml:space="preserve">
          <source>Next, we'll explore how to &lt;a href=&quot;store&quot;&gt;create a Redux store&lt;/a&gt; that holds the state and takes care of calling your reducer when you dispatch an action.</source>
          <target state="translated">다음으로 상태를 유지하고 액션을 전달할 때 리듀서를 호출 &lt;a href=&quot;store&quot;&gt;하는 Redux 스토어&lt;/a&gt; 를 생성하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="00e1f82b828451acc6eb547238db43005cf32c21" translate="yes" xml:space="preserve">
          <source>No Destructuring or Spread Operators</source>
          <target state="translated">비파괴 또는 확산 연산자 없음</target>
        </trans-unit>
        <trans-unit id="45a97bbdd6d1c0b59be783757a1880b3f98ba017" translate="yes" xml:space="preserve">
          <source>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern &amp;ldquo;reducer composition&amp;rdquo;. A given action could be handled by all, some, or none of them. This keeps components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the &amp;ldquo;ducks&amp;rdquo; file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</source>
          <target state="translated">아니요. 특정 상태 조각의 업데이트를 담당하는 독립적 인 소형 감속기 함수를 작성하는 것이 좋습니다. 우리는이 패턴을&amp;ldquo;감소 기 구성&amp;rdquo;이라고 부릅니다. 주어진 행동은 전부 또는 일부에 의해 처리 될 수 있습니다. 하나의 작업이 상태 트리의 다른 부분에 영향을 미칠 수 있으므로 구성 요소가이를 알 필요가 없기 때문에 구성 요소가 실제 데이터 변경 사항과 분리됩니다. 일부 사용자는 &quot;ducks&quot;파일 구조와 같이보다 밀접하게 결합하도록 선택하지만 기본적으로 일대일 매핑은 없으며, 원하는 패러다임을 벗어날 수 있습니다. 많은 감속기에서 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2d55eda060d4abd9e941e61eac1c5a4760b4b7fb" translate="yes" xml:space="preserve">
          <source>No. You are welcome to use any approach you'd like to respond to an action in a reducer. The &lt;code&gt;switch&lt;/code&gt; statement is the most common approach, but it's fine to use &lt;code&gt;if&lt;/code&gt; statements, a lookup table of functions, or to create a function that abstracts this away. In fact, while Redux does require that action objects contain a &lt;code&gt;type&lt;/code&gt; field, your reducer logic doesn't even have to rely on that to handle the action. That said, the standard approach is definitely using a switch statement or a lookup table based on &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">아니요. 감속기의 동작에 응답하려는 접근 방식을 사용하는 것이 좋습니다. &lt;code&gt;switch&lt;/code&gt; 문은 가장 일반적인 방법이지만, 그것의 벌금 사용하는 &lt;code&gt;if&lt;/code&gt; 문, 함수의 조회 테이블을, 또는 멀리이 추상화 기능을 만들 수 있습니다. 실제로 Redux는 액션 객체에 &lt;code&gt;type&lt;/code&gt; 필드가 포함되도록 요구하지만 , 리듀서 로직은 액션을 처리하기 위해 그것에 의존 할 필요조차 없습니다. 즉, 표준 방식은 switch 문 또는 &lt;code&gt;type&lt;/code&gt; 기반 조회 테이블을 사용하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e0d7b6b9e9168e473b1803957df55eb87b2031d" translate="yes" xml:space="preserve">
          <source>Nope, it's just HTML, some artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, and plain old DOM manipulation. Enjoy!</source>
          <target state="translated">아니, 그것은 단지 HTML, 일부 artisanal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 및 일반 오래된 DOM 조작입니다. 즐겨!</target>
        </trans-unit>
        <trans-unit id="327c34539b30a346bec5ad81c0c1b3f68e1bdeed" translate="yes" xml:space="preserve">
          <source>Normalizing Data</source>
          <target state="translated">데이터 정규화</target>
        </trans-unit>
        <trans-unit id="24e6df000cfc0eae18573e3ca083b23c0599cf6a" translate="yes" xml:space="preserve">
          <source>Normalizing Nested Data</source>
          <target state="translated">중첩 데이터 정규화</target>
        </trans-unit>
        <trans-unit id="dcd338fb8e5bd8068c0c2b43bfce9d5de3e8a57c" translate="yes" xml:space="preserve">
          <source>Normalizing State Shape</source>
          <target state="translated">상태 형태 정규화</target>
        </trans-unit>
        <trans-unit id="eb23cc3f5afc902e5be043420e1d724b51659962" translate="yes" xml:space="preserve">
          <source>Normalizr Documentation</source>
          <target state="translated">Normalizr 설명서</target>
        </trans-unit>
        <trans-unit id="335b95f34a7df1f471d9e66d848a822638f18b4c" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; 를&lt;/a&gt; 직접 호출해야 합니다. Reux와 함께 Redux를 사용하면 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; 가 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능을 제공하므로 직접 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c3f41f979e0141ba2295989bb6b08208506c7a" translate="yes" xml:space="preserve">
          <source>Normally you should just call &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; directly on your &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance. If you use Redux with React, &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; will provide you with the &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function so you can call it directly, too.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 직접 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; 를&lt;/a&gt; 호출해야 합니다. React와 함께 Redux를 사용하는 경우 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; 가 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능을 제공하므로 직접 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4e5332959aece0b47c0b738573f9bd470cb893" translate="yes" xml:space="preserve">
          <source>Normally, a Javascript array's contents are modified using mutative functions like &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see &quot;insert&quot; or &quot;remove&quot; behavior written like this:</source>
          <target state="translated">일반적으로 Javascript 배열의 내용은 &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;unshift&lt;/code&gt; 및 &lt;code&gt;splice&lt;/code&gt; 와 같은 변형 함수를 사용하여 수정됩니다 . 감속기에서 상태를 직접 변경하고 싶지 않기 때문에 일반적으로 피해야합니다. 이 때문에 다음과 같이 &quot;삽입&quot;또는 &quot;제거&quot;동작이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf716978826f82f5c2d71096281b5d3d023f9c8" translate="yes" xml:space="preserve">
          <source>Not suitable for small values that change often</source>
          <target state="translated">자주 바뀌는 작은 값에는 적합하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eb86ccd5312e5081a352de1334537a0b4650d54d" translate="yes" xml:space="preserve">
          <source>Note About Other Routing Libraries</source>
          <target state="translated">다른 라우팅 라이브러리에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="6bbf18fa1a59b4aceea2d7935084a5984b1e6199" translate="yes" xml:space="preserve">
          <source>Note about Server Rendering</source>
          <target state="translated">서버 렌더링에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4c76dccbb579daeff6d19eccfc8338e7cf2dfdca" translate="yes" xml:space="preserve">
          <source>Note for Advanced Users</source>
          <target state="translated">고급 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0e1755ef6326ca3fc737a66979bb10b7fe7587af" translate="yes" xml:space="preserve">
          <source>Note for ES6 Savvy Users</source>
          <target state="translated">ES6 정통한 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4bfd422b1acf7ab6bcc2d683c3dcc9593e8dfe47" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;Object.assign&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.assign&lt;/code&gt; 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="759269df6e82649e8ad3a46ac965bc2b1dbc225c" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;fetch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4191e14191dc73a177c536b0008fd934e599f6c0" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;switch&lt;/code&gt; and Boilerplate</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 및 보일러 플레이트 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="ae1778afee8eaabfaf5e882ffee86fd7dfad1748" translate="yes" xml:space="preserve">
          <source>Note on Boilerplate</source>
          <target state="translated">보일러 플레이트에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f520e769580a42a8ec1ab5c7de5b32126ab034fd" translate="yes" xml:space="preserve">
          <source>Note on Create React App</source>
          <target state="translated">React 앱 생성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0dba1d6300344edb76956054e6c0d4c05d8a5923" translate="yes" xml:space="preserve">
          <source>Note on Error Handling</source>
          <target state="translated">오류 처리에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="226b6e169b44973eab9a3a7d4ce9abe63d0c7f07" translate="yes" xml:space="preserve">
          <source>Note on Nested Entities</source>
          <target state="translated">중첩 된 엔티티에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f85a104fce56d4fdf589c3dd1d9c7b40327d3c8b" translate="yes" xml:space="preserve">
          <source>Note on Reducer Composition</source>
          <target state="translated">감속기 구성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4d5561853fa6b8c8692a5c30631ba7770fde7366" translate="yes" xml:space="preserve">
          <source>Note on Relationships</source>
          <target state="translated">관계에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0b2ca83fd75e901aec616d782b23314502061cce" translate="yes" xml:space="preserve">
          <source>Note on immutability, side effects, and mutation</source>
          <target state="translated">불변성, 부작용 및 돌연변이에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="068f9eefaa044d6807c7bf4c8c0f32ef9489c02e" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;updating data immutably&amp;rdquo; does &lt;em&gt;not&lt;/em&gt; mean that you must use &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt;, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</source>
          <target state="translated">&quot;데이터를 불변으로 업데이트&quot; 한다고해서 반드시 &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; 를 사용해야한다는 의미 는 &lt;em&gt;아닙니다&lt;/em&gt; . 여러 가지 다른 접근 방식을 사용하여 일반 JS 객체 및 배열을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03a447c3fbe3d52e5d3b4ec4eb5f4cbd98b4d07a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combineReducers&lt;/code&gt; doesn't know or care that there's anything special about the reducer function that's responsible for managing &lt;code&gt;a&lt;/code&gt;. We didn't need to modify &lt;code&gt;combineReducers&lt;/code&gt; to specifically know how to undo things - we just built up the pieces we needed into a new composed function.</source>
          <target state="translated">참고 &lt;code&gt;combineReducers&lt;/code&gt; 가 관리하는 책임이 감속기의 기능에 대해 아무것도 특수가 있음을 알거나 관리하지 않는 &lt;code&gt;a&lt;/code&gt; . 우리는 &lt;code&gt;combineReducers&lt;/code&gt; 를 수정 하여 특정 작업을 취소하는 방법을 구체적으로 알 필요가 없었 습니다. 필요한 조각을 새로운 구성 함수로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="b8cedc1c11fc5e0b2729544aacc4a299dcef1a86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;todos&lt;/code&gt; also accepts &lt;code&gt;state&lt;/code&gt;&amp;mdash;but it's an array! Now &lt;code&gt;todoApp&lt;/code&gt; just gives it the slice of the state to manage, and &lt;code&gt;todos&lt;/code&gt; knows how to update just that slice. &lt;strong&gt;This is called &lt;em&gt;reducer composition&lt;/em&gt;, and it's the fundamental pattern of building Redux apps.&lt;/strong&gt;</source>
          <target state="translated">참고 것을 &lt;code&gt;todos&lt;/code&gt; 또한 받아 &lt;code&gt;state&lt;/code&gt; 가 배열입니다 -하지만! 이제 &lt;code&gt;todoApp&lt;/code&gt; 은 관리 할 상태 조각을 제공하고 &lt;code&gt;todos&lt;/code&gt; 는 해당 조각 만 업데이트하는 방법을 알고 있습니다. &lt;strong&gt;이를 &lt;em&gt;리듀서 구성&lt;/em&gt; 이라고하며 Redux 앱을 빌드하는 기본 패턴입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f8b0362b0a282b6bc627b26a9692c8cb48f4d7f" translate="yes" xml:space="preserve">
          <source>Note that Immutable.JS objects do have a &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data as a plain JavaScript data structure, but this method is extremely slow, and using it extensively will negate the performance benefits that Immutable.JS provides</source>
          <target state="translated">Immutable.JS 객체에는 &lt;code&gt;toJS()&lt;/code&gt; 메소드 가 있습니다. 이 메소드는 데이터를 일반 JavaScript 데이터 구조로 리턴하지만이 메소드는 매우 느리며 광범위하게 사용하면 Immutable.JS가 제공하는 성능 이점을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="453c35dfa0c302d121b3eadd02c225634676ef9a" translate="yes" xml:space="preserve">
          <source>Note that a normalized state structure generally implies that more components are connected and each component is responsible for looking up its own data, as opposed to a few connected components looking up large amounts of data and passing all that data downwards. As it turns out, having connected parent components simply pass item IDs to connected children is a good pattern for optimizing UI performance in a React Redux application, so keeping state normalized plays a key role in improving performance.</source>
          <target state="translated">표준화 된 상태 구조는 일반적으로 더 많은 구성 요소가 연결되어 있고 각 구성 요소가 많은 양의 데이터를 찾아서 모든 데이터를 아래쪽으로 전달하는 것과 달리 연결된 구성 요소와는 달리 자체 데이터를 검색해야 함을 의미합니다. 결과적으로, 연결된 상위 컴포넌트가 단순히 연결된 하위 컴포넌트에 항목 ID를 전달하는 것은 React Redux 애플리케이션에서 UI 성능을 최적화하기위한 좋은 패턴이므로 상태를 정상화 상태로 유지하는 것이 성능 향상에 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bd5f79bd2131ac43e4417a0d7a6aaff0b70dafa1" translate="yes" xml:space="preserve">
          <source>Note that a reducer is a pure function. It only &lt;em&gt;computes&lt;/em&gt; the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn't perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</source>
          <target state="translated">감속기는 순수한 기능입니다. 다음 상태 만 &lt;em&gt;계산&lt;/em&gt; 합니다. 완전히 예측 가능해야합니다. 동일한 입력으로 여러 번 호출하면 동일한 출력이 생성됩니다. API 호출이나 라우터 전환과 같은 부작용을 수행해서는 안됩니다. 이러한 조치는 조치가 전달되기 전에 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="dce445ddd99a63b5841226d22eed33b3bf5571f8" translate="yes" xml:space="preserve">
          <source>Note that experimental language features are subject to change.</source>
          <target state="translated">실험 언어 기능은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b9f2be80295a73b990bda31c5fcc186d2c3fd08" translate="yes" xml:space="preserve">
          <source>Note that if you use &lt;code&gt;reduceReducers&lt;/code&gt;, you should make sure that the first reducer in the list is able to define the initial state, since the later reducers will generally assume that the entire state already exists and not try to provide defaults.</source>
          <target state="translated">&lt;code&gt;reduceReducers&lt;/code&gt; 를 사용하는 경우 , 목록의 첫 번째 감속기가 초기 상태를 정의 할 수 있는지 확인해야합니다. 이후 감속기는 일반적으로 전체 상태가 이미 존재한다고 가정하고 기본값을 제공하려고 시도하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3299e9657e0599957e5ab9cd478270d217e7c17c" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e53104dd9201201207a0d3f3e75f9194a7e7bc6e" translate="yes" xml:space="preserve">
          <source>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</source>
          <target state="translated">이것은 여전히 ​​실험적인 언어 기능 제안이므로 향후 변경 될 수 있습니다. 그럼에도 불구하고 &lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt; 와 같은 일부 대규모 프로젝트는 이미 광범위하게 사용하므로 변경시 자동 마이그레이션 경로가 양호하다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b83325ce50b1549fdb9a559ec6487d2af3c6cb" translate="yes" xml:space="preserve">
          <source>Note that unlike Redux itself, many packages in the Redux ecosystem don't provide UMD builds, so we recommend using CommonJS module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; and &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; for the most comfortable development experience.</source>
          <target state="translated">Redux 자체와 달리 Redux 에코 시스템의 많은 패키지는 UMD 빌드를 제공하지 않으므로 가장 편안한 개발 환경을 위해 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; 및 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 CommonJS 모듈 번 들러 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="62f695305f86349d2a0577aa88e353229236d1f1" translate="yes" xml:space="preserve">
          <source>Note that we are using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring&lt;/a&gt; on the properties to pass in &lt;code&gt;params&lt;/code&gt; to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 에 &lt;code&gt;params&lt;/code&gt; 를 전달하기 위해 속성에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 구조 해제&lt;/a&gt; 를 사용 하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1618ff7b8e1c0dbfdbf2def8e4b7d2220f232032" translate="yes" xml:space="preserve">
          <source>Note that your &lt;code&gt;combineReducers()&lt;/code&gt; call will stay exactly as it was, but the &lt;code&gt;todos&lt;/code&gt; reducer will now refer to the reducer enhanced with Redux Undo:</source>
          <target state="translated">귀하의 &lt;code&gt;combineReducers()&lt;/code&gt; 호출은 그대로 유지되지만, &lt;code&gt;todos&lt;/code&gt; 리듀서는 이제 Redux Undo로 향상된 리듀서를 참조합니다 :</target>
        </trans-unit>
        <trans-unit id="727f3c121140693e9689630208289bf9c864cbb3" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if an &lt;em&gt;immutable&lt;/em&gt; object is used, the &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;component may re-render when it should not&lt;/a&gt;.</source>
          <target state="translated">반대로, &lt;em&gt;불변의&lt;/em&gt; 객체가 사용되는 경우, &lt;a href=&quot;#immutability-issues-with-react-redux&quot;&gt;컴퍼넌트는 그렇지 않은 경우에 다시 렌더링 할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b863cfb1b4dca7e52579f1008befc33963aff3ba" translate="yes" xml:space="preserve">
          <source>Note that, conversely, if the values in your props object refer to mutable objects, &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;your component may not render when it should&lt;/a&gt;.</source>
          <target state="translated">반대로 props 객체의 값이 변경 가능한 객체를 참조하면 &lt;a href=&quot;#shallow-checking-stops-component-re-rendering&quot;&gt;구성 요소가 필요할 때 렌더링되지 않을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e99340e9e77003c33d3f85a388e8f45942421146" translate="yes" xml:space="preserve">
          <source>Note that, even if your immutable library supports cursors, you shouldn't use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn't make sense for Redux. &lt;strong&gt;If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.&lt;/strong&gt; Selectors are composable getter functions. See &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; for a really great and concise implementation of composable selectors.</source>
          <target state="translated">불변 라이브러리가 커서를 지원하더라도 Redux 앱에서는 커서를 사용해서는 안됩니다. 전체 상태 트리는 읽기 전용으로 간주되어야하며 Redux를 사용하여 상태를 업데이트하고 업데이트를 구독해야합니다. 따라서 커서를 통한 쓰기는 Redux에 적합하지 않습니다. &lt;strong&gt;커서의 유일한 유스 케이스가 상태 트리를 UI 트리에서 분리하고 점차적으로 커서를 조정하는 경우 선택기를 대신 살펴 봐야합니다. &lt;/strong&gt;선택기는 컴포저 블 게터 함수입니다. 컴포저 블 선택기의 훌륭하고 간결한 구현에 대해서는 &lt;a href=&quot;http://github.com/faassen/reselect&quot;&gt;재 선택&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="9b3033c3ffc250f6cdbccd213236b9854f6e17c7" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not apply to the Redux state tree, which is (usually) represented as a large collection of data.</source>
          <target state="translated">그러나 Redux 상태 트리에는 적용되지 않으며, 일반적으로 대규모 데이터 모음으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="401d2785d679a18987a35eba32cda5b4c90664ab" translate="yes" xml:space="preserve">
          <source>Nothing happens when I dispatch an action</source>
          <target state="translated">액션을 전달해도 아무런 변화가 없습니다</target>
        </trans-unit>
        <trans-unit id="f2f081e8fb2d918d664c68f1b3afaafa905dc9ec" translate="yes" xml:space="preserve">
          <source>Notice that because the two &quot;slice of state&quot; reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.</source>
          <target state="translated">두 &quot;상태 분할&quot;감속기가 이제 전체 상태의 자체 부분 만 인수로 가져 오므로 더 이상 복잡한 중첩 된 상태 객체를 반환 할 필요가 없으며 결과적으로 더 단순 해집니다.</target>
        </trans-unit>
        <trans-unit id="259bf730b245ab69768be3ff064b89e550ad7e24" translate="yes" xml:space="preserve">
          <source>Notice that because we used the ES6 shorthand for defining an object literal, the key names in the resulting state are the same as the variable names from the imports. This may not always be the desired behavior, and is often a cause of confusion for those who aren't as familiar with ES6 syntax.</source>
          <target state="translated">객체 리터럴을 정의하기 위해 ES6 속기를 사용 했으므로 결과 상태의 키 이름은 가져 오기의 변수 이름과 동일합니다. 항상 원하는 동작은 아니지만 ES6 구문에 익숙하지 않은 사람들에게는 혼동의 원인이되기도합니다.</target>
        </trans-unit>
        <trans-unit id="c55d1d53bcc6077be7393d548df6e69409007456" translate="yes" xml:space="preserve">
          <source>Notice that the structure of the data is a bit complex, and some of the data is repeated. This is a concern for several reasons:</source>
          <target state="translated">데이터의 구조는 약간 복잡하며 일부 데이터는 반복됩니다. 이것은 여러 가지 이유로 우려됩니다.</target>
        </trans-unit>
        <trans-unit id="31c43966210d015eb458a0c29218a03e52a64682" translate="yes" xml:space="preserve">
          <source>Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done.</source>
          <target state="translated">이 간단한 기능은 모든 기본 요구 사항을 충족합니다. 존재하지 않는 경우 기본값을 리턴하여 상점을 초기화합니다. 조치 유형에 따라 어떤 종류의 업데이트를 수행해야하는지 결정하고 새 값을 리턴합니다. 작업을 수행 할 필요가없는 경우 이전 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f594ca01c521a947b3e348a3910ebef9ac4949d" translate="yes" xml:space="preserve">
          <source>Now I specified the &lt;code&gt;preloadedState&lt;/code&gt; as the argument to &lt;code&gt;createStore()&lt;/code&gt;. The state returned from the combined reducer &lt;em&gt;combines&lt;/em&gt; the initial state I specified for the &lt;code&gt;a&lt;/code&gt; reducer with the &lt;code&gt;'wat'&lt;/code&gt; default argument specified that &lt;code&gt;b&lt;/code&gt; reducer chose itself.</source>
          <target state="translated">이제 &lt;code&gt;preloadedState&lt;/code&gt; 를 &lt;code&gt;createStore()&lt;/code&gt; 의 인수로 지정했습니다 . 결합 감속기에서 반환 된 상태는 &lt;em&gt;결합&lt;/em&gt; 제가 지정된 초기 상태 와 감속기 &lt;code&gt;'wat'&lt;/code&gt; 기본 인수가 지정된 &lt;code&gt;b&lt;/code&gt; 감속기 자체를 선택했다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b89cc88436f6b137ad4a9f780f72e731b9b03e7" translate="yes" xml:space="preserve">
          <source>Now all that's left to do is to port the UI to &lt;a href=&quot;../basics/usagewithreact&quot;&gt;use react-redux&lt;/a&gt; or equivalent.</source>
          <target state="translated">이제 남은 일은 &lt;a href=&quot;../basics/usagewithreact&quot;&gt;react-redux&lt;/a&gt; 또는 이와 동등한 기능 을 사용하도록 UI를 이식 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb64c52d4e3660f6e76a49dcb8eecf7480f674ab" translate="yes" xml:space="preserve">
          <source>Now all you need to do is add the buttons for the Undo and Redo actions.</source>
          <target state="translated">이제 실행 취소 및 다시 실행 작업에 대한 버튼을 추가하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a13470744cb184c27b6870ae352da0030e60cab7" translate="yes" xml:space="preserve">
          <source>Now if you click on &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; you will see that your URL will change between &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt;, &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt;, and &lt;code&gt;'/'&lt;/code&gt;. Even if you are going back with your browser, it will use your browser's history and effectively go to your previous URL.</source>
          <target state="translated">&lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; 를 클릭 하면 URL이 &lt;code&gt;'/SHOW_COMPLETED'&lt;/code&gt; , &lt;code&gt;'/SHOW_ACTIVE'&lt;/code&gt; 및 &lt;code&gt;'/'&lt;/code&gt; 사이에서 변경되는 것을 볼 수 있습니다 . 브라우저로 돌아가더라도 브라우저 기록을 사용하여 효과적으로 이전 URL로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b5c5b26561c588a93e62173562a3ad6868edb589" translate="yes" xml:space="preserve">
          <source>Now it's &lt;em&gt;very&lt;/em&gt; clear what's happening in each case. We can also start to see some patterns emerging.</source>
          <target state="translated">이제 각 상황에서 무슨 일이 일어나고 있는지 &lt;em&gt;매우&lt;/em&gt; 분명합니다. 또한 몇 가지 패턴이 나타나기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039958ecab3a233f66de07e31ed5de4247ff1cc6" translate="yes" xml:space="preserve">
          <source>Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt; to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React performance suggestion&lt;/a&gt; of implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; yourself.)</source>
          <target state="translated">이제 컨테이너를 만들어 프리젠 테이션 컴포넌트를 Redux에 연결할 차례입니다. 기술적으로 컨테이너 구성 요소는 &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 Redux 상태 트리의 일부를 읽고 렌더링하는 프레젠테이션 구성 요소에 소품을 제공 하는 React 구성 요소입니다 . 컨테이너 구성 요소를 직접 작성할 수는 있지만 React Redux 라이브러리의 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 컨테이너 구성 요소를 생성하는 것이 좋습니다.이 구성 요소는 불필요한 다시 렌더링을 방지하기 위해 많은 유용한 최적화 기능을 제공합니다. (이 결과로 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 직접 구현할 때 &lt;a href=&quot;https://facebook.github.io/react/docs/advanced-performance.html&quot;&gt;React 성능 제안&lt;/a&gt; 에 대해 걱정할 필요가 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="9e400bbf3cbd513fc16c8f3c4354394f2d6dfefd" translate="yes" xml:space="preserve">
          <source>Now let's &lt;a href=&quot;reducers&quot;&gt;define some reducers&lt;/a&gt; to specify how the state updates when you dispatch these actions!</source>
          <target state="translated">이제 이러한 액션을 디스패치 할 때 상태가 업데이트되는 방식을 지정하기 위해 &lt;a href=&quot;reducers&quot;&gt;일부 리듀서&lt;/a&gt; 를 정의 해 봅시다 !</target>
        </trans-unit>
        <trans-unit id="a861289e4760b669f41d014c314ded1b05995e5c" translate="yes" xml:space="preserve">
          <source>Now let's consider a case where you use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;combineReducers()&lt;/code&gt; 를 사용하는 경우를 생각해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="25793e0576f1da9e1c2bfbfd26f6e9946bceb3cb" translate="yes" xml:space="preserve">
          <source>Now let's handle &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;. All it needs to do is to change &lt;code&gt;visibilityFilter&lt;/code&gt; on the state. Easy:</source>
          <target state="translated">이제 &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; 를 다루 겠습니다 . 그 상태에서 &lt;code&gt;visibilityFilter&lt;/code&gt; 를 변경하기 만하면 됩니다. 쉬운:</target>
        </trans-unit>
        <trans-unit id="f7f2dcd080c7438e503e2c14d7c5e936c3fb8edb" translate="yes" xml:space="preserve">
          <source>Now let's say you create a store with it.</source>
          <target state="translated">이제 상점을 작성한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="29c32e5fc4131c9dccec8ae29eeeaccbf917ea78" translate="yes" xml:space="preserve">
          <source>Now middleware takes the &lt;code&gt;next()&lt;/code&gt; dispatch function, and returns a dispatch function, which in turn serves as &lt;code&gt;next()&lt;/code&gt; to the middleware to the left, and so on. It's still useful to have access to some store methods like &lt;code&gt;getState()&lt;/code&gt;, so &lt;code&gt;store&lt;/code&gt; stays available as the top-level argument.</source>
          <target state="translated">이제 미들웨어는 &lt;code&gt;next()&lt;/code&gt; 디스패치 함수를 가져오고 디스패치 함수를 리턴합니다. 그러면 디스패치 함수가 차례로 미들웨어의 &lt;code&gt;next()&lt;/code&gt; 역할 을합니다. &lt;code&gt;getState()&lt;/code&gt; 와 같은 일부 상점 메소드에 액세스하는 것이 여전히 유용 하므로 &lt;code&gt;store&lt;/code&gt; 은 최상위 인수로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="382b9eb84610aaa6ea11db467333f8d6953604ec" translate="yes" xml:space="preserve">
          <source>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what &lt;code&gt;undoable&lt;/code&gt; should have been:</source>
          <target state="translated">리듀서 인핸서에 대해 더 잘 이해 했으므로 이것이 &lt;code&gt;undoable&lt;/code&gt; 것임을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5a09e1de7d9c9396b8d34429449e39f8bd9943d" translate="yes" xml:space="preserve">
          <source>Now that we have created a store, let's verify our program works! Even without any UI, we can already test the update logic.</source>
          <target state="translated">상점을 만들었으므로 프로그램이 작동하는지 확인합시다! UI가 없어도 이미 업데이트 논리를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b286277222e0bb8486e6265c655c4d0a7094d7a9" translate="yes" xml:space="preserve">
          <source>Now that we've decided what our state object looks like, we're ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</source>
          <target state="translated">상태 객체의 모양을 결정 했으므로 이제 리듀서를 작성할 준비가되었습니다. 감속기는 이전 상태와 조치를 취하고 다음 상태를 리턴하는 순수 함수입니다.</target>
        </trans-unit>
        <trans-unit id="c21e7038b2cfa1d79db9097dffc1cae32ab8eff6" translate="yes" xml:space="preserve">
          <source>Now that you know how Redux works, let's &lt;a href=&quot;usagewithreact&quot;&gt;connect it to a React app&lt;/a&gt;.</source>
          <target state="translated">이제 Redux의 작동 방식을 알았으므로 &lt;a href=&quot;usagewithreact&quot;&gt;이를 React 앱에 연결&lt;/a&gt; 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="04bd1420551bdec742d2330183e8fe0464300fae" translate="yes" xml:space="preserve">
          <source>Now that you know how to do basic routing, you can learn more about &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API&lt;/a&gt;</source>
          <target state="translated">기본 라우팅을 수행하는 방법을 알고 있으므로 &lt;a href=&quot;https://github.com/reactjs/react-router/tree/v3/docs/&quot;&gt;React Router API에&lt;/a&gt; 대해 자세히 알아볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df198929b555d3f025b9f4c6dce1d531c1c5ab85" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; component will be rendered if the URL matches '/'. Additionally, we will add the optional &lt;code&gt;(:filter)&lt;/code&gt; parameter to &lt;code&gt;/&lt;/code&gt;, because we will need it further on when we try to read the parameter &lt;code&gt;(:filter)&lt;/code&gt; from the URL.</source>
          <target state="translated">URL이 '/'와 일치 하면 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 구성 요소가 렌더링됩니다. 또한 URL에서 매개 변수 &lt;code&gt;(:filter)&lt;/code&gt; 를 읽으려고 할 때 추가로 필요하므로 선택적 &lt;code&gt;(:filter)&lt;/code&gt; 매개 변수를 &lt;code&gt;/&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5d916cc36e1dd4f19a7f89bff47aaabeb96451f9" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;todos&lt;/code&gt; part of the state looks like this:</source>
          <target state="translated">이제 상태 의 &lt;code&gt;todos&lt;/code&gt; 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d942270816eb39d5e0deb26630ac877f7158718d" translate="yes" xml:space="preserve">
          <source>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn't need to know the complete initial state anymore. It's enough that the child reducers return their initial state when given &lt;code&gt;undefined&lt;/code&gt; at first.</source>
          <target state="translated">이제 메인 리듀서를 상태의 일부를 관리하는 리듀서를 호출하고 단일 객체로 결합하는 함수로 다시 작성할 수 있습니다. 또한 더 이상 완전한 초기 상태를 알 필요가 없습니다. 처음에 &lt;code&gt;undefined&lt;/code&gt; 가 주어지면 자식 감속기가 초기 상태를 반환하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="a667ae6de0b7dc9eab910e5e9d0c63d6e4240965" translate="yes" xml:space="preserve">
          <source>Now you can add &lt;code&gt;UndoRedo&lt;/code&gt; component to the &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">이제 &lt;code&gt;App&lt;/code&gt; 구성 요소에 &lt;code&gt;UndoRedo&lt;/code&gt; 구성 요소를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2b05aac713becd3e746ad95aee7b78fc6182e91" translate="yes" xml:space="preserve">
          <source>Now you saw an example of what middleware can do in Redux, it's time to learn how it actually works, and how you can create your own. Go on to the next detailed section about &lt;a href=&quot;middleware&quot;&gt;Middleware&lt;/a&gt;.</source>
          <target state="translated">이제 Redux에서 미들웨어가 수행 할 수있는 작업에 대한 예를 보았습니다. 이제 실제 작동 방식과 직접 작성하는 방법을 배울 차례입니다. &lt;a href=&quot;middleware&quot;&gt;미들웨어&lt;/a&gt; 에 대한 다음 세부 섹션으로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="65dfb2a3456a6347a253e5df887084ce9d5bc969" translate="yes" xml:space="preserve">
          <source>Now you'll be able to call them directly:</source>
          <target state="translated">이제 직접 전화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7d7d4bdf1f24961ac2cd4648199d9fca2b39f7d" translate="yes" xml:space="preserve">
          <source>Now, if user presses &amp;ldquo;Undo&amp;rdquo;, we want it to change to move into the past:</source>
          <target state="translated">이제 사용자가 &quot;실행 취소&quot;를 누르면 과거로 이동하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="9f0f0f51df5136b797764eade8b49d76aa9d3def" translate="yes" xml:space="preserve">
          <source>Now, the UI can be updated to reflect the new state. If you use bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt;, this is the point at which &lt;code&gt;component.setState(newState)&lt;/code&gt; is called.</source>
          <target state="translated">이제 새로운 상태를 반영하도록 UI를 업데이트 할 수 있습니다. &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;React Redux&lt;/a&gt; 와 같은 바인딩을 사용 하는 경우 &lt;code&gt;component.setState(newState)&lt;/code&gt; 가 호출 되는 지점 입니다.</target>
        </trans-unit>
        <trans-unit id="238539b34511566c52f015ab4f02c6eba84442e7" translate="yes" xml:space="preserve">
          <source>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</source>
          <target state="translated">이제 문제는 액션 제작자에 넣을 것과 리듀서에 무엇이 있는지, 지방과 얇은 액션 객체 중에서 선택하는 것입니다. 액션 생성자에 모든 로직을 넣으면 기본적으로 상태에 대한 업데이트를 선언하는 팻 액션 객체가 생깁니다. 감속기는 순수하고 멍청하며 추가하고 제거하고 이러한 기능을 업데이트합니다. 그들은 작성하기 쉬울 것입니다. 그러나 비즈니스 로직이 많지 않을 것입니다. 리듀서에 더 많은 로직을 넣으면 대부분의 데이터 로직이 한 곳에있는 훌륭하고 얇은 액션 객체로 끝나지만 다른 브랜치의 정보가 필요할 수 있으므로 리듀서를 작성하기가 더 어렵습니다. 당신은 큰 리듀서 또는 상태에서 상위에서 추가 인수를 취하는 리듀서로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="dd811c18dfe3457c25b793431983374970c1dbff" translate="yes" xml:space="preserve">
          <source>Object spread lets us simplify the above &lt;code&gt;map&lt;/code&gt; call to:</source>
          <target state="translated">오브젝트 스프레드를 통해 위의 &lt;code&gt;map&lt;/code&gt; 호출을 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d82a77c6f21355d9167707cd08b4acf80faac7" translate="yes" xml:space="preserve">
          <source>Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.</source>
          <target state="translated">분명히, 각 중첩 계층은 이것을 읽기 어렵게 만들고 실수 할 가능성이 더 커집니다. 이것이 주를 평평하게 유지하고 감속기를 최대한 많이 구성하는 몇 가지 이유 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="99059fe3a8c10ea3a773517b2809c9d604ee1753" translate="yes" xml:space="preserve">
          <source>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The &lt;code&gt;combineReducers()&lt;/code&gt; that comes with Redux is one of the many possible ways to achieve this. It's also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</source>
          <target state="translated">분명히, 단일 함수에서 가능한 모든 작업을 처리하려고 시도하는 것은 단순히 함수 크기와 가독성 측면에서 잘 확장되지 않으므로 실제 작업을 최상위 수준 감속기로 호출 할 수있는 별도의 함수로 분할하는 것이 좋습니다. 특히, 일반적으로 제안되는 패턴은 특정 키에서 특정 상태 조각에 대한 업데이트를 관리하는 별도의 하위 감소 기 기능을 갖는 것입니다. Redux와 함께 제공 되는 &lt;code&gt;combineReducers()&lt;/code&gt; 는이를 달성 할 수있는 많은 방법 중 하나입니다. 또한 상점 상태를 최대한 평평하고 표준화 된 상태로 유지하는 것이 좋습니다. 그러나 궁극적으로 원하는 방식으로 감속기 논리를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc135e616ba1be37c0cfabb241f9c97c73b5f08" translate="yes" xml:space="preserve">
          <source>On the client side, a new Redux store will be created and initialized with the state provided from the server.</source>
          <target state="translated">클라이언트 측에서 서버에서 제공 한 상태로 새 Redux 저장소가 생성되고 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f42b17ddf866ba0ef881ccab2d5ac7ea6bba3a" translate="yes" xml:space="preserve">
          <source>On the server side, we simply wrap our existing code in the &lt;code&gt;fetchCounter&lt;/code&gt; and receive the result in the callback:</source>
          <target state="translated">서버 측에서는 기존 코드를 &lt;code&gt;fetchCounter&lt;/code&gt; 에 래핑하고 콜백에서 결과를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="abb297d24ed9dbaa92d7ae801845e13d9a8c7d96" translate="yes" xml:space="preserve">
          <source>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don't let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the &amp;ldquo;staff picks&amp;rdquo;, and don't hesitate to submit a PR if you've built something wonderful with Redux.</source>
          <target state="translated">이 페이지에는 Redux 관리자가 개인적으로 조사한 몇 가지 기능 만 소개합니다. 이로 인해 나머지를 시도하지 못하게하십시오! 생태계가 너무 빠르게 성장하고 있으며 모든 것을 볼 시간이 제한되어 있습니다. 이 &quot;직원 선택&quot;을 고려하고 Redux로 멋진 것을 만들면 주저하지 말고 PR을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="00a57ab237ca0a42b345eb1574324e493eaac905" translate="yes" xml:space="preserve">
          <source>Once used, Immutable.JS will spread throughout your codebase</source>
          <target state="translated">일단 사용되면 Immutable.JS는 코드베이스 전체에 퍼집니다</target>
        </trans-unit>
        <trans-unit id="e388b344448bc1c302e673361dcd29e30a20c835" translate="yes" xml:space="preserve">
          <source>Once you encapsulate your data with Immutable.JS, you have to use Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; property accessors to access it.</source>
          <target state="translated">Immutable.JS로 데이터를 캡슐화하면 Immutable.JS의 &lt;code&gt;get()&lt;/code&gt; 또는 &lt;code&gt;getIn()&lt;/code&gt; 속성 접근자를 사용하여 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="99e18cc195c97bd7e16b2c5c00f317c2ee608dad" translate="yes" xml:space="preserve">
          <source>One approach is to merge the contents of the action in to the existing state. In this case, we need to do a deep recursive merge, not just a shallow copy. The Lodash &lt;code&gt;merge&lt;/code&gt; function can handle this for us:</source>
          <target state="translated">한 가지 방법은 작업 내용을 기존 상태로 병합하는 것입니다. 이 경우 얕은 사본이 아니라 깊은 재귀 병합을 수행해야합니다. Lodash &lt;code&gt;merge&lt;/code&gt; 기능은 다음을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a9b8df0f4b63915decda672bef5db25fe34cfb" translate="yes" xml:space="preserve">
          <source>One frequently asked question is whether Redux &quot;calls all reducers&quot; when dispatching an action. Since there really is only one root reducer function, the default answer is &quot;no, it does not&quot;. However, &lt;code&gt;combineReducers&lt;/code&gt; has specific behavior that &lt;em&gt;does&lt;/em&gt; work that way. In order to assemble the new state tree, &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with its current slice of state and the current action, giving the slice reducer a chance to respond and update its slice of state if needed. So, in that sense, using &lt;code&gt;combineReducers&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; &quot;call all reducers&quot;, or at least all of the slice reducers it is wrapping.</source>
          <target state="translated">자주 묻는 질문 중 하나는 Redux가 작업을 전달할 때 &quot;모든 감속기를 호출&quot;하는지 여부입니다. 실제로 루트 리듀서 기능은 하나뿐이므로 기본 대답은 &quot;아니오, 그렇지 않습니다&quot;입니다. 그러나 &lt;code&gt;combineReducers&lt;/code&gt; 에는 그런 식으로 작동하는 특정 동작 &lt;em&gt;이&lt;/em&gt; 있습니다. 새 상태 트리를 조립하기 위해 &lt;code&gt;combineReducers&lt;/code&gt; 는 각 슬라이스 감속기를 현재 상태 슬라이스와 현재 동작으로 호출하여 슬라이스 감속기가 필요한 경우 상태 슬라이스를 응답하고 업데이트 할 수있는 기회를 제공합니다. 그래서, 그런 의미에서 사용 &lt;code&gt;combineReducers&lt;/code&gt; 은&lt;em&gt;않습니다&lt;/em&gt; &quot;모든 감속기 전화&quot;, 또는 슬라이스 감속기의 모든 적어도 그것은 포장입니다.</target>
        </trans-unit>
        <trans-unit id="a4284542792cb9fd32437214931abfe8482da4b0" translate="yes" xml:space="preserve">
          <source>One neat trick is to use the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 default arguments syntax&lt;/a&gt; to write this in a more compact way:</source>
          <target state="translated">깔끔한 방법 중 하나는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters&quot;&gt;ES6 기본 인수 구문&lt;/a&gt; 을 사용하여 보다 간단한 방법으로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da5b8fcb37f2ad97d55411d18f4f50a8acf81489" translate="yes" xml:space="preserve">
          <source>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</source>
          <target state="translated">Redux의 장점 중 하나는 상태 변경을 예측 가능하고 투명하게 만드는 것입니다. 조치가 발송 될 때마다 새 상태가 계산되어 저장됩니다. 국가 자체는 변할 수 없으며 특정 행동의 결과로만 변할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b05c40a81c382d7e1e4c5eb83c383c8c7dded6ae" translate="yes" xml:space="preserve">
          <source>One of the key advantages of immutability is that it enables shallow equality checking, which dramatically improves performance.</source>
          <target state="translated">불변성의 주요 장점 중 하나는 얕은 동등성 검사가 가능하여 성능이 크게 향상된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="850c598dddd960ff8dafd82d078c789192dada81" translate="yes" xml:space="preserve">
          <source>Operating on JavaScript objects and arrays in an immutable way can be slow, particularly as your state tree grows larger.</source>
          <target state="translated">특히 상태 트리가 커질수록 JavaScript 객체 및 배열에서 변경 불가능한 방식으로 작동하는 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6c37b39bb6ed10d58088845d5a93da150bef3c" translate="yes" xml:space="preserve">
          <source>Operations like &quot;Look up all books by this author&quot; can then accomplished with a single loop over the join table. Given the typical amounts of data in a client application and the speed of Javascript engines, this kind of operation is likely to have sufficiently fast performance for most use cases.</source>
          <target state="translated">그런 다음 &quot;이 저자의 모든 책 조회&quot;와 같은 작업은 조인 테이블을 단일 루프로 수행 할 수 있습니다. 클라이언트 응용 프로그램의 일반적인 데이터 양과 Javascript 엔진의 속도를 고려할 때 이러한 종류의 작업은 대부분의 사용 사례에서 충분히 빠른 성능을 발휘할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7d7275da2d9aaca178d7f0589e207de7175f18" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a59e4840cfb59b6c79325bf664a6e38968716f6" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b1b65f5915920208d15bbc3e393183be7f4d31d" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e36463d35299a6a01ac3b467e7d9564b1281179e" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b45aa8dcd97522495289719a1a18c6bc3300442" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0e47b777f4c49cec0992d3e10c918d3a72df107" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="238eb2632136a6f032d42bfad2c07321a67db57b" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6685195fe8e2bc04892759da1650e9052a5de4a3" translate="yes" xml:space="preserve">
          <source>Or check out the &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;샌드 박스를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8370968834196c749ed73b6cfe92801e8117ab54" translate="yes" xml:space="preserve">
          <source>Or many granular histories so user can undo and redo actions in them independently:</source>
          <target state="translated">또는 많은 세분화 된 내역을 통해 사용자가 작업을 독립적으로 실행 취소 및 재실행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b392c8838a1573058a955eb668416b3dbbd0f9f" translate="yes" xml:space="preserve">
          <source>Or you can define separate types for them:</source>
          <target state="translated">또는 별도의 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0da4144d426fe2efff7bea61cbf27a014d43a17" translate="yes" xml:space="preserve">
          <source>Organizing Large React Applications</source>
          <target state="translated">대규모 반응 응용 프로그램 구성</target>
        </trans-unit>
        <trans-unit id="8ca854d46781915131c4b8db35d1de91075f652b" translate="yes" xml:space="preserve">
          <source>Organizing Normalized Data in State</source>
          <target state="translated">상태에서 정규화 된 데이터 구성</target>
        </trans-unit>
        <trans-unit id="34d16c8765f577c8baee06d396d90415855ba54d" translate="yes" xml:space="preserve">
          <source>Organizing State</source>
          <target state="translated">조직 상태</target>
        </trans-unit>
        <trans-unit id="077be78f1b3e88543b41122cb8c6c6f77f12b367" translate="yes" xml:space="preserve">
          <source>Other Approaches</source>
          <target state="translated">다른 접근법</target>
        </trans-unit>
        <trans-unit id="eebb2f9cdc2951c739e98100dec8f3363c3a726b" translate="yes" xml:space="preserve">
          <source>Other Components</source>
          <target state="translated">다른 구성 요소</target>
        </trans-unit>
        <trans-unit id="0b72b54d734e499b1f158ae8c13378ee3157b18a" translate="yes" xml:space="preserve">
          <source>Other side effects like generating unique IDs or timestamps in a reducer also make the code unpredictable and harder to debug and test.</source>
          <target state="translated">감속기에서 고유 ID 또는 타임 스탬프 생성과 같은 다른 부작용으로 인해 코드를 예측할 수없고 디버그 및 테스트하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="fb937a0b9fb7519cc10c3b20032625261018ed28" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 이외 의 액션 객체의 구조는 실제로 당신에게 달려 있습니다. 관심이 있으시면 &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux 표준 조치&lt;/a&gt; 에서 조치 구성 방법에 대한 권장 사항을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6536268ad716d89a65f56ced3b4cc69350c48fb9" translate="yes" xml:space="preserve">
          <source>Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions should be constructed.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 이외 의 액션 객체의 구조는 실제로 당신에게 달려 있습니다. 관심이 있으시면 &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux 표준 조치&lt;/a&gt; 에서 조치 구성 방법에 대한 권장 사항을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d77d9e8f5844c5c74da60395774b58f7d3f5387d" translate="yes" xml:space="preserve">
          <source>Others, like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;불변성 헬퍼&lt;/a&gt; (현재 사용되지 않는 React Immutability Helpers 애드온의 포크) 와 같은 다른 것들은 중첩 된 값과 헬퍼 함수를 ​​사용합니다 :</target>
        </trans-unit>
        <trans-unit id="dda0bb30409a978c6095e977bd09a407e7ec0ccd" translate="yes" xml:space="preserve">
          <source>Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:</source>
          <target state="translated">우리의 앱 감속기는 여전히 우리의 응용 프로그램에 대한 모든 다른 경우를 알고 있습니다. 필터 로직과 할일 로직이 분리되도록 분할 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="57d76ff70a2b8d5f74ef5118abd52ad01b3bb657" translate="yes" xml:space="preserve">
          <source>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</source>
          <target state="translated">우리의 디자인 개요는 간단합니다. 할 일 항목 목록을 표시하려고합니다. 클릭하면 할 일 항목이 완료된 것으로 표시됩니다. 사용자가 새 할 일을 추가 할 수있는 필드를 표시하려고합니다. 바닥 글에는 모두, 완료 만 또는 활성 할 일만 표시하는 토글을 표시하려고합니다.</target>
        </trans-unit>
        <trans-unit id="53d2ee76615e0933562a889f329ff05a0a727e4c" translate="yes" xml:space="preserve">
          <source>Overall, Redux-ORM provides a very useful set of abstractions for defining relations between data types, creating the &quot;tables&quot; in our state, retrieving and denormalizing relational data, and applying immutable updates to relational data.</source>
          <target state="translated">전반적으로 Redux-ORM은 데이터 유형 간의 관계를 정의하고, 상태에서 &quot;테이블&quot;을 작성하고, 관계형 데이터를 검색 및 비정규 화하며, 관계형 데이터에 불변 업데이트를 적용하는 데 매우 유용한 추상화 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31d482d1d287457cca90cae82978407bee745dc3" translate="yes" xml:space="preserve">
          <source>PDF: JavaScript Immutability - Don&amp;rsquo;t go changing</source>
          <target state="translated">PDF : JavaScript 불변성-변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="430ea9730cf326c3cf262aa3e00acbc94a6af33d" translate="yes" xml:space="preserve">
          <source>Passing the Store</source>
          <target state="translated">가게 통과</target>
        </trans-unit>
        <trans-unit id="acae9ab8b8cf95f09e38c1fb61c7e7375972f22f" translate="yes" xml:space="preserve">
          <source>Patrons</source>
          <target state="translated">Patrons</target>
        </trans-unit>
        <trans-unit id="d9b870a4eca18252d7bd7d9da857129a2bd3ed18" translate="yes" xml:space="preserve">
          <source>Perform side effects like API calls and routing transitions;</source>
          <target state="translated">API 호출 및 라우팅 전환과 같은 부작용을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="09c0613fe519089a7fc506820537146b438f0dc9" translate="yes" xml:space="preserve">
          <source>Pete Hunt, one of the early contributors to React, says:</source>
          <target state="translated">React의 초기 기여자 중 하나 인 Pete Hunt는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="518776dd7f483eb0d4df7b1bd43c6cdb73104192" translate="yes" xml:space="preserve">
          <source>Poor Performance</source>
          <target state="translated">불쌍한 성능</target>
        </trans-unit>
        <trans-unit id="9993816052f22041086b70cb5e1a32b14dfbb33d" translate="yes" xml:space="preserve">
          <source>Practical Redux, Part 6: Connected Lists, Forms, and Performance</source>
          <target state="translated">실용 Redux, 6 부 : 연결된 목록, 양식 및 성능</target>
        </trans-unit>
        <trans-unit id="738c6f9450a7465416076aa7cb2f7dbc8ca7bcb4" translate="yes" xml:space="preserve">
          <source>Preparing the Initial State</source>
          <target state="translated">초기 상태 준비</target>
        </trans-unit>
        <trans-unit id="02510af1c9e56dc9bd70dc87dc84e81b435ad642" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts</source>
          <target state="translated">전제 조건 개념</target>
        </trans-unit>
        <trans-unit id="69ac187c979012e887601c19566c66ee6ab15258" translate="yes" xml:space="preserve">
          <source>Prerequisite Concepts for Writing Reducers</source>
          <target state="translated">감속기를 작성하기위한 전제 조건 개념</target>
        </trans-unit>
        <trans-unit id="1c55cdda21f1ad5ea1b98437db0236145dd69099" translate="yes" xml:space="preserve">
          <source>Prerequisite Reducer Concepts</source>
          <target state="translated">전제 조건 감속기 개념</target>
        </trans-unit>
        <trans-unit id="b3ed0c728475ae7dfeea9ed4c1bc0af7c27941d6" translate="yes" xml:space="preserve">
          <source>Presentational Components</source>
          <target state="translated">프리젠 테이션 컴포넌트</target>
        </trans-unit>
        <trans-unit id="69e7885b45c24e48f26b3abc065d13744594de0a" translate="yes" xml:space="preserve">
          <source>Presentational and Container Components</source>
          <target state="translated">프리젠 테이션 및 컨테이너 구성 요소</target>
        </trans-unit>
        <trans-unit id="f184d44b598b788adde29d493e92a5c25b0ed0b5" translate="yes" xml:space="preserve">
          <source>Prior Art</source>
          <target state="translated">선행 기술</target>
        </trans-unit>
        <trans-unit id="9cb3636454de25708139a72d5a8daebcbab292a1" translate="yes" xml:space="preserve">
          <source>Problem: Crash Reporting</source>
          <target state="translated">문제 : 충돌보고</target>
        </trans-unit>
        <trans-unit id="4367434447e2cee1f6e98eeb1e8d7bc393e9ff67" translate="yes" xml:space="preserve">
          <source>Problem: Logging</source>
          <target state="translated">문제 : 로깅</target>
        </trans-unit>
        <trans-unit id="55ebe517b50c8c6c3d52435b9681b506cd9eed36" translate="yes" xml:space="preserve">
          <source>Processing Request Parameters</source>
          <target state="translated">요청 매개 변수 처리</target>
        </trans-unit>
        <trans-unit id="71d526269be49e8a2200a08466e2a7f151fbcce6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability With React</source>
          <target state="translated">불변성을 리 액트와 함께 사용하는 장단점</target>
        </trans-unit>
        <trans-unit id="4be452a463fb3cf62c5a4a03fdd906246f9e80cd" translate="yes" xml:space="preserve">
          <source>Pros and Cons of Using Immutability with React</source>
          <target state="translated">불변성을 React와 함께 사용하는 장단점</target>
        </trans-unit>
        <trans-unit id="dc98b8947b98b64aa54d5357f558ae0935c47d87" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js</source>
          <target state="translated">React.js와 함께 불변성을 사용하는 장단점</target>
        </trans-unit>
        <trans-unit id="d6e73fb000c8b75a17c1069b0079cbf4bdde15b6" translate="yes" xml:space="preserve">
          <source>Pros and Cons of using immutability with React.js - React Kung Fu</source>
          <target state="translated">React.js와 함께 불변성을 사용하는 장단점-React Kung Fu</target>
        </trans-unit>
        <trans-unit id="21cf88ab38b25368d2f9cb3c579e6a17bc644483" translate="yes" xml:space="preserve">
          <source>Pure Functions and Side Effects</source>
          <target state="translated">순수한 기능과 부작용</target>
        </trans-unit>
        <trans-unit id="86a07cd587b106a4018fbf8dbee2dbdcf791f1eb" translate="yes" xml:space="preserve">
          <source>Pure functionality and side effects in Redux</source>
          <target state="translated">Redux의 순수한 기능 및 부작용</target>
        </trans-unit>
        <trans-unit id="82a325d136b15dd1db828b5e748b6d37453db386" translate="yes" xml:space="preserve">
          <source>Pure functions</source>
          <target state="translated">순수한 기능</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ea644ff66049122da6969531a96ca0fe72184b08" translate="yes" xml:space="preserve">
          <source>Querying a Redux Store</source>
          <target state="translated">Redux 저장소 쿼리</target>
        </trans-unit>
        <trans-unit id="55075a14cfbfc51a035aba7e61a80df40309acdd" translate="yes" xml:space="preserve">
          <source>Rails-style: separate folders for &amp;ldquo;actions&amp;rdquo;, &amp;ldquo;constants&amp;rdquo;, &amp;ldquo;reducers&amp;rdquo;, &amp;ldquo;containers&amp;rdquo;, and &amp;ldquo;components&amp;rdquo;</source>
          <target state="translated">Rails 스타일 :&amp;ldquo;actions&amp;rdquo;,&amp;ldquo;constants&amp;rdquo;,&amp;ldquo;reducers&amp;rdquo;,&amp;ldquo;containers&amp;rdquo;및&amp;ldquo;components&amp;rdquo;를위한 별도의 폴더</target>
        </trans-unit>
        <trans-unit id="45a38418ad120f3d535295f729a198b3b7c6c8d7" translate="yes" xml:space="preserve">
          <source>React Boilerplate #27: Application Structure</source>
          <target state="translated">반응 판 # 27 : 응용 구조</target>
        </trans-unit>
        <trans-unit id="efc78471488cf3d2e323b930c4ab2275310bd60b" translate="yes" xml:space="preserve">
          <source>React Forums: Redux and global state vs local state</source>
          <target state="translated">반응 포럼 : Redux 및 글로벌 상태 대 로컬 상태</target>
        </trans-unit>
        <trans-unit id="214641af7b84dcf096934eb2a695cb6d024aae3a" translate="yes" xml:space="preserve">
          <source>React Higher Order Components in depth</source>
          <target state="translated">고차 부품에 대한 심층 반응</target>
        </trans-unit>
        <trans-unit id="01d8e1cb3dcc43b6aac331fa4ddc4ac02aff9465" translate="yes" xml:space="preserve">
          <source>React How-To</source>
          <target state="translated">반응 방법</target>
        </trans-unit>
        <trans-unit id="c00f59a0285f84558e8d0d48133c22e6b6f706e6" translate="yes" xml:space="preserve">
          <source>React Redux</source>
          <target state="translated">리덕스 반응</target>
        </trans-unit>
        <trans-unit id="e9ec3cce75743443bbba2142d270fc34d79b7599" translate="yes" xml:space="preserve">
          <source>React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</source>
          <target state="translated">Redux # 145 반응 : mapDispatchToProps의 기능에 관계없이 항상 디스패치를 ​​전달하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="732e7a5dfabaa54435e980f9e805a54c93e2dd29" translate="yes" xml:space="preserve">
          <source>React Redux #235: Predicate function for updating component</source>
          <target state="translated">React Redux # 235 : 컴포넌트 업데이트를위한 술어 함수</target>
        </trans-unit>
        <trans-unit id="01a98dba508a8efb62a16078cc6efb83597ba734" translate="yes" xml:space="preserve">
          <source>React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</source>
          <target state="translated">반응 Redux # 255 : mapDispatchToProps를 사용하는 경우 this.props.dispatch는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="287e83661d0b0ace70aa4b2e7cbc6e6a0b50d186" translate="yes" xml:space="preserve">
          <source>React Redux #263: Huge performance issue when dispatching hundreds of actions</source>
          <target state="translated">Redux # 263 반응 : 수백 가지 작업을 디스패치 할 때 성능 문제</target>
        </trans-unit>
        <trans-unit id="2aea4e5f490054875b5d85d349369a3658b249ef" translate="yes" xml:space="preserve">
          <source>React Redux #269: Connect could be used with a custom subscribe method</source>
          <target state="translated">React Redux # 269 : Connect는 커스텀 subscribe 메소드와 함께 사용될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bbdb52200c9c3640fa284dd7801b308c292acc73" translate="yes" xml:space="preserve">
          <source>React Redux #291: Should mapStateToProps be called every time an action is dispatched?</source>
          <target state="translated">반응 Redux # 291 : 액션이 전달 될 때마다 mapStateToProps를 호출해야합니까?</target>
        </trans-unit>
        <trans-unit id="ca17da9174a409f3ef37d08c9748a93925d108fc" translate="yes" xml:space="preserve">
          <source>React Redux #407: Rewrite connect to offer an advanced API</source>
          <target state="translated">React Redux # 407 : 고급 API를 제공하기 위해 Rewrite connect</target>
        </trans-unit>
        <trans-unit id="4e611799527e4e43143ed34634f793cd5a162cf1" translate="yes" xml:space="preserve">
          <source>React Redux #416: Rewrite connect for better performance and extensibility</source>
          <target state="translated">Reux Redux # 416 : 성능 및 확장 성을 향상시키기 위해 Rewrite 연결</target>
        </trans-unit>
        <trans-unit id="3f31b465a1a05e3ab0e22b96c59d09ee25c33ef2" translate="yes" xml:space="preserve">
          <source>React Redux #89: can i wrap multi actionCreators into one props with name?</source>
          <target state="translated">Reux Redux # 89 : 멀티 actionCreator를 이름을 가진 하나의 소품으로 포장 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fa04ceff7eca5e570aecaefd3ee71f236ce6eb9f" translate="yes" xml:space="preserve">
          <source>React Redux API: connect()</source>
          <target state="translated">Redux API 반응 : connect ()</target>
        </trans-unit>
        <trans-unit id="5fffe16c96023bbe3dd9abec1447678a45a147c0" translate="yes" xml:space="preserve">
          <source>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt; arguments passed to &lt;code&gt;connect&lt;/code&gt;. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time &lt;code&gt;mapStateToProps&lt;/code&gt; is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</source>
          <target state="translated">React Redux는 실제 구성 요소가 실제로 필요할 때만 다시 렌더링 할 수 있도록 몇 가지 최적화를 구현합니다. 그중 하나는 &lt;code&gt;connect&lt;/code&gt; 에 전달 된 &lt;code&gt;mapStateToProps&lt;/code&gt; 및 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 인수에 의해 생성 된 결합 된 props 객체에 대한 얕은 동등성 검사입니다 . 불행하게도 &lt;code&gt;mapStateToProps&lt;/code&gt; 가 호출 될 때마다 새 배열 또는 객체 인스턴스가 생성되는 경우 얕은 동등성이 도움이되지 않습니다 . 일반적인 예는 ID 배열을 매핑하고 다음과 같은 일치하는 객체 참조를 반환하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b3923afd4f9b76fbadb161e5309fe47c5935c89" translate="yes" xml:space="preserve">
          <source>React Redux: Troubleshooting</source>
          <target state="translated">반응 Redux : 문제 해결</target>
        </trans-unit>
        <trans-unit id="7cf84f305d9b4ae3d2e5899504cef59f17174eb6" translate="yes" xml:space="preserve">
          <source>React Router comes with a &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt;&lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt;&lt;/a&gt; component that lets you navigate around your application. In our example, we can wrap &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; with a new container component &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; so as to dynamically change the URL. The &lt;code&gt;activeStyle={}&lt;/code&gt; property lets us apply a style on the active state.</source>
          <target state="translated">React Router에는 응용 프로그램을 탐색 할 수 있는 &lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/v3/docs/API.md#link&quot;&gt; &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; &lt;/a&gt; 구성 요소가 제공됩니다. 이 예에서는 URL을 동적으로 변경하기 위해 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 를 새 컨테이너 구성 요소 &lt;code&gt;&amp;lt;FilterLink /&amp;gt;&lt;/code&gt; 로 랩핑 할 수 있습니다 . &lt;code&gt;activeStyle={}&lt;/code&gt; 속성은 우리가 활성 상태에 스타일을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="679ef62ec4985a413831aad6d5f132c1e1b0074f" translate="yes" xml:space="preserve">
          <source>React bindings for Redux embrace the idea of &lt;strong&gt;separating presentational and container components&lt;/strong&gt;. If you're not familiar with these terms, &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;read about them first&lt;/a&gt;, and then come back. They are important, so we'll wait!</source>
          <target state="translated">Redux에 대한 반응 바인딩은 &lt;strong&gt;프리젠 테이션 및 컨테이너 컴포넌트&lt;/strong&gt; 를 &lt;strong&gt;분리&lt;/strong&gt; 한다는 아이디어를 수용합니다 . 이 용어에 익숙하지 않은 경우 먼저 해당 용어를 &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&quot;&gt;읽은&lt;/a&gt; 다음 다시 오십시오. 그것들은 중요하므로 기다릴 것입니다!</target>
        </trans-unit>
        <trans-unit id="cd703ea889752160be52204476a7e5217587c640" translate="yes" xml:space="preserve">
          <source>React-Redux Bindings</source>
          <target state="translated">반응 리덕스 바인딩</target>
        </trans-unit>
        <trans-unit id="720534ae4ea5a2a18f4bb7bfe9ed16ef3bef02de" translate="yes" xml:space="preserve">
          <source>React-Redux performs a shallow equality check on on each &lt;em&gt;value&lt;/em&gt; within the props object, not on the props object itself.</source>
          <target state="translated">React-Redux 는 props 객체 자체가 아닌 props 객체 내의 각 &lt;em&gt;값&lt;/em&gt; 에 대해 얕은 동등성 검사를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="9a3b307a7afe13dcc2d2b56d385f6e7fcdd89e12" translate="yes" xml:space="preserve">
          <source>React-Redux therefore maintains separate references to each &lt;em&gt;value&lt;/em&gt; in the returned props object.</source>
          <target state="translated">따라서 React-Redux 는 반환 된 props 객체의 각 &lt;em&gt;값&lt;/em&gt; 에 대한 별도의 참조를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="a84961e51f0e9045534f55ef19c9b890ec0454dc" translate="yes" xml:space="preserve">
          <source>React-Redux uses shallow equality checking to determine whether the component it&amp;rsquo;s wrapping needs to be re-rendered.</source>
          <target state="translated">React-Redux는 얕은 동등성 검사를 사용하여 랩핑하는 구성 요소를 다시 렌더링해야하는지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="25f69fafc4d53ef37a01d27855717f1b910c32ee" translate="yes" xml:space="preserve">
          <source>React-Redux's &lt;code&gt;connect&lt;/code&gt; method generates components that &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;shallowly check reference changes to the root state&lt;/a&gt;, and the return values from the &lt;code&gt;mapStateToProps&lt;/code&gt; function to see if the wrapped components actually need to re-render. Such &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;shallow checking requires immutability&lt;/a&gt; to function correctly.</source>
          <target state="translated">React-Redux의 &lt;code&gt;connect&lt;/code&gt; 메소드 &lt;a href=&quot;#how-react-redux-uses-shallow-checking&quot;&gt;는 루트 상태에 대한 참조 변경 사항을 얕게 확인&lt;/a&gt; 하는 구성 요소를 생성 하고 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수 의 반환 값 은 래핑 된 구성 요소를 실제로 다시 렌더링 해야하는지 확인합니다. 이러한 &lt;a href=&quot;#redux-shallow-checking-requires-immutability&quot;&gt;얕은 검사는&lt;/a&gt; 제대로 작동 하려면 불변성 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="7f4f4a56fd030dcfc889dad10f3ba7abdeb9bf09" translate="yes" xml:space="preserve">
          <source>React.js Pure Render Performance Anti-Pattern</source>
          <target state="translated">React.js 순수 렌더 성능 안티 패턴</target>
        </trans-unit>
        <trans-unit id="efcf558b2b7ed1ce931d4bbaf10d10e4a81b9190" translate="yes" xml:space="preserve">
          <source>React.js pure render performance anti-pattern</source>
          <target state="translated">React.js 순수 렌더링 성능 안티 패턴</target>
        </trans-unit>
        <trans-unit id="a6c84930df2d0caae45068e630cc45ccf1245b86" translate="yes" xml:space="preserve">
          <source>React/Redux Links: &quot;Redux Side Effects&quot; category</source>
          <target state="translated">반응 / Redux 링크 : &quot;Redux 부작용&quot;카테고리</target>
        </trans-unit>
        <trans-unit id="e7b97ce28bebc20ce4023d4d1544d8ca708ac055" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Project File Structure</source>
          <target state="translated">반응 / Redux 링크 : 아키텍처-프로젝트 파일 구조</target>
        </trans-unit>
        <trans-unit id="799adc6d5d994e504c2c138e4ff53248644d5147" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Architecture - Redux Architecture</source>
          <target state="translated">리 액트 / 리덕스 링크 : 아키텍처-Redux 아키텍처</target>
        </trans-unit>
        <trans-unit id="f700891537e9332e39007ef543a0c7005ac696ee" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Immutable Data</source>
          <target state="translated">반응 / Redux 링크 : 불변 데이터</target>
        </trans-unit>
        <trans-unit id="fce00908db372392230a5dc59966f0556c9a96b3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux</source>
          <target state="translated">반응 / Redux 링크 : 성능-Redux</target>
        </trans-unit>
        <trans-unit id="ea6624400dd0619a4028a0782161b341f95b9bf3" translate="yes" xml:space="preserve">
          <source>React/Redux Links: Performance - Redux Performance</source>
          <target state="translated">반응 / Redux 링크 : 성능-Redux 성능</target>
        </trans-unit>
        <trans-unit id="11abaa387b4e1d4c6df486f331bca1593b96648d" translate="yes" xml:space="preserve">
          <source>React/Redux Links: React/Redux Performance</source>
          <target state="translated">반응 / Redux 링크 : 반응 / Redux 성능</target>
        </trans-unit>
        <trans-unit id="86308254ca58c32a4b48e2e7a927c0057319908d" translate="yes" xml:space="preserve">
          <source>React: Higher-Order Components</source>
          <target state="translated">반응 : 고차 부품</target>
        </trans-unit>
        <trans-unit id="2d90bde2bec2c8fa094a1d2200ae82033494cad5" translate="yes" xml:space="preserve">
          <source>React: Optimizing Performance</source>
          <target state="translated">반응 : 성능 최적화</target>
        </trans-unit>
        <trans-unit id="7d9c1b09aeb1d155202a538eba6d9a3492931ad1" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;asyncflow&quot;&gt;Async Flow&lt;/a&gt; to recap how async actions fit into the Redux flow.</source>
          <target state="translated">읽기 &lt;a href=&quot;asyncflow&quot;&gt;비동기 흐름&lt;/a&gt; 요약하자면 비동기 작업은 돌아 오는 흐름에 맞는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b607ca1ed943113b8bd40acd28ee479c753558db" translate="yes" xml:space="preserve">
          <source>Read data from props</source>
          <target state="translated">소품에서 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="99172ffcab6825648dfba7e3fc262a9a5fbe7648" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;exampletodolist&quot;&gt;complete source code for this tutorial&lt;/a&gt; to better internalize the knowledge you have gained. Then, head straight to the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle network requests and routing!</source>
          <target state="translated">&lt;a href=&quot;exampletodolist&quot;&gt;이 학습서&lt;/a&gt; 의 전체 소스 코드를 읽고 얻은 지식을보다 잘 내부화하십시오. 그런 다음 &lt;a href=&quot;../advanced/index&quot;&gt;고급 자습서&lt;/a&gt; 로 바로 이동하여 네트워크 요청 및 라우팅을 처리하는 방법을 배우십시오!</target>
        </trans-unit>
        <trans-unit id="b21e1ed4d5217309315f564ff74b9eea1936e93c" translate="yes" xml:space="preserve">
          <source>Reading From the URL</source>
          <target state="translated">URL에서 읽기</target>
        </trans-unit>
        <trans-unit id="095c451a2e9ce2021d38bf795774b05403fc75f1" translate="yes" xml:space="preserve">
          <source>Real World</source>
          <target state="translated">현실 세계</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="42624a20e6e4c1562537410bf82ff591ce07f160" translate="yes" xml:space="preserve">
          <source>Recipes: Computed Derived Data</source>
          <target state="translated">레시피 : 계산 된 파생 데이터</target>
        </trans-unit>
        <trans-unit id="b6d39d52a5e86324ade1d44e7e08ce0b5387e017" translate="yes" xml:space="preserve">
          <source>Recipes: Computing Derived Data</source>
          <target state="translated">레시피 : 파생 데이터 계산</target>
        </trans-unit>
        <trans-unit id="5effb0f63ab3eb21c89f18e6368e7c1d5f17c3ac" translate="yes" xml:space="preserve">
          <source>Recipes: Immutable Update Patterns</source>
          <target state="translated">레시피 : 변경 불가능한 업데이트 패턴</target>
        </trans-unit>
        <trans-unit id="cbeb9b0f5422b15a6d088c47aaf6e528d0350c4c" translate="yes" xml:space="preserve">
          <source>Recipes: Prerequisite Reducer Concepts</source>
          <target state="translated">조리법 : 전제 조건 감속기 개념</target>
        </trans-unit>
        <trans-unit id="49a1f34779a5afe85e05cff662577501366300bb" translate="yes" xml:space="preserve">
          <source>Recipes: Reducing Boilerplate</source>
          <target state="translated">조리법 : 보일러 플레이트 줄이기</target>
        </trans-unit>
        <trans-unit id="8c1f469e59e4322a9cb07ef58ade84919608d01c" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers</source>
          <target state="translated">조리법 : 구조화 감속기</target>
        </trans-unit>
        <trans-unit id="29196f40d836acaf77c762f6f7580bf65b85cab3" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Immutable Update Patterns</source>
          <target state="translated">레시피 : 감속기 구조화-변경 불가능한 업데이트 패턴</target>
        </trans-unit>
        <trans-unit id="cb76eaeb79f5b86547d0360e4948f5f88d59b72d" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Normalizing State Shape</source>
          <target state="translated">레시피 : 구조화 감속기-상태 모양 정규화</target>
        </trans-unit>
        <trans-unit id="e9e51b9812b2e58af4823344e551de6481db8b1b" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Prerequisite Concepts</source>
          <target state="translated">조리법 : 감속기 구조화-전제 조건 개념</target>
        </trans-unit>
        <trans-unit id="d8db7ccea3429c3219a46b29a7fb105658ffffce" translate="yes" xml:space="preserve">
          <source>Recipes: Structuring Reducers - Splitting Reducer Logic</source>
          <target state="translated">조리법 : 구조화 감속기-분할 감속기 논리</target>
        </trans-unit>
        <trans-unit id="e29b3bc65e2933e5a918d6357b2967374e89998f" translate="yes" xml:space="preserve">
          <source>Recipes: Using the Object Spread Operator</source>
          <target state="translated">레시피 : 객체 확산 연산자 사용</target>
        </trans-unit>
        <trans-unit id="3b66d7a1f117e84d49ce190a144bfa4013537819" translate="yes" xml:space="preserve">
          <source>Recipes: immutability, side effects and mutation</source>
          <target state="translated">조리법 : 불변성, 부작용 및 돌연변이</target>
        </trans-unit>
        <trans-unit id="f0284a396b98e7ed88f256c52e6515c77bb1b45d" translate="yes" xml:space="preserve">
          <source>Reddit: &quot;When should I put something into my Redux store?&quot;</source>
          <target state="translated">Reddit : &quot;언제 Redux 매장에 무엇을 넣어야합니까?&quot;</target>
        </trans-unit>
        <trans-unit id="daca44adc4ef60f42583641246276d004e688c4b" translate="yes" xml:space="preserve">
          <source>Reddit: Help designing Redux state for a single page app</source>
          <target state="translated">Reddit : 단일 페이지 앱에 대한 Redux 상태 디자인을 도와줍니다</target>
        </trans-unit>
        <trans-unit id="afe887e317c898f703e24f7d827235e7f21d4918" translate="yes" xml:space="preserve">
          <source>Reddit: Help performing Async API calls with Redux-Promise Middleware.</source>
          <target state="translated">Reddit : Redux-Promise Middleware로 비동기 API 호출을 수행하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="15ccb05f9d496bf9727d87cee8b1f71f8bdbfba0" translate="yes" xml:space="preserve">
          <source>Reddit: Large open source react/redux projects?</source>
          <target state="translated">Reddit : 대규모 오픈 소스 반응 / redux 프로젝트?</target>
        </trans-unit>
        <trans-unit id="31b5fcaedfa00391f0da82305fa9d9c465e145ba" translate="yes" xml:space="preserve">
          <source>Reddit: React/Redux for Ultra Large Scale apps</source>
          <target state="translated">Reddit : 초대형 앱을위한 React / Redux</target>
        </trans-unit>
        <trans-unit id="dc41eb745ff0afdeef230ca621cfd49d330d77d6" translate="yes" xml:space="preserve">
          <source>Reddit: Redux performance issues with a large state object?</source>
          <target state="translated">Reddit : 상태 개체가 큰 Redux 성능 문제가 있습니까?</target>
        </trans-unit>
        <trans-unit id="ad1dcdbc206f62d81049e1fbbc24d1b99f39b065" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep initial state?</source>
          <target state="translated">레딧 : 초기 상태를 유지하는 가장 좋은 곳은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="216d6244581ce722d2b213f82dbff87a6148139c" translate="yes" xml:space="preserve">
          <source>Reddit: What's the best place to keep the initial state?</source>
          <target state="translated">레딧 : 초기 상태를 유지하는 가장 좋은 곳은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6473c3e5bd0f3e386d368c764bc6cec02354577e" translate="yes" xml:space="preserve">
          <source>Reddit: Why Redux Needs Reducers To Be Pure Functions</source>
          <target state="translated">Reddit : Redux에서 리듀서가 순수한 기능을 갖기 위해 필요한 이유</target>
        </trans-unit>
        <trans-unit id="05ce1169a192ae766ca0f1d7c50a759c7c51974e" translate="yes" xml:space="preserve">
          <source>Reddit: You don't need Redux if your app just fetches something on a single page</source>
          <target state="translated">Reddit : 앱이 단일 페이지에서 무언가를 가져 오는 경우 Redux가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cffbc53fcadf1ea0dddef2d232230038efb6dd3c" translate="yes" xml:space="preserve">
          <source>Reddit: acemarke and cpsubrian comments on Dan Abramov: Redux is not an architecture or design pattern, it is just a library.</source>
          <target state="translated">Reddit : Dan Abramov에 대한 acemarke 및 cpsubrian 의견 : Redux는 아키텍처 또는 디자인 패턴이 아니라 라이브러리 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="59ce6f6beebd57025f07ecd7d9c06fc4781ffca1" translate="yes" xml:space="preserve">
          <source>Reducer</source>
          <target state="translated">Reducer</target>
        </trans-unit>
        <trans-unit id="1b526057cc1ef5812f4ada08c7de94063561f436" translate="yes" xml:space="preserve">
          <source>Reducer Concepts and Techniques</source>
          <target state="translated">감속기 개념과 기법</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="840f7767cb01214ba0a12025998a85422ab6e283" translate="yes" xml:space="preserve">
          <source>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</source>
          <target state="translated">감속기는 단지 이전 상태와 조치를 취하고 다음 상태를 리턴하는 순수한 함수입니다. 이전 상태를 변경하지 않고 새 상태 객체를 반환해야합니다. 단일 리듀서로 시작하여 앱이 성장함에 따라 상태 트리의 특정 부분을 관리하는 더 작은 리듀서로 분리 할 수 ​​있습니다. 감속기는 단지 기능이기 때문에 호출 순서를 제어하거나 추가 데이터를 전달하거나 페이지 매김과 같은 일반적인 작업에 재사용 가능한 감속기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96a29cc7551675123cb7f5294dd805e57df90ca1" translate="yes" xml:space="preserve">
          <source>Reducers are not unique to Redux&amp;mdash;they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">감속기는 Redux의 고유 기능이 아닙니다. 기능 프로그래밍의 기본 개념입니다. JavaScript와 같은 대부분의 비 기능 언어조차도 축소를위한 API가 내장되어 있습니다. JavaScript에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="693d4ec3dd35d12c94a5cb25d408b2e71be3d5b1" translate="yes" xml:space="preserve">
          <source>Reducers are the most important concept in Redux.</source>
          <target state="translated">감속기는 Redux에서 가장 중요한 개념입니다.</target>
        </trans-unit>
        <trans-unit id="493c42af719ab1cd4cc31be798bcf7e6648293eb" translate="yes" xml:space="preserve">
          <source>Reducing Boilerplate</source>
          <target state="translated">보일러 플레이트 감소</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="ec290bd2917cc3416af368d34f3c085a675f09e6" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Component State</source>
          <target state="translated">Redux 애드온 카탈로그 : 구성 요소 상태</target>
        </trans-unit>
        <trans-unit id="8290cc030aab4b8babf95fab40608d602458690f" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: DevTools - Component Update Monitoring</source>
          <target state="translated">Redux 애드온 카탈로그 : DevTools-구성 요소 업데이트 모니터링</target>
        </trans-unit>
        <trans-unit id="f07485fcebaac4a393292df3922516fc30d4bbca" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store - Change Subscriptions</source>
          <target state="translated">Redux 애드온 카탈로그 : 스토어-가입 변경</target>
        </trans-unit>
        <trans-unit id="a577b901e78ea650452597a6b1059b8084d2ebcb" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Store Change Subscriptions</source>
          <target state="translated">Redux 애드온 카탈로그 : 스토어 변경 구독</target>
        </trans-unit>
        <trans-unit id="a6d683688573717dedb09bb8c524dd092308d6bd" translate="yes" xml:space="preserve">
          <source>Redux Addons Catalog: Use Cases - Authentication</source>
          <target state="translated">Redux 애드온 카탈로그 : 사용 사례-인증</target>
        </trans-unit>
        <trans-unit id="9344d1305fa4b38f64ad8cebd9635fa2921b0e1a" translate="yes" xml:space="preserve">
          <source>Redux Best Practices</source>
          <target state="translated">Redux 모범 사례</target>
        </trans-unit>
        <trans-unit id="bfac34990e02b9e66cd0d6829d754be59da6a26f" translate="yes" xml:space="preserve">
          <source>Redux Docs: &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">Redux Docs : &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="114c170f090803b3e9b2bcc5c3a6e50beaeed134" translate="yes" xml:space="preserve">
          <source>Redux Docs: Implementing Undo History</source>
          <target state="translated">Redux Docs : 실행 취소 기록 구현</target>
        </trans-unit>
        <trans-unit id="9e6cb1adf2efb90cb6a27ea6a72f98f7ab473f85" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducers</source>
          <target state="translated">Redux Docs : 리듀서</target>
        </trans-unit>
        <trans-unit id="9d40a9cd844cea91b94b47ac94fa5330e9011c46" translate="yes" xml:space="preserve">
          <source>Redux Docs: Reducing Boilerplate</source>
          <target state="translated">Redux Docs : 보일러 플레이트 줄이기</target>
        </trans-unit>
        <trans-unit id="726708480591ce54144dc3645deedfceb6e02a27" translate="yes" xml:space="preserve">
          <source>Redux Docs: Using the Object Spread Operator</source>
          <target state="translated">Redux Docs : 객체 확산 연산자 사용</target>
        </trans-unit>
        <trans-unit id="43b86674da50a6ae9dfb143b4ed6cba4221221fc" translate="yes" xml:space="preserve">
          <source>Redux Egghead Course Notes</source>
          <target state="translated">Redux Egghead 코스 노트</target>
        </trans-unit>
        <trans-unit id="4428f96db39ca62c1587ebeaa693e35a74b127e5" translate="yes" xml:space="preserve">
          <source>Redux FAQ</source>
          <target state="translated">Redux FAQ</target>
        </trans-unit>
        <trans-unit id="d41715c0d155a118b9497d660d8d8ce21d26b4a2" translate="yes" xml:space="preserve">
          <source>Redux FAQ - How do I share state between two reducers? do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">Redux FAQ-두 리듀서간에 상태를 공유하려면 어떻게합니까? &lt;code&gt;combineReducers&lt;/code&gt; 를 사용해야 합니까 ?</target>
        </trans-unit>
        <trans-unit id="c491bee4fced1d7081108b5ad804a138bbbbd52e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Actions</source>
          <target state="translated">Redux FAQ : 조치</target>
        </trans-unit>
        <trans-unit id="d4e401fc452061ae23c6d3ded639c0139571e70a" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Code Structure</source>
          <target state="translated">Redux FAQ : 코드 구조</target>
        </trans-unit>
        <trans-unit id="b9dd7213b027596f3629ad531290ad9920e77526" translate="yes" xml:space="preserve">
          <source>Redux FAQ: General</source>
          <target state="translated">Redux FAQ : 일반</target>
        </trans-unit>
        <trans-unit id="0d53c1155526d25e48dcd19338cae9548715d564" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Immutable Data</source>
          <target state="translated">Redux FAQ : 변경 불가능한 데이터</target>
        </trans-unit>
        <trans-unit id="af79a6a6e3a5246c79d316570a87b7cf700c435e" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Miscellaneous</source>
          <target state="translated">Redux FAQ : 기타</target>
        </trans-unit>
        <trans-unit id="ac2ba19db266451829b5648e7675c23413cb2290" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Organizing State</source>
          <target state="translated">Redux FAQ : 상태 구성</target>
        </trans-unit>
        <trans-unit id="b775beb138a1c3fb7195b5b0df10ccb6b82fa87d" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Performance</source>
          <target state="translated">Redux FAQ : 성능</target>
        </trans-unit>
        <trans-unit id="a5b614caad88c44f368607bba25481b521bd85c6" translate="yes" xml:space="preserve">
          <source>Redux FAQ: React Redux</source>
          <target state="translated">Redux FAQ : 반응 Redux</target>
        </trans-unit>
        <trans-unit id="ef49df474a3cc851a7439d8e67a8e396e5ccf5d5" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Reducers</source>
          <target state="translated">Redux FAQ : 감속기</target>
        </trans-unit>
        <trans-unit id="24a41d53bd26e4da6f09186f3361b234ecd45560" translate="yes" xml:space="preserve">
          <source>Redux FAQ: Store Setup</source>
          <target state="translated">Redux FAQ : 매장 설정</target>
        </trans-unit>
        <trans-unit id="0102181826c0cb7d859681534988eee33484e834" translate="yes" xml:space="preserve">
          <source>Redux Patterns and Anti-Patterns</source>
          <target state="translated">리덕스 패턴 및 안티 패턴</target>
        </trans-unit>
        <trans-unit id="e73b59699c981c999e9ca3504f30fe27527addd7" translate="yes" xml:space="preserve">
          <source>Redux Reducer Basics</source>
          <target state="translated">Redux Reducer 기본 사항</target>
        </trans-unit>
        <trans-unit id="56891cb67a23a2b058baaee611e9e76e2ced8ffb" translate="yes" xml:space="preserve">
          <source>Redux Reducer/Selector Asymmetry</source>
          <target state="translated">산화 환원 감속기 / 선택기 비대칭</target>
        </trans-unit>
        <trans-unit id="d7f6bdcedeb4f02ba8baec4a6f623462b01e41d1" translate="yes" xml:space="preserve">
          <source>Redux Side-Effects and You</source>
          <target state="translated">Redux 부작용과 당신</target>
        </trans-unit>
        <trans-unit id="ec9ae2589e9681b8d5b9a2330255a41898aa3398" translate="yes" xml:space="preserve">
          <source>Redux Tutorial</source>
          <target state="translated">Redux 튜토리얼</target>
        </trans-unit>
        <trans-unit id="d6c0eff7c8b338ccc1a25decaa770c2ce1222c1c" translate="yes" xml:space="preserve">
          <source>Redux Without Profanity: Normalizr</source>
          <target state="translated">욕설없는 Redux : Normalizr</target>
        </trans-unit>
        <trans-unit id="37f4f3e1befc5ff99eacec66375e5105a07bde1d" translate="yes" xml:space="preserve">
          <source>Redux architecture revolves around a &lt;strong&gt;strict unidirectional data flow&lt;/strong&gt;.</source>
          <target state="translated">Redux 아키텍처는 &lt;strong&gt;엄격한 단방향 데이터 흐름을&lt;/strong&gt; 중심으로 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca8fd39e0f583c4771e3b7ab47147f9b7250d1ac" translate="yes" xml:space="preserve">
          <source>Redux assumes that you never mutate the objects it gives to you in the reducer. &lt;strong&gt;Every single time, you must return the new state object.&lt;/strong&gt; Even if you don't use a library like &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;, you need to completely avoid mutation.</source>
          <target state="translated">Redux는 감속기에서 사용자에게 제공하는 객체를 절대로 변경하지 않는다고 가정합니다. &lt;strong&gt;매번 새 상태 객체를 반환해야합니다. &lt;/strong&gt;&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; 과 같은 라이브러리를 사용하지 않더라도 돌연변이를 완전히 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9b13f4fc65014317fe6e4b9892befedf11af3bc" translate="yes" xml:space="preserve">
          <source>Redux can be described in three fundamental principles:</source>
          <target state="translated">Redux는 세 가지 기본 원칙으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="325d0a3329fe90a45278bb0a0417bd084002d235" translate="yes" xml:space="preserve">
          <source>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said, it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes, such as React or one of the similar libraries available.</source>
          <target state="translated">Redux는 모든 UI 계층의 데이터 저장소로 사용할 수 있습니다. 가장 일반적인 사용법은 React 및 React Native를 사용하지만 Angular, Angular 2, Vue, Mithril 등에 사용할 수있는 바인딩이 있습니다. Redux는 다른 코드에서 사용할 수있는 구독 메커니즘을 제공합니다. 즉, React 또는 사용 가능한 유사한 라이브러리 중 하나와 같은 상태 변경에서 UI 업데이트를 유추 할 수있는 선언적 뷰 구현과 결합 할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b52d3f31e7f26a9796dbdf1e3a68c3e4fb5e3992" translate="yes" xml:space="preserve">
          <source>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</source>
          <target state="translated">Redux는 작업 내역을 저장하지 않습니다. 그러나 Redux DevTools는 액션을 저장하여 재생할 수 있지만 일반적으로 개발 중에 만 활성화되며 프로덕션에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dbbf7352cc48a4f94b3a8d8faa33290b580cd67" translate="yes" xml:space="preserve">
          <source>Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the &quot;&lt;em&gt;state&lt;/em&gt;&quot; of your application, and the structure and organization of that state is typically referred to as its &quot;&lt;em&gt;shape&lt;/em&gt;&quot;. The shape of your state plays a major role in how you structure your reducer logic.</source>
          <target state="translated">Redux는 관리해야하는 데이터 측면에서 애플리케이션에 대해 생각하도록 권장합니다. 특정 시점의 데이터는 응용 프로그램 의 &quot; &lt;em&gt;상태&lt;/em&gt; &quot;이며 해당 상태의 구조와 구성은 일반적으로 &quot; &lt;em&gt;모양&lt;/em&gt; &quot;이라고합니다. 상태의 모양은 감속기 논리를 구성하는 방법에 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="0516f1b49c0332831cef6d046aead301f5a49142" translate="yes" xml:space="preserve">
          <source>Redux evolves the ideas of &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, but avoids its complexity by taking cues from &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm&lt;/a&gt;.</source>
          <target state="translated">Redux는 &lt;a href=&quot;http://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; 의 아이디어를 발전 시키지만 &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm의&lt;/a&gt; 신호를 받아 복잡성을 피합니다 .</target>
        </trans-unit>
        <trans-unit id="e3d9d039526eff2bcbbc1e2bb2c6ef489f1116bd" translate="yes" xml:space="preserve">
          <source>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We'll explore some of the similarities and the differences below.</source>
          <target state="translated">Redux는 혼합 된 유산을 가지고 있습니다. 일부 패턴 및 기술과 유사하지만 중요한 방식과 다릅니다. 아래에서 몇 가지 유사점과 차이점을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="08c2c8d16a217b7f149595bcdd911d990cf837d5" translate="yes" xml:space="preserve">
          <source>Redux is a predictable state container for JavaScript apps.</source>
          <target state="translated">Redux는 JavaScript 앱을위한 예측 가능한 상태 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="1658730b992fc25b0e570963398f980bbbac8597" translate="yes" xml:space="preserve">
          <source>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</source>
          <target state="translated">Redux는 작은 라이브러리이지만 계약 및 API는 툴과 확장의 에코 시스템을 생성하기 위해 신중하게 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="d0def49afc1d69e709f05c3918091a08540604e3" translate="yes" xml:space="preserve">
          <source>Redux is distributed with a few examples in its &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;source code&lt;/a&gt;. Most of these examples are also on &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt;, this is an online editor that lets you play with the examples online.</source>
          <target state="translated">Redux는 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples&quot;&gt;소스 코드&lt;/a&gt; 에 몇 가지 예제와 함께 배포됩니다 . 이러한 예제의 대부분은 &lt;a href=&quot;https://codesandbox.io&quot;&gt;CodeSandbox&lt;/a&gt; 에도 있으며 , 온라인 편집기로 예제를 온라인으로 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc1ca81429d291e4da182d33067adbc2146a5ff" translate="yes" xml:space="preserve">
          <source>Redux is in part &lt;a href=&quot;../introduction/priorart&quot;&gt;inspired by Flux&lt;/a&gt;, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</source>
          <target state="translated">Redux는 &lt;a href=&quot;../introduction/priorart&quot;&gt;Flux&lt;/a&gt; 에서 영감을 얻었으며 Flux 에 대한 가장 일반적인 불만은 많은 상용구를 작성하는 방법입니다. 이 레시피에서는 개인 스타일, 팀 환경 설정, 장기 유지 관리 성 등에 따라 Redux를 사용하여 코드를 얼마나 자세하게 표시할지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca9a51778106939cd3dfebf9551abdc4b16988e" translate="yes" xml:space="preserve">
          <source>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions &lt;em&gt;must&lt;/em&gt; always be pure functions of &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;. However, Redux's middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</source>
          <target state="translated">Redux는 기능적 프로그래밍에서 영감을 얻었으며 즉시 사용할 수 있으며 부작용을 실행할 수있는 곳이 없습니다. 특히 감속기 함수 &lt;em&gt;는&lt;/em&gt; 항상 &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 의 순수 함수 &lt;em&gt;여야합니다&lt;/em&gt; . 그러나 Redux의 미들웨어를 사용하면 디스패치 된 작업을 가로 챌 수 있으며 부작용을 포함하여 복잡한 동작을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e51cf296aaae20f776d432b753a50cb2d012fba" translate="yes" xml:space="preserve">
          <source>Redux is not a monolithic framework, but a set of contracts and a &lt;a href=&quot;../api/index&quot;&gt;few functions that make them work together&lt;/a&gt;. The majority of your &amp;ldquo;Redux code&amp;rdquo; will not even use Redux APIs, as most of the time you'll be writing functions.</source>
          <target state="translated">Redux는 모 놀리 식 프레임 워크가 아니라 계약 세트와 &lt;a href=&quot;../api/index&quot;&gt;함께 작동&lt;/a&gt; 하는 몇 가지 기능입니다 . 대부분의&amp;ldquo;Redux 코드&amp;rdquo;는 대부분 함수를 작성할 때 Redux API를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fa50b0cdd3b8374bae86ce4f34e3e66331618ca" translate="yes" xml:space="preserve">
          <source>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;counter-vanilla&lt;/a&gt; example demonstrates basic ES5 usage with Redux included as a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. As the relevant pull request says:</source>
          <target state="translated">Redux는 원래 ES6로 작성되었으며 Webpack 및 Babel을 사용하여 ES5로 프로덕션 용으로 변환되었습니다. JavaScript 빌드 프로세스에 관계없이 사용할 수 있어야합니다. 또한 Redux는 빌드 프로세스없이 직접 사용할 수있는 UMD 빌드를 제공합니다. &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;카운터 바닐라&lt;/a&gt; 예는 돌아 오는 기본적인 ES5 사용이 포함 보여줍니다 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그입니다. 관련 풀 요청에 따르면 :</target>
        </trans-unit>
        <trans-unit id="34fee0109b88a277c57526193a6d212f3a10d90d" translate="yes" xml:space="preserve">
          <source>Redux itself is very simple.</source>
          <target state="translated">Redux 자체는 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="42dce762d39e68e2336c77e1bc865792d15451f7" translate="yes" xml:space="preserve">
          <source>Redux may not be as efficient out of the box when compared to other libraries. For maximum rendering performance in a React application, state should be stored in a normalized shape, many individual components should be connected to the store instead of just a few, and connected list components should pass item IDs to their connected child list items (allowing the list items to look up their own data by ID). This minimizes the overall amount of rendering to be done. Use of memoized selector functions is also an important performance consideration.</source>
          <target state="translated">Redux는 다른 라이브러리와 비교할 때 기본적으로 효율적이지 않을 수 있습니다. React 애플리케이션에서 렌더링 성능을 극대화하려면 상태를 정규화 된 모양으로 저장해야하며 많은 개별 구성 요소를 몇 개가 아닌 저장소에 연결해야하며 연결된 목록 구성 요소는 항목 ID를 연결된 하위 목록 항목으로 전달해야합니다. ID별로 자신의 데이터를 조회 할 항목을 나열). 이렇게하면 전체 렌더링 양이 최소화됩니다. 메모 된 선택기 기능을 사용하는 것도 중요한 성능 고려 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3d50c81abd53c840945ee2fdbaa44b7467c60100" translate="yes" xml:space="preserve">
          <source>Redux middleware act like a linked list. Each middleware function can either call &lt;code&gt;next(action)&lt;/code&gt; to pass an action along to the next middleware in line, call &lt;code&gt;dispatch(action)&lt;/code&gt; to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</source>
          <target state="translated">Redux 미들웨어는 연결된 목록처럼 작동합니다. 각 미들웨어 함수는 &lt;code&gt;next(action)&lt;/code&gt; 을 호출 하여 조치를 다음 미들웨어에 한 줄로 &lt;code&gt;dispatch(action)&lt;/code&gt; , dispatch (action) 을 호출 하여 목록의 시작 부분에서 처리를 다시 시작하거나, 조치가 처리되는 것을 중지하기 위해 아무것도 수행하지 않을 수 있습니다. 더욱이.</target>
        </trans-unit>
        <trans-unit id="66a12ac42dd9b817c0a1c7e67e3311842a1c46e9" translate="yes" xml:space="preserve">
          <source>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. &lt;strong&gt;It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.&lt;/strong&gt; People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</source>
          <target state="translated">Redux 미들웨어는 Express 또는 Koa 미들웨어와는 다른 개념을 개념적으로 유사한 방식으로 해결합니다. &lt;strong&gt;작업 디스패치와 리듀서에 도달하는 순간 사이에 타사 확장 점을 제공합니다. &lt;/strong&gt;사람들은 로깅, 충돌보고, 비동기 API와의 대화, 라우팅 등에 Redux 미들웨어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="63d4a8adb65aae837c51967b76d09fff2ff98328" translate="yes" xml:space="preserve">
          <source>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row.</source>
          <target state="translated">Redux는 각 성공적으로 디스패치 된 조치 (즉, 조치가 상점에 도달하여 리듀서에 의해 처리 된 후)에 가입자에게 알립니다. 경우에 따라, 특히 활동 작성자가 여러 개의 개별 조치를 연속으로 디스패치하는 경우 구독자가 호출되는 횟수를 줄이는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e36bd6fb2ddfb9b618b443d363e9df585734103" translate="yes" xml:space="preserve">
          <source>Redux on the Server</source>
          <target state="translated">서버의 Redux</target>
        </trans-unit>
        <trans-unit id="321a21760687e7864fd03dec217ad326b52df5ef" translate="yes" xml:space="preserve">
          <source>Redux provides a single &lt;code&gt;store.subscribe&lt;/code&gt; method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument&amp;mdash;it is simply an indication that &lt;em&gt;something&lt;/em&gt; has changed. The subscriber logic can then call &lt;code&gt;getState()&lt;/code&gt; to get the current state value.</source>
          <target state="translated">Redux는 저장소가 업데이트되었음을 ​​리스너에게 알리기위한 단일 &lt;code&gt;store.subscribe&lt;/code&gt; 메소드를 제공합니다 . 리스너 콜백은 현재 상태를 인수로받지 않습니다. 이는 단순히 &lt;em&gt;무언가&lt;/em&gt; 가 변경 되었음을 나타냅니다 . 그런 다음 가입자 논리는 &lt;code&gt;getState()&lt;/code&gt; 를 호출 하여 현재 상태 값을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4319c52fd7a20695a4bdd02b2e2cc58d73b86bdf" translate="yes" xml:space="preserve">
          <source>Redux puts some basic constraints on how that write logic function should work. As described in &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, it has to have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, is known as a &lt;strong&gt;&lt;em&gt;reducer function&lt;/em&gt;&lt;/strong&gt;, and must be &lt;em&gt;pure&lt;/em&gt; and predictable.</source>
          <target state="translated">Redux는 쓰기 논리 기능의 작동 방식에 대한 몇 가지 기본 제약 조건을 제시합니다. &lt;a href=&quot;../basics/reducers&quot;&gt;Reducers에&lt;/a&gt; 설명 된대로 &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; 의 서명을 가져야 하고 &lt;strong&gt;&lt;em&gt;Reducer 함수&lt;/em&gt;&lt;/strong&gt; 라고 하며 &lt;em&gt;순수&lt;/em&gt; 하고 예측 가능 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="59977664d77ebcee933d545dac412554294aeaf2" translate="yes" xml:space="preserve">
          <source>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</source>
          <target state="translated">Redux는 업데이트 논리를 함수로 설명하여 Flux 상점의 상용구를 상당히 줄입니다. 함수는 객체보다 간단하고 클래스보다 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="402da21959ad1b00c3d1ab6f8adf5613dbe09688" translate="yes" xml:space="preserve">
          <source>Redux uses shallow equality checking in its &lt;code&gt;combineReducers&lt;/code&gt; function to return either a new mutated copy of the root state object, or, if no mutations have been made, the current root state object.</source>
          <target state="translated">Redux는 &lt;code&gt;combineReducers&lt;/code&gt; 함수 에서 얕은 동등성 검사를 사용 하여 루트 상태 객체의 새로운 돌연변이 사본을 반환하거나 돌연변이가없는 경우 현재 루트 상태 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc4318e83cc01aa898dd245b381a161bc5966ecd" translate="yes" xml:space="preserve">
          <source>Redux vs MobX TodoMVC Benchmark: #1</source>
          <target state="translated">Redux vs MobX TodoMVC 벤치 마크 : # 1</target>
        </trans-unit>
        <trans-unit id="6ad6e121085cd64eb499597e7144d3ad136b11ac" translate="yes" xml:space="preserve">
          <source>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (&amp;ldquo;stores&amp;rdquo; in Flux, &amp;ldquo;reducers&amp;rdquo; in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an &amp;ldquo;action&amp;rdquo;.</source>
          <target state="translated">Redux는 Flux의 몇 가지 중요한 특성에서 영감을 받았습니다. 플럭스와 마찬가지로, Redux는 모델 업데이트 로직을 특정 애플리케이션 계층 (Flux의 &quot;저장소&quot;, Redux의 &quot;리듀서&quot;)에 집중하도록 규정합니다. 응용 프로그램 코드가 데이터를 직접 변경하도록하는 대신, 모든 변이를 ​​&quot;조치&quot;라는 일반 객체로 설명하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="fdbb1f1c5606597f48f095414e66742812988218" translate="yes" xml:space="preserve">
          <source>Redux's &lt;code&gt;combineReducers&lt;/code&gt; utility &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;shallowly checks for reference changes&lt;/a&gt; caused by the reducers that it calls.</source>
          <target state="translated">Redux의 &lt;code&gt;combineReducers&lt;/code&gt; 유틸리티 &lt;a href=&quot;#how-redux-uses-shallow-checking&quot;&gt;는&lt;/a&gt; 호출하는 리듀서로 인한 참조 변경 사항을 얕게 검사 합니다.</target>
        </trans-unit>
        <trans-unit id="88595cd44ffbc83a4871c93314b71b115c573390" translate="yes" xml:space="preserve">
          <source>Redux's &lt;strong&gt;&lt;em&gt;only&lt;/em&gt;&lt;/strong&gt; job on the server side is to provide the &lt;strong&gt;initial state&lt;/strong&gt; of our app.</source>
          <target state="translated">서버 측에서 Redux의 &lt;strong&gt;&lt;em&gt;유일한&lt;/em&gt;&lt;/strong&gt; 작업은 앱 의 &lt;strong&gt;초기 상태&lt;/strong&gt; 를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d7eb32f60e5c70f3bc2c26ceb6005796e8b88abe" translate="yes" xml:space="preserve">
          <source>Redux's use of shallow equality checking requires immutability if any connected components are to be updated correctly. To see why, we need to understand the difference between shallow and deep equality checking in JavaScript.</source>
          <target state="translated">연결된 구성 요소를 올바르게 업데이트하려면 Redux의 얕은 동등성 검사를 사용하려면 불변성이 필요합니다. 이유를 확인하려면 JavaScript에서 균등 검사와 균등 검사의 차이점을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="143302841cb0d7dca0440bc31869328f76d81e32" translate="yes" xml:space="preserve">
          <source>Redux-ORM</source>
          <target state="translated">Redux-ORM</target>
        </trans-unit>
        <trans-unit id="7367376eab7e449568c0adff1f6f05f157d89179" translate="yes" xml:space="preserve">
          <source>Reduxible #8: Reducers and action creators aren't a one-to-one mapping</source>
          <target state="translated">Reduxible # 8 : 리듀서와 액션 제작자는 일대일 매핑이 아닙니다</target>
        </trans-unit>
        <trans-unit id="1ccd2c30250c1777fda07e84c391cdb978d5d1e8" translate="yes" xml:space="preserve">
          <source>Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition</source>
          <target state="translated">기능적 분해 및 감속기 구성을 사용한 리팩터링 감속기 로직</target>
        </trans-unit>
        <trans-unit id="7b4c884acfadf4ccd7e8f7f80505e0cb44517215" translate="yes" xml:space="preserve">
          <source>Refactoring Reducers Example</source>
          <target state="translated">리팩토링 리듀서 예제</target>
        </trans-unit>
        <trans-unit id="e0710cd8e6f7d93aaa10c5bd0b7c50d5a6a0ac74" translate="yes" xml:space="preserve">
          <source>Referring to items by IDs</source>
          <target state="translated">ID로 항목 참조</target>
        </trans-unit>
        <trans-unit id="35a045863630981b0a8f647ab7457dcd879ee624" translate="yes" xml:space="preserve">
          <source>Regardless of the specific data type, the shape of the undo history state is the same:</source>
          <target state="translated">특정 데이터 유형에 관계없이 실행 취소 히스토리 상태의 모양은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c899eec73f6b556d4b90d92d6ad1d39154a4b74c" translate="yes" xml:space="preserve">
          <source>Registers listeners via &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt; 를 통해 리스너를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="07072abd45ba7236bb3989cbd897b07eeac1c93b" translate="yes" xml:space="preserve">
          <source>Relationships and Tables</source>
          <target state="translated">관계 및 테이블</target>
        </trans-unit>
        <trans-unit id="f9da905dbbbb2d63041deb7197b587a590301a7b" translate="yes" xml:space="preserve">
          <source>Remember how we &lt;a href=&quot;reducers&quot;&gt;designed the shape of the root state object&lt;/a&gt;? It's time we design the UI hierarchy to match it. This is not a Redux-specific task. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;Thinking in React&lt;/a&gt; is a great tutorial that explains the process.</source>
          <target state="translated">&lt;a href=&quot;reducers&quot;&gt;루트 상태 객체의 모양을&lt;/a&gt; 어떻게 설계 했는지 기억 하십니까? UI 계층 구조를 설계 할 때가되었습니다. 이것은 Redux 관련 작업이 아닙니다. &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;React에서 생각&lt;/a&gt; 하는 것은 프로세스를 설명하는 훌륭한 튜토리얼입니다.</target>
        </trans-unit>
        <trans-unit id="956f2f6dcc69fefbba147a07801daf0bec3cb1a6" translate="yes" xml:space="preserve">
          <source>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</source>
          <target state="translated">감속기는 기능 일 뿐이므로 편안한 느낌으로 기능 구성과 고차 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186767200c580a2653e26a568dd78d79172ed4ba" translate="yes" xml:space="preserve">
          <source>Remember, to change an immutable object, you must mutate a &lt;em&gt;copy&lt;/em&gt; of it, and copying large objects can be slow as every property must be copied.</source>
          <target state="translated">불변 개체를 변경하려면 &lt;em&gt;복사본&lt;/em&gt; 을 변경 해야하며 모든 속성을 복사해야하므로 큰 개체를 복사하면 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14133871ccbb6d27982d438fb7486a531414b6e" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;first&lt;/em&gt; element from the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 에서 &lt;em&gt;첫 번째&lt;/em&gt; 요소를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="8db23b2ef380238e2a9332bbe7bb7805acafcd6f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;em&gt;last&lt;/em&gt; element from the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;past&lt;/code&gt; 에서 &lt;em&gt;마지막&lt;/em&gt; 요소를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6bae9950e29a13f58e366e00739630628accfbd" translate="yes" xml:space="preserve">
          <source>Replaces the reducer currently used by the store to calculate the state.</source>
          <target state="translated">상점에서 현재 상태를 계산하기 위해 사용하는 감속기를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e267d53c29587c8cde50b829af85bdaecdc01bb5" translate="yes" xml:space="preserve">
          <source>Reselect #47: Memoizing Hierarchical Selectors</source>
          <target state="translated">다시 선택 # 47 : 계층 선택기 메모</target>
        </trans-unit>
        <trans-unit id="d0e0bcc2864b7d77b721a68ce1600fd8bd2214df" translate="yes" xml:space="preserve">
          <source>Reselect Documentation: How do I use Reselect with Immutable.js?</source>
          <target state="translated">문서 재 선택 : Immutable.js에서 재 선택을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="c338cf732b237c24b1f0506400e28357d0f15bd3" translate="yes" xml:space="preserve">
          <source>Reselect provides a function &lt;code&gt;createSelector&lt;/code&gt; for creating memoized selectors. &lt;code&gt;createSelector&lt;/code&gt; takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</source>
          <target state="translated">재 선택은 메모리 화 된 선택기를 작성하기위한 &lt;code&gt;createSelector&lt;/code&gt; 기능을 제공합니다 . &lt;code&gt;createSelector&lt;/code&gt; 는 입력 선택기 배열과 변환 함수를 인수로 사용합니다. Redux 상태 트리가 입력 선택기의 값을 변경시키는 방식으로 변경되면 선택기는 입력 선택기의 값을 인수로 사용하여 변환 함수를 호출하고 결과를 반환합니다. 입력 선택기의 값이 이전 선택기 호출과 동일하면 변환 함수를 호출하는 대신 이전에 계산 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c51b3f2e5f8258e6431cab2fcee20d079a2248f" translate="yes" xml:space="preserve">
          <source>Reselect: Selector library for Redux</source>
          <target state="translated">다시 선택 : Redux 용 선택기 라이브러리</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="9845b29c661b5f09755c1a2c1a4a6d8ac8f795eb" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application.</source>
          <target state="translated">응용 프로그램의 현재 상태 트리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c935f384c6e4b3d5772f231b8837bf4689621ec3" translate="yes" xml:space="preserve">
          <source>Returns the current state tree of your application. It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">애플리케이션의 현재 상태 트리를 반환합니다. 저장소의 감속기가 반환 한 마지막 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be483740a1e90670b770a1abe4ce081d261c0d0a" translate="yes" xml:space="preserve">
          <source>Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</source>
          <target state="translated">Returns&lt;a href=&quot;#returns-2&quot;&gt;#&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b78505f9e7ca9beb942dcc8131c9189c9eeb998a" translate="yes" xml:space="preserve">
          <source>Reusing Reducer Logic</source>
          <target state="translated">감속기 로직 재사용</target>
        </trans-unit>
        <trans-unit id="0966cd2fd5d2cb35f03ce6b1bce5d1e7251e6744" translate="yes" xml:space="preserve">
          <source>Rich API</source>
          <target state="translated">리치 API</target>
        </trans-unit>
        <trans-unit id="a245bc64c38d63184404dacd3bd9f275e513df5f" translate="yes" xml:space="preserve">
          <source>Right now we are not passing anything to &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; so &lt;code&gt;ownProps&lt;/code&gt; is an empty object. To filter our todos according to the URL, we want to pass the URL params to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">지금 우리는 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 에 아무것도 전달하지 않으므로 &lt;code&gt;ownProps&lt;/code&gt; 는 빈 객체입니다. URL에 따라 할일을 필터링하기 위해 URL 매개 변수를 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 에 전달하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="c9f8b56b323ff1d67c59f2e6a12b4f9fd24bb536" translate="yes" xml:space="preserve">
          <source>Rules For Structuring (Redux) Applications</source>
          <target state="translated">구조화 (Redux) 응용 프로그램 규칙</target>
        </trans-unit>
        <trans-unit id="432cd1e0e18bce42cdef21bc0e2bf47d9952aaae" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;Async&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;비동기&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8f9990ca1ff84f660e4614ac28b5a1202d83be9" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;카운터&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="02bc6e8d90233a64557847335ed8fd0a2138380c" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;카운터 바닐라&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff2baf0af3858008f9b05583c2312fb090bd1e5d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;Real World&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;실제&lt;/a&gt; 예를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0e8812bdf4fabf867445d42be0aa6d8b7c05486" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;장바구니&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d299f4e9292980bd1533a8b98ddf4a548b317e3d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;TodoMVC&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a20317121271e18a234a5efdad9fa25e4ae9ccb" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="abfea29e9c7baf9015d33caddf86571e5480eee7" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; example:</source>
          <target state="translated">실행 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;취소로 Todos&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3419ab9b88258855aae8167ab6392ff99bc35318" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;Tree View&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;트리 뷰&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="eaf774d91e164852adb76afadeea254ddd1b6e1d" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;Universal&lt;/a&gt; example:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;범용&lt;/a&gt; 예제를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="297ff09ad1fee6372badff1acb02a01184e1b455" translate="yes" xml:space="preserve">
          <source>RxJS</source>
          <target state="translated">RxJS</target>
        </trans-unit>
        <trans-unit id="f5c8e7496f807cd64744816fba01dc672fea8b3c" translate="yes" xml:space="preserve">
          <source>Sandrino Di Mattia</source>
          <target state="translated">산 드리 노 디 마티아</target>
        </trans-unit>
        <trans-unit id="06c1e2b042f09a95936f43d636e7a9cfe06fa2c4" translate="yes" xml:space="preserve">
          <source>Say, you call this when creating a todo:</source>
          <target state="translated">할 일을 만들 때 이것을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="e86aae6b5aebceaa76af1cce53d3199d645e9dcb" translate="yes" xml:space="preserve">
          <source>Screencasts</source>
          <target state="translated">Screencasts</target>
        </trans-unit>
        <trans-unit id="abf418e07a2bb8523e609c6622f0ee30e20593e9" translate="yes" xml:space="preserve">
          <source>Second Attempt: Writing a Reducer Enhancer</source>
          <target state="translated">두 번째 시도 : Reducer Enhancer 작성</target>
        </trans-unit>
        <trans-unit id="325c723ca2b67b9b7f5ba09ec5687e02ae1b0279" translate="yes" xml:space="preserve">
          <source>Secure Your React and Redux App with JWT Authentication</source>
          <target state="translated">JWT 인증으로 React 및 Redux 앱 보안</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">보안 고려 사항</target>
        </trans-unit>
        <trans-unit id="919870200d649a13066b3447ce0f0c25022cc8f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt; for a detailed look at middleware.</source>
          <target state="translated">&lt;a href=&quot;api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용은 applyMiddleware (... middlewares) 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94f2d6b880adb72fb73adf9d3a1c8276271ee55a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; below.</source>
          <target state="translated">아래의 &lt;a href=&quot;#async-action&quot;&gt;비동기 작업&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22ce2ecd3395a41aaf7f8cf591c10dd2e971bbd0" translate="yes" xml:space="preserve">
          <source>See the complete &lt;a href=&quot;api/store#dispatch&quot;&gt;store API reference&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 전체 &lt;a href=&quot;api/store#dispatch&quot;&gt;상점 API 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1664d8a03fa57f4c8be0067b9d13327134f1e58a" translate="yes" xml:space="preserve">
          <source>Separating Data Handling by Domain</source>
          <target state="translated">도메인 별 데이터 처리 분리</target>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="translated">서버 렌더링</target>
        </trans-unit>
        <trans-unit id="25c47193088be9016d58e256803985285406a208" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the element we removed in the previous step.</source>
          <target state="translated">&lt;code&gt;present&lt;/code&gt; 을 이전 단계에서 제거한 요소로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0b36286cd9781f93bd06e4cc2ba9bd4a1ae46eb" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;present&lt;/code&gt; to the new state after handling the action.</source>
          <target state="translated">조치를 처리 한 후 &lt;code&gt;present&lt;/code&gt; 를 새 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d60b0890a431be3750d67b0f7fe70b5f3af16d7e" translate="yes" xml:space="preserve">
          <source>Setting Up</source>
          <target state="translated">설정</target>
        </trans-unit>
        <trans-unit id="6ef3f0bd0914407afe72f32d7220011189833964" translate="yes" xml:space="preserve">
          <source>Seven Examples</source>
          <target state="translated">일곱 가지 예</target>
        </trans-unit>
        <trans-unit id="bceef6abe99285193523d99d3503c8cbe59abd17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking (or &lt;em&gt;reference equality&lt;/em&gt;) simply checks that two different &lt;em&gt;variables&lt;/em&gt; reference the same object; in contrast, deep equality checking (or &lt;em&gt;value equality&lt;/em&gt;) must check every &lt;em&gt;value&lt;/em&gt; of two objects' properties.</source>
          <target state="translated">얕은 동등성 검사 (또는 &lt;em&gt;참조 동등성&lt;/em&gt; )는 단순히 두 개의 서로 다른 &lt;em&gt;변수&lt;/em&gt; 가 동일한 객체를 참조 하는지 확인 합니다. 반대로 심도 동등 검사 (또는 &lt;em&gt;값 평등&lt;/em&gt; )는 두 객체 속성의 모든 &lt;em&gt;값&lt;/em&gt; 을 검사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c1af20867da7a30bee30fa39bc87d4d6bf5086c5" translate="yes" xml:space="preserve">
          <source>Shallow equality checking cannot be used to detect if a function mutates an object passed into it if that object is mutable.</source>
          <target state="translated">얕은 동등 검사는 객체가 변경 가능한 경우 함수가 전달 된 객체를 변경하는지 감지하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a3368201d828a558753e74bfb641b78ef4ebe17" translate="yes" xml:space="preserve">
          <source>Shallow equality checking with a mutable object will not cause problems with Redux, but &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;it will cause problems with libraries that depend on the store, such as React-Redux&lt;/a&gt;.</source>
          <target state="translated">변경 가능한 객체를 사용한 얕은 동등성 검사는 Redux에 문제를 일으키지 않지만 &lt;a href=&quot;#shallow-checking-problems-with-react-redux&quot;&gt;React-Redux와 같이 저장소에 의존하는 라이브러리에는 문제가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54774f0c2c7e8f191039f8359b7b19ab53fad9f2" translate="yes" xml:space="preserve">
          <source>Sharing Selectors Across Multiple Components</source>
          <target state="translated">여러 구성 요소에서 선택기 공유</target>
        </trans-unit>
        <trans-unit id="192f8cbb6f5871d94ba5fb03d97db29c7de825cd" translate="yes" xml:space="preserve">
          <source>Sharing State Between Redux Reducers</source>
          <target state="translated">Redux Reducer 간의 상태 공유</target>
        </trans-unit>
        <trans-unit id="b89a118c798fa4a35e3c16cccb58dae4801140ac" translate="yes" xml:space="preserve">
          <source>Sharing data between slice reducers</source>
          <target state="translated">슬라이스 리듀서간에 데이터 공유</target>
        </trans-unit>
        <trans-unit id="90d67309aeeeaf7718677d90e2400596d8e164bd" translate="yes" xml:space="preserve">
          <source>Shopping Cart</source>
          <target state="translated">쇼핑 카트</target>
        </trans-unit>
        <trans-unit id="36fe368c9da0c4844911eb85a837f68dcae6c653" translate="yes" xml:space="preserve">
          <source>Should I dispatch multiple actions in a row from one action creator?</source>
          <target state="translated">하나의 액션 제작자로부터 여러 액션을 연속으로 발송해야합니까?</target>
        </trans-unit>
        <trans-unit id="e5b09d329a9d354e9f3fa021df3644b2917c4096" translate="yes" xml:space="preserve">
          <source>Should I only connect my top component, or can I connect multiple components in my tree?</source>
          <target state="translated">최상위 구성 요소 만 연결해야합니까, 아니면 트리에서 여러 구성 요소를 연결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1737c8bf68fcf64ccfaf2774ab797e55426baaa7" translate="yes" xml:space="preserve">
          <source>Should be &quot;pure&quot;, which means the reducer:</source>
          <target state="translated">리듀서를 의미하는 &quot;순수&quot;여야합니다.</target>
        </trans-unit>
        <trans-unit id="e9fdc92b96e07741038b0992e2225ba1bf7f6560" translate="yes" xml:space="preserve">
          <source>Should have a signature of &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt;, similar to the type of function you would pass to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce(reducer, ?initialValue)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(previousState, action) =&amp;gt; newState&lt;/code&gt; initialValue)에 전달할 함수 유형과 유사한 (previousState, action) =&amp;gt; newState 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">부작용</target>
        </trans-unit>
        <trans-unit id="2bdc602c5e4f77691c4cf05236ccbfb9a3a7d6cd" translate="yes" xml:space="preserve">
          <source>Similarly, Dan Abramov, one of the creators of Redux, says:</source>
          <target state="translated">마찬가지로 Redux 제작자 중 한 명인 Dan Abramov는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="a8d94bc8e96596ebe8e2c196ec3465a016861842" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;sliceReducerA&lt;/code&gt; happens to need some data from &lt;code&gt;sliceReducerB&lt;/code&gt;'s slice of state in order to handle a particular action, or &lt;code&gt;sliceReducerB&lt;/code&gt; happens to need the entire state as an argument, &lt;code&gt;combineReducers&lt;/code&gt; does not handle that itself. This could be resolved by writing a custom function that knows to pass the needed data as an additional argument in those specific cases, such as:</source>
          <target state="translated">마찬가지로 &lt;code&gt;sliceReducerA&lt;/code&gt; 가 특정 조치를 처리하기 위해 &lt;code&gt;sliceReducerB&lt;/code&gt; 의 상태 슬라이스 에서 일부 데이터가 필요 하거나 &lt;code&gt;sliceReducerB&lt;/code&gt; 가 전체 상태를 인수로 필요로하는 경우, &lt;code&gt;combineReducers&lt;/code&gt; 는 그 자체를 처리하지 않습니다. 이는 다음과 같은 특정 경우에 필요한 데이터를 추가 인수로 전달하는 것을 알고있는 사용자 정의 함수를 작성하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442aad2b9dae61af274e1b5ffcce14c8db98f18c" translate="yes" xml:space="preserve">
          <source>Similarly, while you &lt;em&gt;can&lt;/em&gt; reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</source>
          <target state="translated">마찬가지로 상점 인스턴스를 직접 가져 와서 참조 할 &lt;em&gt;수&lt;/em&gt; 있지만 Redux에서는 권장되지 않습니다. 상점 인스턴스를 작성하고 모듈에서 내 보내면 단일 인스턴스가됩니다. 즉, Redux 앱을 필요한 경우 더 큰 앱의 구성 요소로 격리하거나 서버 렌더링을 활성화하기가 더 어려워집니다. 서버에서 모든 요청에 ​​대해 별도의 스토어 인스턴스를 생성하려고하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4f6c75f4d537fefd2d55e1099d473ae02742b468" translate="yes" xml:space="preserve">
          <source>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to &lt;code&gt;store.dispatch()&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 다른 비동기 스트림을 작성하여 &lt;code&gt;store.dispatch()&lt;/code&gt; 공급하기 전에이를 동작으로 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b1172b53a0feb7a9bb295b5a660a2ffbcb58fc3" translate="yes" xml:space="preserve">
          <source>Simple Merging</source>
          <target state="translated">간단한 병합</target>
        </trans-unit>
        <trans-unit id="2070eaef74ea9323409e358647e9ae6ca53c37cd" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;combineReducers&lt;/code&gt; currently only works with plain Javascript objects, an application that uses an Immutable.js Map object for the top of its state tree could not use &lt;code&gt;combineReducers&lt;/code&gt; to manage that Map. Since many developers do use Immutable.js, there are a number of published utilities that provide equivalent functionality, such as &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;. This package provides its own implementation of &lt;code&gt;combineReducers&lt;/code&gt; that knows how to iterate over an Immutable Map instead of a plain Javascript object.</source>
          <target state="translated">이후 &lt;code&gt;combineReducers&lt;/code&gt; 현재는, 그 상태 트리의 상단에 대한 Immutable.js Map 객체를 사용하는 응용 프로그램에서 사용할 수없는 객체 일반 자바 스크립트와 함께 작동 &lt;code&gt;combineReducers&lt;/code&gt; 을 지도 것을 관리 할 수 있습니다. 많은 개발자가 Immutable.js를 사용하므로 &lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; 과 같은 동등한 기능을 제공하는 게시 된 유틸리티가 많이 있습니다 . 이 패키지는 일반 Javascript 객체 대신 불변 맵을 반복하는 방법을 알고있는 자신의 &lt;code&gt;combineReducers&lt;/code&gt; 구현을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="81feae1ade917069a12cf9aa7539b91da9719215" translate="yes" xml:space="preserve">
          <source>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</source>
          <target state="translated">Redux는 데이터 저장소 라이브러리 일 뿐이므로 프로젝트 구성 방식에 대한 직접적인 의견은 없습니다. 그러나 대부분의 Redux 개발자가 사용하는 일반적인 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec6d8987b40f3810e89420d79f0a03ad196ea3a0" translate="yes" xml:space="preserve">
          <source>Since a Redux reducer is &lt;em&gt;just&lt;/em&gt; a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function.</source>
          <target state="translated">Redux 감속기는 기능 일 &lt;em&gt;뿐이&lt;/em&gt; 므로 동일한 개념이 적용됩니다. 감속기 로직의 일부를 다른 함수로 분리하고 상위 함수에서 새 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7004cb2a5422c7e3364434a15f16aaad43e92c0" translate="yes" xml:space="preserve">
          <source>Since each data type is separated, an update like changing the text of a comment would only require new copies of the &quot;comments &amp;gt; byId &amp;gt; comment&quot; portion of the tree. This will generally mean fewer portions of the UI that need to update because their data has changed. In contrast, updating a comment in the original nested shape would have required updating the comment object, the parent post object, the array of all post objects, and likely have caused &lt;em&gt;all&lt;/em&gt; of the Post components and Comment components in the UI to re-render themselves.</source>
          <target state="translated">각 데이터 유형이 분리되므로 주석 텍스트 변경과 같은 업데이트는 트리의 &quot;주석&amp;gt; byId&amp;gt; 주석&quot;부분의 새 사본 만 필요합니다. 이는 일반적으로 데이터가 변경되어 업데이트해야하는 UI 부분이 적다는 것을 의미합니다. 반대로 원래 중첩 모양에서 주석을 업데이트하려면 주석 오브젝트, 상위 포스트 오브젝트, 모든 포스트 오브젝트의 배열을 업데이트해야 했으며 UI의 &lt;em&gt;모든&lt;/em&gt; 포스트 컴포넌트 및 주석 컴포넌트가 다시 렌더링되었습니다. 그들 자신.</target>
        </trans-unit>
        <trans-unit id="3378207602b38cf49f27093860fe75762bdd12fe" translate="yes" xml:space="preserve">
          <source>Since immutable data updates require all ancestors in the state tree to be copied and updated as well, and new object references will cause connected UI components to re-render, an update to a deeply nested data object could force totally unrelated UI components to re-render even if the data they're displaying hasn't actually changed.</source>
          <target state="translated">변경 불가능한 데이터 업데이트는 상태 트리의 모든 조상도 복사 및 업데이트해야하며, 새로운 객체 참조로 인해 연결된 UI 구성 요소가 다시 렌더링되므로 깊이 중첩 된 데이터 객체를 업데이트하면 완전히 관련되지 않은 UI 구성 요소가 표시하는 데이터가 실제로 변경되지 않은 경우에도 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="bc174df1294758024d3aa9d37156a3b1ea508c4a" translate="yes" xml:space="preserve">
          <source>Since one of the core tenets of Redux is to never mutate state, you'll often find yourself using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; to create copies of objects with new or updated values. For example, in the &lt;code&gt;todoApp&lt;/code&gt; below &lt;code&gt;Object.assign()&lt;/code&gt; is used to return a new &lt;code&gt;state&lt;/code&gt; object with an updated &lt;code&gt;visibilityFilter&lt;/code&gt; property:</source>
          <target state="translated">Redux의 핵심 원칙 중 하나는 상태를 절대로 변경하지 않는 것이므로 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 을 사용하여 새 값 또는 업데이트 된 값으로 객체의 복사본을 만드는 경우가 종종 있습니다. 예를 들어, 아래 &lt;code&gt;todoApp&lt;/code&gt; 에서 &lt;code&gt;Object.assign()&lt;/code&gt; 은 업데이트 된 &lt;code&gt;visibilityFilter&lt;/code&gt; 필터 속성을 가진 새 &lt;code&gt;state&lt;/code&gt; 객체 를 반환하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="751750d4cb79c6a8466b2981d8a7c11a9b335b87" translate="yes" xml:space="preserve">
          <source>Since reducers are just functions, there's an infinite number of ways to split up this logic. While using slice reducers is obviously the most common, it's also possible to organize behavior in a more task-oriented structure. Because this will often involve more nested updates, you may want to use an immutable update utility library like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; or &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; to simplify the update statements. Here's an example of what that might look like:</source>
          <target state="translated">감속기는 단지 기능이기 때문에이 논리를 분할하는 방법에는 무한한 방법이 있습니다. 슬라이스 감속기를 사용하는 것이 가장 일반적이지만 동작을보다 작업 지향적 인 구조로 구성 할 수도 있습니다. 여기에는 종종 중첩 업데이트가 더 많이 포함되므로 &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/mariocasciaro/object-path-immutable&quot;&gt;object-path-immutable&lt;/a&gt; 과 같은 불변 업데이트 유틸리티 라이브러리 를 사용하여 업데이트 문을 단순화 할 수 있습니다. 다음은 그 모양에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="9524f9ed1b2581f0acc17e64cde44a8908d2e14e" translate="yes" xml:space="preserve">
          <source>Since the default export is still the decorated component, the import statement pictured above will work as before so you won't have to change your application code. However, you can now import the undecorated &lt;code&gt;App&lt;/code&gt; components in your test file like this:</source>
          <target state="translated">기본 내보내기는 여전히 꾸며진 구성 요소이므로 위 그림과 같은 import 문은 이전과 같이 작동하므로 응용 프로그램 코드를 변경할 필요가 없습니다. 그러나 이제 다음과 같이 장식되지 않은 &lt;code&gt;App&lt;/code&gt; 구성 요소를 테스트 파일로 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fb6dcac04c2641afe5f5ceba2752f16941c0489" translate="yes" xml:space="preserve">
          <source>Since the object spread syntax is still a &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;Stage 3&lt;/a&gt; proposal for ECMAScript you'll need to use a transpiler such as &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to use it in production. You can use your existing &lt;code&gt;es2015&lt;/code&gt; preset, install &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt;&lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt;&lt;/a&gt; and add it individually to the &lt;code&gt;plugins&lt;/code&gt; array in your &lt;code&gt;.babelrc&lt;/code&gt;.</source>
          <target state="translated">오브젝트 스프레드 구문은 여전히 ECMAScript에 대한 &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread#status-of-this-proposal&quot;&gt;3 단계&lt;/a&gt; 제안 이므로 프로덕션에서 사용하려면 &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 과 같은 변환기 를 사용해야합니다. 기존 &lt;code&gt;es2015&lt;/code&gt; 사전 설정을 사용하고 &lt;a href=&quot;http://babeljs.io/docs/plugins/transform-object-rest-spread/&quot;&gt; &lt;code&gt;babel-plugin-transform-object-rest-spread&lt;/code&gt; &lt;/a&gt; 를 설치 한 후 &lt;code&gt;.babelrc&lt;/code&gt; 의 &lt;code&gt;plugins&lt;/code&gt; 배열에 개별적으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ca51516913ff8c686b4181a9850b407d585f33e" translate="yes" xml:space="preserve">
          <source>Single Simple Reducer</source>
          <target state="translated">단일 단순 감속기</target>
        </trans-unit>
        <trans-unit id="c3607f5a3395346db279c8631885ad76c32cdec0" translate="yes" xml:space="preserve">
          <source>Single source of truth</source>
          <target state="translated">진실의 단일 소스</target>
        </trans-unit>
        <trans-unit id="3d0ddd2467b9b23c1a85abd5a68ac4b84b509998" translate="yes" xml:space="preserve">
          <source>Slice Reducer Composition</source>
          <target state="translated">슬라이스 감속기 구성</target>
        </trans-unit>
        <trans-unit id="6f8966ee06a6a598a66e68a6f2128780e130ca9a" translate="yes" xml:space="preserve">
          <source>Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)</source>
          <target state="translated">여러 곳에서 필요한 일부 재사용 가능한 논리 청크를 포함하는 작은 유틸리티 함수 (특정 비즈니스 논리와 실제로 관련되거나 그렇지 않을 수 있음)</target>
        </trans-unit>
        <trans-unit id="712ac3fdb33cc95ff1f79708b05bdbf85fc873a3" translate="yes" xml:space="preserve">
          <source>Smart and Dumb Components in React</source>
          <target state="translated">반응의 스마트 및 벙어리 구성 요소</target>
        </trans-unit>
        <trans-unit id="dd67eec5e031f2788f993ce1a20a1c919e9f1589" translate="yes" xml:space="preserve">
          <source>Smart components that access the store via React Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function must use the Immutable.JS values returned by your selectors. Make sure you avoid the potential issues this can cause with unnecessary component re-rendering. Memoize your selectors using a library such as reselect if necessary.</source>
          <target state="translated">React Redux의 &lt;code&gt;connect&lt;/code&gt; 기능을 통해 상점에 액세스하는 스마트 컴포넌트는 선택기에서 리턴 한 Immutable.JS 값을 사용해야합니다. 불필요한 컴포넌트 재 렌더링으로 인해 발생할 수있는 잠재적 인 문제를 피하십시오. 필요한 경우 다시 선택과 같은 라이브러리를 사용하여 선택기를 메모하십시오.</target>
        </trans-unit>
        <trans-unit id="0fa28ccaea98dae4e7adc0d2f21a6688416f5c11" translate="yes" xml:space="preserve">
          <source>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</source>
          <target state="translated">지금까지 셀렉터 만이 Redux 스토어 상태를 인수로받는 것을 보았지만, 셀렉터도 props를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c7e37241e1ba9e69dbbe9b4a4d92f9d4db7b97e" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;getVisibleTodos&lt;/code&gt; has access to &lt;code&gt;props&lt;/code&gt;, and everything seems to be working fine.</source>
          <target state="translated">이제 &lt;code&gt;getVisibleTodos&lt;/code&gt; 는 &lt;code&gt;props&lt;/code&gt; 에 액세스 할 수 있으며 모든 것이 잘 작동하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7a8e420420cf895d7c454a61b1d5cb20007fa2a" translate="yes" xml:space="preserve">
          <source>So you want to do routing with your Redux app. You can use it with &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. Redux will be the source of truth for your data and React Router will be the source of truth for your URL. In most of the cases, &lt;strong&gt;it is fine&lt;/strong&gt; to have them separate unless you need to time travel and rewind actions that triggers the change URL.</source>
          <target state="translated">따라서 Redux 앱으로 라우팅하고 싶습니다. &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt; 와 함께 사용할 수 있습니다 . Redux는 귀하의 데이터에 대한 진실의 원천이되고 React Router는 귀하의 URL에 대한 진실의 원천이 될 것입니다. 대부분의 경우에, &lt;strong&gt;그것은 괜찮&lt;/strong&gt; 당신이 URL 변경을 트리거 시간 여행 및 되감기 작업에 필요하지 않는 한 그들을 분리 가지고는.</target>
        </trans-unit>
        <trans-unit id="2fc8fe9a73edd4d111843f389431f4101d5d9c17" translate="yes" xml:space="preserve">
          <source>So, for example, if your state shape is &lt;code&gt;{ todos, counter }&lt;/code&gt;, the call to &lt;code&gt;combineReducers&lt;/code&gt; would be:</source>
          <target state="translated">예를 들어, 상태 형태가 &lt;code&gt;{ todos, counter }&lt;/code&gt; 인 경우 &lt;code&gt;combineReducers&lt;/code&gt; 에 대한 호출 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccb9fbf6736643b0e42418e768268b9cd0d29f5f" translate="yes" xml:space="preserve">
          <source>So, what are you waiting for?</source>
          <target state="translated">그래서, 당신은 무엇을 기다리고 있습니까?</target>
        </trans-unit>
        <trans-unit id="aaba548cf058bc58a2b9e6247d0f30696c87f137" translate="yes" xml:space="preserve">
          <source>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</source>
          <target state="translated">앱을 프로파일 링하여 확인할 때 상태의 일부를 너무 자주 업데이트하여 발생하는 성능 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="d49f0c1ce0f85599fd62bed378620cb762c1e648" translate="yes" xml:space="preserve">
          <source>Some Reasons Why Redux is Useful in a React App</source>
          <target state="translated">Redux가 React 앱에서 유용한 몇 가지 이유</target>
        </trans-unit>
        <trans-unit id="67effe7198ec1da2c9351c8b657b35336537bffb" translate="yes" xml:space="preserve">
          <source>Some common rules of thumb for determining what kind of data should be put into Redux:</source>
          <target state="translated">Redux에 어떤 종류의 데이터를 넣어야하는지 결정하기위한 몇 가지 일반적인 규칙 :</target>
        </trans-unit>
        <trans-unit id="fce335731003088c209cd9b37e95f6128c05deb1" translate="yes" xml:space="preserve">
          <source>Some frameworks like &lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define &lt;code&gt;ADD_TODO&lt;/code&gt; constant and &lt;code&gt;addTodo()&lt;/code&gt; action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; 와 같은 일부 프레임 워크 는 활동 작성기 함수 정의에서 활동 유형 상수를 자동으로 생성합니다. 아이디어는 &lt;code&gt;ADD_TODO&lt;/code&gt; 상수와 &lt;code&gt;addTodo()&lt;/code&gt; 액션 생성기 를 모두 정의 할 필요가 없다는 것 입니다. 후드에서 이러한 솔루션은 여전히 ​​액션 유형 상수를 생성하지만 암시 적으로 생성되므로 간접적 수준이며 혼란을 유발할 수 있습니다. 활동 유형 상수를 명시 적으로 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11a2735a6d7891b97c7769374cd7a4c5a0bb87e0" translate="yes" xml:space="preserve">
          <source>Some of these concepts are already described elsewhere in the Redux documentation. Others are generic and applicable outside of Redux itself, and there are numerous existing articles that cover these concepts in detail. These concepts and techniques form the foundation of writing solid Redux reducer logic.</source>
          <target state="translated">이러한 개념 중 일부는 Redux 설명서의 다른 곳에 이미 설명되어 있습니다. 다른 것은 일반적으로 Redux 외부에서 적용 가능하며 이러한 개념을 자세히 다루는 수많은 기존 기사가 있습니다. 이러한 개념과 기술은 견고한 Redux 감속기 논리를 작성하는 기초를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="f81aa5aa34cf8b3e24fa1aaf08e9c45c13b0947d" translate="yes" xml:space="preserve">
          <source>Some valid reasons for using multiple stores in Redux might include:</source>
          <target state="translated">Redux에서 여러 상점을 사용하는 몇 가지 유효한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0393764cde3422b70bb25ef444a0fd2f0c54e31" translate="yes" xml:space="preserve">
          <source>Something else doesn't work</source>
          <target state="translated">다른 것이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="cb49415fd84ba99d743a94724fc704b532a5abb2" translate="yes" xml:space="preserve">
          <source>Something needs to map the Immutable.JS props in your Smart Component to the pure JavaScript props used in your Dumb Component. That something is a Higher Order Component (HOC) that simply takes the Immutable.JS props from your Smart Component, and converts them using &lt;code&gt;toJS()&lt;/code&gt; to plain JavaScript props, which are then passed to your Dumb Component.</source>
          <target state="translated">스마트 컴포넌트의 Immutable.JS 소품을 Dumb 컴포넌트에서 사용되는 순수한 JavaScript 소품에 매핑해야합니다. 즉, Smart Component에서 Immutable.JS 소품을 &lt;code&gt;toJS()&lt;/code&gt; 를 사용하여 일반 JavaScript 소품으로 변환 한 다음 Dumb Component로 전달하는 HOC (Higher Order Component)입니다 .</target>
        </trans-unit>
        <trans-unit id="82c027e36202d6dbe2e05d86322f925c7f839e11" translate="yes" xml:space="preserve">
          <source>Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</source>
          <target state="translated">때로는 어떤 컴포넌트가 프리젠 테이션 컴포넌트인지 컨테이너인지를 말하기가 어렵습니다. 예를 들어, 때로는 작은 구성 요소의 경우와 같이 형태와 기능이 실제로 서로 결합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d627c00cc83e8506e9cca85f44caed1d800c8c74" translate="yes" xml:space="preserve">
          <source>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.</source>
          <target state="translated">새로운 기능을 사용하기 전에 기존의 모든 작업을보고 싶을 때가 있습니다. 팀의 누군가가 필요한 조치를 이미 추가했을 수도 있지만 몰랐습니다.</target>
        </trans-unit>
        <trans-unit id="268852f5aa4bf3dafae464e32161ca334e3c609b" translate="yes" xml:space="preserve">
          <source>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</source>
          <target state="translated">때때로 작업을 전달하려고하지만보기가 업데이트되지 않는 경우가 있습니다. 왜 이런 일이 발생합니까? 몇 가지 이유가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">소스 코드</target>
        </trans-unit>
        <trans-unit id="f7919286c635d777ca9b544031e60fec3b718ae8" translate="yes" xml:space="preserve">
          <source>Special thanks to &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; for handing over the &lt;code&gt;redux&lt;/code&gt; NPM package name.</source>
          <target state="translated">&lt;code&gt;redux&lt;/code&gt; NPM 패키지 이름을 전달해 주신 &lt;a href=&quot;http://jdpaton.github.io&quot;&gt;Jamie Paton&lt;/a&gt; 에게 감사드립니다 .</target>
        </trans-unit>
        <trans-unit id="56c91bc14a02e8f889305106eb782729b8dd411c" translate="yes" xml:space="preserve">
          <source>Specifically, at each stage of the iteration, &lt;code&gt;combineReducers&lt;/code&gt; performs a shallow equality check on the current state slice and the state slice returned from the reducer. If the reducer returns a new object, the shallow equality check will fail, and &lt;code&gt;combineReducers&lt;/code&gt; will set a &lt;code&gt;hasChanged&lt;/code&gt; flag to true.</source>
          <target state="translated">특히, 반복의 각 단계에서 &lt;code&gt;combineReducers&lt;/code&gt; 는 현재 상태 조각과 감속기에서 반환 된 상태 조각에 대해 얕은 동등성 검사를 수행합니다. 감속기가 새 객체를 반환하면 얕은 동등성 검사가 실패하고 &lt;code&gt;combineReducers&lt;/code&gt; 가 &lt;code&gt;hasChanged&lt;/code&gt; 플래그를 true로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="00a3d8825c5eff03d86ea087a0b53050c94c3f8c" translate="yes" xml:space="preserve">
          <source>Specifically, if the state slice passed to a reducer by &lt;code&gt;combineReducers&lt;/code&gt; is a mutable object, the reducer can modify it directly and return it.</source>
          <target state="translated">특히, &lt;code&gt;combineReducers&lt;/code&gt; 에 의해 리듀서에 전달 된 상태 슬라이스 가 변경 가능한 객체 인 경우 리듀서는이를 직접 수정하여 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479e7df6db27bd135fe0142b00903715ac33068a" translate="yes" xml:space="preserve">
          <source>Splitting Reducer Logic</source>
          <target state="translated">스 플리 팅 리듀서 로직</target>
        </trans-unit>
        <trans-unit id="0b815e2bedf75de31f11e6b703026f6acada0f6e" translate="yes" xml:space="preserve">
          <source>Splitting Reducers</source>
          <target state="translated">분할 감속기</target>
        </trans-unit>
        <trans-unit id="63a2a0cb21e82fc3b8d2808aae5b0cbb52a99600" translate="yes" xml:space="preserve">
          <source>Splitting Up Reducer Logic</source>
          <target state="translated">감속기 로직 분리</target>
        </trans-unit>
        <trans-unit id="d329a5765000192b22c2d117af29d9bee7c6537b" translate="yes" xml:space="preserve">
          <source>Splitting relational/nested data up into separate tables</source>
          <target state="translated">관계형 / 중첩 데이터를 별도의 테이블로 분할</target>
        </trans-unit>
        <trans-unit id="1230663d5b652e72592a5cdc4822bd583ada50c6" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator</source>
          <target state="translated">스택 오버플로 : Action Creator에서 Redux 상태에 액세스</target>
        </trans-unit>
        <trans-unit id="af2ce625671f1ad526f0f824992d40592fc65945" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing Redux state in an action creator?</source>
          <target state="translated">스택 오버플로 : Action Creator에서 Redux 상태에 액세스하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="cc4a21e47f70cd2f23b0f2c342d8b431463d5d43" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Accessing other parts of the state when using combined reducers?</source>
          <target state="translated">스택 오버플로 : 결합 된 감속기를 사용할 때 상태의 다른 부분에 액세스합니까?</target>
        </trans-unit>
        <trans-unit id="b04783e3f6d9939621df25d5e278f88f85d40f4e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</source>
          <target state="translated">스택 오버플로 : Redux Thunk 미들웨어없이 여러 작업을 전달할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="48da126c64af14eeff2ddf00eef38c1862600c5d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a React Redux app scale as well as Backbone?</source>
          <target state="translated">스택 오버플로 : React Redux 앱과 백본을 확장 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4dfaf2359aff2ab31c33a3dbf21369953e0929ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Can a Redux store lead to a memory leak?</source>
          <target state="translated">스택 오버 플로우 : Redux 스토어에서 메모리 누수가 발생할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="988abe0fa36c2ebb4e0cbf914b4d5fe269cc989b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Cleaner/shorter way to update nested state in Redux?</source>
          <target state="translated">스택 오버플로 : Redux에서 중첩 상태를 업데이트하는 더 깨끗하고 짧은 방법?</target>
        </trans-unit>
        <trans-unit id="5b1e48bcacf1979014102c6547e344589cfc1043" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</source>
          <target state="translated">스택 오버플로 : Redux에서 이벤트와 작업이 1 : 1 관계입니까?</target>
        </trans-unit>
        <trans-unit id="ebddfda346f9cc1931bdaef9cad513e27fe3e4da" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How does Redux deal with deeply nested models?</source>
          <target state="translated">스택 오버플로 : Redux는 중첩 된 모델을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="94b70dfefdce48458a92962024bd2e39922329c0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to dispatch a Redux action with a timeout?</source>
          <target state="translated">스택 오버플로 : 시간 초과로 Redux 액션을 전달하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b44a8af5f0a70fd30e935dc3f76e87f077627bbd" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</source>
          <target state="translated">스택 오버플로 : Redux의 상태 변경에 따라 AJAX 호출을 시작하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3e47386ec6016dd7f3fc367e6cffa3cf96cda35c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</source>
          <target state="translated">스택 오버플로 : Redux 연결을 사용하여 this.props에서 간단한 디스패치를 ​​얻는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2165fe78c71949f8e9b453c57e11f6841bdc5b4c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle complex side-effects in Redux?</source>
          <target state="translated">스택 오버플로 : Redux에서 복잡한 부작용을 처리하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="28f22a2146692414a69f910d533939bac7f855eb" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to handle tree-shaped entities in Redux reducers?</source>
          <target state="translated">스택 오버플로 : Redux 감속기에서 나무 모양의 엔티티를 처리하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9d4b50a3426c2e7c8b83c7f6061b71189fc4ad4d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components in React + Redux?</source>
          <target state="translated">스택 오버플로 : React + Redux에서 중첩 구성 요소의 소품에 작은 업데이트를 최적화하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4d918cb89f55a87fe62b679dfe98194482be59ff" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to optimize small updates to props of nested components?</source>
          <target state="translated">스택 오버플로 : 중첩 된 구성 요소의 소품에 작은 업데이트를 최적화하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="acba72b3df5c830d1b5aba0a48d173bc22d8fc32" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to structure Redux components/containers</source>
          <target state="translated">스택 오버플로 : Redux 구성 요소 / 컨테이너를 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="e3eccf206103856b93ecbd37ce4f41620479a06a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: How to unit test async Redux actions to mock ajax response</source>
          <target state="translated">스택 오버플로 : 비동기 Redux 작업을 단위 테스트하여 Ajax 응답을 조롱하는 방법</target>
        </trans-unit>
        <trans-unit id="4927a93f0a45155d14400120ebde30fcac96c00b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Is there any way to &quot;commit&quot; the state in Redux to free memory?</source>
          <target state="translated">스택 오버플로 : Redux에서 상태를 &quot;커밋&quot;하여 메모리를 비울 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="8a704c1a402b4c7a231139affcc8b80dae9a39bc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Memory Usage Concern with Controlled Components</source>
          <target state="translated">스택 오버플로 : 제어되는 구성 요소와 관련된 메모리 사용</target>
        </trans-unit>
        <trans-unit id="dee2e567cd35803ebf7a0cd85960b6e1c5f84ae0" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Reducing an entire subtree with redux combineReducers</source>
          <target state="translated">스택 오버플로 : redux 결합으로 전체 하위 트리 줄이기</target>
        </trans-unit>
        <trans-unit id="f5c28dc373c45c187ad94b9e7c8d28a1a1e19e92" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux and ALL the application state</source>
          <target state="translated">스택 오버 플로우 : Redux 및 모든 애플리케이션 상태</target>
        </trans-unit>
        <trans-unit id="c804eaac1de7836c4167b4c7ce22081a3aecc375" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux multiple stores, why not?</source>
          <target state="translated">스택 오버플로 : 여러 저장소를 리 덕트하세요.</target>
        </trans-unit>
        <trans-unit id="b7e9dc84c7d9700ead6d04e9e5ccc4ca7533584c" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Redux vs plain React?</source>
          <target state="translated">스택 오버플로 : Redux와 일반 반응?</target>
        </trans-unit>
        <trans-unit id="105923b79101b77a45fa4c3b2354a35798f4c76b" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should I use one or several action types to represent this async action?</source>
          <target state="translated">스택 오버플로 :이 비동기 작업을 나타 내기 위해 하나 이상의 작업 유형을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="31fdb0827c84ebe2269807c61132bfaba82d6831" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</source>
          <target state="translated">스택 오버플로 : 감속기를 사용하여 관련 작업을 처리하거나 작업 작성자가 직접 작업을 처리해야합니까?</target>
        </trans-unit>
        <trans-unit id="65014c400549c8612072befc0adf72ed3b081d64" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Should all component state be kept in Redux store?</source>
          <target state="translated">스택 오버플로 : 모든 구성 요소 상태를 Redux 저장소에 유지해야합니까?</target>
        </trans-unit>
        <trans-unit id="b98acfbe9a6b5556936b1fc7e937ef42e8da0b73" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State in Redux app has the name of the reducer</source>
          <target state="translated">스택 오버플로 : Redux 앱의 상태에 리듀서 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bb052748fb6d9f95b232931f6b7ce0b330d741" translate="yes" xml:space="preserve">
          <source>Stack Overflow: State key names and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">스택 오버플로 : 상태 키 이름 및 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70cc3d889ceeb8e34d6f3922754c47f23bd9be8d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Store initial state and &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">스택 오버 플로우 : 초기 상태 저장 및 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c38c53a8386528fdbcdcab4494d509416d698fc" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What could be the downsides of using Redux instead of Flux?</source>
          <target state="translated">스택 오버플로 : Flux 대신 Redux를 사용하면 어떤 단점이 있습니까?</target>
        </trans-unit>
        <trans-unit id="895ded7294588881bb7fc95054edf3c3db5d4e96" translate="yes" xml:space="preserve">
          <source>Stack Overflow: What is the point of the constants in Redux?</source>
          <target state="translated">스택 오버플로 : Redux에서 상수의 요점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="658846fec2f949984f29281c5ad5f8e0b3afe04d" translate="yes" xml:space="preserve">
          <source>Stack Overflow: When should I add Redux to a React app?</source>
          <target state="translated">스택 오버플로 : 언제 Reux 앱에 Redux를 추가해야합니까?</target>
        </trans-unit>
        <trans-unit id="49f9fa997616236334bab1f021f4d95a98961d28" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</source>
          <target state="translated">스택 오버플로 : redux에서 액션과 관련된 동기 부작용을 어디에 두어야합니까?</target>
        </trans-unit>
        <trans-unit id="936266740da7540850a532833e6a2df525b2a8b5" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do we need middleware for async flow in Redux?</source>
          <target state="translated">스택 오버플로 : Redux에서 비동기 흐름을 위해 미들웨어가 필요한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9bba3ac3bd12027bb6ac452b12ce38c7e56b122a" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why do you need 'Actions' as data in Redux?</source>
          <target state="translated">스택 오버플로 : Redux의 데이터로 'Actions'가 필요한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="18756cef85dbd29ab28641afa6772d3fefa20cc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why is state all in one place, even state that isn't global?</source>
          <target state="translated">스택 오버플로 : 왜 모든 상태가 한곳에 있고, 심지어 전역이 아닌 상태일까요?</target>
        </trans-unit>
        <trans-unit id="7d2d7c0b7e20393e0c17c7eab1c82b6b5fc50426" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why should I use Redux in this example?</source>
          <target state="translated">스택 오버플로 :이 예에서 왜 Redux를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="a0364f6c9c8a113f92fdf913bbb551039a9724ed" translate="yes" xml:space="preserve">
          <source>Stack Overflow: Why use Redux over Facebook Flux?</source>
          <target state="translated">스택 오버플로 : Facebook Flux를 통해 Redux를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="10aa1b0c136f369eeefa163ced6c37c7c591e72e" translate="yes" xml:space="preserve">
          <source>Stack Overflow: can a dumb component use a Redux container?</source>
          <target state="translated">스택 오버플로 : 바보 같은 구성 요소가 Redux 컨테이너를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4b161211956de081a873933a4c8a044abab7e0fb" translate="yes" xml:space="preserve">
          <source>Standard Approaches</source>
          <target state="translated">표준 접근법</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="d587c099b9773435ddc0261ea9851ea406674dcf" translate="yes" xml:space="preserve">
          <source>State is read-only</source>
          <target state="translated">상태는 읽기 전용입니다</target>
        </trans-unit>
        <trans-unit id="88bdda40b1f54211bc74c1e437fac5cd7bd92718" translate="yes" xml:space="preserve">
          <source>Still, this isn't nice.</source>
          <target state="translated">아직도, 이것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="6bd6be2595d77f48a33fbcd6f117fa074b3dc576" translate="yes" xml:space="preserve">
          <source>Store API</source>
          <target state="translated">스토어 API</target>
        </trans-unit>
        <trans-unit id="2ae5ce622a7b9cf0a55280ae39f15ebca3636999" translate="yes" xml:space="preserve">
          <source>Store Methods</source>
          <target state="translated">저장 방법</target>
        </trans-unit>
        <trans-unit id="755c0688d517f4d1f3befaef9cbffed1a12611b7" translate="yes" xml:space="preserve">
          <source>Store Setup</source>
          <target state="translated">매장 설정</target>
        </trans-unit>
        <trans-unit id="46284619675b8370e43c07e07ae7f90f0dc58a68" translate="yes" xml:space="preserve">
          <source>Store creator</source>
          <target state="translated">스토어 제작자</target>
        </trans-unit>
        <trans-unit id="8ce0b798e0d4896a15608877012298d37342e347" translate="yes" xml:space="preserve">
          <source>Store enhancer</source>
          <target state="translated">점포 증강</target>
        </trans-unit>
        <trans-unit id="e142a8c534381fae47d56a5e16a0f2235b158282" translate="yes" xml:space="preserve">
          <source>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called &amp;ldquo;component enhancers&amp;rdquo;.</source>
          <target state="translated">스토어 인핸서는 React의 고차 컴포넌트와 개념과 거의 동일하며 때때로 &quot;컴포넌트 인핸서&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9416c1d5086bab5c721ad43af63fa3ab63c0a122" translate="yes" xml:space="preserve">
          <source>Store#dispatch()</source>
          <target state="translated">Store#dispatch()</target>
        </trans-unit>
        <trans-unit id="114eacc705a7df0e8c46ba7b192ea5316ba2c4ac" translate="yes" xml:space="preserve">
          <source>Store#getState()</source>
          <target state="translated">Store#getState()</target>
        </trans-unit>
        <trans-unit id="df99ee9fbf8a2efc5c7ed00b4492bf6b553163b9" translate="yes" xml:space="preserve">
          <source>Store#replaceReducer()</source>
          <target state="translated">Store#replaceReducer()</target>
        </trans-unit>
        <trans-unit id="013d0660eaa2690e6a9f899d36b23e021b36d850" translate="yes" xml:space="preserve">
          <source>Store#subscribe()</source>
          <target state="translated">Store#subscribe()</target>
        </trans-unit>
        <trans-unit id="71b541e49eef296d8df0cc8c719be0338a66cc03" translate="yes" xml:space="preserve">
          <source>Storing a single definition for a given item</source>
          <target state="translated">주어진 항목에 대한 단일 정의 저장</target>
        </trans-unit>
        <trans-unit id="92eb6223892f134972ff80efa523a2000d6d1189" translate="yes" xml:space="preserve">
          <source>Structuring Reducers</source>
          <target state="translated">구조화 감속기</target>
        </trans-unit>
        <trans-unit id="2ff01fd753f588ce2cd880cdb10c47db54dde5a5" translate="yes" xml:space="preserve">
          <source>Subscribe to Redux state</source>
          <target state="translated">Redux 상태에 가입</target>
        </trans-unit>
        <trans-unit id="a54bde2350739858cdd0b5bc888eeb8620d23e6e" translate="yes" xml:space="preserve">
          <source>Such a dependency renders the component impure, makes testing the component more difficult, and makes reusing and refactoring the component unnecessarily difficult.</source>
          <target state="translated">이러한 종속성으로 인해 구성 요소가 불완전 해지고 구성 요소 테스트가 더욱 어려워지고 불필요하게 구성 요소를 재사용 및 리팩토링하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="0fe97fb0406402fb59fa412b3bbeb9b60ac9262c" translate="yes" xml:space="preserve">
          <source>Synchronous Action Creators</source>
          <target state="translated">동기 동작 생성자</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="15c674d7738210d0c5965059a30efc2059314bf7" translate="yes" xml:space="preserve">
          <source>Talks</source>
          <target state="translated">Talks</target>
        </trans-unit>
        <trans-unit id="2b65f913df556f349b0a7873cfdb7a6a8dd462a1" translate="yes" xml:space="preserve">
          <source>Task-Based Updates</source>
          <target state="translated">작업 기반 업데이트</target>
        </trans-unit>
        <trans-unit id="d95c7170ec15da472e1fc16a1b3628b7692d766d" translate="yes" xml:space="preserve">
          <source>Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.</source>
          <target state="translated">기술적으로는 두 가지 구성 요소로 나눌 수 있지만이 단계에서는 너무 빠를 수 있습니다. 아주 작은 컴포넌트에 프리젠 테이션과 로직을 혼합하는 것이 좋습니다. 자라면서 나누는 방법이 더 분명해 지므로 혼합 상태로 두겠습니다.</target>
        </trans-unit>
        <trans-unit id="97405b706d923beb562a978445f95da1784f550e" translate="yes" xml:space="preserve">
          <source>Technically you could write the container components by hand using &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe()&lt;/code&gt;&lt;/a&gt;. We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; function provided by React Redux, as you will see below.</source>
          <target state="translated">기술적으로 &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe()&lt;/code&gt; &lt;/a&gt; 사용하여 컨테이너 구성 요소를 직접 작성할 수 있습니다. React Redux는 수작업으로 수행하기 어려운 많은 성능 최적화를 수행하므로 권장하지 않습니다. 이러한 이유로 컨테이너 컴포넌트를 작성하는 대신 아래에서 볼 수 있듯이 React Redux에서 제공 하는 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 컴포넌트를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2c2cd2ae8ff170115855201664f8bc10a106aa1d" translate="yes" xml:space="preserve">
          <source>Testimonials</source>
          <target state="translated">Testimonials</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="09191f5d1ae35f788275b3791134e5c6cc9695f6" translate="yes" xml:space="preserve">
          <source>That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere.</source>
          <target state="translated">이 기능은 상당히 짧지 만 이미 지나치게 복잡해졌습니다. 우리는 두 가지 다른 관심 영역 (필터링과 할일 목록 관리)을 다루고 있으며 중첩은 업데이트 논리를 읽기 어렵게 만들고 있으며 모든 곳에서 무슨 일이 일어나고 있는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="532f0a532fc0a678855d599bf7ec4ac18d1963d4" translate="yes" xml:space="preserve">
          <source>That reduced the duplication and made things a bit easier to read.</source>
          <target state="translated">그것은 중복을 줄이고 물건을 조금 더 읽기 쉽게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="3d029300dc585308627967e2bccdc91655721462" translate="yes" xml:space="preserve">
          <source>That said, Redux works especially well with libraries like &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;Deku&lt;/a&gt; because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</source>
          <target state="translated">즉, Redux는 UI를 상태의 함수로 설명 할 수 있고 Redux는 작업에 대한 응답으로 상태 업데이트를 &lt;a href=&quot;https://github.com/dekujs/deku&quot;&gt;생성&lt;/a&gt; 하기 때문에 &lt;a href=&quot;http://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 및 Deku 와 같은 라이브러리와 특히 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ba443c628e5456614af4a08cbb732b49948515da" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s perfectly OK when you mutate the copy, but in the context of a reducer, if you return a copy that &lt;em&gt;hasn&amp;rsquo;t&lt;/em&gt; been mutated, Redux&amp;rsquo;s &lt;code&gt;combineReducers&lt;/code&gt; function will still think that the state needs to be updated, as you're returning an entirely different object from the state slice object that was passed in.</source>
          <target state="translated">사본을 변경하면 완벽하게 괜찮지 만 감속기의 맥락에서 변경 &lt;em&gt;되지&lt;/em&gt; 않은 사본을 반환하면 Redux의 &lt;code&gt;combineReducers&lt;/code&gt; 함수는 여전히 전체를 반환 할 때 상태를 업데이트해야한다고 생각합니다. 전달 된 상태 슬라이스 객체와 다른 객체</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="695a585b3252ff564ab700e0286c7c4e8dfbd47b" translate="yes" xml:space="preserve">
          <source>That's it! Now any actions dispatched to the store instance will flow through &lt;code&gt;logger&lt;/code&gt; and &lt;code&gt;crashReporter&lt;/code&gt;:</source>
          <target state="translated">그게 다야! 이제 상점 인스턴스에 전달 된 모든 조치는 &lt;code&gt;logger&lt;/code&gt; 및 &lt;code&gt;crashReporter&lt;/code&gt; 를 통해 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="62c0daeb24847642ed1a353245f2da0b5ca7faa7" translate="yes" xml:space="preserve">
          <source>That's it! Now you know what Redux is all about.</source>
          <target state="translated">그게 다야! 이제 Redux가 무엇인지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c632b918c1b5cb3e6e028274046e1a0dbd5fac5" translate="yes" xml:space="preserve">
          <source>The 5 Types of React Application State</source>
          <target state="translated">5 가지 유형의 반응 애플리케이션 상태</target>
        </trans-unit>
        <trans-unit id="8082f45d35153e13c48e541bd18a7f65d42e1b2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;Redux-ORM&lt;/a&gt; library provides a very useful abstraction layer for managing normalized data in a Redux store. It allows you to declare Model classes and define relations between them. It can then generate the empty &quot;tables&quot; for your data types, act as a specialized selector tool for looking up the data, and perform immutable updates on that data.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;돌아 오는-ORM의&lt;/a&gt; 라이브러리는 돌아 오는 저장소에 정규화 된 데이터를 관리하기위한 매우 유용한 추상화 계층을 제공합니다. 모델 클래스를 선언하고 이들 사이의 관계를 정의 할 수 있습니다. 그런 다음 데이터 유형에 대해 빈 &quot;테이블&quot;을 생성하고 데이터를 찾기위한 특수한 선택기 도구 역할을하며 해당 데이터에 대해 불변 업데이트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c005dfb17d1e5ad9227170c4331db15898fd97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reducers#reducers-share-state&quot;&gt;suggested structure&lt;/a&gt; for a Redux store is to split the state object into multiple &quot;slices&quot; or &quot;domains&quot; by key, and provide a separate reducer function to manage each individual data slice.</source>
          <target state="translated">&lt;a href=&quot;reducers#reducers-share-state&quot;&gt;제안 된 구조&lt;/a&gt; 돌아 오는 저장소 키 여러 &quot;분할&quot;또는 &quot;영역&quot;로 상태 객체를 분할하고, 각각의 데이터 조각을 관리하는 별도의 감속기의 기능을 제공하는 것이다.</target>
        </trans-unit>
        <trans-unit id="b9a0e951a049ef97cd89a4e10f26e1e463b189ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; will pass two arguments to the &lt;a href=&quot;reducers&quot;&gt;reducer&lt;/a&gt;: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</source>
          <target state="translated">&lt;a href=&quot;store&quot;&gt;저장소&lt;/a&gt; 받는 두 개의 인수를 전달합니다 &lt;a href=&quot;reducers&quot;&gt;감속기&lt;/a&gt; 현재 상태 트리와 조치 :. 예를 들어, todo 앱에서 루트 리듀서는 다음과 같은 것을 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738fb16f4a3da86b179b5fd2928c5cc0c8706445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; helper function turns an object whose values are different reducing functions into a single reducing function you can pass to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 의 도우미 함수 값을 가지는 사용자가 전달할 수있는 하나의 함수로 감소시키는 기능을 감소시키는 다른 객체 회전 &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a78fbb758be2a28c07a8ce0abb4a2f572f7c0bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;combineReducers&lt;/code&gt; utility included with Redux is very useful, but is deliberately limited to handle a single common use case: updating a state tree that is a plain Javascript object, by delegating the work of updating each slice of state to a specific slice reducer. It does &lt;em&gt;not&lt;/em&gt; handle other use cases, such as a state tree made up of Immutable.js Maps, trying to pass other portions of the state tree as an additional argument to a slice reducer, or performing &quot;ordering&quot; of slice reducer calls. It also does not care how a given slice reducer does its work.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 에 돌아 오는에 포함 된 유틸리티는 매우 유용하지만, 의도적으로 하나의 일반적인 사용 사례를 처리하기 위해 제한 : 특정 슬라이스 감속기에 국가의 각 조각을 업데이트하는 작업을 위임하여, 일반 자바 스크립트 객체 인 상태 트리를 업데이트. Immutable.js Maps로 구성된 상태 트리와 같은 다른 유스 케이스 는 처리 하지 &lt;em&gt;않고&lt;/em&gt; 상태 트리의 다른 부분을 슬라이스 리듀서에 대한 추가 인수로 전달하거나 슬라이스 리듀서 호출의 &quot;순서&quot;를 수행합니다. 또한 주어진 슬라이스 감속기가 작동하는 방식을 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48d1690c6f2d0e9c8b98b4f655fb56dfcdddc0d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connect()&lt;/code&gt; function takes two primary arguments, both optional. The first, &lt;code&gt;mapStateToProps&lt;/code&gt;, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, &lt;code&gt;mapDispatchToProps&lt;/code&gt;, is a function you provide to make use of the store's &lt;code&gt;dispatch&lt;/code&gt; function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 함수는 두 개의 주요 인수, 모두 선택을합니다. 첫 번째 인 &lt;code&gt;mapStateToProps&lt;/code&gt; 는 상점이 변경 될 때 상점에서 데이터를 가져와 해당 값을 소품으로 컴포넌트에 전달하기 위해 제공하는 함수입니다. 두 번째 인 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 는 상점의 &lt;code&gt;dispatch&lt;/code&gt; 기능 을 사용하기 위해 제공하는 기능으로, 일반적으로 조치가 호출 되 자마자 자동으로 조치를 디스패치하는 사전 작성 버전의 조치 작성자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a1f724426f5bed59b6fcff9c426308b18d862500" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dispatch()&lt;/code&gt; function can be accessed directly from the store as &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;, but more likely you'll access it using a helper like &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;'s &lt;code&gt;connect()&lt;/code&gt;. You can use &lt;a href=&quot;../api/bindactioncreators&quot;&gt;&lt;code&gt;bindActionCreators()&lt;/code&gt;&lt;/a&gt; to automatically bind many action creators to a &lt;code&gt;dispatch()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;dispatch()&lt;/code&gt; 함수는 다음과 같이 상점에서 직접 액세스 할 수 있습니다 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt; 하지만, 같은 가능성 당신은 도우미를 사용하여 액세스 할 수 있습니다 &lt;a href=&quot;http://github.com/gaearon/react-redux&quot;&gt;-REDUX 반응&lt;/a&gt; 의를 &lt;code&gt;connect()&lt;/code&gt; . &lt;a href=&quot;../api/bindactioncreators&quot;&gt; &lt;code&gt;bindActionCreators()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 많은 액션 생성자를 &lt;code&gt;dispatch()&lt;/code&gt; 함수 에 자동으로 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cc5ef634bd494a2bcb0eba3ea9aacd39c49c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinctState()&lt;/code&gt; filter serves to ignore the actions that didn't result in a state change. There are &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;many other options&lt;/a&gt; to configure your undoable reducer, like setting the action type for Undo and Redo actions.</source>
          <target state="translated">&lt;code&gt;distinctState()&lt;/code&gt; 필터는 상태 변경을 초래하지 않은 행동을 무시하는 역할을한다. 실행 취소 및 다시 실행 작업에 대한 작업 유형 설정과 같이 실행 취소 가능한 감속기를 구성하는 &lt;a href=&quot;https://github.com/omnidan/redux-undo#configuration&quot;&gt;다른 옵션&lt;/a&gt; 이 많이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e69fb3a56cc38e559d99f56a4e63839a609eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preloadedState&lt;/code&gt; will then be available on the client side by accessing &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;preloadedState&lt;/code&gt; 는 다음에 액세스하여 클라이언트 측에서 사용할 수 있습니다 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454736cedd126ee22b50a1ed19c0f4bfc6ed98d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문은 &lt;em&gt;없습니다&lt;/em&gt; 진짜 보일러. Flux의 실제 상용구는 개념입니다. 업데이트를해야 할 필요성, Dispatcher에 Store를 등록해야 할 필요성, Store가 객체가 될 필요성 및 범용 앱을 원할 때 발생하는 복잡성.</target>
        </trans-unit>
        <trans-unit id="5dfd028dd21b9e32d0060e5d401ade9a104ea3fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switch&lt;/code&gt; statement is &lt;em&gt;not&lt;/em&gt; the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문은 &lt;em&gt;없습니다&lt;/em&gt; 진짜 보일러. Flux의 실제 상용구는 개념입니다. 업데이트를해야 할 필요성, Dispatcher에 Store를 등록해야 할 필요성, Store가 객체가 될 필요성 및 범용 앱을 원할 때 발생하는 복잡성. Redux는 이벤트 이미 터 대신 순수한 감속기를 사용하여 이러한 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="3e916ef3dceacc26ab023c93511c4a41b777908e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Store&lt;/strong&gt; is the object that brings them together. The store has the following responsibilities:</source>
          <target state="translated">&lt;strong&gt;스토어는&lt;/strong&gt; 그들을 함께 제공하는 객체입니다. 상점은 다음과 같은 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dfb0a89f92611bca64f034a94a2f962e4ebd962" translate="yes" xml:space="preserve">
          <source>The Case for Flux</source>
          <target state="translated">플럭스 사례</target>
        </trans-unit>
        <trans-unit id="2be97967a036b4704b556ca385f3d427bc4090d4" translate="yes" xml:space="preserve">
          <source>The Client Side</source>
          <target state="translated">클라이언트 측</target>
        </trans-unit>
        <trans-unit id="8d8895e86bbb9fcbb32585f22afa4849467be15b" translate="yes" xml:space="preserve">
          <source>The Final Approach</source>
          <target state="translated">최종 접근법</target>
        </trans-unit>
        <trans-unit id="2ec2a8c85e269f721fc1b0c962b89cc607899b26" translate="yes" xml:space="preserve">
          <source>The Gist</source>
          <target state="translated">요점</target>
        </trans-unit>
        <trans-unit id="de9191847383c1842749d836c1147436f76724d9" translate="yes" xml:space="preserve">
          <source>The HyperTerm terminal application</source>
          <target state="translated">하이퍼 터미널 터미널 애플리케이션</target>
        </trans-unit>
        <trans-unit id="d571c123a7cfe23b3bbf561d3957e3c00ed11319" translate="yes" xml:space="preserve">
          <source>The Little Idea of Functional Programming</source>
          <target state="translated">함수형 프로그래밍의 작은 아이디어</target>
        </trans-unit>
        <trans-unit id="dfb1aa70710a03922941317888e0b7cc0c028c48" translate="yes" xml:space="preserve">
          <source>The Power of Higher-Order Reducers</source>
          <target state="translated">고차 감속기의 힘</target>
        </trans-unit>
        <trans-unit id="79913e28740ae0370c83c1b4c15cfb9703563d49" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="translated">Redux API 표면은 매우 작습니다. Redux는 &lt;a href=&quot;../glossary#reducer&quot;&gt;리듀서&lt;/a&gt; 와 같은 구현할 계약 세트를 정의하고 이러한 계약을 하나로 묶는 몇 가지 도우미 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb0e273e2c9f9b6f01da6a08131796d0f995d9f2" translate="yes" xml:space="preserve">
          <source>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducers&lt;/a&gt;) and provides a few helper functions to tie these contracts together.</source>
          <target state="translated">Redux API 표면은 작습니다. Redux는 구현할 계약 세트 (예 : &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#reducer&quot;&gt;reducer&lt;/a&gt; )를 정의하고 이러한 계약을 함께 묶는 몇 가지 도우미 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5c1e3f8c2dd5838d397dba36b04c9a62e93369f" translate="yes" xml:space="preserve">
          <source>The Redux reducer API is &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;, but how you create those reducers is up to you.</source>
          <target state="translated">Redux 리듀서 API는 &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; 이지만 이러한 리듀서를 만드는 방법은 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="4558623f708d5c23e2aa2461d3125df5fcd82d4a" translate="yes" xml:space="preserve">
          <source>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;any modern browser&lt;/a&gt;. You don't need to use Babel or a module bundler to &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;get started with Redux&lt;/a&gt;.</source>
          <target state="translated">Redux 소스 코드는 ES2015로 작성되었지만 CommonJS 및 UMD 빌드를 ES5로 사전 컴파일하여 &lt;a href=&quot;http://caniuse.com/#feat=es5&quot;&gt;최신 브라우저&lt;/a&gt; 에서 작동 합니다 . &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html&quot;&gt;Redux를 시작&lt;/a&gt; 하기 위해 Babel 또는 모듈 번 들러를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc1a1a17b3429a96287b0bd69b636f5a14dc84c" translate="yes" xml:space="preserve">
          <source>The Redux-ORM library maintains an internal queue of updates to be applied. Those updates are then applied immutably, simplifying the update process.</source>
          <target state="translated">Redux-ORM 라이브러리는 적용 할 내부 업데이트 큐를 유지 관리합니다. 그런 다음 이러한 업데이트는 변경 불가능하게 적용되어 업데이트 프로세스를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="478f0f344043467133811ff0c84e58dc576376c2" translate="yes" xml:space="preserve">
          <source>The Server Side</source>
          <target state="translated">서버 측</target>
        </trans-unit>
        <trans-unit id="6a5fcafa1bd7939d8a0603992e21bd96c7692240" translate="yes" xml:space="preserve">
          <source>The Tao of Redux, Part 2 - Practice and Philosophy. Thick and thin reducers.</source>
          <target state="translated">Redux의 Tao, 파트 2-실습과 철학. 두껍고 얇은 감속기.</target>
        </trans-unit>
        <trans-unit id="9b46572db1b8dfcd7649cde9229d79fb8affd4f2" translate="yes" xml:space="preserve">
          <source>The actual list of todos.</source>
          <target state="translated">할일의 실제 목록.</target>
        </trans-unit>
        <trans-unit id="5aef95989e50df9f820f46a8576b4cdb580a5dd4" translate="yes" xml:space="preserve">
          <source>The advantage of using the object spread syntax becomes more apparent when you're composing complex objects. Below &lt;code&gt;getAddedIds&lt;/code&gt; maps an array of &lt;code&gt;id&lt;/code&gt; values to an array of objects with values returned from &lt;code&gt;getProduct&lt;/code&gt; and &lt;code&gt;getQuantity&lt;/code&gt;.</source>
          <target state="translated">복잡한 객체를 구성 할 때 객체 스프레드 구문을 사용하는 이점이 더 분명해집니다. &lt;code&gt;getAddedIds&lt;/code&gt; 아래 에서 &lt;code&gt;id&lt;/code&gt; 값 배열을 &lt;code&gt;getProduct&lt;/code&gt; 및 &lt;code&gt;getQuantity&lt;/code&gt; 에서 리턴 된 값을 가진 오브젝트 배열에 맵핑합니다 .</target>
        </trans-unit>
        <trans-unit id="1e2c53398d8416bc804266234b36f940f2c701d5" translate="yes" xml:space="preserve">
          <source>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</source>
          <target state="translated">ES6의 배열 스프레드 연산자 및 향후 버전의 JavaScript에 제안되는 유사한 오브젝트 스프레드 연산자</target>
        </trans-unit>
        <trans-unit id="e3bc116f9668143f3ac5c44b58f1126b54a0f5a3" translate="yes" xml:space="preserve">
          <source>The articles listed in &lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts#Immutable Data Management&lt;/a&gt; give a number of good examples for how to perform basic update operations immutably, such as updating a field in an object or adding an item to the end of an array. However, reducers will often need to use those basic operations in combination to perform more complicated tasks. Here are some examples for some of the more common tasks you might have to implement.</source>
          <target state="translated">&lt;a href=&quot;prerequisiteconcepts#immutable-data-management&quot;&gt;Prerequisite Concepts # Immutable Data Management에&lt;/a&gt; 나열된 기사 는 개체의 필드 업데이트 또는 배열 끝에 항목 추가와 같은 기본 업데이트 작업을 변경하지 않는 방법에 대한 여러 가지 좋은 예를 제공합니다. 그러나 감속기는 종종보다 복잡한 작업을 수행하기 위해 이러한 기본 작업을 조합하여 사용해야합니다. 다음은 구현해야 할 일반적인 작업 중 일부에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="6c3850419731a888edfb498c6aaa6ebf75a3a7c1" translate="yes" xml:space="preserve">
          <source>The base dispatch function &lt;em&gt;always&lt;/em&gt; synchronously sends an action to the store's reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</source>
          <target state="translated">기본 발송 기능은 &lt;em&gt;항상&lt;/em&gt; 동 기적으로 새로운 상태를 계산하기 위해, 가게에 의해 반환 이전 상태와 함께, 가게의 감속기에 작업을 전송합니다. 감속기에서 사용할 준비가 된 일반 객체 일 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="b132326ede652b0ef3bcc14eb28b705253858136" translate="yes" xml:space="preserve">
          <source>The basic concepts of normalizing data are:</source>
          <target state="translated">데이터 정규화의 기본 개념은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e52a5e9fc4db9bd1340d6ab9bc0823d57fe77ab" translate="yes" xml:space="preserve">
          <source>The client side is very straightforward. All we need to do is grab the initial state from &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;, and pass it to our &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; function as the initial state.</source>
          <target state="translated">클라이언트 쪽은 매우 간단합니다. 우리가해야 할 일은 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 에서 초기 상태를 잡고 초기 상태로 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 함수에 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cf2d52f1f096bfa92fc770873878e027f7266621" translate="yes" xml:space="preserve">
          <source>The code reads from the Express &lt;code&gt;Request&lt;/code&gt; object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;http://localhost:3000/?counter=100&lt;/a&gt; in your browser, you'll see the counter starts at 100. In the rendered HTML, you'll see the counter output as 100 and the &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; variable has the counter set in it.</source>
          <target state="translated">이 코드는 서버 미들웨어로 전달 된 Express &lt;code&gt;Request&lt;/code&gt; 오브젝트 에서 읽습니다 . 매개 변수는 숫자로 구문 분석 된 후 초기 상태로 설정됩니다. 당신이 방문하는 경우 &lt;a href=&quot;http://localhost:3000/?counter=100&quot;&gt;에 http : // localhost를 : 3000 / 카운터 = 100&lt;/a&gt; 브라우저에서, 당신이 렌더링 된 HTML에서 (100)에서 카운터의 시작을 볼 수 있습니다, 당신은 100 카운터 출력과 볼 &lt;code&gt;__PRELOADED_STATE__&lt;/code&gt; 의 변수를 카운터를했다 그것을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4826495f8f747fbdf0f71e9d47d5be2bf0b9040a" translate="yes" xml:space="preserve">
          <source>The common question, then, is &quot;How can I use &lt;code&gt;combineReducers&lt;/code&gt; to handle these other use cases?&quot;. The answer to that is simply: &quot;you don't - you probably need to use something else&quot;. &lt;strong&gt;Once you go past the core use case for &lt;code&gt;combineReducers&lt;/code&gt;, it's time to use more &quot;custom&quot; reducer logic&lt;/strong&gt;, whether it be specific logic for a one-off use case, or a reusable function that could be widely shared. Here's some suggestions for dealing with a couple of these typical use cases, but feel free to come up with your own approaches.</source>
          <target state="translated">그렇다면 일반적인 질문은 &quot; &lt;code&gt;combineReducers&lt;/code&gt; 를 사용 하여 이러한 다른 사용 사례를 어떻게 처리 할 수 있습니까?&quot;입니다. 이에 대한 대답은 간단합니다. &quot;그렇지 않습니다. 아마도 다른 것을 사용해야합니다.&quot; &lt;strong&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 의 핵심 사용 사례를 지나면 일회용 사용 사례에 대한&lt;/strong&gt; 특정 논리이든 광범위하게 공유 할 수있는 재사용 가능한 기능이든 &lt;strong&gt;더 많은 &quot;맞춤형&quot;감속기 논리&lt;/strong&gt; 를 사용할 차례입니다. 다음은 이러한 일반적인 사용 사례를 처리하기위한 몇 가지 제안 사항이지만 자신의 접근 방식을 자유롭게 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="1c5f1c9e6c8f5bdeafe0125ff96ed215a380912f" translate="yes" xml:space="preserve">
          <source>The current suggested best practice is to categorize your components as &amp;ldquo;presentational&amp;rdquo; or &amp;ldquo;container&amp;rdquo; components, and extract a connected container component wherever it makes sense:</source>
          <target state="translated">현재 권장되는 모범 사례는 구성 요소를 &quot;프레젠테이션&quot;또는 &quot;컨테이너&quot;구성 요소로 분류하고 해당되는 경우 연결된 컨테이너 구성 요소를 추출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="89bd096d9d762c82ef72e28c42515ef633264780" translate="yes" xml:space="preserve">
          <source>The currently selected visibility filter;</source>
          <target state="translated">현재 선택된 가시성 필터.</target>
        </trans-unit>
        <trans-unit id="edf1af83e4170e21d0f26a22f25cf9daa7c8184e" translate="yes" xml:space="preserve">
          <source>The data lifecycle in any Redux app follows these 4 steps:</source>
          <target state="translated">Redux 앱의 데이터 수명주기는 다음 4 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="62b467d39a23989592c09583e8808c4f173188dd" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don't worry, it's not as hard as it may sound.</source>
          <target state="translated">이를 수행하는 가장 쉬운 방법은 일부 콜백을 통해 동기 코드로 다시 전달하는 것입니다. 이 경우 응답 객체를 참조하고 렌더링 된 HTML을 클라이언트로 다시 보내는 함수가됩니다. 걱정하지 마십시오. 들리는 것처럼 어렵지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4ce871b16323b1c0bb886336edf356b3878eb0d" translate="yes" xml:space="preserve">
          <source>The example is a bit long, because it's showing how all the different slice reducers and case reducers fit together. Note the delegation involved here. The &lt;code&gt;postsById&lt;/code&gt; slice reducer delegates the work for this case to &lt;code&gt;addComment&lt;/code&gt;, which inserts the new Comment's ID into the correct Post item. Meanwhile, both the &lt;code&gt;commentsById&lt;/code&gt; and &lt;code&gt;allComments&lt;/code&gt; slice reducers have their own case reducers, which update the Comments lookup table and list of all Comment IDs appropriately.</source>
          <target state="translated">예제는 약간 길다. 왜냐하면 모든 다른 슬라이스 리듀서와 케이스 리듀서가 서로 어떻게 어울리는지를 보여주기 때문이다. 여기에 관련된 대표단을 주목하십시오. &lt;code&gt;postsById&lt;/code&gt; 슬라이스 리듀서는이 사례에 대한 작업을 &lt;code&gt;addComment&lt;/code&gt; 에 위임합니다 . 그러면 addComment 가 새 Comment의 ID를 올바른 Post 항목에 삽입합니다. 한편, &lt;code&gt;commentsById&lt;/code&gt; 및 &lt;code&gt;allComments&lt;/code&gt; 슬라이스 리듀서는 모두 고유 한 case reducer를 가지고 있으며, 이는 Comments 조회 테이블과 모든 코멘트 ID 목록을 적절하게 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="779dfe0ad26c982a1de5c2e0e8649831bf366e55" translate="yes" xml:space="preserve">
          <source>The examples in this section require React Redux v4.3.0 or greater</source>
          <target state="translated">이 섹션의 예제에는 React Redux v4.3.0 이상이 필요합니다</target>
        </trans-unit>
        <trans-unit id="e75214fea4fb1a9ffce832f2c35732c7381684ab" translate="yes" xml:space="preserve">
          <source>The examples use React, but you should still find them useful if you use something else.</source>
          <target state="translated">예제는 React를 사용하지만 다른 것을 사용하는 경우 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5ea635408bd084da5b7ab91bad09e779b2cf750c" translate="yes" xml:space="preserve">
          <source>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;, or implementing &lt;code&gt;shouldComponentUpdate&lt;/code&gt; in the component by hand and doing a more in-depth props comparison using a function such as &lt;code&gt;_.isEqual&lt;/code&gt;. Be careful to not make your custom &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</source>
          <target state="translated">추가적인 재 - 렌더하여 매핑 배열 캐싱, 환원제를 사용 상태로 오브젝트의 배열을 저장함으로써 해결 될 수있는 &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;다시 선택을&lt;/a&gt; 하거나 구현 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 같은 기능을 이용하여 손으로 부품 및보다 깊이 소품 비교를 수행 &lt;code&gt;_.isEqual&lt;/code&gt; . 사용자 정의 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 가 렌더링 자체보다 비싸지 않도록주의하십시오 ! 항상 프로파일 러를 사용하여 성능에 대한 가정을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0da3ed8f89bdb310cc912494206553bc1426d386" translate="yes" xml:space="preserve">
          <source>The fact that we hide it inside the library doesn't alter this fact.</source>
          <target state="translated">라이브러리 안에 숨기더라도이 사실은 바뀌지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1de0392a7f8331d8c01e93cc6658a1acbeb1d36b" translate="yes" xml:space="preserve">
          <source>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag that will attach &lt;code&gt;preloadedState&lt;/code&gt; to &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt;.</source>
          <target state="translated">서버 측의 마지막 단계는 초기 구성 요소 HTML과 초기 상태를 템플릿에 주입하여 클라이언트 측에서 렌더링하는 것입니다. 상태를 전달하기 위해 &lt;code&gt;preloadedState&lt;/code&gt; 를 &lt;code&gt;window.__PRELOADED_STATE__&lt;/code&gt; 첨부 하는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="dba272babae41e9f815da394011efbc9abd976d3" translate="yes" xml:space="preserve">
          <source>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</source>
          <target state="translated">모든 요청에 ​​대해 가장 먼저해야 할 일은 새로운 Redux 스토어 인스턴스를 만드는 것입니다. 이 스토어 인스턴스의 유일한 목적은 애플리케이션의 초기 상태를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="437ff180e90b483ac82f3a0b997133834d4da2f7" translate="yes" xml:space="preserve">
          <source>The first time the reducer is called, the &lt;code&gt;state&lt;/code&gt; value will be &lt;code&gt;undefined&lt;/code&gt;. The reducer needs to handle this case by supplying a default state value before handling the incoming action.</source>
          <target state="translated">감속기를 처음 호출하면 &lt;code&gt;state&lt;/code&gt; 값이 &lt;code&gt;undefined&lt;/code&gt; . 감속기는 들어오는 동작을 처리하기 전에 기본 상태 값을 제공하여이 경우를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a95e0198d37edafccaeec5cfcad513398e60156" translate="yes" xml:space="preserve">
          <source>The fix is to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;api/store&quot;&gt;store&lt;/a&gt; instance:</source>
          <target state="translated">수정은 &lt;a href=&quot;api/store&quot;&gt;상점&lt;/a&gt; 인스턴스 에서 &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9cbc5ae45e711e0e52c905a6773d8d1b1935dc93" translate="yes" xml:space="preserve">
          <source>The fixed code looks like this:</source>
          <target state="translated">고정 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="023789ed8635b6b65d05d6a4ac33fe464c661c24" translate="yes" xml:space="preserve">
          <source>The following is the outline for what our server side is going to look like. We are going to set up an &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express middleware&lt;/a&gt; using &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; to handle all requests that come in to our server. If you're unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</source>
          <target state="translated">다음은 서버 측의 모습에 대한 개요입니다. 우리는 서버에 들어오는 모든 요청을 처리하기 위해 &lt;a href=&quot;http://expressjs.com/api.html#app.use&quot;&gt;app.use&lt;/a&gt; 를 사용하여 &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;Express 미들웨어&lt;/a&gt; 를 설정하려고 합니다. Express 또는 미들웨어에 익숙하지 않다면 서버가 요청을받을 때마다 handleRender 함수가 호출된다는 것을 알고 계십시오.</target>
        </trans-unit>
        <trans-unit id="4316b779bf18bece5b0ccea09756426fce5c6d7c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; that ships with Redux is similar, but &lt;strong&gt;different in three important aspects&lt;/strong&gt;:</source>
          <target state="translated">Redux와 함께 제공되는 &lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; 구현 은 비슷하지만 &lt;strong&gt;세 가지 중요한 측면에서 다릅니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a9eb650209f72859301cebd361ec76ff3db6f6bc" translate="yes" xml:space="preserve">
          <source>The initial state is zero. Why? Because the second argument to &lt;code&gt;createStore&lt;/code&gt; was &lt;code&gt;undefined&lt;/code&gt;. This is the &lt;code&gt;state&lt;/code&gt; passed to your reducer the first time. When Redux initializes it dispatches a &quot;dummy&quot; action to fill the state. So your &lt;code&gt;counter&lt;/code&gt; reducer was called with &lt;code&gt;state&lt;/code&gt; equal to &lt;code&gt;undefined&lt;/code&gt;. &lt;strong&gt;This is exactly the case that &quot;activates&quot; the default argument.&lt;/strong&gt; Therefore, &lt;code&gt;state&lt;/code&gt; is now &lt;code&gt;0&lt;/code&gt; as per the default &lt;code&gt;state&lt;/code&gt; value (&lt;code&gt;state = 0&lt;/code&gt;). This state (&lt;code&gt;0&lt;/code&gt;) will be returned.</source>
          <target state="translated">초기 상태는 0입니다. 왜? &lt;code&gt;createStore&lt;/code&gt; 에 대한 두 번째 인수 가 &lt;code&gt;undefined&lt;/code&gt; 않았기 때문 입니다. 이것이 처음으로 감속기로 전달 된 &lt;code&gt;state&lt;/code&gt; 입니다. Redux가 초기화되면 &quot;더미&quot;작업을 전달하여 상태를 채 웁니다. 따라서 &lt;code&gt;counter&lt;/code&gt; 감속기는 &lt;code&gt;state&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 와 같은 상태 로 호출되었습니다 . &lt;strong&gt;이것이 바로 기본 인수를 &quot;활성화&quot;하는 경우입니다.&lt;/strong&gt; 따라서 기본 &lt;code&gt;state&lt;/code&gt; 값 ( &lt;code&gt;state = 0&lt;/code&gt; )에 따라 &lt;code&gt;state&lt;/code&gt; 는 이제 &lt;code&gt;0&lt;/code&gt; 입니다. 이 상태 ( &lt;code&gt;0&lt;/code&gt; )가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f1870e4c91c65906a132e8ab3a09c561bb5d7c0e" translate="yes" xml:space="preserve">
          <source>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</source>
          <target state="translated">여기서 흥미로운 부분은 숫자, 문자열, 배열 또는 객체의 실행 취소 스택을 유지할지 여부는 중요하지 않다는 것입니다. 구조는 항상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aced1e5fb79ae68b6eba1085040abdf61e8e93fd" translate="yes" xml:space="preserve">
          <source>The invoke function runs our middleware in the same way Redux does.</source>
          <target state="translated">invoke 함수는 Redux와 같은 방식으로 미들웨어를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d2e2db63b16b97293e72fee9e740a81bd129896c" translate="yes" xml:space="preserve">
          <source>The key step in server side rendering is to render the initial HTML of our component &lt;em&gt;&lt;strong&gt;before&lt;/strong&gt;&lt;/em&gt; we send it to the client side. To do this, we use &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString()&lt;/a&gt;.</source>
          <target state="translated">서버 측 렌더링의 핵심 단계는 컴포넌트 &lt;em&gt;&lt;strong&gt;를&lt;/strong&gt;&lt;/em&gt; 클라이언트 측으로 보내기 &lt;em&gt;&lt;strong&gt;전에&lt;/strong&gt;&lt;/em&gt; 컴포넌트의 초기 HTML을 렌더링하는 것입니다. 이를 위해 &lt;a href=&quot;https://facebook.github.io/react/docs/react-dom-server.html#rendertostring&quot;&gt;ReactDOMServer.renderToString ()을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ebf3991556cfed7c3eed26e9a4ebee92564c0c2e" translate="yes" xml:space="preserve">
          <source>The key to updating nested data is &lt;strong&gt;that &lt;em&gt;every&lt;/em&gt; level of nesting must be copied and updated appropriately&lt;/strong&gt;. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.</source>
          <target state="translated">중첩 된 데이터를 업데이트하는 열쇠는 &lt;strong&gt;것을 &lt;em&gt;모든&lt;/em&gt; 중첩 수준을 복사하고 적절하게 업데이트해야합니다&lt;/strong&gt; . 이것은 종종 Redux를 배우는 사람들에게는 어려운 개념이며 중첩 된 객체를 업데이트하려고 할 때 자주 발생하는 특정 문제가 있습니다. 이로 인해 우발적 인 직접 돌연변이가 발생하므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1f13b41716a56d3a6b663d8adeef0fbfebcd6da" translate="yes" xml:space="preserve">
          <source>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</source>
          <target state="translated">풀 요청에서 추가, 제거 및 변경된 작업 유형 목록은 팀의 모든 사람이 범위와 새로운 기능의 구현을 추적하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a909efdb80760679c43fc5e7380d281a27aa83b" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="translated">리스너가 호출되기 전에 중첩 된 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 중에 상태가 여러 번 업데이트되었을 수 있으므로 리스너는 모든 상태 변경을 볼 수 없습니다 . 그러나 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 시작 되기 전에 등록 된 모든 구독자 는 종료 될 때까지 최신 상태로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c8d57f0dc666d6c5ce99071844c64516efa85351" translate="yes" xml:space="preserve">
          <source>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; before the listener is called. It is, however, guaranteed that all subscribers registered before the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; started will be called with the latest state by the time it exits.</source>
          <target state="translated">리스너가 호출되기 전에 중첩 된 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 동안 상태가 여러 번 업데이트되었을 수 있으므로 리스너는 모든 상태 변경을 기 대해서는 안됩니다 . 그러나 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 시작 되기 전에 등록 된 모든 구독자 는 종료 될 때 최신 상태로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dfc2ce49bb9fba9f11cb4c299cb527330ef38e0b" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="translated">리스너는 사용자 조치에 대한 응답 또는 특정 조건 (예 : 상점에 특정 필드가있을 때 조치 디스패치 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 에서만 dispatch () 를 호출해야합니다 . 조건없이 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것은 기술적으로 가능하지만 모든 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출이 일반적으로 리스너를 다시 트리거하므로 무한 루프가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="488cee853ee8f2ee1b7b34adadde5165f8f7a005" translate="yes" xml:space="preserve">
          <source>The listener should only call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; without any conditions is technically possible, however it leads to an infinite loop as every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call usually triggers the listener again.</source>
          <target state="translated">리스너는 사용자 작업에 대한 응답으로 또는 특정 조건 (예 : 상점에 특정 필드가있을 때 작업을 전달하는 경우 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 에서만 dispatch () 를 호출해야합니다 . 조건없이 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것은 기술적으로 가능하지만 모든 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출이 일반적으로 리스너를 다시 트리거하므로 무한 루프가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f1a0911c22c72f7c2742cacaf4dc763e35a23b3f" translate="yes" xml:space="preserve">
          <source>The logic for retrieving or updating a given item is now fairly simple and consistent. Given an item's type and its ID, we can directly look it up in a couple simple steps, without having to dig through other objects to find it.</source>
          <target state="translated">주어진 항목을 가져 오거나 업데이트하는 논리는 이제 매우 간단하고 일관성이 있습니다. 항목의 유형과 ID가 주어지면 다른 개체를 찾아서 찾지 않고도 몇 가지 간단한 단계를 통해 직접 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3c8144b116952a7e48b511c8b6726d8e7f3ef8" translate="yes" xml:space="preserve">
          <source>The middleware that interprets such actions could look like this:</source>
          <target state="translated">이러한 동작을 해석하는 미들웨어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d682e36630596f87baf92e1be74cab220ee7bbc6" translate="yes" xml:space="preserve">
          <source>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it's necessary to map any asynchronous fetches into a synchronous operation.</source>
          <target state="translated">서버 측 렌더링의 가장 일반적인 문제는 비동기 적으로 발생하는 상태를 처리하는 것입니다. 서버에서의 렌더링은 본질적으로 동기식이므로 비동기 페치를 동기 오퍼레이션에 맵핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bd487c6f173028a7534d7c66f721bcbc1a7152f" translate="yes" xml:space="preserve">
          <source>The most common state shape for a Redux app is a plain Javascript object containing &quot;slices&quot; of domain-specific data at each top-level key. Similarly, the most common approach to writing reducer logic for that state shape is to have &quot;slice reducer&quot; functions, each with the same &lt;code&gt;(state, action)&lt;/code&gt; signature, and each responsible for managing all updates to that specific slice of state. Multiple slice reducers can respond to the same action, independently update their own slice as needed, and the updated slices are combined into the new state object.</source>
          <target state="translated">Redux 앱의 가장 일반적인 상태 형태는 각 최상위 키에서 도메인 별 데이터의 &quot;슬라이스&quot;를 포함하는 일반 Javascript 객체입니다. 마찬가지로, 해당 상태 형태에 대한 감속기 논리를 작성하는 가장 일반적인 방법은 각각 동일한 &lt;code&gt;(state, action)&lt;/code&gt; 서명 을 가진 &quot;슬라이스 감속기&quot;기능을 사용하고 각 특정 상태 조각에 대한 모든 업데이트를 관리하는 역할을하는 것입니다. 다중 슬라이스 감속기는 동일한 동작에 응답하고 필요에 따라 자체 슬라이스를 독립적으로 업데이트 할 수 있으며 업데이트 된 슬라이스는 새로운 상태 객체로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="93bd18e049d16d78b6a4f2d8ab6b83aaccc924a2" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="translated">미들웨어의 가장 일반적인 사용 사례는 많은 상용구 코드 또는 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt; 와 같은 라이브러리에 대한 종속성없이 비동기 조치를 지원하는 것 입니다. 일반적인 작업 외에도 &lt;a href=&quot;../glossary#async-action&quot;&gt;비동기 작업&lt;/a&gt; 을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eabd6d6748896987c05d969d3d0db08e988f3bce" translate="yes" xml:space="preserve">
          <source>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt;. It does so by letting you dispatch &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#async-action&quot;&gt;async actions&lt;/a&gt; in addition to normal actions.</source>
          <target state="translated">미들웨어의 가장 일반적인 사용 사례는 많은 상용구 코드 나 &lt;a href=&quot;https://github.com/Reactive-Extensions/RxJS&quot;&gt;Rx&lt;/a&gt; 와 같은 라이브러리에 대한 종속성없이 비동기 작업을 지원하는 것 입니다. 일반 작업에 추가하여 &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#async-action&quot;&gt;비동기 작업&lt;/a&gt; 을 전달할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="5ca5c9f8c9076592f848e34b0f4212ad6547c204" translate="yes" xml:space="preserve">
          <source>The most common use case for server-side rendering is to handle the &lt;em&gt;initial render&lt;/em&gt; when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</source>
          <target state="translated">서버 측 렌더링의 가장 일반적인 사용 사례 는 사용자 (또는 검색 엔진 크롤러)가 앱을 처음 요청할 때 &lt;em&gt;초기 렌더링&lt;/em&gt; 을 처리하는 것입니다. 서버는 요청을 받으면 필요한 구성 요소를 HTML 문자열로 렌더링 한 다음 클라이언트에 대한 응답으로 보냅니다. 그 시점부터 클라이언트는 렌더링 작업을 인계받습니다.</target>
        </trans-unit>
        <trans-unit id="24ae76922e0a16060847d467d7cc8498c8e8fd41" translate="yes" xml:space="preserve">
          <source>The most na&amp;iuml;ve solution is just to log the action and the next state yourself every time you call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;. It's not really a solution, but just a first step towards understanding the problem.</source>
          <target state="translated">가장 순진한 솔루션은 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; 를 호출 할 때마다 작업과 다음 상태를 기록하는 것 입니다. 실제로 해결책은 아니지만 문제를 이해하기위한 첫 번째 단계 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c28210a81ca17cd5297b553285382ceab58a3637" translate="yes" xml:space="preserve">
          <source>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</source>
          <target state="translated">새로운 Counter Vanilla 예제는 Redux에 Webpack, React, 핫 리로딩, sagas, 액션 제작자, 상수, Babel, npm, CSS 모듈, 데코레이터, 유창한 라틴어, Egghead 구독, PhD 또는 Exceeds가 필요하다는 신화를 없애기위한 것입니다. 기대 올빼미 수준.</target>
        </trans-unit>
        <trans-unit id="93fb65536a0476327978e11533ea1a5d24a10c81" translate="yes" xml:space="preserve">
          <source>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</source>
          <target state="translated">Redux DevTools와 같은 스토어 인핸서 구현을 단순화하기 위해 새 상태가 리스너에 전달되지 않습니다. 또한 가입자는 조치가 아닌 상태 값 자체에 반응하도록 의도됩니다. 조치가 중요하고 구체적으로 처리해야하는 경우 미들웨어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e78ce3d1d64476af75b7e5f41d5be781a323a4c" translate="yes" xml:space="preserve">
          <source>The nice thing about thunks is that they can dispatch results of each other:</source>
          <target state="translated">썽크에 대한 좋은 점은 서로의 결과를 전달할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d99c20eac2d1658b7df0891305cdca243a9af62" translate="yes" xml:space="preserve">
          <source>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</source>
          <target state="translated">서버 측 코드의 유일한 입력은 브라우저에서 앱의 페이지를로드 할 때 요청입니다. 부팅하는 동안 서버를 구성하도록 선택할 수 있지만 (예 : 개발 환경과 프로덕션 환경에서 실행중인 경우) 해당 구성은 정적입니다.</target>
        </trans-unit>
        <trans-unit id="0f86933dcbbe66c8f04e7c9fc359e8fa49b3f7f3" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="translated">&lt;code&gt;bindActionCreators&lt;/code&gt; 의 유일한 사용 사례 는 일부 액션 생성자를 Redux를 인식하지 못하는 구성 요소로 전달하고 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 또는 Redux 저장소를 전달하지 않으려 는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="11679d519383db9e97765680c1c087a4c5d58e4d" translate="yes" xml:space="preserve">
          <source>The only use case for &lt;code&gt;bindActionCreators&lt;/code&gt; is when you want to pass some action creators down to a component that isn't aware of Redux, and you don't want to pass &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; or the Redux store to it.</source>
          <target state="translated">&lt;code&gt;bindActionCreators&lt;/code&gt; 의 유일한 사용 사례 는 Redux를 인식하지 않는 구성 요소에 일부 작업 생성자를 전달하고 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 또는 Redux 저장소를 전달하지 않으려 는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="66b4d49e553bb0efa470bbe85e68619297117596" translate="yes" xml:space="preserve">
          <source>The only way to change the state inside it is to dispatch an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; on it.</source>
          <target state="translated">그것이 파견하는 내부 유일한 방법은 상태를 변경하는 &lt;a href=&quot;../glossary#action&quot;&gt;조치를&lt;/a&gt; 그 위에.</target>
        </trans-unit>
        <trans-unit id="3d51f5c9be0da0a1475d839514b718722284186c" translate="yes" xml:space="preserve">
          <source>The only way to change the state tree is to emit an &lt;em&gt;action&lt;/em&gt;, an object describing what happened.</source>
          <target state="translated">상태 트리를 변경하는 유일한 방법은 발생한 &lt;em&gt;작업을&lt;/em&gt; 설명하는 객체 인 &lt;em&gt;action&lt;/em&gt; 을 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c24d16d7147d4d6eb8c10527b6a9d45b0beb9c87" translate="yes" xml:space="preserve">
          <source>The option we recommend is to use a special React Redux component called &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;magically&lt;/a&gt; make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</source>
          <target state="translated">권장되는 옵션은 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; &lt;/a&gt; 라는 특수 React Redux 구성 요소를 사용하여 명시 적으로 전달하지 않고 응용 프로그램의 모든 컨테이너 구성 요소에서 저장소 를 &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;마술처럼&lt;/a&gt; 사용할 수 있도록하는 것입니다. 루트 컴포넌트를 렌더링 할 때 한 번만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="648fab04f4ba80945b0b8fe210f400cb5cd99721" translate="yes" xml:space="preserve">
          <source>The original Flux pattern describes having multiple &amp;ldquo;stores&amp;rdquo; in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store &amp;ldquo;&lt;code&gt;waitFor&lt;/code&gt;&amp;rdquo; another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</source>
          <target state="translated">원래 Flux 패턴은 앱에 여러 개의 &quot;저장소&quot;가 있으며 각각은 서로 다른 도메인 데이터 영역을 보유합니다. 이로 인해 한 상점에서 다른 상점을 &amp;ldquo; &lt;code&gt;waitFor&lt;/code&gt; &amp;rdquo;업데이트 해야하는 등의 문제가 발생할 수 있습니다 . 데이터 도메인 사이의 분리는 단일 리듀서를 더 작은 리듀서로 분할하여 이미 수행되므로 Redux에서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62ee23332a72fc3750f78243b123043b65f95888" translate="yes" xml:space="preserve">
          <source>The question is: do you really need Redux if you already use Rx? Maybe not. It's not hard to &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;re-implement Redux in Rx&lt;/a&gt;. Some say it's a two-liner using Rx &lt;code&gt;.scan()&lt;/code&gt; method. It may very well be!</source>
          <target state="translated">문제는 이미 Rx를 사용하고 있다면 실제로 Redux가 필요합니까? 아마. &lt;a href=&quot;https://github.com/jas-chen/rx-redux&quot;&gt;Rx에서 Redux&lt;/a&gt; 를 다시 구현하는 것은 어렵지 않습니다 . 일부는 Rx &lt;code&gt;.scan()&lt;/code&gt; 메서드를 사용하는 2 라이너라고 말합니다 . 아주 좋을 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="b112f1eaa085df10f0fb3a949e7c7d0512123ef7" translate="yes" xml:space="preserve">
          <source>The reducer &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; signature makes it natural to implement generic &amp;ldquo;reducer enhancers&amp;rdquo; or &amp;ldquo;higher order reducers&amp;rdquo;. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</source>
          <target state="translated">감속기 &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; 서명은 일반적인 &quot;감소 기 향상 기&quot;또는 &quot;고차 감속기&quot;를 구현하는 것이 당연합니다. 그것들은 리듀서를 가져 와서 서명을 유지하면서 몇 가지 추가 기능으로 향상시키는 기능입니다. 실행 취소 기록은 정확히 그런 경우입니다.</target>
        </trans-unit>
        <trans-unit id="831cdccd0fe29b2292b102e71a67a95df749f9a5" translate="yes" xml:space="preserve">
          <source>The reducer generated by &lt;code&gt;combineReducers({ a, b })&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;combineReducers({ a, b })&lt;/code&gt; 의해 생성 된 감속기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="579bccc1a8ba0deb299c67fd02b66c1a0bde82b3" translate="yes" xml:space="preserve">
          <source>The reducer logic doesn't have to deal with deep levels of nesting, so it will probably be much simpler.</source>
          <target state="translated">감속기 논리는 깊은 수준의 중첩을 처리 할 필요가 없으므로 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8b251f78a3911e16c890bcff055432910c7e244e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by merging the new data into the state they manage and resetting &lt;code&gt;isFetching&lt;/code&gt;. The UI would hide the spinner, and display the fetched data.</source>
          <target state="translated">감속기는 새 데이터를 관리하고 &lt;code&gt;isFetching&lt;/code&gt; 재설정 상태로 병합하여이 작업을 처리 할 수 ​​있습니다 . UI는 스피너를 숨기고 가져온 데이터를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ef702e159de1a7ac56e685ea8e6312a6d8a5ae0e" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by resetting &lt;code&gt;isFetching&lt;/code&gt;. Additionally, some reducers may want to store the error message so the UI can display it.</source>
          <target state="translated">감속기는 &lt;code&gt;isFetching&lt;/code&gt; 을 재설정 하여이 작업을 처리 할 수 ​​있습니다 . 또한 일부 리듀서는 UI가 표시 할 수 있도록 오류 메시지를 저장하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3589533d63065a42192671f978f7884a00c50eb" translate="yes" xml:space="preserve">
          <source>The reducers may handle this action by toggling an &lt;code&gt;isFetching&lt;/code&gt; flag in the state. This way the UI knows it's time to show a spinner.</source>
          <target state="translated">감속기는 상태에서 &lt;code&gt;isFetching&lt;/code&gt; 플래그를 토글하여이 조치를 처리 할 수 ​​있습니다 . 이런 식으로 UI는 스피너를 보여줄 시간을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="fb415aec3abf5f69e7a7dbc95599da2a8b59bb09" translate="yes" xml:space="preserve">
          <source>The remove function could also be implemented as:</source>
          <target state="translated">제거 기능은 다음과 같이 구현 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="34eee3e75bb47e88848e238f22d63bbf7668e6ee" translate="yes" xml:space="preserve">
          <source>The request contains information about the URL requested, including any query parameters, which will be useful when using something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;. It can also contain headers with inputs like cookies or authorization, or POST body data. Let's see how we can set the initial counter state based on a query parameter.</source>
          <target state="translated">요청에는 쿼리 매개 변수를 포함하여 요청 된 URL에 대한 정보가 포함되어 있으며 이는 &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt; 와 같은 것을 사용할 때 유용합니다 . 쿠키 또는 권한 부여 또는 POST 본문 데이터와 같은 입력이있는 헤더를 포함 할 수도 있습니다. 쿼리 매개 변수를 기반으로 초기 카운터 상태를 설정하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cb8346bc09abdc2bdbbd4e730bada908b5a84b2e" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The shape of the state object matches the keys of the passed &lt;code&gt;reducers&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">결과 리듀서는 모든 하위 리듀서를 호출하고 결과를 단일 상태 객체로 수집합니다. &lt;strong&gt;상태 객체의 모양은 전달 된 &lt;code&gt;reducers&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 의 키와 일치합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bebc73dea03ed82f283ad8c04dfdcbf094d7911a" translate="yes" xml:space="preserve">
          <source>The resulting reducer calls every child reducer, and gathers their results into a single state object. &lt;strong&gt;The state produced by &lt;code&gt;combineReducers()&lt;/code&gt; namespaces the states of each reducer under their keys as passed to &lt;code&gt;combineReducers()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">결과 감속기는 모든 하위 감속기를 호출하고 결과를 단일 상태 객체로 수집합니다. &lt;strong&gt;제조 상태 &lt;code&gt;combineReducers()&lt;/code&gt; 에 전달 된 것처럼 열쇠 하에서 각 감속기의 상태를 네임 스페이스 &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="191b4037dec326d03a76e5e3d99a324826c75a29" translate="yes" xml:space="preserve">
          <source>The shallow check of &lt;code&gt;param&lt;/code&gt; and &lt;code&gt;returnValue&lt;/code&gt; simply checks whether both variables reference the same object, which they do.&lt;code&gt;mutateObj()&lt;/code&gt; may return a mutated version of &lt;code&gt;obj&lt;/code&gt;, but it's still the same object as that passed in. The fact that its values have been changed within &lt;code&gt;mutateObj&lt;/code&gt; matters not at all to a shallow check.</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt; 및 &lt;code&gt;returnValue&lt;/code&gt; 의 얕은 검사는 단순히 두 변수가 동일한 객체를 참조하는지 여부를 확인합니다. &lt;code&gt;mutateObj()&lt;/code&gt; 는 &lt;code&gt;obj&lt;/code&gt; 의 변형 된 버전을 반환 할 수 있지만 여전히 전달 된 것과 동일한 객체입니다. &lt;code&gt;mutateObj&lt;/code&gt; 내에서 값이 변경되었다는 사실 은 전혀 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc6715934729123df24e127a2b31fa31c6f3d1d9" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to do this is to add the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; which lets you write more synchronous-looking code using generators, and can act like &amp;ldquo;background threads&amp;rdquo; or &amp;ldquo;daemons&amp;rdquo; in a Redux app. Yet another approach is &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt;, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are &lt;em&gt;many&lt;/em&gt; other community-developed libraries and ideas, each with their own take on how side effects should be managed.</source>
          <target state="translated">가장 간단하고 일반적인 방법은 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; 미들웨어 를 추가하여 보다 복잡하고 비동기적인 로직으로 액션 제작자를 작성할 수 있습니다. 널리 사용되는 또 다른 방법 인 &lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;Redux Saga&lt;/a&gt; 는 생성기를 사용하여보다 동 기적으로 보이는 코드를 작성하고 Redux 앱에서 &quot;백그라운드 스레드&quot;또는 &quot;데몬&quot;처럼 작동 할 수 있습니다. 또 다른 접근 방식은 &lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;Redux Loop&lt;/a&gt; 인데, 이는 감속기가 상태 변경에 따라 부작용을 선언하고 별도로 실행하도록하여 프로세스를 반전시킵니다. 그 외에도 커뮤니티 개발 라이브러리와 아이디어 가 &lt;em&gt;많이&lt;/em&gt; 있으며, 각각 자체적으로 부작용을 관리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a1ef44d7beed8bc507d7e3d3fa102d8a5af7a998" translate="yes" xml:space="preserve">
          <source>The simplest example of middleware is &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;. &lt;strong&gt;&amp;ldquo;Thunk&amp;rdquo; middleware lets you write action creators as &amp;ldquo;thunks&amp;rdquo;, that is, functions returning functions.&lt;/strong&gt; This inverts the control: you will get &lt;code&gt;dispatch&lt;/code&gt; as an argument, so you can write an action creator that dispatches many times.</source>
          <target state="translated">미들웨어의 가장 간단한 예는 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; 입니다. &lt;strong&gt;&quot;썽크&quot;미들웨어를 사용하면 액션 제작자를 &quot;썽크&quot;즉 함수를 반환하는 함수로 작성할 수 있습니다. &lt;/strong&gt;이렇게하면 컨트롤이 반전됩니다. &lt;code&gt;dispatch&lt;/code&gt; 를 인수로 받아 여러 번 디스패치하는 액션 작성자를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a224c5bb5c7b0257b4abc9573a41ae755e11d225" translate="yes" xml:space="preserve">
          <source>The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:</source>
          <target state="translated">감속기 논리를 작성하는 가장 간단한 방법은 다음과 같이 모든 것을 단일 함수 선언에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="df00019572e1d526628ee1357601871796c2e3aa" translate="yes" xml:space="preserve">
          <source>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</source>
          <target state="translated">상태는 이미 불변이고, 돌연변이는 이미 불 연속적 정신 모델에 가까운 불연속 행동으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="4e2a0df854ac3a6ba67f8bf8af131bbbadf64b8c" translate="yes" xml:space="preserve">
          <source>The store will still be updated with the new values for the root state, but because the root state object itself is still the same object, libraries that bind to Redux, such as React-Redux, will not be aware of the state&amp;rsquo;s mutation, and so will not trigger a wrapped component&amp;rsquo;s re-rendering.</source>
          <target state="translated">저장소는 여전히 루트 상태에 대한 새로운 값으로 업데이트되지만 루트 상태 객체 자체는 여전히 동일한 객체이므로 React-Redux와 같이 Redux에 바인딩하는 라이브러리는 상태의 돌연변이를 인식하지 못합니다. 래핑 된 구성 요소의 다시 렌더링을 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f3016ca7583094ba4738ed1d27a81993f9cabc7" translate="yes" xml:space="preserve">
          <source>The store's reducing function will be called with the current &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; result and the given &lt;code&gt;action&lt;/code&gt; synchronously. Its return value will be considered the next state. It will be returned from &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; from now on, and the change listeners will immediately be notified.</source>
          <target state="translated">상점의 축소 함수는 현재 &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 결과 및 지정된 &lt;code&gt;action&lt;/code&gt; 동 기적 으로 호출됩니다 . 반환 값은 다음 상태로 간주됩니다. 이제부터 &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 에서 리턴되며 변경 리스너에게 즉시 통지됩니다.</target>
        </trans-unit>
        <trans-unit id="cea20ac25d592424eac6b0baa84b4cb2827c5999" translate="yes" xml:space="preserve">
          <source>The sub-app approach is also useful for large teams that are divided by product or feature verticals. These teams can ship sub-apps independently or in combination with an enclosing &amp;ldquo;app shell&amp;rdquo;.</source>
          <target state="translated">하위 앱 접근 방식은 제품 또는 기능 카테고리로 구분 된 대규모 팀에도 유용합니다. 이 팀은 하위 앱을 독립적으로 또는 둘러싼 &quot;앱 셸&quot;과 함께 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="375db8357be87b44ec99ec266964bcb0566ca944" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="translated">구독은 모든 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출 직전에 스냅 샷 됩니다. 리스너가 호출되는 동안 구독 또는 구독 취소하면 현재 진행중인 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 에 영향을 미치지 않습니다 . 그러나 다음 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출은 중첩 여부에 관계없이 구독 목록의 최신 스냅 샷을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="80feb06d33ae82b791c73d4ad38cfd11b702fe4b" translate="yes" xml:space="preserve">
          <source>The subscriptions are snapshotted just before every &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; that is currently in progress. However, the next &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; call, whether nested or not, will use a more recent snapshot of the subscription list.</source>
          <target state="translated">구독은 모든 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출 직전에 스냅 샷이 생성됩니다 . 리스너가 호출되는 동안 구독 또는 구독 취소하면 현재 진행중인 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 에 영향을주지 않습니다 . 그러나 다음 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 호출은 중첩 여부에 관계없이 구독 목록의 최신 스냅 샷을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e3fcb31aa94b0e76b32e4908a5de1c115f3b15a7" translate="yes" xml:space="preserve">
          <source>The suggested structure for a Redux store is to split the state object into multiple &amp;ldquo;slices&amp;rdquo; or &amp;ldquo;domains&amp;rdquo; by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; utility function to make this pattern easier. However, it's important to note that &lt;code&gt;combineReducers&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; required&amp;mdash;it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</source>
          <target state="translated">Redux 스토어에 제안 된 구조는 키를 사용하여 상태 객체를 여러 &quot;슬라이스&quot;또는 &quot;도메인&quot;으로 분할하고 각 개별 데이터 슬라이스를 관리하는 별도의 감속기 기능을 제공하는 것입니다. 이는 표준 Flux 패턴에 여러 개의 독립적 인 상점이있는 방식과 유사하며 Redux는 이 패턴을보다 쉽게 ​​만들기 위해 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; 유틸리티 기능을 제공합니다 . 그러나 &lt;code&gt;combineReducers&lt;/code&gt; 는 필요 &lt;em&gt;하지 않습니다&lt;/em&gt; . 이는 데이터에 대한 일반 JavaScript 객체와 함께 상태 슬라이스 당 단일 감속기 기능을 갖는 일반적인 사용 사례에 대한 유틸리티 기능 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="19890ee5401ad9b13da13113d9a0a8f02936561b" translate="yes" xml:space="preserve">
          <source>The term &quot;&lt;em&gt;sub-reducer&lt;/em&gt;&quot; has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as &quot;&lt;em&gt;business logic&lt;/em&gt;&quot; (functions that relate to application-specific behavior) or &quot;&lt;em&gt;utility functions&lt;/em&gt;&quot; (generic functions that are not application-specific).</source>
          <target state="translated">용어 &quot; &lt;em&gt;하위 환원 기 (sub-reducer)&lt;/em&gt; &quot;는 다양한 논의에서 루트 리듀서가 아닌 임의의 기능을 의미하기 위해 사용되었지만, 그 용어는 매우 정확하지는 않다. 일부 사람들은 일부 기능을 &quot; &lt;em&gt;비즈니스 로직&lt;/em&gt; &quot;(응용 프로그램 특정 동작과 관련된 기능) 또는 &quot; &lt;em&gt;유틸리티 기능&lt;/em&gt; &quot;(응용 프로그램 특정이 아닌 일반 기능 ) 이라고도 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4efb799026840b45f617b41420282694075bcbb5" translate="yes" xml:space="preserve">
          <source>The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:</source>
          <target state="translated">감속기를 특수화하는 가장 일반적인 두 가지 방법은 지정된 접두사 또는 접미사를 사용하여 새로운 동작 상수를 생성하거나 동작 객체 내부에 추가 정보를 첨부하는 것입니다. 그 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8244d8d3077f561bcd0f5377b25ede16bd17a723" translate="yes" xml:space="preserve">
          <source>The whole state of your app is stored in an object tree inside a single &lt;em&gt;store&lt;/em&gt;.</source>
          <target state="translated">앱의 전체 상태는 단일 &lt;em&gt;저장소&lt;/em&gt; 내의 객체 트리에 &lt;em&gt;저장&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b55a43c532a7c8e9947bf52f67dd941ff93ac2e5" translate="yes" xml:space="preserve">
          <source>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it's certainly &lt;em&gt;possible&lt;/em&gt; for each of these to become a performance concern in sufficiently complex situations, there's nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders, and React-Redux v5 shows noticeable improvements over earlier versions.</source>
          <target state="translated">Redux가 수행하는 작업은 일반적으로 미들웨어 및 감속기의 작업 처리 (불변 업데이트에 대한 객체 복제 포함), 작업이 발송 된 후 가입자에게 알리기 및 상태 변경에 따라 UI 구성 요소 업데이트와 같은 몇 가지 영역에 속합니다. 그것은 확실히이지만 &lt;em&gt;가능한&lt;/em&gt; 이들 각각이 충분히 복잡한 상황에서 성능 문제가 될 때까지, 돌아 오는 구현하는 방법에 대한 본질적으로 느리거나 비효율적 아무것도 없다. 실제로 React Redux는 특히 불필요한 다시 렌더링을 줄 이도록 최적화되어 있으며 React-Redux v5는 이전 버전보다 눈에 띄게 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="e621bbd33e777ec7ef3871509510242d1781c64a" translate="yes" xml:space="preserve">
          <source>The work on Redux was &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;funded by the community&lt;/a&gt;.</source>
          <target state="translated">Redux에 대한 연구 &lt;a href=&quot;https://www.patreon.com/reactdx&quot;&gt;는 지역 사회에 의해 자금&lt;/a&gt; 이 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0e58a6fbd2c7776a43fa3f20f5482c786c5abf51" translate="yes" xml:space="preserve">
          <source>Then your reducer might look like this:</source>
          <target state="translated">그러면 감속기가 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b64fceb751659a715e3ef58186964669c75267" translate="yes" xml:space="preserve">
          <source>Then, add this to &lt;code&gt;scripts&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;scripts&lt;/code&gt; 에 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="e96f86541d1773854c7bcc0e179868209a9a8589" translate="yes" xml:space="preserve">
          <source>There are a few important bits here:</source>
          <target state="translated">여기 몇 가지 중요한 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d06a233fcb86cede2504f1d8109e3efa70aa46c" translate="yes" xml:space="preserve">
          <source>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as &lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt;, &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt;, &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt;, and more. It's also possible to apply Redux's principles and concept of reducers to the task of updating local component state as well, along the lines of &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tonyhb/redux-ui&quot;&gt;redux-ui&lt;/a&gt; , &lt;a href=&quot;https://github.com/tomchentw/redux-component&quot;&gt;redux-component&lt;/a&gt; , &lt;a href=&quot;https://github.com/threepointone/redux-react-local&quot;&gt;redux-react-local&lt;/a&gt; 등과 같은 Redux 저장소에 구성 요소 별 상태를 저장하기위한 다양한 접근 방식을 구현하는 여러 커뮤니티 패키지가 있습니다. &lt;code&gt;this.setState( (previousState) =&amp;gt; reducer(previousState, someAction))&lt;/code&gt; 라인을 따라 Redux의 리듀서 원칙과 리듀서 개념을 로컬 구성 요소 상태 업데이트 작업에도 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0014d11cb95b6c4884244108322b1ff44ccf44a1" translate="yes" xml:space="preserve">
          <source>There are also utility libraries to aid in generating action creators, such as &lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; and &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;. These can help reduce boilerplate code and enforce adherence to standards such as &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action (FSA)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; 와 같은 액션 생성자를 생성하는 데 도움이되는 유틸리티 라이브러리도 있습니다 . 이를 통해 상용구 코드를 줄이고 Flua &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Standard Action (FSA)&lt;/a&gt; 과 같은 표준을 준수 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d7c3fb839d1de9f174190d1095682848236da15" translate="yes" xml:space="preserve">
          <source>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;hot reloading with time travel&lt;/a&gt;. If you'd rather modify data directly, you don't need Redux.</source>
          <target state="translated">Flux와 유사하다고 주장하지만 액션 객체의 개념이없는 프레임 워크가 있습니다. 예측 가능하다는 점에서 Flux 또는 Redux에서 한 단계 뒤로 이동합니다. 직렬화 가능한 일반 객체 작업이없는 경우 사용자 세션을 기록 및 재생하거나 &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;시간 여행으로 핫 리로딩&lt;/a&gt; 을 구현할 수 없습니다 . 데이터를 직접 수정하려는 경우 Redux가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfa801b0cb8664a9ae599fb04c53df6ce12bf658" translate="yes" xml:space="preserve">
          <source>There are no multiple models&amp;mdash;just a state subtree that you want to keep track of.</source>
          <target state="translated">추적하려는 상태 하위 트리 만 여러 모델이 없습니다.</target>
        </trans-unit>
        <trans-unit id="420577e78b88dd5a407cd7bcfca83fee052024be" translate="yes" xml:space="preserve">
          <source>There are several important ideas to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 를 사용할 때 알아야 할 몇 가지 중요한 아이디어가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31dadb8b332eafb541ac48d1ad1b0591872b1ba8" translate="yes" xml:space="preserve">
          <source>There are some simple tweaks that can be made to this reducer. First, repeated &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements quickly grow tiresome, so it's very common to use &lt;code&gt;switch&lt;/code&gt; statements instead. Second, we can use ES6's default parameter values to handle the initial &quot;no existing data&quot; case. With those changes, the reducer would look like:</source>
          <target state="translated">이 감속기에 적용 할 수있는 몇 가지 간단한 조정이 있습니다. 먼저 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 문이 빠르게 번거 롭다 면 반복해서 &lt;code&gt;switch&lt;/code&gt; 문 을 사용하는 것이 일반적 입니다. 둘째, ES6의 기본 파라미터 값을 사용하여 초기 &quot;기존 데이터 없음&quot;사례를 처리 할 수 ​​있습니다. 이러한 변경으로 감속기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0306be0f55c35417f1fb94a7a6a33b60158cc20" translate="yes" xml:space="preserve">
          <source>There are two main ways to initialize state for your application. The &lt;code&gt;createStore&lt;/code&gt; method can accept an optional &lt;code&gt;preloadedState&lt;/code&gt; value as its second argument. Reducers can also specify an initial value by looking for an incoming state argument that is &lt;code&gt;undefined&lt;/code&gt;, and returning the value they'd like to use as a default. This can either be done with an explicit check inside the reducer, or by using the ES6 default argument value syntax: &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램의 상태를 초기화하는 두 가지 주요 방법이 있습니다. &lt;code&gt;createStore&lt;/code&gt; 의 방법은 옵션으로 받아 들일 수 &lt;code&gt;preloadedState&lt;/code&gt; 의 두 번째 인수로 값입니다. 감속기는 또한 &lt;code&gt;undefined&lt;/code&gt; 인 수신 상태 인수를 찾고 기본값으로 사용하려는 값을 반환하여 초기 값을 지정할 수 있습니다 . 이것은 리듀서 내부에서 명시 적으로 확인하거나 ES6 기본 인수 값 구문을 사용하여 수행 할 수 있습니다 : &lt;code&gt;function myReducer(state = someDefaultValue, action)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597620fe64267cbabf96711d555ec9adca761b24" translate="yes" xml:space="preserve">
          <source>There are two ways to define the initial shape and contents of your store's state. First, the &lt;code&gt;createStore&lt;/code&gt; function can take &lt;code&gt;preloadedState&lt;/code&gt; as its second argument. This is primarily intended for initializing the store with state that was previously persisted elsewhere, such as the browser's localStorage. The other way is for the root reducer to return the initial state value when the state argument is &lt;code&gt;undefined&lt;/code&gt;. These two approaches are described in more detail in &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt;, but there are some additional concerns to be aware of when using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">상점 상태의 초기 형태와 내용을 정의하는 두 가지 방법이 있습니다. 먼저 &lt;code&gt;createStore&lt;/code&gt; 함수는 &lt;code&gt;preloadedState&lt;/code&gt; 를 두 번째 인수로 사용할 수 있습니다 . 이는 주로 브라우저의 localStorage와 같이 다른 곳에서 이전에 유지되었던 상태로 저장소를 초기화하기위한 것입니다. 다른 방법은 상태 인수가 &lt;code&gt;undefined&lt;/code&gt; 경우 루트 감속기가 초기 상태 값을 반환하는 것 입니다. 이 두 가지 접근 방식은 &lt;a href=&quot;initializingstate&quot;&gt;Initializing State&lt;/a&gt; 에 자세히 설명되어 있지만 &lt;code&gt;combineReducers&lt;/code&gt; 를 사용할 때 알아야 할 몇 가지 추가 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56409b9a5183b19808817fe73374f07883b83a73" translate="yes" xml:space="preserve">
          <source>There is an important gotcha: you need to remember to append &lt;code&gt;.present&lt;/code&gt; to the current state when you retrieve it. You may also check &lt;code&gt;.past.length&lt;/code&gt; and &lt;code&gt;.future.length&lt;/code&gt; to determine whether to enable or to disable the Undo and Redo buttons, respectively.</source>
          <target state="translated">&lt;code&gt;.present&lt;/code&gt; 를 검색 할 때 현재 상태 에 추가해야한다는 점을 기억해야 합니다. 당신은 또한 확인할 수 있습니다 &lt;code&gt;.past.length&lt;/code&gt; 및 &lt;code&gt;.future.length&lt;/code&gt; 각각 사용하거나 실행 취소 및 다시 실행 버튼을 불가능하게 할 것인지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f5f4b92d40c5193a89ef2d973b4dea0cf41db580" translate="yes" xml:space="preserve">
          <source>There is no &amp;ldquo;right&amp;rdquo; answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as &amp;ldquo;is this dropdown currently open&amp;rdquo;, inside a component's internal state.</source>
          <target state="translated">이에 대한 &quot;올바른&quot;답변은 없습니다. 일부 사용자는 애플리케이션의 직렬화 및 제어 가능한 버전을 항상 유지하기 위해 Redux에 모든 단일 데이터를 유지하는 것을 선호합니다. 다른 사람들은 구성 요소의 내부 상태 안에&amp;ldquo;이 드롭 다운이 현재 열려 있습니까?&amp;rdquo;와 같이 중요하지 않은 또는 UI 상태를 유지하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="90170588b4fa6d7f622136b2c7f8e6e07e225db6" translate="yes" xml:space="preserve">
          <source>There should only be a single store in a Redux app, as the composition happens on the reducer level.</source>
          <target state="translated">컴포지션이 리듀서 레벨에서 발생하므로 Redux 앱에는 단일 스토어 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="992aa1eaaf62b5438b3953fb40feec345ca3edf1" translate="yes" xml:space="preserve">
          <source>There should only be a single store in your app.</source>
          <target state="translated">앱에는 하나의 스토어 만 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="168b0114042369684de79c5fdf6b3e093b40d171" translate="yes" xml:space="preserve">
          <source>There will &lt;em&gt;rarely&lt;/em&gt; be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different.</source>
          <target state="translated">UI 트리와 상태 모양간에 일대일 대응 은 &lt;em&gt;거의 없습니다&lt;/em&gt; . 예외적으로 Redux 스토어에서 UI 데이터의 다양한 측면을 명시 적으로 추적하는 경우에도 UI 데이터의 모양과 도메인 데이터의 모양이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d2ef296166ce0ecc73c05efc95f385ad2e7495" translate="yes" xml:space="preserve">
          <source>There's a couple ways Redux-ORM can be used to perform updates. First, the Redux-ORM docs suggest defining reducer functions on each Model subclass, then including the auto-generated combined reducer function into your store:</source>
          <target state="translated">Redux-ORM을 사용하여 업데이트를 수행 할 수있는 몇 가지 방법이 있습니다. 먼저, Redux-ORM 문서는 각 모델 서브 클래스에서 감속기 기능을 정의한 후 자동 생성 결합 감속기 기능을 상점에 포함시킬 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="51018a56e34b691dd014441eabce29bdbcbc8652" translate="yes" xml:space="preserve">
          <source>There's no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have &amp;ldquo;fat&amp;rdquo; action creators, with &amp;ldquo;thin&amp;rdquo; reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of &lt;code&gt;getState()&lt;/code&gt; in an action creator. (For purposes of this question, other async approaches such as sagas and observables fall in the &quot;action creator&quot; category.)</source>
          <target state="translated">감속기 나 액션 제작자에게 어떤 논리 조각을 사용해야하는지에 대한 명확한 대답은 없습니다. 일부 개발자는 단순히 작업에서 데이터를 가져 와서 해당 상태로 맹목적으로 병합하는 &quot;씬 (thin)&quot;감속기를 사용하여 &quot;뚱뚱한&quot;액션 제작자를 선호합니다. 다른 사람들은 액션을 가능한 작게 유지 하고 액션 제작자에서 &lt;code&gt;getState()&lt;/code&gt; 사용을 최소화하려고합니다 . (이 질문의 목적 상, sagas 및 observable과 같은 다른 비동기 접근 방식은 &quot;action creator&quot;범주에 속합니다.</target>
        </trans-unit>
        <trans-unit id="28edc5708a2301951ec09979956f382164d459ec" translate="yes" xml:space="preserve">
          <source>There's no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</source>
          <target state="translated">행동을 구성하는 방법에 대한 구체적인 규칙은 없습니다. Redux Thunk와 같은 비동기 미들웨어를 사용하면 확실히 여러 가지 관련이 있지만 관련된 액션을 연속으로 디스패치, AJAX 요청의 진행을 나타내는 액션을 디스패치, 상태에 따라 조건에 따라 액션을 디스패치하거나 심지어 액션을 디스패치하고 업데이트 된 상태를 즉시 확인할 수 있습니다. 나중에.</target>
        </trans-unit>
        <trans-unit id="3919f394ea7f45a742af3ee7c733b38c93a6700c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt;s will be completely independent. They won't share data or actions, and won't see or communicate with each other.</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; 은 완전히 독립적입니다. 그들은 데이터 나 행동을 공유하지 않으며 서로 보거나 의사 소통하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7403f67d70c46d230048ba2241787084beea6a95" translate="yes" xml:space="preserve">
          <source>These are all normal React components, so we won't examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn't mean that presentational components &lt;em&gt;have to&lt;/em&gt; be functions&amp;mdash;it's just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</source>
          <target state="translated">이것들은 모두 일반적인 React 구성 요소이므로 자세히 조사하지는 않습니다. 로컬 상태 또는 수명주기 방법을 사용해야하는 경우가 아니라면 기능 상태 비 저장 구성 요소를 작성합니다. 그렇다고 프레젠테이션 컴포넌트 &lt;em&gt;가&lt;/em&gt; 기능적이어야 한다는 의미는 아닙니다 . 이러한 방식으로 정의하기가 더 쉽습니다. 로컬 상태, 수명주기 메소드 또는 성능 최적화를 추가해야하는 경우 클래스로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad42b9f4f6a7ded866b5edd040dee5736736ad79" translate="yes" xml:space="preserve">
          <source>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in &lt;a href=&quot;../basics/index&quot;&gt;basic&lt;/a&gt; and &lt;a href=&quot;../advanced/index&quot;&gt;advanced&lt;/a&gt; tutorials.</source>
          <target state="translated">다음은 실제 응용 프로그램에서 Redux를 시작하기위한 사용 사례 및 코드 스 니펫입니다. &lt;a href=&quot;../basics/index&quot;&gt;기본&lt;/a&gt; 및 &lt;a href=&quot;../advanced/index&quot;&gt;고급&lt;/a&gt; 학습서 의 주제를 이해한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d704feeae1991cd907524cb1c0f7f6fcf0575629" translate="yes" xml:space="preserve">
          <source>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;its documentation&lt;/a&gt; in detail. In case you are worried about &lt;code&gt;mapStateToProps&lt;/code&gt; creating new objects too often, you might want to learn about &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;computing derived data&lt;/a&gt; with &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect&lt;/a&gt;.</source>
          <target state="translated">React Redux API의 기본 사항이지만 몇 가지 바로 가기 및 전원 옵션이 있으므로 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;설명서&lt;/a&gt; 를 자세히 확인하는 것이 좋습니다 . &lt;code&gt;mapStateToProps&lt;/code&gt; 가 새 객체를 너무 자주 생성하는 것이 걱정되는 경우 &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;reselect를 사용&lt;/a&gt; 하여 &lt;a href=&quot;../recipes/computingderiveddata&quot;&gt;파생 데이터&lt;/a&gt; 를 계산 하는 방법을 배우고 싶을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c26d64685238ce4dbcec18d03116138fa0bb9a0" translate="yes" xml:space="preserve">
          <source>These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting.</source>
          <target state="translated">이러한 기본 패턴을 사용하면 UI 내에 여러 스마트 연결 구성 요소 인스턴스를 사용하거나 페이지 매김 또는 정렬과 같은 일반 기능에 공통 논리를 재사용하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c558d4ebff40066937cf4fb4becc7cf460cf85d8" translate="yes" xml:space="preserve">
          <source>These new functions would typically fall into one of three categories:</source>
          <target state="translated">이러한 새로운 기능은 일반적으로 다음 세 가지 범주 중 하나에 속합니다.</target>
        </trans-unit>
        <trans-unit id="84e2759c050a4d6ddff70ba97270b913483ea299" translate="yes" xml:space="preserve">
          <source>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</source>
          <target state="translated">이는 사용자 상호 작용에 의해 통제되는 조치입니다. 우리는 또한 네트워크 요청에 의해 통제되는 또 다른 종류의 조치를 취할 것입니다. 나중에 파견하는 방법을 살펴 보 겠지만 지금은 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="734284615f4837016bf49d7e82571425d6842e5d" translate="yes" xml:space="preserve">
          <source>They can also press a &amp;ldquo;refresh&amp;rdquo; button to update it:</source>
          <target state="translated">또한 &quot;새로 고침&quot;버튼을 눌러 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d52a5e55f55bac64300f695ab9f42bb206bbca5" translate="yes" xml:space="preserve">
          <source>They can provide a useful alternative to writing manual immutable update logic.</source>
          <target state="translated">수동 불변 업데이트 논리를 작성하는 대신 유용한 대안을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c5827cb1612ac05aed827f421dec6e57380bb2" translate="yes" xml:space="preserve">
          <source>They describe the &lt;em&gt;look&lt;/em&gt; but don't know &lt;em&gt;where&lt;/em&gt; the data comes from, or &lt;em&gt;how&lt;/em&gt; to change it. They only render what's given to them. If you migrate from Redux to something else, you'll be able to keep all these components exactly the same. They have no dependency on Redux.</source>
          <target state="translated">그들은 설명하는 &lt;em&gt;모습을&lt;/em&gt; 알고 있지만하지 않는 &lt;em&gt;경우&lt;/em&gt; 데이터에서, 또는 제공 &lt;em&gt;방법&lt;/em&gt; 을 변경합니다. 그들은 그들에게 주어진 것을 렌더링합니다. Redux에서 다른 것으로 마이그레이션하면 이러한 모든 구성 요소를 정확히 동일하게 유지할 수 있습니다. 그들은 Redux에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1159323b5c6aa9389a4540485a8db710c7036ca" translate="yes" xml:space="preserve">
          <source>Think of an action as a very brief snippet of news. &amp;ldquo;Mary liked article 42.&amp;rdquo; or &amp;ldquo;&amp;lsquo;Read the Redux docs.' was added to the list of todos.&amp;rdquo;</source>
          <target state="translated">행동을 아주 간단한 뉴스 조각으로 생각하십시오. &amp;ldquo;메리는 기사 42를 좋아했습니다.&amp;rdquo; 또는&amp;ldquo; 'Redux 문서를 읽습니다.' 할 일 목록에 추가되었습니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b4665b478e044391de06bdde9d3e79d16edd37cb" translate="yes" xml:space="preserve">
          <source>Thinking in terms of state and state shape</source>
          <target state="translated">상태와 상태의 형태로 생각</target>
        </trans-unit>
        <trans-unit id="91e52043da589de141b602e3e454bd09930f4ace" translate="yes" xml:space="preserve">
          <source>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt;, &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; and &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; which offer different approaches to specifying subscriptions and handling changes.</source>
          <target state="translated">이 API는 종속성이나 복잡성이없는 저수준 기본 형식으로 만들어졌으며 상위 구독 논리를 작성하는 데 사용할 수 있습니다. React Redux와 같은 UI 바인딩은 연결된 각 구성 요소에 대한 구독을 만들 수 있습니다. 또한 이전 상태와 새로운 상태를 지능적으로 비교하고 특정 부분이 변경된 경우 추가 논리를 실행할 수있는 함수를 작성할 수도 있습니다. 예를 들어 &lt;a href=&quot;https://github.com/jprichardson/redux-watch&quot;&gt;redux-watch&lt;/a&gt; , &lt;a href=&quot;https://github.com/ashaffer/redux-subscribe&quot;&gt;redux-subscribe&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/ivantsov/redux-subscriber&quot;&gt;redux-subscriber&lt;/a&gt; 는 구독 지정 및 변경 처리에 대한 다양한 접근 방식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5bc9835804c7bf5d69285a0788d4ec1618aaf13" translate="yes" xml:space="preserve">
          <source>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; so the rest of your app is not aware that this is happening and sees the Flux stores.</source>
          <target state="translated">이를 통해 앱의 모든 Flux Store를 리듀서로 서서히 다시 작성할 수 있지만 &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; 계속 내보낼 수 있으므로 나머지 앱은 이것이 발생하고 있음을 인식하지 못하고 Flux 스토어를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a519a41d84a5c9b747a85285b24fa851ba29b4a3" translate="yes" xml:space="preserve">
          <source>This approach makes it very clear what's happening for the &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; case, but it does require nested updating logic, and some specific knowledge of the state tree shape. Depending on how you want to compose your reducer logic, this may or may not be desired.</source>
          <target state="translated">이 접근 방식을 사용하면 &lt;code&gt;&quot;ADD_COMMENTS&quot;&lt;/code&gt; 사례 에서 발생하는 상황을 매우 명확하게 알 수 있지만 중첩 된 업데이트 논리와 상태 트리 모양에 대한 특정 지식이 필요합니다. 감속기 논리를 작성하려는 방법에 따라 이는 바람직하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b98104ccad15391aa66227a6551d8fc9f45bc0" translate="yes" xml:space="preserve">
          <source>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</source>
          <target state="translated">이 아키텍처는 카운터 앱에 과도한 영향을 줄 수 있지만이 패턴의 장점은 크고 복잡한 앱으로 얼마나 잘 확장되는지입니다. 또한 매우 강력한 개발자 도구를 사용할 수 있습니다. 왜냐하면 모든 돌연변이가 원인이 된 동작을 추적 할 수 있기 때문입니다. 모든 동작을 재생하기 만하면 사용자 세션을 기록하고 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af9a7125c23f1d9f99cfc569936c1de486169781" translate="yes" xml:space="preserve">
          <source>This article is divided into an in-depth intro to help you grok the concept, and &lt;a href=&quot;#seven-examples&quot;&gt;a few practical examples&lt;/a&gt; to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</source>
          <target state="translated">이 기사는 개념을 이해하는 데 도움이되는 심층적 인 소개와 마지막에 미들웨어의 힘을 보여주는 &lt;a href=&quot;#seven-examples&quot;&gt;몇 가지 실제적인 예로&lt;/a&gt; 나뉩니다 . 지루하고 영감을주는 느낌 사이를 전환 할 때 서로 전환하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cbc20dacc9ba008323bf48c00c65d6371405cdd" translate="yes" xml:space="preserve">
          <source>This assumes you are using &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; as your package manager.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 을 패키지 관리자로 사용한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="36abb8e476a11a68638ccf33afca7adf0759ffbc" translate="yes" xml:space="preserve">
          <source>This can be prevented by using &lt;code&gt;toJS()&lt;/code&gt; in a Higher Order Component, as discussed in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;Best Practices section&lt;/a&gt; below.</source>
          <target state="translated">아래 &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;우수 사례 섹션&lt;/a&gt; 에서 설명한대로 상위 컴포넌트에서 &lt;code&gt;toJS()&lt;/code&gt; 를 사용하면이를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80afa0a6f3a3ec186233802f8708789e06fce0fb" translate="yes" xml:space="preserve">
          <source>This chain of middleware is defined by the arguments passed to the &lt;code&gt;applyMiddleware&lt;/code&gt; function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different &lt;code&gt;dispatch&lt;/code&gt; references and the different chains would effectively be disconnected.</source>
          <target state="translated">이 미들웨어 체인은 상점을 작성할 때 사용되는 &lt;code&gt;applyMiddleware&lt;/code&gt; 함수에 전달 된 인수로 정의됩니다 . 여러 체인을 정의하면 분명히 다른 &lt;code&gt;dispatch&lt;/code&gt; 참조가 있고 다른 체인이 효과적으로 연결 해제 되므로 올바르게 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e1fe353295b682382d86ef4ed3fc4f643382d4c5" translate="yes" xml:space="preserve">
          <source>This comment sums up the dichotomy nicely:</source>
          <target state="translated">이 의견은 이분법을 멋지게 요약합니다.</target>
        </trans-unit>
        <trans-unit id="324ca41cb1e96cbdc6d22ac4f0dc0ea7baff76ab" translate="yes" xml:space="preserve">
          <source>This complexity is difficult to handle as &lt;strong&gt;we're mixing two concepts&lt;/strong&gt; that are very hard for the human mind to reason about: &lt;strong&gt;mutation and asynchronicity.&lt;/strong&gt; I call them &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;Mentos and Coke&lt;/a&gt;. Both can be great in separation, but together they create a mess. Libraries like &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</source>
          <target state="translated">인간이 생각하기 어려운 &lt;strong&gt;두 가지 개념,&lt;/strong&gt; 즉 &lt;strong&gt;돌연변이와 비동기 성 &lt;/strong&gt;&lt;strong&gt;이 혼합&lt;/strong&gt; 되어 있기 때문에 이러한 복잡성을 다루기가 어렵습니다 &lt;strong&gt;. &lt;/strong&gt;나는 그들을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption&quot;&gt;멘토스와 콜라&lt;/a&gt; 라고 부릅니다 . 둘 다 분리가 잘 될 수 있지만 함께 엉망이됩니다. &lt;a href=&quot;http://facebook.github.io/react&quot;&gt;React&lt;/a&gt; 와 같은 라이브러리 는 비동기 및 직접 DOM 조작을 모두 제거하여 뷰 계층에서이 문제를 해결하려고합니다. 그러나 데이터 상태 관리는 사용자의 몫입니다. Redux가 시작되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="bed55034327edcc9ff177976049dde9f1a8518bf" translate="yes" xml:space="preserve">
          <source>This could be expanded in a number of ways. For example, an application that does a lot of editing of entities might want to keep two sets of &quot;tables&quot; in the state, one for the &quot;current&quot; item values and one for the &quot;work-in-progress&quot; item values. When an item is edited, its values could be copied into the &quot;work-in-progress&quot; section, and any actions that update it would be applied to the &quot;work-in-progress&quot; copy, allowing the editing form to be controlled by that set of data while another part of the UI still refers to the original version. &quot;Resetting&quot; the edit form would simply require removing the item from the &quot;work-in-progress&quot; section and re-copying the original data from &quot;current&quot; to &quot;work-in-progress&quot;, while &quot;applying&quot; the edits would involve copying the values from the &quot;work-in-progress&quot; section to the &quot;current&quot; section.</source>
          <target state="translated">이것은 여러 가지 방법으로 확장 될 수 있습니다. 예를 들어, 엔터티를 많이 편집하는 응용 프로그램은 &quot;현재&quot;항목 값과 &quot;진행중인 작업&quot;항목 값에 대한 두 개의 &quot;테이블&quot;세트를 상태로 유지하려고 할 수 있습니다. 항목을 편집하면 해당 값을 &quot;진행중인 작업&quot;섹션으로 복사 할 수 있으며이를 업데이트하는 모든 작업이 &quot;진행중인 작업&quot;사본에 적용되어 편집 양식을 제어 할 수 있습니다. UI의 다른 부분이 여전히 원래 버전을 참조하는 동안 해당 데이터 세트. 편집 양식을 &quot;재설정&quot;하려면 &quot;적용 중&quot;섹션에서 항목을 제거하고 &quot;적용&quot;중 원래 데이터를 &quot;현재&quot;에서 &quot;진행 중&quot;으로 다시 복사하면됩니다.편집에는 &quot;진행중인 작업&quot;섹션의 값을 &quot;현재&quot;섹션으로 복사하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="707c74a21f1746d2a960832a6b8a8cb90405d2f5" translate="yes" xml:space="preserve">
          <source>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to transform the state. Because all changes are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</source>
          <target state="translated">이렇게하면 뷰나 네트워크 콜백이 상태에 직접 쓰지 않습니다. 대신, 그들은 국가를 변화시키려는 의도를 표현한다. 모든 변경 사항이 중앙 집중식으로 이루어지고 엄격한 순서대로 하나씩 발생하므로주의해야 할 미묘한 경쟁 조건이 없습니다. 작업은 단순한 개체이므로 디버깅, 테스트 목적으로 기록, 직렬화, 저장 및 나중에 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9210dbb4de5b40a1c13ddea412dbce790a6977d8" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="translated">이 예는 사용하는 방법을 보여줍니다 &lt;code&gt;compose&lt;/code&gt; 강화하기 위해 &lt;a href=&quot;store&quot;&gt;가게&lt;/a&gt; 에 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt; 로부터 몇 개발자 도구 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;REDUX - DevTools로의&lt;/a&gt; 패키지를.</target>
        </trans-unit>
        <trans-unit id="370e39616b24bac8573bee9b7a0a5bf7ef9116fb" translate="yes" xml:space="preserve">
          <source>This example demonstrates how to use &lt;code&gt;compose&lt;/code&gt; to enhance a &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt; and a few developer tools from the &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; package.</source>
          <target state="translated">이 예제는 &lt;code&gt;compose&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://github.com/reduxjs/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; 패키지 의 몇 가지 개발자 도구 로 &lt;a href=&quot;store&quot;&gt;상점&lt;/a&gt; 을 향상시키는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e6a4f9f87221d4ef2187fb40a3e81e24b1380c59" translate="yes" xml:space="preserve">
          <source>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</source>
          <target state="translated">이 예제는 깊게 중첩 된 트리 뷰를 렌더링하고 상태를 표준화 된 형태로 나타내므로 리듀서에서 쉽게 업데이트 할 수 있습니다. 컨테이너 구성 요소가 렌더링하는 트리 노드 만 세분화하여 구독하면 우수한 렌더링 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23160794e888b31513354f69f0e10e67f1dfbb27" translate="yes" xml:space="preserve">
          <source>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware to encapsulate asynchronous side effects.</source>
          <target state="translated">이 예제에는 비동기 API에서 읽기, 사용자 입력에 대한 응답으로 데이터 가져 오기,로드 표시기 표시, 응답 캐싱 및 캐시 무효화가 포함됩니다. &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; 미들웨어를 사용 하여 비동기 부작용을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="6057ac5d12f923863450854603485d162d2c570a" translate="yes" xml:space="preserve">
          <source>This example includes tests.</source>
          <target state="translated">이 예제에는 테스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="41942bb35c722938329a0363bb8f7775d2d0a267" translate="yes" xml:space="preserve">
          <source>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger&lt;/a&gt; and conditional dispatching of actions with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; middleware.</source>
          <target state="translated">이 예는 앱이 성장함에 따라 중요 해지는 중요한 관용적 Redux 패턴을 보여줍니다. 특히, ID별로 엔터티를 정규화 된 방식으로 저장하는 방법, 여러 수준에서 리듀서를 구성하는 방법 및 리듀서와 함께 선택기를 정의하여 상태 모양에 대한 지식을 캡슐화하는 방법을 보여줍니다. 또한 &lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;Redux Logger를&lt;/a&gt; 사용한 로깅 및 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; 미들웨어를 사용한 조건부 작업 디스패치에 대해서도 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="5a2efc02036a88d2c881bcfa8505561b220da980" translate="yes" xml:space="preserve">
          <source>This function does correctly return a shallow copy of the top-level state object, but because the &lt;code&gt;nestedState&lt;/code&gt; variable was still pointing at the existing object, the state was directly mutated.</source>
          <target state="translated">이 함수는 최상위 상태 개체의 얕은 복사본을 올바르게 반환하지만 &lt;code&gt;nestedState&lt;/code&gt; 변수가 여전히 기존 개체를 가리키고 있기 때문에 상태가 직접 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="25186369f150cbdf9cc822a9194a9d16061eb99f" translate="yes" xml:space="preserve">
          <source>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but &lt;code&gt;combineReducers&lt;/code&gt; helps you keep the same logical division between reducers.</source>
          <target state="translated">이 기능을 사용하면 다른 플럭스 저장소가 다른 상태를 관리하는 방법과 유사하게 리듀서를 구성하여 자체 상태 조각을 관리 할 수 ​​있습니다. Redux를 사용하면 매장이 하나 &lt;code&gt;combineReducers&lt;/code&gt; 만 combineReducers를 사용 하면 감속 기간에 동일한 논리적 구분을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b6fed5d5eb1e62767d1062998c1daeac688f17a" translate="yes" xml:space="preserve">
          <source>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don't have to follow if you write the root reducer manually.</source>
          <target state="translated">이 기능은 약간의 의견이 있으며 초보자가 일반적인 함정을 피할 수 있도록 기울여 져 있습니다. 그렇기 때문에 루트 리듀서를 수동으로 작성하는 경우 따르지 않아도되는 일부 규칙을 적용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bd18efd9ce822617a56ac05dccc19791483c2b46" translate="yes" xml:space="preserve">
          <source>This has the effect of spreading Immutable.JS across your entire codebase, including potentially your components, where you may prefer not to have such external dependencies. Your entire codebase must know what is, and what is not, an Immutable.JS object. It also makes removing Immutable.JS from your app difficult in the future, should you ever need to.</source>
          <target state="translated">이는 외부 의존성을 원하지 않는 구성 요소를 포함하여 전체 코드베이스에 Immutable.JS를 분산시키는 효과가 있습니다. 전체 코드베이스는 Immutable.JS 객체가 무엇인지, 그렇지 않은 것이 무엇인지 알아야합니다. 또한 필요에 따라 향후 앱에서 Immutable.JS를 제거하기가 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="452cdbd1b5122ca3249e3d165f402ca90ca1b7d3" translate="yes" xml:space="preserve">
          <source>This helper is just a convenience! You can write your own &lt;code&gt;combineReducers&lt;/code&gt; that &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;works differently&lt;/a&gt;, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</source>
          <target state="translated">이 도우미는 단지 편리합니다! &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;다르게 작동&lt;/a&gt; 하는 자신의 &lt;code&gt;combineReducers&lt;/code&gt; 를 작성 하거나 자식 리듀서에서 수동으로 상태 객체를 어셈블하고 다른 함수를 작성하는 것처럼 루트 감소 함수를 명시 적으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc9476c901cfaf7607621afa617534b0f6a0851" translate="yes" xml:space="preserve">
          <source>This implementation isn't usable because it leaves out three important questions:</source>
          <target state="translated">이 구현은 다음 세 가지 중요한 질문이 없으므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5af3f9d227b391b86b28a8a3163dbc7f9de3e1f6" translate="yes" xml:space="preserve">
          <source>This installs the package that provides the &lt;code&gt;undoable&lt;/code&gt; reducer enhancer.</source>
          <target state="translated">이렇게하면 &lt;code&gt;undoable&lt;/code&gt; 감속기 향상 기를 제공하는 패키지가 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="930f0e45185d6f76c2ee37901cdc264e626e46fc" translate="yes" xml:space="preserve">
          <source>This is a basic demonstration of &lt;a href=&quot;../recipes/serverrendering&quot;&gt;server rendering&lt;/a&gt; with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</source>
          <target state="translated">Redux 및 React를 사용한 &lt;a href=&quot;../recipes/serverrendering&quot;&gt;서버 렌더링&lt;/a&gt; 의 기본 데모입니다 . 클라이언트 저장소가 기존 상태에서 부팅 될 수 있도록 서버에서 초기 저장소 상태를 준비하고이를 클라이언트로 전달하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b54fe358811791887040e3628c693b0d5817b4bb" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience.</source>
          <target state="translated">이것은 기능적 프로그래밍 유틸리티이며 편의상 Redux에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ffc3c7d398f7588925b4181068f9ae044df7c9" translate="yes" xml:space="preserve">
          <source>This is a functional programming utility, and is included in Redux as a convenience. You might want to use it to apply several &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">이것은 함수형 프로그래밍 유틸리티이며 편의를 위해 Redux에 포함되어 있습니다. 여러 &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#store-enhancer&quot;&gt;점포 강화제&lt;/a&gt; 를 연속적 으로 적용하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="902e57be6eebfba5d7e76929983c6c6258e9c271" translate="yes" xml:space="preserve">
          <source>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;Flow notation&lt;/a&gt;.</source>
          <target state="translated">이것은 유형 서명과 함께 Redux의 핵심 용어에 대한 용어집입니다. 유형은 &lt;a href=&quot;http://flowtype.org/docs/quick-reference.html&quot;&gt;흐름 표기법을&lt;/a&gt; 사용하여 문서화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="6257b5ee434e5a7cbdec29bbbff466cb0f6850ea" translate="yes" xml:space="preserve">
          <source>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</source>
          <target state="translated">이것은 코드를 구성하는 방법과 사용해야하는 방법에 대한 다양한 의견과 함께 길고 복잡한 주제입니다.</target>
        </trans-unit>
        <trans-unit id="e6d24f497bb054862fa8e8a2557607b7b064ec7c" translate="yes" xml:space="preserve">
          <source>This is a particular issue if you use &lt;code&gt;toJS()&lt;/code&gt; in a wrapped component&amp;rsquo;s &lt;code&gt;mapStateToProps&lt;/code&gt; function, as React-Redux shallowly compares each value in the returned props object. For example, the value referenced by the &lt;code&gt;todos&lt;/code&gt; prop returned from &lt;code&gt;mapStateToProps&lt;/code&gt; below will always be a different object, and so will fail a shallow equality check.</source>
          <target state="translated">래핑 된 컴포넌트의 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수 에서 &lt;code&gt;toJS()&lt;/code&gt; 를 사용하는 경우 React-Redux가 반환 된 props 객체의 각 값을 얕게 비교 하기 때문에 이는 특별한 문제 입니다. 예를 들어, 아래 &lt;code&gt;mapStateToProps&lt;/code&gt; 에서 리턴 된 &lt;code&gt;todos&lt;/code&gt; prop이 참조하는 값 은 항상 다른 오브젝트이므로 얕은 동등성 검사에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cf9d83f291ff6e78c4b43b491bded250a9eb9edd" translate="yes" xml:space="preserve">
          <source>This is a place to share common problems and solutions to them.</source>
          <target state="translated">이곳은 일반적인 문제와 해결책을 공유 할 수있는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="a195446956524ddebe615c6b4dea2d58bc44adbd" translate="yes" xml:space="preserve">
          <source>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; lets you add a Undo/Redo functionality to your app with a few lines of code.</source>
          <target state="translated">이것은 이전 예의 변형입니다. 거의 동일하지만 &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo로&lt;/a&gt; 리듀서를 래핑하여 몇 줄의 코드로 앱에 Undo / Redo 기능을 추가하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b62f6d500da56c6baedf79190677dba7f4254d1" translate="yes" xml:space="preserve">
          <source>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</source>
          <target state="translated">이것이 우리가 지금 알아야 할 전부입니다. 이러한 조치를 네트워크 요청과 함께 디스패치하는 특정 메커니즘에 대해서는 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="eb3caec81383b1f746ae38119a27f33a05999d77" translate="yes" xml:space="preserve">
          <source>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</source>
          <target state="translated">이것은 이미 우리가 원하는 것에 더 가깝습니다! 우리가 액션을 어디에 파견하든, 그것은 기록 될 것이 보장됩니다. 몽키 패칭은 결코 기분이 좋지 않지만 지금은 이걸로 살 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9084a2b0e6567c9efcaf4f6cafe694a18afbf28" translate="yes" xml:space="preserve">
          <source>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</source>
          <target state="translated">이것은 이미 좋아 보인다! 앱이 더 크면 리듀서를 별도의 파일로 분할하여 완전히 독립적으로 유지하고 다른 데이터 도메인을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6e84b6d20c865b455ea1e36d59bd6ef0bdf66609" translate="yes" xml:space="preserve">
          <source>This is basically the whole idea of Redux. Note that we haven&amp;rsquo;t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</source>
          <target state="translated">이것은 기본적으로 Redux의 전체 아이디어입니다. Redux API는 사용하지 않았습니다. 이 패턴을 용이하게하기위한 몇 가지 유틸리티가 제공되지만, 주요 아이디어는 액션 객체에 대한 응답으로 상태가 시간이 지남에 따라 업데이트되는 방식을 설명하고, 작성하는 코드의 90 %가 단순한 JavaScript이며 Redux를 사용하지 않는다는 것입니다 자체, API 또는 모든 마술.</target>
        </trans-unit>
        <trans-unit id="1d949a0761f2189999f3ad52f3288abf9de3a495" translate="yes" xml:space="preserve">
          <source>This is because two variables that reference the same object will &lt;em&gt;always&lt;/em&gt; be equal, regardless of whether the object&amp;rsquo;s values changes or not, as they're both referencing the same object. Thus, the following will always return true:</source>
          <target state="translated">같은 객체를 참조하는 두 변수가 모두 동일한 객체를 참조하기 때문에 객체의 값이 변경되는지 여부에 관계없이 동일한 객체를 참조하는 두 변수가 &lt;em&gt;항상&lt;/em&gt; 동일하기 때문 입니다. 따라서 다음은 항상 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc3fc2dfb4922ecd32a6e14514c4b08ea0d0030f" translate="yes" xml:space="preserve">
          <source>This is it! Run &lt;code&gt;npm install&lt;/code&gt; and &lt;code&gt;npm start&lt;/code&gt; in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;example folder&lt;/a&gt; and try it out!</source>
          <target state="translated">이거 야! &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;예제 폴더&lt;/a&gt; 에서 &lt;code&gt;npm install&lt;/code&gt; 및 &lt;code&gt;npm start&lt;/code&gt; 를 실행 하고 사용해보십시오!</target>
        </trans-unit>
        <trans-unit id="7e796128df0ba3814b3885d8d0519693c9b9ad24" translate="yes" xml:space="preserve">
          <source>This is much less typing! If you'd like, you can still have &amp;ldquo;vanilla&amp;rdquo; action creators like &lt;code&gt;loadPostsSuccess&lt;/code&gt; which you'd use from a container &lt;code&gt;loadPosts&lt;/code&gt; action creator.</source>
          <target state="translated">이것은 타이핑이 훨씬 적습니다! 원하는 경우 컨테이너 &lt;code&gt;loadPosts&lt;/code&gt; 작업 작성자 에서 사용할 &lt;code&gt;loadPostsSuccess&lt;/code&gt; 와 같은 &quot;vanilla&quot;작업 작성자를 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb9aca90fe801173ceb6b822d63183ddbc28a375" translate="yes" xml:space="preserve">
          <source>This is the basic structure that a typical Redux reducer function uses.</source>
          <target state="translated">이것이 전형적인 Redux 감속기 기능이 사용하는 기본 구조입니다.</target>
        </trans-unit>
        <trans-unit id="368280f7bdb144d919f7347598b1d6a5599ac6c1" translate="yes" xml:space="preserve">
          <source>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate container components from your presentational components.</source>
          <target state="translated">이것은 상태 업데이트가 Redux의 구성 요소와 함께 작동하는 방식에 대한 심층적 인 이해를 얻는 가장 좋은 예입니다. 리듀서가 처리 작업을 다른 리듀서에 위임하는 방법과 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; 를 사용 하여 프레젠테이션 구성 요소에서 컨테이너 구성 요소를 생성 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7c0930eaef048e02ff0d006be39c4d3167f83671" translate="yes" xml:space="preserve">
          <source>This is the classical &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; example. It's here for the sake of comparison, but it covers the same points as the Todos example.</source>
          <target state="translated">이것이 전형적인 &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; 예제입니다. 비교를 위해 여기 있지만 Todos 예제와 동일한 요점을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="881a664225fae7f2e081dcac2b6413fc1deac116" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the Reddit headline fetching example we built during the &lt;a href=&quot;index&quot;&gt;advanced tutorial&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;index&quot;&gt;고급 튜토리얼에서&lt;/a&gt; 구축 한 Reddit 헤드 라인 가져 오기 예제의 완전한 소스 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="b128d306a5e5a953daf8f443d8e01801093f1c92" translate="yes" xml:space="preserve">
          <source>This is the complete source code of the tiny todo app we built during the &lt;a href=&quot;index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">이것은 우리가 &lt;a href=&quot;index&quot;&gt;기본 튜토리얼&lt;/a&gt; 중에 만든 작은 todo 앱의 완전한 소스 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="bc3837809c1d7850b463c21cec48fd076bd0bf1f" translate="yes" xml:space="preserve">
          <source>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</source>
          <target state="translated">이것은 가장 진보 된 예입니다. 설계 상 밀도가 높습니다. 페치 된 엔티티를 정규화 된 캐시에 유지하고, API 호출을위한 사용자 정의 미들웨어 구현, 부분적으로로드 된 데이터 렌더링, 페이지 매김, 캐싱 응답, 오류 메시지 표시 및 라우팅. 또한 Redux DevTools가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c30e411c7f43679e4c0b5f0869178bc002c0cf5" translate="yes" xml:space="preserve">
          <source>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; bindings instead.</source>
          <target state="translated">이것이 Reux와 함께 Redux를 사용하는 가장 기본적인 예입니다. 편의상 상점이 변경 될 때 React 구성 요소를 수동으로 다시 렌더링합니다. 실제 프로젝트에서는 고성능 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; 바인딩을 대신 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="45b51f5c0e7ff3cf14ba10063daa88c68ff8ff42" translate="yes" xml:space="preserve">
          <source>This is worth emphasising: &lt;em&gt;If the reducers all return the same &lt;code&gt;state&lt;/code&gt; object passed to them, then &lt;code&gt;combineReducers&lt;/code&gt; will return the &lt;em&gt;current&lt;/em&gt; root state object, not the newly updated one.&lt;/em&gt;</source>
          <target state="translated">이 가치가 강조하는 것입니다 : &lt;em&gt;감속기는 모두 같은 돌아 가면 &lt;code&gt;state&lt;/code&gt; 그들에게 전달 된 객체를 다음 &lt;code&gt;combineReducers&lt;/code&gt; 가 반환됩니다 &lt;em&gt;현재&lt;/em&gt; 루트 상태 개체가 아니라 새로 업데이트 된 하나.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="903f50f13ad03393a3f2547dd8b1848ec4cbcd1e" translate="yes" xml:space="preserve">
          <source>This issue can be avoided by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;uncoupling your application logic from your data structures&lt;/a&gt;, as outlined in the &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;best practices section&lt;/a&gt; below.</source>
          <target state="translated">아래 &lt;a href=&quot;#immutable-js-best-practices&quot;&gt;모범 사례 섹션에&lt;/a&gt; 요약 된대로 &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;데이터 구조에서 애플리케이션 로직을 분리&lt;/a&gt; 하면이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584dbd560993face7c721c8a75c7abf6bb57ad23" translate="yes" xml:space="preserve">
          <source>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</source>
          <target state="translated">이를 통해보다 복잡한 비동기 제어 흐름을 점진적으로 작성할 수 있으며 소비 코드는 거의 동일하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2f3d7f982ac8af695c62a8985d12ce4b3081ba8" translate="yes" xml:space="preserve">
          <source>This makes it awkward to interoperate not just with your own code, but also with other libraries, such as lodash or ramda, that expect plain JavaScript objects.</source>
          <target state="translated">따라서 고유 코드뿐만 아니라 일반 JavaScript 객체를 기대하는 lodash 또는 ramda와 같은 다른 라이브러리와도 상호 운용하기가 어색합니다.</target>
        </trans-unit>
        <trans-unit id="8150ebb2edf39875f24f4fc61c627e5d2769703b" translate="yes" xml:space="preserve">
          <source>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</source>
          <target state="translated">따라서 번들 도구로 불필요한 모듈을 쉽게 잘라 내고 빌드 크기를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf383b9f03a180ee3b947f3cafa81eed01efef2e" translate="yes" xml:space="preserve">
          <source>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or inspect an application; it also enables you to persist your app's state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</source>
          <target state="translated">이렇게하면 별도의 코딩 작업없이 서버의 상태를 클라이언트에 직렬화하고 수화 할 수 있으므로 범용 앱을 쉽게 만들 수 있습니다. 단일 상태 트리를 사용하면 응용 프로그램을보다 쉽게 ​​디버깅하거나 검사 할 수 있습니다. 또한 개발주기를 단축하기 위해 개발시 앱의 상태를 유지할 수 있습니다. 예를 들어 실행 취소 / 다시 실행과 같이 구현하기 어려운 일부 기능은 모든 상태가 단일 트리에 저장된 경우 갑자기 구현하기가 쉽지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a113870425edd65d4dff2ca88a4e416744f63a" translate="yes" xml:space="preserve">
          <source>This makes it easy to migrate both to and from Redux.</source>
          <target state="translated">이를 통해 Redux로 또는 Redux에서 쉽게 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6870275e1cdc117fad62310af9bce1130ddad1e5" translate="yes" xml:space="preserve">
          <source>This makes them portable and easy to test.</source>
          <target state="translated">따라서 휴대 성과 테스트가 용이합니다.</target>
        </trans-unit>
        <trans-unit id="0117d509de0b7ec1b99dd909691fb32267c2c284" translate="yes" xml:space="preserve">
          <source>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</source>
          <target state="translated">이는 애플리케이션의 모든 데이터가 동일한 수명주기 패턴을 따르므로 앱의 논리를보다 예측 가능하고 이해하기 쉽게 만듭니다. 또한 데이터 정규화를 장려하므로 서로 모르는 동일한 데이터의 독립적 인 여러 사본으로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f34593a4e623dbcb3f458552c5cd1622e7dfef63" translate="yes" xml:space="preserve">
          <source>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt;.</source>
          <target state="translated">즉, MVC 응용 프로그램에서 실행 취소 및 다시 실행을 구현하면 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command&lt;/a&gt; 와 같은 특정 데이터 변이 패턴을 사용하도록 응용 프로그램의 일부를 다시 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc5b85dff1510174b626939c1704dc6629908600" translate="yes" xml:space="preserve">
          <source>This means that we could also write the insert and remove functions like this:</source>
          <target state="translated">즉, 다음과 같이 삽입 및 제거 기능을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbde7ae30a809fab338b95f7689a7203a8a17b4d" translate="yes" xml:space="preserve">
          <source>This means you need to access your state with &lt;code&gt;state.todos.present&lt;/code&gt; instead of just &lt;code&gt;state.todos&lt;/code&gt;:</source>
          <target state="translated">이 방법 당신은 당신의 상태에 접근 할 필요가 &lt;code&gt;state.todos.present&lt;/code&gt; 대신의 &lt;code&gt;state.todos&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="386fbee61a70c4b922b5caaee2907587414b6c05" translate="yes" xml:space="preserve">
          <source>This mutated copy is a &lt;em&gt;separate&lt;/em&gt; object from that passed into the function, and so when it is returned, a shallow check will identify it as being a different object from that passed in, and so will fail.</source>
          <target state="translated">이 변형 된 복사본은 함수에 전달 &lt;em&gt;된 것과는 별도의&lt;/em&gt; 개체이므로 반환 될 때 얕은 검사는 전달 된 것과 다른 개체 인 것으로 식별하므로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ca74d22b1244f1a72be0424378b1b4d590fc1e51" translate="yes" xml:space="preserve">
          <source>This new tree is now the next state of your app! Every listener registered with &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;store.subscribe(listener)&lt;/code&gt;&lt;/a&gt; will now be invoked; listeners may call &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt; to get the current state.</source>
          <target state="translated">이 새로운 트리는 이제 앱의 다음 상태입니다! &lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;store.subscribe(listener)&lt;/code&gt; &lt;/a&gt; 등록 된 모든 리스너 가 이제 호출됩니다. 리스너는 &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 현재 상태를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="375420430845c3b31d4e0a7e67b9eb12e1e064ee" translate="yes" xml:space="preserve">
          <source>This object is like a &amp;ldquo;model&amp;rdquo; except that there are no setters. This is so that different parts of the code can&amp;rsquo;t change the state arbitrarily, causing hard-to-reproduce bugs.</source>
          <target state="translated">이 객체는 세터가 없다는 점을 제외하고는 &quot;모델&quot;과 같습니다. 이것은 코드의 다른 부분이 상태를 임의로 변경할 수 없으므로 재현하기 어려운 버그를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="10b96d7bed30bd18afc4040b966809bdd54e8f1c" translate="yes" xml:space="preserve">
          <source>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</source>
          <target state="translated">비동기 응용 프로그램의 상태를 설명하는 정보와이를 단일 트리로 구성하는 방법을 즉시 명확하게 알 수 없기 때문에이 부분은 초보자에게 혼동되는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="726e2aa43c64e8c49eac59a956f48c4350c3da4d" translate="yes" xml:space="preserve">
          <source>This pattern is &lt;em&gt;not&lt;/em&gt; recommended for parts of the same app that share data. However, it can be useful when the bigger app has zero access to the smaller apps' internals, and we'd like to keep the fact that they are implemented with Redux as an implementation detail. Each component instance will have its own store, so they won't &amp;ldquo;know&amp;rdquo; about each other.</source>
          <target state="translated">이 패턴은 데이터를 공유하는 동일한 앱의 일부 &lt;em&gt;에는&lt;/em&gt; 권장 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그러나 더 큰 앱이 더 작은 앱의 내부에 액세스 할 수 없을 때 유용 할 수 있으며, Redux를 구현 세부 정보로 구현한다는 사실을 유지하고 싶습니다. 각 구성 요소 인스턴스에는 자체 저장소가 있으므로 서로 &quot;알지&quot;않습니다.</target>
        </trans-unit>
        <trans-unit id="4797209ab61d0cba555b0ba999e5df76ff770f2a" translate="yes" xml:space="preserve">
          <source>This problem is caused predominantly by returning a mutated state object from a Redux reducer. With Immutable.JS, this problem simply does not exist, thereby removing a whole class of bugs from your app.</source>
          <target state="translated">이 문제는 주로 Redux 감속기에서 변형 된 상태 개체를 반환함으로써 발생합니다. Immutable.JS에서는이 문제가 존재하지 않으므로 앱에서 모든 종류의 버그가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="faee56a051b54fbdf7c577f45ce201c8fd514250" translate="yes" xml:space="preserve">
          <source>This produces the desired effect, but you wouldn't want to do it every time.</source>
          <target state="translated">원하는 효과를 낼 수 있지만 매번 그렇게하고 싶지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="112bf8b2448707863e70924e561703fd39856861" translate="yes" xml:space="preserve">
          <source>This project adheres to &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="translated">이 프로젝트는 &lt;a href=&quot;http://semver.org/&quot;&gt;시맨틱 버전 관리를&lt;/a&gt; 준수합니다 .</target>
        </trans-unit>
        <trans-unit id="9ca436d5a0e732efb5749020024d046800e0f232" translate="yes" xml:space="preserve">
          <source>This requires the least amount of work on the reducer side, but does require that the action creator potentially do a fair amount of work to organize the data into the correct shape before the action is dispatched. It also doesn't handle trying to delete an item.</source>
          <target state="translated">이를 위해서는 감속기 쪽에서 최소한의 작업이 필요하지만, 활동 작성자는 조치가 전달되기 전에 데이터를 올바른 형태로 구성하기 위해 상당한 양의 작업을 수행해야합니다. 또한 항목 삭제 시도를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e32344333ff16130ad1fc8d8911f91949fab05e" translate="yes" xml:space="preserve">
          <source>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you'll also want to use UI bindings like &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt;.</source>
          <target state="translated">이 섹션은 완전한 Redux API를 설명합니다. Redux는 상태 관리에만 관심이 있습니다. 실제 앱에서는 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; 와 같은 UI 바인딩을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="8e4e2606978c9371c54128bb24c749164cec9f04" translate="yes" xml:space="preserve">
          <source>This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren't directly relevant to the topics discussed and have been omitted for brevity.</source>
          <target state="translated">이 섹션에서는 앱에 여러 가지 할 일 목록을 지원할 수있는 가상 확장을 소개합니다. 이 확장을 완전히 구현하려면 논의 된 주제와 직접 관련이없고 간략히 생략 된 감속기, 구성 요소, 동작 등을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="d91b745838a2d3e64174d93a13b4a7f1adc65cd3" translate="yes" xml:space="preserve">
          <source>This state shape better reflects the data involved, because we took care to set up the keys we passed to &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">이 상태 형태는 우리가 &lt;code&gt;combineReducers&lt;/code&gt; 에 전달한 키를 설정하기 위해주의를 기울 였기 때문에 관련된 데이터를 더 잘 반영합니다 .</target>
        </trans-unit>
        <trans-unit id="125428949dd664c2936fb5646d4a4a0944ef542f" translate="yes" xml:space="preserve">
          <source>This state structure is much flatter overall. Compared to the original nested format, this is an improvement in several ways:</source>
          <target state="translated">이 상태 구조는 전체적으로 훨씬 더 평평합니다. 원래 중첩 형식과 비교하면 다음과 같은 여러 가지 측면에서 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="94ba4d7a3e72dccff4a9100d843bda3c33581bff" translate="yes" xml:space="preserve">
          <source>This was all very informative, but can't we just drop a library and use it instead of implementing &lt;code&gt;undoable&lt;/code&gt; ourselves? Sure, we can! Meet &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt;, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</source>
          <target state="translated">이것은 매우 유익한 정보 였지만 우리가 라이브러리를 제거하고 스스로 &lt;code&gt;undoable&lt;/code&gt; 할 수없는 것을 구현하는 대신 사용할 수는 없습니까? 물론, 우린 할 수있어! Redux 트리의 모든 부분에 간단한 Undo 및 Redo 기능을 제공하는 라이브러리 인 &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo를&lt;/a&gt; 만나십시오 .</target>
        </trans-unit>
        <trans-unit id="96ab6b14f2ef0811b01a8fd50008edc6febd0745" translate="yes" xml:space="preserve">
          <source>This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a &amp;ldquo;catch all&amp;rdquo; handler. All of this depends on the conventions you choose for your team on a specific project.</source>
          <target state="translated">어렵지 않습니까? Redux는 작성하는 방법이 많기 때문에 이러한 도우미 기능을 기본적으로 제공하지 않습니다. 서버 상태를 수화하기 위해 일반 JS 객체를 불변 객체로 자동 변환하도록 할 수 있습니다. 반환 된 상태를 현재 상태와 병합하려고 할 수 있습니다. &quot;캐치 모두&quot;처리기에 대한 다른 접근 방식이있을 수 있습니다. 이 모든 것은 특정 프로젝트에서 팀을 위해 선택한 규칙에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="445c1e6f198a1adb4c272f78fb177f8661af0686" translate="yes" xml:space="preserve">
          <source>This way every instance will be independent.</source>
          <target state="translated">이런 식으로 모든 인스턴스는 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="92e38ef43aaabbe31217e626c55343afb37a1c0f" translate="yes" xml:space="preserve">
          <source>This, together with its performance and rich API for data manipulation, is why Immutable.JS is worth the effort.</source>
          <target state="translated">이는 데이터 조작을위한 성능 및 풍부한 API와 함께 Immutable.JS가 그만한 가치가있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="a60662bb0cf6dca00077914648ad22d8b2ebadfe" translate="yes" xml:space="preserve">
          <source>Three Principles</source>
          <target state="translated">세 가지 원칙</target>
        </trans-unit>
        <trans-unit id="45a585aa3738a0a8dc2ee89ca5d822a00a010018" translate="yes" xml:space="preserve">
          <source>Thunk middleware is just one example of middleware. Middleware is not about &amp;ldquo;letting you dispatch functions&amp;rdquo;. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</source>
          <target state="translated">썽크 미들웨어는 미들웨어의 한 예일뿐입니다. 미들웨어는 &quot;함수 디스패치&quot;에 관한 것이 아닙니다. 사용하는 특정 미들웨어가 처리하는 방법을 알고있는 것을 파견하도록하는 것입니다. 썽크 미들웨어는 함수를 전달할 때 특정 동작을 추가하지만 실제로 사용하는 미들웨어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="031dd77e620cd8fc8065335ff0e03be8cb20884f" translate="yes" xml:space="preserve">
          <source>Time-travel debugging requires that reducers be pure functions with no side effects, so that you can correctly jump between different states.</source>
          <target state="translated">시간 이동 디버깅에서는 리듀서가 부작용없이 순수한 함수 여야하므로 다른 상태간에 올바르게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="ee1f5ebc6cc52d4f51b113f5097b8455a407c4ed" translate="yes" xml:space="preserve">
          <source>Tips For a Better Redux Architecture: Lessons for Enterprise Scale</source>
          <target state="translated">더 나은 Redux 아키텍처를위한 팁 : 엔터프라이즈 규모의 교훈</target>
        </trans-unit>
        <trans-unit id="901c769f8e578666848aa3aae81fe0b1028b6236" translate="yes" xml:space="preserve">
          <source>Tips to Handle Authentication in Redux</source>
          <target state="translated">Redux에서 인증 처리 팁</target>
        </trans-unit>
        <trans-unit id="e74f240f49222ea150d6391c54e16b213cd2b1cd" translate="yes" xml:space="preserve">
          <source>To apply multiple store enhancers, you may use &lt;a href=&quot;compose&quot;&gt;&lt;code&gt;compose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 상점 향상기를 적용하려면 &lt;a href=&quot;compose&quot;&gt; &lt;code&gt;compose()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0f538cbe1b062d76f03414cbe7f487e9b2e5a6" translate="yes" xml:space="preserve">
          <source>To avoid these issues, ensure you follow the recommended &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;immutable update patterns for ES6&lt;/a&gt;.</source>
          <target state="translated">이러한 문제를 피하려면 &lt;a href=&quot;../recipes/reducers/immutableupdatepatterns&quot;&gt;ES6에 대해&lt;/a&gt; 권장되는 변경 불가능한 업데이트 패턴을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="2f92fd6720446a22647fac455b49ebc045cfee8c" translate="yes" xml:space="preserve">
          <source>To change data</source>
          <target state="translated">데이터를 변경하려면</target>
        </trans-unit>
        <trans-unit id="6565dc46b441e1305f44f9389c074e1086ac2ba7" translate="yes" xml:space="preserve">
          <source>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don&amp;rsquo;t introduce any magic?) that describes what happened. Here are a few example actions:</source>
          <target state="translated">상태에서 무언가를 변경하려면 작업을 전달해야합니다. 액션은 무슨 일이 일어 났는지 설명하는 평범한 자바 스크립트 객체입니다. 다음은 몇 가지 동작 예입니다.</target>
        </trans-unit>
        <trans-unit id="eda24989c78e46dab8c06cd8412d3b18d2d68eab" translate="yes" xml:space="preserve">
          <source>To create it, pass your root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이를 작성하려면 루트 &lt;a href=&quot;../glossary#reducer&quot;&gt;축소 함수&lt;/a&gt; 를 &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; 에&lt;/a&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac7a33667ce69790c31c3c6959a00eb15d3762e3" translate="yes" xml:space="preserve">
          <source>To do this, it assumes that the wrapped component is pure; that is, that the component will produce the &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;same results given the same props and state&lt;/a&gt;.</source>
          <target state="translated">이를 위해 랩핑 된 구성 요소가 순수하다고 가정합니다. 즉, 구성 요소 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/f4d55840a14601c3a5bdc0c3d741fc5753e87f66/docs/troubleshooting.md#my-views-arent-updating-when-something-changes-outside-of-redux&quot;&gt;에 동일한 props 및 state가 주어지면 동일한 결과&lt;/a&gt; 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="29e591a3897c0d0b177067748378b071109328ac" translate="yes" xml:space="preserve">
          <source>To ensure that you may only apply middleware once, it operates on &lt;code&gt;createStore()&lt;/code&gt; rather than on &lt;code&gt;store&lt;/code&gt; itself. Instead of &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt;, its signature is &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt;.</source>
          <target state="translated">미들웨어는 한 번만 적용 할 수 있도록 &lt;code&gt;store&lt;/code&gt; 자체가 아닌 &lt;code&gt;createStore()&lt;/code&gt; 에서 작동 합니다. &lt;code&gt;(store, middlewares) =&amp;gt; store&lt;/code&gt; 대신 서명은 &lt;code&gt;(...middlewares) =&amp;gt; (createStore) =&amp;gt; createStore&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b6f0480002ee862ea4e286d796db8dca014c865" translate="yes" xml:space="preserve">
          <source>To hide Redux behind a React API, we can wrap it in a special component that initializes the store in the constructor:</source>
          <target state="translated">Reux API 뒤에 Redux를 숨기려면 생성자에서 저장소를 초기화하는 특수 구성 요소로 Redux를 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a523db44ce0192bb638d90e57a1f49df365f204" translate="yes" xml:space="preserve">
          <source>To install the stable version:</source>
          <target state="translated">안정적인 버전을 설치하려면</target>
        </trans-unit>
        <trans-unit id="598097c2e73e4e488253e6050c3375112c094ef7" translate="yes" xml:space="preserve">
          <source>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비동기 API 호출을 설명하고 조치 작성자 내부의 현재 상태를 읽거나 부작용을 수행하거나 순서대로 실행하도록 체인을 연결하는 방법을 알아 보려면 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; &lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ed8cb192b488a31ce6935bdfe7a74665d721d67" translate="yes" xml:space="preserve">
          <source>To log the action and state, you can change it to something like this:</source>
          <target state="translated">동작 및 상태를 기록하기 위해 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f1cce2ba9b1ff85191ae7e2687f49081a21c5b" translate="yes" xml:space="preserve">
          <source>To prevent this from happening, you must &lt;em&gt;always return the state slice object that&amp;rsquo;s passed into a reducer if the reducer does not mutate the state.&lt;/em&gt;</source>
          <target state="translated">이 문제가 발생 &lt;em&gt;하지 않도록하려면 감속기가 상태를 변경하지 않는 경우 항상 감속기로 전달 된 상태 슬라이스 개체를 반환&lt;/em&gt; 해야합니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89ea208e2cc969561f1309636abe373b57da32a9" translate="yes" xml:space="preserve">
          <source>To read data</source>
          <target state="translated">데이터를 읽으려면</target>
        </trans-unit>
        <trans-unit id="eed3ad29a679d760cf82b7215bd55f2febaeba23" translate="yes" xml:space="preserve">
          <source>To resolve this issue, use a browser extension such as the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable.js Object Formatter&lt;/a&gt;, which surfaces your data in Chrome Dev Tools, and hides Immutable.JS&amp;rsquo;s properties when inspecting your data.</source>
          <target state="translated">이 문제를 해결하려면 Chrome Dev Tools에 데이터를 표시하고 데이터를 검사 할 때 Immutable.JS의 속성을 숨기는 Immutable.js &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;객체 포맷터&lt;/a&gt; 와 같은 브라우저 확장 프로그램을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2401479a503b53af9fbceea514e83457e1c292ef" translate="yes" xml:space="preserve">
          <source>To send the data down to the client, we need to:</source>
          <target state="translated">데이터를 클라이언트로 보내려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ab24a1445cfb045dd93cf66376dc281c3f5f6bd" translate="yes" xml:space="preserve">
          <source>To specify how the actions transform the state tree, you write pure &lt;em&gt;reducers&lt;/em&gt;.</source>
          <target state="translated">액션이 상태 트리를 변환하는 방법을 지정하려면 순수한 &lt;em&gt;리듀서&lt;/em&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="50ef1b259d84757adca29f3df1d2d641b6eec11c" translate="yes" xml:space="preserve">
          <source>To sum this up, if you stick to Redux conventions and return the initial state from reducers when they're called with &lt;code&gt;undefined&lt;/code&gt; as the &lt;code&gt;state&lt;/code&gt; argument (the easiest way to implement this is to specify the &lt;code&gt;state&lt;/code&gt; ES6 default argument value), you're going to have a nice useful behavior for combined reducers. &lt;strong&gt;They will prefer the corresponding value in the &lt;code&gt;preloadedState&lt;/code&gt; object you pass to the &lt;code&gt;createStore()&lt;/code&gt; function, but if you didn't pass any, or if the corresponding field is not set, the default &lt;code&gt;state&lt;/code&gt; argument specified by the reducer is chosen instead.&lt;/strong&gt; This approach works well because it provides both initialization and hydration of existing data, but lets individual reducers reset their state if their data was not preserved. Of course you can apply this pattern recursively, as you can use &lt;code&gt;combineReducers()&lt;/code&gt; on many levels, or even compose reducers manually by calling reducers and giving them the relevant part of the state tree.</source>
          <target state="translated">요약하자면, Redux 규칙을 고수 하고 &lt;code&gt;state&lt;/code&gt; 인수 로 &lt;code&gt;undefined&lt;/code&gt; 로 호출 될 때 감속기에서 초기 상태를 반환하면 ( 상태 를 구현하는 가장 쉬운 방법은 &lt;code&gt;state&lt;/code&gt; ES6 기본 인수 값 을 지정하는 것입니다 ) 결합 된 감속기에는 유용한 동작이 있습니다. &lt;strong&gt; &lt;code&gt;preloadedState&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 객체 &lt;/strong&gt;&lt;strong&gt;에서 해당 값을 선호하며 &lt;code&gt;createStore()&lt;/code&gt; 함수에 전달하지만, 아무것도 전달하지 않거나 해당 필드가 설정되지 않은 경우 리듀서에 의해 지정된 기본 &lt;code&gt;state&lt;/code&gt; 인수가 대신 선택됩니다.&lt;/strong&gt;이 방법은 기존 데이터의 초기화 및 수화를 제공하지만 데이터가 보존되지 않은 경우 개별 감속기에서 상태를 재설정 할 수 있기 때문에 잘 작동합니다. 물론 여러 레벨에서 &lt;code&gt;combineReducers()&lt;/code&gt; 를 사용 하거나 리듀서를 호출하고 상태 트리의 관련 부분을 제공하여 리듀서를 수동으로 구성 할 수 있으므로이 패턴을 재귀 적으로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8cdb0c4afd8333274d4833966816662659fdba2" translate="yes" xml:space="preserve">
          <source>To test the components we make a &lt;code&gt;setup()&lt;/code&gt; helper that passes the stubbed callbacks as props and renders the component with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;shallow rendering&lt;/a&gt;. This lets individual tests assert on whether the callbacks were called when expected.</source>
          <target state="translated">컴포넌트를 테스트하기 위해 스텁 된 콜백을 소품으로 전달하고 컴포넌트를 &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;얕은 렌더링으로 렌더링&lt;/a&gt; 하는 &lt;code&gt;setup()&lt;/code&gt; 도우미를 만듭니다 . 이를 통해 개별 테스트에서 콜백이 호출되었는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="511c9087c67a4a067c397c7eec06e3c3e446f664" translate="yes" xml:space="preserve">
          <source>To unsubscribe the change listener, invoke the function returned by &lt;code&gt;subscribe&lt;/code&gt;.</source>
          <target state="translated">변경 리스너를 탈퇴하려면에 의해 반환 된 함수를 호출 &lt;code&gt;subscribe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898034cb5cc5c4fc7410f57fc7be8100ebeae451" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;connect()&lt;/code&gt;, you need to define a special function called &lt;code&gt;mapStateToProps&lt;/code&gt; that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, &lt;code&gt;VisibleTodoList&lt;/code&gt; needs to calculate &lt;code&gt;todos&lt;/code&gt; to pass to the &lt;code&gt;TodoList&lt;/code&gt;, so we define a function that filters the &lt;code&gt;state.todos&lt;/code&gt; according to the &lt;code&gt;state.visibilityFilter&lt;/code&gt;, and use it in its &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 를 사용하려면 현재 Redux 스토어 상태를 줄 바꿈 할 프리젠 테이션 컴포넌트로 전달할 소품으로 변환하는 방법을 알려주는 &lt;code&gt;mapStateToProps&lt;/code&gt; 라는 특수 함수를 정의해야합니다 . 예를 들어, &lt;code&gt;VisibleTodoList&lt;/code&gt; 은 계산해야 &lt;code&gt;todos&lt;/code&gt; 받는 통과 &lt;code&gt;TodoList&lt;/code&gt; 우리는 필터 함수를 정의하므로 &lt;code&gt;state.todos&lt;/code&gt; 을 받는있어서 &lt;code&gt;state.visibilityFilter&lt;/code&gt; 를 , 그것의 사용 &lt;code&gt;mapStateToProps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b84ac1ca067a403df64cc26ea17e56c8180c71f" translate="yes" xml:space="preserve">
          <source>To use it together with &lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt;, you will need to install &lt;code&gt;babel-jest&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://babeljs.io&quot;&gt;Babel&lt;/a&gt; 과 함께 사용 하려면 &lt;code&gt;babel-jest&lt;/code&gt; 를 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="717cd30aec4dd5a323fdb13aff5182c806d12d1b" translate="yes" xml:space="preserve">
          <source>TodoMVC</source>
          <target state="translated">TodoMVC</target>
        </trans-unit>
        <trans-unit id="a4114a83f4c6b03e326fda4a57471ca7c2d9fa96" translate="yes" xml:space="preserve">
          <source>Todos</source>
          <target state="translated">Todos</target>
        </trans-unit>
        <trans-unit id="6426098ad9410ea40ed780712b90e9b1ee4b090c" translate="yes" xml:space="preserve">
          <source>Todos with Undo</source>
          <target state="translated">실행 취소가있는 할일</target>
        </trans-unit>
        <trans-unit id="11dbf4818429dd1d9ae43c9b6f0078f50d78eca5" translate="yes" xml:space="preserve">
          <source>Top-Level Exports</source>
          <target state="translated">최상위 수출</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="c579263052bf20f3a459fb334a149d298234c3f6" translate="yes" xml:space="preserve">
          <source>Tree View</source>
          <target state="translated">트 리뷰</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="63ae2d8b43c9bd5c5d9a4a0152b1f52dd71f01f5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: My views aren&amp;rsquo;t updating when something changes outside of Redux</source>
          <target state="translated">문제 해결 : Redux 외부에서 무언가가 변경 될 때 뷰가 업데이트되지 않습니다</target>
        </trans-unit>
        <trans-unit id="c5984c35d0b5720f5ededf659b1e4bb94f25efcc" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Never mutate reducer arguments</source>
          <target state="translated">문제 해결 : 감속기 인수를 변경하지 마십시오</target>
        </trans-unit>
        <trans-unit id="f2569e4c2636e5cc4f4bc61ec91ab96c592717fa" translate="yes" xml:space="preserve">
          <source>Troubleshooting: Nothing happens when I dispatch an action</source>
          <target state="translated">문제 해결 : 액션을 전달할 때 아무 반응이 없습니다</target>
        </trans-unit>
        <trans-unit id="5c79bb1da81bc4cdf1612625ab31bb11eaf51494" translate="yes" xml:space="preserve">
          <source>Try to avoid dispatching several times synchronously in a row in the places where you're concerned about performance. There are a number of addons and approaches that can batch up dispatches as well.</source>
          <target state="translated">성능이 걱정되는 곳에서 여러 번 연속해서 여러 번 발송하지 않도록하십시오. 디스패치를 ​​일괄 처리 할 수있는 많은 애드온과 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72970471e5d1f5bed9e5c8dccde351d73710853a" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="translated">값이 &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creators&lt;/a&gt; 인 객체를 동일한 키를 가진 객체로 변환하지만 모든 action creator가 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 호출에 래핑되어 직접 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7b143d4c5f841fa87b3ffa44b1a514a798acb9" translate="yes" xml:space="preserve">
          <source>Turns an object whose values are &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creators&lt;/a&gt;, into an object with the same keys, but with every action creator wrapped into a &lt;a href=&quot;store#dispatchaction&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; call so they may be invoked directly.</source>
          <target state="translated">값이 &lt;a href=&quot;https://redux.js.org/understanding/thinking-in-redux/glossary#action-creator&quot;&gt;action creators&lt;/a&gt; 인 객체를 동일한 키를 가진 객체로 변환하지만 모든 액션 작성자가 직접 호출 될 수 있도록 &lt;a href=&quot;store#dispatchaction&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 호출 로 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="e1733ad2a0216b6de85e1fcd35dfdee394e2afa0" translate="yes" xml:space="preserve">
          <source>Tutorials and Articles</source>
          <target state="translated">튜토리얼 및 기사</target>
        </trans-unit>
        <trans-unit id="606fbca55ef1c11f19a4f936a99beb986380cf17" translate="yes" xml:space="preserve">
          <source>Twitter's mobile site</source>
          <target state="translated">트위터의 모바일 사이트</target>
        </trans-unit>
        <trans-unit id="9404d68c02ebdd30a4a808a24f9060471b759192" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux unless you're unhappy with local component state</source>
          <target state="translated">트위터 : 로컬 구성 요소 상태에 만족하지 않는 한 Redux를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="d2affd0dcee2425ca66385d0faf980e7f7ecdf02" translate="yes" xml:space="preserve">
          <source>Twitter: Don't use Redux until...</source>
          <target state="translated">트위터 : Redux를 사용할 때까지 사용하지 마십시오 ...</target>
        </trans-unit>
        <trans-unit id="d7fb782e77a8b9b4edadf5251f4fd4a2b65f0b1b" translate="yes" xml:space="preserve">
          <source>Twitter: If your reducer looks boring, don't use redux</source>
          <target state="translated">트위터 : 리듀서가 지루해 보인다면 redux를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="ee9af1a3c185fc74743f29130b1e126141719508" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is a platform for developers to build customized state management with reusable things</source>
          <target state="translated">트위터 : Redux는 개발자가 재사용 가능한 것들로 맞춤형 상태 관리를 구축 할 수있는 플랫폼입니다</target>
        </trans-unit>
        <trans-unit id="c1674978f90c098b4d6e689712105d7a768088c7" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is designed to be predictable, not concise</source>
          <target state="translated">트위터 : Redux는 간결하지 않고 예측 가능하도록 설계되었습니다</target>
        </trans-unit>
        <trans-unit id="6df45452576b437fd3a9fe2fc716cd66dddc4433" translate="yes" xml:space="preserve">
          <source>Twitter: Redux is useful to eliminate deep prop passing</source>
          <target state="translated">트위터 : Redux는 깊은 소품 전달을 제거하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="66661fb38bd97dedfe9248a69ac48fe3658b604e" translate="yes" xml:space="preserve">
          <source>Twitter: Redux scaling</source>
          <target state="translated">트위터 : Redux 스케일링</target>
        </trans-unit>
        <trans-unit id="ecc8be1c9df1cfaf1fb1dfafd8fc3b52bba36bca" translate="yes" xml:space="preserve">
          <source>Twitter: Redux vs MobX benchmark graph - Redux state shape matters</source>
          <target state="translated">트위터 : Redux vs MobX 벤치 마크 그래프-Redux 상태 형태가 중요</target>
        </trans-unit>
        <trans-unit id="129f727416c8f720bb392b36e9ceac07d9339857" translate="yes" xml:space="preserve">
          <source>Twitter: Should I keep something in React component state?</source>
          <target state="translated">트위터 : React 컴포넌트 상태를 유지해야합니까?</target>
        </trans-unit>
        <trans-unit id="1951b46de5200e3cec6a0f10d24bc32b95efcec1" translate="yes" xml:space="preserve">
          <source>Twitter: There is no ultimate file structure for Redux</source>
          <target state="translated">트위터 : Redux에 대한 궁극적 인 파일 구조는 없습니다</target>
        </trans-unit>
        <trans-unit id="a5ab467d2f0669472526a676c4046e4696c17a6a" translate="yes" xml:space="preserve">
          <source>Twitter: Using a reducer to update a component</source>
          <target state="translated">Twitter : 감속기를 사용하여 구성 요소 업데이트</target>
        </trans-unit>
        <trans-unit id="cd42d6934051561b9a42541c428d37e9a49eefd7" translate="yes" xml:space="preserve">
          <source>Twitter: You don't need Redux if your data never changes</source>
          <target state="translated">트위터 : 데이터가 변하지 않는다면 Redux가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="65143436c2a655126e87e9283def5be8f1f1d3d7" translate="yes" xml:space="preserve">
          <source>Twitter: common misconception - deep cloning</source>
          <target state="translated">트위터 : 일반적인 오해-깊은 복제</target>
        </trans-unit>
        <trans-unit id="f7449ca3dc33732cd2745f1868991eecc95eeb34" translate="yes" xml:space="preserve">
          <source>Twitter: emphasizing &amp;ldquo;one container&amp;rdquo; was a mistake</source>
          <target state="translated">트위터 :&amp;ldquo;하나의 컨테이너&amp;rdquo;를 강조하는 것은 실수였다</target>
        </trans-unit>
        <trans-unit id="94f434b5b79b7481ac06603cc2fe9a2a75efff91" translate="yes" xml:space="preserve">
          <source>Twitter: most common Redux misconception</source>
          <target state="translated">트위터 : 가장 일반적인 Redux 오해</target>
        </trans-unit>
        <trans-unit id="dec8b9c8b688102b7c98c2e00ef8f8e810be3a8d" translate="yes" xml:space="preserve">
          <source>Twitter: possible comparison between sagas, loops, and other approaches</source>
          <target state="translated">트위터 : 사가, 루프 및 기타 접근 방식 간의 가능한 비교</target>
        </trans-unit>
        <trans-unit id="eb2d03183352dc0e1406c06a363bec69ab899d18" translate="yes" xml:space="preserve">
          <source>Twitter: state shape should be normalized</source>
          <target state="translated">트위터 : 상태 모양이 정상화되어야합니다</target>
        </trans-unit>
        <trans-unit id="0fc31910b305d54661578ccc6703279eccabacfc" translate="yes" xml:space="preserve">
          <source>Understanding Middleware</source>
          <target state="translated">미들웨어 이해</target>
        </trans-unit>
        <trans-unit id="aa44a604eeec984741a16fa1f77345805911c705" translate="yes" xml:space="preserve">
          <source>Understanding Programmatic Side-Effects</source>
          <target state="translated">프로그래밍 방식의 부작용 이해</target>
        </trans-unit>
        <trans-unit id="5f8aabc2d6ab53ecb7bf65fd5b21232c2d632dbb" translate="yes" xml:space="preserve">
          <source>Understanding Redux</source>
          <target state="translated">Redux 이해</target>
        </trans-unit>
        <trans-unit id="da9a514a65a385fa6f49e9ff3ac2134dd5049f72" translate="yes" xml:space="preserve">
          <source>Understanding Redux Middleware</source>
          <target state="translated">Redux 미들웨어 이해</target>
        </trans-unit>
        <trans-unit id="1126940f0f175f3010de4d728fe1b602fc4c7c2e" translate="yes" xml:space="preserve">
          <source>Understanding Undo History</source>
          <target state="translated">실행 취소 기록 이해</target>
        </trans-unit>
        <trans-unit id="29149689e59122b80c1e38105a1193a813f6026c" translate="yes" xml:space="preserve">
          <source>Undo history is also part of your app's state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the &lt;em&gt;history&lt;/em&gt; of this state at different points in time.</source>
          <target state="translated">실행 취소 기록도 앱 상태의 일부이므로 다른 방식으로 접근해야 할 이유가 없습니다. 시간이 지남에 따라 상태 유형이 변경 되더라도 Undo 및 Redo를 구현할 때 다른 시점에서이 상태 의 &lt;em&gt;이력&lt;/em&gt; 을 추적하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="64a01a0c422c934a7950b6881de9ff78984dfa04" translate="yes" xml:space="preserve">
          <source>Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; might look like:</source>
          <target state="translated">불행히도 불변 업데이트를 깊게 중첩 된 상태에 올바르게 적용하는 프로세스는 쉽게 장황하고 읽기 어려워 질 수 있습니다. &lt;code&gt;state.first.second[someId].fourth&lt;/code&gt; 를 업데이트하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9541a9acaaaf0a817940ec4f10e5183c2dd8e50" translate="yes" xml:space="preserve">
          <source>Unfortunately, this setup has a problem. Because &lt;code&gt;combineReducers&lt;/code&gt; will call each slice reducer with the same action, dispatching &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; will actually cause &lt;em&gt;all three&lt;/em&gt; counter values to be incremented, not just one of them. We need some way to wrap the &lt;code&gt;counter&lt;/code&gt; logic so that we can ensure that only the counter we care about is updated.</source>
          <target state="translated">불행히도이 설정에는 문제가 있습니다. &lt;code&gt;combineReducers&lt;/code&gt; 는 동일한 동작으로 각 슬라이스 감속기를 호출 하기 때문에 &lt;code&gt;{type : 'INCREMENT'}&lt;/code&gt; 을 (를) 디스패치 하면 실제로 하나의 카운터가 아닌 &lt;em&gt;세 개의&lt;/em&gt; 카운터 값이 모두 증가합니다. 관심있는 카운터 만 업데이트되도록 &lt;code&gt;counter&lt;/code&gt; 로직 을 감쌀 수있는 방법이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d02603176f8822a40aaa5b4270e49934a7f83824" translate="yes" xml:space="preserve">
          <source>Universal</source>
          <target state="translated">Universal</target>
        </trans-unit>
        <trans-unit id="994fe41b283ff02621f9c7dc77840d41dc98c31d" translate="yes" xml:space="preserve">
          <source>Unless you are targeting old browsers like IE9, you can always use &lt;code&gt;browserHistory&lt;/code&gt;.</source>
          <target state="translated">IE9와 같은 오래된 브라우저를 대상으로하지 않는 한 항상 &lt;code&gt;browserHistory&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b1ae928f14271308acdf16284c1c3318ffccaac" translate="yes" xml:space="preserve">
          <source>Unlike Flux, &lt;strong&gt;Redux does not have the concept of a Dispatcher&lt;/strong&gt;. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt;described as &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt;&lt;/a&gt;. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</source>
          <target state="translated">플럭스와 달리 &lt;strong&gt;Redux에는 디스패처 개념이 없습니다&lt;/strong&gt; . 이벤트 이미 터 대신 순수한 함수에 의존하기 때문에 순수한 함수는 작성하기 쉽고이를 관리하는 추가 엔티티가 필요하지 않기 때문입니다. Flux를 보는 방식에 따라이를 편차 또는 구현 세부 사항으로 볼 수 있습니다. 플럭스는 종종 &lt;a href=&quot;https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1&quot;&gt; &lt;code&gt;(state, action) =&amp;gt; state&lt;/code&gt; &lt;/a&gt; 로 설명 되었습니다 . 이런 의미에서 Redux는 Flux 아키텍처에 적합하지만 순수한 기능 덕분에 단순 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="369afc8b01a8d03d314e492b4f13b9436b7f3540" translate="yes" xml:space="preserve">
          <source>Unlike Immutable, Baobab doesn't yet implement any special efficient data structures under the hood, so you don't really win anything from using it together with Redux. It's easier to just use plain objects in this case.</source>
          <target state="translated">Immutable과 달리 Baobab은 아직 특별한 효율적인 데이터 구조를 구현하지 않으므로 Redux와 함께 사용하면 아무런 효과가 없습니다. 이 경우 일반 객체를 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="dafc7d2108e005fe79487a219c36098fea188c9e" translate="yes" xml:space="preserve">
          <source>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the &lt;code&gt;case&lt;/code&gt; expression). Even if you don't plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;JavaScript library playground implementing similar ideas&lt;/a&gt;. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;using a gradual typing solution like Flow&lt;/a&gt;.</source>
          <target state="translated">Redux와 달리 Elm은 언어이므로 강제 순도, 정적 타이핑, 즉시 사용 가능한 불변성 및 패턴 일치 ( &lt;code&gt;case&lt;/code&gt; 표현식 사용)와 같은 많은 이점을 활용할 수 있습니다. Elm을 사용하지 않더라도 Elm 아키텍처에 대해 읽고이를 활용해야합니다. &lt;a href=&quot;https://github.com/paldepind/noname-functional-frontend-framework&quot;&gt;비슷한 아이디어를 구현&lt;/a&gt; 하는 흥미로운 JavaScript 라이브러리 놀이터가 있습니다. 우리는 Redux에 대한 영감을 찾아야합니다! Elm의 정적 타이핑에 더 가까이 갈 수있는 한 가지 방법은 &lt;a href=&quot;https://github.com/reactjs/redux/issues/290&quot;&gt;Flow와 같은 점진적인 타이핑 솔루션&lt;/a&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fb573dae642cd298a26b5ad3f7d8a6aa2a22ab64" translate="yes" xml:space="preserve">
          <source>Updating Nested Objects</source>
          <target state="translated">중첩 된 객체 업데이트</target>
        </trans-unit>
        <trans-unit id="ba005750a992aac6711d42039081d7dea24565c8" translate="yes" xml:space="preserve">
          <source>Updating Normalized Data</source>
          <target state="translated">정규화 된 데이터 업데이트</target>
        </trans-unit>
        <trans-unit id="34a615077aef7febb310a581aba6ddb1f4573a22" translate="yes" xml:space="preserve">
          <source>Updating an Item in an Array</source>
          <target state="translated">배열에서 항목 업데이트</target>
        </trans-unit>
        <trans-unit id="38f356713eaa6d37ea438e2f8aa17840c5f0c625" translate="yes" xml:space="preserve">
          <source>Updating complex nested state trees can lead to verbose code that is tedious to write and difficult to debug.</source>
          <target state="translated">복잡한 중첩 된 상태 트리를 업데이트하면 작성하기가 지루하고 디버깅하기 어려운 자세한 코드가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692659407b3b434cf95e2a7e004744aa8b983be9" translate="yes" xml:space="preserve">
          <source>Updating one item in an array can be accomplished by using &lt;code&gt;Array.map&lt;/code&gt;, returning a new value for the item we want to update, and returning the existing values for all other items:</source>
          <target state="translated">배열에서 하나의 항목을 업데이트하려면 &lt;code&gt;Array.map&lt;/code&gt; 을 사용하여 업데이트하려는 항목의 새 값을 반환하고 다른 모든 항목의 기존 값을 반환하면됩니다.</target>
        </trans-unit>
        <trans-unit id="46dd59ad0b98ced1d4302c19c79265603a50b5a9" translate="yes" xml:space="preserve">
          <source>Updating the Selectors</source>
          <target state="translated">선택기 업데이트</target>
        </trans-unit>
        <trans-unit id="59dca19d5e82666b029e887367ee83ee76a6cde5" translate="yes" xml:space="preserve">
          <source>Usage with React</source>
          <target state="translated">React와 함께 사용</target>
        </trans-unit>
        <trans-unit id="4bd635c7ecaee77c3a25d970afecbab5846b8de6" translate="yes" xml:space="preserve">
          <source>Usage with React Router</source>
          <target state="translated">React Router와 함께 사용</target>
        </trans-unit>
        <trans-unit id="f27c1c781c4770c2582ae4093ae556d8904e293c" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS everywhere except your dumb components</source>
          <target state="translated">바보 같은 구성 요소를 제외한 모든 곳에서 Immutable.JS를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9cd0943012b7d196bcc304b78eaf4d76beb5b078" translate="yes" xml:space="preserve">
          <source>Use Immutable.JS objects in your Smart Components</source>
          <target state="translated">스마트 컴포넌트에서 Immutable.JS 객체 사용</target>
        </trans-unit>
        <trans-unit id="14a99c911eb8f6fe086d95ec62a6192b50d4564c" translate="yes" xml:space="preserve">
          <source>Use a Higher Order Component to convert your Smart Component&amp;rsquo;s Immutable.JS props to your Dumb Component&amp;rsquo;s JavaScript props</source>
          <target state="translated">고급 구성 요소를 사용하여 Smart Component의 Immutable.JS 소품을 Dumb Component의 JavaScript 소품으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="5f88c0684b6236b23ff1f689452822f930944d64" translate="yes" xml:space="preserve">
          <source>Use an Immutable.JS-aware version of the &lt;code&gt;combineReducers&lt;/code&gt; function, such as the one in &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt;, as Redux itself expects the state tree to be a plain JavaScript object.</source>
          <target state="translated">Redux 자체는 상태 트리가 일반 JavaScript 객체가 될 것으로 기대하므로 &lt;a href=&quot;https://www.npmjs.com/package/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; 과 같은 &lt;code&gt;combineReducers&lt;/code&gt; 인식 버전의 combineReducers 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e7660e3d84caaf8d0d389dd1aa86ddb2e25f9d1" translate="yes" xml:space="preserve">
          <source>Use the Immutable Object Formatter Chrome Extension to Aid Debugging</source>
          <target state="translated">불변의 Object Formatter Chrome 확장 프로그램을 사용하여 디버깅 지원</target>
        </trans-unit>
        <trans-unit id="f02307698aa7f146036376ea5c566843affb0cce" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="f08b702827057616968fd391c82f707b1a5a2d8f" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS everywhere keeps your code performant. Use it in your smart components, your selectors, your sagas or thunks, action creators, and especially your reducers.</source>
          <target state="translated">Immutable.JS를 사용하면 어디에서나 코드 성능을 유지할 수 있습니다. 스마트 구성 요소, 선택기, 사가 또는 썽크, 액션 제작자 및 특히 감속기에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7293e4f3b5e035630a5bc60b64f59c693251afd" translate="yes" xml:space="preserve">
          <source>Using Immutable.JS with Redux</source>
          <target state="translated">Redux와 함께 Immutable.JS 사용</target>
        </trans-unit>
        <trans-unit id="67ca03c7a7625d155b3a537ee064c3e9d484c709" translate="yes" xml:space="preserve">
          <source>Using Object Spread Operator</source>
          <target state="translated">객체 확산 연산자 사용</target>
        </trans-unit>
        <trans-unit id="ac6f51d94e4af12a8acd288d8eb407840de3df95" translate="yes" xml:space="preserve">
          <source>Using Redux</source>
          <target state="translated">Redux 사용</target>
        </trans-unit>
        <trans-unit id="fe5bda3640263724e1162e68bdb4f3f60a23f165" translate="yes" xml:space="preserve">
          <source>Using Redux Undo</source>
          <target state="translated">Redux 실행 취소 사용</target>
        </trans-unit>
        <trans-unit id="4350d0f8a60fb29773b2696fff9bb5c97e53d8b5" translate="yes" xml:space="preserve">
          <source>Using combineReducers</source>
          <target state="translated">CombineReducers 사용</target>
        </trans-unit>
        <trans-unit id="7d518ee67915b609a1dd9ff6c8af1cfadb6c6da1" translate="yes" xml:space="preserve">
          <source>Using objects keyed by item IDs as lookup tables, and arrays of IDs to track ordering</source>
          <target state="translated">항목 ID별로 키가 지정된 객체를 조회 테이블 및 ID 배열로 사용하여 순서 추적</target>
        </trans-unit>
        <trans-unit id="8ed1d4412e834bf938d3923e0b8f3cc5b2463506" translate="yes" xml:space="preserve">
          <source>Using redux-saga To Simplify Your Growing React Native Codebase</source>
          <target state="translated">redux-saga를 사용하여 성장하는 반응 네이티브 코드베이스 단순화</target>
        </trans-unit>
        <trans-unit id="021b423143ef7a73f92d60003574a87608876b96" translate="yes" xml:space="preserve">
          <source>Using slice reducers with Immutable.js objects</source>
          <target state="translated">Immutable.js 객체에 슬라이스 리듀서 사용</target>
        </trans-unit>
        <trans-unit id="b97756d7719f737231f86a444a2d68e775b67e86" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;getVisibleTodos&lt;/code&gt; selector with multiple instances of the &lt;code&gt;visibleTodoList&lt;/code&gt; container will not correctly memoize:</source>
          <target state="translated">&lt;code&gt;visibleTodoList&lt;/code&gt; 컨테이너 의 여러 인스턴스와 함께 &lt;code&gt;getVisibleTodos&lt;/code&gt; 선택기를 사용하면 올바르게 메모리 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4df7fb586380ea5e7c187fb0014d6c3d49e85d05" translate="yes" xml:space="preserve">
          <source>Usually generated by React Redux</source>
          <target state="translated">일반적으로 React Redux에서 생성</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="3b6bce0bc82ec87711aba57c2f985407b17ac4e1" translate="yes" xml:space="preserve">
          <source>Utility libraries that wrap immutable update logic into simpler functions</source>
          <target state="translated">변경 불가능한 업데이트 로직을 더 간단한 함수로 감싸는 유틸리티 라이브러리</target>
        </trans-unit>
        <trans-unit id="a83ddc10110955dee4bc01b56024b22edcbf4ac4" translate="yes" xml:space="preserve">
          <source>Verbose Code</source>
          <target state="translated">자세한 코드</target>
        </trans-unit>
        <trans-unit id="306838c8867984c3b915bde4dd3f78004f4ca086" translate="yes" xml:space="preserve">
          <source>Watch the 30 Free Videos!</source>
          <target state="translated">30 개의 무료 비디오를 시청하십시오!</target>
        </trans-unit>
        <trans-unit id="0483b60e25b0c25edcc348bff84793a3d91be49a" translate="yes" xml:space="preserve">
          <source>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</source>
          <target state="translated">또한 스크립트 태그를 통해 클라이언트 측 애플리케이션을위한 번들 파일도 포함합니다. 이것은 번들링 도구가 클라이언트 진입 점에 제공하는 모든 출력입니다. 정적 파일이거나 핫 리로딩 개발 서버의 URL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10bbc3b0c569fe69fdd473c376b8f564d7a80d0e" translate="yes" xml:space="preserve">
          <source>We also need a way to give each instance of a container access to its own private selector. The &lt;code&gt;mapStateToProps&lt;/code&gt; argument of &lt;code&gt;connect&lt;/code&gt; can help with this.</source>
          <target state="translated">또한 컨테이너의 각 인스턴스에 자체 개인 선택기에 액세스 할 수있는 방법이 필요합니다. &lt;code&gt;connect&lt;/code&gt; 의 &lt;code&gt;mapStateToProps&lt;/code&gt; 인수가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdaefd698de230a2f7c12c50f1c7217019df8d31" translate="yes" xml:space="preserve">
          <source>We can now wrap any reducer into &lt;code&gt;undoable&lt;/code&gt; reducer enhancer to teach it to react to &lt;code&gt;UNDO&lt;/code&gt; and &lt;code&gt;REDO&lt;/code&gt; actions.</source>
          <target state="translated">이제 모든 감속기를 &lt;code&gt;undoable&lt;/code&gt; 감속기 향상 기로 감싸서 &lt;code&gt;UNDO&lt;/code&gt; 및 &lt;code&gt;REDO&lt;/code&gt; 작업 에 반응하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c827f05d5a3cbe83f760b9cd2939ca0c33269a0" translate="yes" xml:space="preserve">
          <source>We can still define these special thunk action creators inside our &lt;code&gt;actions.js&lt;/code&gt; file:</source>
          <target state="translated">우리는 여전히 &lt;code&gt;actions.js&lt;/code&gt; 파일 내에서 이러한 특수 썽크 액션 생성자를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="938b765a6a181b2876b551536787a61427ae0513" translate="yes" xml:space="preserve">
          <source>We can write the following helper to accomplish this:</source>
          <target state="translated">이를 위해 다음과 같은 도우미를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8360b823356a1165aff2dcb5acddb15d0faf8a6" translate="yes" xml:space="preserve">
          <source>We can't reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the &lt;code&gt;type&lt;/code&gt; is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</source>
          <target state="translated">성능상의 이유로 직렬화 가능한 작업을 안정적으로 시행 할 수 없으므로 Redux는 모든 작업이 일반 개체인지, &lt;code&gt;type&lt;/code&gt; 이 정의되어 있는지 확인합니다 . 나머지는 당신에게 달려 있지만 직렬화 가능한 모든 것을 유지하면 문제를 디버그하고 재현하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00855934fc4901f8d981dcebd3bffdd698a1fcbf" translate="yes" xml:space="preserve">
          <source>We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:</source>
          <target state="translated">우리는 또한 접근 방식을 다소 다를 수 있으며 주어진 감속기 기능과 이름 또는 식별자를 모두 허용하는보다 일반적인 고차 감속기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f190e4360534b4c5d20b45090414be9e9e50cea0" translate="yes" xml:space="preserve">
          <source>We could end this here, but it's not very convenient to import a special function every time.</source>
          <target state="translated">여기서는 끝낼 수 있지만 매번 특수 함수를 가져 오는 것은 그리 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05ab24ad4034d462a58f7bf871314f5e1296bcbc" translate="yes" xml:space="preserve">
          <source>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</source>
          <target state="translated">Redux 내부에 실제 몽키 패칭을 구현 세부 사항으로 적용하는 도우미를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9014512e14daf5d56a7fc1c2a33ed8ae10444137" translate="yes" xml:space="preserve">
          <source>We could use it to apply multiple middleware like this:</source>
          <target state="translated">다음과 같이 여러 미들웨어를 적용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62783244d2f4a7054a2bb285d688f4cb5a60d38f" translate="yes" xml:space="preserve">
          <source>We don't want to lock you in!</source>
          <target state="translated">우리는 당신을 잠그고 싶지 않습니다!</target>
        </trans-unit>
        <trans-unit id="8a9e7b213f0799be76b21fa0d3f91f45192784f7" translate="yes" xml:space="preserve">
          <source>We extracted &lt;code&gt;posts(state, action)&lt;/code&gt; that manages the state of a specific post list. This is just &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;reducer composition&lt;/a&gt;! It is our choice how to split the reducer into smaller reducers, and in this case, we're delegating updating items inside an object to a &lt;code&gt;posts&lt;/code&gt; reducer. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; goes even further, showing how to create a reducer factory for parameterized pagination reducers.</source>
          <target state="translated">특정 게시물 목록의 상태를 관리하는 &lt;code&gt;posts(state, action)&lt;/code&gt; 을 추출했습니다 . 이것은 단지 &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;감속기 구성입니다&lt;/a&gt; ! 리듀서를 더 작은 리듀서로 나누는 방법을 선택하는 것이며,이 경우 객체 내부의 업데이트 항목을 &lt;code&gt;posts&lt;/code&gt; 리듀서로 위임합니다 . &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;실제 예는&lt;/a&gt; 파라미터 매김 감속기의 감속기 공장을 만드는 방법을 보여주는, 더 나아가.</target>
        </trans-unit>
        <trans-unit id="f2ba230f751c2afe5d48e98a148b40dba74b740d" translate="yes" xml:space="preserve">
          <source>We have two more actions to handle! Just like we did with &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt;, we'll import the &lt;code&gt;ADD_TODO&lt;/code&gt; and &lt;code&gt;TOGGLE_TODO&lt;/code&gt; actions and then extend our reducer to handle &lt;code&gt;ADD_TODO&lt;/code&gt;.</source>
          <target state="translated">처리해야 할 작업이 두 가지 더 있습니다! 우리가 그랬던 것처럼 &lt;code&gt;SET_VISIBILITY_FILTER&lt;/code&gt; , 우리는 가져올 수 있습니다 &lt;code&gt;ADD_TODO&lt;/code&gt; 및 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 작업을 한 후 처리하는 우리의 감속기 확장 &lt;code&gt;ADD_TODO&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="937d04010c34a1830de25cf054cedd314fd77775" translate="yes" xml:space="preserve">
          <source>We just modified how the &lt;code&gt;addTodo&lt;/code&gt; action creator behaves, completely invisible to the calling code. &lt;strong&gt;We don't have to worry about looking at each place where todos are being added, to make sure they have this check.&lt;/strong&gt; Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.</source>
          <target state="translated">&lt;code&gt;addTodo&lt;/code&gt; 액션 생성자가 동작 하는 방식을 수정 하여 호출 코드에는 전혀 보이지 않습니다. &lt;strong&gt;우리는 할 일이 추가되는 각 장소를 보면서 걱정할 필요가 없습니다. &lt;/strong&gt;액션 제작자는 액션 디스패치와 관련된 추가 로직을 해당 액션을 생성하는 실제 구성 요소와 분리 할 수 ​​있습니다. 응용 프로그램이 많이 개발되고 있고 요구 사항이 자주 변경되는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="727029cc06658123c8225de825d04ad8f8957f5b" translate="yes" xml:space="preserve">
          <source>We must distinguish between dispatching functions in general and the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function provided by the store instance without any middleware.</source>
          <target state="translated">일반적으로 디스패치 기능과 미들웨어없이 상점 인스턴스가 제공 하는 기본 &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능을 구별해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44bbe40c8a0e33b691c1b061d98660259d085213" translate="yes" xml:space="preserve">
          <source>We need to create a fake &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions. We use &lt;code&gt;jest.fn()&lt;/code&gt; to create stubs, but with other test frameworks you would likely use sinon.</source>
          <target state="translated">가짜 &lt;code&gt;getState&lt;/code&gt; , &lt;code&gt;dispatch&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 함수 를 만들어야 합니다. 우리는 사용 &lt;code&gt;jest.fn()&lt;/code&gt; 스텁을 만들 수 있지만, 다른 테스트 프레임 워크와 함께 당신은 가능성이 sinon를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="299e4ddfafdfef1e85fc435e6d7114d6525ef4bd" translate="yes" xml:space="preserve">
          <source>We now have examples of several kinds of split-up reducer functions: helper utilities like &lt;code&gt;updateObject&lt;/code&gt; and &lt;code&gt;createReducer&lt;/code&gt;, handlers for specific cases like &lt;code&gt;setVisibilityFilter&lt;/code&gt; and &lt;code&gt;addTodo&lt;/code&gt;, and slice-of-state handlers like &lt;code&gt;visibilityReducer&lt;/code&gt; and &lt;code&gt;todosReducer&lt;/code&gt;. We also can see that &lt;code&gt;appReducer&lt;/code&gt; is an example of a &quot;root reducer&quot;.</source>
          <target state="translated">우리는 지금 분할 최대 감속 기능의 몇 가지 예를 가지고 : 같은 도우미 유틸리티 &lt;code&gt;updateObject&lt;/code&gt; 및 &lt;code&gt;createReducer&lt;/code&gt; 같은 특별한 경우를위한 핸들러 &lt;code&gt;setVisibilityFilter&lt;/code&gt; 및 &lt;code&gt;addTodo&lt;/code&gt; 와 같은 슬라이스의 상태 핸들러 &lt;code&gt;visibilityReducer&lt;/code&gt; 및 &lt;code&gt;todosReducer&lt;/code&gt; . 또한 &lt;code&gt;appReducer&lt;/code&gt; 가 &quot;루트 리듀서&quot;의 예 임을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f931773a23d44ef9110cfd8557dfc7aa1e3202fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; as the testing engine. Note that it runs in a Node environment, so you won't have access to the DOM.</source>
          <target state="translated">테스트 엔진으로 &lt;a href=&quot;http://facebook.github.io/jest/&quot;&gt;Jest&lt;/a&gt; 를 권장 합니다. 노드 환경에서 실행되므로 DOM에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c48c28638a818ee714914dc38026f386ac75db5b" translate="yes" xml:space="preserve">
          <source>We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:</source>
          <target state="translated">이제이 중 하나를 사용하여 특수 카운터 감속기를 생성 한 다음 관심있는 상태 부분에 영향을주는 작업을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c89ee6942601c0a301153e30e9c58b2f5d8ec40b" translate="yes" xml:space="preserve">
          <source>We specified the behavior of our app before we even started writing the UI. We won't do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won't need to mock anything because they are just &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;pure&lt;/a&gt; functions. Call them, and make assertions on what they return.</source>
          <target state="translated">UI 작성을 시작하기 전에 앱의 동작을 지정했습니다. 이 자습서에서는이 작업을 수행하지 않지만이 시점에서 감속기와 액션 제작자를위한 테스트를 작성할 수 있습니다. &lt;a href=&quot;../introduction/threeprinciples#changes-are-made-with-pure-functions&quot;&gt;순수한&lt;/a&gt; 기능 이기 때문에 아무것도 조롱 할 필요가 없습니다 . 그들에게 전화를 걸어 그들이 돌아 오는 것에 대해 단언하십시오.</target>
        </trans-unit>
        <trans-unit id="c4470bb993a07bc6bfa269c5fb94507004598031" translate="yes" xml:space="preserve">
          <source>We store each subreddit's information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won't need to refetch unless we want to. Don't worry about all these items being in memory: unless you're dealing with tens of thousands of items, and your user rarely closes the tab, you won't need any sort of cleanup.</source>
          <target state="translated">모든 하위 레딧의 정보를 개별적으로 저장하여 모든 하위 레딧을 캐시 할 수 있습니다. 사용자가 두 번째로 전환하면 업데이트가 즉시 이루어 지므로 원하지 않으면 다시 가져올 필요가 없습니다. 이 모든 항목이 메모리에 있다는 것에 대해 걱정하지 마십시오. 수만 개의 항목을 다루지 않고 사용자가 탭을 거의 닫지 않는 한, 정리할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e50f981325b4d6e7b5e1ac94e3d14479ea909a5" translate="yes" xml:space="preserve">
          <source>We test that our middleware is calling the &lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, and &lt;code&gt;next&lt;/code&gt; functions at the right time.</source>
          <target state="translated">미들웨어가 &lt;code&gt;getState&lt;/code&gt; , &lt;code&gt;dispatch&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 함수를 적시에 호출하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="75cf0f6e6b134023b61b31d405a78b8ef43ce618" translate="yes" xml:space="preserve">
          <source>We then get the initial state from our Redux store using &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;store.getState()&lt;/code&gt;&lt;/a&gt;. We will see how this is passed along in our &lt;code&gt;renderFullPage&lt;/code&gt; function.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;store.getState()&lt;/code&gt; &lt;/a&gt; 사용하여 Redux 스토어에서 초기 상태를 가져옵니다 . &lt;code&gt;renderFullPage&lt;/code&gt; 함수 에서 이것이 어떻게 전달되는지 볼 것 입니다.</target>
        </trans-unit>
        <trans-unit id="319de368fdc28c8b195a6d2c03281f6821c69298" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt;&lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; in the examples. It is a new API for making network requests that replaces &lt;code&gt;XMLHttpRequest&lt;/code&gt; for most common needs. Because most browsers don't yet support it natively, we suggest that you use &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt;&lt;code&gt;isomorphic-fetch&lt;/code&gt;&lt;/a&gt; library:</source>
          <target state="translated">예제 에서는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/Fetch_API&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; API&lt;/a&gt; 를 사용합니다. 가장 일반적인 요구에 대해 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 대체하는 네트워크 요청을 작성하기위한 새로운 API입니다 . 대부분의 브라우저는 아직 기본적으로 지원하지 않으므로 &lt;a href=&quot;https://github.com/matthew-andrews/isomorphic-fetch&quot;&gt; &lt;code&gt;isomorphic-fetch&lt;/code&gt; &lt;/a&gt; 라이브러리 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a7b84a5beb3839d0cf7131fb4a2fbbb7aa5d2618" translate="yes" xml:space="preserve">
          <source>We use ES6 computed property syntax so we can update &lt;code&gt;state[action.subreddit]&lt;/code&gt; with &lt;code&gt;Object.assign()&lt;/code&gt; in a concise way. This:</source>
          <target state="translated">ES6 계산 속성 구문을 사용 하여 간결한 방식으로 &lt;code&gt;state[action.subreddit]&lt;/code&gt; 를 &lt;code&gt;Object.assign()&lt;/code&gt; 으로 업데이트 할 수 있습니다 . 이:</target>
        </trans-unit>
        <trans-unit id="38db718a04799e7dc7479e35fa4bd78f62cd7909" translate="yes" xml:space="preserve">
          <source>We will also need some container components to connect the presentational components to Redux. For example, the presentational &lt;code&gt;TodoList&lt;/code&gt; component needs a container like &lt;code&gt;VisibleTodoList&lt;/code&gt; that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a &lt;code&gt;FilterLink&lt;/code&gt; container component that renders a &lt;code&gt;Link&lt;/code&gt; that dispatches an appropriate action on click:</source>
          <target state="translated">프리젠 테이션 컴포넌트를 Redux에 연결하려면 컨테이너 컴포넌트도 필요합니다. 예를 들어 프레젠테이션 &lt;code&gt;TodoList&lt;/code&gt; 구성 요소 에는 Redux 저장소에 가입하고 현재 가시성 필터를 적용하는 방법을 알고있는 &lt;code&gt;VisibleTodoList&lt;/code&gt; 와 같은 컨테이너가 필요합니다 . 가시성 필터를 변경하기 위해 클릭시 적절한 조치를 전달하는 &lt;code&gt;Link&lt;/code&gt; 를 렌더링하는 &lt;code&gt;FilterLink&lt;/code&gt; 컨테이너 구성 요소를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cbe16722b5d079bcbcd195adcf84c0f8b9537578" translate="yes" xml:space="preserve">
          <source>We will also need to refactor &lt;code&gt;index.js&lt;/code&gt; to render the &lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; component to the DOM.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Root /&amp;gt;&lt;/code&gt; 컴포넌트를 DOM 으로 렌더링하려면 &lt;code&gt;index.js&lt;/code&gt; 를 리팩터링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eed46c74461e18da655f49826f9bb4cec981c01c" translate="yes" xml:space="preserve">
          <source>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</source>
          <target state="translated">나중에 우리가 취하는 접근 방식으로 세분화 된 실행 취소 및 재실행이 어떻게 필요한지 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48b8e0b74723fbbce7a038049b47d5983a8ab63" translate="yes" xml:space="preserve">
          <source>We will then import the &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; from React Redux:</source>
          <target state="translated">그런 다음 React Redux에서 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3dfe117d376bf6280908c658894a43c98efefd9b" translate="yes" xml:space="preserve">
          <source>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</source>
          <target state="translated">아래 예에서는 React를 사용하지만 서버에서 렌더링 할 수있는 다른 뷰 프레임 워크와 동일한 기술을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cfc720c34e5f99bae08591a1d21b8028d872f1f" translate="yes" xml:space="preserve">
          <source>We will use React to build our simple todo app.</source>
          <target state="translated">간단한 todo 앱을 만들기 위해 React를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="77e9494b8c84b985dfa4f4d49ca2fb485e0d6cbd" translate="yes" xml:space="preserve">
          <source>We will wrap &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; so that route handlers can get &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt;access to the &lt;code&gt;store&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">라우트 핸들러가 &lt;a href=&quot;../basics/usagewithreact#passing-the-store&quot;&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt; 액세스 할 수 있도록 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 에서 &amp;lt;Router /&amp;gt; 를 랩핑 합니다 .</target>
        </trans-unit>
        <trans-unit id="1d2a4109058f0af68e149216b99cc33debbea027" translate="yes" xml:space="preserve">
          <source>We would like to replace &lt;code&gt;getVisibleTodos&lt;/code&gt; with a memoized selector that recalculates &lt;code&gt;todos&lt;/code&gt; when the value of &lt;code&gt;state.todos&lt;/code&gt; or &lt;code&gt;state.visibilityFilter&lt;/code&gt; changes, but not when changes occur in other (unrelated) parts of the state tree.</source>
          <target state="translated">우리는 대체하려는 &lt;code&gt;getVisibleTodos&lt;/code&gt; 을 memoized 선택과 그을 다시 계산에 &lt;code&gt;todos&lt;/code&gt; 때의 값 &lt;code&gt;state.todos&lt;/code&gt; 또는 &lt;code&gt;state.visibilityFilter&lt;/code&gt; 의 변화가 아니라 변화 상태 트리의 다른 (무관) 부분에서 발생하는 경우.</target>
        </trans-unit>
        <trans-unit id="6c0e7d729963aa201c31d1a06cb609fdf81434f4" translate="yes" xml:space="preserve">
          <source>We'll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by &lt;code&gt;index&lt;/code&gt; because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</source>
          <target state="translated">사용자가 할 일을 완료 한 것으로 표시하는 동작 유형을 하나 더 추가합니다. 우리 는 배열에 저장하기 때문에 &lt;code&gt;index&lt;/code&gt; 로 특정 할 일을 참조합니다 . 실제 앱에서는 새로운 것이 생성 될 때마다 고유 ID를 생성하는 것이 더 현명합니다.</target>
        </trans-unit>
        <trans-unit id="070f3dc99d82df0afd700715eae9b841ac7a6b07" translate="yes" xml:space="preserve">
          <source>We'll explore how to perform side effects in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced walkthrough&lt;/a&gt;. For now, just remember that the reducer must be pure. &lt;strong&gt;Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;../advanced/index&quot;&gt;고급 연습&lt;/a&gt; 에서 부작용을 수행하는 방법을 살펴 보겠습니다 . 지금은 감속기가 순수해야 함을 기억하십시오. &lt;strong&gt;동일한 인수가 주어지면 다음 상태를 계산하여 반환해야합니다. 놀랍지 않습니다. 부작용이 없습니다. API 호출이 없습니다. 돌연변이가 없습니다. 계산 만하면됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa545b7295152e58ab853f3d912b19f7b907eb9" translate="yes" xml:space="preserve">
          <source>We'll start by specifying the initial state. Redux will call our reducer with an &lt;code&gt;undefined&lt;/code&gt; state for the first time. This is our chance to return the initial state of our app:</source>
          <target state="translated">초기 상태를 지정하여 시작하겠습니다. Redux는 감속기를 &lt;code&gt;undefined&lt;/code&gt; 상태로 처음으로 호출합니다 . 앱의 초기 상태를 반환 할 수있는 기회입니다.</target>
        </trans-unit>
        <trans-unit id="a566f04c7bb96e3dad921f4e977a52579a6948e3" translate="yes" xml:space="preserve">
          <source>We'll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You'll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</source>
          <target state="translated">가장 일반적인 사용 사례 인 목록부터 시작하겠습니다. 웹 애플리케이션은 종종 사물 목록을 보여줍니다. 예를 들어 게시물 목록 또는 친구 목록입니다. 앱이 어떤 종류의 목록을 표시 할 수 있는지 파악해야합니다. 이런 방식으로 상태를 캐시에 저장하고 필요한 경우에만 다시 가져올 수 있기 때문에 상태에서 별도로 저장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bf88ce0d8fb03a1213e9e5aff6c740f652fabdf4" translate="yes" xml:space="preserve">
          <source>We'll use separate types in this tutorial.</source>
          <target state="translated">이 튜토리얼에서는 별도의 유형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6deda5b238140890ee6ed5f2e792c4827705c840" translate="yes" xml:space="preserve">
          <source>We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the &lt;code&gt;createReducer&lt;/code&gt; function described in &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;Reducing Boilerplate&lt;/a&gt;:</source>
          <target state="translated">거의 다 끝났습니다. 많은 사람들이 switch 문을 좋아하지 않기 때문에 액션 유형의 룩업 테이블을 사례 함수로 만드는 함수를 사용하는 것이 매우 일반적입니다. &lt;a href=&quot;../reducingboilerplate#generating-reducers&quot;&gt;보일러 플레이트 줄이기에&lt;/a&gt; 설명 된 &lt;code&gt;createReducer&lt;/code&gt; 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="cf8eb046053a065111d778fef4cfcdc223cb9816" translate="yes" xml:space="preserve">
          <source>Webflow</source>
          <target state="translated">Webflow</target>
        </trans-unit>
        <trans-unit id="cb59effde77f318efa4856b404dd72c191879fc1" translate="yes" xml:space="preserve">
          <source>What approaches are there for handling data immutably? Do I have to use Immutable.JS?</source>
          <target state="translated">데이터를 불변 적으로 처리하기위한 어떤 접근법이 있습니까? Immutable.JS를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="2ec40d3e3697bdc90d47223d9a786375d4854093" translate="yes" xml:space="preserve">
          <source>What are some opinionated Best Practices for using Immutable.JS with Redux?</source>
          <target state="translated">Redux와 함께 Immutable.JS를 사용하기위한 의견이있는 모범 사례는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4617f0a4931acbdece3479c94cd5d9b8a29ffbc4" translate="yes" xml:space="preserve">
          <source>What are the benefits of Immutability?</source>
          <target state="translated">불변성의 이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="60982d038a3233ff8e99646cab1b3f3181f09be8" translate="yes" xml:space="preserve">
          <source>What are the benefits of immutability?</source>
          <target state="translated">불변성의 이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="de1352defc592755d5729188ff9c5931f975beca" translate="yes" xml:space="preserve">
          <source>What are the issues with using ES6 for immutable operations?</source>
          <target state="translated">불변 작업에 ES6을 사용할 때의 문제점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="87f7ec6d6c32ff8a62aada75fa88678bc51d6ac0" translate="yes" xml:space="preserve">
          <source>What are the issues with using Immutable.JS?</source>
          <target state="translated">Immutable.JS 사용과 관련된 문제는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7669cca5868cf84a7c911639d6206223bbfb9011" translate="yes" xml:space="preserve">
          <source>What are the issues with using JavaScript for immutable operations?</source>
          <target state="translated">불변 작업에 JavaScript를 사용할 때의 문제점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b6f105fcf428cb482f2dba1e64704d18ef939497" translate="yes" xml:space="preserve">
          <source>What are the issues with using plain JavaScript for immutable operations?</source>
          <target state="translated">불변 작업에 일반 JavaScript를 사용하는 데 어떤 문제가 있습니까?</target>
        </trans-unit>
        <trans-unit id="502931ac19eb7ad8e3a6b09a7f30f2039e70b8f9" translate="yes" xml:space="preserve">
          <source>What are the past (and future) states in the undo stack?</source>
          <target state="translated">실행 취소 스택에서 과거와 미래의 상태는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7af9c4632a04865406facc7a09e8fff13bee6fa5" translate="yes" xml:space="preserve">
          <source>What if we just replace the &lt;code&gt;dispatch&lt;/code&gt; function on the store instance? The Redux store is just a plain object with &lt;a href=&quot;../api/store&quot;&gt;a few methods&lt;/a&gt;, and we're writing JavaScript, so we can just monkeypatch the &lt;code&gt;dispatch&lt;/code&gt; implementation:</source>
          <target state="translated">스토어 인스턴스 에서 &lt;code&gt;dispatch&lt;/code&gt; 기능을 교체하면 어떻게 되나요? Redux 저장소는 &lt;a href=&quot;../api/store&quot;&gt;몇 가지 메소드가&lt;/a&gt; 있는 일반 객체이며 JavaScript를 작성 중이므로 &lt;code&gt;dispatch&lt;/code&gt; 구현을 원숭이 패치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da380f2420edcb4fe953f900cae3cd95adf19059" translate="yes" xml:space="preserve">
          <source>What if we want to apply &lt;strong&gt;more than one&lt;/strong&gt; such transformation to &lt;code&gt;dispatch&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; 을 위해 &lt;strong&gt;하나 이상의&lt;/strong&gt; 변환을 적용하려면 어떻게해야 합니까?</target>
        </trans-unit>
        <trans-unit id="8d5e21ca6d6c7949c97bbb82b6de23a8e86a90ba" translate="yes" xml:space="preserve">
          <source>What is the current state?</source>
          <target state="translated">현재 상태는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ccdd9f0a8546e0e957522917e3028ad2fdff0b9e" translate="yes" xml:space="preserve">
          <source>What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</source>
          <target state="translated">내 파일 구조는 어떻게 보입니까? 프로젝트에서 액션 크리에이터와 리듀서를 어떻게 그룹화해야합니까? 선택기는 어디로 가야합니까?</target>
        </trans-unit>
        <trans-unit id="39b7e4ebfa46344ad4758dbb7c54ade6b182a09d" translate="yes" xml:space="preserve">
          <source>What the Flux?! Let's Redux.</source>
          <target state="translated">플럭스 란?! Redux하자.</target>
        </trans-unit>
        <trans-unit id="7685a22848ac997a066fa32d4715b4fcb5b90efa" translate="yes" xml:space="preserve">
          <source>Whatever convention you choose, stick with it throughout the application.</source>
          <target state="translated">어떤 규칙을 선택하든 응용 프로그램 전체에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e44dc3bb557d164a1c8cd909a8179ffc29fe58f" translate="yes" xml:space="preserve">
          <source>When a piece of data is duplicated in several places, it becomes harder to make sure that it is updated appropriately.</source>
          <target state="translated">여러 부분에 데이터 조각이 복제되면 데이터가 제대로 업데이트되는지 확인하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="c0b74de7e07b265987ff3765a92ea469eb3be3c6" translate="yes" xml:space="preserve">
          <source>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is &lt;code&gt;undefined&lt;/code&gt;, and you're all set.</source>
          <target state="translated">상점이 작성되면 Redux는 더미 조치를 감속기에 전달하여 상점을 초기 상태로 채 웁니다. 더미 조치를 직접 처리하지는 않습니다. 첫 번째 인수로 주어진 상태가 &lt;code&gt;undefined&lt;/code&gt; 이고 감속기가 설정되어 있으면 감속기가 일종의 초기 상태를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="55f47f3d19e55c7f647cc1402dfe664e913c42b7" translate="yes" xml:space="preserve">
          <source>When adding JavaScript objects to an Immutable.JS Map or List using Immutable.JS&amp;rsquo;s &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; methods, ensure that the object being added is first converted to an Immutable object using &lt;code&gt;fromJS()&lt;/code&gt;.</source>
          <target state="translated">Immutable.JS의 &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 메소드를 사용하여 JavaScript 오브젝트를 Immutable.JS 맵 또는 목록에 추가 할 때 추가 중인 오브젝트가 먼저 &lt;code&gt;fromJS()&lt;/code&gt; 사용하여 Immutable 오브젝트로 변환되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5532214553b2a415074b0f39f2cead024233404a" translate="yes" xml:space="preserve">
          <source>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn't need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions&amp;mdash;like those synchronous actions we defined earlier.</source>
          <target state="translated">액션 생성자가 함수를 반환하면 해당 함수는 Redux Thunk 미들웨어에 의해 실행됩니다. 이 기능은 순수 할 필요는 없습니다. 따라서 비동기 API 호출 실행을 포함하여 부작용이 발생할 수 있습니다. 이 함수는 앞서 정의한 동기 동작과 같은 동작도 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b511652b6790f3eca5e3448a96b4a14c313d91" translate="yes" xml:space="preserve">
          <source>When it's time to fetch the posts for some subreddit, we will dispatch a &lt;code&gt;REQUEST_POSTS&lt;/code&gt; action:</source>
          <target state="translated">하위 하위 항목에 대한 게시물을 가져올 때 &lt;code&gt;REQUEST_POSTS&lt;/code&gt; 작업 을 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c552f80b72ecd37903e2d6ffce7bb1a0b3ba91ad" translate="yes" xml:space="preserve">
          <source>When previously we wrote: &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt;, it made available inside &lt;code&gt;App&lt;/code&gt; a &lt;code&gt;params&lt;/code&gt; property.</source>
          <target state="translated">이전에 우리가 썼을 때 : &lt;code&gt;&amp;lt;Route path=&quot;/(:filter)&quot; component={App} /&amp;gt;&lt;/code&gt; , 그것은 내부에서 사용할 &lt;code&gt;App&lt;/code&gt; &lt;code&gt;params&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c55e37eb1a90ec0796f6a4f05992a64917889494" translate="yes" xml:space="preserve">
          <source>When rendering, we will wrap &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;, our root component, inside a &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; to make the store available to all components in the component tree, as we saw in &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;.</source>
          <target state="translated">렌더링 할 때 &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt; 에서 보았 듯이 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 안에 루트 구성 요소 인 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 를 래핑 하여 구성 요소 트리의 모든 구성 요소에서 저장소를 사용할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f09b0e83401e68e4c33132aa1b3b73a6d4dcd4" translate="yes" xml:space="preserve">
          <source>When should I use Redux?</source>
          <target state="translated">언제 Redux를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="d794925cbdb0e31214ecfc88910755d33c4f0b10" translate="yes" xml:space="preserve">
          <source>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous Redux data flow&lt;/a&gt; takes place.</source>
          <target state="translated">체인의 마지막 미들웨어가 조치를 전달할 때는 일반 오브젝트 여야합니다. 때이다 &lt;a href=&quot;../basics/dataflow&quot;&gt;동기 돌아 오는 데이터 흐름이&lt;/a&gt; 일어난다.</target>
        </trans-unit>
        <trans-unit id="d74a3e9748d787071d9c2fe4d73363cc68c2dcd3" translate="yes" xml:space="preserve">
          <source>When the page loads, the bundle file will be started up and &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; will hook into the &lt;code&gt;data-react-id&lt;/code&gt; attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</source>
          <target state="translated">페이지가로드되면 번들 파일이 시작되고 &lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; 는 서버 렌더링 HTML에서 &lt;code&gt;data-react-id&lt;/code&gt; 속성에 연결됩니다. 새로 시작한 React 인스턴스를 서버에서 사용되는 가상 DOM에 연결합니다. Redux 스토어의 초기 상태가 동일하고 모든 뷰 구성 요소에 동일한 코드를 사용했기 때문에 결과는 동일한 실제 DOM이됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc93b372187dd00b09c70c8f0349010aacbd69a" translate="yes" xml:space="preserve">
          <source>When the shallow check fails, React-Redux will cause the component to re-render. Using &lt;code&gt;toJS()&lt;/code&gt; in &lt;code&gt;mapStateToProps&lt;/code&gt; in this way, therefore, will always cause the component to re-render, even if the value never changes, impacting heavily on performance.</source>
          <target state="translated">얕은 확인이 실패하면 React-Redux는 구성 요소를 다시 렌더링합니다. 따라서 &lt;code&gt;mapStateToProps&lt;/code&gt; 에서 &lt;code&gt;toJS()&lt;/code&gt; 를 사용 하면 값이 변경되지 않더라도 성능에 큰 영향을 미치는 구성 요소가 항상 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa9765bfd105e5641e876f4bda241427a866bc5" translate="yes" xml:space="preserve">
          <source>When the user presses &amp;ldquo;Redo&amp;rdquo;, we want to move one step back into the future:</source>
          <target state="translated">사용자가 &quot;Redo&quot;를 누르면 한 단계 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6f1dc68360b35a018ee091fccfa401d6fad91461" translate="yes" xml:space="preserve">
          <source>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won't match the server markup, and the client would have to load the data again.</source>
          <target state="translated">서버 렌더링과 함께 Redux를 사용할 때는 클라이언트가 앱을 초기 상태로 사용할 수 있도록 응답과 함께 앱 상태도 보내야합니다. HTML을 생성하기 전에 데이터를 미리로드하면 클라이언트도이 데이터에 액세스 할 수 있기를 원하기 때문에 이것은 중요합니다. 그렇지 않으면 클라이언트에서 생성 된 마크 업이 서버 마크 업과 일치하지 않으므로 클라이언트가 데이터를 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="08905f564cddc435b39d4746befbbfde05d56c89" translate="yes" xml:space="preserve">
          <source>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</source>
          <target state="translated">비동기 API를 호출 할 때는 두 가지 중요한 순간, 즉 호출을 시작하는 순간과 응답을받는 순간 (또는 시간 초과)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17e363eb01279dd12d04917f1f023babea53839" translate="yes" xml:space="preserve">
          <source>When you emit an action, &lt;code&gt;todoApp&lt;/code&gt; returned by &lt;code&gt;combineReducers&lt;/code&gt; will call both reducers:</source>
          <target state="translated">액션을 생성하면 &lt;code&gt;todoApp&lt;/code&gt; 반환 한 &lt;code&gt;combineReducers&lt;/code&gt; 이 두 리듀서를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9320a916b3e55e2e80a21708cceecfcf437cc640" translate="yes" xml:space="preserve">
          <source>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers(reducers)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 Flux Store를 리듀서 위에 구현하도록 포팅 한 경우 Flux 라이브러리를 단일 Redux 스토어로 교체하고 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers(reducers)&lt;/code&gt; &lt;/a&gt; 사용하여 이미 보유한 리듀서를 하나로 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0a2799ac8efd1f6499c6fb41130094d5c12a451" translate="yes" xml:space="preserve">
          <source>Where do I put my business logic in a React/Redux application?</source>
          <target state="translated">비즈니스 로직을 React / Redux 애플리케이션에서 어디에 배치해야합니까?</target>
        </trans-unit>
        <trans-unit id="8c07523b65b47a0ad36e94ad44e0e56dd3913c89" translate="yes" xml:space="preserve">
          <source>Where do we get the initial &lt;code&gt;present&lt;/code&gt; state from? We don't seem to know it beforehand.</source>
          <target state="translated">초기 &lt;code&gt;present&lt;/code&gt; 상태는 어디서 얻 습니까? 미리 알지 못하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c79f8ed0107a7fe0a477df33c48d8c228e7eee0" translate="yes" xml:space="preserve">
          <source>Where do we react to the external actions to save the &lt;code&gt;present&lt;/code&gt; to the &lt;code&gt;past&lt;/code&gt;?</source>
          <target state="translated">우리 는 &lt;code&gt;past&lt;/code&gt; &lt;code&gt;present&lt;/code&gt; 를 구하기 위해 외부 행동에 어떤 반응을 보 입니까?</target>
        </trans-unit>
        <trans-unit id="6559f99fd936b0050a5d2a1fc16d0873490da574" translate="yes" xml:space="preserve">
          <source>Where to Hold React Component Data: state, store, static, and this</source>
          <target state="translated">반응 구성 요소 데이터를 보유 할 위치 : 상태, 저장, 정적 및이</target>
        </trans-unit>
        <trans-unit id="03693bfdc7508d98809d55b857217f95caac409e" translate="yes" xml:space="preserve">
          <source>Whether you choose to use such a library, or stick with plain JavaScript, depends on how comfortable you are with adding another dependency to your app, or how sure you are that you can avoid the pitfalls inherent within JavaScript&amp;rsquo;s approach to immutability.</source>
          <target state="translated">이러한 라이브러리를 사용하거나 일반 JavaScript를 고를 지 여부는 앱에 다른 종속성을 추가하는 것이 얼마나 편안한 지 또는 불변성에 대한 JavaScript의 접근 방식에 내재 된 함정을 피할 수 있는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="067c7d896d6446815e8315d7a4fcfafc8f8da43b" translate="yes" xml:space="preserve">
          <source>Whether you have used them or not, Redux only takes a few minutes to get started with.</source>
          <target state="translated">사용 여부에 관계없이 Redux는 시작하는 데 몇 분 밖에 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbfecd927f559c2b5baf796e97b2ca728811bf43" translate="yes" xml:space="preserve">
          <source>Whichever option you choose, make sure you&amp;rsquo;re familiar with the concepts of &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;immutability, side effects and mutation&lt;/a&gt;. In particular, ensure you have a deep understanding of what JavaScript does when updating and copying values in order to guard against accidental mutations that will degrade your app&amp;rsquo;s performance, or break it altogether.</source>
          <target state="translated">어떤 옵션을 선택 하든지 &lt;a href=&quot;reducers/prerequisiteconcepts#note-on-immutability-side-effects-and-mutation&quot;&gt;불변성, 부작용 및 돌연변이&lt;/a&gt; 의 개념에 익숙해야합니다 . 특히, 앱 성능을 저하 시키거나 완전히 파괴하는 실수로 인한 돌연변이를 방지하기 위해 값을 업데이트하고 복사 할 때 JavaScript가 수행하는 작업에 대해 깊이 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="03047acfd57571e8bdbc8135d9d15cea99035eb1" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is a handy helper utility, you don't have to use it; feel free to write your own root reducer!</source>
          <target state="translated">하지만 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 편리한 도우미 유틸리티입니다, 당신은 그것을 사용할 필요가 없습니다; 자신의 루트 리듀서를 자유롭게 작성하십시오!</target>
        </trans-unit>
        <trans-unit id="4089c3ad2441e642d6adb86e7f9d112ea7103b43" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;combineReducers&lt;/code&gt; attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. &lt;code&gt;combineReducers&lt;/code&gt; will check your reducers by passing &lt;code&gt;undefined&lt;/code&gt; to them; this is done even if you specify initial state to &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt;. Therefore, you &lt;strong&gt;must&lt;/strong&gt; ensure your reducers work properly when receiving &lt;code&gt;undefined&lt;/code&gt; as state, even if you never intend for them to actually receive &lt;code&gt;undefined&lt;/code&gt; in your own code.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는 감속기가 이러한 규칙 중 일부를 준수하는지 확인하려고 시도 하지만 규칙을 기억하고 따라야합니다. &lt;code&gt;combineReducers&lt;/code&gt; 는 감속기를 &lt;code&gt;undefined&lt;/code&gt; 하지 않고 전달하여 검사합니다 . 이것은 초기 상태를 &lt;code&gt;Redux.createStore(combineReducers(...), initialState)&lt;/code&gt; 지정하더라도 수행됩니다 . 따라서 자신의 코드에서 실제로 &lt;code&gt;undefined&lt;/code&gt; 것을 수신하지 않더라도 상태로 &lt;code&gt;undefined&lt;/code&gt; 상태를 수신 할 때 감속기가 올바르게 작동하는지 확인 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1e65f5bf9037c5912b84c5835b30699b791739" translate="yes" xml:space="preserve">
          <source>While React Redux does work to minimize the number of times that your &lt;code&gt;mapStateToProps&lt;/code&gt; function is called, it's still a good idea to ensure that your &lt;code&gt;mapStateToProps&lt;/code&gt; runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized &amp;ldquo;selector&amp;rdquo; functions using &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt;. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</source>
          <target state="translated">React Redux는 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수가 호출 되는 횟수를 최소화 하기 위해 노력하지만 &lt;code&gt;mapStateToProps&lt;/code&gt; 가 빠르게 실행 되도록하고 작업량 을 최소화 하는 것이 좋습니다 . 일반적인 권장 방법은 사용 &quot;선택&quot;기능 memoized 만드는 것입니다 &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;다시 선택을&lt;/a&gt; . 이러한 선택기는 함께 결합 및 구성 될 수 있으며 파이프 라인에서 나중에 선택기는 입력이 변경된 경우에만 실행됩니다. 즉, 필터링 또는 정렬과 같은 작업을 수행하는 선택기를 만들 수 있으며 필요한 경우에만 실제 작업이 수행되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040c756905d96ee1b18a17c4c17f4f0537e48ce8" translate="yes" xml:space="preserve">
          <source>While Redux itself is not opinionated about how your state is organized, &lt;code&gt;combineReducers&lt;/code&gt; enforces several rules to help users avoid common errors. (See &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Redux 자체는 귀하의 주가 어떻게 구성되어 있는지에 대해서는 의견을 제시하지 않지만 &lt;code&gt;combineReducers&lt;/code&gt; 는 사용자가 일반적인 오류를 피할 수 있도록 몇 가지 규칙을 시행합니다. (자세한 내용은 &lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="8dfc58574b33f1efddcb65068c1c7a976c89a49a" translate="yes" xml:space="preserve">
          <source>While effective, using &lt;code&gt;Object.assign()&lt;/code&gt; can quickly make simple reducers difficult to read given its rather verbose syntax.</source>
          <target state="translated">효과적이지만 &lt;code&gt;Object.assign()&lt;/code&gt; 사용 하면 간단한 구문 기를 사용 하면 간단한 감속기를 읽기가 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="269ba06048a7e4e70129f1c6f218059f072f2367" translate="yes" xml:space="preserve">
          <source>While it is technically &lt;em&gt;possible&lt;/em&gt; to &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;write impure reducers&lt;/a&gt; that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn't seem like immutability poses performance problems in most real apps, because, as &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</source>
          <target state="translated">성능 저하 사례에 대한 데이터를 변경하는 &lt;a href=&quot;https://github.com/reactjs/redux/issues/328#issuecomment-125035516&quot;&gt;불완전한 감속기&lt;/a&gt; 를 작성 하는 것은 기술적으로 &lt;em&gt;가능&lt;/em&gt; 하지만 적극적으로 권장 하지는 않습니다. 시간 여행, 레코드 / 재생 또는 핫 리로드와 같은 개발 기능이 중단됩니다. 또한 &lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om이&lt;/a&gt; 보여 주듯이 객체 할당을 잃어 버려도 값 비싼 재 렌더링 및 재 계산을 피함으로써 여전히 승리 하기 때문에 불변성이 대부분의 실제 앱에서 성능 문제를 일으키는 것처럼 보이지 않습니다. 순도 감소로 인해 변화했습니다.</target>
        </trans-unit>
        <trans-unit id="abcdc11df5ffeb4a687df7b1d5bbf50fd78fa63f" translate="yes" xml:space="preserve">
          <source>While it ultimately doesn't matter how you lay out your code on disk, it's important to remember that actions and reducers shouldn't be considered in isolation. It's entirely possible (and encouraged) for a reducer defined in one folder to respond to an action defined in another folder.</source>
          <target state="translated">디스크에 코드를 배치하는 방법은 궁극적으로 중요하지 않지만 동작과 감속기는 분리하여 고려해서는 안된다는 것을 기억하는 것이 중요합니다. 한 폴더에 정의 된 감속기가 다른 폴더에 정의 된 작업에 응답하는 것이 전적으로 가능하고 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">미들웨어는 비동기 API 호출을 포함하여 다양한 용도로 사용될 수 있지만 그 출처를 이해하는 것이 중요합니다. 로깅 및 충돌보고를 예로 사용하여 미들웨어로 이어지는 사고 과정을 안내합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
