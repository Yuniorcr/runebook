<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="translated">이것에 대한 단 하나의 결정적인 대답은 없지만, 대부분의 경우 이것은 어느 경우에도 문제가되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="translated">왜 &lt;code&gt;dispatch&lt;/code&gt; 덮어 쓰는가 ? 물론 나중에 호출 할 수 있지만 또 다른 이유도 있습니다. 모든 미들웨어가 이전에 랩핑 된 &lt;code&gt;store.dispatch&lt;/code&gt; 에 액세스하고 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="translated">React-Redux가 &lt;code&gt;mapStateToProp&lt;/code&gt; 에서 반환 된 props 객체 내의 각 값을 얕게 검사하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="translated">Redux에서 얕은 동등성 검사를 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">감속기가 상태를 변경하면 React-Redux가 래핑 된 구성 요소를 다시 렌더링하지 못하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">셀렉터가 영속 객체를 변경하고 &lt;code&gt;mapStateToProps&lt;/code&gt; 에 반환하면 React-Redux가 래핑 된 컴포넌트를 다시 렌더링하지 못하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="translated">연결된 구성 요소에 &lt;code&gt;this.props.dispatch&lt;/code&gt; 를 사용할 수 없는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="translated">연결된 구성 요소에 this.props.dispatch를 사용할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="translated">Redux에 불변성이 필요한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="translated">Redux에서 불변성이 필요한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="translated">이번에 는 왜 &lt;code&gt;0&lt;/code&gt; 이 아닌 &lt;code&gt;42&lt;/code&gt; 입니까? &lt;code&gt;createStore&lt;/code&gt; 가 두 번째 인수 로 &lt;code&gt;42&lt;/code&gt; 를 사용하여 호출 되었기 때문입니다. 이 인수는 더미 동작과 함께 감속기로 전달 된 &lt;code&gt;state&lt;/code&gt; 가됩니다. &lt;strong&gt;이번에는 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 가 정의되지 않았으므로 ( &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;42&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; !) ES6 기본 인수 구문은 영향을 미치지 않습니다. &lt;/strong&gt; &lt;code&gt;state&lt;/code&gt; 이다 &lt;code&gt;42&lt;/code&gt; 및 &lt;code&gt;42&lt;/code&gt; 감속기에서 반환된다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="translated">왜 컴포넌트가 너무 자주 렌더링 되나요?</target>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="translated">이것이 왜 유익합니까? &lt;strong&gt;상수가 불필요하다고 주장하는 경우가 많으며 소규모 프로젝트의 경우에는 정확할 수 있습니다. &lt;/strong&gt;대규모 프로젝트의 경우 작업 유형을 상수로 정의하면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="translated">컴포넌트가 다시 렌더링되지 않거나 mapStateToProps가 실행되지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 이 문자열이거나 직렬화 가능한 이유는 무엇 입니까? 액션 유형이 왜 상수 여야합니까?</target>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="translated">불변 라이브러리로 Immutable.JS를 선택해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="translated">Immutable.JS와 같은 변경 불가능한 라이브러리를 사용해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">type이 문자열이거나 직렬화 가능한 이유는 무엇입니까? 액션 유형이 왜 상수 여야합니까?</target>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="translated">가변성 객체에서 얕은 동등성 검사가 작동하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="translated">위키 백과 : 연관 엔터티</target>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="translated">&quot;하나의 상태 트리&quot;가 있으면 메모리 문제가 발생합니까? 많은 작업을 전달하면 메모리가 사용됩니까?</target>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux를&lt;/a&gt; 사용하면 &lt;code&gt;connect()&lt;/code&gt; 함수로 생성 된 래퍼 클래스 가 &lt;code&gt;props.store&lt;/code&gt; 가있는 경우 실제로 props.store를 찾습니다 . 그러나 &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; 에서 루트 구성 요소를 래핑 하고 React Redux가 전달에 대해 걱정하게하는 것이 가장 좋습니다. 가게 아래로. 이렇게하면 컴포넌트가 상점 모듈 가져 오기에 대해 걱정할 필요가 없으며 Redux 앱을 분리하거나 서버 렌더링을 사용하는 것이 나중에 훨씬 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="translated">함께 &lt;code&gt;combineReducers()&lt;/code&gt; 동작은 미묘한 차이입니다. &lt;code&gt;preloadedState&lt;/code&gt; 에 상태가 지정된 리듀서는 해당 상태를 수신합니다. 다른 리듀서는 &lt;code&gt;undefined&lt;/code&gt; 수신 &lt;em&gt;되므로&lt;/em&gt; 지정된 &lt;code&gt;state = ...&lt;/code&gt; 기본 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="translated">JavaScript를 사용하면 실수로 객체 (예 : Redux 상태 트리)를 변경하지 않고도 실수로 쉽게 변경할 수 있습니다. 예를 들어 깊게 중첩 된 속성을 업데이트 하거나, 새 객체 대신 객체에 대한 새로운 &lt;em&gt;참조&lt;/em&gt; 를 만들 거나, 딥 카피가 아닌 얕은 카피를 수행하면, 의도하지 않은 객체 변형이 발생할 수 있으며 가장 경험이 많은 JavaScript 코더조차도 트립 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="translated">그러나 Redux를 사용하면 실행 취소 기록을 쉽게 구현할 수 있습니다. 이에 대한 세 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="translated">Redux를 사용하면 동일한 업데이트 논리를 축소 기능으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="translated">이 방법을 제외하고 앞서 정의한 &lt;a href=&quot;actions&quot;&gt;동작&lt;/a&gt; 을 이해하도록 점진적으로 학습기를 통해 감속기를 작성해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;middleware&quot;&gt;미들웨어가&lt;/a&gt; 없으면 Redux 저장소는 &lt;a href=&quot;../basics/dataflow&quot;&gt;동기식 데이터 흐름&lt;/a&gt; 만 지원 합니다 . 이것은 기본적으로 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 얻는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="translated">없이 &lt;code&gt;combineReducers()&lt;/code&gt; 또는 이와 유사한 수동 코드, &lt;code&gt;preloadedState&lt;/code&gt; 는 항상 이긴다 &lt;code&gt;state = ...&lt;/code&gt; 때문에 감속기의 &lt;code&gt;state&lt;/code&gt; 감속기에 전달이 &lt;em&gt;입니다 &lt;/em&gt; &lt;code&gt;preloadedState&lt;/code&gt; 하고 &lt;em&gt;있지 않습니다 &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; ES6 인수 구문이 적용되지 않도록.</target>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="translated">미들웨어가 없으면 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 는 일반 객체 만 허용하므로 컴포넌트 내부에서 AJAX 호출을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="translated">각 동작에 대해&amp;ldquo;모든 감속기&amp;rdquo;를 호출하는 것이 느리지 않습니까?</target>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="translated">워드 프레스의 새로운 관리자 페이지</target>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="translated">VK API 작업 (러시아어)</target>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="translated">앱에서 발생하는 모든 작업과 그 후에 계산 된 상태를 기록하면 좋지 않습니까? 문제가 발생하면 로그를 되돌아보고 상태를 손상시킨 작업을 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="translated">액션을 디스패치 한 결과로 에러가 발생했을 때 , 스택 트레이스가있는 &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; , 에러를 일으킨 액션, 현재 상태와 같은 충돌보고 서비스로 보내면 유용하지 않습니까? 이런 식으로 개발 과정에서 오류를 재현하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="translated">감속기 포장</target>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="translated">작문 시험</target>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="translated">간단한 액션 제작자를 작성하는 것은 번거롭고 종종 중복 상용구 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="translated">예, 많이 있습니다! 몇 가지 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="translated">Redux가 필요하지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="translated">보다 간결한 구문을 위해 &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;객체 분산 연산자 제안&lt;/a&gt; 을 활성화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="translated">액션 제작자를 생성하는 함수를 항상 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">구성 요소 및 XHR 콜백을 포함하여 앱의 어느 곳에서나 예약 된 간격으로 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">전달 된 객체의 리듀서에 다른 키를 사용하여 상태 키 이름을 제어 할 수 있습니다. 예를 들어 상태 모양이 &lt;code&gt;{ todos, counter }&lt;/code&gt; &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;실제 예제&lt;/a&gt; 처럼 API에 대한 호출을 설명하는 사용자 정의 미들웨어를 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">함수에 로깅을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; 에서 더 많은 예제를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">공식 로고 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;는 GitHub에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">이로 인해 상점이 보유한 상태가 어떻게 변경되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">번들 파일을 &lt;code&gt;static/bundle.js&lt;/code&gt; 로 컴파일하도록 선택한 빌드 도구 (Webpack, Browserify 등)를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">그런 다음 원하는 경우 &lt;code&gt;dispatch&lt;/code&gt; 를 다른 구성 요소로 수동으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;store.dispatch()&lt;/code&gt; 대신 어디서나 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; 를 사용하여 기능 대신 약속을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; 을 사용하여 Observable을 발송할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">Redux를 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 또는 다른 뷰 라이브러리와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">루트 감속기를 만드는 것이 아니라 모든 수준의 감속기 구조에서 사용할 수 있습니다. 루트 리듀서를 만들기 위해 함께 구성된 여러 장소에 여러 개의 결합 감속기를 갖는 것이 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; 미들웨어를 사용하여 약속 기반 비동기 조치를 디스패치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; 미들웨어를 사용하여보다 복잡한 비동기 조치를 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">불변의 객체는 변경할 수 없습니다. 대신 원본을 그대로두고 복사본을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">그들에게 다른 키를 주거나 기능을 다르게 호출 할 수도 있습니다. 결합 감속기를 작성하는이 두 가지 방법은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">일반 필터링을 고차 리듀서로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">Redux와 함께 Immutable.JS를 사용할 필요는 없습니다. 일반 JavaScript는 올바르게 작성된 경우 불변 중심 라이브러리를 사용하지 않고도 불변성을 완벽하게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">별도의 파일에서 활동 유형 상수를 정의하거나 전혀 정의하지 않아도됩니다. 소규모 프로젝트의 경우 작업 유형에 문자열 리터럴을 사용하는 것이 더 쉬울 수 있습니다. 그러나 더 큰 코드베이스에서 상수를 명시 적으로 선언하면 몇 가지 이점이 있습니다. 코드베이스를 깨끗하게 유지하는 데 대한 실용적인 팁을 보려면 &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;보일러 플레이트 줄이기를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">두 개의 감속기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">다음과 같은 경고를 사용하여 변경 리스너에서 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b929863aa2c2de96072c024f0b1ab365c66cfa6b" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">변경 리스너에서 &lt;a href=&quot;#dispatchaction&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .주의 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">리듀서 계층의 모든 레벨에서 &lt;code&gt;combineReducers&lt;/code&gt; 를 호출 할 수 있습니다 . 맨 위에서 일어날 필요는 없습니다. 실제로 너무 복잡한 아동 감속기를 독립 손자 등으로 나누는 데 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 를 향상시킬 수 있습니다 . 필수는 아니지만 &lt;a href=&quot;asyncactions&quot;&gt;편리한 방식으로 비동기 작업&lt;/a&gt; 을 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">이러한 조치 중 일부를 처리하기 위해 일부 사용자 정의 함수를 작성해야 할 수도 있습니다. 이로 인해 &lt;code&gt;combineReducers&lt;/code&gt; 를 고유 한 최상위 감속기 기능으로 교체해야 할 수도 있습니다. &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; 와 같은 유틸리티를 사용하여 &lt;code&gt;combineReducers&lt;/code&gt; 를 실행 하여 대부분의 작업을 처리 할 수 ​​있지만 상태 조각을 가로 지르는 특정 작업에 대해보다 전문화 된 Reducer를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">선택적으로 초기 상태를 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 지정할 수 있습니다 . 이는 서버에서 실행중인 Redux 애플리케이션의 상태와 일치하도록 클라이언트의 상태를 수화시키는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">작업에 전용 &lt;code&gt;status&lt;/code&gt; 필드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">약속 및 썽크와 같은 비동기 기본 요소를 사용하여 Redux에서 비동기 플로우를 표시하는 방법에 대해 자세히 알아 보려면 &lt;a href=&quot;../advanced/asyncactions&quot;&gt;비동기 조치&lt;/a&gt; 를 읽으십시오 . 여기서 배우는 것은 보편적 인 렌더링에도 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">리듀서 구성 계층의 모든 수준 에서 하나 이상의 리듀서를 &lt;code&gt;undoable&lt;/code&gt; 할 수없는 상태로 래핑 할 수 있습니다 . &lt;code&gt;visibilityFilter&lt;/code&gt; 변경 사항 이 실행 취소 기록에 반영되지 않도록 최상위 결합 감속기 대신 &lt;code&gt;todos&lt;/code&gt; 을 래핑하도록 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">클래식 Flux처럼 액션 제작자를 스토어 인스턴스에 즉시 바인딩하지 않는 이유는 무엇입니까? 문제는 이것이 서버에서 렌더링해야하는 범용 앱에서 제대로 작동하지 않는다는 것입니다. 대부분의 경우 요청마다 별도의 상점 인스턴스를 갖고 싶어서 다른 데이터로 준비 할 수 있지만 정의 중에 조치 작성자를 바인딩하면 모든 요청에 ​​대해 단일 상점 인스턴스가 붙어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;고차 함수에&lt;/a&gt; 익숙 할 것 입니다. React를 사용하면 &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;고차 컴포넌트에&lt;/a&gt; 익숙 할 수 있습니다 . 다음은 감속기에 적용되는 동일한 패턴의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">Redux가 &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture의&lt;/a&gt; 영향을 받았다고 들었을 것입니다 . 이 예제가 &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt; 와 매우 유사하다는 것은 놀라운 일이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">이를 사용하여 여러 &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;상점 향상&lt;/a&gt; 기를 연속 으로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">별도의 파일에 조치 작성자를 작성하여 컴포넌트로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">물론 이것을 볼 수는 없습니다-Immutable.JS 객체에 제공하는 데이터는 절대로 변경되지 않습니다. 오히려 Immutable.JS 내에서 생성 된 &lt;em&gt;중간&lt;/em&gt; 데이터이며 자유롭게 변경할 수있는 일련의 메소드 호출 시퀀스에서 생성됩니다. 따라서 잠재적 인 성능 저하가 거의 없거나 전혀없는 불변 데이터 구조의 모든 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">&lt;code&gt;undoable&lt;/code&gt; 기능 으로 강화하려는 감속기를 포장해야 합니다. 예를 들어, 전용 파일에서 &lt;code&gt;todos&lt;/code&gt; Reducer 를 내 보낸 경우 , 작성한 Reducer를 사용하여 &lt;code&gt;undoable()&lt;/code&gt; 호출 결과를 내보내도록이를 변경하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">URL에서 해시를 제거하고 싶을 것입니다 (예 : &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ). 이를 위해 React Router에서 &lt;code&gt;browserHistory&lt;/code&gt; 도 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">당신은 사용할 &lt;code&gt;connect()&lt;/code&gt; 에서이 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;돌아 오는 반응&lt;/a&gt; 컨테이너 구성 요소를 생성 할 수 있습니다. 실행 취소 및 다시 실행 버튼을 사용할지 여부를 결정하기 위해 &lt;code&gt;state.todos.past.length&lt;/code&gt; 및 &lt;code&gt;state.todos.future.length&lt;/code&gt; 를 확인할 수 있습니다 . Redux Undo가 이미 제공하기 때문에 실행 취소 및 재실행을 수행하기 위해 활동 작성자를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">테스트에는 명명 된 내보내기 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">플럭스가 필요할 때 알게 될 것입니다. 필요한지 확실하지 않으면 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">상태 트리에 일부 데이터와 UI 상태를 저장해야하는 경우가 종종 있습니다. 이것은 좋지만 데이터를 UI 상태와 별도로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">&lt;a href=&quot;asyncactions&quot;&gt;비동기 작업&lt;/a&gt; 예제 에서 미들웨어가 작동하는 것을 보았습니다 . &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; 및 &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt; 와 같은 서버 측 라이브러리를 사용한 경우 이미 &lt;em&gt;미들웨어&lt;/em&gt; 개념에 익숙했을 것입니다 . 이러한 프레임 워크에서 미들웨어는 요청을 수신하는 프레임 워크와 응답을 생성하는 프레임 워크 사이에 넣을 수있는 일부 코드입니다. 예를 들어 Express 또는 Koa 미들웨어는 CORS 헤더, 로깅, 압축 등을 추가 할 수 있습니다. 미들웨어의 가장 큰 특징은 체인으로 구성 할 수 있다는 것입니다. 단일 프로젝트에서 여러 개의 독립적 인 타사 미들웨어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">바보 같은 구성 요소는 순수해야합니다. 즉, 동일한 입력이 주어지면 동일한 출력을 생성해야하며 외부 종속성이 없어야합니다. 그러한 컴포넌트를 Immutable.JS 객체를 소품으로 전달하는 경우 Immutable.JS에 의존하여 소품의 값을 추출하고 그렇지 않으면 조작합니다.</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">선택기는 Immutable.JS 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;(기능)&lt;/em&gt; : 상점 인핸서. 미들웨어, 시간 여행, 지속성 등과 같은 써드 파티 기능으로 상점을 향상 시키도록 선택적으로 지정할 수 있습니다. Redux와 함께 제공되는 유일한 상점 향상제는 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;(any)&lt;/em&gt; : 초기 상태입니다. 선택적으로 범용 앱의 서버에서 상태를 수화하거나 이전에 직렬화 된 사용자 세션을 복원하도록 지정할 수 있습니다. 당신이 생산 된 경우 &lt;code&gt;reducer&lt;/code&gt; 와 &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; ,이 전달 된 키와 같은 모양으로 일반 객체 여야합니다. 그렇지 않으면 &lt;code&gt;reducer&lt;/code&gt; 가 이해할 수있는 모든 것을 자유롭게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">.babelrc에서 &lt;code&gt;.babelrc&lt;/code&gt; 기능을 사용하도록 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">URL에서 해시를 제거하려면 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">및 실행 &lt;code&gt;npm test&lt;/code&gt; 한 번 실행하거나하는 &lt;code&gt;npm run test:watch&lt;/code&gt; 시험에 모든 파일 변경에.</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">그런 다음 상태를 클라이언트에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators (actionCreators, 디스패치)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">적절한 감속기를 호출하고 슬라이스를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">다음과 같이 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian : redux / react-router / immutable 'smart'컴포넌트를위한 React 데코레이터</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">모든 요청마다 새로운 Redux 스토어 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore (reducer, [preloadedState], [enhancer])</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">각 키가 참조하는 현재 상태 슬라이스에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">리듀서에 의해 리턴 될 가능성이있는 상태 슬라이스에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">규모에는 ~ 500 개의 액션 유형, ~ 400 개의 리듀서 케이스, ~ 150 개의 구성 요소, 5 개의 미들웨어, ~ 200 개의 액션, ~ 2300 개의 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">선택적으로 일부 작업을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">상태를 상점에서 꺼내십시오.</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">키 &lt;code&gt;todos&lt;/code&gt; 과 &lt;code&gt;counter&lt;/code&gt; 각각은 별도의 상태 슬라이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">&lt;code&gt;myTodosReducer&lt;/code&gt; 및 &lt;code&gt;myCounterReducer&lt;/code&gt; 값 은 각각의 키로 식별 된 상태 슬라이스에 각각 작용하는 감속기 함수입니다.</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
