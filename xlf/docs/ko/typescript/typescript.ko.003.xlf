<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">엄격한 널 검사 모드에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값은 모든 유형의 도메인에 &lt;em&gt;있지 않으며&lt;/em&gt; 자신 및 &lt;code&gt;any&lt;/code&gt; 에게만 지정할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 예외는 &lt;code&gt;void&lt;/code&gt; 에 지정할 수도 있습니다 ). 그래서, 반면 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;T | undefined&lt;/code&gt; 는 일반 유형 검사 모드에서 동의어로 간주되며 ( &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 하위 유형으로 간주 되므로 ) 엄격한 유형 검사 모드에서는 서로 다른 유형이며 &lt;code&gt;T | undefined&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 값을 허용 합니다. 동일의 관계를 사실 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;T | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">엄격한 널 검사 모드에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값은 모든 유형의 도메인에 있지 않으며 자신 및 &lt;code&gt;any&lt;/code&gt; 에게만 지정할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 예외는 &lt;code&gt;void&lt;/code&gt; 에 지정할 수도 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">여부를 그 예제에서, 우리는 먼저 확인 &lt;code&gt;x&lt;/code&gt; 가 있었다 &lt;em&gt;하지 &lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; . 확인이 성공하면 &lt;code&gt;||&lt;/code&gt; 단락되고 'if'의 본문이 실행됩니다. 그러나 검사가 성공하지 못하면 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;E.Foo&lt;/code&gt; &lt;em&gt;만&lt;/em&gt; 될 수 있으므로 E.Bar 와 같은지 여부는 알 수 &lt;code&gt;E.Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb5ff5bf0dceac10cc35060c81ee9faad7242ab" translate="yes" xml:space="preserve">
          <source>In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.</source>
          <target state="translated">표준화 이후 20 년 이상 동안 JavaScript는 매우 먼 길을 걸어 왔습니다. 2020 년에는 JavaScript를 서버, 데이터 과학, 심지어 IoT 장치에서 사용할 수 있지만 가장 많이 사용되는 사용 사례 인 웹 브라우저를 기억하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6db5a8c7126c3ff13b89dab79253baece66850d2" translate="yes" xml:space="preserve">
          <source>In the Template section you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.</source>
          <target state="translated">템플릿 섹션에는 새 파일을 작성할 때 유용한 시작점 역할을하는 여러 선언 파일이 있습니다. 구조가 무엇인지 이미 알고 있다면 사이드 바의 d.ts 템플릿 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="548f3708a85b8745e47e7af1b59669e8ecf4cfa7" translate="yes" xml:space="preserve">
          <source>In the above case:</source>
          <target state="translated">위의 경우 :</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; 는 제대로 작동하지만 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; 는 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에 지정되지 않았으므로 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;SelectableControl&lt;/code&gt; 은 private &lt;code&gt;state&lt;/code&gt; 속성을 포함하여 &lt;code&gt;Control&lt;/code&gt; 의 모든 멤버를 포함합니다 . 이후 &lt;code&gt;state&lt;/code&gt; 개인 구성원 인의 후손을 위해에만 가능 &lt;code&gt;Control&lt;/code&gt; 구현하는 &lt;code&gt;SelectableControl&lt;/code&gt; 을 . 이것은의 후손 때문이다 &lt;code&gt;Control&lt;/code&gt; 해야합니다 &lt;code&gt;state&lt;/code&gt; 개인 회원이 개인 회원 호환하기위한 요구 사항입니다 같은 선언에서 유래.</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">위의 예에서 &lt;code&gt;x&lt;/code&gt; 의 모든 선언은 실제로 &lt;em&gt;동일한 &lt;/em&gt; &lt;code&gt;x&lt;/code&gt; 를 참조 하며 이는 완벽하게 유효합니다. 이것은 종종 버그의 원인이됩니다. 다행히, &lt;code&gt;let&lt;/code&gt; 선언 용서로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c61ebd05e2312c5e85ecc6cef6e59dba4f593f68" translate="yes" xml:space="preserve">
          <source>In the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, TypeScript will try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; 에서 가져 오는 경우 TypeScript는 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (및 기타 관련 경로) 에서 확인을 시도합니다. TypeScript 3.1에서 실행할 때. 우리가 가져올 경우 &lt;code&gt;package-name/foo&lt;/code&gt; , 우리가 찾기 위해 노력할 것이다 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; 및 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0ee9dcee21963bf1982f4a5b086175197a8510" translate="yes" xml:space="preserve">
          <source>In the above form, the mixin&amp;rsquo;s have no underlying knowledge of the class which can make it hard to create the design you want.</source>
          <target state="translated">위의 형식에서 mixin은 클래스에 대한 기본 지식이 없으므로 원하는 디자인을 만들기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">위에서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 구조가 다른 방식으로 type 인수를 사용하지 않기 때문에 호환됩니다. 멤버를 &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; 에 추가하여이 예제를 변경하면 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">위에서 &lt;code&gt;baz&lt;/code&gt; 가 잠재적으로 &lt;code&gt;undefined&lt;/code&gt; 가되도록하려면 &lt;code&gt;boolean | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">위의 변수 &lt;code&gt;a&lt;/code&gt; 에는 아직 분기를 선택하지 않은 조건부 유형이 있습니다. 다른 코드 조각이 &lt;code&gt;foo&lt;/code&gt; 를 호출 하면 &lt;code&gt;U&lt;/code&gt; 에서 다른 유형으로 대체 되고 TypeScript는 조건부 유형을 다시 평가하여 실제로 분기를 선택할 수 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">아래 코드에서는 TypeScript에서 믹스 인을 모델링하는 방법을 보여줍니다. 코드가 끝나면 작동 방식을 세분화합니다.</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">위 의 &lt;code&gt;f2&lt;/code&gt; 선언 에서 형식 유추는 유형 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;[string, boolean]&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt; 을 각각 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 에 대해 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="8ab389301f78b38cc120b50ad55981dfdf9ab9b4" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">위의 예 에서 &lt;code&gt;makeObject&lt;/code&gt; 에 대한 인수 의 &lt;code&gt;methods&lt;/code&gt; 개체 에는 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; 이 포함 된 컨텍스트 유형이 있으므로 &lt;code&gt;methods&lt;/code&gt; 개체 내의 메서드 &lt;a href=&quot;functions#this&quot;&gt;에서이&lt;/a&gt; 유형 은 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; . &lt;code&gt;methods&lt;/code&gt; 속성 의 유형이 동시에 메서드 &lt;code&gt;this&lt;/code&gt; 유형에 대한 추론 대상 및 소스 임을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">위의 예 에서 &lt;code&gt;makeObject&lt;/code&gt; 인수 의 &lt;code&gt;methods&lt;/code&gt; 오브젝트 에는 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; 을 포함하는 컨텍스트 유형이 있으므로 &lt;code&gt;methods&lt;/code&gt; 오브젝트 내의 메소드 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; . &lt;code&gt;methods&lt;/code&gt; 속성 의 유형이 동시에 추론 대상 &lt;code&gt;this&lt;/code&gt; 되고 메소드 에서이 유형 의 소스가되는 방법에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;fruit&lt;/code&gt; 및 &lt;code&gt;color&lt;/code&gt; 매개 변수는 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 유형의 새로운 매개 변수와 함께 교차됩니다 . &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 정말 동일하다 &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; 에 해당하는 &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; . 그 불가능한 교차점들 각각은 &lt;code&gt;never&lt;/code&gt; 줄어들지 않으며 , 우리 는 단지 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; 남겨진다 .</target>
        </trans-unit>
        <trans-unit id="a3d9dddab39b8eb943f3877822ffa8bdb3bae451" translate="yes" xml:space="preserve">
          <source>In the first &lt;code&gt;length&lt;/code&gt;, T is not necessary; notice that it&amp;rsquo;s only referenced once, so it&amp;rsquo;s not being used to constrain the type of the return value or other parameters.</source>
          <target state="translated">첫 번째 &lt;code&gt;length&lt;/code&gt; 에서 T는 필요하지 않습니다. 한 번만 참조되므로 반환 값 또는 기타 매개 변수의 유형을 제한하는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">다음 예에서 각 입력 요소는 400ms 지연으로 한 번에 하나씩 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d0896b9003166f205cee791b2a20d447c0e588fb" translate="yes" xml:space="preserve">
          <source>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</source>
          <target state="translated">명확성과 간결성을 위해 핸드북의 주요 내용은 다루는 기능의 모든 가장자리 사례 또는 세부 사항을 탐색하지 않을 것입니다. 참조 문서에서 특정 개념에 대한 자세한 내용을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">마지막 줄에서 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;Greeter&lt;/code&gt; 클래스 의 인스턴스를 만듭니다. 앞에서 정의한 생성자를 호출하여 &lt;code&gt;Greeter&lt;/code&gt; 모양 의 새 객체를 생성 하고 생성자를 실행하여 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">마지막 창에서 &lt;strong&gt;빈&lt;/strong&gt; 템플릿을 선택 하고 &lt;em&gt;만들기&lt;/em&gt; 버튼을 누릅니다</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">그 동안 조건부 각 분기를 해당 대상에 할당 할 수있는 한 다른 대상 유형에 조건부 유형을 할당 할 수 있습니다. 위의 예에서 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; 를 &lt;code&gt;string | number&lt;/code&gt; 조건부 평가하여, 그것은 알려진하는 상관없이 보낸 사람이 될 수 있습니다 &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">가까운 장래에 놀이터 샘플을 새로 고치고 JSX 지원을 추가하고 자동 유형 획득을 연마 할 것입니다. 즉, 개인 편집기에서 얻을 때와 동일한 놀이터에서 동일한 경험을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">프로젝트 루트 &lt;code&gt;proj&lt;/code&gt; 에서 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">프로젝트 루트에서 &lt;code&gt;gulpfile.js&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">모듈 객체의 유형에서 내 보낸 &lt;code&gt;const&lt;/code&gt; 변수는 읽기 전용 속성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">열거 형 객체의 유형에서 열거 형 멤버는 읽기 전용 속성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">이 예제에서 특성 목록은 &lt;code&gt;keyof T&lt;/code&gt; 이고 결과 유형은 &lt;code&gt;T[P]&lt;/code&gt; 의 일부 변형입니다 . 매핑 된 형식을 일반적으로 사용하기에 적합한 템플릿입니다. 이런 종류의 변환은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;동형&lt;/a&gt; 이기 때문에 매핑은 &lt;code&gt;T&lt;/code&gt; 의 속성에만 적용 되고 다른 속성에는 적용 되지 않습니다. 컴파일러는 새로운 속성 수정자를 추가하기 전에 기존의 모든 속성 수정자를 복사 할 수 있다는 것을 알고 있습니다. 예를 들어 &lt;code&gt;Person.name&lt;/code&gt; 이 읽기 전용 인 경우 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 은 읽기 전용이며 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9c7ec405a4a58ac2e2e3c9c60919a90fae57f264" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">이 예에서 속성 목록은 &lt;code&gt;keyof T&lt;/code&gt; 이고 결과 유형은 &lt;code&gt;T[P]&lt;/code&gt; 의 일부 변형입니다 . 이것은 매핑 된 유형의 일반적인 사용을위한 좋은 템플릿입니다. 이는 이러한 종류의 변환이 &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;동형&lt;/a&gt; 이기 때문입니다. 즉 , 매핑이 &lt;code&gt;T&lt;/code&gt; 의 속성에만 적용 되고 다른 속성에는 적용 되지 않습니다. 컴파일러는 새 속성 수정자를 추가하기 전에 기존 속성 수정자를 모두 복사 할 수 있음을 알고 있습니다. 예를 들어 &lt;code&gt;Person.name&lt;/code&gt; 이 읽기 전용이면 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 은 읽기 전용이며 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에 선언 된 변수 &lt;code&gt;a&lt;/code&gt; 를 캡처했습니다 . 것을 어느 시점에서 &lt;code&gt;g&lt;/code&gt; 가 호출되는, 값 &lt;code&gt;a&lt;/code&gt; 값에 연결됩니다 에서 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 가 실행 되면 &lt;code&gt;g&lt;/code&gt; 가 호출 되더라도 &lt;code&gt;a&lt;/code&gt; 에 액세스하고 수정할 수 있습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">이 경우 호출자에게 함수 오버로드를 사용하여 &lt;code&gt;myCoolFunction&lt;/code&gt; 을 호출 할 수있는 방법에 대해 알리려면 TypeScript를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca269f81daa4e288c099aeabd210add3bf701ab7" translate="yes" xml:space="preserve">
          <source>In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code. This pattern can be used to avoid long relative paths within your codebase.</source>
          <target state="translated">이 경우 TypeScript 파일 해석기에 코드를 찾기 위해 여러 사용자 지정 접두사를 지원하도록 지시 할 수 있습니다. 이 패턴은 코드베이스 내에서 긴 상대 경로를 방지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ee66fa54ed1af4b6530c2bbfb39ea8c9308255" translate="yes" xml:space="preserve">
          <source>In this case, you can use a &lt;code&gt;switch&lt;/code&gt; statement to narrow down which type is represented at runtime:</source>
          <target state="translated">이 경우 &lt;code&gt;switch&lt;/code&gt; 문을 사용하여 런타임에 표시되는 유형의 범위를 좁힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">만약이 예에서 &lt;code&gt;someValue&lt;/code&gt; 와는 동일하지 않은 &lt;code&gt;42&lt;/code&gt; 다음 &lt;code&gt;assert&lt;/code&gt; 던 것이다 &lt;code&gt;AssertionError&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">이 예에서 &lt;code&gt;b?&lt;/code&gt; 것을 나타내고 &lt;code&gt;b&lt;/code&gt; 이 될 수 있으므로, 선택적 &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;keepWholeObject&lt;/code&gt; 에는 이제 &lt;code&gt;b&lt;/code&gt; 가 정의되지 않은 경우에도 속성 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 뿐만 아니라 &lt;code&gt;wholeObject&lt;/code&gt; 에 대한 변수 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">이 예에서 &lt;code&gt;greeter1&lt;/code&gt; 은 이전과 유사하게 작동합니다. &lt;code&gt;Greeter&lt;/code&gt; 클래스를 인스턴스화 하고이 객체를 사용합니다. 우리는 전에 본 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">이 예에서 가장 일반적인 유형에는 &lt;code&gt;Animal&lt;/code&gt; , &lt;code&gt;Rhino&lt;/code&gt; , &lt;code&gt;Elephant&lt;/code&gt; 및 &lt;code&gt;Snake&lt;/code&gt; 의 네 가지 후보 세트가 있습니다. 이 중 가장 일반적인 유형 알고리즘으로 &lt;code&gt;Animal&lt;/code&gt; 을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">이 예에서 첫 번째 블록은 다음과 같은 이름 의미를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">이 예에서는 &lt;code&gt;namespace&lt;/code&gt; 선언을 작성할 때까지 네임 스페이스 &lt;code&gt;C&lt;/code&gt; 가 없었 습니다. 네임 스페이스로서의 &lt;code&gt;C&lt;/code&gt; 의 의미 는 클래스에 의해 생성 된 &lt;code&gt;C&lt;/code&gt; 의 값 또는 유형의 의미와 충돌하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">이 예제에는 &lt;code&gt;Animal&lt;/code&gt; 과 &lt;code&gt;Rhino&lt;/code&gt; 가 있으며 &lt;code&gt;Rhino&lt;/code&gt; 는 &lt;code&gt;Animal&lt;/code&gt; 의 하위 클래스입니다 . 또한 모양면에서 &lt;code&gt;Animal&lt;/code&gt; 과 동일하게 보이는 새로운 클래스 &lt;code&gt;Employee&lt;/code&gt; 이 있습니다. 이러한 클래스의 일부 인스턴스를 만든 다음 서로에게 할당하여 어떤 일이 발생하는지 확인합니다. 때문에 &lt;code&gt;Animal&lt;/code&gt; 과 &lt;code&gt;Rhino&lt;/code&gt; 에서 공유 &lt;code&gt;private&lt;/code&gt; 같은 선언에서 그 형태의면 &lt;code&gt;private name: string&lt;/code&gt; 의 &lt;code&gt;Animal&lt;/code&gt; , 그들은 호환됩니다. 그러나 &lt;code&gt;Employee&lt;/code&gt; 의 경우에는 해당되지 않습니다 . 우리 을 할당하려고 할 때 &lt;code&gt;Employee&lt;/code&gt; 에 &lt;code&gt;Animal&lt;/code&gt; 우리는 이러한 유형의 호환되지 않는 오류가 발생합니다. &lt;code&gt;Employee&lt;/code&gt; 에도 &lt;code&gt;name&lt;/code&gt; 이라는 &lt;code&gt;private&lt;/code&gt; 구성원 이 있지만 &lt;code&gt;Animal&lt;/code&gt; 에서 선언 한 구성원 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 모든 유효성 검사기 관련 엔터티를 &lt;code&gt;Validation&lt;/code&gt; 이라는 네임 스페이스로 이동합니다 . 여기서 인터페이스와 클래스가 네임 스페이스 외부에 표시되기를 원하므로 &lt;code&gt;export&lt;/code&gt; 로 시작 합니다. 반대로, 변수 &lt;code&gt;lettersRegexp&lt;/code&gt; 및 &lt;code&gt;numberRegexp&lt;/code&gt; 는 구현 세부 사항이므로 내 보내지 않고 네임 스페이스 외부의 코드에는 표시되지 않습니다. 파일 맨 아래의 테스트 코드에서 네임 스페이스 외부에서 사용될 때 유형의 이름 (예 : &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; )을 규정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">(이 생성 된 코드에서, ENUM은 저장 순방향 것을 목적으로 컴파일 &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ) 및 (후진 &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; 매핑). 다른 열거 형 멤버에 대한 참조는 항상 속성 액세스로 생성되며 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">이 가이드에서는 TypeScript 언어에 대한 기본 지식이 있다고 가정합니다. 아직없는 경우 &lt;a href=&quot;../basic-types&quot;&gt;TypeScript 핸드북&lt;/a&gt; 을 읽고 기본 개념, 특히 유형 및 네임 스페이스에 익숙해 져야합니다.</target>
        </trans-unit>
        <trans-unit id="daba3c5117e7e15297eb31c7463a628f5e08b0ec" translate="yes" xml:space="preserve">
          <source>In this introduction, I assume you know the following:</source>
          <target state="translated">이 소개에서는 다음 사항을 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">이 모드에서 모듈 및 패키지에 대한 참조 (예 : &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문)는 모두 해당 경로가 아닌 심볼릭 링크 파일의 위치를 ​​기준으로 확인됩니다. 심볼릭 링크가 해결됩니다. 보다 구체적인 예를 보려면 &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;Node.js 웹 사이트의 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">이 섹션에서는 네임 스페이스와 모듈을 사용할 때 발생하는 다양한 일반적인 함정과이를 피하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">이 섹션에서는 TypeScript의 형식 유추에 대해 설명합니다. 즉, 유형을 유추하는 위치와 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">이 간단한 예제에서 &lt;code&gt;Keys&lt;/code&gt; 는 하드 코딩 된 속성 이름 목록이며 속성 유형은 항상 &lt;code&gt;boolean&lt;/code&gt; 이므로이 매핑 된 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">이런 식으로 형식 인수가 지정된 제네릭 형식은 제네릭이 아닌 형식처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">전통적인 객체 지향 코드에서는 유형의 계층 구조를 만들어 두 유형을 추상화 할 수 있습니다. 이것은 훨씬 더 명시 적이지만 약간 과잉입니다. &lt;code&gt;padLeft&lt;/code&gt; 의 원래 버전에 대한 좋은 점 중 하나는 프리미티브를 전달할 수 있다는 것입니다. 그것은 사용법이 간단하고 간결하다는 것을 의미했습니다. 이 새로운 접근법은 우리가 이미 다른 곳에 존재하는 함수를 사용하려고 시도해도 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">편집기에서 &lt;code&gt;greeter.ts&lt;/code&gt; 에 다음 JavaScript 코드를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2065108186f788b7e824c4d623ba210ab88b1c4" translate="yes" xml:space="preserve">
          <source>Include - &lt;code&gt;include&lt;/code&gt;</source>
          <target state="translated">포함- &lt;code&gt;include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.json&lt;/code&gt; 확장자로 가져온 모듈을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--allowJs&lt;/code&gt; 와 함께 &lt;code&gt;.js&lt;/code&gt; 파일 포함</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--lib&lt;/code&gt; 와 함께 내장형 선언 포함</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">npm 패키지에 선언 포함</target>
        </trans-unit>
        <trans-unit id="67c5ad4060ac33b6d094ebba765d48e9ee51b0ef" translate="yes" xml:space="preserve">
          <source>Incremental - &lt;code&gt;incremental&lt;/code&gt;</source>
          <target state="translated">증분- &lt;code&gt;incremental&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; 에서 복합 프로젝트에 대한 증분 파일 감시</target>
        </trans-unit>
        <trans-unit id="7deed7a63ea26f03a02053b178171e4c34213f53" translate="yes" xml:space="preserve">
          <source>Incremental typing in JavaScript &lt;a href=&quot;jsdoc-supported-types&quot;&gt;via JSDoc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;jsdoc-supported-types&quot;&gt;JSDoc을 통한&lt;/a&gt; JavaScript의 증분 입력</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">색인 유형 및 색인 서명</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">인덱서 블 타입</target>
        </trans-unit>
        <trans-unit id="0adbe17edc35b59357a465c0c0744f9ea42fd3f6" translate="yes" xml:space="preserve">
          <source>Individual library components</source>
          <target state="translated">개별 라이브러리 구성 요소</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">매핑 된 형식에서 유추</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">유형 유추</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">TypeScript 프로젝트를 초기화하고 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">동적 속성으로 객체를 초기화하는 것은 약간의 부담이 될 수 있습니다. 다음 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="9c7561073b85798bf28e57100cdf96cfe8bdcf3e" translate="yes" xml:space="preserve">
          <source>Inline Source Map - &lt;code&gt;inlineSourceMap&lt;/code&gt;</source>
          <target state="translated">인라인 소스 맵 &lt;code&gt;inlineSourceMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="424e6831576ffef65176196315c29ac68ac4bf21" translate="yes" xml:space="preserve">
          <source>Inline Sources - &lt;code&gt;inlineSources&lt;/code&gt;</source>
          <target state="translated">인라인 소스 &lt;code&gt;inlineSources&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">내부 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; 의 섹션 &lt;code&gt;package.json&lt;/code&gt; 의 파일, 추가 &lt;em&gt;꿀꺽&lt;/em&gt; 와 &lt;em&gt;델을&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">ASP.NET Core 및 TypeScript 설치</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">의존성 설치</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">TypeScript 설치</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 대신 기본이 아닌 &lt;code&gt;object&lt;/code&gt; 유형 ( &lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;TypeScript 2.2에 추가&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="481ebcf06d3a6af9b20dbe32b1d7d942a9bbaeef" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 대신 기본이 아닌 &lt;code&gt;object&lt;/code&gt; 유형을 사용하십시오 ( &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;TypeScript 2.2에 추가됨&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 대신에 &lt;code&gt;padding&lt;/code&gt; 매개 변수에 &lt;em&gt;공용체 유형&lt;/em&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 언어에서 추론 할 수있는 &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; 와 같이 비교적 쓸모없는 유형 대신 TypeScript 3.4의 추론을 통해 &lt;code&gt;newFn&lt;/code&gt; 을 일반화 할 수 있습니다. 새로운 유형은 &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7820345e86f733909d6d0cf768d7afc07da46bf5" translate="yes" xml:space="preserve">
          <source>Instead of importing helpers with &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</source>
          <target state="translated">&lt;a href=&quot;#importHelpers&quot;&gt; &lt;code&gt;importHelpers&lt;/code&gt; &lt;/a&gt; 를 사용하여 도우미를 가져 오는 대신 사용하는 도우미에 대한 전역 범위의 구현을 제공하고 도우미 함수의 방출을 완전히 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">모든 유형의 작업을 수행하는 대신이 함수가 &lt;code&gt;.length&lt;/code&gt; 속성 이있는 모든 유형에서 작동하도록 제한 하려고 합니다. 유형에이 멤버가있는 한 허용하지만 최소한이 멤버가 있어야합니다. 그렇게하려면 T가 무엇인지에 대한 제약 조건으로 요구 사항을 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="56c1302b0e9b5a2d049280773df6dd17a03e760a" translate="yes" xml:space="preserve">
          <source>Instead, use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; 및 &lt;code&gt;symbol&lt;/code&gt; 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">대신에, 우리는 또한 반환되는 것을 나타 내기 위해 그것을 사용할 수있는 방식으로 인수의 유형을 캡처하는 방법이 필요합니다. 여기서는 값이 아닌 유형에서 작동하는 특수한 &lt;em&gt;유형의 변수&lt;/em&gt; 인 &lt;em&gt;type variable&lt;/em&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">대신 유형에 필요한 모든 속성이있는 값을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">대신 클래스의 정적 측면을 직접 사용해야합니다. 이 예제에서는 생성자를 위한 &lt;code&gt;ClockInterface&lt;/code&gt; 와 인스턴스 메소드를위한 &lt;code&gt;ClockConstructor&lt;/code&gt; 두 가지 인터페이스를 정의 합니다. 그런 다음 편의상 전달 된 형식의 인스턴스를 만드는 생성자 함수 &lt;code&gt;createClock&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">빌드 도구와 통합</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">빌드 도구와 통합 : Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">빌드 도구와 통합 : Browserify</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">빌드 도구와 통합 : Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">빌드 툴과 통합 : Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">빌드 도구와 통합 : Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">빌드 도구와 통합 : Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">빌드 도구와 통합 : MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">빌드 도구와 통합 : NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">빌드 도구와 통합 : Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="a018a82309e992e850b9031373cff79ce1cccba4" translate="yes" xml:space="preserve">
          <source>Interested in learning more?</source>
          <target state="translated">자세한 내용을 알고 싶으십니까?</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">클래스 확장 인터페이스</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">인터페이스는 JavaScript 객체가 취할 수있는 광범위한 모양을 설명 할 수 있습니다. 속성이있는 객체를 설명하는 것 외에도 인터페이스는 함수 유형을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">인터페이스는 공개 및 비공개 측면이 아니라 클래스의 공개 측면을 설명합니다. 이렇게하면 클래스를 사용하여 클래스에 클래스 인스턴스의 전용 측면에 대한 특정 유형이 있는지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">인터페이스 대 유형 별명</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">선택적 속성이있는 인터페이스는 다른 인터페이스와 유사하게 작성되며 각 선택적 속성은 &lt;code&gt;?&lt;/code&gt; 선언에서 속성 이름 끝에</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">교차로 유형</target>
        </trans-unit>
        <trans-unit id="084148d39f0e6339840f9abce4a71b7b8a28568e" translate="yes" xml:space="preserve">
          <source>Intersection and Union types are one of the ways in which you can compose types.</source>
          <target state="translated">교차 및 공용체 유형은 유형을 구성 할 수있는 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">교차로 유형</target>
        </trans-unit>
        <trans-unit id="b78d51b88c1d1feb693e6d11fb2eab9417d88d2e" translate="yes" xml:space="preserve">
          <source>Intersection types are closely related to union types, but they are used very differently. An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a type which is all of &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">교차 유형은 공용체 유형과 밀접한 관련이 있지만 매우 다르게 사용됩니다. 교차 유형은 여러 유형을 하나로 결합합니다. 이를 통해 기존 유형을 함께 추가하여 필요한 모든 기능을 갖춘 단일 유형을 얻을 수 있습니다. 예를 들어, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; 은 모두 &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 인 유형입니다 . 즉,이 유형의 개체는 세 가지 유형의 모든 구성원을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="564a9241fc2a9fe2599b22267f67a36231a5fd3e" translate="yes" xml:space="preserve">
          <source>Intersections</source>
          <target state="translated">Intersections</target>
        </trans-unit>
        <trans-unit id="024b4beab6775314e602953c2f94088fe4678bde" translate="yes" xml:space="preserve">
          <source>Intrinsic String Manipulation Types</source>
          <target state="translated">내장 문자열 조작 유형</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">본질적인 요소</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">내장 요소는 특수 인터페이스 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에서 조회 됩니다. 기본적으로이 인터페이스를 지정하지 않으면 모든 것이 진행되고 내장 요소는 유형 검사되지 않습니다. 그러나이 인터페이스 &lt;em&gt;가&lt;/em&gt; 있으면 내장 요소의 이름이 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 인터페이스 의 특성으로 검색 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5929e5c75cee5abeee0333968fe15c20cd3d7eef" translate="yes" xml:space="preserve">
          <source>Intro to the TSConfig Reference</source>
          <target state="translated">TSConfig 참조 소개</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7f426c016099b5f664f1e39e6247678f1b9e5312" translate="yes" xml:space="preserve">
          <source>Introduction to the DOM</source>
          <target state="translated">DOM 소개</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">소개 : 딥 다이브</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">소개 : 선언 파일 찾기 및 설치</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">소개 : 라이브러리 구조</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">소개 : npm에 게시</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">소개 : 섹션</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">소개 : 템플릿</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">소개 :&amp;ldquo;할 일&amp;rdquo;및&amp;ldquo;하지 말 것&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 를 두 번 호출하면 더 많은 시작 시간 오버 헤드가 발생합니다</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">&lt;code&gt;--alwaysStrict&lt;/code&gt; 를 사용 하여 컴파일러를 호출하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; 을 사용 하여 컴파일러 호출</target>
        </trans-unit>
        <trans-unit id="92c7543673d428591b536d245bf2f8a34c3f3bdf" translate="yes" xml:space="preserve">
          <source>Is your build output mostly the same as your source input files? Use &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">빌드 출력이 소스 입력 파일과 거의 동일합니까? &lt;code&gt;tsc&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="8e2b2e48ddaed31be99cbca83c7b264785d54b10" translate="yes" xml:space="preserve">
          <source>Isolated Modules - &lt;code&gt;isolatedModules&lt;/code&gt;</source>
          <target state="translated">절연 모듈- &lt;code&gt;isolatedModules&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="54054e6683cbfd13efd0196ccd3001db60a01e75" translate="yes" xml:space="preserve">
          <source>It also ships with a mapped type &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; that makes all properties &lt;code&gt;readonly&lt;/code&gt;:</source>
          <target state="translated">또한 모든 속성을 &lt;code&gt;readonly&lt;/code&gt; 만드는 매핑 된 유형 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">전역 변수로도 사용할 수 있지만 스크립트 내에서만 사용할 수 있습니다. (스크립트는 가져 오기 또는 내보내기가없는 파일입니다.)</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">간단한 네임 스페이스를 만드는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="683cf85c60231c18d1e9862199f167cc8ac3cdf5" translate="yes" xml:space="preserve">
          <source>It can be tempting to think that the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Object&lt;/code&gt; 유형 이 위에서 권장 한 소문자 버전과 동일 하다고 생각하고 싶을 수 있습니다 . 그러나 이러한 유형은 언어 프리미티브를 참조하지 않으며 거의 ​​유형으로 사용되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b38dbabfa59d50143ee85c5c345800b0f340110b" translate="yes" xml:space="preserve">
          <source>It does not change the behavior of your code, or otherwise change the behavior of TypeScript&amp;rsquo;s checking and emitting process.</source>
          <target state="translated">코드의 동작을 변경하거나 TypeScript의 검사 및 방출 프로세스의 동작을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">이니셜 라이저가 없으며 앞의 열거 형 멤버가 &lt;em&gt;숫자&lt;/em&gt; 상수였습니다. 이 경우 현재 열거 형 멤버의 값은 선행 열거 형 멤버의 값에 1을 더한 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;유창한 스타일의 API&lt;/a&gt; 를 생성하는 메소드에서 현재 객체 (예 : &lt;code&gt;this&lt;/code&gt; ) 를 반환하는 일반적인 패턴 입니다. 예를 들어 다음 &lt;code&gt;BasicCalculator&lt;/code&gt; 모듈을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">상수 열거 형 표현식이 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;Infinity&lt;/code&gt; 로 평가되는 것은 컴파일 시간 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="c6c1d1a64c5c77319ef0ca3b0e9b3ec9e20641bd" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and &lt;strong&gt;we recommended modules over namespaces in modern code&lt;/strong&gt;.</source>
          <target state="translated">Node.js 애플리케이션의 경우 모듈이 기본값이며 &lt;strong&gt;현대 코드에서 네임 스페이스보다 모듈을 권장&lt;/strong&gt; 한다는 점도 주목할 가치가 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">Node.js 응용 프로그램의 경우 모듈이 기본이며 코드를 구성하는 데 권장되는 방법이라는 점도 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">존재하지 않는 파일을 참조하는 것은 오류입니다. 파일 자체에 트리플 슬래시 참조가있는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">너무 많은 인수를 가진 함수를 호출하는 것은 오류라는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">컴파일러는 이러한 변환을 수행하지 &lt;em&gt;않습니다&lt;/em&gt; . 단지 이러한 정보를 사용하여 모듈 가져 오기를 정의 파일로 해결하는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="3789f800d631595c74b86aed0db3fe5327908530" translate="yes" xml:space="preserve">
          <source>It is not a mechanism that &lt;strong&gt;prevents&lt;/strong&gt; a file from being included in the codebase - it simply changes what the &lt;code&gt;include&lt;/code&gt; setting finds.</source>
          <target state="translated">파일이 코드베이스에 포함되는 &lt;strong&gt;것을 방지&lt;/strong&gt; 하는 메커니즘이 아닙니다. 단순히 &lt;code&gt;include&lt;/code&gt; 설정이 찾은 내용을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">일반 유형 매개 변수에 대한 제한 조건 절에서 &lt;code&gt;infer&lt;/code&gt; 선언 을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">클래스 구성 요소의 유형을 정의 할 수 있습니다. 그러나 그렇게하려면 &lt;em&gt;요소 클래스 유형&lt;/em&gt; 과 &lt;em&gt;요소 인스턴스 유형의&lt;/em&gt; 두 가지 새로운 용어를 이해하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">열거 형의 첫 번째 멤버이며 초기화 프로그램이 없으므로 &lt;code&gt;0&lt;/code&gt; 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">npm 패키지에 &lt;a href=&quot;publishing&quot;&gt;Publishing에&lt;/a&gt; 설명 된대로 선언 파일이 이미 포함되어 있으면 해당 &lt;code&gt;@types&lt;/code&gt; 패키지를 다운로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">TypeScript에는 &lt;em&gt;type guard&lt;/em&gt; 라는 것이 있습니다. 타입 가드는 타입을 보장하는 런타임 검사를 수행하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">구현 파일이 테스트 파일을 가져올 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">출력 폴더 이름에 &lt;code&gt;src&lt;/code&gt; 가 나타나지 않으면 &lt;code&gt;test&lt;/code&gt; 와 &lt;code&gt;src&lt;/code&gt; 를 동시에 빌드 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="9c6a38098d06734f39da99f25d9ab37fea049fd8" translate="yes" xml:space="preserve">
          <source>It would be an error to specify &lt;code&gt;rootDir&lt;/code&gt; as &lt;code&gt;core&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;include&lt;/code&gt; as &lt;code&gt;*&lt;/code&gt; because it creates a file (&lt;code&gt;helpers.ts&lt;/code&gt;) that would need to be emitted &lt;em&gt;outside&lt;/em&gt; the &lt;code&gt;outDir&lt;/code&gt; (i.e. &lt;code&gt;../helpers.js&lt;/code&gt;).</source>
          <target state="translated">지정하면 오류가 발생 될 &lt;code&gt;rootDir&lt;/code&gt; 같이 &lt;code&gt;core&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;include&lt;/code&gt; 으로 &lt;code&gt;*&lt;/code&gt; 이 파일 (생성하기 때문에 &lt;code&gt;helpers.ts&lt;/code&gt; 방출 될 필요가있을 것이다) &lt;em&gt;외부 &lt;/em&gt; &lt;code&gt;outDir&lt;/code&gt; (즉 &lt;code&gt;../helpers.js&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="d57b32bfac61e19b63383ba6ca826d555cc838b5" translate="yes" xml:space="preserve">
          <source>It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">한 번 확인을하면 각 지점 내 에서 &lt;code&gt;pet&lt;/code&gt; 의 종류를 알 수 있다면 훨씬 더 좋을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">그것은 이전하는 방법에 액세스하려고하는 것이 일반적입니다 &lt;code&gt;await&lt;/code&gt; 를 -ing 나 &lt;code&gt;.then()&lt;/code&gt; -ing &lt;code&gt;Promise&lt;/code&gt; . 이것은 우리가 더 잘할 수있는 다른 많은 사례 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">또한 TypeScript는 이전 버전의 ECMAScript로 컴파일 할 때 &lt;code&gt;globalThis&lt;/code&gt; 에 대한 참조를 변환하지 않습니다 . 따라서 이미 &lt;code&gt;globalThis&lt;/code&gt; 를 지원하는 상록 브라우저를 대상으로하지 않는 &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;한 적절한 polyfill을&lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">구성을 문서화 할 수있는 것이 좋습니다. &lt;code&gt;tsconfig.json&lt;/code&gt; 은 이제 한 줄 및 여러 줄 주석을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">요소의 범위를 넘어 튜플을 구조화하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">이 상황에서 각 참조 앞에 붙지 않는 것이 중요합니다. &lt;code&gt;D&lt;/code&gt; 의 출력에서 &lt;code&gt;A&lt;/code&gt; 의 사본 두 개로 끝나기 때문에 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일 을 처리하는 다른 로더보다 먼저 awesome-typescript-loader를 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a2ffa790ea2c3349ed046c358aae967ad51e1cec" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that ts-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일 을 처리하는 다른 로더보다 먼저 ts-loader를 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b692de3183276b518dabfb631757e7af1419f734" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that TypeScript uses the same &lt;em&gt;runtime&lt;/em&gt; as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don&amp;rsquo;t limit yourself to TypeScript-specific resources!</source>
          <target state="translated">TypeScript는 JavaScript 와 동일한 &lt;em&gt;런타임&lt;/em&gt; 을 사용 하므로 특정 런타임 동작 (문자열을 숫자로 변환, 경고 표시, 디스크에 파일 쓰기 등)을 수행하는 방법에 대한 모든 리소스는 항상 똑같이 잘 적용됩니다. TypeScript 프로그램. TypeScript 관련 리소스에 국한하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">API가 특정 값에 대해 특정 문자열 세트를 기대하는 것은 드문 일이 아닙니다. 예를 들어, &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;애니메이션&lt;/a&gt; 의 &quot;여유&quot; 를 제어하면서 화면을 가로 질러 요소를 이동할 수있는 UI 라이브러리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b18ceff60d615281a03cf2a9ea16d87dd519931" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible you really &lt;em&gt;did&lt;/em&gt; intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript&amp;rsquo;s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we&amp;rsquo;ll learn about settings you can use to configure how strictly TypeScript checks your code.)</source>
          <target state="translated">그것은 당신이 정말 가능 &lt;em&gt;않았다&lt;/em&gt; 아마 단지 어떻게되는지, 배열에 의해 숫자를 분할하고자하지만, 대부분의 시간,하지만이 프로그래밍 실수입니다. TypeScript의 유형 검사기는 가능한 한 많은 일반적인 오류를 포착하면서 올바른 프로그램을 허용하도록 설계되었습니다. (나중에 TypeScript가 코드를 얼마나 엄격하게 검사하는지 구성하는 데 사용할 수있는 설정에 대해 알아 봅니다.)</target>
        </trans-unit>
        <trans-unit id="c163602d3325175e90ecde073b2e8d099514998d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file, and that circularity between configuration files is not allowed.</source>
          <target state="translated">상속 구성 파일에서 &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 가 기본 구성 파일의 파일을 &lt;em&gt;덮어&lt;/em&gt; 쓰며 구성 파일 간의 순환이 허용되지 않는다는 점에 주목할 가치가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">타입 체커는 이러한 속성들이 어떤 종류의 순서로 오도록 요구할 필요는 없으며 인터페이스에 필요한 속성들이 존재하고 필요한 타입을 가질뿐임을 지적 할 가치가있다.</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">반복자 및 생성기</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">반복자와 생성기</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="7aec719645d59e0338990dc21d17c20ab20b5e3a" translate="yes" xml:space="preserve">
          <source>JS Class extensions</source>
          <target state="translated">JS 클래스 확장</target>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="translated">JS Projects Utilizing TypeScript</target>
        </trans-unit>
        <trans-unit id="cad13379ffbb44dfeef3669b43a6cf7eda0226c2" translate="yes" xml:space="preserve">
          <source>JSDoc Property Modifiers</source>
          <target state="translated">JSDoc 속성 수정 자</target>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="translated">JSDoc Reference</target>
        </trans-unit>
        <trans-unit id="5d193b4e629fd62bb8a4297db587f6b30503894f" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;) to express optionality. e.g.:</source>
          <target state="translated">JSDoc 주석이 달린 함수는이 규칙에서 제외됩니다. 선택성 을 표현 하려면 JSDoc 선택적 매개 변수 구문 ( &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; )을 사용하십시오 . 예 :</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc 어노테이션이있는 기능은이 규칙에서 제외됩니다. JSDoc 선택적 매개 변수 구문을 사용하여 선택 적성을 표현하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">선언을 장식하는 JSDoc 주석은 해당 선언의 유형을 설정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b57ab1e3e810539c8d1ec0a2a10337c1c2186c67" translate="yes" xml:space="preserve">
          <source>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">JSDoc 주석은 선언이 해당 선언의 유형을 설정하는 데 사용되기 전에옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDoc 유형은 유형 정보에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="200185b1255b1a221ca2903c5a111895d54bee5e" translate="yes" xml:space="preserve">
          <source>JSX - &lt;code&gt;jsx&lt;/code&gt;</source>
          <target state="translated">JSX - &lt;code&gt;jsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3a12fc57c5b8ab36078ef438cd9ea85d576a140" translate="yes" xml:space="preserve">
          <source>JSX Factory - &lt;code&gt;jsxFactory&lt;/code&gt;</source>
          <target state="translated">JSX 팩토리 &lt;code&gt;jsxFactory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX를 사용하면 표현식을 중괄호 ( &lt;code&gt;{ }&lt;/code&gt; )로 묶어 태그 사이에 표현식을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSX 요소 이름 및 특성은 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스 에 대해 유효성 검증 됩니다. 프레임 워크에 대한 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스를 정의하려면 [[JSX]] 위키 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX 요소는 이제 형식 인수를 일반 구성 요소에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX는 임베드 가능한 XML 유사 구문입니다. 유효한 JavaScript로 변환되어야하지만 해당 변환의 의미는 구현에 따라 다릅니다. JSX는 React 라이브러리에서 인기를 얻었지만 이후 다른 응용 프로그램을 보았습니다. TypeScript 1.6은 포함, 유형 검사 및 선택적으로 JSX를 JavaScript로 직접 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX 지원</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSX 타입 체크는 예를 들면, JSX 정의 네임 스페이스에 의해 구동된다 &lt;code&gt;JSX.Element&lt;/code&gt; JSX 요소의 유형 및 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 요소 내장한다. TypeScript 2.8 이전에는 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스가 전역 네임 스페이스에 있어야하므로 프로젝트에서 하나만 정의 할 수있었습니다. TypeScript 2.8부터 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스는 &lt;code&gt;jsxNamespace&lt;/code&gt; (예 : &lt;code&gt;React&lt;/code&gt; ) 아래 에서 한 번의 컴파일로 여러 jsx 팩토리를 허용합니다. 이전 버전과의 호환성을 위해 전역 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스는 팩토리 함수에 정의되지 않은 경우 대체로 사용됩니다. 파일 당 &lt;code&gt;@jsx&lt;/code&gt; 와 결합 pragma, 각 파일은 다른 JSX 팩토리를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0a68962be09173771bec34eb689c44a3c96b2537" translate="yes" xml:space="preserve">
          <source>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page &amp;mdash; writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</source>
          <target state="translated">JavaScript (ECMAScript라고도 함)는 브라우저를위한 간단한 스크립팅 언어로 시작되었습니다. 그것이 발명되었을 때, 웹 페이지에 포함 된 짧은 코드 스 니펫에 사용될 것으로 예상되었습니다. 수십 줄 이상의 코드를 작성하는 것은 다소 이례적이었을 것입니다. 이로 인해 초기 웹 브라우저는 이러한 코드를 매우 느리게 실행했습니다. 하지만 시간이 지남에 따라 JS는 점점 더 인기를 얻었고 웹 개발자는이를 사용하여 대화 형 경험을 만들기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="f9d9a3e1ce5dffeacdf5c830a6c6440a69613ddc" translate="yes" xml:space="preserve">
          <source>JavaScript also allows accessing properties which aren&amp;rsquo;t present:</source>
          <target state="translated">JavaScript는 또한 존재하지 않는 속성에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="88b453322efee2df3d69cc86054aa88030b8bd03" translate="yes" xml:space="preserve">
          <source>JavaScript defines 8 built-in types:</source>
          <target state="translated">JavaScript는 8 가지 내장 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="21c885f8940580133691e264e6c024d89b341481" translate="yes" xml:space="preserve">
          <source>JavaScript does have some limited primitives like &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, &lt;code&gt;typeof (new Car())&lt;/code&gt; will be &lt;code&gt;&quot;object&quot;&lt;/code&gt;, not &lt;code&gt;Car&lt;/code&gt; or &lt;code&gt;&quot;Car&quot;&lt;/code&gt;.</source>
          <target state="translated">JavaScript에는 &lt;code&gt;typeof&lt;/code&gt; 및 &lt;code&gt;instanceof&lt;/code&gt; 와 같은 제한된 기본 요소가 있지만 이러한 연산자는 유형이 지워진 출력 코드에 존재하는 값에 대해 여전히 작업하고 있음을 기억하십시오. 예를 들어 &lt;code&gt;typeof (new Car())&lt;/code&gt; 는 &lt;code&gt;Car&lt;/code&gt; 또는 &lt;code&gt;&quot;Car&quot;&lt;/code&gt; 가 아니라 &lt;code&gt;&quot;object&quot;&lt;/code&gt; &quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript에는 ECMAScript 표준의 하나, Node가 이미 (CommonJS), AMD, System.js 등을 지원하는 다양한 모듈 구문 또는 규칙이 있습니다! 대부분의 경우 TypeScript는 기본적으로 ECMAScript 모듈 구문을 사용하여 자동 가져 오기로 기본 설정되며, 이는 컴파일러 설정이 다른 특정 TypeScript 프로젝트 또는 일반 JavaScript가있는 노드 프로젝트에서 부적절 &lt;code&gt;require&lt;/code&gt; 호출이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="98cdb2f49473d8f457b2b983ae7b2e9569316471" translate="yes" xml:space="preserve">
          <source>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type &lt;code&gt;number&lt;/code&gt; and the boxed type &lt;code&gt;Number&lt;/code&gt;. The boxed types are rarely needed, since their methods return primitives.</source>
          <target state="translated">JavaScript에는 프로그래머가 해당 유형과 연관시키는 메소드를 포함하는 기본 유형의 박스형 등가물이 있습니다. TypeScript는이를 기본 유형 &lt;code&gt;number&lt;/code&gt; 와 박스 유형 &lt;code&gt;Number&lt;/code&gt; 간의 차이로 반영합니다 . boxed 형식은 메서드가 기본 형식을 반환하기 때문에 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript는 본질적으로 매우 역동적 인 언어입니다. 단일 JavaScript 함수가 전달 된 인수의 모양에 따라 다른 유형의 객체를 반환하는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3fa9627af8c315eed2d8a18ed7ec36d91039abb7" translate="yes" xml:space="preserve">
          <source>JavaScript projects can use a &lt;code&gt;jsconfig.json&lt;/code&gt; file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.</source>
          <target state="translated">JavaScript 프로젝트는 &lt;code&gt;jsconfig.json&lt;/code&gt; 파일을 대신 사용할 수 있습니다. jsconfig.json 파일은 거의 동일하게 작동하지만 기본적으로 활성화 된 일부 JavaScript 관련 컴파일러 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1195a91c56a7095e67e44a18fe31d7c0292fae" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s equality operator (&lt;code&gt;==&lt;/code&gt;) &lt;em&gt;coerces&lt;/em&gt; its arguments, leading to unexpected behavior:</source>
          <target state="translated">자바 스크립트의 같음 연산자 ( &lt;code&gt;==&lt;/code&gt; ) &lt;em&gt;는&lt;/em&gt; 인수를 &lt;em&gt;강제&lt;/em&gt; 하여 예기치 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="6db5a96d3e3aba783d7007c3a17e6f71e51a7e0e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s modern module syntax is a bit like Haskell&amp;rsquo;s, except that any file with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is implicitly a module:</source>
          <target state="translated">JavaScript의 최신 모듈 구문은 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 가 있는 모든 파일 이 암시 적으로 모듈 이라는 점을 제외하면 Haskell과 약간 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">&quot;최상위 수준에 가까운 내보내기&quot;가 모듈 소비자의 마찰을 줄이는 것처럼 기본 내보내기도 도입됩니다. 모듈의 주요 목적이 하나의 특정 내보내기를 저장하는 것이라면 기본 내보내기로 내보내는 것을 고려해야합니다. 이를 통해 가져 오기와 실제로 가져 오기를 조금 더 쉽게 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">JavaScript에서와 마찬가지로 함수는 함수 본문 외부의 변수를 참조 할 수 있습니다. 그들이 그렇게 할 때, 그들은 이 변수 들을 &lt;em&gt;포착&lt;/em&gt; 한다고 합니다. 이것이 어떻게 작동하는지 (그리고이 기술을 사용할 때의 장단점)을 이해하는 것은이 기사의 범위를 벗어나는 것이지만,이 메커니즘이 어떻게 작동하는지 이해하는 것이 JavaScript 및 TypeScript를 사용하는 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="f568f7b7378d75e427e395efb94692dbc6539719" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JS 파일과 모듈 사이에 일대일 대응이있는 것처럼 TypeScript는 모듈 소스 파일과 생성 된 JS 파일 사이에 일대일 대응이 있습니다. 이로 인한 한 가지 효과는 대상 모듈 시스템에 따라 여러 모듈 소스 파일을 연결할 수 없다는 것입니다. 예를 들어 &lt;code&gt;commonjs&lt;/code&gt; 또는 &lt;code&gt;umd&lt;/code&gt; 를 대상으로하는 동안 &lt;code&gt;outFile&lt;/code&gt; 옵션을 사용할 수 없지만 TypeScript 1.8 이상에서는 &lt;code&gt;amd&lt;/code&gt; 또는 &lt;code&gt;system&lt;/code&gt; 을 대상으로 할 때 &lt;code&gt;outFile&lt;/code&gt; 을 사용할 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;수 &lt;/a&gt;있습니다 .</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JS 파일과 모듈간에 일대일 대응이있는 것처럼 TypeScript는 모듈 소스 파일과 생성 된 JS 파일간에 일대일 대응이 있습니다. 이것의 한 가지 효과는 대상 모듈 시스템에 따라 여러 개의 모듈 소스 파일을 연결할 수 없다는 것입니다. 예를 들어 &lt;code&gt;commonjs&lt;/code&gt; 또는 &lt;code&gt;umd&lt;/code&gt; 를 대상으로하는 동안 &lt;code&gt;outFile&lt;/code&gt; 옵션을 사용할 수 없지만 TypeScript 1.8 이상에서는 &lt;code&gt;amd&lt;/code&gt; 또는 &lt;code&gt;system&lt;/code&gt; 을 대상으로 하는 경우 &lt;code&gt;outFile&lt;/code&gt; 을 사용할 &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;수 &lt;/a&gt;있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ce9925cfd88bf773f747d79c2d2f37e043fb9f" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;for / of&lt;/code&gt;, &lt;code&gt;downlevelIteration&lt;/code&gt; will use &lt;code&gt;Symbol.iterator&lt;/code&gt; (if present) to more accurately emulate ES 6 behavior.</source>
          <target state="translated">단지와 같이 &lt;code&gt;for / of&lt;/code&gt; , &lt;code&gt;downlevelIteration&lt;/code&gt; 는 사용 &lt;code&gt;Symbol.iterator&lt;/code&gt; 더 정확하게 에뮬레이션 ES (6) 행동 (있는 경우)를.</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">인터페이스와 마찬가지로 클래스 자체에 type 매개 변수를 지정하면 클래스의 모든 속성이 동일한 유형으로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">모든 글로벌 네임 스페이스 오염과 마찬가지로, 특히 대규모 응용 프로그램에서 구성 요소 종속성을 식별하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">인터페이스와 마찬가지로 타입 별칭도 일반적 일 수 있습니다. 타입 파라미터를 추가하고 별칭 선언의 오른쪽에서 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">네임 스페이스와 마찬가지로 모듈에는 코드와 선언이 모두 포함될 수 있습니다. 가장 큰 차이점은 모듈 이 종속성을 &lt;em&gt;선언&lt;/em&gt; 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">문자열과 마찬가지로 심볼을 객체 속성의 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">그냥 실행 :</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">있다는 사실을 숙지 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 가 다른과 함께 켜집니다 &lt;code&gt;--strict&lt;/code&gt; 의 프로젝트에 영향을 줄 수있는 모드 플래그. 당신은 설정할 수 있습니다 &lt;code&gt;strictPropertyInitialization&lt;/code&gt; 의 설정을 &lt;code&gt;false&lt;/code&gt; 당신에 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 &lt;code&gt;compilerOptions&lt;/code&gt; 를 , 또는 &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; 명령 행에서이 검사를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">명심하십시오 &lt;code&gt;?.&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 는 &quot;falsy&quot;값 (예 : 빈 문자열, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; ) 에 대해 특수하게 작동하므로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산 과 다르게 작동 하지만 이는 구성의 의도적 인 기능입니다. &lt;code&gt;0&lt;/code&gt; 또는 빈 문자열 과 같은 유효한 데이터를 단락시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">자동 선언은 전역 선언이있는 파일 (모듈로 선언 된 파일이 아닌)을 사용하는 경우에만 중요합니다. 예를 들어 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; 문 을 사용하는 경우 TypeScript는 여전히 &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; 폴더를 통해 &lt;code&gt;foo&lt;/code&gt; 패키지 를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">위와 같은 간단한 코드의 경우 이러한 검사를 &quot;해결&quot;하려고 시도해서는 안됩니다. 메서드가 있고 상태를 유지하는 더 복잡한 개체 리터럴의 경우 이러한 기술을 염두에 두어야하지만 과도한 속성 오류의 대부분은 실제로 버그입니다. 즉, 옵션 백과 같은 속성에 대한 초과 속성 검사 문제가 발생하면 일부 유형 선언을 수정해야 할 수도 있습니다. 이 경우, &lt;code&gt;createSquare&lt;/code&gt; 에 &lt;code&gt;color&lt;/code&gt; 또는 &lt;code&gt;colour&lt;/code&gt; 속성이 있는 객체 를 전달해도 괜찮다면 SquareConfig 정의를 &lt;code&gt;SquareConfig&lt;/code&gt; 하여 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">비동기 반복자에 대한 지원 은 런타임에 존재 하는 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 에 대한 지원에 의존 합니다. 간단한 목적을 위해 다음과 같이 간단 할 수있는 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 를 polyfill해야 할 수도 있습니다. &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">문자열 열거 형 멤버 &lt;em&gt;는&lt;/em&gt; 리버스 매핑을 전혀 생성 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">화면을 지우지 않고 오래된 콘솔 출력을 시계 모드로 유지</target>
        </trans-unit>
        <trans-unit id="652c3d36f013f3eb41d356a2dc9496bad6b87cd2" translate="yes" xml:space="preserve">
          <source>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</source>
          <target state="translated">JavaScript와 동일한 런타임 동작을 유지하는 것은 TypeScript의 기본 약속입니다. 이는 프로그램 작동을 중지시킬 수있는 미묘한 차이에 대해 걱정하지 않고 두 언어간에 쉽게 전환 할 수 있음을 의미하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">주요 컨셉</target>
        </trans-unit>
        <trans-unit id="e3f555e673324c6ef7fc096a52a9695768dbceba" translate="yes" xml:space="preserve">
          <source>Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</source>
          <target state="translated">Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842ec99d82ed307bd84f2310114874cbd9666b4e" translate="yes" xml:space="preserve">
          <source>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</source>
          <target state="translated">레이블은 JavaScript에서 매우 드물며 일반적으로 객체 리터럴을 작성하려는 시도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3366a00a2d7b488f6edaccf084d0f236fe293734" translate="yes" xml:space="preserve">
          <source>Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.</source>
          <target state="translated">언어 서비스 플러그인은 기존 TypeScript 파일을 기반으로 사용자에게 추가 정보를 제공하는 방법입니다. TypeScript와 편집기 간의 기존 메시지를 향상 시키거나 자체 오류 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">마지막으로, 우리를 위해 믹싱을 수행 할 도우미 함수를 만듭니다. 그러면 각 믹스 인의 속성이 실행되고 믹스 인의 대상으로 복사되어 독립형 속성이 해당 구현으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">프로젝트 배치</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">상대 경로는 중요하지 않기 때문에 &lt;code&gt;outFile&lt;/code&gt; 을 사용한 컴파일 레이아웃 이 더 유연합니다. 명심해야 할 한 가지는 일반적으로 &quot;마지막&quot;프로젝트까지 &lt;code&gt;prepend&lt;/code&gt; 사용하지 않을 것입니다. 이렇게하면 빌드 시간이 향상되고 특정 빌드에 필요한 I / O 양이 줄어 듭니다. TypeScript 리포지토리 자체는 여기서 좋은 참고 자료입니다. 우리는 &quot;라이브러리&quot;프로젝트와 &quot;엔드 포인트&quot;프로젝트가 있습니다. &quot;종료점&quot;프로젝트는 가능한 작게 유지하고 필요한 라이브러리 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a8ce8ab803d2f69beb12ecc965c63513d9c144ec" translate="yes" xml:space="preserve">
          <source>Learn how to use a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt; 파일 사용 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="f574e7a40077551e582b33afc9de1c41b4ea1f26" translate="yes" xml:space="preserve">
          <source>Learn how to work in an &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild project&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild 프로젝트&lt;/a&gt; 에서 작업하는 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="translated">Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</target>
        </trans-unit>
        <trans-unit id="c1f5cb90f300e2c9d89b461fd1882c4957ea2a20" translate="yes" xml:space="preserve">
          <source>Learning JavaScript and TypeScript</source>
          <target state="translated">JavaScript 및 TypeScript 학습</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;this&lt;/code&gt; 사용하는 방법을 배우는 것은 통과 의례입니다. TypeScript는 JavaScript의 상위 집합이므로 TypeScript 개발자는 &lt;code&gt;this&lt;/code&gt; 를 사용 하는 방법과 올바르게 사용되지 않을 때 확인하는 방법을 배워야 합니다. 다행히, 타이프 라이터는 잘못 사용 잡을 수 있도록 &lt;code&gt;this&lt;/code&gt; 기술의 부부와 함께. JavaScript에서 &lt;code&gt;this&lt;/code&gt; 어떻게 작동 하는지 배우 려면 먼저 Yehuda Katz의 &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;JavaScript 함수 호출 이해 및&amp;ldquo;this&amp;rdquo;를&lt;/a&gt; 읽으십시오 . 예후의 문서의 내부 동작 설명 &lt;code&gt;this&lt;/code&gt; 우리가 여기에 기초를 다룰 것이다, 그래서 아주 잘.</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">위의 예에 &lt;code&gt;Card&lt;/code&gt; 와 &lt;code&gt;Deck&lt;/code&gt; 인터페이스를 추가 하여 유형을보다 명확하고 재사용하기 쉽게하자.</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">이전의 간단한 예제에 유형을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 과 &lt;code&gt;set&lt;/code&gt; 을 사용하도록 간단한 클래스를 변환 해 봅시다 . 먼저, 게터와 세터가없는 예제부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">샘플을 더 개발해 봅시다. 여기서 firstName 및 lastName 필드가있는 객체를 설명하는 인터페이스를 사용합니다. TypeScript에서 내부 구조가 호환되는 경우 두 가지 유형이 호환됩니다. 이를 통해 명시적인 &lt;code&gt;implements&lt;/code&gt; 조항 없이 인터페이스에 필요한 형태를 갖도록 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">TypeScript를 사용하여 간단한 웹 응용 프로그램을 작성하여 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="31f50512e5bac716ad2127f4d6b19108bf103d8e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for a version of &lt;code&gt;padLeft&lt;/code&gt; which uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">돌아가서 공용체 유형을 사용 하는 &lt;code&gt;padLeft&lt;/code&gt; 버전에 대한 코드를 작성해 보겠습니다 . 다음과 같이 유형 술어로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">돌아가서 결합 유형을 사용 하는 &lt;code&gt;padLeft&lt;/code&gt; 버전의 코드를 작성해 봅시다 . 다음과 같이 유형 술어로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">상당히 정상적인 프로그램을 살펴보고 프로젝트 참조가 프로그램을 더 잘 구성하는 데 어떻게 도움이 될 수 있는지 봅시다. 두 개의 모듈 ( &lt;code&gt;converter&lt;/code&gt; 및 &lt;code&gt;units&lt;/code&gt; )과 각각에 해당하는 테스트 파일 이있는 프로젝트가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">이것이 실제로 어떻게 작동하는지 더 잘 알기위한 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">이 차이점을 보여주기 위해 예제를 약간 수정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 파일에 대한 의존성으로 선언 파일과 함께 React 및 React-DOM을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">이제 더 복잡한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">실제로이 함수가 &lt;code&gt;T&lt;/code&gt; 가 아닌 &lt;code&gt;T&lt;/code&gt; 의 배열에서 직접 작동하도록 의도했다고 가정 해 봅시다 . 우리는 배열을 사용하고 있기 때문에 &lt;code&gt;.length&lt;/code&gt; 멤버를 사용할 수 있어야합니다. 다른 유형의 배열을 만드는 것처럼 이것을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typescript&lt;/code&gt; 모듈 을 사용하는 샘플 응용 프로그램이 있다고 가정 해 봅시다 . &lt;code&gt;app.ts&lt;/code&gt; 는 &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; 같은 가져 오기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">모듈 파일 &lt;code&gt;foo.d.ts&lt;/code&gt; 를 작성했다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">이것을 비계로 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">이것이 어떻게 사용될 수 있는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">새로운 디렉토리로 시작하자. 우리는 지금 이름을 &lt;code&gt;proj&lt;/code&gt; 로 지정 하지만 원하는대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">이 페이지 전체에서 예제로 사용할 프로그램으로 시작하겠습니다. 우리는 웹 페이지의 폼에서 사용자 입력을 확인하거나 외부 제공 데이터 파일의 형식을 확인하기 위해 작성할 수있는 간단한 문자열 유효성 검사기 세트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">간단한 클래스 기반 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">가장 간단한 매핑 유형과 그 부분을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">그것이 무엇을 의미하는지 잠시 생각해 봅시다. &lt;code&gt;setTimeout&lt;/code&gt; 은 몇 밀리 초 후에 함수를 실행 &lt;em&gt;하지만 &lt;/em&gt; &lt;code&gt;for&lt;/code&gt; 루프가 실행을 중지 한 후에 &lt;em&gt;만&lt;/em&gt; 실행됩니다. &lt;code&gt;for&lt;/code&gt; 루프가 실행을 중지 할 때까지 &lt;code&gt;i&lt;/code&gt; 값 은 &lt;code&gt;10&lt;/code&gt; 입니다. 주어진 함수가 호출 될 때마다 &lt;code&gt;10&lt;/code&gt; 을 출력합니다 !</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 기능을 이전부터 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Hello World 프로그램을 작성해 봅시다. 에서 &lt;code&gt;src&lt;/code&gt; , 파일 생성 &lt;code&gt;main.ts&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">React를 사용하여 첫 번째 TypeScript 파일을 작성해 봅시다. 먼저,라는 이름의 파일 생성 &lt;code&gt;Hello.tsx&lt;/code&gt; 에 &lt;code&gt;src/components&lt;/code&gt; 및 다음 쓰기 :</target>
        </trans-unit>
        <trans-unit id="aae2739f68fb37ce086c5c2093758c62b36667b3" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;#app&lt;/code&gt; 요소에 &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; 요소를 추가하는 TypeScript 스크립트를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a7305992657ab0909fb4eb83c394c6114c9f6b07" translate="yes" xml:space="preserve">
          <source>Lets you set a base directory to resolve non-absolute module names.</source>
          <target state="translated">절대적이지 않은 모듈 이름을 확인하기 위해 기본 디렉토리를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="0282b6f4a590ade8d83152438864b31e1ed6a0e7" translate="yes" xml:space="preserve">
          <source>Lib - &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="translated">Lib - &lt;code&gt;lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">라이브러리는 &lt;code&gt;this&lt;/code&gt; 매개 변수를 사용 하여 콜백이 호출되는 방법을 선언 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">도서관 구조</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">라이브러리 구조 : 소비 종속성</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">라이브러리 구조 : 글로벌 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">라이브러리 구조 : 모듈에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">라이브러리 구조 : UMD 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">라이브러리 구조 : 글로벌 라이브러리</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">라이브러리 구조 : 글로벌 플러그인</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">라이브러리 구조 : 전역 수정 모듈</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">라이브러리 구조 : 라이브러리 종류 식별</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">라이브러리 구조 : 라이브러리 파일 레이아웃</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">라이브러리 구조 : 모듈 식 라이브러리</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">라이브러리 구조 : 모듈 플러그인 또는 UMD 플러그인</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">라이브러리 구조 : 이름 충돌 방지</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">라이브러리 구조 : 모듈 플러그인에 대한 ES6의 영향</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">라이브러리 구조 : UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">라이브러리 파일 레이아웃</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">배열 파괴와 마찬가지로 선언없이 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">클래스와 마찬가지로 인터페이스도 서로 확장 될 수 있습니다. 이를 통해 한 인터페이스의 멤버를 다른 인터페이스로 복사 할 수 있으므로 인터페이스를 재사용 가능한 구성 요소로 분리하는 방법에있어 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7d787f38e64660d964087ea17b902351795b7ef8" translate="yes" xml:space="preserve">
          <source>Like most C-descended languages, TypeScript requires declaration of type parameters:</source>
          <target state="translated">대부분의 C 종속 언어와 마찬가지로 TypeScript에는 유형 매개 변수의 선언이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">다른 특수 JS 검사 동작과 마찬가지로이 동작은 변수에 JSDoc 유형을 지정하여 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">앞에서 언급했듯이 변환 후 오류 메시지가 나타나는 것은 예기치 않은 일이 아닙니다. 중요한 것은 실제로 이들을 통해 하나씩 차례로 가서 오류를 처리하는 방법을 결정하는 것입니다. 종종 이것들은 합법적 인 버그 일 것입니다. 그러나 때때로 TypeScript에 대해 조금 더 잘하려고하는 것을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">마찬가지로 함수의 반환 유형에 대해서도 :</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">마찬가지로, 반 변형 위치에서 동일한 유형 변수에 대한 여러 후보는 교집합 유형을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="17904ff532be036b7cb87941e7bed2e100c68152" translate="yes" xml:space="preserve">
          <source>Linter Checks</source>
          <target state="translated">린터 체크</target>
        </trans-unit>
        <trans-unit id="885980150a8aa23ee2581fde57cdd77e524c220a" translate="yes" xml:space="preserve">
          <source>List Emitted Files - &lt;code&gt;listEmittedFiles&lt;/code&gt;</source>
          <target state="translated">내 보낸 파일 나열 &lt;code&gt;listEmittedFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef72f198033a01dd1518070e6ebb3e26bd88d5da" translate="yes" xml:space="preserve">
          <source>List Files - &lt;code&gt;listFiles&lt;/code&gt;</source>
          <target state="translated">파일 나열 &lt;code&gt;listFiles&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">의 목록</target>
        </trans-unit>
        <trans-unit id="0a9f639b79fa294ae337e3e6ef448a4796481e4d" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">유형 정의를 포함 할 폴더 목록입니다. 자세한 내용은 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots 및 &amp;mdash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">유형 정의를 포함 할 폴더 목록. 자세한 내용은 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots 및 &amp;ndash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc93386b00a8c2f17516b547e96b3b9822dd074a" translate="yes" xml:space="preserve">
          <source>List of language service plugins to run inside the editor.</source>
          <target state="translated">편집기 내에서 실행할 언어 서비스 플러그인 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">컴파일에 포함 할 라이브러리 파일 목록.</target>
        </trans-unit>
        <trans-unit id="9230df08537df807ad2117d7fc0d39c84158a446" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="translated">포함 할 유형 정의의 이름 목록입니다. 자세한 내용은 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots 및 &amp;mdash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">포함 할 유형 정의의 이름 목록입니다. 자세한 내용은 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots 및 &amp;ndash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">받는 사람의 상대 위치에 모듈 이름에 대한 경로 매핑 항목의 목록 &lt;code&gt;baseUrl&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de64a9e9a2fea78c8d6ba63c5e5b1387423f2076" translate="yes" xml:space="preserve">
          <source>Literal Narrowing</source>
          <target state="translated">리터럴 좁히기</target>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="translated">리터럴 타입</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">명시 적 유형 주석을 통해 리터럴 유형 확장을 제어 할 수 있습니다. 구체적으로, 리터럴 타입의 표현식이 타입 어노테이션이없는 const 위치에 대해 유추 될 때, 그 &lt;code&gt;const&lt;/code&gt; 변수는 확장 된 리터럴 타입을 유추합니다. 그러나 &lt;code&gt;const&lt;/code&gt; 위치에 명시적인 리터럴 형식 주석이 있으면 &lt;code&gt;const&lt;/code&gt; 변수는 확장되지 않은 리터럴 형식을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">npm 패키지에서 유형로드</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">로컬 및 가져온 형식 선언이 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">이제 로컬 클래스, 인터페이스, 열거 형 및 유형 별칭 선언이 함수 선언 내에 나타날 수 있습니다. 지역 유형은 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 로 선언 된 변수와 유사한 블록 범위 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">지역 유형 선언</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">로컬 형식은 둘러싸는 형식 매개 변수를 참조 할 수 있으며 로컬 클래스와 인터페이스 자체는 일반적 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">명령 줄에서 현지화 된 진단</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">로컬 범위의 JSX 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="f24374818cfbd2c002fceb8b97034ee88dd96257" translate="yes" xml:space="preserve">
          <source>Location of default .d.ts</source>
          <target state="translated">기본 .d.ts의 위치</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">첫 번째 localhost 폴더를 찾은 다음 scripts / app.ts를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">당신의 봐 &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; 파일. MSBuild XML 태그와 &lt;code&gt;tsc&lt;/code&gt; 컴파일러 옵션 사이의 권위있는 매핑 이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild 속성 이름</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">&lt;code&gt;gulp&lt;/code&gt; 를 실행 한 다음 노드에서 테스트 하여 모듈이 작동하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">자세한 정보 는 &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;소비 종속성&lt;/a&gt; 섹션 을 다시 방문 하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">많은 JavaScript 개발자는이 동작에 대해 친숙하지만 친숙한 사용자는 아닙니다. 대부분의 사람들은 출력이</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">많은 번 &lt;code&gt;esnext&lt;/code&gt; 는 이러한 &lt;code&gt;import&lt;/code&gt; 표현식을 기반으로 출력 번들 자동 분할을 지원 하므로 esnext 모듈 대상 과 함께이 새로운 기능을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">선언 파일의 많은 일반적인 실수는 쉽게 피할 수 있습니다. &lt;a href=&quot;do-s-and-don-ts&quot;&gt;하는 것과하지 않는&lt;/a&gt; 섹션을 식별 일반적인 오류는이를 감지하는 방법 및이를 해결하는 방법을 설명합니다. 일반적인 실수를 피하기 위해이 섹션을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 와 같이 널리 사용되는 많은 Node.js 라이브러리가 모듈 제품군에 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Express와 같은 널리 사용되는 많은 라이브러리는 가져올 때 호출 가능한 함수로 자신을 노출시킵니다. 예를 들어, 일반적인 Express 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">우리는 기본 라이브러리의 예제 만 가지고있을 때 선언 파일을 작성해야하는 경우가 많습니다. &lt;a href=&quot;by-example&quot;&gt;으로 예&lt;/a&gt; 섹션 쇼 많은 일반적인 API 패턴과 방법을 그들 각각에 대한 선언을 작성하는 방법. 이 안내서는 TypeScript의 모든 언어 구성에 아직 익숙하지 않은 TypeScript 초보자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="e04dbd57e91d78d0c5bec01a4fe02f73a4ba1540" translate="yes" xml:space="preserve">
          <source>Map Root - &lt;code&gt;mapRoot&lt;/code&gt;</source>
          <target state="translated">맵 루트 &lt;code&gt;mapRoot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">매핑 된 형식은 리터럴 형식을 통합하고 새 개체 형식에 대한 속성 집합을 계산하여 생성됩니다. 그들은 &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;파이썬에서 목록 이해&lt;/a&gt; 와 같지만 목록에서 새로운 요소를 생성하는 대신 유형으로 새로운 속성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">튜플 및 배열의 ​​매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">매핑 된 유형은 &lt;code&gt;readonly&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 수정자를 맵핑 된 특성에 대한 수정 자이지만 수정자를 &lt;em&gt;제거&lt;/em&gt; 하는 기능을 지원하지 않았습니다 . 기본적으로 기본 형식의 수정자를 유지하는 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;동형 매핑 형식&lt;/em&gt;&lt;/a&gt; 이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">어울리는 행동</target>
        </trans-unit>
        <trans-unit id="e877b2873e30b35f125ca0ad5fb9dc583519caa0" translate="yes" xml:space="preserve">
          <source>Max Node Module JS Depth - &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</source>
          <target state="translated">최대 노드 모듈 JS 깊이 &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6746fd6ef4bdedacc9e255f7e5c953f3f9081507" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some experienced JavaScript developers, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">경험이 많은 자바 스크립트 개발자에게는 쉽게 알아 차릴 수 있었지만, 내부 &lt;code&gt;for&lt;/code&gt; 루프는 &lt;code&gt;i&lt;/code&gt; 가 동일한 함수 범위 변수를 참조하기 때문에 실수로 변수 &lt;code&gt;i&lt;/code&gt; 를 덮어 쓰게됩니다 . 숙련 된 개발자가 지금까지 알고 있듯이 유사한 종류의 버그가 코드 검토를 통해 빠져 나가며 끝없는 좌절의 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">어쩌면 일부를 알아내는 것이 쉽지만 내부 &lt;code&gt;for&lt;/code&gt; -loop는 실수로 변수 &lt;code&gt;i&lt;/code&gt; 를 덮어 씁니다. 왜냐하면 &lt;code&gt;i&lt;/code&gt; 는 동일한 함수 범위 변수를 참조하기 때문 입니다. 지금까지 숙련 된 개발자가 알고 있듯이 유사한 종류의 버그는 코드 검토 과정을 거칠며 끝없는 좌절의 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">인터페이스 병합</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">클래스와 네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">클래스, 함수 및 열거와 네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">앰비언트 클래스 및 인터페이스 선언 병합</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">메소드 데코레이터</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">추상으로 표시된 추상 클래스 내의 메소드는 구현을 포함하지 않으며 파생 클래스에서 구현되어야합니다. 추상 메소드는 인터페이스 메소드와 유사한 구문을 공유합니다. 둘 다 메소드 본문을 포함하지 않고 메소드의 서명을 정의합니다. 그러나 추상 메소드는 &lt;code&gt;abstract&lt;/code&gt; 키워드를 포함해야하며 선택적으로 액세스 수정자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">JavaScript에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">JavaScript에서 마이그레이션 : 초기 이점</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">JavaScript에서 마이그레이션 :보다 엄격한 검사</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">JavaScript에서 마이그레이션 : Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">JavaScript에서 마이그레이션 : 빌드 도구와 통합</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">JavaScript에서 마이그레이션 : TypeScript 파일로 이동</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">JavaScript에서 마이그레이션 : 디렉토리 설정</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">JavaScript에서 마이그레이션 : Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">JavaScript에서 마이그레이션 : 오류 제거</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">JavaScript에서 마이그레이션 : 구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">최소 프로젝트</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Mixin 클래스는 type 매개 변수의 제약 조건에서 구문 서명 반환 형식을 지정하여 혼합 할 수있는 클래스 유형을 제한 할 수 있습니다. 예를 들어, 다음 &lt;code&gt;WithLocation&lt;/code&gt; 의 기능을 구현하는 추가 서브 클래스 공장 &lt;code&gt;getLocation&lt;/code&gt; 어떤 클래스 방법을 만족하는 &lt;code&gt;Point&lt;/code&gt; (즉 갖는 인터페이스 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 형의 특성 &lt;code&gt;number&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">믹스 인 샘플</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="bf3760256feac6cc46ec45ef674425285cde51d6" translate="yes" xml:space="preserve">
          <source>Modern browsers support all ES6 features, so &lt;code&gt;ES6&lt;/code&gt; is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.</source>
          <target state="translated">최신 브라우저는 모든 ES6 기능을 지원하므로 &lt;code&gt;ES6&lt;/code&gt; 가 좋은 선택입니다. 코드가 이전 환경에 배포 된 경우 더 낮은 대상을 설정하거나 코드가 최신 환경에서 실행되도록 보장되는 경우 더 높은 대상을 설정하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b8e599868465369a62573e28c7d5b2c17c8067" translate="yes" xml:space="preserve">
          <source>Modify the html by removing one of the &lt;code&gt;p&lt;/code&gt; tags, but keep the text.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 태그 중 하나를 제거하여 html을 수정 하되 텍스트는 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">모듈 식 라이브러리</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">모듈 식 라이브러리는 일반적으로 다음 중 일부를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="680e2cdf724785f8d2fb8c99fb4ac60b980c1748" translate="yes" xml:space="preserve">
          <source>Module - &lt;code&gt;module&lt;/code&gt;</source>
          <target state="translated">모듈- &lt;code&gt;module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">모듈 확대</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">모듈 확인</target>
        </trans-unit>
        <trans-unit id="3f1f355f5558be61bf0295855b4e35d7e9e193c7" translate="yes" xml:space="preserve">
          <source>Module Resolution - &lt;code&gt;moduleResolution&lt;/code&gt;</source>
          <target state="translated">모듈 확인 &lt;code&gt;moduleResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">모듈 확인 전략</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 확장자를 허용하는 모듈 식별자</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">모듈 가져 오기는 모듈 참조가 상대적인지 아닌지에 따라 다르게 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">SystemJS와 같은 모듈 로더는 CommonJS 모듈을 랩핑 한 다음 &lt;code&gt;default&lt;/code&gt; ES6 가져 오기 로 노출 합니다. 이는 로더에 따라 모듈 모양이 다르기 때문에 모듈의 SystemJS와 CommonJS 구현간에 정의 파일을 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">모듈 해상도 향상 : BaseUrl, 경로 매핑, rootDirs 및 추적</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;'NodeJs'를&lt;/strong&gt; 사용하여 모듈 분석 종류를 지정하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="translated">모듈 시스템</target>
        </trans-unit>
        <trans-unit id="0e1df43e7e9f83fc7173a7334ad19fcc3cc8e8bc" translate="yes" xml:space="preserve">
          <source>Module: Class</source>
          <target state="translated">모듈 : 클래스</target>
        </trans-unit>
        <trans-unit id="f261737e777673d28880af66138654486e39e3bc" translate="yes" xml:space="preserve">
          <source>Module: Function</source>
          <target state="translated">모듈 : 기능</target>
        </trans-unit>
        <trans-unit id="3b2f8f319a1e5fc06c98c20b985a907aed2cafd5" translate="yes" xml:space="preserve">
          <source>Module: Plugin</source>
          <target state="translated">모듈 : 플러그인</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="48e09f525757a351dfe7b299e6750c6d122d7d38" translate="yes" xml:space="preserve">
          <source>Modules .d.ts</source>
          <target state="translated">모듈 .d.ts</target>
        </trans-unit>
        <trans-unit id="12d8406349015ac16eed554df9f310ef31446573" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">모듈은 또한 모듈 로더 (예 : CommonJs / Require.js) 또는 ES 모듈을 지원하는 런타임에 대한 종속성을 갖습니다. 모듈은 더 나은 코드 재사용, 더 강력한 격리 및 번들링을위한 더 나은 도구 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">모듈은 또한 모듈 로더 (예 : CommonJs / Require.js)에 종속됩니다. 소규모 JS 애플리케이션의 경우 이것이 최적이 아닐 수 있지만 대규모 애플리케이션의 경우 비용은 장기적인 모듈성 및 유지 보수성 이점과 함께 제공됩니다. 모듈은 더 나은 코드 재사용, 강력한 격리 및 번들링을위한 더 나은 툴링 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">모듈은 선언적입니다. 모듈 간의 관계는 파일 레벨에서 가져 오기 및 내보내기 측면에서 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">모듈은 전역 범위가 아닌 자체 범위 내에서 실행됩니다. 이는 모듈에 선언 된 변수, 함수, 클래스 등이 &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; 양식&lt;/a&gt; 중 하나를 사용하여 명시 적으로 내 보내지 않는 한 모듈 외부에서 볼 수 없음을 의미 합니다 . 반대로, 다른 모듈에서 내 보낸 변수, 함수, 클래스, 인터페이스 등을 사용하려면 &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; 양식&lt;/a&gt; 중 하나를 사용하여 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">모듈은 이제 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 방출됩니다 . 프롤로그</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">엄격 모드에서는 모듈이 자동으로 구문 분석됩니다. 비 플래그 코드에는 새로운 플래그가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="eb465684cf64b809ea4e18738ce52c8fd9a32f30" translate="yes" xml:space="preserve">
          <source>Modules can contain both code and declarations.</source>
          <target state="translated">모듈은 코드와 선언을 모두 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">모듈은 다른 모듈에서 선언 된 유형을 가져올 수 있습니다. 그러나 비 모듈 전역 스크립트는 모듈에 선언 된 유형에 액세스 할 수 없습니다. &lt;code&gt;import&lt;/code&gt; 유형을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">모듈은 모듈 로더를 사용하여 서로 가져옵니다. 런타임시 모듈 로더는 모듈을 실행하기 전에 모듈의 모든 종속성을 찾아 실행해야합니다. JavaScript에 사용되는 잘 알려진 모듈 로더는 &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; 모듈 용 Node.js의 로더 이며 웹 응용 프로그램의 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; 모듈 용 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; 로더입니다 .</target>
        </trans-unit>
        <trans-unit id="252a052c9420d6ecb6b140e66b5a6e193c6c9859" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">모듈은 모듈 로더를 사용하여 서로를 가져옵니다. 런타임시 모듈 로더는 모듈을 실행하기 전에 모듈의 모든 종속성을 찾아서 실행합니다. JavaScript에서 사용되는 잘 알려진 모듈 로더는 &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; 모듈 용 Node.js 로더 와 웹 애플리케이션의 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; 모듈 용 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; 로더입니다 .</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">모듈은 항상 ES6에 따라 엄격 모드로 구문 분석되었지만 ES6 이외의 대상의 경우 생성 된 코드에서이를 고려하지 않았습니다. TypeScript 1.8부터는 방출 모듈이 항상 엄격 모드입니다. TS는 컴파일 타임에 가장 엄격한 모드 오류를 오류로 간주하므로 대부분의 코드에서 눈에 띄는 변화가 없어야하지만 TS 코드에서 런타임에 자동으로 실패하는 &lt;code&gt;NaN&lt;/code&gt; 할당과 같은 일부 는 이제 크게 들립니다. 불합격. 엄격 모드와 엄격하지 않은 모드의 차이점에 대한 자세한 목록은 엄격 모드 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN 아티클&lt;/a&gt; 을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">보다 정확한 어레이 확산</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">MSBuild 컴파일러 옵션 정의에 대한 자세한 내용 : &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild 프로젝트에서 컴파일러 옵션 설정&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">자세한 내용은에서 찾을 수 있습니다 &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;패키지 관리자 대화 상자&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;사용하여 야간 NuGet으로 구축&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;Sublime Text 용 TypeScript 플러그인 설치 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">더 자세한 내용은, 당신은 할 수 있습니다 &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;제안에 읽어&lt;/a&gt; 하고 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;원래의 풀 요청을 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="752dbfdfe70e9a653727ad54bd026e4e1adbb672" translate="yes" xml:space="preserve">
          <source>More of a gotcha than a constraint. The class expression pattern creates singletons, so they can&amp;rsquo;t be mapped at the type system to support different variable types.</source>
          <target state="translated">제약보다 더 많은 문제가 있습니다. 클래스 표현식 패턴은 싱글 톤을 생성하므로 다른 변수 유형을 지원하기 위해 유형 시스템에서 매핑 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="translated">More on Functions</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">보다 명확하게 해당 코드 스 니펫은 다음을 작성하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e65b8445ad886f1be93458429fb5dd37c90a50bb" translate="yes" xml:space="preserve">
          <source>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The &amp;ldquo;run anywhere&amp;rdquo; nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use &lt;em&gt;only&lt;/em&gt; JavaScript to program their entire stack!</source>
          <target state="translated">이보다 JS는 node.js를 사용하여 JS 서버를 구현하는 것과 같이 브라우저의 컨텍스트 외부에서 사용될만큼 충분히 대중화되었습니다. JS의 &quot;어디서나 실행&quot;특성은 크로스 플랫폼 개발을위한 매력적인 선택입니다. 요즘에는 자바 스크립트 &lt;em&gt;만&lt;/em&gt; 사용 하여 전체 스택을 프로그래밍 하는 개발자가 많이 있습니다 !</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">가장 인기있는 라이브러리는 이제 UMD 패키지로 제공됩니다. 예를 들어 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; , &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt; 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b01864f5579af47acd49be012292e69db8aa02" translate="yes" xml:space="preserve">
          <source>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation &amp;mdash; before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</source>
          <target state="translated">대부분의 프로그래밍 언어는 이러한 종류의 오류가 발생할 때 오류를 발생시키고 일부는 컴파일 중에 코드가 실행되기 전에 발생합니다. 작은 프로그램을 작성할 때 이러한 단점은 성가 시지만 관리하기 쉽습니다. 수백 또는 수천 줄의 코드로 응용 프로그램을 작성할 때 이러한 끊임없는 놀라움은 심각한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">TypeScript 파일로 이동</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">많은 사람들이&amp;ldquo;단일 유형&amp;rdquo;과&amp;ldquo;문자 유형&amp;rdquo;을 상호 교환 적으로 사용하지만&amp;ldquo;단일 유형&amp;rdquo;에 대해 이야기 할 때 많은 경우에, 우리는 열거 형 멤버 유형과 숫자 / 문자열 리터럴 유형을 모두 언급하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">다중 파일 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">다음 예제와 같이 선언에 여러 데코레이터를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">여러 필드</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">최상위에 동일한 &lt;code&gt;export namespace Foo {&lt;/code&gt; 를 가진 여러 파일 (이 파일들이 하나의 &lt;code&gt;Foo&lt;/code&gt; 로 결합 될 것이라고 생각하지 마십시오 !)</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">동일한 형식 매개 변수에 대한 여러 개체 리터럴 형식 유추는 마찬가지로 표준화 된 단일 공용체 형식으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="aede1800680b8eed7745689bb8cd192726458952" translate="yes" xml:space="preserve">
          <source>Mutually exclusive with &lt;a href=&quot;#sourceMap&quot;&gt;&lt;code&gt;sourceMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sourceMap&quot;&gt; &lt;code&gt;sourceMap&lt;/code&gt; &lt;/a&gt; 과 상호 배타적입니다 .</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html (발췌)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">주의점 &lt;em&gt;재산권 기술자&lt;/em&gt; 에 의한 재산 장식은 타이프 라이터로 초기화하는 방법에 속성 데코레이터에 대한 인수로 제공되지 않습니다. 현재 프로토 타입의 멤버를 정의 할 때 인스턴스 속성을 설명하는 메커니즘이없고 속성의 이니셜 라이저를 관찰하거나 수정할 수있는 방법이 없기 때문입니다. 반환 값도 무시됩니다. 따라서 속성 데코레이터는 특정 이름의 속성이 클래스에 선언되었음을 관찰하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">참고 매개 변수 데코레이터는 매개 변수가 메소드에서 선언되었음을 관찰하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">주 데코레이터 메타 데이터는 실험적인 기능으로 향후 릴리스에서 주요 변경 사항이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">주 데코레이터는 향후 릴리스에서 변경 될 수있는 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">참고 새 생성자 함수를 반환하도록 선택한 경우 원래 프로토 타입을 유지 관리해야합니다. 런타임시 데코레이터를 적용하는 논리 는이를 수행하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;em&gt;재산권 기술자가&lt;/em&gt; 될 것입니다 &lt;code&gt;undefined&lt;/code&gt; 스크립트 목표보다 작은 경우 &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">참고 스크립트 대상이 &lt;code&gt;ES5&lt;/code&gt; 미만인 경우 반환 값이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">참고이 예에는 &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리 가 필요합니다 . &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리 에 대한 자세한 내용은 &lt;a href=&quot;#metadata&quot;&gt;메타 데이터&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">참고 TypeScript 에서는 단일 멤버에 대한 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근자를 모두 장식 할 수 없습니다 . 대신 멤버의 모든 데코레이터를 문서 순서대로 지정된 첫 번째 접근 자에 적용해야합니다. 데코레이터는 &lt;em&gt;속성 설명자에&lt;/em&gt; 적용되기 때문에 각 선언이 아닌 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근 자를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">참고 아래의 &lt;a href=&quot;#method-decorators&quot;&gt;메소드 데코레이터&lt;/a&gt; 에서 데코레이터 팩토리에 대한 자세한 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">참고 아래의 &lt;a href=&quot;#class-decorators&quot;&gt;클래스 데코레이터&lt;/a&gt; 에서 데코레이터에 대한 자세한 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">수입품의 이름과 위치</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; 확장자로 파일 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">프로젝트와 솔루션의 이름을 지정하십시오. &lt;em&gt;생성&lt;/em&gt; 버튼을 선택한 후</target>
        </trans-unit>
        <trans-unit id="b69558e9b061498c09673bf8df0b367bf33694fd" translate="yes" xml:space="preserve">
          <source>Named types just give a name to a type; for assignability purposes there&amp;rsquo;s no difference between the type alias &lt;code&gt;One&lt;/code&gt; and the interface type &lt;code&gt;Two&lt;/code&gt; below. They both have a property &lt;code&gt;p: string&lt;/code&gt;. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)</source>
          <target state="translated">명명 된 유형은 유형에 이름을 부여합니다. 할당 가능성을 위해 아래의 유형 별칭 &lt;code&gt;One&lt;/code&gt; 과 인터페이스 유형 &lt;code&gt;Two&lt;/code&gt; 사이에는 차이가 없습니다 . 둘 다 &lt;code&gt;p: string&lt;/code&gt; 속성이 있습니다 . (그러나 유형 별명은 재귀 적 정의 및 유형 매개 변수와 관련하여 인터페이스와 다르게 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">네임 스페이스 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">네임 스페이스 및 모듈</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">네임 스페이스 및 모듈</target>
        </trans-unit>
        <trans-unit id="0b0a6e9c59b25d6d7bd54387d9652cfedae85b49" translate="yes" xml:space="preserve">
          <source>Namespaces are a TypeScript-specific way to organize code.</source>
          <target state="translated">네임 스페이스는 코드를 구성하는 TypeScript 고유의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">네임 스페이스는 다른 유형의 선언과 병합 할 수있을만큼 유연합니다. 그렇게하려면 네임 스페이스 선언이 병합 할 선언을 따라야합니다. 결과 선언에는 두 선언 유형 모두의 속성이 있습니다. TypeScript는이 기능을 사용하여 JavaScript 및 기타 프로그래밍 언어의 일부 패턴을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="3952a1181de40dbd2a06ce80db7e580384e74ec9" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">네임 스페이스는 전역 범위에서 이름 충돌을 방지하는 데 중요합니다. 예를 들어 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 및 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; 이있을 수 있습니다. 이름은 같지만 네임 스페이스가 다른 두 가지 유형입니다. 그러나 이것은 모듈의 문제가 아닙니다. 모듈 내에서 동일한 이름을 가진 두 개의 개체를 가질 그럴듯한 이유가 없습니다. 소비 측면에서 특정 모듈의 소비자는 모듈을 참조하는 데 사용할 이름을 선택하게되므로 우발적 인 이름 충돌은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">네임 스페이스는 전역 범위에서 이름 충돌을 피하기 위해 중요합니다. 예를 들어, 이름은 같지만 네임 스페이스는 다른 두 가지 유형 인 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 및 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; 이있을 수 있습니다 . 그러나 이것은 모듈의 문제가 아닙니다. 모듈 내에서 동일한 이름을 가진 두 개의 객체를 가질만한 이유는 없습니다. 소비 측면에서 특정 모듈의 소비자는 모듈을 참조하는 데 사용할 이름을 선택하므로 우연한 이름 충돌이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">네임 스페이스는 단순히 글로벌 네임 스페이스에서 JavaScript 객체로 명명됩니다. 이것은 네임 스페이스를 사용하기 매우 간단한 구조로 만듭니다. 여러 파일에 걸쳐있을 수 있으며 &lt;code&gt;--outFile&lt;/code&gt; 을 사용하여 연결할 수 있습니다 . 네임 스페이스는 웹 응용 프로그램에서 코드를 구성하는 좋은 방법이 될 수 있으며 HTML 페이지에 모든 종속성이 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="558fb2926bc952cf7a6b78aa83d90ef0f04f4eb8" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">네임 스페이스는 단순히 전역 네임 스페이스에서 이름이 지정된 JavaScript 개체입니다. 이것은 네임 스페이스를 사용하기 매우 간단한 구조로 만듭니다. 모듈과 달리 여러 파일에 걸쳐있을 수 있으며 &lt;code&gt;--outFile&lt;/code&gt; 을 사용하여 연결할 수 있습니다 . 네임 스페이스는 웹 애플리케이션에서 코드를 구조화하는 좋은 방법이 될 수 있으며 모든 종속성은 HTML 페이지에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="abfc41609e10694546f23e6fe8ec31d3b441731d" translate="yes" xml:space="preserve">
          <source>Namespaces in Module Code</source>
          <target state="translated">모듈 코드의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">기본 ECMAScript 2015 모듈 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">불필요한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">모듈 기능 보강이나 전역 기능 보강은 최상위 항목에 새 항목을 추가 할 수 없으며 기존 선언 만 &quot;패치&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">중첩 및 병합 된 선언</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">중첩은 이제 모든 수준에서 작동하며 파일간에 올바르게 병합됩니다. 이전에는 그렇지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">새롭고 &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">새로운- &lt;code&gt;--strict&lt;/code&gt; 마스터 옵션</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">새로운 &lt;code&gt;.tsx&lt;/code&gt; 의 파일 확장자와 &lt;code&gt;as&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; 새로운 유형</target>
        </trans-unit>
        <trans-unit id="3249cca6099abd4cca11ff2add4d8cce20a25fa1" translate="yes" xml:space="preserve">
          <source>New Line - &lt;code&gt;newLine&lt;/code&gt;</source>
          <target state="translated">뉴 라인 &lt;code&gt;newLine&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">새로운 TypeScript 놀이터</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">기존 프로젝트가 중단되는 것을 막기 위해 TypeScript에 추가 된 새로운 검사는 종종 기본적으로 해제되어 있습니다. 파손을 피하는 것이 좋지만이 전략은 최고 수준의 유형 안전을 선택하는 것이 점점 더 복잡 해지는 단점이 있으며, 그렇게하려면 모든 TypeScript 릴리스에서 명시적인 옵트 인 작업이 필요합니다. &lt;code&gt;--strict&lt;/code&gt; 옵션을 사용하면 향상된 유형 검사 기능이 추가됨에 따라 최신 버전의 컴파일러에서 추가 오류가보고 될 수 있다는 점을 이해하여 최대 유형 안전을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">다음으로 생성자를 재정의하는 방법에 대한 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">다음으로 새 폴더를 추가하고이를 &lt;code&gt;scripts&lt;/code&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">다음으로, &lt;code&gt;U&lt;/code&gt; 내에서 &lt;code&gt;infer&lt;/code&gt; (보다 나중에) 선언에 의해 도입 된 각 유형 변수에 대해 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로 추론하여 (일반 함수의 유형 추론과 동일한 추론 알고리즘 사용) 후보 유형 세트를 수집합니다 . 주어진 &lt;code&gt;infer&lt;/code&gt; 유형 변수 &lt;code&gt;V&lt;/code&gt; 의 경우, 후보가 공변량 위치에서 추론 된 경우 &lt;code&gt;V&lt;/code&gt; 에 대해 추론되는 유형 은 해당 후보의 합집합입니다. 그렇지 않은 경우, 후보가 반 변형 위치에서 추론 된 경우 &lt;code&gt;V&lt;/code&gt; 에 대해 유추 된 유형 은 해당 후보의 교집합입니다. 그렇지 않으면 &lt;code&gt;V&lt;/code&gt; 에 대해 유추 된 유형 은 &lt;code&gt;never&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">다음으로 Visual Studio 버전에 최신 TypeScript가없는 경우 &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;설치할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">다음 소스를 사용하여 &lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;index.tsx&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">다음으로 클래스를 직접 사용합니다. 여기 &lt;code&gt;greeterMaker&lt;/code&gt; 라는 새 변수를 만듭니다 . 이 변수는 클래스 자체를 보유하거나 생성자 함수를 다르게 설명합니다. 여기서는 &lt;code&gt;typeof Greeter&lt;/code&gt; 를 사용 합니다. 즉, 인스턴스 유형이 아닌&amp;ldquo; &lt;code&gt;Greeter&lt;/code&gt; 클래스 자체 의 유형을 제공 합니다.&amp;rdquo; 또는 더 정확하게 는 생성자 함수의 유형 인&amp;ldquo; &lt;code&gt;Greeter&lt;/code&gt; 라는 심볼의 유형을 알려주십시오. &amp;rdquo;입니다. 이 유형에는 &lt;code&gt;Greeter&lt;/code&gt; 클래스의 인스턴스를 생성하는 생성자와 함께 Greeter의 모든 정적 멤버가 포함됩니다 . &lt;code&gt;greeterMaker&lt;/code&gt; 에서 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;Greeter&lt;/code&gt; 의 새 인스턴스를 만들어 이를 보여줍니다. 이전과 같이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d23baf839f3be80e72847391d0e91cd097e57246" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before. It is also good to mention that changing static property is frowned upon, here &lt;code&gt;greeter3&lt;/code&gt; has &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; on &lt;code&gt;standardGreeting&lt;/code&gt;.</source>
          <target state="translated">다음으로 클래스를 직접 사용합니다. 여기에서 &lt;code&gt;greeterMaker&lt;/code&gt; 라는 새 변수를 만듭니다 . 이 변수는 클래스 자체를 보유하거나 다른 방식으로 생성자 기능을 보유합니다. 여기서는 인스턴스 유형이 아닌 &quot; &lt;code&gt;Greeter&lt;/code&gt; 클래스 자체 의 유형을 제공&quot; 하는 &lt;code&gt;typeof Greeter&lt;/code&gt; 를 사용 합니다. 또는 더 정확하게 는 생성자 함수의 유형 인 &quot; &lt;code&gt;Greeter&lt;/code&gt; 라는 기호 유형을 알려주십시오 .&quot; 이 형식에는 &lt;code&gt;Greeter&lt;/code&gt; 클래스의 인스턴스를 만드는 생성자와 함께 Greeter의 모든 정적 멤버가 포함됩니다 . &lt;code&gt;greeterMaker&lt;/code&gt; 에서 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;Greeter&lt;/code&gt; 의 새 인스턴스를 생성 하여이를 보여줍니다.이전과 같이 호출합니다. 정적 속성을 변경하는 것이 눈살을 찌푸리는 것도 언급하는 것이 좋습니다. 여기서 &lt;code&gt;greeter3&lt;/code&gt; 에는 &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; 가 있습니다.대신 &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; 에 &lt;code&gt;standardGreeting&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; 및 &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt; 에 개발 시간 종속성을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">다음으로 두 믹스 인의 조합을 처리 할 클래스를 만듭니다. 이것이 어떻게 작동하는지 더 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="65015e14839407ce052eab7ebecff46c96ec532e" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ve also added the &lt;code&gt;@readonly&lt;/code&gt; modifier to ensure that a property is only ever written to during initialization.</source>
          <target state="translated">다음으로, 초기화 중에 만 속성이 기록되도록 &lt;code&gt;@readonly&lt;/code&gt; 한정자를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">야간 빌드</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">야간 빌드 : MSBuild와 함께 NuGet 사용</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">야간 빌드 : npm 사용</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">야간 빌드</target>
        </trans-unit>
        <trans-unit id="137f56df766041937e987c0af9dc02adfcc4755b" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;main&amp;rdquo; field</source>
          <target state="translated">&quot;메인&quot;필드 없음</target>
        </trans-unit>
        <trans-unit id="7f2bbc3e501b46e56dd329eeeb31b55fa0b1f266" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;types&amp;rdquo; field</source>
          <target state="translated">&quot;유형&quot;필드 없음</target>
        </trans-unit>
        <trans-unit id="947828c2d274f8a21e38e5dd1c59c5dea679fff4" translate="yes" xml:space="preserve">
          <source>No Emit - &lt;code&gt;noEmit&lt;/code&gt;</source>
          <target state="translated">아니 방출 - &lt;code&gt;noEmit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="517bdc2dcead288c404ef1a218dadda3060ef0b5" translate="yes" xml:space="preserve">
          <source>No Emit Helpers - &lt;code&gt;noEmitHelpers&lt;/code&gt;</source>
          <target state="translated">방출 도우미 없음 &lt;code&gt;noEmitHelpers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03f8de53c793590eccee3c9ce2ed4caeb14a5452" translate="yes" xml:space="preserve">
          <source>No Emit On Error - &lt;code&gt;noEmitOnError&lt;/code&gt;</source>
          <target state="translated">오류 &lt;code&gt;noEmitOnError&lt;/code&gt; 방출 없음 -noEmitOnError</target>
        </trans-unit>
        <trans-unit id="7b1eb323a13015b5221c0cd99fda83cbd652752c" translate="yes" xml:space="preserve">
          <source>No Error Truncation - &lt;code&gt;noErrorTruncation&lt;/code&gt;</source>
          <target state="translated">오류 잘림 없음 &lt;code&gt;noErrorTruncation&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8026bb65899345422d9472e2fb88c6be373e8549" translate="yes" xml:space="preserve">
          <source>No Fallthrough Cases In Switch - &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</source>
          <target state="translated">스위치에 폴 스루 케이스 없음 &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">내재 된 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">어떤 암시 적없는 &lt;code&gt;any&lt;/code&gt; 을위한 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c1c5d879a76450e09d3b73229dae5a7fb02f8" translate="yes" xml:space="preserve">
          <source>No Implicit Any - &lt;code&gt;noImplicitAny&lt;/code&gt;</source>
          <target state="translated">암시 적 없음 &lt;code&gt;noImplicitAny&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10c71f4c5d6c858e8b215dbb144dbf6d05414836" translate="yes" xml:space="preserve">
          <source>No Implicit Returns - &lt;code&gt;noImplicitReturns&lt;/code&gt;</source>
          <target state="translated">암시 적 반환 없음 &lt;code&gt;noImplicitReturns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5134182dd86f7b3181089a2100da25c6c0bc7cf4" translate="yes" xml:space="preserve">
          <source>No Implicit This - &lt;code&gt;noImplicitThis&lt;/code&gt;</source>
          <target state="translated">암시 적 없음 &lt;code&gt;noImplicitThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="763fcaff914bd4c20f0951a9a84eab99aa002c2b" translate="yes" xml:space="preserve">
          <source>No Implicit Use Strict - &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</source>
          <target state="translated">암시 적 사용 제한 없음 &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00b77ce03e2df58d71af1d4f405d9bf1ac7e9005" translate="yes" xml:space="preserve">
          <source>No Lib - &lt;code&gt;noLib&lt;/code&gt;</source>
          <target state="translated">Lib 없음 &lt;code&gt;noLib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="592cae7a1118d335c8f2c20593f693616662691c" translate="yes" xml:space="preserve">
          <source>No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</source>
          <target state="translated">No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="675ae146fc17269a9c7ab5f87fa461ad1c19cf8e" translate="yes" xml:space="preserve">
          <source>No Strict Generic Checks - &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</source>
          <target state="translated">엄격한 일반 검사 없음 &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36e5a62628a8609c8c2ea29d4e598862499087d1" translate="yes" xml:space="preserve">
          <source>No Unused Locals - &lt;code&gt;noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">사용하지 않은 로컬 없음 &lt;code&gt;noUnusedLocals&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56c92a5c1d34b1db353f920c96e229f154407160" translate="yes" xml:space="preserve">
          <source>No Unused Parameters - &lt;code&gt;noUnusedParameters&lt;/code&gt;</source>
          <target state="translated">사용하지 않는 매개 변수 없음 &lt;code&gt;noUnusedParameters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">어떤 유형에의 하위 유형 또는 양도 할 수 없습니다 &lt;code&gt;never&lt;/code&gt; (제외 &lt;code&gt;never&lt;/code&gt; 그 자체).</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="5c47793ac8ba8a46e72ec2594c5dca3b16c44344" translate="yes" xml:space="preserve">
          <source>Node 10</source>
          <target state="translated">노드 10</target>
        </trans-unit>
        <trans-unit id="1c07c40cb823fe2596e38b4e3bb579fa72706bed" translate="yes" xml:space="preserve">
          <source>Node 12</source>
          <target state="translated">노드 12</target>
        </trans-unit>
        <trans-unit id="1f07679d61eb1484f3fbb7f03c094ced47df3b09" translate="yes" xml:space="preserve">
          <source>Nominal Reified Type Systems</source>
          <target state="translated">공칭 Reified 유형 시스템</target>
        </trans-unit>
        <trans-unit id="05004c27291ee5258d4639719f948e95da6af52b" translate="yes" xml:space="preserve">
          <source>Non-Goals</source>
          <target state="translated">Non-Goals</target>
        </trans-unit>
        <trans-unit id="116d53de6ee6ef67d2d4805314ad0787f638003a" translate="yes" xml:space="preserve">
          <source>Non-Module Files</source>
          <target state="translated">비 모듈 파일</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">인터페이스의 비 기능 구성원은 고유해야합니다. 고유하지 않은 경우 동일한 유형이어야합니다. 인터페이스가 모두 같은 이름이지만 기능이 다른 유형의 함수가 아닌 멤버를 선언하면 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">제네릭이 아닌 스프레드 식은 이전과 같이 계속 처리됩니다. 호출 및 구문 서명이 제거되고 메서드가 아닌 속성 만 보존되며 이름이 같은 속성의 경우 가장 오른쪽 속성 유형이 사용됩니다. 이는 호출을 연결하고 서명을 구성하고 모든 속성을 유지하며 동일한 이름의 속성 유형을 교차시키는 교차 유형과 대조됩니다. 따라서 동일한 유형의 스프레드는 일반 유형의 인스턴스화를 통해 생성 될 때 다른 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">동형이 아닌 유형은 본질적으로 새로운 속성을 생성하므로 어디서나 속성 수정자를 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">널이 아닌 및 정의되지 않은 유형 가드</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">비 - 널 및 사용할 수있는 비 미정 형 가드 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;===&lt;/code&gt; 또는 &lt;code&gt;!==&lt;/code&gt; 연산자 비교할 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 같이 &lt;code&gt;x != null&lt;/code&gt; 또는 &lt;code&gt;x === undefined&lt;/code&gt; . 주제 변수 유형에 미치는 영향은 JavaScript 의미를 정확하게 반영합니다 (예 : 이중 같음 연산자는 지정된 값에 상관없이 두 값을 모두 확인하지만 삼중 같음은 지정된 값만 확인).</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">널이 아닌 어설 션 연산자</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">널 입력 불가능 유형은 의미가 없으며 원래 유형으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">노동 조합 차별 자로서의 비 단위 유형</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">일반적으로 컴파일러는 컴파일 프로세스를 시작하기 전에 모든 모듈 가져 오기를 해결하려고 시도합니다. 파일 로 &lt;code&gt;import&lt;/code&gt; 가 성공적으로 해결 될 때마다 파일은 컴파일러가 나중에 처리 할 파일 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">일반적으로, &lt;code&gt;tsc&lt;/code&gt; (출력을 생산할 예정 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; 을 하지 않는 구 타입 또는 에러의 존재 하에서) &lt;code&gt;noEmitOnError&lt;/code&gt; 가 에있다. 증분 빌드 시스템에서이 작업을 수행하는 것은 매우 나쁩니다. 오래된 종속성 중 하나에 새로운 오류가 발생 하면 후속 빌드에서 최신 프로젝트 빌드를 건너 뛰기 때문에 &lt;em&gt;한 번만&lt;/em&gt; 보게됩니다 . 이러한 이유로 &lt;code&gt;tsc -b&lt;/code&gt; 는 모든 프로젝트에 대해 &lt;code&gt;noEmitOnError&lt;/code&gt; 가 활성화 된 것처럼 효과적으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="9fd029d8465bd91c3c7282b62d1066fe73ce0eee" translate="yes" xml:space="preserve">
          <source>Normally, TypeScript would return silently on success.</source>
          <target state="translated">일반적으로 TypeScript는 성공하면 조용히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">TypeScript에서 모든 병합이 허용되는 것은 아닙니다. 현재 클래스는 다른 클래스 또는 변수와 병합 할 수 없습니다. 클래스 병합 모방에 대한 정보 &lt;a href=&quot;mixins&quot;&gt;는 TypeScript의 믹스 인&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">인터페이스의 모든 속성이 필요한 것은 아닙니다. 일부는 특정 조건 하에서 존재하거나 전혀 존재하지 않을 수 있습니다. 이러한 선택적 속성은&amp;ldquo;옵션 백&amp;rdquo;과 같은 패턴을 만들 때 자주 사용되며, 속성이 몇 개만 채워진 함수에 객체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">아래에 명시 적으로 나열되지 않은 태그 (예 : &lt;code&gt;@async&lt;/code&gt; )는 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f5feea3e404674922df60252466104fa5c5fc9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike TypeScript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">참고 &lt;code&gt;@enum&lt;/code&gt; 는 상당히 다른, 그리고, 타이프 라이터의 것보다 훨씬 간단 &lt;code&gt;enum&lt;/code&gt; . 그러나, 타이프 라이터의 열거는 달리, &lt;code&gt;@enum&lt;/code&gt; 는 모든 유형을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">참고 &lt;code&gt;@enum&lt;/code&gt; 는 상당히 다른, 그리고, 타이프 라이터의 것보다 훨씬 간단 &lt;code&gt;enum&lt;/code&gt; . 그러나 Typescript의 열거 형과 달리 &lt;code&gt;@enum&lt;/code&gt; 은 모든 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">참고 &lt;code&gt;@extends&lt;/code&gt; 는 클래스 만 작동합니다. 현재 생성자 함수가 클래스를 확장 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; , 그들과 함께 타이프의 표준 라이브러리에 매우 유용하게 포함되어 있습니다 &lt;code&gt;Pick&lt;/code&gt; 및 &lt;code&gt;Record&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a8635b5b3c1a94603cc953231075f37144a428de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;keyof any&lt;/code&gt; represents the type of any value that can be used as an index to an object. In otherwords, &lt;code&gt;keyof any&lt;/code&gt; is currently equal to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;keyof any&lt;/code&gt; 물체에 대한 인덱스로서 이용 될 수있는 값의 종류를 나타낸다. 즉, &lt;code&gt;keyof any&lt;/code&gt; 는 현재 &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">참고 것을 &lt;code&gt;y&lt;/code&gt; 추가가 &lt;code&gt;location&lt;/code&gt; 속성을하지만,이 오류를 생성하지 않습니다. 호환성을 확인할 때는 대상 유형 ( 이 경우 &lt;code&gt;Named&lt;/code&gt; 의 멤버 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">TypeScript는 JavaScript 의미와 일치시키기 위해 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 를 다르게 처리합니다 . &lt;code&gt;string | null&lt;/code&gt; 은 &lt;code&gt;string | undefined&lt;/code&gt; 과 다른 유형입니다. | 정의 및 &lt;code&gt;string | undefined | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d964565fed797b8fe69da21280237178f8dd90d" translate="yes" xml:space="preserve">
          <source>Note that TypeScript will never write an output file to a directory outside of &lt;code&gt;outDir&lt;/code&gt;, and will never skip emitting a file. For this reason, &lt;code&gt;rootDir&lt;/code&gt; also enforces that all files which need to be emitted are underneath the &lt;code&gt;rootDir&lt;/code&gt; path.</source>
          <target state="translated">타이프 라이터가의 디렉토리 외부로 출력 파일 쓰기하지 않습니다 &lt;code&gt;outDir&lt;/code&gt; 하고 파일을 발광 건너하지 않습니다. 이러한 이유로 &lt;code&gt;rootDir&lt;/code&gt; 는 내 보내야 하는 모든 파일이 &lt;code&gt;rootDir&lt;/code&gt; 경로 아래에 있도록 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; 와 마찬가지로 기존 TypeScript 프로젝트 속성은 고려되지 않으며 모든 설정은 tsconfig 파일을 사용하여 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="49f454e4294f1faa6bdcf0d5b1903082b8d7d4af" translate="yes" xml:space="preserve">
          <source>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</source>
          <target state="translated">숫자 리터럴에서 메서드를 호출하려면 구문 분석기를 지원하기 위해 괄호 안에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="af06da8b751f486668f66523aec780426d9aaf88" translate="yes" xml:space="preserve">
          <source>Note that functions and arrays are objects at runtime, but have their own predicates.</source>
          <target state="translated">함수와 배열은 런타임에 객체이지만 자체 조건자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 로 선언 된 전역 변수는 &lt;code&gt;globalThis&lt;/code&gt; 에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">참고 경우 것이 &lt;code&gt;bar&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; , 우리의 코드는 여전히 액세스 할 경우에 에러 칠 것이다 &lt;code&gt;baz&lt;/code&gt; . 마찬가지로 &lt;code&gt;baz&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 인 경우 호출 사이트에서 오류가 발생합니다. &lt;code&gt;?.&lt;/code&gt; &lt;em&gt;왼쪽&lt;/em&gt; 의 값 이 &lt;code&gt;null&lt;/code&gt; 인지 &lt;code&gt;undefined&lt;/code&gt; 않은지 여부 만 확인 하며 후속 속성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">에 있습니다 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드, 호모 모르 픽 매핑 유형이 제거 &lt;code&gt;?&lt;/code&gt; 기본 유형의 속성에서 수정 자 또한 해당 속성의 유형에서 &lt;code&gt;undefined&lt;/code&gt; 을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">TypeScript 1.4에서는 알려진 인덱스 집합 외부의 요소에 액세스 할 때 공용체 유형이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">이 예제에서는 &lt;code&gt;C&lt;/code&gt; 의 &lt;em&gt;정적&lt;/em&gt; 측 (생성자 함수)에 값을 추가했습니다 . 이는 &lt;em&gt;value를&lt;/em&gt; 추가하고 모든 값의 컨테이너가 다른 값 이기 때문입니다 (유형은 네임 스페이스에 포함되고 네임 스페이스는 다른 네임 스페이스에 포함됨).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4521e5d9ffa1f2a7a2398a1ba71b06034b84ba66" translate="yes" xml:space="preserve">
          <source>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare &lt;code&gt;map&lt;/code&gt; with the array first:</source>
          <target state="translated">추론은 어떤 순서로든 작동하지만 intellisense는 왼쪽에서 오른쪽으로 만 작동하므로 TypeScript는 먼저 배열로 &lt;code&gt;map&lt;/code&gt; 을 선언하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">전역 선언 파일을 작성할 때 전역 범위에서 많은 유형을 정의 할 수 있습니다. 많은 선언 파일이 프로젝트에있을 때 해결할 수없는 이름 충돌이 발생할 수 있으므로이 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">괄호는 공용체 유형의 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">속성 유형이 유효한 한 부분 오버랩이 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">상대 모듈 가져 오기는 baseUrl을 설정해도 영향을받지 않습니다. 이는 항상 가져 오기 파일을 기준으로 해결되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">있습니다 &lt;code&gt;&quot;typings&quot;&lt;/code&gt; 필드의 대명사 &lt;code&gt;&quot;types&quot;&lt;/code&gt; ,뿐만 아니라 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">그 주 &lt;code&gt;function pickCard(x): any&lt;/code&gt; 목적을 얻어 하나의 숫자를 취 하나가 두 과부하를 갖도록 조각 과부하리스트의 일부가 아니다. 다른 매개 변수 유형으로 &lt;code&gt;pickCard&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e52a12186dadc57595c17ea6c93216559c79848" translate="yes" xml:space="preserve">
          <source>Note that the return type of &lt;code&gt;area&lt;/code&gt; is inferred to be &lt;code&gt;number&lt;/code&gt; because TypeScript knows the function is total. If some variant is not covered, the return type of &lt;code&gt;area&lt;/code&gt; will be &lt;code&gt;number | undefined&lt;/code&gt; instead.</source>
          <target state="translated">TypeScript는 함수가 총계임을 알고 있기 때문에 &lt;code&gt;area&lt;/code&gt; 의 반환 유형은 &lt;code&gt;number&lt;/code&gt; 로 추론됩니다 . 약간의 변형이 적용되지 않은 경우의 반환 형식 &lt;code&gt;area&lt;/code&gt; 될 것입니다 &lt;code&gt;number | undefined&lt;/code&gt; 대신 정의되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">이 붕괴는 모든 과부하가 동일한 반환 유형을 갖는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">이것은 튜플이 불변 배열을 나타내는 것은 아닙니다만, 이것은 암묵적인 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">이것은 일부 코드의 주요 변경 사항입니다. 튜플이 최소 길이 만 적용하는 원래 동작에 의존해야하는 경우 &lt;code&gt;length&lt;/code&gt; 속성을 명시 적으로 정의하지 않고 &lt;code&gt;number&lt;/code&gt; 로 돌아가는 유사한 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">이 구문은 멤버가 아닌 유형을 설명합니다. 멤버를 추가하려는 경우 교차 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">이 언 래핑 추론은 동형 매핑 된 유형에서만 작동합니다. 매핑 된 형식이 동형이 아닌 경우 언 래핑 함수에 명시 적 형식 매개 변수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca498eaf7012359010349b6f8e9e80f634eacb51" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;export default&lt;/code&gt; in your .d.ts files requires &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt;&lt;/a&gt; to work. If you can&amp;rsquo;t have &lt;code&gt;esModuleInterop: true&lt;/code&gt; in your project, such as when you&amp;rsquo;re submitting a PR to Definitely Typed, you&amp;rsquo;ll have to use the &lt;code&gt;export=&lt;/code&gt; syntax instead. This older syntax is harder to use but works everywhere. Here&amp;rsquo;s how the above example would have to be written using &lt;code&gt;export=&lt;/code&gt;:</source>
          <target state="translated">.d.ts 파일에서 &lt;code&gt;export default&lt;/code&gt; 을 사용 하려면 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt; &lt;code&gt;esModuleInterop: true&lt;/code&gt; &lt;/a&gt; 가 작동해야합니다. 프로젝트에서 &lt;code&gt;esModuleInterop: true&lt;/code&gt; 를 사용할 수없는 경우 ( 예 : Definitely Typed에 PR을 제출하는 경우) 대신 &lt;code&gt;export=&lt;/code&gt; 구문 을 사용해야합니다 . 이 오래된 구문은 사용하기가 더 어렵지만 모든 곳에서 작동합니다. 다음은 &lt;code&gt;export=&lt;/code&gt; 사용하여 위의 예를 작성하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">인터페이스를 사용하여 유형 별칭 ( &lt;code&gt;type s = string;&lt;/code&gt; )에 추가 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">현재 문자열 리터럴 유형의 판별 특성 만 지원합니다. 나중에 부울 및 숫자 리터럴 유형에 대한 지원을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">서명의 반환 유형이 다르기 때문에 여기서 &lt;code&gt;b&lt;/code&gt; 를 선택적으로 만들지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">튜플 유형이 일련의 매개 변수에서 유추되고 나중에 &lt;code&gt;U&lt;/code&gt; 의 경우와 같이 매개 변수 목록으로 확장 되면 원래 매개 변수 이름이 확장에 사용됩니다 (단, 의미는 의미가 없으며 다른 의미는 아닙니다) 주목할 만한).</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">이러한 플래그를 함께 사용하는 경우 TypeScript가 반드시 &lt;code&gt;.js&lt;/code&gt; 파일 을 다운 레벨 할 필요는 없습니다 . TypeScript가 &lt;code&gt;.d.ts&lt;/code&gt; 파일 을 만들려면 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; 컴파일러 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">이 예제가 사용하는 동안주의 &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;구성 요소를 작동&lt;/a&gt; , 우리는 또한 우리의 예를 조금 할 수 &lt;em&gt;classier&lt;/em&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">참고 : &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 는 최신 지원 대상</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 는 지원되는 최신 &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES 제안 기능을&lt;/a&gt; 대상으로 합니다 .</target>
        </trans-unit>
        <trans-unit id="9d7cb6b652ecb3fc440c1897098d4132f67f5630" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;node&lt;/code&gt; module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;export&lt;/code&gt;s in TypeScript, try setting &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; to see if it fixes the issue.</source>
          <target state="translated">참고 : &lt;code&gt;node&lt;/code&gt; 모듈 확인은 TypeScript 커뮤니티에서 가장 일반적으로 사용되며 대부분의 프로젝트에 권장됩니다. TypeScript의 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 에 해결 문제가있는 경우 &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; 를 설정 하여 문제가 해결되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b385aa9974c78d1114e7d19ac34ae3cecb189cbb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;outFile&lt;/code&gt; cannot be used unless &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt;, or &lt;code&gt;AMD&lt;/code&gt;. This option &lt;em&gt;cannot&lt;/em&gt; be used to bundle CommonJS or ES6 modules.</source>
          <target state="translated">참고 : &lt;code&gt;module&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;System&lt;/code&gt; 또는 &lt;code&gt;AMD&lt;/code&gt; 가 아니면 &lt;code&gt;outFile&lt;/code&gt; 을 사용할 수 없습니다 . 이 옵션 &lt;em&gt;은&lt;/em&gt; CommonJS 또는 ES6 모듈을 번들하는 데 사용할 &lt;em&gt;수 없습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">참고 : 해야 &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;할 일과하지 말아야&lt;/a&gt; 할 일에 설명 된 것처럼 기본이 아닌 &lt;code&gt;object&lt;/code&gt; 유형 에 유리하게 &lt;code&gt;Object&lt;/code&gt; 를 사용 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="93a51f16eac9cd871496fa3f38f5e48ecd5fea51" translate="yes" xml:space="preserve">
          <source>Note: Error messages only show up in JS codebases with &lt;a href=&quot;tsconfig-json&quot;&gt;a JSConfig&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">참고 : 오류 메시지 &lt;a href=&quot;tsconfig-json&quot;&gt;는 JSConfig&lt;/a&gt; 및 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt; &lt;code&gt;checkJs&lt;/code&gt; &lt;/a&gt; 활성화 된 JS 코드베이스에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">참고 : 기능 구성 요소는 이전에는 상태 비 저장 기능 구성 요소 (SFC)로 알려져 있습니다. 최신 버전의 반응에서는 함수 구성 요소를 더 이상 상태 비 저장으로 간주 할 수 없으므로 &lt;code&gt;SFC&lt;/code&gt; 유형 및 별명 &lt;code&gt;StatelessComponent&lt;/code&gt; 는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">참고 : &lt;code&gt;--lib&lt;/code&gt; 를 지정하지 않으면 기본 라이브러리 목록이 삽입됩니다. 주입 된 기본 라이브러리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">참고 : 속성 이름이 유효한 JS 식별자 (예 : &lt;code&gt;data-*&lt;/code&gt; 속성)가 아닌 경우 요소 속성 유형에서 찾을 수없는 경우 오류로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="019f04b9d1d907c729221ba8c0d3f15ea3b9e489" translate="yes" xml:space="preserve">
          <source>Note: In &lt;em&gt;very&lt;/em&gt; old versions of TypeScript namespaces were called &amp;lsquo;Internal Modules&amp;rsquo;, these pre-date JavaScript module systems.</source>
          <target state="translated">참고 : &lt;em&gt;아주&lt;/em&gt; 오래된 버전의 TypeScript 네임 스페이스에서 '내부 모듈'이라고 불 렸습니다. 이러한 이전 자바 스크립트 모듈 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">참고 : 대부분의 변경으로 인해 새 버전의 VS TypeScript 플러그인을 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">참고 : 내부 모듈을 정의하는 이전 구문은 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">참고 : &lt;code&gt;Exclude&lt;/code&gt; 유형은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;여기에&lt;/a&gt; 제안 된 &lt;code&gt;Diff&lt;/code&gt; 유형 의 올바른 구현입니다 . &lt;code&gt;Exclude&lt;/code&gt; 라는 이름을 사용하여 &lt;code&gt;Diff&lt;/code&gt; 를 정의하는 기존 코드가 깨지지 않도록 하고 해당 이름이 형식의 의미를보다 잘 전달한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Exclude&lt;/code&gt; 유형은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;여기에&lt;/a&gt; 제안 된 &lt;code&gt;Diff&lt;/code&gt; 유형 의 올바른 구현입니다. . &lt;code&gt;Exclude&lt;/code&gt; 라는 이름을 사용하여 &lt;code&gt;Diff&lt;/code&gt; 를 정의하는 기존 코드가 깨지지 않도록 하고 해당 이름이 형식의 의미를보다 잘 전달한다고 생각합니다. &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; 유형은 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; 포함하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">참고 : 기존 코드베이스에 대한 불필요한 중단을 피하기 위해 플래그 아래에 새로운 동작이 추가되었습니다. &lt;strong&gt;새로운 프로젝트와 기존 프로젝트 모두에 적용하는 것이 좋습니다. &lt;/strong&gt;기존 프로젝트의 경우 네임 스페이스 가져 오기 ( &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; )를 기본 가져 &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; 로 변환해야합니다 ( import express from &quot;express&quot;; express (); ).</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">참고 :이 변경으로 인해 새로운 방출 도우미 &lt;code&gt;__makeTemplateObject&lt;/code&gt; 가 제공됩니다. . &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;--importHelpers&lt;/code&gt; 를 사용하는 경우 버전 1.8 이상으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">참고 :이 유형 은 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 가 활성화 된 경우에만 올바르게 작동합니다 . &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;# 32964를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">참고 : &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에서 다음과 같이 범용 문자열 인덱서를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">참고 : NuGet 패키지를 사용하도록 프로젝트를 구성해야합니다. 참조하십시오&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt; 구성은 MSBuild 프로젝트 NuGet을 사용하는&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">참고 : 먼저 런타임에 ECMAScript 호환 &lt;code&gt;Promise&lt;/code&gt; 가 전 세계적으로 제공 되는지 확인해야합니다 . &lt;code&gt;Promise&lt;/code&gt; 용 &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;폴리 필&lt;/a&gt; 을 가져 오거나 대상으로 하는 런타임 에 있을 수 있는 폴리 필 에 의존 할 수 있습니다. 또한 &lt;code&gt;lib&lt;/code&gt; 플래그를 &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; 와 같은 형식 으로 설정하여 TypeScript에 &lt;code&gt;Promise&lt;/code&gt; 가 있음을 알도록해야합니다. 또는 &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">참고 : 검색중인 선언 파일이 없으면 언제든지 다시 기여하고 다음 개발자가 도움을 줄 수 있습니다. 자세한 내용은 DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;기여 가이드 라인 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">우리가 떨어 방법 공지 사항 &lt;code&gt;theName&lt;/code&gt; 를 모두 그냥 단축 사용 &lt;code&gt;readonly name: string&lt;/code&gt; 생성 및 초기화하는 생성자에 매개 변수를 &lt;code&gt;name&lt;/code&gt; 멤버. 선언과 과제를 한 곳에 통합했습니다.</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">것을 알 수 &lt;code&gt;T&lt;/code&gt; 가 에서 전파 된 &lt;code&gt;makeArray&lt;/code&gt; 결과 형식의 형식 매개 변수 목록에. 즉, &lt;code&gt;compose&lt;/code&gt; 인수의 &lt;code&gt;makeBoxedArray&lt;/code&gt; 이 유지되고 makeBoxedArray 샘플이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">공지 것이 &lt;code&gt;T&lt;/code&gt; 는 추가적인 제약 조건이 &lt;code&gt;any[]&lt;/code&gt; 의 실제 분기 내의 &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 과 그 배열의 요소 유형 등을 참조하는 것이 가능하다 &lt;code&gt;T[number]&lt;/code&gt; . 또한 마지막 예에서 조건 유형이 공용체 유형에 어떻게 분산되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">것을 알 수 &lt;code&gt;createCardPicker&lt;/code&gt; 은 그 자체가 함수를 반환하는 함수입니다. 예제를 실행하려고하면 예상 된 경고 상자 대신 오류가 발생합니다. 때문이다 &lt;code&gt;this&lt;/code&gt; 만든 함수에서 사용되는 &lt;code&gt;createCardPicker&lt;/code&gt; 가 설정됩니다 &lt;code&gt;window&lt;/code&gt; 대신에 우리의 &lt;code&gt;deck&lt;/code&gt; 객체입니다. 자체적으로 &lt;code&gt;cardPicker()&lt;/code&gt; 를 호출하기 때문 입니다. 이와 같은 최상위 비 메소드 구문 호출은 this에 &lt;code&gt;window&lt;/code&gt; 를 사용 &lt;code&gt;this&lt;/code&gt; . (참고 : 엄격 모드에서, &lt;code&gt;this&lt;/code&gt; 됩니다 &lt;code&gt;undefined&lt;/code&gt; 보다는 &lt;code&gt;window&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">공지 사항 &lt;code&gt;uglify&lt;/code&gt; 자체가 하나의 호출이 - 호출하는 &lt;code&gt;buffer&lt;/code&gt; 하고 &lt;code&gt;sourcemaps&lt;/code&gt; 는 확인 sourcemaps이 작업을 계속하기 위해 존재한다. 이러한 호출은 이전과 같이 인라인 소스 맵을 사용하는 대신 별도의 소스 맵 파일을 제공합니다. 이제 Gulp를 실행하고 &lt;code&gt;bundle.js&lt;/code&gt; 가 읽을 수없는 혼란으로 축소 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">Node.js는 단계 (4)와 (7)에서 디렉토리를 뛰어 넘었습니다.</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">타이프 라이터가 알고뿐만 아니라 통지 &lt;code&gt;pet&lt;/code&gt; A는 &lt;code&gt;Fish&lt;/code&gt; 의 &lt;code&gt;if&lt;/code&gt; 지점; 그것은 또한에서 것을 알고 &lt;code&gt;else&lt;/code&gt; 지점, 당신이 &lt;em&gt;하지 않는&lt;/em&gt; 이 &lt;code&gt;Fish&lt;/code&gt; 당신이 있어야합니다, 그래서 &lt;code&gt;Bird&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">오류가 있었지만 &lt;code&gt;greeter.js&lt;/code&gt; 는 파일이 계속 생성됩니다. 코드에 오류가 있어도 TypeScript를 사용할 수 있습니다. 그러나이 경우 TypeScript는 코드가 예상대로 실행되지 않을 것이라고 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">ES2015 모듈 구문을 사용했지만 TypeScript는 Node가 사용하는 CommonJS 모듈을 생성했습니다. 이 튜토리얼에서는 CommonJS를 사용하지만 옵션 객체에서 &lt;code&gt;module&lt;/code&gt; 을 설정 하여이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">이 예는 약간 다른 것으로 변경되었습니다. 제네릭 함수를 설명하는 대신 이제 제네릭 형식의 일부인 제네릭이 아닌 함수 서명이 있습니다. &lt;code&gt;GenericIdentityFn&lt;/code&gt; 을 사용할 때 해당 유형 인수를 지정해야합니다 (여기 : &lt;code&gt;number&lt;/code&gt; ) 하여 기본 호출 서명이 사용할 항목을 효과적으로 잠급니다. 유형 매개 변수를 호출 시그니처에 직접 배치 할시기와 인터페이스 자체에 배치하는시기를 이해하면 유형의 일반적인 측면을 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">각 그룹의 요소는 동일한 순서를 유지하지만 그룹 자체는 나중에 주문 된 이후의 과부하 세트와 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; )로 유형을 명시 적으로 전달할 필요는 없습니다 . 컴파일러는 방금 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; 값을보고 &lt;code&gt;T&lt;/code&gt; 를 해당 유형으로 설정 했습니다. 형식 인수 유추는 코드를 더 짧고 읽기 쉽게 유지하는 데 유용한 도구 일 수 있지만 컴파일러가 형식을 유추하지 못하는 경우 이전 예제에서와 같이 형식 인수를 명시 적으로 전달해야합니다 (더 복잡한 예제에서 발생할 수 있음) .</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 키워드는 사용하지 않습니다 . 대신 가져 오는 심볼의 정규화 된 이름에서 직접 할당합니다. 이것은 &lt;code&gt;var&lt;/code&gt; 사용과 유사 하지만 가져온 심볼의 유형 및 네임 스페이스 의미에서도 작동합니다. 중요하게, 값의 경우 &lt;code&gt;import&lt;/code&gt; 는 원래 기호와 별개의 참조이므로 별칭 &lt;code&gt;var&lt;/code&gt; 에 대한 변경 사항 은 원래 변수에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">이 문장을 괄호로 묶어야합니다. JavaScript는 일반적으로 &lt;code&gt;{&lt;/code&gt; 를 블록의 시작 으로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">형식 어설 션을 여러 번 사용해야했습니다. 점검을 한 후에 각 지점 에서 &lt;code&gt;pet&lt;/code&gt; 의 종류를 알 수 있다면 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">개발 의존성으로 TypeScript를 설치했습니다. &lt;code&gt;npm link typescript&lt;/code&gt; 를 사용하여 TypeScript를 전역 복사본에 연결할 수도 있지만 이는 덜 일반적인 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Browserify에 &lt;code&gt;debug: true&lt;/code&gt; 를 지정 했습니다. 이로 인해 tsify는 번들 JavaScript 파일 내에서 소스 맵을 생성합니다. 소스 맵을 사용하면 번들 JavaScript 대신 브라우저에서 원본 TypeScript 코드를 디버깅 할 수 있습니다. 브라우저의 디버거를 열고 &lt;code&gt;main.ts&lt;/code&gt; 안에 중단 점을 두어 소스 맵이 작동하는지 테스트 할 수 있습니다 . 페이지를 새로 고치면 중단 점이 페이지를 일시 중지하고 &lt;code&gt;greet.ts&lt;/code&gt; 를 디버깅 할 수 있도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 내에 파일이 포함되어 있습니다 . React 및 React-DOM의 npm 패키지에는 웹 페이지에 포함 할 수있는 독립형 &lt;code&gt;.js&lt;/code&gt; 파일이 포함되어 있으며, 더 빠르게 이동하기 위해 직접 참조합니다. 이러한 파일을 다른 디렉토리로 복사하거나 CDN (Content Delivery Network)에서 호스팅하십시오. Facebook은 CDN 호스트 버전의 React를 제공 &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;하며 여기에서 자세한 내용을 읽을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">우리가 사용하는 수는 없지만 것을주의 &lt;code&gt;name&lt;/code&gt; 외부에서 &lt;code&gt;Person&lt;/code&gt; , 우리는 여전히의 인스턴스 메서드 내에서 사용할 수 있습니다 &lt;code&gt;Employee&lt;/code&gt; 때문에 &lt;code&gt;Employee&lt;/code&gt; 에서 유래 &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">위의 유형 주석은 필요하지 않습니다. &lt;code&gt;const&lt;/code&gt; 주장은 타이프는 식의 가장 구체적인 유형을 할 수 있었다.</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">에 주어진 인수에 주목 &lt;code&gt;createSquare&lt;/code&gt; 가 철자 &lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt; 대신 &lt;code&gt;color&lt;/code&gt; . 일반 JavaScript에서는 이런 종류의 일이 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">이제 &lt;code&gt;search&lt;/code&gt; 은 &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; 입니다. 객체 확산은 배열 확산보다 복잡합니다. 배열 확산과 같이 왼쪽에서 오른쪽으로 진행되지만 결과는 여전히 개체입니다. 이는 스프레드 객체에서 나중에 나오는 속성이 앞서 나오는 속성을 덮어 씁니다. 따라서 이전 예제를 수정하여 마지막에 확산되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">TypeScript는 &lt;code&gt;createCardPicker&lt;/code&gt; 가 &lt;code&gt;Deck&lt;/code&gt; 객체 에서 호출 될 것으로 예상 한다는 것을 알고 있습니다 . 것을 그 수단 &lt;code&gt;this&lt;/code&gt; 타입이다 &lt;code&gt;Deck&lt;/code&gt; 하지, 지금 &lt;code&gt;any&lt;/code&gt; 때문에, &lt;code&gt;--noImplicitThis&lt;/code&gt; 는 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">이제 &lt;code&gt;main.ts&lt;/code&gt; 를 변경 하여 페이지를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">지금의 코드 변경 &lt;code&gt;src/main.ts&lt;/code&gt; 가져올 &lt;code&gt;sayHello&lt;/code&gt; 에서 &lt;code&gt;greet.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">이제 gulpfile을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;this&lt;/code&gt; 호출 코드에 주석을 달면 :</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 로의 가져 오기 는 &lt;code&gt;./modules/moduleA&lt;/code&gt; 에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">이제 리턴 유형 만 다른 두 가지 함수를 사용하여 리턴 유형을 처리하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">이제이 프로젝트를 노드에서 브라우저로 옮깁니다. 이를 위해 모든 모듈을 하나의 JavaScript 파일로 묶고 싶습니다. 다행히도 이것이 바로 Browserify가하는 일입니다. 또한 기본 TypeScript 이미 터 인 Node에서 사용하는 CommonJS 모듈 시스템을 사용할 수 있습니다. 즉, TypeScript 및 Node 설정은 기본적으로 변경되지 않은 브라우저로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">이제 차별적 노동 조합을 사용합시다 :</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">이제 선호하는 브라우저에서 &lt;code&gt;index.html&lt;/code&gt; 을 열고 모든 것을 사용할 준비가되었습니다! &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;라는 페이지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; 를 마우스 오른쪽 버튼으로 클릭 하고 Task Runner Explorer를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">이제 코드를 Browserify 및 tsify와 번들로 제공하므로 browserify 플러그인을 사용하여 빌드에 다양한 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">함수를 입력 했으므로 함수 유형의 각 부분을보고 함수의 전체 유형을 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">이 안내서의 단계에 따라 선언 파일을 작성 했으므로 이제 npm에 게시 할 차례입니다. 선언 파일을 npm에 게시 할 수있는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">타입의 속성을 래핑하는 방법을 알았으니, 다음으로해야 할 것은 래핑 해제입니다. 다행히도 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6f30ea04179dac8c71c16f96f3f1582920ec3fad" translate="yes" xml:space="preserve">
          <source>Now the type of the array propagates into the &lt;code&gt;ArrayMetadata&lt;/code&gt; type.</source>
          <target state="translated">이제 배열 유형 이 &lt;code&gt;ArrayMetadata&lt;/code&gt; 유형 으로 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">10이 아닌 다른 숫자로 입력을 지원하기 위해 이것을 확장하기 위해 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt; 를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;greeter.html&lt;/code&gt; 에 다음을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; 를 수행 한 다음 &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; 또는 &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">이제 TypeScript가 제공하는 몇 가지 새로운 도구를 활용할 수 있습니다. 다음 과 같이 'person'함수 인수에 &lt;code&gt;: string&lt;/code&gt; 유형 주석을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">이제 &lt;code&gt;npm install&lt;/code&gt; 을 사용하여 패키지를 설치할 수 있습니다 . 먼저 &lt;code&gt;gulp-cli&lt;/code&gt; 를 전체적으로 설치하십시오 (Unix 시스템을 사용하는 경우이 안내서에서 &lt;code&gt;npm install&lt;/code&gt; 명령 앞에 &lt;code&gt;sudo&lt;/code&gt; 를 추가 해야 할 수도 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">이제이 폴더를 npm 패키지로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">이제 이러한 &lt;code&gt;never&lt;/code&gt; 반환 기능이 호출되면 TypeScript는 해당 기능이 제어 흐름 그래프에 영향을 미치고이를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">이제 Gulp를 실행하면 시작되어 계속 실행됩니다. &lt;code&gt;showHello&lt;/code&gt; 에서 &lt;code&gt;main.ts&lt;/code&gt; 의 코드를 변경 하고 저장해보십시오. 다음과 같은 출력이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 와 일치하는 항목을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b80d5fe66868146461ed39d9590423def0cc437" translate="yes" xml:space="preserve">
          <source>Now, for the remainder of the &lt;code&gt;createElement&lt;/code&gt; definition: &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt;. The first argument &lt;code&gt;tagName&lt;/code&gt; is defined as the generic parameter &lt;code&gt;K&lt;/code&gt; . The TypeScript interpreter is smart enough to &lt;em&gt;infer&lt;/em&gt; the generic parameter from this argument. This means that the developer does not actually have to specify the generic parameter when using the method; whatever value is passed to the &lt;code&gt;tagName&lt;/code&gt; argument will be inferred as &lt;code&gt;K&lt;/code&gt; and thus can be used throughout the remainder of the definition. Which is exactly what happens; the return value &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; takes the &lt;code&gt;tagName&lt;/code&gt; argument and uses it to return the corresponding type. This definition is how the &lt;code&gt;p&lt;/code&gt; variable from the code snippet gets a type of &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. And if the code was &lt;code&gt;document.createElement('a')&lt;/code&gt;, then it would be an element of type &lt;code&gt;HTMLAnchorElement&lt;/code&gt;.</source>
          <target state="translated">이제 나머지 &lt;code&gt;createElement&lt;/code&gt; 정의 : &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt; . 첫 번째 인수 &lt;code&gt;tagName&lt;/code&gt; 은 일반 매개 변수 &lt;code&gt;K&lt;/code&gt; 로 정의됩니다 . TypeScript 인터프리터는 이 인수에서 일반 매개 변수 를 &lt;em&gt;추론 할 수&lt;/em&gt; 있을만큼 똑똑 합니다. 이는 개발자가 메소드를 사용할 때 실제로 일반 매개 변수를 지정할 필요가 없음을 의미합니다. &lt;code&gt;tagName&lt;/code&gt; 인수에 전달되는 값은 &lt;code&gt;K&lt;/code&gt; 로 추론 되므로 나머지 정의에서 사용할 수 있습니다. 정확히 무슨 일이 일어나는지; 반환 값 &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; 는 &lt;code&gt;tagName&lt;/code&gt; 을 사용합니다.인수를 사용하고 해당 유형을 반환하는 데 사용합니다. 이 정의는 코드 스 니펫 의 &lt;code&gt;p&lt;/code&gt; 변수가 &lt;code&gt;HTMLParagraphElement&lt;/code&gt; 유형을 가져 오는 방법입니다 . 코드가 &lt;code&gt;document.createElement('a')&lt;/code&gt; 이면 &lt;code&gt;HTMLAnchorElement&lt;/code&gt; 유형의 요소가됩니다 .</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">널 및 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">널 및 정의되지 않은 인식 유형</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">널 입력 가능 유형</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">Nullable 유형 은 &lt;code&gt;strictNullChecks&lt;/code&gt; 가 설정된 경우에만 의미 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">널리 한 병합</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">객체 유형의 숫자 ​​형 속성은 숫자 리터럴 또는 숫자 리터럴 유형의 계산 된 속성 이름을 사용하여 선언 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">숫자 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">숫자 열거 형</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">숫자 열거 형은 &lt;a href=&quot;#computed-and-constant-members&quot;&gt;계산 멤버와 상수 멤버&lt;/a&gt; 로 혼합 될 수 있습니다 (아래 참조) . 짧은 이야기는, 초기화자가없는 열거 형이 먼저 필요하거나 숫자 상수 또는 다른 상수 열거 형 멤버로 초기화 된 숫자 열거 형 뒤에 와야한다는 것입니다. 즉, 다음은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">숫자 분리기</target>
        </trans-unit>
        <trans-unit id="8ec915a9d6271aa88a6e6bab3fe9b7a8d9dc2808" translate="yes" xml:space="preserve">
          <source>OOP in TypeScript</source>
          <target state="translated">TypeScript의 OOP</target>
        </trans-unit>
        <trans-unit id="54e96ab681e7258c80946a74a514f141957d53b7" translate="yes" xml:space="preserve">
          <source>OOP programmers are accustomed to being able to query the type of any value, even a generic one:</source>
          <target state="translated">OOP 프로그래머는 일반적인 값을 포함하여 모든 값의 유형을 쿼리 할 수있는 데 익숙합니다.</target>
        </trans-unit>
        <trans-unit id="adeb8baadb7619ed1ee71c0d637100cf68745ddb" translate="yes" xml:space="preserve">
          <source>OOP programmers are often surprised by two particular aspects of structural typing.</source>
          <target state="translated">OOP 프로그래머는 종종 구조적 타이핑의 두 가지 특정 측면에 놀라곤합니다.</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">물체 퍼짐 및 휴식</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">객체 파괴</target>
        </trans-unit>
        <trans-unit id="1ccb033a21e86f3dd077314deacc164caf7a1572" translate="yes" xml:space="preserve">
          <source>Object literal type syntax closely mirrors object literal value syntax:</source>
          <target state="translated">객체 리터럴 유형 구문은 객체 리터럴 값 구문과 거의 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">객체 리터럴은 개방형입니다.</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">객체 리터럴은 인덱스 서명 &lt;code&gt;[x:string]: any&lt;/code&gt; 이있는 것처럼 동작 합니다.이 객체는 닫힌 객체 대신 열린 맵으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">오브젝트 레스트는 요소를 파괴 할 때 선택되지 않은 추가 속성을 추출 할 수 있다는 점에서 오브젝트 스프레드의 이중입니다.</target>
        </trans-unit>
        <trans-unit id="e39aafc54b41f807d4c66cedbf76e1c69bb09f15" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">개체 확산에는 몇 가지 다른 놀라운 한계가 있습니다. 첫째, 개체 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;고유의 열거 가능한 속성&lt;/a&gt; 만 포함합니다 . 기본적으로 이는 객체의 인스턴스를 퍼뜨릴 때 메서드를 잃는다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">개체 확산에는 몇 가지 놀라운 한계가 있습니다. 먼저, 객체 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;자체의 열거 가능한 속성&lt;/a&gt; 만 포함합니다 . 기본적으로 객체의 인스턴스를 펼치면 메소드가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">속성이있는 객체</target>
        </trans-unit>
        <trans-unit id="e74f2b06a5fbe1c04ad866d78d3e98d6af48f45f" translate="yes" xml:space="preserve">
          <source>Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">경우에 따라 매개 변수가 &lt;code&gt;number&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 될 것으로 예상하는 라이브러리를 보게됩니다 . 예를 들어, 다음 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b8b413b8349b0d2cda00f56b58728dca71d8f18" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using TypeScript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">물론, 이러한 유형의 단일 라인에서 타이프 라이터 구문을 사용하여 선언 할 수 &lt;code&gt;@typedef&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">물론 이러한 유형은 단일 줄 &lt;code&gt;@typedef&lt;/code&gt; 에서 Typescript 구문을 사용하여 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">물론 이것은 JavaScript이기 때문에 신경 쓰지 않는 후행 요소를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">물론, 그것은 기분이 좋지 않을 수 있습니다. TypeScript를 지원하는 편집기에서 해당 파일을 열거 나 (또는 &lt;code&gt;tsc --pretty&lt;/code&gt; 를 실행하는 경우 ) 특정 행에 빨간색 표시가 나타날 수 있습니다. Microsoft Word와 같은 편집기에서 빨간색 구불 구불 한 생각과 동일한 방식으로 생각해야합니다. Word에서 문서를 인쇄 할 수있는 것처럼 TypeScript는 여전히 코드를 번역합니다.</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">매개 변수와 리턴 유형 만 기능 유형을 구성합니다. 캡처 된 변수는 유형에 반영되지 않습니다. 실제로, 캡처 된 변수는 함수의 &quot;숨겨진 상태&quot;의 일부이며 API를 구성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58d8c4b2203739a560ee5629e213ae51b2e9cc9a" translate="yes" xml:space="preserve">
          <source>Offers a way to configure the root directory for where declaration files are emitted.</source>
          <target state="translated">선언 파일이 생성되는 루트 디렉토리를 구성하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">공식 TypeScript NuGet 패키지</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">종종 프로젝트에는 여러 개의 출력 대상 (예 : &lt;code&gt;ES5&lt;/code&gt; 및 &lt;code&gt;ES2015&lt;/code&gt; , 디버그 및 프로덕션 또는 &lt;code&gt;CommonJS&lt;/code&gt; 및 &lt;code&gt;System&lt;/code&gt; . 이 두 대상간에 몇 가지 구성 옵션 만 변경하면 여러 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 유지 관리하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">종종 Node.js 애플리케이션에서 &lt;code&gt;.json&lt;/code&gt; 이 필요합니다. TypeScript 2.9에서는 &lt;code&gt;--resolveJsonModule&lt;/code&gt; 을 사용하여 &lt;code&gt;.json&lt;/code&gt; 파일 에서 가져 오기, 유형 추출 및 생성이 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">종종 모듈은 다른 모듈을 확장하고 일부 기능을 부분적으로 노출합니다. 다시 내보내기는 로컬로 가져 오거나 로컬 변수를 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">종종 프로젝트에 TypeScript로 제작되지 않은 외부 소스 파일이 있습니다. 또는 JS 코드베이스를 TS로 변환하는 중이지만 새 TS 코드의 출력을 사용하여 모든 JS 코드를 단일 파일로 번들링하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">종종 모듈의 기능을 확장해야합니다. 일반적인 JS 패턴은 JQuery 확장이 작동하는 방식과 유사하게 원래 객체를 &lt;em&gt;확장 기능&lt;/em&gt; 으로 보강하는 것입니다. 앞에서 언급했듯이 모듈은 전역 네임 스페이스 객체처럼 &lt;em&gt;병합&lt;/em&gt; 되지 않습니다 . 권장되는 솔루션은 원래 객체를 변경 &lt;em&gt;하지&lt;/em&gt; 않고 새로운 기능을 제공하는 새 엔티티를 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">한 줄로 :</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">여러 줄에서 :</target>
        </trans-unit>
        <trans-unit id="b121f75269ef9070c6142e71c944032a79d56440" translate="yes" xml:space="preserve">
          <source>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on &lt;code&gt;node_modules&lt;/code&gt; and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in &lt;code&gt;node_modules&lt;/code&gt;, whereas there are way fewer directories to track.</source>
          <target state="translated">Linux와 같은 운영 체제에서 TypeScript는 &lt;code&gt;node_modules&lt;/code&gt; 및 많은 하위 디렉터리에 디렉터리 감시자 (파일 감시자와 반대)를 설치 하여 종속성의 변경 사항을 감지합니다. 사용 가능한 파일 감시자의 수는 종종 &lt;code&gt;node_modules&lt;/code&gt; 의 파일 수에 의해 가려지는 반면 추적 할 디렉토리가 훨씬 적기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">스 니펫의 마지막 줄에서 전체 &lt;code&gt;ReadonlyArray&lt;/code&gt; 를 일반 배열에 다시 할당하는 것조차 불법임을 알 수 있습니다. 그래도 유형 어설 션으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">조직 전면에서 네임 스페이스는 논리적으로 관련된 개체와 유형을 전역 적으로 그룹화하는 데 편리합니다. 예를 들어 C #에서는 System.Collections에서 모든 컬렉션 유형을 찾습니다. 유형을 계층 적 네임 스페이스로 구성하여 해당 유형의 사용자에게 좋은 &quot;발견&quot;경험을 제공합니다. 반면에 모듈은 반드시 파일 시스템에 이미 존재합니다. 경로와 파일 이름으로 해결해야하므로 사용할 수있는 논리적 구성 체계가 있습니다. 리스트 모듈이있는 / collections / generic / 폴더를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">반면에 인터페이스로 모양을 표현할 수없고 공용체 또는 튜플 형식을 사용해야하는 경우 일반적으로 형식 별칭이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">반면, &lt;code&gt;forEach&lt;/code&gt; 와 같은 메소드 는 이제 호출 가능하지만 &lt;code&gt;noImplicitAny&lt;/code&gt; 에서는 몇 가지 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">일단 정의되면 다른 인터페이스와 마찬가지로이 함수 유형 인터페이스를 사용할 수 있습니다. 여기에서는 함수 유형의 변수를 작성하고 동일한 유형의 함수 값을 지정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">클래스 유형이 설정되면 인스턴스 유형은 클래스 유형의 구성 또는 호출 서명 (둘 중 존재하는 것)의 리턴 유형을 결합하여 결정됩니다. 다시 ES6 클래스의 경우 인스턴스 유형은 해당 클래스의 인스턴스 유형이되고 팩토리 함수의 경우 함수에서 반환 된 값의 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">파일이 여러 개 있으면 컴파일 된 코드가 모두로드되는지 확인해야합니다. 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">일반 아이덴티티 함수를 작성하면 두 가지 방법 중 하나로 호출 할 수 있습니다. 첫 번째 방법은 type 인수를 포함한 모든 인수를 함수에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="efd9fd3ef569813fe54f40f7a5348da23bd676a1" translate="yes" xml:space="preserve">
          <source>Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it&amp;rsquo;s awkward to pass around a value that is &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, because there isn&amp;rsquo;t a single type that represents this sort of value.</source>
          <target state="translated">유형을 세트로 생각하기 시작하면 특정 작업이 매우 자연스러워집니다. 예를 들어, C #으로, 그것은이다 값 주위를 통과 어색한 &lt;em&gt;중 하나 &lt;/em&gt; &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;int&lt;/code&gt; 값의 종류를 나타내는 단일 유형이 없기 때문에.</target>
        </trans-unit>
        <trans-unit id="cd09b9672aef2e12094c6286dae7bf22bea682c2" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re feeling comfortable, you can come back to read &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;TypeScript for JavaScript Programmers&lt;/a&gt;, then start on &lt;a href=&quot;intro&quot;&gt;the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="translated">편안 &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;해지면 JavaScript 프로그래머 용 TypeScript를&lt;/a&gt; 다시 읽은 다음 &lt;a href=&quot;intro&quot;&gt;핸드북에서&lt;/a&gt; 시작 하거나 &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;플레이 그라운드 예제를 살펴볼 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">이것의 한 가지 장점은 호출 가능한 생성자 패턴을 쉽게 표현할 수 있고 네임 스페이스를 이러한 선언과 병합 할 수 있다는 것입니다 ( &lt;code&gt;var&lt;/code&gt; 선언은 &lt;code&gt;namespace&lt;/code&gt; 와 병합 할 수 없으므로 ).</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">한 가지 일반적인 작업은 기존 유형을 사용하여 각 속성을 완전히 선택적으로 만드는 것입니다. &lt;code&gt;Person&lt;/code&gt; 이 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">이전 예제와의 한 가지 차이점은 생성자 함수를 포함하는 각 파생 클래스 는 기본 클래스의 생성자를 실행하는 &lt;code&gt;super()&lt;/code&gt; 를 호출 &lt;em&gt;해야한다는&lt;/em&gt; 것입니다. 우리가 전에, 무엇보다 &lt;em&gt;지금까지&lt;/em&gt; 의 속성에 접근 &lt;code&gt;this&lt;/code&gt; 생성자 본문에, 우리는 &lt;em&gt;이&lt;/em&gt; 호출 &lt;code&gt;super()&lt;/code&gt; . 이것은 TypeScript가 적용 할 중요한 규칙입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">한 가지 차이점은 인터페이스가 모든 곳에서 사용되는 새로운 이름을 생성한다는 것입니다. 유형 별칭은 새 이름을 만들지 않습니다. 예를 들어 오류 메시지는 별칭 이름을 사용하지 않습니다. 아래의 코드에서 유혹 &lt;code&gt;interfaced&lt;/code&gt; 그것이 반환 표시됩니다 편집기에서 &lt;code&gt;Interface&lt;/code&gt; ,하지만 표시됩니다 &lt;code&gt;aliased&lt;/code&gt; 반환 문자 오브젝트 유형.</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">이 규칙의 한 가지 예외는 특수 서명입니다. 서명에 유형이 &lt;em&gt;단일&lt;/em&gt; 문자열 리터럴 유형 (예 : 문자열 리터럴의 결합이 아님) 인 매개 변수가있는 경우 병합 된 과부하 목록의 상단으로 버블 링됩니다.</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">놀랍게도 이러한 검사를 해결하는 마지막 방법 중 하나는 객체를 다른 변수에 할당하는 것입니다 . &lt;code&gt;squareOptions&lt;/code&gt; 는 과도한 속성 검사를받지 않으므로 컴파일러에서 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">이 하나의 큰 장점은 볼 수 있다는 것입니다 &lt;em&gt;방법을 적은&lt;/em&gt; 암시 &lt;code&gt;any&lt;/code&gt; 실행시 오류를 &lt;code&gt;--noImplicitAny&lt;/code&gt; . 컴파일러가 유형 주석없이 변수의 유형을 알 수없는 경우에만 내재 &lt;code&gt;any&lt;/code&gt; 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">주변 열거 형과 주변이 아닌 열거 형의 중요한 차이점 중 하나는 일반 열거 형에서는 이니셜 라이저가없는 멤버는 이전 열거 형 멤버가 상수로 간주 될 경우 상수로 간주된다는 것입니다. 반대로 이니셜 라이저가없는 앰비언트 (및 비 const) 열거 형 멤버는 &lt;em&gt;항상&lt;/em&gt; 계산 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b053fca39618dd4a858f60861664a6e5ed2adab" translate="yes" xml:space="preserve">
          <source>One is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">하나는 &lt;code&gt;as&lt;/code&gt; 구문입니다.</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">TypeScript의 핵심 원칙 중 하나는 유형 검사 가 값 의 &lt;em&gt;모양에&lt;/em&gt; 중점을 둔다 는 것입니다. 이것을 &quot;덕 타이핑&quot;또는 &quot;구조적 서브 타이핑&quot;이라고도합니다. TypeScript에서 인터페이스는 이러한 유형의 이름을 지정하는 역할을하며 프로젝트 외부의 코드와 계약뿐만 아니라 코드 내에서 계약을 정의하는 강력한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c757d0f6603eddb47aa6c55cbe608a6509f704fb" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural typing&amp;rdquo;.</source>
          <target state="translated">TypeScript의 핵심 원칙 중 하나는 유형 검사 가 값 의 &lt;em&gt;모양에&lt;/em&gt; 초점을 맞추는 것입니다. 이를 &quot;덕 타이핑&quot;또는 &quot;구조 타이핑&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">클래스가 특정 계약을 충족하도록 명시 적으로 적용하는 C # 및 Java와 같은 언어에서 인터페이스의 가장 일반적인 용도 중 하나는 TypeScript에서도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window.someName&lt;/code&gt; 에 대한 하나 이상의 할당</target>
        </trans-unit>
        <trans-unit id="48a39bde8026af120315f595a3ebaf87946a36c6" translate="yes" xml:space="preserve">
          <source>One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added are included in the export.</source>
          <target state="translated">CommonJS에서 내보내는 한 가지 스타일은 함수를 내보내는 것입니다. 함수도 객체이기 때문에 내보내기에 추가 필드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">그러한 예 중 하나는 추가 속성을 가진 함수와 객체의 역할을하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">한 가지 주목할 점은 &lt;code&gt;const&lt;/code&gt; 어설 션은 간단한 리터럴 표현식에만 즉시 적용될 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">'.d.ts'선언 파일 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7c44d3d53fcf28280aed7f275c80df87912e368d" translate="yes" xml:space="preserve">
          <source>Only emit &lt;code&gt;.d.ts&lt;/code&gt; declaration files.</source>
          <target state="translated">&lt;code&gt;.d.ts&lt;/code&gt; 선언 파일 만 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">브라우저에서 &lt;code&gt;greeter.html&lt;/code&gt; 을 열어 첫 번째 간단한 TypeScript 웹 응용 프로그램을 실행하십시오!</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">열기 &lt;strong&gt;종속성&amp;gt;&amp;gt; 찾아보기를 NuGet 패키지를 관리 할 수 있습니다. &lt;/strong&gt; &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; 및 &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; 를 검색하여 설치 하십시오 .</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">&lt;code&gt;Startup.cs&lt;/code&gt; 파일을 열고 다음과 같이 &lt;code&gt;Configure&lt;/code&gt; 기능을 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">&lt;code&gt;--outDir&lt;/code&gt; 옵션 은 출력에서 ​​입력 계층을 복제합니다. 컴파일러는 입력 파일의 루트를 모든 입력 파일의 가장 긴 공통 경로로 계산합니다. 그런 다음이를 사용하여 모든 하위 구조를 출력에 복제합니다.</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">선택적 &lt;code&gt;catch&lt;/code&gt; 절 변수</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">옵션 체인</target>
        </trans-unit>
        <trans-unit id="7639a6c68ad000bff451144276aba49f18f3a141" translate="yes" xml:space="preserve">
          <source>Optional Global Usage</source>
          <target state="translated">선택적 글로벌 사용</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">선택적 모듈 로딩 및 기타 고급 로딩 시나리오</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">선택적 매개 변수 및 나머지 매개 변수</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">콜백의 선택적 매개 변수</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">선택적 속성</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">선택적 및 기본 매개 변수</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">선택적 체인에는 두 가지 다른 작업도 포함됩니다. 먼저 선택적 속성 액세스와 유사하게 작동하지만 식별자가 아닌 속성 (예 : 임의의 문자열, 숫자 및 기호)에 액세스 할 수 있는 &lt;em&gt;선택적 요소 액세스&lt;/em&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">선택적 체이닝은 이슈 트래커의 이슈 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;# 16&lt;/a&gt; 입니다. 문맥 상, 그 이후로 TypeScript 이슈 트래커에 23,000 개가 넘는 이슈가있었습니다.</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">선택적 클래스 속성</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">튜플 유형의 선택적 요소</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">튜플 유형의 선택적 요소</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">선택적 매개 변수 및 특성</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">선택적 매개 변수와 속성에는 형식 주석에 &lt;code&gt;undefined&lt;/code&gt; 가 포함되어 있지 않은 경우에도 형식에 자동으로 &lt;code&gt;undefined&lt;/code&gt; 가 추가됩니다 . 예를 들어 다음 두 가지 유형이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">인터페이스에서 이미 허용 된 것과 유사한 클래스에서 선택적 속성 및 메서드를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">선택 사항 : Visual Studio에서 &lt;code&gt;greeter.ts&lt;/code&gt; 를 열거 나 코드를 TypeScript 놀이터로 복사하십시오. 식별자 위에 마우스를 올려 놓으면 해당 유형을 볼 수 있습니다. 경우에 따라 이러한 유형이 자동으로 유추됩니다. 마지막 행을 다시 입력하고 DOM 요소 유형에 따라 완료 목록 및 매개 변수 도움말을 참조하십시오. greeter 함수에 대한 참조에 커서를 놓고 F12를 눌러 정의로 이동하십시오. 또한 심볼을 마우스 오른쪽 버튼으로 클릭하고 리팩토링을 사용하여 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">선택적으로 모듈은 하나 이상의 모듈을 랩핑하고 &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; 구문을 사용하여 모든 내보내기를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df58492b3818e56d4c38cba029dab1a47423cc16" translate="yes" xml:space="preserve">
          <source>Or a number:</source>
          <target state="translated">또는 숫자 :</target>
        </trans-unit>
        <trans-unit id="c98dcc822443a4b856eb1d3e76f5a1ef879a05c5" translate="yes" xml:space="preserve">
          <source>Or by marking each export individually:</source>
          <target state="translated">또는 각 내보내기를 개별적으로 표시하여 :</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">또는 후행 요소 나 다른 요소는 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">또는 다른 요소들 :</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">또는 읽기 전용 버전을 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">또는 지정되지 않은 것을 사용할 수 있습니다. &lt;code&gt;Function&lt;/code&gt; 유형을 .</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">또는 열거 형의 모든 값을 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">또는, 우리는 사용하여 식별 기능을 설명 할 수 &lt;code&gt;any&lt;/code&gt; 유형을 .</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">조직 유형</target>
        </trans-unit>
        <trans-unit id="62cda73390e4d48b545b79bfcdb477a68054f2e3" translate="yes" xml:space="preserve">
          <source>Other important TypeScript types</source>
          <target state="translated">기타 중요한 TypeScript 유형</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Closure의 다른 유형도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">다른 변형도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9840b9a741b28ca4c8860ce6d87a0177a3a2e4c4" translate="yes" xml:space="preserve">
          <source>Otherwise</source>
          <target state="translated">Otherwise</target>
        </trans-unit>
        <trans-unit id="f12741a8f50c8d0742198f4cc7b9b0054355cfbe" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;--keyofStringsOnly&lt;/code&gt; 를 사용 하십시오. 컴파일러 옵션을 사용하여 새 동작을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">그렇지 않으면 조건이 하나 이상의 유형 변수에 의존하고 조건 유형이 연기됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe09ba85c2f62b83a765f71cc1cff43f6cbaef7" translate="yes" xml:space="preserve">
          <source>Otherwise, these functions accept any arguments and will return &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">그렇지 않으면 이러한 함수는 모든 인수를 받아들이고 다음을 반환 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면, 우리는 이미 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 과 함께 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 를 사용하고 있다고 가정합니다. .</target>
        </trans-unit>
        <trans-unit id="6a8d8f3092b4cff717b9df2b61723845c6880cb0" translate="yes" xml:space="preserve">
          <source>Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the &lt;code&gt;@types&lt;/code&gt; organization on npm.</source>
          <target state="translated">그렇지 않으면 유형을 DefinitelyTyped에 제출하여 npm 의 &lt;code&gt;@types&lt;/code&gt; 조직에 게시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">첫 인터페이스</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">우리 패키지는 각각의 선언을 공개하므로 &lt;code&gt;browserify-typescript-extension&lt;/code&gt; 패키지 의 모든 사용자 는 이러한 의존성을 가져야합니다. 따라서 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; 가 아닌 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 를 사용했습니다. 그렇지 않으면 소비자가 해당 패키지를 수동으로 설치해야했기 때문입니다. 명령 행 애플리케이션을 방금 작성했지만 패키지가 라이브러리로 사용될 것으로 예상하지 않은 경우 &lt;code&gt;devDependencies&lt;/code&gt; 를 사용 했을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9be54203007d8d30f26947bb7d7851872869089d" translate="yes" xml:space="preserve">
          <source>Out - &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">아웃- &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcdf8d59b6859bfc492a315ea8318c5d9803cadf" translate="yes" xml:space="preserve">
          <source>Out Dir - &lt;code&gt;outDir&lt;/code&gt;</source>
          <target state="translated">Out Dir - &lt;code&gt;outDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27a751e953fed78cf12f40a39506ec48371ed775" translate="yes" xml:space="preserve">
          <source>Out File - &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">아웃 파일 &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">출력 파일 확장자</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">생성 된 선언 파일의 출력 디렉토리.</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">출력 생성</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; 외부 파일 에서 꺾쇠 괄호 어설 션 구문도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9668372e49b3da9f21e77e4a98e554bc74a9a36" translate="yes" xml:space="preserve">
          <source>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript&amp;rsquo;s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</source>
          <target state="translated">프로그래밍 커뮤니티에 소개 된 지 20 년이 지난 지금 JavaScript는 지금까지 만들어진 가장 널리 퍼진 크로스 플랫폼 언어 중 하나입니다. 웹 페이지에 사소한 상호 작용을 추가하기위한 작은 스크립팅 언어로 시작하여 JavaScript는 모든 크기의 프런트 엔드 및 백엔드 응용 프로그램에서 선택하는 언어로 성장했습니다. JavaScript로 작성된 프로그램의 크기, 범위 및 복잡성은 기하 급수적으로 증가했지만 다른 코드 단위 간의 관계를 표현하는 JavaScript 언어의 능력은 그렇지 않습니다. JavaScript의 다소 특이한 런타임 의미 체계와 결합하여 언어와 프로그램 복잡성 간의 이러한 불일치는 JavaScript 개발을 대규모로 관리하기 어려운 작업으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">전반적인 구조</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">과부하 기능</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">과부하 된 기능</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">과부하 및 콜백</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3db8119e7d2abacd7ddc5a64f7223117366fcdc7" translate="yes" xml:space="preserve">
          <source>Package.json</source>
          <target state="translated">Package.json</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; 조직의 패키지 는 &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher 도구를&lt;/a&gt; 사용하여 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; 에서 자동으로 게시됩니다 . 선언을 @types 패키지로 게시하려면 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped에&lt;/a&gt; 풀 요청을 제출 하십시오 . &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;기여 지침 페이지&lt;/a&gt; 에서 자세한 내용을 확인할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="84bd5a555866968aa5aa6d7b7d92dc740334b9d1" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; 조직의 패키지 는 &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher 도구를&lt;/a&gt; 사용하여 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; 에서 자동으로 게시됩니다 . 선언을 @types 패키지로 게시하려면 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped에&lt;/a&gt; pull 요청을 제출하십시오 . &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;기여 지침 페이지&lt;/a&gt; 에서 자세한 내용을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">패키징 종속 선언</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">파라미터 데코레이터</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">파라미터 속성</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">매개 변수 속성은 생성자 매개 변수 앞에 접근성 수정 자 또는 &lt;code&gt;readonly&lt;/code&gt; 또는 둘 다를 붙여서 선언 합니다. 매개 변수 속성에 &lt;code&gt;private&lt;/code&gt; 을 사용하면 개인 구성원을 선언하고 초기화합니다. 마찬가지로 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 에 대해서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">이름이 &lt;code&gt;_&lt;/code&gt; 로 시작하는 매개 변수 선언 은 사용되지 않은 매개 변수 검사에서 제외됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">엄격 모드에서 구문 분석하고 각 소스 파일에 대해 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">엄격 모드에서 모든 코드를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">컴포지트 프로젝트 ( &lt;code&gt;composite&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 &lt;code&gt;tsconfig.json&lt;/code&gt; ) 의 의도 중 하나는 다른 프로젝트 간의 참조를 증분 적으로 빌드 할 수 있다는 것입니다. 따라서 복합 프로젝트는 &lt;strong&gt;항상 &lt;/strong&gt; &lt;code&gt;.tsbuildinfo&lt;/code&gt; 파일을 생성 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5be6f8582750be194de793f18c152404f2f31a1" translate="yes" xml:space="preserve">
          <source>Pass it an element id string and it will return either &lt;code&gt;HTMLElement&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; . This method introduces one of the most important types, &lt;code&gt;HTMLElement&lt;/code&gt;. It serves as the base interface for every other element interface. For example, the &lt;code&gt;p&lt;/code&gt; variable in the code example is of type &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. Also take note that this method can return &lt;code&gt;null&lt;/code&gt;. This is because the method can&amp;rsquo;t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new &lt;em&gt;optional chaining&lt;/em&gt; operator is used in order to call &lt;code&gt;appendChild&lt;/code&gt;.</source>
          <target state="translated">요소 ID 문자열을 전달하면 &lt;code&gt;HTMLElement&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 이 메소드는 가장 중요한 유형 중 하나 인 &lt;code&gt;HTMLElement&lt;/code&gt; 를 소개 합니다. 다른 모든 요소 인터페이스의 기본 인터페이스 역할을합니다. 예를 들어 코드 예제 의 &lt;code&gt;p&lt;/code&gt; 변수는 &lt;code&gt;HTMLParagraphElement&lt;/code&gt; 유형 입니다 . 또한이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 있습니다 . 이는 메서드가 지정된 요소를 실제로 찾을 수 있는지 여부를 확인할 수있는 경우 특정 사전 런타임이 될 수 없기 때문입니다. 코드 조각의 마지막 줄 에서 &lt;code&gt;appendChild&lt;/code&gt; 를 호출하기 위해 새로운 &lt;em&gt;선택적 연결&lt;/em&gt; 연산자가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--jsx react&lt;/code&gt; 와 함께 &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; 을 전달 하면 기본 &lt;code&gt;React&lt;/code&gt; 와 다른 JSX 팩토리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">경로 매핑</target>
        </trans-unit>
        <trans-unit id="a3a3e9569fa3eb5fb1f186e97032bcfd280061ac" translate="yes" xml:space="preserve">
          <source>Paths - &lt;code&gt;paths&lt;/code&gt;</source>
          <target state="translated">경로- &lt;code&gt;paths&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">지원되지 않는 것으로 알려진 패턴</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">파일 별 JSX 팩토리</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">별도의 컴파일 ( &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript 등&lt;/a&gt; )이 안전한지 확인하기 위해 추가 검사를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">성능 개선</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">네임 스페이스 및 모듈의 함정</target>
        </trans-unit>
        <trans-unit id="b9fa3258f08647142ce462aa1c6002ef1e1b8662" translate="yes" xml:space="preserve">
          <source>Platform specific</source>
          <target state="translated">플랫폼 별</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">컴파일러에는 출력이 가능한 파일이 포함되어 있지 않습니다. 상기 입력을 포함하는 경우 등 &lt;code&gt;index.ts&lt;/code&gt; 을 다음 &lt;code&gt;index.d.ts&lt;/code&gt; 및 &lt;code&gt;index.js&lt;/code&gt; 제외된다. 일반적으로 확장자 만 다른 파일은 서로 옆에 두지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">이 설명은 오류보고 만 억제 &lt;em&gt;하므로이&lt;/em&gt; 설명은 &lt;em&gt;매우 드물게&lt;/em&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">이것은 배열이 아닌 값에 대해 런타임에 기본 &lt;code&gt;Symbol.iterator&lt;/code&gt; 또는 &lt;code&gt;Symbol.iterator&lt;/code&gt; shim을 필요로 합니다.</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">타입 스크립트를위한 유일한 로더는 ts-loader가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">것을 통지하십시오 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 를 기준으로 해결된다 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; . 설정하는 경우 &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; 아닌 다른 값으로 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 즉, &lt;code&gt;tsconfig.json&lt;/code&gt; 디렉토리와 같이 매핑을 적절히 변경해야합니다. 말, 당신은 설정 &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; , 다음 JQuery와 매핑해야 위의 예에서 &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ee1de1fe598e71ad53be227754dfcb283d7c826" translate="yes" xml:space="preserve">
          <source>Plugins - &lt;code&gt;plugins&lt;/code&gt;</source>
          <target state="translated">플러그인- &lt;code&gt;plugins&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d901da355d2ea7de032bab6160e7791b0cc0d9bd" translate="yes" xml:space="preserve">
          <source>Point-free programming</source>
          <target state="translated">포인트 프리 프로그래밍</target>
        </trans-unit>
        <trans-unit id="9a6adebfdf8f61c41e82811b81640f526a81d347" translate="yes" xml:space="preserve">
          <source>Point-free programming &amp;mdash; heavy use of currying and function composition &amp;mdash; is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you&amp;rsquo;ll end up specifying type parameters instead of value parameters. The result is so verbose that it&amp;rsquo;s usually better to avoid point-free programming.</source>
          <target state="translated">점없는 프로그래밍 (커링 및 함수 구성의 과도한 사용)은 JavaScript에서 가능하지만 장황 할 수 있습니다. TypeScript에서 유형 추론은 포인트없는 프로그램에 대해 종종 실패하므로 값 매개 변수 대신 유형 매개 변수를 지정하게됩니다. 결과는 너무 장황하여 일반적으로 포인트 프리 프로그래밍을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형의 다형성</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">이 유형의 다형성</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">Postfix는 객체 리터럴 유형의 속성 유형과 같으며 선택적 속성을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">미리 정의 된 조건 유형</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">프로젝트를 추가하면 현재 프로젝트 출력 위에 프로젝트 출력이 포함됩니다. 이것은 &lt;code&gt;.js&lt;/code&gt; 파일과 &lt;code&gt;.d.ts&lt;/code&gt; 파일 모두에서 작동 하며 소스 맵 파일도 올바르게 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">전처리 입력 파일</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="3718a89b87a1c09f9d2b2ab9ae6694d53dd18a75" translate="yes" xml:space="preserve">
          <source>Preserve Const Enums - &lt;code&gt;preserveConstEnums&lt;/code&gt;</source>
          <target state="translated">헌장 열거 형을 유지 - &lt;code&gt;preserveConstEnums&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="144537ff5fbb1fe2e7112d7a59fca5f0abb8a715" translate="yes" xml:space="preserve">
          <source>Preserve Symlinks - &lt;code&gt;preserveSymlinks&lt;/code&gt;</source>
          <target state="translated">심볼릭 링크를 유지 - &lt;code&gt;preserveSymlinks&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="43e1ce16ca2c523a57cb24a6559708ada861d29c" translate="yes" xml:space="preserve">
          <source>Preserve Watch Output - &lt;code&gt;preserveWatchOutput&lt;/code&gt;</source>
          <target state="translated">감시 출력 &lt;code&gt;preserveWatchOutput&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1f0d63b565582e80417d45fc9ee92a490e7a966" translate="yes" xml:space="preserve">
          <source>Preserve: &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</source>
          <target state="translated">보존 : &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">더 예쁘다- &lt;code&gt;--pretty&lt;/code&gt; 출력</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 의 더 예쁜 오류 메시지</target>
        </trans-unit>
        <trans-unit id="7570791dbea8739420c045a800b27168c94bfd74" translate="yes" xml:space="preserve">
          <source>Pretty - &lt;code&gt;pretty&lt;/code&gt;</source>
          <target state="translated">예쁘다- &lt;code&gt;pretty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">이름 충돌 방지</target>
        </trans-unit>
        <trans-unit id="f3be47e0536b2f1e3942d188698143c3820e4e15" translate="yes" xml:space="preserve">
          <source>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</source>
          <target state="translated">이 문서의 이전 버전에서는 런타임과 유형 계층을 별도로 만든 다음 마지막에 병합하는 믹스 인을 작성하는 방법을 권장했습니다.</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">이전에는 CommonJS / AMD / UMD 모듈이 ES6 모듈과 동일한 방식으로 처리되어 몇 가지 문제가 발생했습니다. 즉:</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">이전에는 TypeScript 1.8에서 지원되는 오류가 발생했습니다. 루프 내에서 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 선언은 함수에서 캡처되어 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 신선도 의미 와 정확하게 일치 하도록 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">이전에는 유효하지 않은 플래그 조합으로 플래그가 지정된 &lt;code&gt;target: es5&lt;/code&gt; 및 'module : es6'이 지원됩니다. 이를 통해 &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt; 과 같은 ES2015 기반 트리 셰이커를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">이전에는 생성기가 대상이 ES6 / ES2015 이상인 경우에만 지원되었습니다. 또한, 반복자 프로토콜, 예에서 작동 구조 &lt;code&gt;for..of&lt;/code&gt; 는 그들이 ES6 / ES2015 아래 대상에 대해 배열에서 작동하는 경우에만 지원했다.</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">이전에는 &lt;code&gt;for..in&lt;/code&gt; 변수 의 유형은 &lt;code&gt;any&lt;/code&gt; ; 컴파일러가 &lt;code&gt;for..in&lt;/code&gt; 본문 내에서 유효하지 않은 사용을 무시하도록 허용했습니다 .</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">이전에는 두 가지 옵션이있었습니다.</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">이전 유형 &lt;code&gt;{}&lt;/code&gt; 이 (가) 에 대한 추정 된 &lt;code&gt;obj&lt;/code&gt; 하기 때문에 두 번째 줄 이후 오류가 발생 &lt;code&gt;obj&lt;/code&gt; 가 어떤 특성이없는 것으로 나타납니다. 그것은 이상적이지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">이전에는 비차별 노조가 구성원에 &lt;em&gt;대해&lt;/em&gt; 초과 재산 점검을 수행 하지 않았으므로 결과적으로 잘못 입력 된 &lt;code&gt;name&lt;/code&gt; 재산이 미끄러졌습니다.</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">이전에는 TypeScript가 변수 유형을 알아낼 수없는 경우 &lt;code&gt;any&lt;/code&gt; 유형을 선택했습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc73e847f1b3cd8d1dfb14f901fe12098f69eb7" translate="yes" xml:space="preserve">
          <source>Previously, this document details the &lt;code&gt;HTMLElement&lt;/code&gt; interface extends from &lt;code&gt;Element&lt;/code&gt; which extends from &lt;code&gt;Node&lt;/code&gt;. In the DOM API there is a concept of &lt;em&gt;children&lt;/em&gt; elements. For example in the following HTML, the &lt;code&gt;p&lt;/code&gt; tags are children of the &lt;code&gt;div&lt;/code&gt; element</source>
          <target state="translated">이전에이 문서 는 &lt;code&gt;Node&lt;/code&gt; 에서 확장되는 &lt;code&gt;Element&lt;/code&gt; 에서 확장 된 &lt;code&gt;HTMLElement&lt;/code&gt; 인터페이스에 대해 자세히 설명합니다 . DOM API에는 &lt;em&gt;자식&lt;/em&gt; 요소 의 개념이 &lt;em&gt;있습니다&lt;/em&gt; . 예를 들어 다음 HTML에서 &lt;code&gt;p&lt;/code&gt; 태그는 &lt;code&gt;div&lt;/code&gt; 요소의 자식입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">이전에는 단일 tsconfig 파일을 사용한 경우이 구조를 사용하는 것이 다소 어색했습니다.</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">도움말 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">편집의 일부 파일 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2c60c8260c586544fdf204a6918f732b286ae58d" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.</source>
          <target state="translated">컴파일의 일부 파일 이름을 인쇄합니다. 이것은 TypeScript에 예상 한 파일이 포함되어 있는지 확실하지 않을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b896feedfc6257fcbba34c3460737798c67b71a9" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation to the terminal.</source>
          <target state="translated">컴파일 과정에서 생성 된 파일의 이름을 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">컴파일 과정에서 생성 된 파일의 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">컴파일러 버전을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">3.3 이전에는 &lt;code&gt;--build --watch&lt;/code&gt; 를 사용하여 복합 프로젝트를 빌드 할 때 실제로이 증분 파일 감시 인프라를 사용하지 않았습니다. &lt;code&gt;--build --watch&lt;/code&gt; 모드 에서 한 프로젝트의 업데이트 는 해당 프로젝트 내의 파일이 영향을받는 것을 결정하지 않고 해당 프로젝트를 완전히 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">다음 예제에서 TypeScript 2.4 이전</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">TypeScript 2.4 이전에는이 ​​예제가 성공했습니다. &lt;code&gt;map&lt;/code&gt; 유형과 관련하여 TypeScript는 매개 변수 (예 : &lt;code&gt;f&lt;/code&gt; 유형)를 양방향으로 관련시킵니다 . 각 &lt;code&gt;f&lt;/code&gt; 와 관련하여 TypeScript는 &lt;em&gt;해당&lt;/em&gt; 매개 변수 의 유형을 양방향으로 관련시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9c8599d61f9484e744e8b2658bec61eec3a61688" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 3.8, you can import a type using &lt;code&gt;import&lt;/code&gt;. With TypeScript 3.8, you can import a type using the &lt;code&gt;import&lt;/code&gt; statement, or using &lt;code&gt;import type&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.8 이전에는 import를 사용하여 유형을 &lt;code&gt;import&lt;/code&gt; 있습니다. TypeScript 3.8에서는 &lt;code&gt;import&lt;/code&gt; 문을 사용하거나 &lt;code&gt;import type&lt;/code&gt; 을 사용하여 유형 을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">개인 및 보호 생성자</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">클래스의 개인 및 보호 멤버는 호환성에 영향을줍니다. 클래스의 인스턴스가 호환성을 검사 할 때 대상 유형에 개인 구성원이 포함 된 경우 소스 유형에도 동일한 클래스에서 시작된 개인 구성원이 포함되어야합니다. 마찬가지로 보호 멤버가있는 인스턴스에도 동일하게 적용됩니다. 이를 통해 클래스는 수퍼 클래스와 호환 가능하지만 다른 상속 계층 구조의 클래스와는 호환 &lt;em&gt;되지 않는&lt;/em&gt; 할당이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">수업 중 개인 및 보호 회원</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">프로젝트 구성</target>
        </trans-unit>
        <trans-unit id="dff8cdae331a987352af975febbbf5bf3497c075" translate="yes" xml:space="preserve">
          <source>Project Options</source>
          <target state="translated">프로젝트 옵션</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">프로젝트 참조</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">프로젝트 참조 : TypeScript의 빌드 모드</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">프로젝트 참조 :주의 사항</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">프로젝트 참조 : 프로젝트 참조를위한주의 사항</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">프로젝트 참조 : MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">프로젝트 참조 : 전체 구조</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">프로젝트 참조 서 : outFiles 구조화</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">프로젝트 참조 : 관련 모듈 구조화</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">프로젝트 참조 : 프로젝트 참조 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">프로젝트 참조 : 합성</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">프로젝트 참조 : declarationMaps</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">프로젝트 참조 : outFile 앞에 추가</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">프로젝트 참조 : tsc -b 명령 줄</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">프로젝트 참조는 TypeScript 3.0의 새로운 기능으로 TypeScript 프로그램을 더 작은 조각으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c138392855d638ba9e2bf29899810a7e57e84035" translate="yes" xml:space="preserve">
          <source>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</source>
          <target state="translated">프로젝트 참조는 TypeScript 프로그램을 더 작은 조각으로 구성하는 방법입니다. 프로젝트 참조를 사용하면 빌드 및 편집기 상호 작용 시간을 크게 개선하고 구성 요소 간의 논리적 분리를 적용하며 새롭고 향상된 방식으로 코드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">프로젝트 참조는 이러한 모든 문제 등을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">프로젝트 참조에는 알아야 할 몇 가지 상충 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 을 통한 프로젝트 지원</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">클래스 본문의 할당에서 속성이 유추됩니다</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">함수에 대한 속성 선언</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">객체 리터럴과 일치하지 않는 객체 바인딩 패턴의 속성은 객체 바인딩 패턴에 기본값이 있어야하며 객체 리터럴 유형에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">객체 바인딩 패턴과 일치하지 않는 객체 리터럴의 속성은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">객체 바인딩 패턴에 기본값이있는 속성은 객체 리터럴에서 선택 사항이됩니다.</target>
        </trans-unit>
        <trans-unit id="1af723998a3965fbd8fb5f43c4ba52d973f2b4be" translate="yes" xml:space="preserve">
          <source>Properties with relative paths found in the configuration file, which aren&amp;rsquo;t excluded from inheritance, will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">상속에서 제외되지 않은 구성 파일에서 찾은 상대 경로가있는 속성은 원래 구성 파일을 기준으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">부동산 데코레이터</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">속성 할당과 제네릭이 아닌 스프레드 식은 일반 스프레드 식의 양쪽에서 최대한 병합됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">속성 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">프로토 타입 할당</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">ES5 또는 ES3을 대상으로 할 때 반복 , 파괴 및 &lt;code&gt;for..of&lt;/code&gt; 에서 이터 러블 을 완벽하게 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="d26fd4d0603b6fec3f71df5845863025dd055f63" translate="yes" xml:space="preserve">
          <source>Providing Type Hints in JS via JSDoc</source>
          <target state="translated">JSDoc을 통해 JS에서 유형 힌트 제공</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">기본적으로 공개</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">공개, 개인 및 보호 수정 자</target>
        </trans-unit>
        <trans-unit id="51ca411182511e3fdf77719b4e3e0c22adc6e606" translate="yes" xml:space="preserve">
          <source>Publish to</source>
          <target state="translated">게시</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types에&lt;/a&gt; 게시</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">npm에 게시</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">게시 : 종속성</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">게시 : @types에 게시</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">출판 : 적기</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">리턴 라인에 중단 점을 두십시오.</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">위의 모든 규칙을 예제로 정리</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">함께 모아서</target>
        </trans-unit>
        <trans-unit id="c25bd9f882a3a8b49796dbe73c56bf10103c4152" translate="yes" xml:space="preserve">
          <source>Question to ask yourself while looking at a library you are trying to type.</source>
          <target state="translated">입력하려는 도서관을 보면서 스스로에게 물어보십시오.</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="translated">Quick introductions based on your background or preference.</target>
        </trans-unit>
        <trans-unit id="d8f6fe9f8c69850190c5d7fab3738cc93bedaed0" translate="yes" xml:space="preserve">
          <source>Raise error on &amp;lsquo;this&amp;rsquo; expressions with an implied &amp;lsquo;any&amp;rsquo; type.</source>
          <target state="translated">암시 된 'any'유형으로 'this'표현식에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">내재 된 &lt;code&gt;any&lt;/code&gt; 유형 &lt;code&gt;this&lt;/code&gt; 표현식에서 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">암시적인 &lt;code&gt;any&lt;/code&gt; 유형의 표현식 및 선언에서 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">실제로 다른 입력 옵션 및 구성 파일을 사용하여 빌드를 실행하는 대신 최종 암시 적 구성 파일을 출력에 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">다시 컴파일하면 이제 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">재 선언 및 그림자</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">연장하여 재수출</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">&lt;code&gt;tsc greeter.ts&lt;/code&gt; 를 다시 실행 하면 생성 된 JavaScript가 이전 코드와 동일 하다는 것을 알 수 있습니다. TypeScript의 클래스는 JavaScript에서 자주 사용되는 것과 동일한 프로토 타입 기반 OO의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">반응 및 웹팩</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">반응 및 웹팩 : TypeScript 구성 파일 추가</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">반응 및 웹팩 : 웹팩 구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">반응 및 웹팩 : 프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React &amp;amp; Webpack : 의존성 설치</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">반응 및 웹팩 : 프로젝트 배치</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">리 액트 및 웹팩 : 모두 통합</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">반응 및 웹팩 : 코드 작성</target>
        </trans-unit>
        <trans-unit id="7f185bfe20f1f619f8c9bb6aa99786b71328866a" translate="yes" xml:space="preserve">
          <source>React 17 dev transform: &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17 dev 변환 : &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d97070f74a67941c76e5ea64885d0e08627efa5" translate="yes" xml:space="preserve">
          <source>React 17 transform: &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">React 17 변환 : &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; &lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ae4b21d845bd34b4e6b6216731b5271028fb8f60" translate="yes" xml:space="preserve">
          <source>React Namespace - &lt;code&gt;reactNamespace&lt;/code&gt;</source>
          <target state="translated">React 네임 스페이스 &lt;code&gt;reactNamespace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">네이티브 반응</target>
        </trans-unit>
        <trans-unit id="fa58cb746f54f27aa90a8d689bba8023af13c2bb" translate="yes" xml:space="preserve">
          <source>React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</source>
          <target state="translated">React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">반응 통합</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">반응 네이티브 빌드 파이프 라인 은 파일에 JSX 구문이 포함되어 있어도 모든 파일에 &lt;code&gt;.js&lt;/code&gt; 확장자 가있을 것으로 예상 합니다. 새로운 &lt;code&gt;--jsx&lt;/code&gt; 값 &lt;code&gt;react-native&lt;/code&gt; 는 출력 파일에서 JSX 구문을 유지하지만 확장자 는 &lt;code&gt;.js&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ab19aed84f407a0ba739f934e0edb923766280c" translate="yes" xml:space="preserve">
          <source>Read and understand commonly-used TypeScript syntax and patterns</source>
          <target state="translated">일반적으로 사용되는 TypeScript 구문 및 패턴을 읽고 이해합니다.</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 디렉토리 에서 이해하는 모든 파일을 읽습니다 ( &lt;code&gt;include&lt;/code&gt; 포함 ).</target>
        </trans-unit>
        <trans-unit id="bc4702822c3373e5ee67caa1dc26cc74db6df18f" translate="yes" xml:space="preserve">
          <source>Read the full Handbook &lt;a href=&quot;intro&quot;&gt;from start to finish&lt;/a&gt; (30m)</source>
          <target state="translated">&lt;a href=&quot;intro&quot;&gt;처음부터 끝까지&lt;/a&gt; 전체 핸드북 읽기 (30 분)</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">읽기 전용 속성 및 인덱스 서명</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">읽기 전용 속성에는 이니셜 라이저가있을 수 있으며 동일한 클래스 선언 내의 생성자에 할당 될 수 있지만 그렇지 않으면 읽기 전용 속성에 대한 할당이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">읽기 전용 수정 자</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">읽기 전용 속성</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">준비된? 구경하다:</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">그러나 실제 응용 프로그램은 위의 &lt;code&gt;Readonly&lt;/code&gt; 또는 &lt;code&gt;Partial&lt;/code&gt; 처럼 보입니다 . 기존 유형을 기반으로하며 어떤 방식 으로든 속성을 변환합니다. 여기서 &lt;code&gt;keyof&lt;/code&gt; 및 indexed 액세스 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">타입 주장을 작성하는 방법을 상기하십시오 :</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Node.js는 &lt;code&gt;moduleB.js&lt;/code&gt; 라는 파일을 찾은 다음 적용 가능한 &lt;code&gt;package.json&lt;/code&gt; 을 찾은 다음 &lt;code&gt;index.js&lt;/code&gt; 를찾았습니다 .</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">이전의 &lt;code&gt;setTimeout&lt;/code&gt; 예제에서는 &lt;code&gt;for&lt;/code&gt; 루프가 반복 될 때마다 변수의 상태를 캡처하기 위해 IIFE를 사용해야했습니다 . 실제로 우리가하고 있던 일은 캡처 된 변수를위한 새로운 변수 환경을 만드는 것이 었습니다. 그것은 약간의 고통 이었지만 운 좋게도 TypeScript에서 다시는 그렇게 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="9ef937556efe782b8e9bf8ef16e540c185c5bf00" translate="yes" xml:space="preserve">
          <source>Recommended</source>
          <target state="translated">Recommended</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">붉은 깃발</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">붉은 깃발</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">출력 구조를 디렉토리로 경로 재 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f70cca9ad50ad5b8ed87a8010b088c10db5dda71" translate="yes" xml:space="preserve">
          <source>Reference Example</source>
          <target state="translated">참조 예</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">참조 된 프로젝트에는 새로운 &lt;code&gt;composite&lt;/code&gt; 설정이 활성화되어 있어야합니다 . 이 설정은 TypeScript가 참조 된 프로젝트의 출력을 찾을 위치를 빠르게 결정할 수 있도록하기 위해 필요합니다. &lt;code&gt;composite&lt;/code&gt; 플래그를 활성화하면 몇 가지 사항이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4d6f89c160b09f2d6743dec6ea31f5aef184e7a5" translate="yes" xml:space="preserve">
          <source>References - &lt;code&gt;references&lt;/code&gt;</source>
          <target state="translated">참조- &lt;code&gt;references&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e7e105e2839b4e1b747e4c6dae363b4ac3c64d8" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;const enum&lt;/code&gt; members</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; 멤버에 대한 참조</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">개체가 생성자 함수와 같은 형식을 만들지 않으면 값 공간의 개체를 형식으로 참조하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">상대 경로는 매우 간단합니다. 예를 들어, &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 에 있는 파일을 고려해 봅시다 . 여기에는 import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js는 다음 순서로 가져 오기를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">상대 대 비 상대 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">편안한 선언은 가시성 규칙을 방출</target>
        </trans-unit>
        <trans-unit id="9811fea8059729e6e608294e42cacce36d4ff09d" translate="yes" xml:space="preserve">
          <source>Released:</source>
          <target state="translated">Released:</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">변수 캡처에 대해 앞에서 언급 한 것을 기억하십니까? &lt;code&gt;setTimeout&lt;/code&gt; 에 전달하는 모든 함수 표현식 은 실제로 동일한 범위에서 동일한 &lt;code&gt;i&lt;/code&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4ae2f2f99c6da082f0672c95b34c59cd80c40a24" translate="yes" xml:space="preserve">
          <source>Remove Comments - &lt;code&gt;removeComments&lt;/code&gt;</source>
          <target state="translated">댓글 제거 &lt;code&gt;removeComments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/*!&lt;/code&gt; 시작하는 복사 권한 헤더 주석을 제외한 모든 주석을 제거하십시오 !</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">함수 유형에서 'this'매개 변수를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d619a6862a4f7b32d4a58f285cc5c61b509d1673" translate="yes" xml:space="preserve">
          <source>Removes the &lt;a href=&quot;functions#this-parameters&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; parameter from &lt;code&gt;Type&lt;/code&gt;. If &lt;code&gt;Type&lt;/code&gt; has no explicitly declared &lt;code&gt;this&lt;/code&gt; parameter, the result is simply &lt;code&gt;Type&lt;/code&gt;. Otherwise, a new function type with no &lt;code&gt;this&lt;/code&gt; parameter is created from &lt;code&gt;Type&lt;/code&gt;. Generics are erased and only the last overload signature is propagated into the new function type.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; &lt;a href=&quot;functions#this-parameters&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; 매개 변수를 제거합니다 . &lt;code&gt;Type&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 매개 변수를 명시 적으로 선언하지 않은 경우 결과는 단순히 &lt;code&gt;Type&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;this&lt;/code&gt; 매개 변수가 없는 새 함수 유형 이 &lt;code&gt;Type&lt;/code&gt; 에서 생성됩니다 . 제네릭은 지워지고 마지막 오버로드 서명 만 새 함수 유형으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 의 내용을 다음으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">함수의 모든 코드 경로가 값을 반환하지 않는 경우 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">switch 문에 오류 사례에 대한 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="28ff576f8c9a47a52a73ccec4dfa5490f20abc5a" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. This means you won&amp;rsquo;t accidentally ship a case fallthrough bug.</source>
          <target state="translated">switch 문에서 폴 스루 사례에 대한 오류를보고합니다. switch 문 내에서 비어 있지 않은 모든 case에 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; 이 포함되는지 확인합니다 . 이는 실수로 케이스 폴 스루 버그를 발송하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일의 오류를보고 하십시오. &lt;code&gt;--allowJs&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9859c2bfd11829e29389ef6176aef839ff246a67" translate="yes" xml:space="preserve">
          <source>Report errors on unused local variables.</source>
          <target state="translated">사용하지 않는 지역 변수에 대한 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">사용하지 않은 지역의 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="c070f2ba00c2432442f5870f3f9104c630e23e08" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters in functions.</source>
          <target state="translated">함수에서 사용하지 않는 매개 변수에 대한 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">사용하지 않은 매개 변수에 대한 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">모듈 확인 로그 메시지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">필수 유형 매개 변수는 선택적 유형 매개 변수를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">필수, 선택적 및 기본 매개 변수는 모두 한 가지 공통점이 있습니다. 한 번에 하나의 매개 변수에 대해 말합니다. 때로는 여러 매개 변수를 그룹으로 사용하거나 함수가 궁극적으로 사용할 매개 변수 수를 모를 수도 있습니다. JavaScript에서는 모든 함수 본문 내에 표시 되는 &lt;code&gt;arguments&lt;/code&gt; 변수를 사용하여 직접 인수로 작업 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f3ece0cdbc888dc6e6e500ee3d259d041d3cdae" translate="yes" xml:space="preserve">
          <source>Requires either &lt;code&gt;sourceMap&lt;/code&gt; or &lt;code&gt;inlineSourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">중 필요 &lt;code&gt;sourceMap&lt;/code&gt; 또는 &lt;code&gt;inlineSourceMap&lt;/code&gt; 가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 를 문자열 값 속성 이름 (숫자 또는 기호 없음)으로 만 해결 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6500c452861f317427f27ca99511d2efa2c4566a" translate="yes" xml:space="preserve">
          <source>Resolve JSON Module - &lt;code&gt;resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">JSON 모듈 해결 &lt;code&gt;resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">나머지 매개 변수</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">튜플 유형의 나머지 요소</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">튜플 유형의 나머지 요소.</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">튜플 유형의 나머지 매개 변수</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">다음과 같은 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="acde6ca95b6974ed08c6f806127b9ecb63b7289c" translate="yes" xml:space="preserve">
          <source>Rethinking Types</source>
          <target state="translated">유형 재검토</target>
        </trans-unit>
        <trans-unit id="854f4c1b2de1f042fed1a2f43dfb41e328c62875" translate="yes" xml:space="preserve">
          <source>Rethinking the Class</source>
          <target state="translated">수업 재검토</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">콜백의 반환 유형</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">추론 대상으로 반환 유형</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">재사용 가능한 유형 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">재사용 가능한 유형 (유형 별명)</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">역 매핑</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scripts&lt;/code&gt; 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;새 항목을&lt;/strong&gt; 클릭하십시오 . 그런 다음 &lt;strong&gt;TypeScript File을&lt;/strong&gt; 선택 &lt;strong&gt;하고 파일&lt;/strong&gt; 이름을 &lt;code&gt;app.ts&lt;/code&gt; 로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; 폴더를 마우스 오른쪽 단추로 클릭하고 (폴더가 프로젝트 빌드를 시도하지 않는 경우) &lt;code&gt;index.html&lt;/code&gt; 이라는 새 항목을 안에 추가하십시오 . &lt;code&gt;index.html &lt;/code&gt; 에 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77c4e77f51ec4dad132664992b8975f2dfbe92c9" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wwwroot&lt;/code&gt; 폴더를 마우스 오른쪽 버튼으로 클릭하고 (폴더가 보이지 않으면 프로젝트를 빌드 해보십시오) &lt;code&gt;index.html&lt;/code&gt; 이라는 새 항목을 내부에 추가하십시오 . &lt;code&gt;index.html&lt;/code&gt; 에 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">프로젝트를 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;새 항목을&lt;/strong&gt; 클릭하십시오 . 그런 다음 &lt;strong&gt;JavaScript 파일을&lt;/strong&gt; 선택 하고 &lt;code&gt;gulpfile.js&lt;/code&gt; 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">마우스 오른쪽 버튼 클릭-&amp;gt; NuGet 패키지 관리</target>
        </trans-unit>
        <trans-unit id="4404226825fd8913da119eed59015272595b178d" translate="yes" xml:space="preserve">
          <source>Root Dir - &lt;code&gt;rootDir&lt;/code&gt;</source>
          <target state="translated">루트 디렉터리 &lt;code&gt;rootDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46607474e45e56af8b5a3efd5baf9b86a8244110" translate="yes" xml:space="preserve">
          <source>Root Dirs - &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">루트 Dirs- &lt;code&gt;rootDirs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5045f031d11028d3e898f4dd9c0e8f030ca21936" translate="yes" xml:space="preserve">
          <source>Root Fields</source>
          <target state="translated">루트 필드</target>
        </trans-unit>
        <trans-unit id="a49cce94f7aee86f9844fd38022767d62fef80bd" translate="yes" xml:space="preserve">
          <source>Roughly speaking, once TypeScript&amp;rsquo;s compiler is done with checking your code, it &lt;em&gt;erases&lt;/em&gt; the types to produce the resulting &amp;ldquo;compiled&amp;rdquo; code. This means that once your code is compiled, the resulting plain JS code has no type information.</source>
          <target state="translated">대략적으로 말하면 TypeScript의 컴파일러가 코드 검사를 마치면 유형을 &lt;em&gt;지워&lt;/em&gt; &quot;컴파일 된&quot;코드를 생성합니다. 즉, 코드가 컴파일되면 결과 일반 JS 코드에는 유형 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">디렉토리에서 &lt;code&gt;tsc --init&lt;/code&gt; 를 실행 하여이 디렉토리에 사전 설정 기본값으로 초기 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 작성 하십시오. 선택적으로 &lt;code&gt;--init&lt;/code&gt; 와 함께 명령 행 인수를 전달 하여 작성시 초기 tsconfig.json에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="9aa34d67108614684377b79ebc1738ed47fa9c79" translate="yes" xml:space="preserve">
          <source>Run the TypeScript compiler to generate the corresponding d.ts files for JS files</source>
          <target state="translated">TypeScript 컴파일러를 실행하여 JS 파일에 해당하는 d.ts 파일 생성</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">응용 프로그램을 실행하고 작동하는지 확인하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
