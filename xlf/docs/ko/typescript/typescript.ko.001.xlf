<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2019 Microsoft</target>
        </trans-unit>
        <trans-unit id="30e2637a4121a97d6d63991f19ff28a13222931e" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2020 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2020 Microsoft</target>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="translated">&quot;기본 선언&quot;을 사용하면 논리 또는 왼쪽의 선언 된 이름을 참조하는 이니셜 라이저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="translated">&amp;ldquo;해야 할 것&amp;rdquo;과&amp;ldquo;하지 말아야 할 것&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0a462d0a363472f89aab32695c02164466ca6a9c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;./dist/index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a7a19458753d64363353ed730635e775ee136020" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;main&amp;rdquo;:&amp;ldquo;index.js&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="77f022a953afe741cc802b7587833dd3652f325c" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;./dist/main.js&amp;rdquo;</source>
          <target state="translated">&quot;유형&quot;: &quot;./dist/main.js&quot;</target>
        </trans-unit>
        <trans-unit id="80dbbfebc33b03e9a8e299b3392e1bc5e89f27da" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;types&amp;rdquo;: &amp;ldquo;main.d.ts&amp;rdquo;</source>
          <target state="translated">&quot;유형&quot;: &quot;main.d.ts&quot;</target>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="translated">'classic'-1.6 이전 TypeScript 컴파일러에서 사용하는 모듈 확인 규칙</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="translated">'node'-노드와 유사한 모듈 확인</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="translated">'package.json'에는 &lt;strong&gt;'&lt;/strong&gt; node_modules / typescript / lib / typescript.d.ts'를 참조하는 &lt;strong&gt;'types'&lt;/strong&gt; 필드 './lib/typescript.d.ts'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-dependency /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="translated">&amp;lt;amd- 모듈 /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference lib = &quot;...&quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="translated">&amp;lt;reference no-default-lib = &quot;true&quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference path = &quot;...&quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference types = &quot;...&quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="translated">&amp;lt;reference&amp;gt;-모듈을 호출</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes" xml:space="preserve">
          <source>(More) Recursive Type Aliases</source>
          <target state="translated">재귀 유형 별칭</target>
        </trans-unit>
        <trans-unit id="9c306edcd7029e4d6802fe5b57d73e67c702ff8a" translate="yes" xml:space="preserve">
          <source>(optional) Edit your package.json to reference the types</source>
          <target state="translated">(선택 사항) 유형을 참조하도록 package.json을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes" xml:space="preserve">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="translated">* 참고 : &lt;code&gt;--jsxFactory&lt;/code&gt; 옵션 을 사용하여 반응 JSX 방출을 대상으로 지정할 때 사용할 JSX 팩토리 기능을 지정할 수 있습니다 (기본값은 &lt;code&gt;React.createElement&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb61c992209f91996318a06868699d18ec06bb49" translate="yes" xml:space="preserve">
          <source>./dist/index.d.ts</source>
          <target state="translated">./dist/index.d.ts</target>
        </trans-unit>
        <trans-unit id="7d54547932b925cb04c81035e7676fa6182e3b7e" translate="yes" xml:space="preserve">
          <source>./main/main.d.ts</source>
          <target state="translated">./main/main.d.ts</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes" xml:space="preserve">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes" xml:space="preserve">
          <source>1 - greeting: Mandatory string</source>
          <target state="translated">1-인사말 : 필수 문자열</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes" xml:space="preserve">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="translated">2-지속 시간 : 선택적 시간 길이 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes" xml:space="preserve">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="translated">3-색상 : 선택적 문자열 (예 : '# ff00ff'</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes" xml:space="preserve">
          <source>3.7 API Changes</source>
          <target state="translated">3.7 API 변경</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes" xml:space="preserve">
          <source>3.7 Breaking Changes</source>
          <target state="translated">3.7 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="f93d8407b2959853084d09f0c851bf5d0e08f0b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c8964ae98596ed53789c768e5ec7b3994c6c70f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#alwaysStrict&quot;&gt;&lt;code&gt;alwaysStrict&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictNullChecks&quot;&gt;&lt;code&gt;strictNullChecks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictBindCallApply&quot;&gt;&lt;code&gt;strictBindCallApply&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictFunctionTypes&quot;&gt;&lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictPropertyInitialization&quot;&gt;&lt;code&gt;strictPropertyInitialization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitAny&quot;&gt;&lt;code&gt;noImplicitAny&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitThis&quot;&gt;&lt;code&gt;noImplicitThis&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#alwaysStrict&quot;&gt;&lt;code&gt;alwaysStrict&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictNullChecks&quot;&gt;&lt;code&gt;strictNullChecks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictBindCallApply&quot;&gt;&lt;code&gt;strictBindCallApply&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictFunctionTypes&quot;&gt;&lt;code&gt;strictFunctionTypes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#strictPropertyInitialization&quot;&gt;&lt;code&gt;strictPropertyInitialization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitAny&quot;&gt;&lt;code&gt;noImplicitAny&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#noImplicitThis&quot;&gt;&lt;code&gt;noImplicitThis&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5eacc0bc20a210ca7f562d1dcc3f9914ec788f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="badedc9fbd49fc64159ae3e3285103c2215b1231" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c5c6fc0beafcad83d2b6b97d85ab7a3f4ec9e95" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#declarationDir&quot;&gt;&lt;code&gt;declarationDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#declarationDir&quot;&gt;&lt;code&gt;declarationDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd29cc36234c4eac24bd08b0eb7f3d7d4f112ffb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddac993a02e1f8c405d537e647fcf6c8af40be8d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#exclude&quot;&gt;&lt;code&gt;exclude&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d95311b8db4676f55e1e9cc9e97adb0d1405c5a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88bdfa25010df7871fccc20c32ead1f8e700ec6c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#composite&quot;&gt;&lt;code&gt;composite&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="700909c3f1adfc70abc84a37875bd1c7e5f1ffab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#incremental&quot;&gt;&lt;code&gt;incremental&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c12ed2ab3db736413d8125bf80d66ce2f131642f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsdoc-property-modifiers&quot;&gt;Property Modifiers&lt;/a&gt;&lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, &lt;code&gt;@protected&lt;/code&gt;, &lt;code&gt;@readonly&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;#jsdoc-property-modifiers&quot;&gt;속성 수정 자 &lt;/a&gt; &lt;code&gt;@public&lt;/code&gt; , &lt;code&gt;@private&lt;/code&gt; , &lt;code&gt;@protected&lt;/code&gt; , &lt;code&gt;@readonly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fc6cd42c46b121f604de4e278b03e63d3fc187f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="617124b58852d620746b0e2268ef8092a6b18811" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aff88d2e32507d449d9725602353414158333ea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b56648998908a0672096f6bf781cb50cdcab9a9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#jsxFactory&quot;&gt;&lt;code&gt;jsxFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxFragmentFactory&quot;&gt;&lt;code&gt;jsxFragmentFactory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#jsxImportSource&quot;&gt;&lt;code&gt;jsxImportSource&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f442113fa72aea1d2a309e3551e6bdb58d220c1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#noEmitHelpers&quot;&gt;&lt;code&gt;noEmitHelpers&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f40f8e7b81466e628cd1d26c0f4d604250df0117" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58f38543a8c287d6b6c4baaf9485cbf9c6434afc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#out&quot;&gt;&lt;code&gt;out&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="841ccc42e3622be2086b39b4485fddb5faa8b194" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#outDir&quot;&gt;&lt;code&gt;outDir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#outFile&quot;&gt;&lt;code&gt;outFile&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="translated">&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;위에서 언급했듯이&lt;/a&gt; TypeScript 3.7은 &lt;code&gt;.d.ts&lt;/code&gt; 파일 에 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 접근 자를 내 보냅니다 . 3.5 및 이전 버전과 같은 이전 버전의 TypeScript에서는 소비자에게 변경 사항을 적용 할 수 있습니다. 해당 버전은이 기능에 대해 향후 보장되므로 TypeScript 3.6 사용자에게는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015는 또한 &lt;/a&gt; &lt;code&gt;Iterator&lt;/code&gt; 인터페이스와 &lt;code&gt;yield&lt;/code&gt; 키워드 를 통해 부분 계산 결과를 산출하는 데 사용할 수있는 함수 인 &quot;Generators&quot;를 도입했습니다 . 또한 생성기는 &lt;code&gt;yield *&lt;/code&gt; 를 통해 호출을 다른 iterable에 내부적으로 위임 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 는 다음 인터페이스에 따라 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 세 가지 메소드를 노출하는 객체 인 Iterator를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="b6333d998c229faa742c2259393328f8ce5717b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.stroustrup.com/4th.html&quot;&gt;The C++ Programming Language&lt;/a&gt; is a good place to learn about C-style type syntax. Unlike C++, TypeScript uses postfix types, like so: &lt;code&gt;x: string&lt;/code&gt; instead of &lt;code&gt;string x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.stroustrup.com/4th.html&quot;&gt;C ++ 프로그래밍 언어&lt;/a&gt; 는 C 스타일 유형 구문에 대해 배우기에 좋은 곳입니다. C ++와 달리 TypeScript는 다음과 같이 접미사 유형을 사용합니다. &lt;code&gt;x: string&lt;/code&gt; 대신 &lt;code&gt;string x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c522a5a7799016630add0cfdae778f7d5c18f87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/DOM&quot;&gt;DOM&lt;/a&gt; definitions - &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/DOM&quot;&gt;DOM&lt;/a&gt; 정의- &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;document&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="fbc45d0d18af813393a85ab4e94d2f14b2851e9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Data_structures&quot;&gt;See the MDN page for more detail&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Data_structures&quot;&gt;자세한 내용은 MDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4092c59537e7cf28a262cdff3ec1a8a7b377cf2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;ECMAScript strict&lt;/a&gt; mode was introduced in ES5 and provides behavior tweaks to the runtime of the JavaScript engine to improve performance, and makes a set of errors throw instead of silently ignoring them.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;ECMAScript 엄격&lt;/a&gt; 모드는 ES5에서 도입되었으며 JavaScript 엔진의 런타임에 동작 조정을 제공하여 성능을 향상시키고 오류를 자동으로 무시하는 대신 일련의 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; 는 임베드 가능한 XML 유사 구문입니다. 변환의 의미는 구현에 따라 다르지만 유효한 JavaScript로 변환되어야합니다. JSX는 &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; 프레임 워크 로 인기를 얻었 지만 이후 다른 구현도 보았습니다. TypeScript는 포함, 유형 검사 및 JSX를 JavaScript로 직접 컴파일하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="199e55c49a5efe4f7eea9b852e615fbd30d3d039" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Microsoft/typescript-styled-plugin&quot;&gt;typescript-styled-plugin&lt;/a&gt; &amp;mdash; Provides CSS linting inside template strings .</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/typescript-styled-plugin&quot;&gt;typescript-styled-plugin&lt;/a&gt; &amp;mdash; 템플릿 문자열 내부에 CSS linting을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c05658a1d8a717f441a947f4b3f5873629b2746f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/ts-graphql-plugin&quot;&gt;ts-graphql-plugin&lt;/a&gt; &amp;mdash; Provides validation and auto-completion inside GraphQL query template strings.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Quramy/ts-graphql-plugin&quot;&gt;ts-graphql-plugin&lt;/a&gt; &amp;mdash; GraphQL 쿼리 템플릿 문자열 내에서 유효성 검사 및 자동 완성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4c1d8571473f401bda993ef5f95107455716e497" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Quramy/typescript-eslint-language-service&quot;&gt;typescript-eslint-language-service&lt;/a&gt; &amp;mdash; Provides eslint error messaging and fix-its inside the compiler&amp;rsquo;s output.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Quramy/typescript-eslint-language-service&quot;&gt;typescript-eslint-language-service&lt;/a&gt; &amp;mdash; 컴파일러 출력 내에서 eslint 오류 메시지 및 수정 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt; &lt;code&gt;lib.dom.d.ts&lt;/code&gt; 의 유형 이 업데이트되었습니다&lt;/a&gt; . 이러한 변경 사항은 주로 null 허용 여부와 관련된 정확성 변경이지만 영향은 궁극적으로 코드베이스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD 모듈&lt;/a&gt; 은 모듈 로더 환경이 있는지 확인합니다. 이것은 다음과 같이 보이는 스팟 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="4501968243cb90a3d84dcd45006c29d533b0884d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xialvjun/ts-sql-plugin#readme&quot;&gt;ts-sql-plugin&lt;/a&gt; &amp;mdash; Adds SQL linting with a template strings SQL builder.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xialvjun/ts-sql-plugin#readme&quot;&gt;ts-sql-plugin&lt;/a&gt; &amp;mdash; 템플릿 문자열 SQL 빌더를 사용하여 SQL linting을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c6483def0fc8c609e15c97336fa075e9de577db1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs&quot;&gt;With TypeScript 3.7&lt;/a&gt;, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#--declaration-and---allowjs&quot;&gt;TypeScript 3.7&lt;/a&gt; 에서 TypeScript는 JSDoc 구문을 사용하여 JavaScript에서 .d.ts 파일을 생성하기위한 지원을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="279d25c3bce3f4af13a20f8e97e6c8096c2c8cff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;declaration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;declaration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#emitDeclarationOnly&quot;&gt;&lt;code&gt;emitDeclarationOnly&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ 맨 위로&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; : 같은 이름이 바뀌지 않았 음을 의미하므로 map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; 는 접두어가 &quot;generated&quot;인 모듈 이름을 의미하므로 &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt; 을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="translated">&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; 는 새 코드를 작성할 때마다 좋은 생각입니다. 실수로 형식화되지 않은 코드를 쓰지 않도록 할 수 있습니다. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; 를 사용하면 실행중인 웹 앱에서 코드를 쉽게 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 는 내용이 런타임에 병합 될 것으로 예상되는 &lt;em&gt;루트&lt;/em&gt; 목록을 지정합니다 . 예를 들어, &lt;code&gt;tsconfig.json&lt;/code&gt; 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="60134d0ac283a5c3d28bf080abb92e5b19e8fb5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; matches any directory nested to any level</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; 는 모든 수준에 중첩 된 모든 디렉토리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; 는 모든 하위 디렉토리와 재귀 적으로 일치</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 0 개 이상의 문자와 일치합니다 (디렉토리 구분 기호 제외)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; 피연산자 상수 열거 식 이진 연산자</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt; : 지정된 프로젝트의 출력을 삭제합니다 ( &lt;code&gt;--dry&lt;/code&gt; 와 결합 가능 )</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; 및 &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="translated">&lt;code&gt;--declarationDir&lt;/code&gt; 을 사용하면 JavaScript 파일과 다른 위치에 선언 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="translated">&lt;code&gt;--dry&lt;/code&gt; : 수행 할 작업을 표시하지만 실제로는 아무것도 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="translated">&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; 선언 파일 &lt;em&gt;만&lt;/em&gt; 생성 할 수 있습니다. &lt;code&gt;.js&lt;/code&gt; / &lt;code&gt;.jsx&lt;/code&gt; 출력 생성은이 플래그로 건너 뜁니다. 이 플래그는 &lt;code&gt;.js&lt;/code&gt; 출력 생성이 Babel과 같은 다른 변환기에 의해 처리 될 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; : 모든 프로젝트가 오래된 것처럼 작동</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 개선</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--init&lt;/code&gt; 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; 및 &lt;code&gt;inlineSources&lt;/code&gt; 명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; 은 소스 맵 파일 이 독립적 인 &lt;code&gt;.js.map&lt;/code&gt; 파일 대신 생성 된 &lt;code&gt;.js&lt;/code&gt; 파일에 인라인으로 작성 되도록 합니다. &lt;code&gt;--inlineSources&lt;/code&gt; 를 사용하면 소스 &lt;code&gt;.ts&lt;/code&gt; 파일을 &lt;code&gt;.js&lt;/code&gt; 파일 에 추가로 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--newLine&lt;/code&gt; 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; 기본적으로 예쁜 출력</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; 은 입력 디렉토리를 계산하지 않고 출력에 미러링 되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; 는 새로운 엄격한 null 확인 모드로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--target ESNext&lt;/code&gt; 는 지원되는 최신 &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES 제안 기능을&lt;/a&gt; 대상으로 합니다 .</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; 은 컴파일러가 모듈을 어떻게 해결했는지 이해하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt; : 자세한 정보를 인쇄하여 진행 상황을 설명합니다 (다른 플래그와 결합 가능)</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; 컴파일러의 --watch 구현은 노드가 제공하는 &lt;code&gt;fs.watch&lt;/code&gt; 및 &lt;code&gt;fs.watchFile&lt;/code&gt; 에 의존하며 ,이 두 가지 방법 모두 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; : 감시 모드 ( &lt;code&gt;--verbose&lt;/code&gt; 이외의 플래그와 함께 사용할 수 없음 )</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="translated">&lt;code&gt;-noEmitOnError&lt;/code&gt; 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일은 이제 &lt;code&gt;tsc&lt;/code&gt; 에 대한 입력으로 허용됩니다 . TypeScript 컴파일러는 입력 &lt;code&gt;.js&lt;/code&gt; 파일에서 구문 오류를 확인하고 &lt;code&gt;--target&lt;/code&gt; 및 &lt;code&gt;--module&lt;/code&gt; 플래그를 기반으로 유효한 출력 을 생성 합니다. 출력을 다른 &lt;code&gt;.ts&lt;/code&gt; 파일과 결합 할 수도 있습니다 . &lt;code&gt;.ts&lt;/code&gt; 파일 과 마찬가지로 &lt;code&gt;.js&lt;/code&gt; 파일에 대한 소스 맵이 계속 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일은 여전히 ​​표준 ECMAScript 기능 만 포함하고 있는지 확인합니다. 형식 주석은 &lt;code&gt;.ts&lt;/code&gt; 파일 에서만 허용 되며 &lt;code&gt;.js&lt;/code&gt; 파일 에서 오류로 표시됩니다 . JSDoc 주석은 JavaScript 코드에 일부 유형 정보를 추가하는 데 사용할 수 있습니다 . 지원되는 JSDoc 구문에 대한 자세한 내용 은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc 지원 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; TypeScript 파일의 @ ts-nocheck</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; 는 결과 모듈의 요구 호출에 삽입해야하는 비 TS 모듈 종속성에 대해 컴파일러에 알립니다.</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; 는 결과 모듈의 요구 호출에 주입해야하는 비 TS 모듈 종속성에 대해 컴파일러에 알립니다. 그러나 TS 코드에서이 모듈을 소비 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; 참조 지시문</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; -모듈을 호출</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (&quot;main &lt;code&gt;&quot;main&quot;&lt;/code&gt; 속성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (&quot;types &lt;code&gt;&quot;types&quot;&lt;/code&gt; 속성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (&quot;main &lt;code&gt;&quot;main&quot;&lt;/code&gt; 속성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (&quot;types &lt;code&gt;&quot;types&quot;&lt;/code&gt; 특성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (&quot;types &lt;code&gt;&quot;types&quot;&lt;/code&gt; 속성을 지정한 경우 )</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (&quot;main &lt;code&gt;&quot;main&quot;&lt;/code&gt; 속성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (&quot;types &lt;code&gt;&quot;types&quot;&lt;/code&gt; 속성을 지정하는 경우 )</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 하나의 문자와 일치합니다 (디렉토리 구분 기호 제외).</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; 비슷 &lt;code&gt;@typedef&lt;/code&gt; 하지만, 대신에 오브젝트의 종류의 함수 유형을 지정</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@class&lt;/code&gt; (또는 &lt;code&gt;@constructor&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d9926a14ef97939b4b2a7dc3f406f497b651cfe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@const&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/19672&quot;&gt;issue #19672&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;@const&lt;/code&gt; ( &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/19672&quot;&gt;문제 # 19672&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; (또는 &lt;code&gt;@augments&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7af159c170df9572411a5fc0ca1c714e2ddcfe48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@inheritdoc&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23215&quot;&gt;issue #23215&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;@inheritdoc&lt;/code&gt; ( &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23215&quot;&gt;문제 # 23215&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9e519c580e10173da9247b85e7b08d470854d616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@memberof&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/7237&quot;&gt;issue #7237&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;@memberof&lt;/code&gt; ( &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/7237&quot;&gt;문제 # 7237&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; (또는 &lt;code&gt;@arg&lt;/code&gt; 또는 &lt;code&gt;@argument&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; 은 일회용 형식 사양과 유사한 구문을 허용합니다. 중첩 된 속성 이름 앞에는 매개 변수 이름이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; 과 &lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; 은 &lt;code&gt;@type&lt;/code&gt; 과 동일한 형식 구문을 사용 하지만 매개 변수 이름을 추가합니다. 매개 변수는 이름을 대괄호로 묶어 선택적으로 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19809d43310d525637902c3117defc38e456422e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@private&lt;/code&gt; means that a property can only be used within the containing class.</source>
          <target state="translated">&lt;code&gt;@private&lt;/code&gt; 는 포함하는 클래스 내에서만 속성을 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="438ac9ff15896d350daae76a2cc4baf6653d6792" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@protected&lt;/code&gt; means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.</source>
          <target state="translated">&lt;code&gt;@protected&lt;/code&gt; 는 포함하는 클래스와 모든 파생 된 하위 클래스 내에서만 속성을 사용할 수 있지만 포함하는 클래스의 다른 인스턴스에서는 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ffd4c7a40333b2bbb8dde7e82e8932abca84df9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@public&lt;/code&gt; is always implied and can be left off, but means that a property can be reached from anywhere.</source>
          <target state="translated">&lt;code&gt;@public&lt;/code&gt; 은 항상 묵시적이며 생략 할 수 있지만 어느 곳에서나 속성에 도달 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@returns&lt;/code&gt; (또는 &lt;code&gt;@return&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; 은 공용체 유형을 지정할 수 있습니다. 예를 들어 문자열 또는 부울 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; 는 복잡한 유형을 정의하는 데 사용될 수 있습니다. &lt;code&gt;@param&lt;/code&gt; 과 유사한 구문이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; , &lt;code&gt;@callback&lt;/code&gt; 및 &lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; 및 &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bae124c1c173e712edc3d1ad0a19078f6a3f6f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@yields&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23857&quot;&gt;issue #23857&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;@yields&lt;/code&gt; ( &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/23857&quot;&gt;문제 # 23857&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ced52b9dec509889f60aa7c87448b485409b7a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; , &lt;code&gt;CommonJs&lt;/code&gt; , &lt;code&gt;UMD&lt;/code&gt; , &lt;code&gt;System&lt;/code&gt; 또는 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRLF&lt;/code&gt; 또는 &lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Classic&lt;/code&gt; 또는 &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7c57db6dc6560c30e85fd334a8c39710cd2a1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Combined&lt;/code&gt; has two properties, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, just as if they had been written as one object literal type. Intersection and union are recursive in case of conflicts, so &lt;code&gt;Conflicting.a: number &amp;amp; string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Combined&lt;/code&gt; 에는 마치 하나의 객체 리터럴 유형으로 작성된 것처럼 두 개의 속성 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 가 있습니다. 교차점과 합집합은 충돌의 경우 재귀 &lt;code&gt;Conflicting.a: number &amp;amp; string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4d793b8dd668dd2130ea7391dfeaa61bed9c3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CommonJS&lt;/code&gt; (default if &lt;code&gt;target&lt;/code&gt; is &lt;code&gt;ES3&lt;/code&gt; or &lt;code&gt;ES5&lt;/code&gt;),</source>
          <target state="translated">&lt;code&gt;CommonJS&lt;/code&gt; ( &lt;code&gt;target&lt;/code&gt; 이 &lt;code&gt;ES3&lt;/code&gt; 또는 &lt;code&gt;ES5&lt;/code&gt; 인 경우 기본값 ),</target>
        </trans-unit>
        <trans-unit id="57e28ff360e77827a000f56ca84a256c62cc3228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2017&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2017&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="e44dc9aa61a49ecca89f1df117b8525c59bdcc98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2018&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2018&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="88589d0dd64cb35a2eed37b1a8b40cce5f9a53e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2019&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2019&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="12f37540cdb9c3492ed986234931fa1515ec2629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES2020&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES2020&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="5458962d81dee50f969981ff115b63eb43196cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt; (default),</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; (기본값),</target>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; , &lt;code&gt;ES5&lt;/code&gt; 또는 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59ffafcef9deaae4f4691bacf9ca573ae6ca0ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="91cc99c38cb2d95e5ad8900b70fbd04f54089424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous),</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; / &lt;code&gt;ES2015&lt;/code&gt; (동의어),</target>
        </trans-unit>
        <trans-unit id="551adb5b78d1804a795f54cee1a99ae987b9a8ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt;/&lt;code&gt;ES2015&lt;/code&gt; (synonymous, default for &lt;code&gt;target&lt;/code&gt;&lt;code&gt;ES6&lt;/code&gt; and higher),</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; / &lt;code&gt;ES2015&lt;/code&gt; (동의어, &lt;code&gt;target&lt;/code&gt; &lt;code&gt;ES6&lt;/code&gt; 이상의 기본값 ),</target>
        </trans-unit>
        <trans-unit id="dd82edcb863935c74f3c96030d44feb854613265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;ES7&lt;/code&gt;/&lt;code&gt;ES2016&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; -에서 제외 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 그 유형 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; -에서 추출 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 그 유형 &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="translated">&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; 생성자 함수 유형의 인스턴스 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MapToPromise&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형을 사용하며 해당 유형이 &lt;code&gt;Coordinate&lt;/code&gt; 와 같은 튜플 인 경우 숫자 속성 만 변환됩니다. 에서는 &lt;code&gt;[number, number]&lt;/code&gt; : 두 숫자라는 성질이있다 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; . 이와 같은 튜플이 주어지면 &lt;code&gt;MapToPromise&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 속성이 원래 유형의 &lt;code&gt;Promise&lt;/code&gt; 인 새 튜플을 만듭니다 . 따라서 결과 유형 &lt;code&gt;PromiseCoordinate&lt;/code&gt; 는 &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt; 유형으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt; : 도구 만 ( &lt;code&gt;tsc.exe&lt;/code&gt; , &lt;code&gt;lib.d.ts&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; : 위와 같은 도구와 MSBuild 작업 및 대상 ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; , &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; - 제외 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;undefined&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89a15a098fe35b271129107f57ff56b0b96a908f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; JavaScript의 Object.defineProperty 선언</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; 앞에서 설명한 것처럼 Partial 및 &lt;code&gt;Readonly&lt;/code&gt; 는 매우 유용한 구성입니다. 이를 사용하여 다음과 같은 일반적인 JS 루틴을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; , &lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Record&lt;/code&gt; 및 &lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="translated">&lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Partial&lt;/code&gt; 및 &lt;code&gt;Pick&lt;/code&gt; 은 동형이지만 &lt;code&gt;Record&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;Record&lt;/code&gt; 가 동형이 아닌 한 가지 단서는 속성을 복사하기 위해 입력 유형을 사용하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="translated">&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; 함수 유형의 반환 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="555e1ab04d96fee8e1f7fce44305f90f1e1a16a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;System&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;System&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="4b99ac4ec7cc9b1967c0464330db6c92bcd93e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UMD&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f596f26b3a4a06ed8796e22604a1d5460910d96c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]&lt;/code&gt;, plus the value of &lt;code&gt;outDir&lt;/code&gt; if one is specified.</source>
          <target state="translated">&lt;code&gt;[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]&lt;/code&gt; 및 지정된 경우 &lt;code&gt;outDir&lt;/code&gt; 값을 더 합니다.</target>
        </trans-unit>
        <trans-unit id="af4e295b21aab254df399f343e9636cc32c7a1ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[T, T]&lt;/code&gt; is a subtype of &lt;code&gt;T[]&lt;/code&gt;. This is different than Haskell, where tuples are not related to lists.</source>
          <target state="translated">&lt;code&gt;[T, T]&lt;/code&gt; 는 &lt;code&gt;T[]&lt;/code&gt; 의 하위 유형입니다 . 이것은 튜플이 목록과 관련이없는 Haskell과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="283c19901d75227a4d28c2d33fc35dbe35af5585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;files&lt;/code&gt; is specified, otherwise &lt;code&gt;[&quot;**/*&quot;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; &lt;code&gt;files&lt;/code&gt; 이 지정 되면 [] , 그렇지 않으면 &lt;code&gt;[&quot;**/*&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; 클래스와 메소드</target>
        </trans-unit>
        <trans-unit id="80eb1110b2f29a5b22fea8c7402e9b9f0d9e30b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; is contagious, too &amp;mdash; if you initialise a variable with an expression of type &lt;code&gt;any&lt;/code&gt;, the variable has type &lt;code&gt;any&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 도 전염성이 - 당신이 유형의 식으로 변수를 초기화하면 &lt;code&gt;any&lt;/code&gt; 변수가 입력이 &lt;code&gt;any&lt;/code&gt; 너무.</target>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;asserts condition&lt;/code&gt; 은 &lt;code&gt;assert&lt;/code&gt; 가 리턴 되면 &lt;code&gt;condition&lt;/code&gt; 매개 변수 로 전달되는 모든 것이 참이어야 한다고 말합니다 (그렇지 않으면 오류가 발생 함). 그것은 나머지 범위에 대해 그 조건이 진실해야 함을 의미합니다. 예를 들어,이 주장 기능 수단을 사용하여 우리가 &lt;em&gt;할&lt;/em&gt; 우리의 원래 잡을 &lt;code&gt;yell&lt;/code&gt; 예.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; ES6 대상에서 비동기 / 지원 &lt;code&gt;await&lt;/code&gt; (노드 v4 +)</target>
        </trans-unit>
        <trans-unit id="e0839c98cf0c1b0d32a7dad40585aa624f84509b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt; extensions</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 확장</target>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 는 다른 두 가지 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 그런 다음 compose 는 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 를 통해 인수를 제공하는 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; (완전히 인라인 된 열거 형)</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 어설 션</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 선언은 변수를 선언하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 열거 형</target>
        </trans-unit>
        <trans-unit id="8980d3e09baee4979420c9636f8b832f951f2861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 변수에 대한 재 할당을 방지한다는 점에서 &lt;code&gt;let&lt;/code&gt; 의 증가입니다 .</target>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; )을 대상으로하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5892822e96ef4ecfe925031773afe23c1bf575ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; 이 켜져 있어야합니다</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 내보내기는 정말 편리합니다. 예를 들어, jQuery와 같은 라이브러리는 &lt;code&gt;jQuery&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 의 기본 내보내기를 가질 수 있으며 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;jQuery&lt;/code&gt; 라는 이름으로 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 내보내기는 값일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe376a04dc77749dab7c4dbd979df3cf8e5dd405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified directories will be checked less often.</source>
          <target state="translated">&lt;code&gt;dynamicPriorityPolling&lt;/code&gt; : 덜 자주 수정되는 디렉토리를 덜 자주 확인하는 동적 대기열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c871853d0e750f1e6eeaefa64d36be33f6fd2e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamicPriorityPolling&lt;/code&gt;: Use a dynamic queue where less-frequently modified files will be checked less often.</source>
          <target state="translated">&lt;code&gt;dynamicPriorityPolling&lt;/code&gt; : 자주 수정되지 않는 파일을 덜 자주 확인하는 동적 대기열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="288c5ada225ba27cfc87c34049e5392aaba3891d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: This preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; : 모든 가져 오기를 유지하지만 (보존 옵션과 동일) 값 가져 오기가 유형으로 만 사용되는 경우 오류가 발생합니다. 실수로 값을 가져 오지 않도록하고 부작용 가져 오기를 명시 적으로 만들고자 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; tsconfig.json에서 특성 지원 제외</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="translated">&lt;code&gt;export *&lt;/code&gt; 는 다른 모듈의 모든 내보내기를 다시 내보내는 데 사용할 수 있습니다. 이는 여러 다른 모듈의 내보내기를 집계하는 모듈을 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 및 &lt;code&gt;import = require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 는 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 새로운 최상위 속성입니다 ( &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 와 함께 ).</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 형 의 인수를 취해 &lt;code&gt;B&lt;/code&gt; 형의 값을 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="9f22e56762e33c4799141e66037e37470d49b81a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; raises compiler errors about unreachable code</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 는 연결할 수없는 코드에 대한 컴파일러 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7b17f3db39a076d6901d31237e6962658b321a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, unless &lt;code&gt;strict&lt;/code&gt; is set</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; , &lt;code&gt;strict&lt;/code&gt; 이 설정 되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 상속하는 config 파일에서 &lt;em&gt;덮어 쓰기&lt;/em&gt; 의 기본 설정 파일에서 그.</target>
        </trans-unit>
        <trans-unit id="f14095026c89d29eb77a2786e83750935d903d15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every directory for changes several times a second at a fixed interval.</source>
          <target state="translated">&lt;code&gt;fixedPollingInterval&lt;/code&gt; : 고정 된 간격으로 1 초에 여러 번 변경 사항이 있는지 모든 디렉토리를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9f2d807f774a8f4511fd40887b6aa11dff8fd264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixedPollingInterval&lt;/code&gt;: Check every file for changes several times a second at a fixed interval.</source>
          <target state="translated">&lt;code&gt;fixedPollingInterval&lt;/code&gt; : 고정 된 간격으로 1 초에 여러 번 모든 파일의 변경 사항을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 는 반복 가능한 객체를 반복 하여 객체 의 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성을 호출 합니다. 다음은 배열 의 간단한 &lt;code&gt;for..of&lt;/code&gt; 루프입니다.</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 문, 배열 Destructuring 및 배열에 확산 요소, 전화, 그리고 새로운 표현을 지원 &lt;code&gt;Symbol.iterator&lt;/code&gt; 를 사용할 때 가능한 경우 ES5 / E3에서 &lt;code&gt;--downlevelIteration&lt;/code&gt; 을 하지만 정의하지 않는 경우에도 배열에서 사용할 수있는 &lt;code&gt;Symbol.iterator&lt;/code&gt; 런타임 또는 디자인 타임에 .iterator</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 대 &lt;code&gt;for..in&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; 는 파일 시스템 이벤트를 사용하여 파일 / 디렉토리의 변경 사항을 알립니다. 그러나 이것은 OS에 따라 다르며 알림이 완전히 신뢰할 수 없으며 많은 OS에서 예상대로 작동하지 않습니다. 또한 만들 수있는 시계 수에 제한이있을 수 있습니다. 리눅스와 우리는 많은 파일을 포함하는 프로그램으로 꽤 빨리 고갈시킬 수 있습니다. 그러나 이것은 파일 시스템 이벤트를 사용하기 때문에 CPU주기가 많지 않습니다. 컴파일러는 일반적으로 &lt;code&gt;fs.watch&lt;/code&gt; 를 사용 하여 디렉토리 (예 : 구성 파일에 포함 된 소스 디렉토리, 모듈 확인에 실패한 디렉토리 등)를 감시합니다. 이러한 변경 사항을 알리는 데 누락 된 정밀도를 처리 할 수 ​​있습니다. 그러나 재귀 시청은 Windows 및 OSX에서만 지원됩니다. 즉, 다른 OS의 재귀 적 특성을 대체 할 무언가가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; 은 폴링을 사용하므로 CPU주기를 포함합니다. 그러나 이것은 파일 / 디렉토리의 상태를 업데이트 할 수있는 가장 안정적인 메커니즘입니다. 컴파일러는 일반적으로 &lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용 하여 소스 파일, 구성 파일 및 누락 된 파일 (파일 참조 누락)을 감시합니다. 즉, CPU 사용량은 프로그램의 파일 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 유형의 인수 ( &lt;code&gt;f&lt;/code&gt; 가 리턴 된 유형)를 취하고 &lt;code&gt;C&lt;/code&gt; 유형의 값을 리턴합니다</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근 자 주위 컨텍스트에서 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3124d2af4a7b268f86acefe54dcc4bd3f7d01f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import type&lt;/code&gt; is always guaranteed to be removed from your JavaScript, and tools like Babel can make better assumptions about your code via the &lt;code&gt;isolatedModules&lt;/code&gt; compiler flag. You can read more in the &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports&quot;&gt;3.8 release notes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;import type&lt;/code&gt; 은 항상 JavaScript에서 제거되도록 보장되며 Babel과 같은 도구는 &lt;code&gt;isolatedModules&lt;/code&gt; 컴파일러 플래그 를 통해 코드에 대해 더 나은 가정을 할 수 있습니다 . &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports&quot;&gt;3.8 릴리스 정보&lt;/a&gt; 에서 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 는 &lt;code&gt;ESNext&lt;/code&gt; 모듈 및 ECMAScript 대상을 대상으로 하는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="c20e5c61459139d6cecacbbae3c9ad3e255d665c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; support wildcard characters to make glob patterns:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; glob 패턴을 만들기 위해 지원 와일드 카드 문자를 포함 및 &lt;code&gt;exclude&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 가드</target>
        </trans-unit>
        <trans-unit id="58f962df495c2ad38d952726f96435f0a9c82665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot;&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot; | &quot;ownersAddress&quot;&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; 는 &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot;&lt;/code&gt; 와 완전히 호환됩니다. | &quot;모델&quot;| &quot;연도&quot; . 차이점은 또 다른 속성을 추가하는 경우이다 &lt;code&gt;Car&lt;/code&gt; 말 &lt;code&gt;ownersAddress: string&lt;/code&gt; 다음 &lt;code&gt;keyof Car&lt;/code&gt; 자동으로 업데이트됩니다 &lt;code&gt;&quot;manufacturer&quot; | &quot;model&quot; | &quot;year&quot; | &quot;ownersAddress&quot;&lt;/code&gt; . 그리고 당신은 사용할 수 있습니다 &lt;code&gt;keyof&lt;/code&gt; 같은 일반적인 상황에서 &lt;code&gt;pluck&lt;/code&gt; 당신이 가능하게 미리의 속성 이름을 알 수 없습니다. 즉, 컴파일러는 &lt;code&gt;pluck&lt;/code&gt; 에 올바른 속성 이름 집합을 전달하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; 는 &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt; 와 완전히 호환됩니다 | '모델'| '년' . 차이점은 또 다른 속성을 추가하는 경우이다 &lt;code&gt;Car&lt;/code&gt; 말 &lt;code&gt;ownersAddress: string&lt;/code&gt; 다음 &lt;code&gt;keyof Car&lt;/code&gt; 자동으로 업데이트됩니다 &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt; 입니다. 그리고 당신은 사용할 수 있습니다 &lt;code&gt;keyof&lt;/code&gt; 같은 일반적인 상황에서 &lt;code&gt;pluck&lt;/code&gt; 당신이 가능하게 미리의 속성 이름을 알 수 없습니다. 즉 컴파일러가 올바른 속성 이름 집합을 &lt;code&gt;pluck&lt;/code&gt; 에 전달 했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="translated">&lt;code&gt;keyof X&lt;/code&gt; 는 문자열 형, 숫자 형 및 기호 형 속성을 나타내는 리터럴 유형의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="a66b6fc8661361e20ef87ae35fc31efb3fbba84e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object[&quot;42&quot;]&lt;/code&gt;) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 및 &lt;code&gt;T[K]&lt;/code&gt; 는 인덱스 서명과 상호 작용합니다. 인덱스 서명 매개 변수 유형은 '문자열'또는 '숫자'여야합니다. 문자열 인덱스 서명이있는 유형이있는 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 &lt;code&gt;string | number&lt;/code&gt; (단지 &lt;code&gt;string&lt;/code&gt; 뿐만 아니라 JavaScript에서는 문자열 ( &lt;code&gt;object[&quot;42&quot;]&lt;/code&gt; ) 또는 숫자 ( &lt;code&gt;object[42]&lt;/code&gt; )) 를 사용하여 객체 속성에 액세스 할 수 있기 때문입니다 . 그리고 &lt;code&gt;T[string]&lt;/code&gt; 은 인덱스 서명의 유형일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 및 &lt;code&gt;T[K]&lt;/code&gt; 는 인덱스 서명과 상호 작용합니다. 색인 서명 매개 변수 유형은 'string'또는 'number'여야합니다. 문자열 색인 서명이있는 유형이있는 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 &lt;code&gt;string | number&lt;/code&gt; 자바 스크립트에서는 문자열 ( &lt;code&gt;object['42'&lt;/code&gt; ]) 또는 숫자 ( &lt;code&gt;object[42]&lt;/code&gt; ) 를 사용하여 객체 속성에 액세스 할 수 있으므로 &lt;code&gt;string&lt;/code&gt; 뿐만 아니라 number 입니다. 그리고 &lt;code&gt;T[string]&lt;/code&gt; 은 인덱스 서명의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 및 조회 유형</target>
        </trans-unit>
        <trans-unit id="9157c1d1156017222354fdad58f5ebf6388c0fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new concepts for variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 는 JavaScript에서 변수 선언에 대한 상대적으로 새로운 두 가지 개념입니다. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;우리는 앞에서 언급 한 바와 같이&lt;/a&gt; , &lt;code&gt;let&lt;/code&gt; 유사하다 &lt;code&gt;var&lt;/code&gt; 어떤면에서, 그러나 사용자는 사용자가 자바 스크립트로 실행하는 것이 일반적인 &quot;개는&quot;의 일부를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 는 JavaScript에서 비교적 새로운 두 가지 유형의 변수 선언입니다. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;우리는 앞에서 언급 한 바와 같이&lt;/a&gt; , &lt;code&gt;let&lt;/code&gt; 유사하다 &lt;code&gt;var&lt;/code&gt; 어떤면에서, 그러나 사용자는 사용자가 자바 스크립트로 실행하는 것이 일반적인 &quot;개는&quot;의 일부를 피할 수 있습니다. &lt;code&gt;const&lt;/code&gt; 는 변수에 대한 재 할당을 방지한다는 점에서 &lt;code&gt;let&lt;/code&gt; 의 기능을 보강 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 루프의 한 부분으로 선언 한 선언이 크게 다른 행동이있다. 루프 자체에 새로운 환경을 도입하는 대신 이러한 선언 &lt;em&gt;은 반복마다&lt;/em&gt; 새로운 범위를 만듭니다 . 이것이 IIFE를 사용하여 수행 한 작업이므로 &lt;code&gt;let&lt;/code&gt; 선언 만 사용하도록 이전 &lt;code&gt;setTimeout&lt;/code&gt; 예제를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 은 ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; )을 대상으로하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 대 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; 또는 &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 모든 유형의 하위 유형이며 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 은 다음과 같이 구성 가능한 함수를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 은 클래스 생성자에서 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 또는 &lt;code&gt;__proto__&lt;/code&gt; 를 설정해야 할 때 유용합니다 . 이러한 사용 사례 중 하나 는 NodeJS v4 이상의 &lt;code&gt;Error&lt;/code&gt; 에서 상속 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; 는 &lt;code&gt;switch&lt;/code&gt; 블록 에서 &lt;code&gt;case&lt;/code&gt; 사이 의 &lt;code&gt;break&lt;/code&gt; 문 을 잊지 않으려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;noImplicitAny&lt;/code&gt; : 암시 된 &lt;code&gt;any&lt;/code&gt; 유형의 표현식 및 선언에서 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="translated">&lt;code&gt;noImplicitReturns&lt;/code&gt; 는 함수의 끝에서 리턴하는 것을 잊어 버리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 는 기본이 아닌 형식, 즉 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 아닌 형식을 나타내는 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="translated">&lt;code&gt;onEmitOnError&lt;/code&gt; : 오류가보고 된 경우 출력을 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="962f6f62ca17f25220b1453a992b090209f2d675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt; lets you declare how TypeScript should resolve an import in your &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt; 를 사용하면 &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 에서 TypeScript가 가져 오기를 해결하는 방법을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="translated">&lt;code&gt;pet is Fish&lt;/code&gt; 는이 예제에서 유형 술어입니다. 술어는 &lt;code&gt;parameterName is Type&lt;/code&gt; 형식을 취합니다 . 여기서 &lt;code&gt;parameterName&lt;/code&gt; 은 현재 함수 시그니처의 매개 변수 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; 로 &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a72fb1d0e76667fcc523f6bd09ef4ab9fea3ee72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Emit &lt;code&gt;.jsx&lt;/code&gt; files with the JSX unchanged</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; : JSX가 변경되지 않은 상태에서 &lt;code&gt;.jsx&lt;/code&gt; 파일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="759693d33e6545513f3137d1a8e8eb2237a7bdde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve&lt;/code&gt;: Preserves all &lt;code&gt;import&lt;/code&gt; statements whose values or types are never used. This can cause imports/side-effects to be preserved.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; : 값이나 유형이 사용되지 않는 모든 &lt;code&gt;import&lt;/code&gt; 문을 보존합니다 . 이로 인해 가져 오기 / 부작용이 보존 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b17c7abd7c031db77146a2cd28f258bded77d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priorityPollingInterval&lt;/code&gt;: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.</source>
          <target state="translated">&lt;code&gt;priorityPollingInterval&lt;/code&gt; : 모든 파일의 변경 사항을 1 초에 여러 번 확인하지만 휴리스틱을 사용하여 특정 유형의 파일을 다른 파일보다 덜 자주 확인합니다.</target>
        </trans-unit>
        <trans-unit id="45719cae5b4f1126bbe06a22e869a53683b4dee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsx&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="356b8546c5e9f87d62546e14302d659e5aac0d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsx&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the changed to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="translated">&lt;code&gt;react-jsx&lt;/code&gt; : &lt;code&gt;_jsx&lt;/code&gt; 호출로 변경된 &lt;code&gt;.js&lt;/code&gt; 파일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="928e6b291318f0359ffca77cbc70fbead8ac5c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-jsxdev&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="8d018e282aac52faf1a5bce4dc9a51f6270555f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-jsxdev&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX to &lt;code&gt;_jsx&lt;/code&gt; calls</source>
          <target state="translated">&lt;code&gt;react-jsxdev&lt;/code&gt; : JSX 와 함께 &lt;code&gt;.js&lt;/code&gt; 파일을 &lt;code&gt;_jsx&lt;/code&gt; 호출 로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1df5feb5a033ea926607a96dcf9030ae5dd911ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="cbd42a4c20856fac2215f1c094cdf7e0fe7a49a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-native&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with the JSX unchanged</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; : JSX가 변경되지 않은 상태에서 &lt;code&gt;.js&lt;/code&gt; 파일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a35412f7057086a24e3247bacc81f6623d22727f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; , &lt;code&gt;react-native&lt;/code&gt; , &lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf2cc92123c8f6b96a9b964e714c58ae52e0a976" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;: Emit &lt;code&gt;.js&lt;/code&gt; files with JSX changed to the equivalent &lt;code&gt;React.createElement&lt;/code&gt; calls</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; : JSX와 동등한 &lt;code&gt;React.createElement&lt;/code&gt; 호출로 변경된 &lt;code&gt;.js&lt;/code&gt; 파일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="56520eb9a155723fc8f96c437620581627d43f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 매핑 유형 수정 자 및 &lt;code&gt;readonly&lt;/code&gt; 배열</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 튜플</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 대 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc067980e88b210a1f21f1cb123315b9bd2081ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&lt;/code&gt;: The default behavior of dropping &lt;code&gt;import&lt;/code&gt; statements which only reference types.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; : 유형 만 참조하는 &lt;code&gt;import&lt;/code&gt; 문을 삭제하는 기본 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="96f5264bdd8f0f7da8b8b991265caec63e1a9c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt; can be used to provide a separate &amp;ldquo;type layer&amp;rdquo; to files that are not TypeScript or JavaScript by providing a home for generated &lt;code&gt;.d.ts&lt;/code&gt; files in another folder. This is technique is useful for bundled applications where you use &lt;code&gt;import&lt;/code&gt; of files that aren&amp;rsquo;t necessarily code:</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 는 다른 폴더 에 생성 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 대한 홈을 제공하여 TypeScript 또는 JavaScript가 아닌 파일에 별도의 &quot;유형 계층&quot;을 제공하는 데 사용할 수 있습니다 . 이 기술은 반드시 코드가 아닌 파일 &lt;code&gt;import&lt;/code&gt; 를 사용하는 번들 애플리케이션에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="136678c68a61a393796c0532e6210ae786397708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s: string&lt;/code&gt; because &lt;code&gt;&quot;right&quot;&lt;/code&gt; widens to &lt;code&gt;string&lt;/code&gt; on assignment to a mutable variable.</source>
          <target state="translated">&lt;code&gt;s: string&lt;/code&gt; &lt;code&gt;&quot;right&quot;&lt;/code&gt; 가 가변 변수에 할당 될 때 &lt;code&gt;string&lt;/code&gt; 확장 되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; : 해당 &lt;code&gt;.map&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; 가 비활성화되었습니다</target>
        </trans-unit>
        <trans-unit id="aea90566bfe67f9e0c36ee7bab295a897337741f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; is not assignable to &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;&quot;left&quot; | &quot;right&quot;&lt;/code&gt; 할당 할 수 없습니다. | &quot;권리&quot;</target>
        </trans-unit>
        <trans-unit id="8f3d1a64f83a79b3e78e4bbbb23a87b2e76a6983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Function&lt;/code&gt; have built-in type predicates, conveniently leaving the object type for the &lt;code&gt;else&lt;/code&gt; branch. It is possible, however, to generate unions that are difficult to differentiate at runtime. For new code, it&amp;rsquo;s best to build only discriminated unions.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; 및 &lt;code&gt;Function&lt;/code&gt; 에는 기본 제공 유형 술어가 있으므로 &lt;code&gt;else&lt;/code&gt; 분기에 대한 객체 유형을 편리하게 남겨 둡니다 . 그러나 런타임에 구별하기 어려운 공용체를 생성하는 것은 가능합니다. 새 코드의 경우 구별 된 공용체 만 만드는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;symbol&lt;/code&gt; 생성자 는 &lt;code&gt;Symbol&lt;/code&gt; 생성자 를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3993556c0c777190448aa36a736f8d0fb775eeae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronousWatchDirectory&lt;/code&gt;: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in &lt;code&gt;node_modules&lt;/code&gt; from running &lt;code&gt;npm install&lt;/code&gt;), but you might want to disable it with this flag for some less-common setups.</source>
          <target state="translated">&lt;code&gt;synchronousWatchDirectory&lt;/code&gt; : 디렉터리에서 지연된 감시를 비활성화합니다. 지연 감시는 한 번에 많은 파일 변경 (예 : &lt;code&gt;npm install&lt;/code&gt; 실행 으로 &lt;code&gt;node_modules&lt;/code&gt; 변경)이 발생할 때 유용 하지만, 덜 일반적인 설정의 경우이 플래그를 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; : ECMAScript 대상 버전을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this is T&lt;/code&gt; 클래스와 인터페이스의 메소드에 유효한 리턴 유형 주석 인 T 입니다. 유형 탐색 위치 (예 : &lt;code&gt;if&lt;/code&gt; 문) 에서 사용될 경우 호출 표현식 대상 객체의 유형은 &lt;code&gt;T&lt;/code&gt; 로 좁아집니다 .</target>
        </trans-unit>
        <trans-unit id="6a3e8615ef6ee0889b418ba23a22ff83460487dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.accountType&lt;/code&gt; is set by default.</source>
          <target state="translated">&lt;code&gt;this.accountType&lt;/code&gt; 은 기본적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="19cd16ac9e7ad7a6244f1c16c39714b038a0f987" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.address&lt;/code&gt; is declared as potentially &lt;code&gt;undefined&lt;/code&gt; which means it does not have to be set.</source>
          <target state="translated">&lt;code&gt;this.address&lt;/code&gt; 는 잠재적으로 &lt;code&gt;undefined&lt;/code&gt; 것으로 선언되어 설정할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cb7a1bd4a571b4f44bdc27ad1f004b76e910b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.email&lt;/code&gt; is not set and raises an error.</source>
          <target state="translated">&lt;code&gt;this.email&lt;/code&gt; 이 설정되지 않아 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a16b01ee1873ea69988138f8f89512d7f866c8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.name&lt;/code&gt; is set specifically.</source>
          <target state="translated">&lt;code&gt;this.name&lt;/code&gt; 은 구체적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 는 &lt;code&gt;addClickListener&lt;/code&gt; 가 &lt;code&gt;onclick&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 유형을 필요로하지 않는 함수일 것으로 예상 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 는 &lt;code&gt;addClickListener&lt;/code&gt; 가 &lt;code&gt;onclick&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 유형을 필요로하지 않는 함수일 것으로 예상 함을 의미합니다 . 둘째, 다음과 &lt;code&gt;this&lt;/code&gt; 호출 코드에 주석을 답니다 .</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 화살표 기능</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 콜백 의이 매개 변수</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형의 경비원</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="6d97a427e5231bc7e7013c2328603de6d9b7acd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;composite&lt;/code&gt; 가 켜져 있으면 true 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8eb24a65272e3cc37e19daeaae9de19be9d06d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;composite&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 다른 프로그램으로 파이핑하거나 출력을 파일로 리디렉션하지 않는 한 true</target>
        </trans-unit>
        <trans-unit id="2f4d5cb6b37ecf15d042f077e1921ffa51b29618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unreachable code is ignored</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 도달 할 수없는 코드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; 명령 줄</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="translated">&lt;code&gt;tsc -w&lt;/code&gt; 는 여러 구성 파일에서 한 번에 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 는 디스크에있는 기존 파일 만 사용하여이 프로세스를 수행하므로 일부 프로젝트의 출력이 결과 파일에 두 번 이상 존재하므로 올바른 출력 파일을 생성 할 수없는 프로젝트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; , 타이프 스크립트 컴파일러,라는 새로운 플래그를 지원 &lt;code&gt;--showConfig&lt;/code&gt; 을 . &lt;code&gt;tsc --showConfig&lt;/code&gt; 를 실행하면 TypeScript는 효과적인 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 계산하고 ( &lt;code&gt;extends&lt;/code&gt; 필드 에서 상속 된 옵션을 계산 한 후 )이를 인쇄합니다. 일반적으로 구성 문제를 진단하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일에는 새로운 최상위 속성 인 &lt;code&gt;references&lt;/code&gt; 있습니다. 참조 할 프로젝트를 지정하는 객체 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; Node.js 패키지를 통한 tsconfig.json 상속</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 은 폴더를&amp;ldquo;프로젝트&amp;rdquo;로 바꿉니다. &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 항목을 지정하지 않으면 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 포함하는 폴더의 모든 파일 및 모든 해당 서브 디렉토리가 컴파일에 포함됩니다. 일부 파일을 제외하려면 &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; 사용 하고, 컴파일러가 파일을 찾도록하는 대신 모든 파일을 지정하려면 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 유형 가드</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; 는 각 필드 이름이 일치하는 범위로 지정되는 여러 필드를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8b90af89196bf03c26d7dd07ee39139d34a210" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; (default) provide suggestions as warnings to editors</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; (기본값)은 편집자에게 경고로 제안을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7b705485b2b636af977359d61c65b14f8f84a2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for directory changes.</source>
          <target state="translated">&lt;code&gt;useFsEvents&lt;/code&gt; (기본값) : 디렉토리 변경에 운영 체제 / 파일 시스템의 기본 이벤트를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="18c594db4c6e1fb35a69bcfe903f083a12dd62b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEvents&lt;/code&gt; (the default): Attempt to use the operating system/file system&amp;rsquo;s native events for file changes.</source>
          <target state="translated">&lt;code&gt;useFsEvents&lt;/code&gt; (기본값) : 파일 변경에 대해 운영 체제 / 파일 시스템의 기본 이벤트를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d34e428b0ba7d576912bfbed8dfbd6fd75f80e59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;useFsEventsOnParentDirectory&lt;/code&gt;: Attempt to use the operating system/file system&amp;rsquo;s native events to listen for changes on a file&amp;rsquo;s parent directory</source>
          <target state="translated">&lt;code&gt;useFsEventsOnParentDirectory&lt;/code&gt; : 운영 체제 / 파일 시스템의 기본 이벤트를 사용하여 파일의 상위 디렉토리에서 변경 사항을 수신하려고합니다.</target>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언에는 다른 언어에 사용되는 것에 대한 이상한 범위 지정 규칙이 있습니다. 다음 예를 보자.</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 약간의 양처럼 &lt;code&gt;any&lt;/code&gt; 전혀 어떠한 형태를 갖는 부재 :. 일반적으로 이것을 값을 반환하지 않는 반환 유형의 함수로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;any&lt;/code&gt; 유형을 갖습니다 . 이것은 프로그램이 유형을 검사한다는 것을 의미했지만 기술적 으로 다음과 같이 &lt;code&gt;y&lt;/code&gt; 로 무엇이든 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e0a0801dcb35d26012a58fcc2e418fc7f6f784d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{@link &amp;hellip;}&lt;/code&gt; (&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/35524&quot;&gt;issue #35524&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;{@link &amp;hellip;}&lt;/code&gt; &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/35524&quot;&gt;link &lt;/a&gt;&amp;hellip;} ( 문제 # 35524 )</target>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(공통 루트 디렉토리는 입력 파일 목록에서 계산됩니다)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(플랫폼 특정)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6d59622e066b207853d896915edd6f8b0489e8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial strength string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; 유형 가드&lt;/em&gt; 는 생성자 함수를 사용하여 유형을 좁히는 방법입니다. 예를 들어, 우리의 산업적 강도의 스트링 패더 예제를 이전에 빌려 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; type guard&lt;/em&gt; 는 생성자 함수를 사용하여 유형을 좁히는 방법입니다. 예를 들어, 이전의 산업 문자열 패더 예제를 빌려 봅시다.</target>
        </trans-unit>
        <trans-unit id="71df9cb200fe1b9d9980debd24153321fc6684ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;An exploration into the &lt;code&gt;HTMLElement&lt;/code&gt; type&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;HTMLElement&lt;/code&gt; 유형 탐색&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;모든 컴파일러 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="translated">&lt;em&gt;수업 데코레이터&lt;/em&gt; 가 &lt;em&gt;수업&lt;/em&gt; 에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TypeScript 컴파일러 구성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="translated">&lt;em&gt;음주&lt;/em&gt; 가 선언 파일을 패키징하지 않는 경우 NPM 형 선언 패키지에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 보다 구체적인 서명 후 더 일반적인 서명을 넣어 정렬 오버로드 :</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 사용 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 가능한 선택적 매개 변수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 반환 형식의 사용 &lt;code&gt;void&lt;/code&gt; 값이 무시됩니다 콜백을 :</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 종류의 사용 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 및 &lt;code&gt;symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 가능한 사용 조합 유형 :</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 의 최대 인수에 대응을 사용하여 하나의 과부하를 쓰기 :</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 이 아닌 선택 사항으로 쓰기 콜백 매개 변수를 :</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="translated">&lt;em&gt;당신&lt;/em&gt; 과 그것을 결합 &lt;em&gt;하지 말고&lt;/em&gt; 각각 자신의 파일에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;패키지의 선언도 복사 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6641e250515c31ff4c29c3458f5aa359e7992e5f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;하지 마십시오&lt;/em&gt; 사상 형식 매개 변수를 사용하지 않는 일반적인 유형이있다. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--&quot;&gt;TypeScript FAQ 페이지&lt;/a&gt; 에서 자세한 내용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;하지 마십시오&lt;/em&gt; 사상 형식 매개 변수를 사용하지 않는 일반적인 유형이있다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Object&lt;/code&gt; 유형을 사용 &lt;em&gt;하지 마십시오.&lt;/em&gt; 이 유형은 JavaScript 코드에서 거의 사용되지 않는 기본이 아닌 박스형 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;보다 구체적인 과부하가 걸리기 전에 일반적인 과부하를 넣지 &lt;em&gt;마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;선언 파일에 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 를 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a55cf7c66dde349c496b594f4eb9369bf866bddb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;any&lt;/code&gt; as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler &lt;em&gt;effectively&lt;/em&gt; treats &lt;code&gt;any&lt;/code&gt; as &amp;ldquo;please turn off type checking for this thing&amp;rdquo;. It is similar to putting an &lt;code&gt;@ts-ignore&lt;/code&gt; comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven&amp;rsquo;t migrated yet as &lt;code&gt;any&lt;/code&gt;, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;JavaScript 프로젝트를 TypeScript로 마이그레이션하는 과정이 아니라면 &lt;code&gt;any&lt;/code&gt; 것도 유형으로 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; . 컴파일러 는 &lt;code&gt;any&lt;/code&gt; 것을 &quot;이 항목에 대한 유형 검사를 해제하십시오&quot;로 &lt;em&gt;효과적으로&lt;/em&gt; 처리 합니다 . 변수의 모든 사용에 대해 &lt;code&gt;@ts-ignore&lt;/code&gt; 주석 을 넣는 것과 유사 합니다. 당신이 물건 당신이로 아직 마이그레이션하지 않은의 형태 설정할 수 있습니다 당신이 첫번째 타이프에 자바 스크립트 프로젝트를 마이그레이션 할 때 매우 도움이 될 수있는 &lt;code&gt;any&lt;/code&gt; 하지만, 전체 타이프 라이터 프로젝트에 당신은 당신의 프로그램의 어떤 부분이에 대한 유형 검사를 비활성화된다 사용해.</target>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;실제로 의미하지 않는 한 콜백에 선택적 매개 변수를 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;하지 마십시오&lt;/em&gt; 반환을 사용하여 입력 한 &lt;code&gt;any&lt;/code&gt; 값이 무시됩니다 콜백 :</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;하나의 인수 위치에서만 유형에 따라 다른 과부하를 &lt;em&gt;쓰지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;콜백 arity에서만 다른 별도의 오버로드를 작성 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;후행 매개 변수에서만 다른 여러 과부하를 쓰지 &lt;em&gt;마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;먼저 몇 가지 ES2016 용어 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;글로벌 플러그인&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;글로벌 수정 모듈&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSBuild 전용 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;모듈 플러그인&lt;/em&gt; 또는 &lt;em&gt;UMD 플러그인&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모듈 확인&lt;/em&gt; 은 컴파일러가 가져 오기가 참조하는 것을 파악하기 위해 사용하는 프로세스입니다. &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt; 와 같은 import 문을 고려하십시오 . 의 사용 확인하기 위해 &lt;code&gt;a&lt;/code&gt; , 컴파일러가 나타내는 정확히 알 필요가있다, 그 정의 확인해야합니다 &lt;code&gt;moduleA&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSBuild에서 지원되지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : jspm에서 현재 TypeScript 지원은 0.16beta입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d7fac5427486f2e613c21aa283c576a7b6e2602" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If you hover over &lt;code&gt;MyBool&lt;/code&gt; above, you&amp;rsquo;ll see that it is classed as &lt;code&gt;boolean&lt;/code&gt;. That&amp;rsquo;s a property of the Structural Type System. More on this below.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 위의 &lt;code&gt;MyBool&lt;/code&gt; 위로 마우스를 가져 가면 &lt;code&gt;boolean&lt;/code&gt; 으로 분류 된 것을 볼 수 있습니다 . 이것이 Structural Type System의 속성입니다. 자세한 내용은 아래에서 확인하세요.</target>
        </trans-unit>
        <trans-unit id="8e7bb0c2f049bd85bb9a3c22454271e46a22ff54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; In order for this to work like you would expect, your &lt;code&gt;tsx&lt;/code&gt; file must include an &lt;code&gt;export&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; so that it is considered a module.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 예상대로 작동하려면 &lt;code&gt;tsx&lt;/code&gt; 파일 에 모듈로 간주되도록 &lt;code&gt;export&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b251d8e6b2dce1d359821b61fd4a66441a0a312c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: You can make JS emit terser by enabling &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;#importHelpers&quot;&gt; &lt;code&gt;importHelpers&lt;/code&gt; &lt;/a&gt; 를 활성화하여 JS가 더 간결 하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e44bb4e42ffe01dfa1f4d3898748e7a02d03761" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Only&lt;/em&gt; emit &lt;code&gt;.d.ts&lt;/code&gt; files; do not emit &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;.d.ts&lt;/code&gt; 파일 &lt;em&gt;만&lt;/em&gt; 내 보냅니다 . &lt;code&gt;.js&lt;/code&gt; 파일을 내 보내지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="translated">&lt;em&gt;매개 변수 데코레이터&lt;/em&gt; 가 생성자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="translated">&lt;em&gt;파라미터 장식&lt;/em&gt; 이어서, &lt;em&gt;방법&lt;/em&gt; , &lt;em&gt;액세스 장치&lt;/em&gt; , 또는 &lt;em&gt;속성 장식은&lt;/em&gt; 각 인스턴스 부재에 적용된다.</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="translated">&lt;em&gt;파라미터 장식&lt;/em&gt; 이어서, &lt;em&gt;방법&lt;/em&gt; , &lt;em&gt;액세스 장치&lt;/em&gt; , 또는 &lt;em&gt;속성 장식은&lt;/em&gt; 각 고정 부재에 적용된다.</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="translated">&lt;em&gt;나머지 매개 변수&lt;/em&gt; 는 무한한 수의 선택적 매개 &lt;em&gt;변수&lt;/em&gt; 로 취급됩니다. rest 매개 변수에 인수를 전달할 때 원하는만큼 사용할 수 있습니다. 당신은 아무 것도 통과 할 수 없습니다. 컴파일러는 생략 부호 ( &lt;code&gt;...&lt;/code&gt; ) 뒤에 주어진 이름으로 전달 된 인수 배열을 빌드 하여 함수에서 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="feac7405587931819084625ba52e25fde237d326" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NPM 설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;NPM&lt;/em&gt; 번호 &lt;em&gt;설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb153592255ec6892092e3704ed2728ce144e9c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;꿀꺽 꿀꺽 설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;꿀꺽 꿀꺽&lt;/em&gt; # &lt;em&gt;설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f0a451725c04750b6fb4ecce8b55da356ae465a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data. It has no runtime impact and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;타입 어설 션&lt;/em&gt; 은 컴파일러에게 &quot;저를 믿으세요. 제가하는 일을 알고 있습니다.&quot;라고 알려주는 방법입니다. 유형 어설 션은 다른 언어의 유형 캐스트와 유사하지만 데이터의 특별한 검사 또는 재구성을 수행하지 않습니다. 런타임에 영향을 미치지 않으며 컴파일러에서만 사용됩니다. TypeScript는 프로그래머가 필요한 특수 검사를 수행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;타입 어설 션&lt;/em&gt; 은 컴파일러에게&amp;ldquo;내가 뭘하는지 알고있다&amp;rdquo;고 말해주는 방법이다. 형식 어설 션은 다른 언어로 된 형식 캐스트와 유사하지만 데이터의 특별한 검사 또는 재구성을 수행하지 않습니다. 런타임에 영향을 미치지 않으며 컴파일러가 순수하게 사용합니다. TypeScript는 프로그래머가 필요한 특수 검사를 수행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 콜백이 매개 변수를 무시하는 것이 항상 합법적이므로 더 짧은 과부하가 필요하지 않습니다. 짧은 콜백을 먼저 제공하면 첫 번째 오버로드와 일치하기 때문에 잘못 입력 된 함수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 이것은 귀하의 기능에 가치를 &quot;통과시키는&quot;사람들에게 중요합니다 :</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 두 가지 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : TypeScript는 함수 호출을 해결할 때 &lt;em&gt;첫 번째로 일치하는 오버로드를&lt;/em&gt; 선택 합니다. 이전의 과부하가 이후의 과부하보다 &quot;일반적인&quot;경우, 나중에 과부하가 효과적으로 숨겨져 호출 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : &lt;code&gt;void&lt;/code&gt; 를 사용하면 실수로 &lt;code&gt;x&lt;/code&gt; 의 반환 값을 검사하지 않은 방식으로 사용하지 못하므로 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;용어에 대한 참고 사항 :&lt;/strong&gt; TypeScript 1.5에서는 명명법이 변경되었습니다. &amp;ldquo;내부 모듈&amp;rdquo;은 이제&amp;ldquo;네임 스페이스&amp;rdquo;입니다. &quot;외부 모듈&quot;은 이제 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; 의 용어 와 일치하도록 간단히 &quot;모듈&quot;입니다 (즉, 해당 &lt;code&gt;module X {&lt;/code&gt; 는 현재 선호되는 &lt;code&gt;namespace X {&lt;/code&gt; 와 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;커맨드 라인&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4a14a1385687f20b567e75759c59e54cfb6cc9ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default&lt;/strong&gt;: The longest common path of all non-declaration input files. If &lt;code&gt;composite&lt;/code&gt; is set, the default is instead the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;strong&gt;기본값&lt;/strong&gt; : 모든 비 선언 입력 파일의 가장 긴 공통 경로입니다. &lt;code&gt;composite&lt;/code&gt; 이 설정된 경우 기본값은 대신 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 포함 된 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="979f72af53937fa00189a4108423e158a79f69c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re looking for more information about the compiler options in a tsconfig, check out the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tsconfig의 컴파일러 옵션에 대한 자세한 정보를 찾고 있다면 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig 참조를&lt;/a&gt; 확인하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e74e37bb8dd2fa2fd06958c252f8d1e1c0b9f1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: &lt;code&gt;exclude&lt;/code&gt;&lt;em&gt;only&lt;/em&gt; changes which files are included as a result of the &lt;code&gt;include&lt;/code&gt; setting. A file specified by &lt;code&gt;exclude&lt;/code&gt; can still become part of your codebase due to an &lt;code&gt;import&lt;/code&gt; statement in your code, a &lt;code&gt;types&lt;/code&gt; inclusion, a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive, or being specified in the &lt;code&gt;files&lt;/code&gt; list.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; : &lt;code&gt;include&lt;/code&gt; 설정 의 결과로 포함되는 파일 변경 &lt;em&gt;만 &lt;/em&gt; &lt;code&gt;exclude&lt;/code&gt; 합니다. &lt;code&gt;exclude&lt;/code&gt; 로 지정된 파일은 코드의 &lt;code&gt;import&lt;/code&gt; 문, &lt;code&gt;types&lt;/code&gt; 포함, &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; 지시문 또는 &lt;code&gt;files&lt;/code&gt; 목록 에 지정되어 있기 때문에 코드베이스의 일부가 될 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f6f93e3961e1411696baa4f771bbaaa46934b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You can use &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support&quot;&gt;the playground to explore JSDoc support&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=truee=4#example/jsdoc-support&quot;&gt;플레이 그라운드를&lt;/a&gt; 사용 하여 JSDoc 지원을 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1f1a236aca787e2d4cec9e772e0a3c360a7f918" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; enabling &lt;code&gt;downlevelIteration&lt;/code&gt; does not improve compliance if &lt;code&gt;Symbol.iterator&lt;/code&gt; is not present in the runtime.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 런타임에 &lt;code&gt;Symbol.iterator&lt;/code&gt; 가없는 경우 &lt;code&gt;downlevelIteration&lt;/code&gt; 을 활성화 해도 규정 준수가 향상되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 지시문은 더 이상 사용되지 않습니다. &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; 사용하십시오 . 대신 진술.</target>
        </trans-unit>
        <trans-unit id="d5eef7e4ca0f22611baae36661abda073e29f1fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook Reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;핸드북 참조&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f90c86a6f498b3ff28fdbaa9255f915348f2c482" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Handbook&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;핸드북&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes" xml:space="preserve">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="translated">&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; 보다 상세하게는, 상기 호모 모르 픽 형태 같은 매핑 유형.</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="translated">&lt;sup&gt;[1]&lt;/sup&gt; 이 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="translated">&lt;sup&gt;[2]&lt;/sup&gt; 이 옵션은 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서만 허용되며 명령 행 스위치를 통해서 는 허용 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes" xml:space="preserve">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="translated">======== 모듈 이름 '타이프 라이터'가되었다 &lt;strong&gt;성공적으로 해결&lt;/strong&gt; 'node_modules / 타이프 라이터 / lib 디렉토리 / typescript.d.ts'로. ========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes" xml:space="preserve">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="translated">======== &lt;strong&gt;'src / app.ts'&lt;/strong&gt; 에서 모듈 &lt;strong&gt;'typescript'&lt;/strong&gt; 해결 중 . ========&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes" xml:space="preserve">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes" xml:space="preserve">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes" xml:space="preserve">
          <source>@param and @returns</source>
          <target state="translated">@param과 @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes" xml:space="preserve">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="translated">&amp;ldquo;베어 임포트&amp;rdquo;는 부작용에 대해서만 모듈을 임포트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="translated">&lt;code&gt;// @ts-ignore&lt;/code&gt; 코멘트는 다음과 같은 줄에 발생한 모든 오류를 억제한다. &lt;code&gt;@ts-ignore&lt;/code&gt; 다음에 주석의 나머지 부분에 어떤 오류가 억제되는지 설명하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 선언은 충돌을 생성하지 않는 방법으로 새로운 유형, 값 및 네임 스페이스를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 또는 &lt;code&gt;module&lt;/code&gt; 값을 포함 선언</target>
        </trans-unit>
        <trans-unit id="0e1b65fe0101802b4d7f9ed8f568068bb52794bf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; A를 &lt;code&gt;typesVersions&lt;/code&gt; 의 필드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일을 사용하여 다른 파일에서 구성을 상속 할 수 &lt;code&gt;extends&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일이 기본 컴파일러 옵션 (전술 한 바와 같이) 기본적으로 포함 된 모든 파일을 컴파일하는, 완전히 비어로 허용된다.</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;클래스 실내 장식은&lt;/em&gt; 단지 클래스 선언하기 전에 선언된다. 클래스 데코레이터는 클래스의 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="translated">&lt;em&gt;실내 장식은&lt;/em&gt; A를 부착 할 수 선언의 특별한 종류의 &lt;a href=&quot;#class-decorators&quot;&gt;클래스 선언&lt;/a&gt; , &lt;a href=&quot;#method-decorators&quot;&gt;방법&lt;/a&gt; , &lt;a href=&quot;#accessor-decorators&quot;&gt;접근&lt;/a&gt; , &lt;a href=&quot;#property-decorators&quot;&gt;재산&lt;/a&gt; , 또는 &lt;a href=&quot;#parameter-decorators&quot;&gt;매개 변수&lt;/a&gt; . 데코레이터는 &lt;code&gt;@expression&lt;/code&gt; 형식을 사용합니다 . 여기서 &lt;code&gt;expression&lt;/code&gt; 은 데코레이션 된 선언에 대한 정보와 함께 런타임에 호출 될 함수로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;방법 실내 장식은&lt;/em&gt; 단지 메소드 선언하기 전에 선언된다. 데코레이터는 메소드 의 &lt;em&gt;특성 설명자&lt;/em&gt; 에 적용되며 메소드 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일, 오버로드 또는 기타 주변 환경 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스)에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;매개 변수 데코레이터는&lt;/em&gt; 단지 매개 변수 선언하기 전에 선언된다. 매개 변수 데코레이터는 클래스 생성자 또는 메소드 선언의 함수에 적용됩니다. 매개 변수 데코레이터는 선언 파일, 오버로드 또는 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스)에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;재산권 실내 장식은&lt;/em&gt; 단지 속성 선언하기 전에 선언된다. 속성 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="translated">&lt;em&gt;UMD의&lt;/em&gt; 모듈은 가능 하나 &lt;em&gt;하나&lt;/em&gt; (가져 오기를 통해) 모듈로서 사용되거나, (a 모듈 로더없는 환경에서 실행하면) 전역있다. &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; 와 같은 많은 인기있는 라이브러리 가 이런 식으로 작성되었습니다. 예를 들어 Node.js 또는 RequireJS를 사용하면 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;판별 속성 유형 가드&lt;/em&gt; 형식의 표현이다 &lt;code&gt;x.p == v&lt;/code&gt; , &lt;code&gt;x.p === v&lt;/code&gt; , &lt;code&gt;x.p != v&lt;/code&gt; 또는 &lt;code&gt;x.p !== v&lt;/code&gt; , 여기서 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 특성 및 문자열 리터 형의 발현 또는 문자열 리터럴 유형의 결합 판별 속성 유형 가드 유형 좁아 &lt;code&gt;x&lt;/code&gt; 의 해당 구성 유형 &lt;code&gt;x&lt;/code&gt; 판별 속성이 &lt;code&gt;p&lt;/code&gt; 의 가능한 값 중 하나와 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="translated">&lt;em&gt;글로벌 플러그인은&lt;/em&gt; 일부 글로벌의 모양을 변경 글로벌 코드입니다. &lt;em&gt;전역 수정 모듈&lt;/em&gt; 과 마찬가지로 런타임 충돌 가능성이 높아집니다.</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="translated">&lt;em&gt;글로벌 개량 모듈&lt;/em&gt; 전역 값을 기존 달라져들은 가져올 때. 예를 들어 가져올 때 &lt;code&gt;String.prototype&lt;/code&gt; 에 새 멤버를 추가하는 라이브러리가있을 수 있습니다 . 이 패턴은 런타임 충돌 가능성으로 인해 다소 위험하지만 여전히 선언 파일을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="translated">&lt;em&gt;글로벌&lt;/em&gt; 라이브러리 (즉, 어떤 형태의 사용하지 않고 세계적인 범위에서 액세스 할 수있는 하나입니다 &lt;code&gt;import&lt;/code&gt; ). 많은 라이브러리는 사용하기 위해 하나 이상의 전역 변수를 노출합니다. 예를 들어, &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 를 사용 하는 경우 &lt;code&gt;$&lt;/code&gt; 변수는 간단히 참조하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="translated">&lt;em&gt;모듈 플러그는&lt;/em&gt; 다른 모듈 (UMD 또는 모듈 중 하나)의 형상을 변화시킨다. 예를 들어 Moment.js에서 &lt;code&gt;moment-range&lt;/code&gt; 는 &lt;code&gt;moment&lt;/code&gt; 객체에 새로운 &lt;code&gt;range&lt;/code&gt; 메서드를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="translated">&lt;em&gt;상대 가져 오기&lt;/em&gt; 시작이다 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="translated">&lt;strong&gt;믹스 인 클래스는&lt;/strong&gt; 클래스 선언 또는 표현 &lt;code&gt;extends&lt;/code&gt; 타입 파라미터 유형의 표현. 다음 규칙은 mixin 클래스 선언에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;믹스 인 생성자 타입은&lt;/strong&gt; 타입의 단일 나머지 인자 단일 구조체 서명 갖는 형태를 의미 &lt;code&gt;any[]&lt;/code&gt; 와 같은 객체 리턴 타입. 예를 들어, 입력 물체를 부여 &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; 인스턴스 타입와 믹스 인 생성자 타입 &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes" xml:space="preserve">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="translated">Array.prototype.concat에 의해 객체가 배열 요소로 병합되어야 함을 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes" xml:space="preserve">
          <source>A Note on Soundness</source>
          <target state="translated">건전성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes" xml:space="preserve">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="translated">객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값입니다. 내장 메소드 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a9182f58f65016d093319fe062109a9686adac2" translate="yes" xml:space="preserve">
          <source>A TSConfig file in a directory indicates that the directory is the root of a TypeScript or JavaScript project. The TSConfig file can be either a &lt;code&gt;tsconfig.json&lt;/code&gt; or &lt;code&gt;jsconfig.json&lt;/code&gt;, both have the same behavior and the same set of config variables.</source>
          <target state="translated">디렉터리의 TSConfig 파일은 디렉터리가 TypeScript 또는 JavaScript 프로젝트의 루트임을 나타냅니다. TSConfig 파일은 &lt;code&gt;tsconfig.json&lt;/code&gt; 또는 &lt;code&gt;jsconfig.json&lt;/code&gt; 일 수 있으며 둘 다 동일한 동작과 동일한 구성 변수 세트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="855d73d13b972d2597c136c97ec4024c17beeaa2" translate="yes" xml:space="preserve">
          <source>A Typed Superset of JavaScript</source>
          <target state="translated">유형화 된 JavaScript 수퍼 세트</target>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes" xml:space="preserve">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">빌드 단계는 &lt;code&gt;/src/views&lt;/code&gt; 및 &lt;code&gt;/generated/templates/views&lt;/code&gt; 의 파일을 출력의 동일한 디렉토리로 복사합니다 . 런타임시보기는 해당 템플리트가 옆에 존재할 것으로 예상 할 수 있으므로 상대 이름을 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 으로 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes" xml:space="preserve">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="translated">일반 함수에 대한 호출은 인수를 사용하여 유형 매개 변수를 유추합니다. 때때로이 프로세스는 주로 추론 소스가 없기 때문에 모든 유형을 추론하지 못합니다. 이 경우 유형 매개 변수는 기본적으로 &lt;code&gt;any&lt;/code&gt; 로 설정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes" xml:space="preserve">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="translated">클래스 생성자는 &lt;code&gt;private&lt;/code&gt; 또는 &lt;code&gt;protected&lt;/code&gt; 로 표시 될 수 있습니다 . 전용 생성자가있는 클래스는 클래스 본문 외부에서 인스턴스화 할 수 없으며 확장 할 수 없습니다. 보호 생성자가있는 클래스는 클래스 본문 외부에서 인스턴스화 할 수 없지만 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes" xml:space="preserve">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="translated">클래스 선언 ( &lt;code&gt;class C { }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="translated">기존 클래스 또는 인터페이스 선언과 병합되는 클래스 또는 인터페이스 선언은 기존 유형 매개 변수의 기본값을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="translated">기존 클래스 또는 인터페이스 선언과 병합되는 클래스 또는 인터페이스 선언은 기본값을 지정하는 한 새 유형 매개 변수를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f827247ace6a9f06365439ae3c387f57673379" translate="yes" xml:space="preserve">
          <source>A collection of extra checks, which somewhat cross the boundaries of compiler vs linter. You may prefer to use a tool like &lt;a href=&quot;https://github.com/typescript-eslint/typescript-eslint#typescript-eslint&quot;&gt;eslint&lt;/a&gt; over these options if you are looking for more in-depth rules.</source>
          <target state="translated">컴파일러와 린터의 경계를 다소 넘는 추가 검사 모음입니다. 보다 심층적 인 규칙을 찾고 있다면 이러한 옵션보다 &lt;a href=&quot;https://github.com/typescript-eslint/typescript-eslint#typescript-eslint&quot;&gt;eslint&lt;/a&gt; 와 같은 도구를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes" xml:space="preserve">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="translated">일반적이고 위험한 오류는 함수를 호출하지 않는 것입니다. 특히 함수에 인수가 없거나 함수가 아닌 속성 일 수있는 방식으로 이름이 지정된 경우에 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="e559cf07cd2ab15a57eb14b846956299870d3251" translate="yes" xml:space="preserve">
          <source>A common case for their use is for describing config values:</source>
          <target state="translated">일반적인 사용 사례는 구성 값을 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="012e1680ac04035d05806ae768fbd8f7e9e4d64b" translate="yes" xml:space="preserve">
          <source>A common case where you might think to use &lt;code&gt;skipLibCheck&lt;/code&gt; is when there are two copies of a library&amp;rsquo;s types in your &lt;code&gt;node_modules&lt;/code&gt;. In these cases, you should consider using a feature like &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/selective-version-resolutions/&quot;&gt;yarn&amp;rsquo;s resolutions&lt;/a&gt; to ensure there is only one copy of that dependency in your tree or investigate how to ensure there is only one copy by understanding the dependency resolution to fix the issue without additional tooling.</source>
          <target state="translated">사용할 생각하는 일반적인 경우 &lt;code&gt;skipLibCheck&lt;/code&gt; 은 당신의 라이브러리의 유형의 두 복사본이있는 경우입니다 &lt;code&gt;node_modules&lt;/code&gt; 가 . 이러한 경우, 트리에 해당 종속성의 복사본이 하나만 있는지 &lt;a href=&quot;https://yarnpkg.com/lang/en/docs/selective-version-resolutions/&quot;&gt;확인&lt;/a&gt; 하기 위해 yarn의 해상도 와 같은 기능을 사용하는 것을 고려 하거나 추가 도구없이 문제를 해결하기 위해 종속성 해결을 이해하여 복사본이 하나만 있는지 확인하는 방법을 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="translated">일반적인 실수는 &lt;code&gt;import&lt;/code&gt; 문을 사용하지 않고 &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; 구문을 사용하여 모듈 파일을 참조하는 것 입니다. 차이를 이해하기 위해서, 우리는 먼저 필요 컴파일러가의 경로에 따라 모듈에 대한 형식 정보를 찾을 수있는 방법을 이해하기 위해 &lt;code&gt;import&lt;/code&gt; 예를 들어 ( &lt;code&gt;...&lt;/code&gt; 에서 &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt; , &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt; 등) 경로.</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes" xml:space="preserve">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">JavaScript의 일반적인 패턴은 &lt;code&gt;typeof&lt;/code&gt; 또는 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 하여 런타임시 표현식의 유형을 검사하는 것입니다. TypeScript는 이제 이러한 조건을 이해하고 &lt;code&gt;if&lt;/code&gt; 블록 에서 사용될 때 유형 유추를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes" xml:space="preserve">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="translated">일반적인 작업은 기존 유형을 사용하여 각 속성을 선택적으로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d835d6d7b039c2f6e80d9f60ed8e2cfe5e3e986f" translate="yes" xml:space="preserve">
          <source>A common technique for working with unions is to have a single field which uses literal types which you can use to let TypeScript narrow down the possible current type. For example, we&amp;rsquo;re going to create a union of three types which have a single shared field.</source>
          <target state="translated">공용체로 작업하는 일반적인 기술은 TypeScript가 가능한 현재 유형을 좁히는 데 사용할 수있는 리터럴 유형을 사용하는 단일 필드를 갖는 것입니다. 예를 들어, 단일 공유 필드가있는 세 가지 유형의 공용체를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes" xml:space="preserve">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="translated">일반적인 해결 방법은 IIFE (즉시 호출 된 함수 표현식)를 사용하여 각 반복에서 &lt;code&gt;i&lt;/code&gt; 를 캡처하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 중입니다 &lt;em&gt;해결&lt;/em&gt; 에 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 또는 &lt;em&gt;연기&lt;/em&gt; 조건이 하나 개 이상의 유형의 변수에 의존하기 때문에. 때 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;U&lt;/code&gt; 가 있는지 여부에 해결하는 형태 변수가 포함 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; 를 , 또는 연기, 타입 시스템이 있다는 결론을 내릴 수있는 충분한 정보가 있는지 여부에 따라 정해집니다 &lt;code&gt;T&lt;/code&gt; 는 항상에 할당 할 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="translated">조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 중입니다 &lt;em&gt;해결&lt;/em&gt; 에 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 또는 &lt;em&gt;연기&lt;/em&gt; 조건이 하나 개 이상의 유형의 변수에 의존하기 때문에. 해결 또는 연기 여부는 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3632cf4e26292b0e76ecac870e4423c2cd5b98f7" translate="yes" xml:space="preserve">
          <source>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="translated">조건부 유형은 유형 관계 테스트로 표현 된 조건에 따라 두 가지 가능한 유형 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes" xml:space="preserve">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="translated">생성자는 &lt;code&gt;protected&lt;/code&gt; 로 표시 될 수도 있습니다 . 이것은 클래스를 포함하는 클래스 외부에서 인스턴스화 할 수 없지만 확장 할 수 있음을 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes" xml:space="preserve">
          <source>A couple of limitations</source>
          <target state="translated">몇 가지 한계</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes" xml:space="preserve">
          <source>A couple of things to note about accessors:</source>
          <target state="translated">접근 자에 대해 참고할 사항 :</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes" xml:space="preserve">
          <source>A decorator is:</source>
          <target state="translated">데코레이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes" xml:space="preserve">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="translated">소멸 선언은 하나 이상의 명명 된 변수를 도입하고 객체의 속성 또는 배열의 요소에서 추출 된 값으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes" xml:space="preserve">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="translated">최상위 선언 만 &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 를 제거 하고 모든 레벨을 '위로'이동)</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes" xml:space="preserve">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="translated">파생 개체를 만드는 데 사용되는 생성자 함수 인 함수 값 속성입니다.</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes" xml:space="preserve">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="translated">본문에 &lt;code&gt;arguments&lt;/code&gt; 참조에 대한 참조가 있는 함수 는 내재적으로 var-arg 매개 변수가있는 것으로 간주됩니다 (예 : &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt; ). JSDoc var-arg 구문을 사용하여 인수 유형을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes" xml:space="preserve">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="translated">함수의 타입은 인자의 타입과 리턴 타입의 두 부분이 동일합니다. 전체 기능 유형을 작성할 때 두 부분이 모두 필요합니다. 매개 변수 유형과 마찬가지로 매개 변수 유형을 작성하여 각 매개 변수에 이름과 유형을 지정합니다. 이 이름은 가독성을 돕기위한 것입니다. 대신 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes" xml:space="preserve">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="translated">생성기 함수는 함수와 마찬가지로 반환 유형 주석을 가질 수 있습니다. 주석은 함수가 반환 한 생성기 유형을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes" xml:space="preserve">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="translated">타입 주석이없는 생성기 함수는 타입 주석을 유추 할 수 있습니다. 따라서 다음의 경우 유형은 yield 문에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes" xml:space="preserve">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="translated">제네릭 클래스는 제네릭 인터페이스와 모양이 비슷합니다. 제네릭 클래스에는 클래스 이름 뒤에 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 로 제네릭 형식 매개 변수 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes" xml:space="preserve">
          <source>A generic parameter default follows the following rules:</source>
          <target state="translated">일반 매개 변수 기본값은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="58295366adbe5e286eb8eb3bd14ff3824be0727b" translate="yes" xml:space="preserve">
          <source>A good first read for your daily TS work.</source>
          <target state="translated">A good first read for your daily TS work.</target>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes" xml:space="preserve">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="translated">열거 형의 편리한 기능은 숫자 형 값에서 열거 형의 해당 값 이름으로 이동할 수도 있다는 것입니다. 예를 들어, 값이 &lt;code&gt;2&lt;/code&gt; 이지만 위 의 &lt;code&gt;Color&lt;/code&gt; 열거 형 에 매핑 된 값 이 확실하지 않은 경우 해당 이름을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes" xml:space="preserve">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="translated">JavaScript의 표준 데이터 유형 집합에 유용한 추가 기능은 &lt;code&gt;enum&lt;/code&gt; 입니다. C #과 같은 언어에서와 같이 열거 형은 숫자 값 집합에 더 친숙한 이름을 부여하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes" xml:space="preserve">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="translated">TypeScript에서 모듈의 주요 기능은 서로 다른 두 모듈이 동일한 범위에 이름을 제공하지 않는다는 것입니다. 모듈 소비자는 할당 할 이름을 결정하기 때문에 네임 스페이스에서 내 보낸 심볼을 사전에 마무리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes" xml:space="preserve">
          <source>A library can consist of multiple modules, such as</source>
          <target state="translated">라이브러리는 다음과 같은 여러 모듈로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8770c272f2840fccfa97bc4c9d703b31f41107" translate="yes" xml:space="preserve">
          <source>A literal is a more concrete sub-type of a collective type. What this means is that &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, but a &lt;code&gt;string&lt;/code&gt; is not &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; inside the type system.</source>
          <target state="translated">리터럴은 집합체 유형의보다 구체적인 하위 유형입니다. 이것이 의미하는 바는 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 가 &lt;code&gt;string&lt;/code&gt; 이지만 유형 시스템 내에서 &lt;code&gt;string&lt;/code&gt; 이 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 가 아니라는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes" xml:space="preserve">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="translated">오랫동안 기다려온 기능은 TypeScript 프로젝트를위한 스마트 한 증분 빌드입니다. 3.0에서는 &lt;code&gt;tsc&lt;/code&gt; 와 함께 &lt;code&gt;--build&lt;/code&gt; 플래그를 사용할 수 있습니다 . 이것은 사실상 간단한 컴파일러보다 빌드 오케 스트레이터처럼 동작 하는 &lt;code&gt;tsc&lt;/code&gt; 의 새로운 진입 점입니다 .</target>
        </trans-unit>
        <trans-unit id="763f393de249964da063f318cee51c3e7602546a" translate="yes" xml:space="preserve">
          <source>A lot of the time the answer is &lt;em&gt;&amp;ldquo;it depends&amp;rdquo;&lt;/em&gt;, or &lt;em&gt;&amp;ldquo;someone may have decided for you&amp;rdquo;&lt;/em&gt; depending on the project. If you are building your project with an existing framework like &lt;a href=&quot;https://tsdx.io&quot;&gt;tsdx&lt;/a&gt;, &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;, &lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt; or any framework mentioned in the &lt;a href=&quot;https://www.typescriptlang.org/docs/home&quot;&gt;Getting Started&lt;/a&gt; then this decision is handled for you.</source>
          <target state="translated">대부분의 경우 대답은 프로젝트에 따라 &lt;em&gt;&amp;ldquo;&lt;/em&gt; 상황에 따라 &lt;em&gt;다릅니다&amp;rdquo;&lt;/em&gt; 또는 &lt;em&gt;&amp;ldquo;누군가가 당신을 위해 결정했을 수도 있습니다&amp;rdquo;&lt;/em&gt; 입니다. &lt;a href=&quot;https://tsdx.io&quot;&gt;tsdx&lt;/a&gt; , &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt; , &lt;a href=&quot;https://nestjs.com/&quot;&gt;NestJS&lt;/a&gt; 또는 &lt;a href=&quot;https://www.typescriptlang.org/docs/home&quot;&gt;시작하기&lt;/a&gt; 에서 언급 된 프레임 워크와 같은 기존 프레임 워크로 프로젝트를 빌드하는 경우이 결정이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes" xml:space="preserve">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="translated">소프트웨어 엔지니어링의 주요 부분은 잘 정의되고 일관된 API가있을뿐 아니라 재사용 할 수있는 구성 요소를 구축하는 것입니다. 오늘날의 데이터와 미래의 데이터를 처리 할 수있는 구성 요소는 대규모 소프트웨어 시스템을 구축 할 수있는 가장 유연한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes" xml:space="preserve">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">매핑 된 유형 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; 는 모든 &lt;code&gt;K&lt;/code&gt; 를 &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes" xml:space="preserve">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="translated">객체를 해당 프리미티브 값으로 변환하는 메서드입니다. &lt;code&gt;ToPrimitive&lt;/code&gt; 추상 연산에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes" xml:space="preserve">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="translated">생성자 객체가 객체를 생성자의 인스턴스 중 하나로 인식하는지 여부를 결정하는 메서드입니다. instanceof 연산자의 시맨틱에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes" xml:space="preserve">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="translated">객체의 기본 반복자를 반환하는 메서드입니다. 진술 문의 의미론에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes" xml:space="preserve">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="translated">아니오 개질제 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 프리픽스가 갖는 개질제와 동일 &lt;code&gt;+&lt;/code&gt; 의 접두사. 따라서 위 의 &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; 유형은</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes" xml:space="preserve">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 에 대한 상대 위치를 기반으로 각 모듈에 대해 모듈 이름이 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fc81a9321caa5212d8c955b9d7611a22e0e64b3" translate="yes" xml:space="preserve">
          <source>A module using CommonJS patterns uses &lt;code&gt;module.exports&lt;/code&gt; to describe the exported values. For example, here is a module which exports a function and a numerical constant:</source>
          <target state="translated">CommonJS 패턴을 사용하는 모듈은 &lt;code&gt;module.exports&lt;/code&gt; 를 사용 하여 내 보낸 값을 설명합니다. 예를 들어 다음은 함수와 숫자 상수를 내보내는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes" xml:space="preserve">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="translated">고급 예제에서는 prototype 속성을 사용하여 생성자 함수와 클래스 유형의 인스턴스 측 간의 관계를 유추하고 제한합니다.</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes" xml:space="preserve">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">이 기능이 포착하는 더 일반적인 오류는 &lt;code&gt;return&lt;/code&gt; 문 뒤에 줄 바꿈을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="translated">네임 스페이스 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;namespace&lt;/code&gt; 선언에 유형 &lt;code&gt;Y&lt;/code&gt; 가 포함 되므로 )</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">네임 스페이스 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes" xml:space="preserve">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="translated">네임 스페이스 가져 오기 (즉 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; )가 호출 할 수없는 것으로 올바르게 플래그 지정되었습니다. 호출하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="translated">새로운 &lt;code&gt;!&lt;/code&gt; post-fix expression operator는 타입 체커가 그 사실을 결론 지을 수없는 상황에서 피연산자가 널이 아니며 정의되지 않은 것을 주장하는데 사용될 수있다. 구체적으로, 연산 &lt;code&gt;x!&lt;/code&gt; 의 형식의 값 생성 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 배제한다. 형태의 유사한 유형 주장하는 &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; 및 &lt;code&gt;x as T&lt;/code&gt; 상기 &lt;code&gt;!&lt;/code&gt; 널이 아닌 어설 션 연산자는 생성 된 JavaScript 코드에서 간단히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes" xml:space="preserve">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="translated">TypeScript 2.0에 새로운 플래그가 추가되어 명시적인 타입 주석없이 함수 &lt;code&gt;this&lt;/code&gt; 플래그의 모든 사용을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="74e05c5f83ee7f74c16bbdd86c8307c4e68ce786" translate="yes" xml:space="preserve">
          <source>A new suite of errors which tackle a new problem domain.</source>
          <target state="translated">새로운 문제 영역을 다루는 새로운 오류 모음.</target>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes" xml:space="preserve">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 의 새로운 구문</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript의 &lt;code&gt;master&lt;/code&gt; &lt;/a&gt; 브랜치 에서 야간 빌드는 자정 PST에 의해 NPM 및 NuGet에 게시됩니다. 다음은 도구를 사용하여 도구를 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="26136197b0e619c7a477a0ede27ddf26c086e432" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript의 &lt;code&gt;master&lt;/code&gt; &lt;/a&gt; 브랜치 에서 야간 빌드는 PST 자정부터 npm까지 게시됩니다. 다음은이를 구하여 도구와 함께 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes" xml:space="preserve">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="translated">상대가 아닌 가져 오기는 &lt;code&gt;baseUrl&lt;/code&gt; 과 관련하여 또는 경로 매핑을 통해 해결할 수 있습니다 . 또한 &lt;a href=&quot;modules#ambient-modules&quot;&gt;주변 모듈 선언으로&lt;/a&gt; 해결할 수 있습니다 . 외부 종속성을 가져올 때 상대 경로가 아닌 경로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes" xml:space="preserve">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">에 비 상대 수입 &lt;code&gt;moduleB&lt;/code&gt; 같은 &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; 소스 파일에서, &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 는 , 위치의 다음 위치 시도 될 것 &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes" xml:space="preserve">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="translated">'let'에 대한 메모</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes" xml:space="preserve">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes" xml:space="preserve">
          <source>A partial version of it would be:</source>
          <target state="translated">그것의 부분 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43fa7e787c62527d93ae270a4c2aa47ce163ffcd" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism, a lot of people know it as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent API&lt;/a&gt; pattern. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">다형성 &lt;code&gt;this&lt;/code&gt; 유형은 포함하는 클래스 또는 인터페이스 의 &lt;em&gt;하위 유형&lt;/em&gt; 인 유형을 나타냅니다 . 이를 &lt;em&gt;F-&lt;/em&gt; bounded polymorphism 이라고 하며 많은 사람들이이를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;유창한 API&lt;/a&gt; 패턴 으로 알고 있습니다 . 예를 들어 계층 적 유창한 인터페이스를 훨씬 쉽게 표현할 수 있습니다. 각 작업 후에 &lt;code&gt;this&lt;/code&gt; 반환하는 간단한 계산기를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형 의 다형성 은 포함하는 클래스 또는 인터페이스 의 &lt;em&gt;하위 유형&lt;/em&gt; 인 유형을 나타냅니다 . 이것을 &lt;em&gt;F&lt;/em&gt; 경계 다형성 이라고 합니다. 예를 들어, 계층 적으로 유창한 인터페이스를 표현하기가 훨씬 쉽습니다. 각 작업 후에 &lt;code&gt;this&lt;/code&gt; 반환하는 간단한 계산기를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed3773d514d4c4811918e29ff471fbec8ab9085" translate="yes" xml:space="preserve">
          <source>A popular use-case for union types is to describe the set of &lt;code&gt;string&lt;/code&gt;s or &lt;code&gt;number&lt;/code&gt;s &lt;a href=&quot;literal-types&quot;&gt;literal&lt;/a&gt; that a value is allowed to be:</source>
          <target state="translated">노동 조합 유형에 대한 인기 사용의 경우는 세트 설명하는 것입니다 &lt;code&gt;string&lt;/code&gt; s 또는 &lt;code&gt;number&lt;/code&gt; 의 &lt;a href=&quot;literal-types&quot;&gt;문자&lt;/a&gt; 값이 될 수 있는지를 :</target>
        </trans-unit>
        <trans-unit id="365b081b2090ee2d0d1ba0c0f61def91ecb0e717" translate="yes" xml:space="preserve">
          <source>A project is compiled in one of the following ways:</source>
          <target state="translated">프로젝트는 다음 방법 중 하나로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes" xml:space="preserve">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="translated">프로젝트 소스 레이아웃이 출력 레이아웃과 일치하지 않는 경우가 있습니다. 일반적으로 일련의 빌드 단계는 최종 출력을 생성합니다. 여기에는 &lt;code&gt;.ts&lt;/code&gt; 파일을 &lt;code&gt;.js&lt;/code&gt; 로 컴파일 하고 다른 소스 위치에서 단일 출력 위치로 종속성을 복사 하는 작업이 포함 됩니다. 결과적으로 런타임시 모듈의 정의가 들어있는 소스 파일과 이름이 다를 수 있습니다. 또는 최종 출력의 모듈 경로가 컴파일 타임에 해당 소스 파일 경로와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes" xml:space="preserve">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="translated">객체 또는 함수가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 포함하는 유형 인 경우 속성 액세스 또는 함수 호출로 컴파일 타임 오류가 발생합니다 . 그러나 유형 가드는 널이 아닌 정의되지 않은 검사를 지원하도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes" xml:space="preserve">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 접근 자와 함께 선언되고 &lt;code&gt;set&lt;/code&gt; 접근자가 없는 속성은 읽기 전용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes" xml:space="preserve">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="translated">이제 &lt;code&gt;readonly&lt;/code&gt; 수정자를 사용하여 속성 또는 인덱스 서명을 선언 할 수 있으며 읽기 전용 으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="14c9c9574f47af69ee1d2d4201e7c958df2ed786" translate="yes" xml:space="preserve">
          <source>A reader who completes the walkthrough should be able to:</source>
          <target state="translated">연습을 완료 한 독자는 다음을 수행 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes" xml:space="preserve">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="translated">정규식을 문자열과 비교하는 정규식 메소드입니다. &lt;code&gt;String.prototype.match&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes" xml:space="preserve">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="translated">일치하는 문자열의 하위 문자열을 대체하는 정규식 메소드입니다. &lt;code&gt;String.prototype.replace&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes" xml:space="preserve">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="translated">정규식과 일치하는 문자열 내에서 인덱스를 반환하는 정규식 메서드입니다. &lt;code&gt;String.prototype.search&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes" xml:space="preserve">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="translated">정규식과 일치하는 인덱스에서 문자열을 분할하는 정규식 메서드입니다. &lt;code&gt;String.prototype.split&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes" xml:space="preserve">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="translated">상대 가져 오기는 가져 오기 파일을 기준으로 해결되며 앰비언트 모듈 선언으로 해결할 &lt;em&gt;수 없습니다&lt;/em&gt; . 런타임시 상대 위치를 유지하려면 자신의 모듈에 대해 상대 가져 오기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes" xml:space="preserve">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">가져 오기 파일을 기준으로 상대 가져 오기가 해결됩니다. 그래서 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 소스 파일에 &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 는 다음과 같은 조회가 발생할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes" xml:space="preserve">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="translated">rest 매개 변수는 배열 유형으로 제한되는 일반 유형을 가질 수 있으며 유형 유추는 이러한 일반 rest 매개 변수에 대한 튜플 유형을 유추 할 수 있습니다. 이를 통해 부분 매개 변수 목록의 고차 캡처 및 확산이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="10834bc0f63c36734ac19d004f786a265bea8f0c" translate="yes" xml:space="preserve">
          <source>A series of entries which re-map imports to lookup locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;, there is a larger coverage of &lt;code&gt;paths&lt;/code&gt; in &lt;a href=&quot;docs/handbook/module-resolution#path-mapping&quot;&gt;the handbook&lt;/a&gt;.</source>
          <target state="translated">가져 오기를 &lt;code&gt;baseUrl&lt;/code&gt; 에 상대적인 조회 위치로 다시 매핑하는 일련의 항목 &lt;a href=&quot;docs/handbook/module-resolution#path-mapping&quot;&gt;은 핸드북&lt;/a&gt; 에 더 큰 &lt;code&gt;paths&lt;/code&gt; 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes" xml:space="preserve">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="translated">따라야 할 간단한 규칙 은 라이브러리가 정의한 전역 변수로 &lt;em&gt;네임 스페이스&lt;/em&gt; 가 지정된 유형 만 선언 하는 것입니다. 예를 들어, 라이브러리가 글로벌 값 'cats'를 정의하면 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="translated">루트가없는 경우 삼중 슬래시 참조 경로는 포함 파일을 기준으로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes" xml:space="preserve">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="translated">files 속성을 지정하지 않는 tsconfig.json 파일 (따라서 모든 하위 디렉토리의 모든 * .ts 파일을 암시 적으로 참조)에는 컴파일에서 제외 할 파일 및 / 또는 디렉토리 목록을 지정하는 exclude 속성이 포함될 수 있습니다. exclude 특성은 각각 tsconfig.json 파일의 위치를 ​​기준으로 파일 또는 폴더 이름을 지정하는 문자열 배열이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes" xml:space="preserve">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="translated">튜플 형식은 요소에 접미사 &lt;code&gt;?&lt;/code&gt; 가 있으면 생략 할 수 있습니다 . 그것의 타입과 그것의 오른쪽에있는 모든 요소에도 수정자가 &lt;code&gt;?&lt;/code&gt; 수정 자.</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="translated">A 형 &lt;code&gt;C&lt;/code&gt; 에서 &lt;code&gt;X.Z&lt;/code&gt; 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 형</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="translated">A 형 &lt;code&gt;Y&lt;/code&gt; 에서 &lt;code&gt;X&lt;/code&gt; 의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="translated">A 형 &lt;code&gt;Z&lt;/code&gt; 에서 &lt;code&gt;X&lt;/code&gt; 의 네임 스페이스 (클래스의 인스턴스 모양)</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes" xml:space="preserve">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="translated">타입 별칭 선언 ( &lt;code&gt;type sn = number | string;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes" xml:space="preserve">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="translated">이러한 유형의 조합을 소요 유형 별칭 - &lt;em&gt;조합&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes" xml:space="preserve">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="translated">유형에는 초과 특성이 허용됨을 명시 적으로 나타내는 색인 서명이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7923f87ba1b11ff5aadde3784a645b7bf0213b2d" translate="yes" xml:space="preserve">
          <source>A type cannot be changed after being created</source>
          <target state="translated">생성 된 후에는 유형을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes" xml:space="preserve">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="translated">점으로 구분 된 이름에 대한 유형 보호는 점으로 구분 된 이름의 일부에 할당 된 후에도 적용되지 않습니다. 예를 들어, &lt;code&gt;x.y.z&lt;/code&gt; 대한 type guard는 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.y&lt;/code&gt; 또는 &lt;code&gt;x.y.z&lt;/code&gt; 대한 할당 후에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes" xml:space="preserve">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="translated">유형 매개 변수는 기본값이있는 경우 선택 사항으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cc781420c33da6107d9682c46a6f8b3ef934ac7b" translate="yes" xml:space="preserve">
          <source>A type-system based only on inference with JavaScript code</source>
          <target state="translated">JavaScript 코드를 사용한 추론만을 기반으로하는 유형 시스템</target>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes" xml:space="preserve">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">유형 패키지는 &lt;code&gt;index.d.ts&lt;/code&gt; 라는 파일이있는 폴더 또는 &lt;code&gt;types&lt;/code&gt; 필드 가있는 &lt;code&gt;package.json&lt;/code&gt; 이 있는 폴더입니다 .</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes" xml:space="preserve">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">공용체 유형은 여러 유형 중 하나 일 수있는 값을 설명합니다. 수직 막대 ( &lt;code&gt;|&lt;/code&gt; )를 사용하여 각 유형을 구분하므로 &lt;code&gt;number | string | boolean&lt;/code&gt; 은 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;boolean&lt;/code&gt; 일 수있는 값의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes" xml:space="preserve">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="translated">사용자는 &lt;code&gt;2 * 5 + 1&lt;/code&gt; 과 같이 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X.Z&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="translated">값 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;namespace&lt;/code&gt; 선언에 값 &lt;code&gt;Z&lt;/code&gt; 가 포함 되기 때문에 )</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Y&lt;/code&gt; (유형 &lt;code&gt;number&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Z&lt;/code&gt; (클래스의 생성자 함수)</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes" xml:space="preserve">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="translated">형식 주석없이 선언되고 초기 값 &lt;code&gt;[]&lt;/code&gt; 은 (는) 암시적인 &lt;code&gt;any[]&lt;/code&gt; 변수로 간주됩니다 . 그러나 각 후속 &lt;code&gt;x.push(value)&lt;/code&gt; , &lt;code&gt;x.unshift(value)&lt;/code&gt; 또는 &lt;code&gt;x[n] = value&lt;/code&gt; 연산 은 추가 된 요소에 따라 변수 유형을 &lt;em&gt;발전&lt;/em&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes" xml:space="preserve">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="translated">AMD / RequireJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes" xml:space="preserve">
          <source>AMD Module names</source>
          <target state="translated">AMD 모듈 이름</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes" xml:space="preserve">
          <source>AMD-dependency optional names</source>
          <target state="translated">AMD 종속 옵션 이름</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes" xml:space="preserve">
          <source>API Changes</source>
          <target state="translated">API 변경</target>
        </trans-unit>
        <trans-unit id="4a2fd182a22546b9a5411efbef21d9ce9da6d56a" translate="yes" xml:space="preserve">
          <source>APIs available in &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;WebWorker&lt;/a&gt; contexts</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;WebWorker&lt;/a&gt; 컨텍스트 에서 사용 가능한 API</target>
        </trans-unit>
        <trans-unit id="514c168cf5e4e1365917faccfdc0926188272b5f" translate="yes" xml:space="preserve">
          <source>APIs for the &lt;a href=&quot;https://wikipedia.org/wiki/Windows_Script_Host&quot;&gt;Windows Script Hosting System&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://wikipedia.org/wiki/Windows_Script_Host&quot;&gt;Windows 스크립트 호스팅 시스템&lt;/a&gt; 용 API</target>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes" xml:space="preserve">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build&lt;/code&gt; 및 &lt;code&gt;--incremental&lt;/code&gt; 을 지원하는 API</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">ASP.NET 코어</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes" xml:space="preserve">
          <source>ASP.NET Core + TypeScript</source>
          <target state="translated">ASP.NET Core + TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="translated">ASP.NET Core : TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Setup</source>
          <target state="translated">ASP.NET 코어 : 설정</target>
        </trans-unit>
        <trans-unit id="50eed69def791463bbdef9085e70b4aade82ea60" translate="yes" xml:space="preserve">
          <source>About &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">약 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2b106ce4000d8d8c80eef39d6b34b6a0ccaab29" translate="yes" xml:space="preserve">
          <source>About this Handbook</source>
          <target state="translated">이 핸드북에 대해</target>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes" xml:space="preserve">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="translated">위의 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 추론 은 반 변형 적 위치에서 시작되므로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;가장 일반적인 하위 유형&lt;/em&gt; 을 유추합니다 . 이것은 &lt;em&gt;가장 일반적인 수퍼 타입&lt;/em&gt; 을 추론하는 공변량 위치의 추론과 대조됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes" xml:space="preserve">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">위 의 색인 서명 이있는 &lt;code&gt;StringArray&lt;/code&gt; 인터페이스가 있습니다. 이 인덱스 서명은 &lt;code&gt;StringArray&lt;/code&gt; 가 &lt;code&gt;number&lt;/code&gt; 로 색인화 될 때 &lt;code&gt;string&lt;/code&gt; 을 리턴한다는 것을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes" xml:space="preserve">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;Up&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 로 초기화 되는 숫자 열거 형이 있습니다. 그 시점부터 다음 멤버가 모두 자동 증가됩니다. 즉, &lt;code&gt;Direction.Up&lt;/code&gt; 의 값은 &lt;code&gt;1&lt;/code&gt; 이고, &lt;code&gt;Down&lt;/code&gt; 의 값 은 &lt;code&gt;2&lt;/code&gt; 이고, &lt;code&gt;Left&lt;/code&gt; 의 값 은 &lt;code&gt;3&lt;/code&gt; 이고, &lt;code&gt;Right&lt;/code&gt; 의 값 은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">추상 클래스</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes" xml:space="preserve">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="translated">추상 클래스는 다른 클래스가 파생 될 수있는 기본 클래스입니다. 직접 인스턴스화 할 수 없습니다. 인터페이스와 달리 추상 클래스에는 멤버에 대한 구현 세부 정보가 포함될 수 있습니다. &lt;code&gt;abstract&lt;/code&gt; 키워드는 추상 클래스에서 추상 클래스뿐만 아니라 추상적 인 방법을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes" xml:space="preserve">
          <source>Abstract properties and accessors</source>
          <target state="translated">추상 속성 및 접근 자</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes" xml:space="preserve">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="translated">JavaScript 파일을 입력으로 허용하십시오 ( &lt;code&gt;allowJs&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes" xml:space="preserve">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="translated">알려진 인덱스 집합 외부의 요소에 액세스하면 오류가 발생하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes" xml:space="preserve">
          <source>Accessor Decorators</source>
          <target state="translated">접근 자 데코레이터</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="63486368539a5a919d2c26a960c13aeb3604f62b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;declare module &quot;[libname]&quot; { }&lt;/code&gt;</source>
          <target state="translated">추가 &lt;code&gt;declare module &quot;[libname]&quot; { }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes" xml:space="preserve">
          <source>Add TypeScript</source>
          <target state="translated">TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes" xml:space="preserve">
          <source>Add TypeScript code</source>
          <target state="translated">TypeScript 코드 추가</target>
        </trans-unit>
        <trans-unit id="46b617acf1ae2b67fe01caa83a0ba7b8ee5a4ac7" translate="yes" xml:space="preserve">
          <source>Add TypeScript to your dev dependencies</source>
          <target state="translated">개발 종속성에 TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="a3415f2a3b0ab2d336eb4c1382554b771158a6ea" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;tsconfig.json&lt;/code&gt; to configure TypeScript</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 을 추가하여 TypeScript 구성</target>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes" xml:space="preserve">
          <source>Add a TypeScript configuration file</source>
          <target state="translated">TypeScript 구성 파일 추가</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes" xml:space="preserve">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="translated">약한 유형 (예 : &lt;code&gt;[propName: string]: {}&lt;/code&gt; )에 색인 서명을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes" xml:space="preserve">
          <source>Add example code</source>
          <target state="translated">예제 코드 추가</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes" xml:space="preserve">
          <source>Add modules to the code</source>
          <target state="translated">코드에 모듈 추가</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes" xml:space="preserve">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;app.ts&lt;/code&gt; 파일에 다음 코드를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="63b990890227ea0e4c75e4a3fe72a5643f059cf0" translate="yes" xml:space="preserve">
          <source>Add the template inside the braces of the declare module, and see where your usage breaks</source>
          <target state="translated">선언 모듈의 중괄호 안에 템플릿을 추가하고 사용량이 중단되는 위치를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3e6d6723ea89a80d4cba5523c3c76499f133755b" translate="yes" xml:space="preserve">
          <source>Adding TypeScript</source>
          <target state="translated">TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">디렉토리에 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 추가 하면 디렉토리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일 및 컴파일러 옵션을 지정합니다. 프로젝트는 다음 방법 중 하나로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="8c611c8266b493d4250ab1994cb67dac5e5d7db4" translate="yes" xml:space="preserve">
          <source>Adding new fields to an existing interface</source>
          <target state="translated">기존 인터페이스에 새 필드 추가</target>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes" xml:space="preserve">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 사용하여 추가</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes" xml:space="preserve">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 사용하여 추가</target>
        </trans-unit>
        <trans-unit id="9cd37b199ac0e5e434243b868db9e5bf59fc0b12" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2015 (also known as ES6) - &lt;code&gt;array.find&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Reflect&lt;/code&gt;, etc.</source>
          <target state="translated">ES2015 (ES6라고도 함)에서 사용할 수있는 추가 API- &lt;code&gt;array.find&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Proxy&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Reflect&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="aee0d1e5c7cb32ad383fffbe67322822cc7ffc56" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2016 - &lt;code&gt;array.include&lt;/code&gt;, etc.</source>
          <target state="translated">ES2016에서 사용 가능한 추가 API- &lt;code&gt;array.include&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="e9e994571e74a140e2c02e5a1c020db032be8f18" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2017 - &lt;code&gt;Object.entries&lt;/code&gt;, &lt;code&gt;Object.values&lt;/code&gt;, &lt;code&gt;Atomics&lt;/code&gt;, &lt;code&gt;SharedArrayBuffer&lt;/code&gt;, &lt;code&gt;date.formatToParts&lt;/code&gt;, typed arrays, etc.</source>
          <target state="translated">ES2017에서 사용 가능한 추가 API- &lt;code&gt;Object.entries&lt;/code&gt; , &lt;code&gt;Object.values&lt;/code&gt; , &lt;code&gt;Atomics&lt;/code&gt; , &lt;code&gt;SharedArrayBuffer&lt;/code&gt; , &lt;code&gt;date.formatToParts&lt;/code&gt; , 형식화 된 배열 등</target>
        </trans-unit>
        <trans-unit id="2cbb8fc3866150fbae3eb7909abccd9056ff25fb" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2018 - &lt;code&gt;async&lt;/code&gt; iterables, &lt;code&gt;promise.finally&lt;/code&gt;, &lt;code&gt;Intl.PluralRules&lt;/code&gt;, &lt;code&gt;rexexp.groups&lt;/code&gt;, etc.</source>
          <target state="translated">ES2018에서 사용할 수있는 추가 API - &lt;code&gt;async&lt;/code&gt; 반복 가능 객체, &lt;code&gt;promise.finally&lt;/code&gt; , &lt;code&gt;Intl.PluralRules&lt;/code&gt; , &lt;code&gt;rexexp.groups&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="95c596730da78330f273d9f27482a3622097fc44" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2019 - &lt;code&gt;array.flat&lt;/code&gt;, &lt;code&gt;array.flatMap&lt;/code&gt;, &lt;code&gt;Object.fromEntries&lt;/code&gt;, &lt;code&gt;string.trimStart&lt;/code&gt;, &lt;code&gt;string.trimEnd&lt;/code&gt;, etc.</source>
          <target state="translated">ES2019에서 사용 가능한 추가 API- &lt;code&gt;array.flat&lt;/code&gt; , &lt;code&gt;array.flatMap&lt;/code&gt; , &lt;code&gt;Object.fromEntries&lt;/code&gt; , &lt;code&gt;string.trimStart&lt;/code&gt; , &lt;code&gt;string.trimEnd&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="f239d6c54edfc279434f6bfed958b9f60c0681c3" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ES2020 - &lt;code&gt;string.matchAll&lt;/code&gt;, etc.</source>
          <target state="translated">ES2020에서 사용 가능한 추가 API- &lt;code&gt;string.matchAll&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="ad5945ef8d12f1d6daf29632bc72ac7f3e5760f6" translate="yes" xml:space="preserve">
          <source>Additional APIs available in ESNext - This changes as the JavaScript specification evolves</source>
          <target state="translated">ESNext에서 사용 가능한 추가 API-JavaScript 사양이 발전함에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes" xml:space="preserve">
          <source>Additional module resolution flags</source>
          <target state="translated">추가 모듈 확인 플래그</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="translated">또한 이 새로운 기능의 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;또 다른 단점&lt;/a&gt; 은 특정 제한으로 인해 &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 가 오버로드가있는 일반 함수 나 함수를 아직 완전히 모델링 할 수 없다는 것입니다. 일반 함수에서 이러한 메소드를 사용하는 경우 유형 매개 변수는 빈 오브젝트 유형 ( &lt;code&gt;{}&lt;/code&gt; ) 으로 대체 되며 과부하가있는 함수에 사용될 경우 마지막 과부하 만 모델링됩니다.</target>
        </trans-unit>
        <trans-unit id="15ac4ccfaca700b5bb61ababb10985733b43516f" translate="yes" xml:space="preserve">
          <source>Additionally, certain constructs from C# and Java such as singletons and static classes are unnecessary in TypeScript.</source>
          <target state="translated">또한 싱글 톤 및 정적 클래스와 같은 C # 및 Java의 특정 구문은 TypeScript에서 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes" xml:space="preserve">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">또한 발전기는 &lt;code&gt;yield&lt;/code&gt; 유형 이 항상 &lt;code&gt;any&lt;/code&gt; 라고 가정했습니다 .</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="translated">또한 &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; 인터페이스를 사용하면 JSX 프레임 워크에서 사용하는 추가 속성 (예 : React의 &lt;code&gt;key&lt;/code&gt; 와 같이 구성 요소의 소품 또는 인수에 의해 일반적으로 사용되지 않는)을 지정할 수 있습니다 . 더 나아가서, 일반 &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; 타입은 클래스 컴포넌트 (함수 컴포넌트가 아닌)에 대해서만 동일한 종류의 추가 속성을 지정하는 데 사용될 수 있습니다. 이 유형에서 일반 매개 변수는 클래스 인스턴스 유형에 해당합니다. React에서 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 &lt;code&gt;ref&lt;/code&gt; 속성 을 허용하는 데 사용됩니다.. 일반적으로 JSX 프레임 워크 사용자가 모든 태그에 일부 속성을 제공해야하는 경우가 아니라면 이러한 인터페이스의 모든 특성은 선택 사항이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes" xml:space="preserve">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="translated">또한 기존 빌드 워크 플로우와의 호환성을 유지하기 위해 &lt;code&gt;tsc&lt;/code&gt; 는 &lt;code&gt;--build&lt;/code&gt; 스위치를 사용 하지 않으면 자동으로 종속성을 빌드 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;--build&lt;/code&gt; 에 대해 더 배워 봅시다 .</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes" xml:space="preserve">
          <source>Adjustments in module resolution logic</source>
          <target state="translated">모듈 확인 로직 조정</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes" xml:space="preserve">
          <source>Advanced Combinations</source>
          <target state="translated">고급 조합</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes" xml:space="preserve">
          <source>Advanced Techniques</source>
          <target state="translated">고급 기술</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">고급 유형</target>
        </trans-unit>
        <trans-unit id="fb80c67075198375c2e70ac850bebb21868957d3" translate="yes" xml:space="preserve">
          <source>After all, remember that all the convenience of &lt;code&gt;any&lt;/code&gt; comes at the cost of losing type safety. Type safety is one of the main motivations for using TypeScript and you should try to avoid using &lt;code&gt;any&lt;/code&gt; when not necessary.</source>
          <target state="translated">결국, 모든 편의를 기억 &lt;code&gt;any&lt;/code&gt; 유형의 안전을 잃고의 비용으로 제공됩니다. 유형 안전성은 TypeScript를 사용하는 주요 동기 중 하나이며 필요하지 않은 경우에는 사용 &lt;code&gt;any&lt;/code&gt; 않도록 노력해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bundle&lt;/code&gt; 을 호출 한 후 &lt;code&gt;source&lt;/code&gt; (비닐 소스 스트림의 별명)를 사용하여 출력 번들 이름을 &lt;code&gt;bundle.js&lt;/code&gt; 로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="408851febc5890c19a84d2e33af34c246f1e0287" translate="yes" xml:space="preserve">
          <source>After capturing the &lt;code&gt;div&lt;/code&gt; element, the &lt;code&gt;children&lt;/code&gt; prop will return a &lt;code&gt;HTMLCollection&lt;/code&gt; list containing the &lt;code&gt;HTMLParagraphElements&lt;/code&gt;. The &lt;code&gt;childNodes&lt;/code&gt; property will return a similar &lt;code&gt;NodeList&lt;/code&gt; list of nodes. Each &lt;code&gt;p&lt;/code&gt; tag will still be of type &lt;code&gt;HTMLParagraphElements&lt;/code&gt;, but the &lt;code&gt;NodeList&lt;/code&gt; can contain additional &lt;em&gt;HTML nodes&lt;/em&gt; that the &lt;code&gt;HTMLCollection&lt;/code&gt; list cannot.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 요소를 캡처 한 후 &lt;code&gt;children&lt;/code&gt; 소품은 &lt;code&gt;HTMLParagraphElements&lt;/code&gt; 를 포함 하는 &lt;code&gt;HTMLCollection&lt;/code&gt; 목록을 반환합니다 . &lt;code&gt;childNodes&lt;/code&gt; 에의 속성은 비슷한 반환 &lt;code&gt;NodeList&lt;/code&gt; 노드의 목록을. 각 &lt;code&gt;p&lt;/code&gt; 태그는 여전히 &lt;code&gt;HTMLParagraphElements&lt;/code&gt; 유형 이지만 &lt;code&gt;NodeList&lt;/code&gt; 는 &lt;code&gt;HTMLCollection&lt;/code&gt; 목록이 할 수없는 추가 &lt;em&gt;HTML 노드&lt;/em&gt; 를 포함 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9a74c2ec05571930c83fcba6df212a860c81677b" translate="yes" xml:space="preserve">
          <source>After compiling and running the &lt;em&gt;index.html&lt;/em&gt; page, the resulting HTML will be:</source>
          <target state="translated">&lt;em&gt;index.html&lt;/em&gt; 페이지를 컴파일하고 실행 한 후 결과 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="translated">그런 다음 문제없이 lodash를 가져 와서 정확하게 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes" xml:space="preserve">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="translated">솔루션 탐색기에 &lt;code&gt;npm&lt;/code&gt; 폴더 가 표시되면</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes" xml:space="preserve">
          <source>Again, being explicit, the following things create values:</source>
          <target state="translated">다시 말하지만 다음과 같은 것은 가치를 창출합니다.</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes" xml:space="preserve">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="translated">다시, 위의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57d29b61eba4579f79786a30e1c6e7ebb0cec52d" translate="yes" xml:space="preserve">
          <source>Again, this isn&amp;rsquo;t an error because the &lt;em&gt;structures&lt;/em&gt; of these classes are the same. While this may seem like a potential source of confusion, in practice, identical classes that shouldn&amp;rsquo;t be related are not common.</source>
          <target state="translated">다시 말하지만, 이러한 클래스 의 &lt;em&gt;구조&lt;/em&gt; 가 동일 하기 때문에 이것은 오류가 아닙니다 . 이것이 혼란의 잠재적 인 원인처럼 보일 수 있지만 실제로는 관련이 없어야하는 동일한 클래스는 일반적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccfe030bc3f42b42dc5c919d01197fcd0004b2c5" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;mdash; they&amp;rsquo;re independent.</source>
          <target state="translated">여기서도 &lt;code&gt;Bar&lt;/code&gt; 를 유형과 값으로 사용했습니다. &lt;code&gt;Bar&lt;/code&gt; 값을 &lt;code&gt;Bar&lt;/code&gt; 유형 으로 선언 할 필요가 없었습니다 . 이들은 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="translated">여기서도 &lt;code&gt;Bar&lt;/code&gt; 를 유형과 값으로 모두 사용 했습니다. &lt;code&gt;Bar&lt;/code&gt; 값을 &lt;code&gt;Bar&lt;/code&gt; 유형 으로 선언 할 필요는 없습니다 . 독립형입니다.</target>
        </trans-unit>
        <trans-unit id="f0dcad08135c25e6858c7a0bc8fc97fa602084c7" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2015&amp;rdquo;</source>
          <target state="translated">&quot;ES2015&quot;의 별칭</target>
        </trans-unit>
        <trans-unit id="d1bc045865e0b8f9a9b71594259251243e592051" translate="yes" xml:space="preserve">
          <source>Alias for &amp;ldquo;ES2016&amp;rdquo;</source>
          <target state="translated">&quot;ES2016&quot;의 별칭</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes" xml:space="preserve">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="translated">앨리어싱은 실제로 새 유형을 만들지 않습니다 . 해당 유형을 참조하기 위해 새 &lt;em&gt;이름&lt;/em&gt; 을 만듭니다 . 프리미티브 앨리어싱은 문서 형태로 사용될 수 있지만별로 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes" xml:space="preserve">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="translated">모든 종속성은 npm에 의해 관리됩니다. 의존하는 모든 선언 패키지가 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 섹션에 적절하게 표시되어 있는지 확인하십시오 . 예를 들어 Browserify 및 TypeScript를 사용하는 패키지를 작성했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="translated">모든 구현 파일은 &lt;code&gt;include&lt;/code&gt; 와 일치해야합니다. 패턴 하거나 &lt;code&gt;files&lt;/code&gt; 배열에 나열되어야합니다 . 이 제한 조건을 위반하면, &lt;code&gt;tsc&lt;/code&gt; 는 지정되지 않은 파일을 알려줍니다</target>
        </trans-unit>
        <trans-unit id="4e5c880db21c996cec3fc4988c560583fa9982e1" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified.</source>
          <target state="translated">모든 구현 파일은 &lt;code&gt;include&lt;/code&gt; 패턴 으로 일치 하거나 &lt;code&gt;files&lt;/code&gt; 배열에 나열되어야합니다 . 이 제약 조건을 위반하면 &lt;code&gt;tsc&lt;/code&gt; 는 지정되지 않은 파일을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">속기 모듈에서 가져온 &lt;code&gt;any&lt;/code&gt; 유형 은 모든 유형 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="translated">속기 모듈에서 가져온 모든 유형은 모든 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes" xml:space="preserve">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="translated">&lt;code&gt;myLibrary&lt;/code&gt; 아래의 모든 모듈에 대한 모든 가져 오기 는 유형이있는 것으로 간주됩니다 &lt;code&gt;any&lt;/code&gt; 컴파일러에 의해을; 따라서 이러한 모듈의 모양이나 유형에 대한 점검을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="711241f4a2d9733149f5b0fa0a9c433a6be2957f" translate="yes" xml:space="preserve">
          <source>All of the above types have a field named &lt;code&gt;state&lt;/code&gt;, and then they also have their own fields:</source>
          <target state="translated">위의 모든 유형에는 &lt;code&gt;state&lt;/code&gt; 라는 필드 가 있으며 자체 필드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes" xml:space="preserve">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="translated">다음은 모두 모듈 구조화를위한 위험 신호입니다. 다음 중 하나라도 파일에 적용되는 경우 외부 모듈의 네임 스페이스를 만들려고하지 않는지 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes" xml:space="preserve">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">구성 파일에서 찾은 모든 상대 경로는 원래 구성 파일과 관련하여 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes" xml:space="preserve">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="translated">모든 엄격 플래그 ( &lt;code&gt;strict&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes" xml:space="preserve">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="fc58b8ed05bcec6a23ae0f9b780d0d812c7a4f62" translate="yes" xml:space="preserve">
          <source>Allow JS - &lt;code&gt;allowJs&lt;/code&gt;</source>
          <target state="translated">JS 허용 &lt;code&gt;allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="translated">JavaScript 파일을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4127f7dca17f65d3e9f2da7cd048b313c157835a" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be imported inside your project, instead of just &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files. For example, this JS file:</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일 대신 자바 스크립트 파일을 프로젝트 내에서 가져올 수 있습니다. 예를 들어,이 JS 파일 :</target>
        </trans-unit>
        <trans-unit id="4d5f4564c78948840747ee82f21c0e6f8232869a" translate="yes" xml:space="preserve">
          <source>Allow Synthetic Default Imports - &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;</source>
          <target state="translated">합성 기본 가져 오기 허용 &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03080da287c39d6533842b0d5b99bb15bf6a11b4" translate="yes" xml:space="preserve">
          <source>Allow Umd Global Access - &lt;code&gt;allowUmdGlobalAccess&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;allowUmdGlobalAccess&lt;/code&gt; 전역 액세스 허용 -allowUmdGlobalAccess</target>
        </trans-unit>
        <trans-unit id="4f45a74002920f6a947fa3ad7930927614185e1d" translate="yes" xml:space="preserve">
          <source>Allow Unreachable Code - &lt;code&gt;allowUnreachableCode&lt;/code&gt;</source>
          <target state="translated">연결할 수없는 코드 허용 &lt;code&gt;allowUnreachableCode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c098cda1fb5e0449f54b4fa69bd2ca68f4c38505" translate="yes" xml:space="preserve">
          <source>Allow Unused Labels - &lt;code&gt;allowUnusedLabels&lt;/code&gt;</source>
          <target state="translated">사용하지 않는 레이블 허용 &lt;code&gt;allowUnusedLabels&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes" xml:space="preserve">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="translated">모듈에서 UMD 글로벌에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes" xml:space="preserve">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="translated">루프에서 캡처 된 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 허용</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes" xml:space="preserve">
          <source>Allow comments in tsconfig.json</source>
          <target state="translated">tsconfig.json에서 주석 허용</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes" xml:space="preserve">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="translated">기본 내보내기가없는 모듈에서 기본 가져 오기를 허용합니다. 이것은 코드 방출에 영향을 미치지 않으며 형식 검사에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes" xml:space="preserve">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="translated">선언에서 중복 식별자 허용</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes" xml:space="preserve">
          <source>Allowed Values</source>
          <target state="translated">허용되는 값</target>
        </trans-unit>
        <trans-unit id="51d3649666c81adc66e5aee277f0deb4bbad2747" translate="yes" xml:space="preserve">
          <source>Allowed:</source>
          <target state="translated">Allowed:</target>
        </trans-unit>
        <trans-unit id="e0a0783e9856d0e09d989d44bcf6f4ac7421085b" translate="yes" xml:space="preserve">
          <source>Allows importing modules with a &amp;lsquo;.json&amp;rsquo; extension, which is a common practice in node projects. This includes generating a type for the &lt;code&gt;import&lt;/code&gt; based on the static JSON shape.</source>
          <target state="translated">노드 프로젝트에서 일반적으로 사용되는 '.json'확장자를 사용하여 모듈을 가져올 수 있습니다. 여기에는 정적 JSON 모양을 기반으로 &lt;code&gt;import&lt;/code&gt; 유형 생성이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cc170000d6a67459bf8aeff3519c663382fe747" translate="yes" xml:space="preserve">
          <source>Almost all features of an &lt;code&gt;interface&lt;/code&gt; are available in &lt;code&gt;type&lt;/code&gt;, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 의 거의 모든 기능은 &lt;code&gt;type&lt;/code&gt; 에서 사용할 수 있습니다 . 주요 차이점은 항상 확장 가능한 인터페이스와 비교하여 새 속성을 추가하기 위해 유형을 다시 열 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b7d1a9e4958d2fb8851168702553d5b6855aea3" translate="yes" xml:space="preserve">
          <source>Almost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">거의 모든 최신 Node.js 라이브러리는 모듈 제품군에 속합니다. 이러한 유형의 라이브러리는 모듈 로더가있는 JS 환경에서만 작동합니다. 예를 들어, &lt;code&gt;express&lt;/code&gt; 는 Node.js에서만 작동하며 CommonJS &lt;code&gt;require&lt;/code&gt; 함수를 사용하여로드 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes" xml:space="preserve">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="translated">설정과 함께 &lt;code&gt;--strict&lt;/code&gt; , 기본적으로에 &lt;code&gt;tsc --init&lt;/code&gt; 향상된 출력을 가지고있다. &lt;code&gt;tsc --init&lt;/code&gt; 에 의해 생성 된 기본 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에는 이제 설명과 함께 일반적인 컴파일러 옵션 세트가 포함됩니다. 원하는 동작을 얻기 위해 설정하려는 구성의 주석을 해제하십시오. 우리는 새로운 출력이 새로운 프로젝트 설정을 단순화하고 프로젝트가 증가함에 따라 구성 파일을 읽을 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes" xml:space="preserve">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="translated">전통적인 OO 계층과 함께 재사용 가능한 구성 요소로 클래스를 구성하는 또 다른 일반적인 방법은 간단한 부분 클래스를 결합하여 클래스를 작성하는 것입니다. 스칼라와 같은 언어에 대한 믹스 인 또는 특성에 대한 개념에 익숙 할 수 있으며 패턴은 JavaScript 커뮤니티에서도 어느 정도 인기를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes" xml:space="preserve">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="translated">또한 자신의 몸 안에서만 호출되는 함수는 사용되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes" xml:space="preserve">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="translated">또한 &lt;code&gt;bigint&lt;/code&gt; 는 &lt;code&gt;typeof&lt;/code&gt; 연산자를 사용할 때 문자열 &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; 와 같은 새 문자열을 생성 한다는 점에 유의해야 합니다. 따라서 TypeScript는 예상대로 &lt;code&gt;typeof&lt;/code&gt; 를 사용하여 올바르게 좁 힙니다 .</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes" xml:space="preserve">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="translated">또한 기본 선언 파일의 이름이 &lt;code&gt;index.d.ts&lt;/code&gt; 이고 패키지의 루트 ( &lt;code&gt;index.js&lt;/code&gt; 옆 )에있는 경우 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 속성 을 표시 할 필요 는 없지만 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes" xml:space="preserve">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--skipDefaultLibCheck&lt;/code&gt; 를 전달할 때 컴파일러는 &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt; 파일 검사 만 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes" xml:space="preserve">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="translated">또한 생성자에 대한 인수 에 &lt;code&gt;public&lt;/code&gt; 을 사용 하면 해당 이름으로 속성을 자동으로 만들 수있는 속기입니다.</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes" xml:space="preserve">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;사용자 정의 언어 서비스 파일 사용&lt;/a&gt; 에 대한 위키 페이지도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes" xml:space="preserve">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;야간 npm 패키지&lt;/a&gt; 와 일치하는 야간 NuGet 패키지 는 &lt;a href=&quot;https://myget.org&quot;&gt;myget에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2ac39874f5d402cff8a6371fac18a2bf87ae7f" translate="yes" xml:space="preserve">
          <source>Also, unlike Haskell, common properties show up in any union, so you can usefully discriminate multiple members of the union:</source>
          <target state="translated">또한 Haskell과 달리 공용 속성은 모든 공용체에 표시되므로 공용체의 여러 구성원을 유용하게 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc570dc40e9dd67a1355d20ed4669b96242c78db" translate="yes" xml:space="preserve">
          <source>Alternative Pattern</source>
          <target state="translated">대체 패턴</target>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="translated">또는 파일 별 컴파일 (기본값)을 사용하여 각 입력 파일에 대해 하나의 JavaScript 파일을 생성 할 수 있습니다. 여러 개의 JS 파일이 생성되면 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 를 사용해야합니다. 웹 페이지에서 태그 하여 방출 된 각 파일을 적절한 순서로로드해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="translated">양자 택일로, 당신은 말할 단지 수 있습니다 &lt;code&gt;options&lt;/code&gt; 유형이 &lt;code&gt;any&lt;/code&gt; 할 수있는 쉬운 일이지만, 당신에게 가장 도움이되는.</target>
        </trans-unit>
        <trans-unit id="14390732b26f6b4f21409bfe475cf716ae549d14" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use a per-file pragma to set this option, for example:</source>
          <target state="translated">또는 파일 별 pragma를 사용하여이 옵션을 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes" xml:space="preserve">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes" xml:space="preserve">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="translated">JavaScript 모듈은 병합을 지원하지 않지만 기존 객체를 가져오고 업데이트하여 패치 할 수 있습니다. 장난감 Observable 예제를 보자 :</target>
        </trans-unit>
        <trans-unit id="e5310a8c4e94d0ca71a8f44c68a436f3effe3b6a" translate="yes" xml:space="preserve">
          <source>Always Strict - &lt;code&gt;alwaysStrict&lt;/code&gt;</source>
          <target state="translated">항상 엄격한 - &lt;code&gt;alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes" xml:space="preserve">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="translated">주변 클래스 및 함수가 병합 될 수 있음</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes" xml:space="preserve">
          <source>Ambient Modules</source>
          <target state="translated">주변 모듈</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes" xml:space="preserve">
          <source>Ambient Namespaces</source>
          <target state="translated">주변 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes" xml:space="preserve">
          <source>Ambient enums</source>
          <target state="translated">주변 열거 형</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes" xml:space="preserve">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="translated">앰비언트 열거 형은 기존의 열거 형 유형의 모양을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b111c707b73d7237aae28fc1288868f165c43e0a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;FString&lt;/code&gt; is just like a normal string, except that the compiler thinks it has a property named &lt;code&gt;__compileTimeOnly&lt;/code&gt; that doesn&amp;rsquo;t actually exist. This means that &lt;code&gt;FString&lt;/code&gt; can still be assigned to &lt;code&gt;string&lt;/code&gt;, but not the other way round.</source>
          <target state="translated">&lt;code&gt;FString&lt;/code&gt; 는 컴파일러가라는 특성이 생각하는 것을 제외하고는 일반 문자열처럼 &lt;code&gt;__compileTimeOnly&lt;/code&gt; 실제로 존재하지 않습니다. 즉, &lt;code&gt;FString&lt;/code&gt; 은 여전히 &lt;code&gt;string&lt;/code&gt; 에 할당 될 수 있지만 그 반대는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="translated">유형을 참조 하는 &lt;code&gt;import&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="translated">값을 참조 하는 &lt;code&gt;import&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">접근 자 &lt;em&gt;데코레이터&lt;/em&gt; 는 접근 자 선언 직전에 선언됩니다. 접근 자 데코레이터는 접근 자의 &lt;em&gt;속성 설명자&lt;/em&gt; 에 적용되며 접근 자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근 자 데코레이터는 선언 파일이나 다른 주변 환경 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="translated">&lt;em&gt;비동기 함수&lt;/em&gt; 접두사 된 기능이나 방법 &lt;code&gt;async&lt;/code&gt; 개질제. 이 수정자는 함수 본문 전치가 필요하며 키워드 &lt;code&gt;await&lt;/code&gt; 는 식별자 대신 단항 표현식으로 처리되어야 함을 컴파일러에 알립니다 . &lt;em&gt;비동기 함수&lt;/em&gt; 반환 유형 주석을 제공해야합니다 호환되는 포인트 그 &lt;code&gt;Promise&lt;/code&gt; 유형입니다. 반환 형식 유추는 전역 적으로 정의되고 호환 가능한 &lt;code&gt;Promise&lt;/code&gt; 형식 이있는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes" xml:space="preserve">
          <source>An Example Project</source>
          <target state="translated">예제 프로젝트</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes" xml:space="preserve">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="translated">함수, 클래스 또는 빈 객체 리터럴을 반환하는 IIFE도 네임 스페이스로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes" xml:space="preserve">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="translated">고유 한 속성 이름이 연결된 개체의 'with'환경 바인딩에서 제외 된 속성 이름 인 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes" xml:space="preserve">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="translated">추상 클래스는 추상 속성 및 / 또는 접근자를 선언 할 수 있습니다. 모든 하위 클래스는 추상 속성을 선언하거나 추상으로 표시해야합니다. 추상 속성은 이니셜 라이저를 가질 수 없습니다. 추상 접근자는 본문을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes" xml:space="preserve">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="translated">ES2015 네임 스페이스를 가져 오기를 통해 액세스 엔티티 (예 : 읽기 전용으로 간주됩니다 &lt;code&gt;foo.x&lt;/code&gt; 읽기 전용 인 경우 &lt;code&gt;foo&lt;/code&gt; 는이 같은 선언 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes" xml:space="preserve">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 문에 선언 된 엔터티는 읽기 전용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes" xml:space="preserve">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="translated">열거 형 선언 ( &lt;code&gt;enum E { A, B, C }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0f0c7003bdcd58ff3b43d23382bd37a83d58b4a2" translate="yes" xml:space="preserve">
          <source>An example use case for this flag would be a web project where you know the particular library (like jQuery or Lodash) will always be available at runtime, but you can&amp;rsquo;t access it with an import.</source>
          <target state="translated">이 플래그에 대한 예제 사용 사례는 특정 라이브러리 (예 : jQuery 또는 Lodash)가 런타임에 항상 사용 가능하다는 것을 알고 있지만 가져 오기로 액세스 할 수없는 웹 프로젝트입니다.</target>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes" xml:space="preserve">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="translated">내보내기 기본 선언은 모듈의 기본 내보내기가되는 표현식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes" xml:space="preserve">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="translated">선언 파일이없는 모듈로 가져 오기는 여전히 &lt;code&gt;--noImplicitAny&lt;/code&gt; 에서 오류로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes" xml:space="preserve">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="translated">중요한 규칙은 &lt;code&gt;export&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; 선언 이 대상의 &lt;em&gt;모든 의미&lt;/em&gt; 를 내보내거나 가져 오는 &lt;em&gt;것&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes" xml:space="preserve">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">인덱스 유형 &lt;code&gt;keyof T&lt;/code&gt; 어떤 종류의 &lt;code&gt;T&lt;/code&gt; 는 의 하위 유형입니다 &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes" xml:space="preserve">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="translated">인터페이스는 여러 인터페이스를 확장하여 모든 인터페이스의 조합을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes" xml:space="preserve">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="translated">인터페이스 선언 ( &lt;code&gt;interface I { x: number[]; }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes" xml:space="preserve">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">교차 유형은 여러 유형을 하나로 결합합니다. 이를 통해 기존 유형을 함께 추가하여 필요한 모든 기능을 갖춘 단일 유형을 얻을 수 있습니다. 예를 들어 &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; 은 &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 입니다. 즉,이 유형의 개체는 세 가지 유형의 모든 멤버를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes" xml:space="preserve">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="translated">&lt;a href=&quot;symbols#symboliterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; 속성에 대한 구현이있는 객체는 반복 가능한 것으로 간주 됩니다. &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Int32Array&lt;/code&gt; , &lt;code&gt;Uint32Array&lt;/code&gt; 등과 같은 일부 내장 유형 에는 이미 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성이 구현되어 있습니다. 객체의 &lt;code&gt;Symbol.iterator&lt;/code&gt; 함수는 반복 할 값 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes" xml:space="preserve">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="translated">객체 리터럴의 알려진 모든 속성을 해당 인덱스 서명에 할당 할 수있는 경우 객체 리터럴 유형을 인덱스 서명이있는 유형에 할당 할 수 있습니다. 이를 통해 객체 리터럴로 초기화 된 변수를 매개 변수로 맵 또는 사전이 필요한 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes" xml:space="preserve">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="translated">객체가 반복 비동기 지원은이 경우 &quot;반복 가능&quot;이라고되어 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 의 방법이 다시 표시 &lt;code&gt;AsyncIterator&lt;/code&gt; 의 개체를.</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes" xml:space="preserve">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="translated">피연산자의 유형 인 경우 피연산자는 널 간주 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 또는 포함하는 연합 형 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; . 통합 유형 대 / 소문자 는 클래식 유형 검사 모드의 공용체에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 사라지기 때문에 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드 에서만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes" xml:space="preserve">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="translated">JSDoc에서 지정되지 않은 유형 인수는 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes" xml:space="preserve">
          <source>And help in Japanese:</source>
          <target state="translated">일본어로 도와주세요 :</target>
        </trans-unit>
        <trans-unit id="dd197d67b41beb4bb9080f0bf626d0c8feceb7c4" translate="yes" xml:space="preserve">
          <source>And it does so while you are typing, so that after typing &lt;code&gt;o.&lt;/code&gt;, you get completions for the property &lt;code&gt;inference&lt;/code&gt;, along with any other properties you&amp;rsquo;d have in a real program. Altogether, this feature can make TypeScript&amp;rsquo;s inference look a bit like a unifying type inference engine, but it is not.</source>
          <target state="translated">그리고 입력하는 동안 그렇게하므로 &lt;code&gt;o.&lt;/code&gt; 를 입력 한 후에 수행됩니다 . , 실제 프로그램에서 가질 수있는 다른 속성과 함께 속성 &lt;code&gt;inference&lt;/code&gt; 대한 완료를 얻습니다 . 전체적으로이 기능은 TypeScript의 추론을 통합 유형 추론 엔진처럼 보이게 만들 수 있지만 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05d2481f5dabbff44ec8dc3190a715bb12f127f0" translate="yes" xml:space="preserve">
          <source>And it has a specific &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that removes side-affecting methods and prevents writing to indices of the array, as well as special syntax for this type:</source>
          <target state="translated">또한 &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 영향을 미치는 메서드를 제거하고 배열의 인덱스에 대한 쓰기를 방지 하는 특정 ReadonlyArray &amp;lt;T&amp;gt; 형식과이 형식에 대한 특수 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes" xml:space="preserve">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="translated">유형 술어 서명과 마찬가지로 이러한 어설 션 서명은 엄청나게 표현 적입니다. 우리는 이것으로 상당히 정교한 아이디어를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes" xml:space="preserve">
          <source>And results in</source>
          <target state="translated">그리고 결과</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes" xml:space="preserve">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">그리고 다른 하나는이다 &lt;code&gt;as&lt;/code&gt; - 구문 :</target>
        </trans-unit>
        <trans-unit id="cb4e175c07b2c59dcc273c9702501096dcd31801" translate="yes" xml:space="preserve">
          <source>And this also generates this json map:</source>
          <target state="translated">그리고 이것은 또한 다음 json 맵을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes" xml:space="preserve">
          <source>And to use it:</source>
          <target state="translated">그리고 그것을 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes" xml:space="preserve">
          <source>And usage would be:</source>
          <target state="translated">그리고 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes" xml:space="preserve">
          <source>And with parameters to a function:</source>
          <target state="translated">그리고 함수에 대한 매개 변수와 함께 :</target>
        </trans-unit>
        <trans-unit id="35f50d63beef167dd9ca426c97e6076057b81ce3" translate="yes" xml:space="preserve">
          <source>And you can use an expression of type &lt;code&gt;any&lt;/code&gt; anywhere:</source>
          <target state="translated">그리고 당신은 유형의 표현을 사용할 수 &lt;code&gt;any&lt;/code&gt; 어느 곳 :</target>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes" xml:space="preserve">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="translated">ES2015 이전 코드의 경우 정적 메소드를 시뮬레이션하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec45c0ce446cf8fa2dd6d9617073a81b5ee50c12" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">TypeScript의 또 다른 ECMAScript 2015 기능은 구조 분해입니다. 전체 참조 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;는 Mozilla 개발자 네트워크의 기사를&lt;/a&gt; 참조하십시오 . 이 섹션에서는 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">TypeScript가 가지고있는 또 다른 ECMAScript 2015 기능은 파괴입니다. 자세한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;내용은 Mozilla Developer Network 기사를&lt;/a&gt; 참조하십시오 . 이 섹션에서는 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes" xml:space="preserve">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="translated">또 다른 차이점은 &lt;code&gt;for..in&lt;/code&gt; 은 모든 객체에서 작동 한다는 것입니다 . 이 객체의 속성을 검사하는 방법으로 사용됩니다. &lt;code&gt;for..of&lt;/code&gt; 에 for..of 는 반복 가능한 객체의 값에 주로 관심이 있습니다. &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 과 같은 내장 객체는 저장된 값에 액세스 할 수있는 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes" xml:space="preserve">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="translated">또 다른 예 는 중첩 조건부 유형을 사용 하는 &lt;code&gt;TypeName&lt;/code&gt; 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="08d5a0729b5af0f7633b6230c048cf4b29055065" translate="yes" xml:space="preserve">
          <source>Another frequent source of surprise comes with identical types:</source>
          <target state="translated">놀라움의 또 다른 빈번한 소스는 동일한 유형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes" xml:space="preserve">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="translated">웹 페이지 및 서버를 위해 JavaScript로 프로그램을 작성하는 또 다른 기본 부분은 텍스트 데이터 작업입니다. 다른 언어와 마찬가지로 유형 &lt;code&gt;string&lt;/code&gt; 을 사용하여 이러한 텍스트 데이터 유형을 참조합니다. JavaScript와 마찬가지로 TypeScript는 문자열 데이터를 둘러싸 기 위해 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 또는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes" xml:space="preserve">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">또 다른 좋은 방법은 단순히 모든 리프 노드 프로젝트에 &lt;code&gt;references&lt;/code&gt; 를 갖고 &lt;code&gt;files&lt;/code&gt; 을 빈 배열로 설정 하는 &quot;솔루션&quot; &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 갖는 것입니다 (그렇지 않으면 솔루션 파일이 파일의 이중 컴파일을 유발 함). 3.0부터 시작 하여 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에 하나 이상의 &lt;code&gt;reference&lt;/code&gt; 가있는 경우 빈 &lt;code&gt;files&lt;/code&gt; 배열 을 갖는 것은 더 이상 오류가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes" xml:space="preserve">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="translated">블록 범위 변수의 또 다른 속성은 실제로 선언되기 전에 읽거나 쓸 수 없다는 것입니다. 이러한 변수는 전체 범위에 걸쳐 &quot;존재&quot;하지만 선언까지의 모든 포인트는 &lt;em&gt;일시적인 데드 존의&lt;/em&gt; 일부입니다 . 이것은 &lt;code&gt;let&lt;/code&gt; 문 전에 액세스 할 수 없다는 정교한 방법 이며 운 좋게도 TypeScript가 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes" xml:space="preserve">
          <source>Another simple way is to use class expressions:</source>
          <target state="translated">또 다른 간단한 방법은 클래스 표현식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes" xml:space="preserve">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="translated">명심해야 할 또 다른 사항은 &lt;code&gt;const&lt;/code&gt; 컨텍스트가 표현식을 완전히 변경할 수없는 것으로 즉시 변환하지는 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes" xml:space="preserve">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="translated">네임 스페이스 작업을 단순화 할 수있는 또 다른 방법은 &lt;code&gt;import q = x.y.z&lt;/code&gt; 를 사용하여 일반적으로 사용되는 객체의 짧은 이름을 만드는 것입니다. 모듈을로드하는 데 사용되는 &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; 구문 과 혼동하지 마십시오 .이 구문은 단순히 지정된 기호의 별명을 작성합니다. 모듈 가져 오기에서 작성된 오브젝트를 포함하여 모든 종류의 식별자에 대해 이러한 종류의 가져 오기 (일반적으로 별명이라고 함)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes" xml:space="preserve">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="translated">예를 설명하는 또 다른 방법 은 기본 유형 검사 모드에서 &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; 의 유형 (x : T) =&amp;gt; void 가 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;이변 량&lt;/em&gt; (즉, 공변량 &lt;em&gt;또는&lt;/em&gt; 반 변형) 이지만 엄격한 함수 유형 모드에서 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;반 변형&lt;/em&gt; 입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes" xml:space="preserve">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 키워드 를 추가하여 모든 선언 (예 : 변수, 함수, 클래스, 유형 별명 또는 인터페이스)을 내보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes" xml:space="preserve">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성을 통해 포함 된 파일이 참조하는 모든 파일 도 포함됩니다. 파일 경우 마찬가지로, &lt;code&gt;B.ts&lt;/code&gt; 이 다른 파일에 의해 참조되는 &lt;code&gt;A.ts&lt;/code&gt; , 다음 &lt;code&gt;B.ts&lt;/code&gt; 가 참조하는 파일을 제외하고 배제 할 수 없다 &lt;code&gt;A.ts&lt;/code&gt; 은 또한에 지정된 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6b984d3931194d80c596d87494a4cd0260323982" translate="yes" xml:space="preserve">
          <source>Any identifier or dotted identifier</source>
          <target state="translated">모든 식별자 또는 점으로 구분 된 식별자</target>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes" xml:space="preserve">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="translated">선택적 매개 변수는 필수 매개 변수를 따라야합니다. 이름 대신 이름을 선택 사항으로 만들려면 함수에서 매개 변수의 순서를 변경하여 이름을 성을 목록에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes" xml:space="preserve">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="translated">다른 수입품은 &lt;strong&gt;상대적이지 않은&lt;/strong&gt; 것으로 간주됩니다 . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes" xml:space="preserve">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="translated">&lt;code&gt;isFish&lt;/code&gt; 가 일부 변수와 함께 호출 될 때마다 TypeScript 는 원래 유형이 호환되는 경우 해당 변수를 특정 유형으로 &lt;em&gt;좁 힙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes" xml:space="preserve">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="translated">null 또는 undefined로 초기화 된 모든 변수, 매개 변수 또는 속성은 엄격한 null 확인이 설정되어 있어도 유형이 any입니다. 엄격한 null 검사가 설정되어 있어도 []로 초기화 된 모든 변수, 매개 변수 또는 속성은 any [] 형식입니다. 위에서 설명한대로 이니셜 라이저가 여러 개인 속성은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes" xml:space="preserve">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="translated">인사말이 필요한 곳이면 어디든 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 을 반환하는 함수 또는 &lt;code&gt;Greeter&lt;/code&gt; 인스턴스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes" xml:space="preserve">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="translated">Apache Cordova Apps에는 여전히 단일 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 의 기존 제한 사항이 있으며 이는 루트 또는 &lt;code&gt;scripts&lt;/code&gt; 폴더에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes" xml:space="preserve">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;최소 권한 원칙을&lt;/a&gt; 적용 할 때 수정하려는 선언 이외의 모든 선언은 &lt;code&gt;const&lt;/code&gt; 를 사용해야합니다 . 근거는 변수를 작성할 필요가없는 경우 동일한 코드베이스에서 작업하는 다른 사람들이 자동으로 객체에 쓸 수 없어야하며 변수에 실제로 재 할당해야하는지 여부를 고려해야한다는 것입니다. &lt;code&gt;const&lt;/code&gt; 를 사용하면 데이터 흐름을 추론 할 때 코드를보다 예측 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feeba9502a1e0f85eacb0af7f74c1820da8711e4" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">&lt;a href=&quot;https://wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;최소 권한 원칙을&lt;/a&gt; 적용하면 수정하려는 선언 이외의 모든 선언은 &lt;code&gt;const&lt;/code&gt; 를 사용해야합니다 . 근거는 변수를 쓸 필요가 없다면 동일한 코드베이스에서 작업하는 다른 사람들이 자동으로 객체에 쓸 수 없어야하며 변수에 실제로 재 할당해야하는지 여부를 고려해야한다는 것입니다. &lt;code&gt;const&lt;/code&gt; 를 사용하면 데이터 흐름을 추론 할 때 코드를 더 예측할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">배열 파괴</target>
        </trans-unit>
        <trans-unit id="e6ac01c9abf0d89c7b3cace9c5d3ec391bebfef5" translate="yes" xml:space="preserve">
          <source>Arrow functions use the contextual type to type their parameters, so the compiler gives &lt;code&gt;o: { inference: string }&lt;/code&gt;.</source>
          <target state="translated">화살표 함수는 컨텍스트 유형을 사용하여 매개 변수를 입력하므로 컴파일러는 &lt;code&gt;o: { inference: string }&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes" xml:space="preserve">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="translated">결과적으로 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 사용할 때 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 사용하도록 종속성 을 업데이트해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes" xml:space="preserve">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="translated">좋은 보너스로, 이는 중복 패키지에서 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 로드하지 않도록하여 컴파일러 및 언어 서비스의 메모리 및 런타임 풋 프린트를 줄일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes" xml:space="preserve">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="translated">참고 : 가능하면 &lt;code&gt;--strictNullChecks&lt;/code&gt; 를 사용하는 것이 좋지만이 핸드북에서는이 기능이 꺼져 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes" xml:space="preserve">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="translated">결과적으로 TypeScript 3.2 는 다음 예제 의 &lt;code&gt;error&lt;/code&gt; 속성을 판별하는 것으로 간주 하지만 &lt;code&gt;Error&lt;/code&gt; 가 싱글 톤 형식이 아니기 전에는 그렇지 않습니다 . 이로 인해 &lt;code&gt;unwrap&lt;/code&gt; 기능 본문에서 축소가 올바르게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes" xml:space="preserve">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="translated">결과적으로 사용자는 TypeScript 3.6의 주변 컨텍스트에서 게터 및 세터를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes" xml:space="preserve">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="translated">개별 가져 오기 대신 네임 스페이스 가져 오기를 사용하여 전체 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes" xml:space="preserve">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="translated">새로운 오류의 예로는 다음과 같은 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes" xml:space="preserve">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="translated">즉시 해결되는 일부 유형의 예로 다음 예를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes" xml:space="preserve">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="translated">예를 들어, 문자 '𠮷'가 포함 된 문자열을 이스케이프해야한다고 가정하십시오. UTF-16 / UCS2에서 '𠮷'은 서로 게이트 쌍으로 표시됩니다. 즉 16 비트 코드 단위 값, 특히 &lt;code&gt;0xD842&lt;/code&gt; 및 &lt;code&gt;0xDFB7&lt;/code&gt; 쌍을 사용하여 인코딩됩니다 . 이전에는 코드 포인트를 &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; 로 이스케이프해야했습니다 . 이것은 대리 쌍에서 두 개의 독립적 인 캐릭터를 식별하기가 어렵다는 주요 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes" xml:space="preserve">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="translated">예를 들어, lodash와 같은 라이브러리에 대한 선언을 얻는 것은 다음 명령 이상을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes" xml:space="preserve">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 많은 유닉스 계열 시스템에서 &lt;code&gt;/dev/stdout&lt;/code&gt; 파일로 표준 출력 스트림에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes" xml:space="preserve">
          <source>As an example, the following code snippet</source>
          <target state="translated">예를 들어, 다음 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes" xml:space="preserve">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 방출 된 JavaScript를 &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt; 와 같은 예쁜 프린터로 파이프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d4eabd9999e1e12bdc9f231452f5d0852a3e159" translate="yes" xml:space="preserve">
          <source>As another example, this is JavaScript code that you can run in your browser, and it &lt;em&gt;will&lt;/em&gt; print a value:</source>
          <target state="translated">또 다른 예로, 이것은 브라우저에서 실행할 수있는 JavaScript 코드이며 값 &lt;em&gt;을&lt;/em&gt; 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes" xml:space="preserve">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="translated">앞에서 설명한 것처럼 컴파일러는 모듈을 확인할 때 현재 폴더 외부의 파일을 방문 할 수 있습니다. 모듈이 해석되지 않은 이유 또는 잘못된 정의로 해석되는 경우 진단하기가 어려울 수 있습니다. &lt;code&gt;--traceResolution&lt;/code&gt; 을 사용하여 컴파일러 모듈 확인 추적을 활성화하면 모듈 확인 프로세스 중에 발생한 상황에 대한 통찰력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2af5d0e8e829dfb3c74ed1966383405987ec7afa" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;, while BigIntegers get the type &lt;code&gt;bigint&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">JavaScript에서와 같이 TypeScript의 모든 숫자는 부동 소수점 값 또는 BigInteger입니다. 이러한 부동 소수점 숫자는 유형 &lt;code&gt;number&lt;/code&gt; 를 가져 오는 반면 BigInteger는 유형 &lt;code&gt;bigint&lt;/code&gt; 를 가져옵니다 . 16 진 및 10 진 리터럴 외에도 TypeScript는 ECMAScript 2015에 도입 된 2 진 및 8 진 리터럴도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">JavaScript에서와 같이 TypeScript의 모든 숫자는 부동 소수점 값입니다. 이 부동 소수점 숫자는 형 얻을 &lt;code&gt;number&lt;/code&gt; . 16 진수 및 10 진수 리터럴 외에도 TypeScript는 ECMAScript 2015에 도입 된 2 진수 및 8 진수 리터럴을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes" xml:space="preserve">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="translated">매개 변수 유형이 정렬되는 한 함수 유형의 매개 변수 이름에 관계없이 함수에 유효한 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes" xml:space="preserve">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;if&lt;/code&gt; 문 조건 내에서 함수가 호출되지 않은 것으로 표시되면 TypeScript에서 오류가 발생합니다 . 기능 유형이 체크인 할 때 오류가 발행되는 &lt;code&gt;if&lt;/code&gt; 다음 중 하나가 적용되지 않는 조건 :</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="translated">&lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;enums 섹션에서&lt;/a&gt; 언급했듯이 enum 멤버는 모든 멤버가 리터럴 초기화 될 때 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes" xml:space="preserve">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="translated">애플리케이션이 성장함에 따라 코드를 여러 파일로 분할하여 유지 관리하기가 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes" xml:space="preserve">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">어설 션 서명 작업의 일환으로 TypeScript는 호출 된 함수와 위치를 더 많이 인코딩해야했습니다. 돌아 오지 기능이 우리에게 기능의 다른 클래스에 대한 지원을 확대 할 수있는 기회 준 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes" xml:space="preserve">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">ECMAScript에 지정된대로 산술 연산에서 &lt;code&gt;number&lt;/code&gt; s와 &lt;code&gt;bigint&lt;/code&gt; s를 혼합 하는 것은 오류입니다. 명시 적으로 값을 &lt;code&gt;BigInt&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes" xml:space="preserve">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="translated">따라서 TypeScript의 단일 선언에서 여러 데코레이터를 평가할 때 다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes" xml:space="preserve">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="translated">이름에서 알 수 있듯이 구성 요소는 첫 번째 인수가 &lt;code&gt;props&lt;/code&gt; 객체 인 JavaScript 함수로 정의됩니다 . TS는 반환 유형을 &lt;code&gt;JSX.Element&lt;/code&gt; 에 할당 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes" xml:space="preserve">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="translated">유효성 검사기를 더 추가 할 때 유형을 추적하고 다른 개체와의 이름 충돌에 대해 걱정할 수 없도록 일종의 구성 체계를 원할 것입니다. 전역 네임 스페이스에 많은 다른 이름을 넣는 대신 객체를 네임 스페이스로 마무리하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes" xml:space="preserve">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="translated">&lt;a href=&quot;classes&quot;&gt;클래스 섹션에서&lt;/a&gt; 다룬 것처럼 클래스에는 정적 측면과 인스턴스 측면의 두 가지 측면이 있습니다. 제네릭 클래스는 정적 쪽이 아닌 인스턴스 쪽에서 만 제네릭이므로 클래스로 작업 할 때 정적 멤버는 클래스의 type 매개 변수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes" xml:space="preserve">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="translated">우리는 운동장과 웹 사이트를 개선함에 따라 &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;GitHub에 대한 피드백과 풀 요청을 환영합니다&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="translated">앞에서 언급했듯이 인터페이스는 실제 JavaScript에 존재하는 다양한 유형을 설명 할 수 있습니다. JavaScript의 역동적이고 유연한 특성으로 인해 위에서 설명한 일부 유형의 조합으로 작동하는 객체가 종종 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes" xml:space="preserve">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="translated">앞에서 언급했듯이 BigInt 지원은 &lt;code&gt;esnext&lt;/code&gt; 대상 에서만 사용할 수 있습니다 . 분명하지는 않지만 BigInts는 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 등과 같은 수학 연산자에 대해 다른 동작을 가지 &lt;code&gt;es2017&lt;/code&gt; 및 아래와 같이 기능이 존재하지 않는 이전 대상에 기능을 제공 하면 이러한 각 작업을 다시 작성해야합니다. . TypeScript는 유형에 따라 올바른 동작으로 전달해야하므로 모든 추가, 문자열 연결, 곱하기 등에는 함수 호출이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes" xml:space="preserve">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="translated">앞에서 언급했듯이 타입 별칭은 일종의 인터페이스처럼 작동 할 수 있습니다. 그러나 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="translated">이전 섹션에서 언급했듯이 클래스 선언은 클래스 인스턴스를 나타내는 유형과 생성자 함수라는 두 가지를 만듭니다. 클래스는 유형을 작성하므로 인터페이스를 사용할 수있는 동일한 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes" xml:space="preserve">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="translated">생성기와 마찬가지로 비동기 생성기는 함수 선언, 함수 표현식 또는 클래스 또는 객체 리터럴의 메소드 만 될 수 있습니다. 화살표 함수는 비동기 생성기가 될 수 없습니다. 비동기 생성기 는 유효한 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 참조 (기본 심볼 또는 shim) 외에 유효한 글로벌 &lt;code&gt;Promise&lt;/code&gt; 구현 (네이티브 또는 ES2015 호환 폴리 필)이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes" xml:space="preserve">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="translated">배열과 마찬가지로 더 짧은 튜플을 얻기 위해 &lt;code&gt;...&lt;/code&gt; 으로 나머지 튜플의 구조를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes" xml:space="preserve">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="translated">어설 션 함수와 마찬가지로 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;동일한 풀 요청에서 더 많은 내용을 읽을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13942b127f03a86eed04c8af9e4662496adae711" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of &lt;a href=&quot;#module&quot;&gt;a UMD&lt;/a&gt; module, so be sure to check the code or documentation.</source>
          <target state="translated">전역 모듈과 마찬가지로 &lt;a href=&quot;#module&quot;&gt;UMD&lt;/a&gt; 모듈 설명서에서 이러한 예제를 볼 수 있으므로 코드 또는 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="translated">글로벌 모듈과 마찬가지로 UMD 모듈 문서에서이 예제를 볼 수 있으므로 코드 또는 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes" xml:space="preserve">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">유형과 마찬가지로 값이 무엇인지 이미 알고있을 것입니다. 값은 표현식에서 참조 할 수있는 런타임 이름입니다. 예를 들어 &lt;code&gt;let x = 5;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 라는 값을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes" xml:space="preserve">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">알다시피, 우리 는 값이 &lt;code&gt;10&lt;/code&gt; 인 &lt;code&gt;a&lt;/code&gt; 라는 변수를 선언했습니다 .</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes" xml:space="preserve">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="translated">상자에 입력하면 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes" xml:space="preserve">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB.js&lt;/code&gt; 파일이 있으면 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="translated">&lt;code&gt;index.js&lt;/code&gt; 파일이 포함되어 있으면 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 폴더를 요청하십시오 . 이 파일은 해당 폴더의 &quot;기본&quot;모듈로 암시 적으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;main&quot;&lt;/code&gt; 모듈 을 지정하는 &lt;code&gt;package.json&lt;/code&gt; 이라는 파일이 포함되어 있으면 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 폴더에 문의하십시오 . 이 예에서 Node.js 가 &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt; 포함하는 &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; 파일을 찾은 경우 Node.js 는 &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes" xml:space="preserve">
          <source>Assertion Functions</source>
          <target state="translated">어설 션 함수</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes" xml:space="preserve">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="translated">JavaScript의 어설 션은 종종 부적절한 유형이 전달되는 것을 막기 위해 사용됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes" xml:space="preserve">
          <source>Assigned-before-use checking</source>
          <target state="translated">사용 전 할당 검사</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes" xml:space="preserve">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="translated">Union 유형에 할당하는 것은 매우 직관적으로 작동합니다. Union 유형의 멤버 중 하나에 할당 할 수있는 모든 항목을 Union에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes" xml:space="preserve">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="translated">최상위 수준의 과제는 같은 방식으로 작동해야합니다. 즉, &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 선언이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes" xml:space="preserve">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;module.exports&lt;/code&gt; 할당</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes" xml:space="preserve">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; 또는 &lt;code&gt;global&lt;/code&gt; 속성에 할당</target>
        </trans-unit>
        <trans-unit id="6d5e5ece4fa70386a240680d096df0f39138ad3f" translate="yes" xml:space="preserve">
          <source>Assume Changes Only Affect Direct Dependencies - &lt;code&gt;assumeChangesOnlyAffectDirectDependencies&lt;/code&gt;</source>
          <target state="translated">변경 사항이 직접 종속성에만 영향을 &lt;code&gt;assumeChangesOnlyAffectDirectDependencies&lt;/code&gt; 가정 -assumeChangesOnlyAffectDirectDependencies</target>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes" xml:space="preserve">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="translated">이러한 각 모듈이 문자열 배열을 내보내는 것으로 가정하십시오. 예를 들어 &lt;code&gt;./zh/messages&lt;/code&gt; 에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;__dirname&lt;/code&gt; 을 항상 사용할 수 있다고 가정하면 &lt;code&gt;ImportMeta&lt;/code&gt; 인터페이스 를 다시 &lt;code&gt;import.meta&lt;/code&gt; 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes" xml:space="preserve">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="translated">&lt;code&gt;document&lt;/code&gt; 나 &lt;code&gt;window&lt;/code&gt; 와 같은 DOM 프리미티브 가 존재 한다고 가정</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes" xml:space="preserve">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="translated">예를 들어, &lt;code&gt;class&lt;/code&gt; 는 &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;값&lt;/em&gt; 목록 에 모두 나타납니다 . 선언 &lt;code&gt;class C { }&lt;/code&gt; A : 두가지 생성 &lt;em&gt;형 &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 클래스의 인스턴스의 형태를 의미하고, &lt;em&gt;값 &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 클래스의 생성자 함수를 의미한다. 열거 형 선언도 비슷하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes" xml:space="preserve">
          <source>Async Generators</source>
          <target state="translated">비동기 생성기</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes" xml:space="preserve">
          <source>Async Iteration</source>
          <target state="translated">비동기 반복</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes" xml:space="preserve">
          <source>Async iterators</source>
          <target state="translated">비동기 반복자</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes" xml:space="preserve">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="translated">핵심적으로 선택적 체인을 사용하면 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 발생하면 TypeScript가 일부 표현식 실행을 즉시 중지 할 수있는 코드를 작성할 수 있습니다 . 옵션 체인의 쇼 스타는 새로운 &lt;code&gt;?.&lt;/code&gt; &lt;em&gt;선택적 속성 액세스를&lt;/em&gt; 위한 연산자 . 우리가 같은 코드를 작성할 때</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes" xml:space="preserve">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="translated">명령 행에서 TypeScript 컴파일러를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes" xml:space="preserve">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="translated">이 시점에서 프로젝트 루트에서 &lt;code&gt;tsc&lt;/code&gt; 를 실행하려고 하면 &lt;code&gt;built&lt;/code&gt; 디렉토리 에 출력 파일이 표시 됩니다. &lt;code&gt;built&lt;/code&gt; 파일 의 레이아웃은 &lt;code&gt;src&lt;/code&gt; 의 레이아웃과 동일해야합니다 . 이제 프로젝트에서 TypeScript가 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes" xml:space="preserve">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="translated">이 시점에서 컴파일러는&amp;ldquo; &lt;code&gt;moduleA&lt;/code&gt; 의 모양은 무엇 입니까?&amp;rdquo;라고 묻습니다 . 이것이 간단하게 들리지만 &lt;code&gt;moduleA&lt;/code&gt; 는 자신의 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 파일 중 하나 또는 코드가 의존 하는 &lt;code&gt;.d.ts&lt;/code&gt; 에 정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="translated">이제 TypeScript 파일을 사용할 수 있습니다. 첫 번째 단계는 &lt;code&gt;.js&lt;/code&gt; 파일 중 하나의 이름 을 &lt;code&gt;.ts&lt;/code&gt; 로 바꾸는 것입니다 . 파일이 JSX를 사용하는 경우 파일 이름을 &lt;code&gt;.tsx&lt;/code&gt; 로 바꾸어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes" xml:space="preserve">
          <source>Attribute type checking</source>
          <target state="translated">속성 유형 확인</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes" xml:space="preserve">
          <source>Augmenting global/module scope from modules</source>
          <target state="translated">모듈에서 글로벌 / 모듈 범위 확대</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes" xml:space="preserve">
          <source>Automatically set to PreferredUILang value</source>
          <target state="translated">PreferredUILang 값으로 자동 설정</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="d20e2c01b6a2f58cc429d37f014c475da407fd6a" translate="yes" xml:space="preserve">
          <source>Babel for transpiling, &lt;code&gt;tsc&lt;/code&gt; for types</source>
          <target state="translated">transpiling을위한 바벨 &lt;code&gt;tsc&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes" xml:space="preserve">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="translated">Babel은 ES2015 이상을 ES5 및 ES3로 변환하는 매우 유연한 컴파일러입니다. 이렇게하면 TypeScript에서 지원하지 않는 광범위하고 사용자 정의 된 변환을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d398ffcbadffa21d8b3f31a932766b42449e22" translate="yes" xml:space="preserve">
          <source>Babel vs &lt;code&gt;tsc&lt;/code&gt; for TypeScript</source>
          <target state="translated">TypeScript의 Babel 대 &lt;code&gt;tsc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes" xml:space="preserve">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="translated">Babel의 ES5 출력은 이러한 간단한 스크립트에 대한 TypeScript의 출력과 매우 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes" xml:space="preserve">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="translated">TypeScript가 퍼블릭 클래스 필드를 구현했을 때, 우리는 다음 코드를 최대한 활용했다고 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes" xml:space="preserve">
          <source>Bare Import</source>
          <target state="translated">베어 임포트</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes" xml:space="preserve">
          <source>Base URL</source>
          <target state="translated">기본 URL</target>
        </trans-unit>
        <trans-unit id="6f8087950b61f86d74cf472c3db8209a3e21e0bb" translate="yes" xml:space="preserve">
          <source>Base Url - &lt;code&gt;baseUrl&lt;/code&gt;</source>
          <target state="translated">기본 URL- &lt;code&gt;baseUrl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes" xml:space="preserve">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">상대적이지 않은 모듈 이름을 해결하기위한 기본 디렉토리. 자세한 내용은 &lt;a href=&quot;module-resolution#base-url&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4833160c36b89ddb86e6b6fbca4d0e967b129ce3" translate="yes" xml:space="preserve">
          <source>Based on the description, it sounds easy to downlevel to ES5:</source>
          <target state="translated">설명에 따르면 ES5로 쉽게 내려가는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="356e91f1e0248e37e452abdcd998b2dddab60e58" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, TypeScript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so TypeScript will throw an error.</source>
          <target state="translated">위의 기능이 할당되고 있다는 사실에 기초 &lt;code&gt;Window.onscroll&lt;/code&gt; , 타이프 라이터는 것을 알고 &lt;code&gt;uiEvent&lt;/code&gt; A는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/UIEvent&quot;&gt;UIEvent를&lt;/a&gt; , 아닌 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;된 MouseEvent&lt;/a&gt; 앞의 예처럼. &lt;code&gt;UIEvent&lt;/code&gt; 객체에는 &lt;code&gt;button&lt;/code&gt; 속성이 없으므로 TypeScript에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="translated">위의 함수가 &lt;code&gt;Window.onscroll&lt;/code&gt; 에 할당되고 있다는 사실에 따라 Typescript는 &lt;code&gt;uiEvent&lt;/code&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt; 이며 이전 예제와 같은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; 가 아니라는 것을 알고 있습니다. &lt;code&gt;UIEvent&lt;/code&gt; 객체에는 &lt;code&gt;button&lt;/code&gt; 속성이 없으므로 Typescript에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">기본 개념</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes" xml:space="preserve">
          <source>Basic Gruntfile.js</source>
          <target state="translated">기본 Gruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes" xml:space="preserve">
          <source>Basic Types: Any</source>
          <target state="translated">기본 유형 : 모두</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes" xml:space="preserve">
          <source>Basic Types: Array</source>
          <target state="translated">기본 유형 : 배열</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes" xml:space="preserve">
          <source>Basic Types: Enum</source>
          <target state="translated">기본 유형 : 열거 형</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes" xml:space="preserve">
          <source>Basic Types: Never</source>
          <target state="translated">기본 유형 : Never</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes" xml:space="preserve">
          <source>Basic Types: Tuple</source>
          <target state="translated">기본 유형 : 튜플</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes" xml:space="preserve">
          <source>Basic Types: Void</source>
          <target state="translated">기본 유형 : 무효</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes" xml:space="preserve">
          <source>Basic gulpfile.js</source>
          <target state="translated">기본 gulpfile.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="translated">Webpack 1 사용시 기본 webpack.config.js</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="translated">Webpack 2 사용시 기본 webpack.config.js</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;&quot;모듈 호출 서명에 대한 ES6의 영향&quot;각주&lt;/a&gt; 를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="translated">때문에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;소프트웨어의 이상적인 속성 확장에 개방되고&lt;/a&gt; , 당신은 항상 타입 별칭 가능한 경우를 통해 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;Dog&lt;/code&gt; 에서 기능 확장 &lt;code&gt;Animal&lt;/code&gt; , 우리의 인스턴스를 만들 수 있었다 &lt;code&gt;Dog&lt;/code&gt; 수를 모두 &lt;code&gt;bark()&lt;/code&gt; 및 &lt;code&gt;move()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="translated">때문에 &lt;code&gt;createClock&lt;/code&gt; 최초의 파라미터 타입이다 &lt;code&gt;ClockConstructor&lt;/code&gt; 에 &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt; , 그것을 확인하는 것이 &lt;code&gt;AnalogClock&lt;/code&gt; 는 올바른 생성자 서명을 갖는다.</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="translated">&lt;code&gt;haveMuscles&lt;/code&gt; 는 내 보내지 않기 때문에 병합되지 않은 동일한 네임 스페이스를 공유하는 &lt;code&gt;animalsHaveMuscles&lt;/code&gt; 함수 만 심볼을 볼 수 있습니다. &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; 은 의 그것의 일부가 합병에도 불구하고, 기능 &lt;code&gt;Animal&lt;/code&gt; 이름 공간이 내 보내지 않은 구성원을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="translated">모든 유형의 하위 유형은 &lt;code&gt;never&lt;/code&gt; 아니기 때문에 항상 공용체 유형에서 생략되며 반환되는 다른 유형이있는 한 함수 반환 유형 유추에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 모든 타입에 할당 할 수 없기 때문에 ,보다 특정한 타입을 반환하는 콜백이 필요할 때는 &lt;code&gt;never&lt;/code&gt; 반환하는 함수를 사용할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="translated">때문에 &lt;code&gt;onClickGood&lt;/code&gt; 은 그 지정 &lt;code&gt;this&lt;/code&gt; 같은 유형의 &lt;code&gt;void&lt;/code&gt; ,에 전달할 법적 &lt;code&gt;addClickListener&lt;/code&gt; . 물론 이것은 &lt;code&gt;this.info&lt;/code&gt; 를 사용할 수 없다는 것을 의미합니다 . 둘 다 원한다면 화살표 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes" xml:space="preserve">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="translated">TypeScript는 구조적 유형 시스템이므로 유형 매개 변수는 멤버 유형의 일부로 소비 될 때 결과 유형에만 영향을줍니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="926c5ce8de1d04093ea0f5a3309faccac7464c9c" translate="yes" xml:space="preserve">
          <source>Because TypeScript is structural, it doesn&amp;rsquo;t need type parameters as much as nominal systems. Specifically, they are not needed to make a function polymorphic. Type parameters should only be used to &lt;em&gt;propagate&lt;/em&gt; type information, such as constraining parameters to be the same type:</source>
          <target state="translated">TypeScript는 구조적이므로 공칭 시스템만큼 유형 매개 변수가 필요하지 않습니다. 특히 함수를 다형성으로 만드는 데 필요하지 않습니다. 유형 매개 변수는 매개 변수를 동일한 유형으로 제한하는 것과 같이 유형 정보 를 &lt;em&gt;전파&lt;/em&gt; 하는 데만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes" xml:space="preserve">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="translated">TypeScript 는 &lt;code&gt;this&lt;/code&gt; 를 반환 한 &lt;code&gt;BasicCalculator&lt;/code&gt; 의 각 메소드에 대해 &lt;code&gt;BasicCalculator&lt;/code&gt; 유형을 유추하는 데 사용 되었기 때문에 유형 시스템은 &lt;code&gt;BasicCalculator&lt;/code&gt; 메소드를 사용할 때마다 &lt;code&gt;ScientificCalculator&lt;/code&gt; 를 가지고 있다는 사실을 잊었습니다 .</target>
        </trans-unit>
        <trans-unit id="bedf22fdedc00ef56a14dec85f7bb3b3494d73cc" translate="yes" xml:space="preserve">
          <source>Because TypeScript&amp;rsquo;s type system is fully erased, information about e.g. the instantiation of a generic type parameter is not available at runtime.</source>
          <target state="translated">TypeScript의 유형 시스템이 완전히 지워졌 기 때문에 일반 유형 매개 변수의 인스턴스화와 같은 정보는 런타임에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes" xml:space="preserve">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="translated">함수 구성 요소는 단순히 JavaScript 함수이므로 함수 오버로드도 여기에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="805d3d429e696b76e1abd7a4044863cf0873570b" translate="yes" xml:space="preserve">
          <source>Because an interface more closely maps how JavaScript objects work &lt;a href=&quot;https://wikipedia.org/wiki/Open/closed_principle&quot;&gt;by being open to extension&lt;/a&gt;, we recommend using an interface over a type alias when possible.</source>
          <target state="translated">인터페이스 &lt;a href=&quot;https://wikipedia.org/wiki/Open/closed_principle&quot;&gt;는 extension에 개방되어&lt;/a&gt; JavaScript 객체가 작동하는 방식을보다 밀접하게 매핑 하므로 가능하면 유형 별칭보다 인터페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes" xml:space="preserve">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="translated">종속 프로젝트 는 해당 종속 항목으로 빌드 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 사용하기 때문에 특정 빌드 출력을 확인 &lt;em&gt;하거나&lt;/em&gt; 복제 한 후 프로젝트를 빌드해야 의심스러운 오류없이 편집기에서 프로젝트를 탐색 할 수 있습니다. 우리는이를 완화 할 수있는 무대 뒤에서 생성되는 .d.ts 생성 프로세스를 개발하고 있지만 현재로서는 개발자에게 복제 후 빌드하도록 지시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="translated">각각의 &lt;code&gt;unique symbol&lt;/code&gt; 은 완전히 별개의 아이덴티티를 가지 므로 , 두 개의 &lt;code&gt;unique symbol&lt;/code&gt; 유형은 서로 할당되거나 비교 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd9b4625ee3434502c77baac6fb3b4163197cdca" translate="yes" xml:space="preserve">
          <source>Because every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new &lt;code&gt;watchOptions&lt;/code&gt; field which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.</source>
          <target state="translated">모든 프로젝트가 다른 전략에서 더 잘 작동 할 수 있고이 새로운 접근 방식이 워크 플로에 적합하지 않을 수 있기 때문에 TypeScript 3.8 은 사용자가 컴파일러 / 언어 서비스에 파일을 추적하는 데 사용해야하는 감시 전략을 알릴 수 있는 새로운 &lt;code&gt;watchOptions&lt;/code&gt; 필드를 도입했습니다. 및 디렉토리.</target>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes" xml:space="preserve">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="translated">인터페이스 (및 기타 객체 유형)에 간접적 인 수준이 도입되고 전체 구조를 간절히 구축 할 필요가 없으므로 TypeScript는이 구조를 사용하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="translated">일반적으로 글로벌 라이브러리를 UMD 라이브러리로 쉽게 전환 할 수 있기 때문에 여전히 글로벌 스타일로 작성된 인기 라이브러리는 거의 없습니다. 그러나 크기가 작고 DOM이 필요하거나 종속성 이 &lt;em&gt;없는&lt;/em&gt; 라이브러리 는 여전히 전역적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes" xml:space="preserve">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="translated">이로 인해 이제 표준 라이브러리에 기본적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="21ce5edafa407b8340ea3cb9742b87949fcfb1fa" translate="yes" xml:space="preserve">
          <source>Because of the variety of supported JavaScript, upgrading to a new version of TypeScript can uncover two types of errors:</source>
          <target state="translated">지원되는 JavaScript가 다양하기 때문에 새 버전의 TypeScript로 업그레이드하면 두 가지 유형의 오류를 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 가 더 이상 완전하지 않기 때문에 TypeScript는 함수가 때때로 &lt;code&gt;undefined&lt;/code&gt; 를 반환 할 수 있음을 알고 있습니다. 명시적인 반환 유형 &lt;code&gt;number&lt;/code&gt; 가있는 경우 반환 유형이 실제로 &lt;code&gt;number | undefined&lt;/code&gt; 라는 오류가 발생합니다. undefined . 그러나이 방법은 매우 미묘하며 &lt;code&gt;--strictNullChecks&lt;/code&gt; 는 항상 이전 코드에서 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a169ffc6d01ce9e9e1170f6d035a3b9d98c04e7e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;string&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;string | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; does not always work with old code.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 가 더 이상 완전하지 않기 때문에 TypeScript는 함수가 때때로 &lt;code&gt;undefined&lt;/code&gt; 를 반환 할 수 있음을 알고 있습니다. 명시적인 반환 유형 &lt;code&gt;string&lt;/code&gt; 이있는 경우 반환 유형이 실제로 &lt;code&gt;string | undefined&lt;/code&gt; 이라는 오류가 발생합니다. undefined . 그러나이 방법은 매우 미묘하며 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt; &lt;code&gt;--strictNullChecks&lt;/code&gt; &lt;/a&gt; 가 항상 이전 코드에서 작동하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes" xml:space="preserve">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="translated">제공된 공통 유형에서 최상의 공통 유형을 선택해야하기 때문에 유형이 공통 구조를 공유하는 경우가 있지만 어떤 유형도 모든 후보 유형의 수퍼 유형이 아닙니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes" xml:space="preserve">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="translated">이제 일반 함수가 제한되었으므로 더 이상 모든 유형에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1ed1478bf3076f9798d93562781e783237eee9e" translate="yes" xml:space="preserve">
          <source>Because there&amp;rsquo;s no value for &lt;code&gt;someType&lt;/code&gt;, the emitted &lt;code&gt;export&lt;/code&gt; will not try to export it (this would be a runtime error in JavaScript):</source>
          <target state="translated">&lt;code&gt;someType&lt;/code&gt; 에 대한 값이 없기 때문에 &lt;code&gt;export&lt;/code&gt; 는 내보내기 를 시도하지 않습니다 (JavaScript의 런타임 오류).</target>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes" xml:space="preserve">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="translated">이 두 가지 유형의 값 기반 요소는 JSX 표현식에서 서로 구별 할 수 없으므로 첫 번째 TS는 과부하 해결을 사용하여 표현식을 함수 구성 요소로 해석하려고합니다. 프로세스가 성공하면 TS는 선언을 식으로 해석합니다. 값이 함수 구성 요소로 해석되지 않으면 TS는이를 클래스 구성 요소로 해석하려고 시도합니다. 실패하면 TS가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="translated">우리는 환경 내에서 &lt;code&gt;city&lt;/code&gt; 를 점령 했으므로 &lt;code&gt;if&lt;/code&gt; 블록의 실행이 완료 되었음에도 불구하고 도시에 계속 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes" xml:space="preserve">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="translated">ES2015 이전에는 Javascript가 클래스 대신 생성자 함수를 사용했습니다. 컴파일러는이 패턴을 지원하고 ES2015 클래스와 동등한 생성자 함수를 이해합니다. 위에서 설명한 속성 유추 규칙은 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes" xml:space="preserve">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="translated">TypeScript 2.0 이전에는 모듈 식별자가 항상 확장이없는 것으로 가정했습니다. 예를 들어, &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt; 로 가져 오기를 수행 하면 컴파일러는 &lt;code&gt;./moduleA.js.ts&lt;/code&gt; 또는 &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt; 에서 &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; 의 정의를 검색했습니다 . 이로 인해 모듈 식별자에 URI가 &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;필요한 SystemJS&lt;/a&gt; 와 같은 번들링 / 로딩 도구를 사용하기가 어려웠습니다 .</target>
        </trans-unit>
        <trans-unit id="67d8456dd67e313605647faf280117c02dfc9eeb" translate="yes" xml:space="preserve">
          <source>Before getting started with &lt;a href=&quot;basic-types&quot;&gt;Basic Types&lt;/a&gt;, we recommend reading one of the following introductory pages. These introductions are intended to highlight key similarities and differences between TypeScript and your favored programming language, and clear up common misconceptions specific to those languages.</source>
          <target state="translated">&lt;a href=&quot;basic-types&quot;&gt;기본 유형&lt;/a&gt; 을 시작하기 전에 다음 소개 페이지 중 하나를 읽는 것이 좋습니다. 이 소개는 TypeScript와 선호하는 프로그래밍 언어 간의 주요 유사점과 차이점을 강조하고 해당 언어에 대한 일반적인 오해를 정리하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes" xml:space="preserve">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="translated">Browserify를 시작하기 전에 코드를 작성하고 믹스에 모듈을 추가하겠습니다. 실제 앱에 사용하기 쉬운 구조입니다.</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes" xml:space="preserve">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;m&lt;/code&gt; 모두 벨로우즈 값을 &lt;em&gt;읽지&lt;/em&gt; 않기 때문에 미사용으로 표시됩니다 . 이전에 TypeScript는 해당 값이 &lt;em&gt;참조&lt;/em&gt; 되었는지 여부 만 확인했습니다 .</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes" xml:space="preserve">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="translated">아래에서는 이전 예제에서 사용 된 Validator 구현을 통합하여 각 모듈에서 하나의 명명 된 내보내기 만 내보냈습니다.</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes" xml:space="preserve">
          <source>Best common type</source>
          <target state="translated">가장 일반적인 유형</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes" xml:space="preserve">
          <source>Better Module Visibility Rules</source>
          <target state="translated">더 나은 모듈 가시성 규칙</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes" xml:space="preserve">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 반환 기능에 대한 향상된 지원</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes" xml:space="preserve">
          <source>Better Type Inference</source>
          <target state="translated">더 나은 타입 추론</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes" xml:space="preserve">
          <source>Better Unicode Support for Identifiers</source>
          <target state="translated">식별자에 대한 더 나은 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes" xml:space="preserve">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="translated">피연산자에서 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 를 더 잘 검사</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes" xml:space="preserve">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일 에서 네임 스페이스 패턴 처리 개선</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes" xml:space="preserve">
          <source>Better inference for literal types</source>
          <target state="translated">리터럴 유형에 대한 더 나은 추론</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes" xml:space="preserve">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="translated">TypeScript에서 BigInt 지원은 &lt;code&gt;bigint&lt;/code&gt; (모두 소문자) 라는 새로운 기본 유형을 도입합니다 . &lt;code&gt;BigInt()&lt;/code&gt; 함수 를 호출 하거나 정수 숫자 리터럴의 끝에 &lt;code&gt;n&lt;/code&gt; 을 추가하여 BigInt 리터럴을 작성 하여 &lt;code&gt;bigint&lt;/code&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes" xml:space="preserve">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">BigInts는 이론적으로 임의로 큰 정수를 모델링 할 수있는 ECMAScript의 향후 제안의 일부입니다. 타이프 3.2 타겟팅 할 때의 BIGINT 리터럴을 방출 BigInts 종류별 검사뿐만 아니라 지원을 제공 &lt;code&gt;esnext&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes" xml:space="preserve">
          <source>Block scoped</source>
          <target state="translated">범위가 지정된 블록</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes" xml:space="preserve">
          <source>Block-scoped variable capturing</source>
          <target state="translated">블록 범위의 변수 캡처</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes" xml:space="preserve">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="1e4200b2f583d0dc3a8f8c9ca192857c23373085" translate="yes" xml:space="preserve">
          <source>Boolean Literal Types</source>
          <target state="translated">부울 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 및 &lt;code&gt;for..in&lt;/code&gt; 문 모두 목록을 반복합니다. 반복되는 값은 다르지만 &lt;code&gt;for..in&lt;/code&gt; 은 반복되는 객체 의 &lt;em&gt;키&lt;/em&gt; 목록을 반환하고 &lt;code&gt;for..of&lt;/code&gt; 는 반복되는 객체 의 숫자 속성 &lt;em&gt;값&lt;/em&gt; 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes" xml:space="preserve">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="translated">CommonJS와 AMD는 일반적으로 모듈의 모든 내보내기를 포함 하는 &lt;code&gt;exports&lt;/code&gt; 오브젝트 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes" xml:space="preserve">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="translated">이 두 가지 의존성 모두 TypeScript와 웹팩을 함께 사용할 수 있습니다. ts-loader는 Typepack의 표준 구성 파일 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하여 Webpack이 TypeScript 코드를 컴파일하도록 도와줍니다 . sourcemap 로더를 생성 할 때 웹팩 알려 타이프에서 모든 sourcemap 출력을 사용하여 &lt;em&gt;자체&lt;/em&gt; sourcemaps한다. 이렇게하면 원본 TypeScript 소스 코드를 디버깅하는 것처럼 최종 출력 파일을 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8845429ecea7d81d05bd48bc682718054a7086" translate="yes" xml:space="preserve">
          <source>Both of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in &lt;em&gt;lib.dom.d.ts&lt;/em&gt; as:</source>
          <target state="translated">이 두 가지 방법 모두보다 고유 한 제약 조건에 맞는 dom 요소 목록을 가져 오는 데 유용한 도구입니다. &lt;em&gt;lib.dom.d.ts&lt;/em&gt; 에서 &lt;em&gt;다음&lt;/em&gt; 과 같이 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="85a3e07fa1f601ed37521339b8334bccb8a1dfdc" translate="yes" xml:space="preserve">
          <source>Boxed types</source>
          <target state="translated">박스형</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes" xml:space="preserve">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="translated">일반적으로 선언 파일 을 &lt;em&gt;구성&lt;/em&gt; 하는 방법은 라이브러리 사용 방식에 따라 다릅니다. JavaScript에서 사용할 라이브러리를 제공하는 방법에는 여러 가지가 있으며, 선언 파일과 일치하도록 선언 파일을 작성해야합니다. 이 안내서는 일반적인 라이브러리 패턴을 식별하는 방법과 해당 패턴에 해당하는 선언 파일을 작성하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes" xml:space="preserve">
          <source>Build Mode for TypeScript</source>
          <target state="translated">TypeScript의 빌드 모드</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes" xml:space="preserve">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="translated">필요한 경우 빌드 모드 (아래 참조)가 참조 된 프로젝트를 자동으로 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes" xml:space="preserve">
          <source>Build out-of-date projects in the correct order</source>
          <target state="translated">올바른 순서로 오래된 프로젝트를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes" xml:space="preserve">
          <source>Build tools</source>
          <target state="translated">빌드 도구</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes" xml:space="preserve">
          <source>Build-Free Editing with Project References</source>
          <target state="translated">프로젝트 참조를 사용한 빌드없는 편집</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes" xml:space="preserve">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="translated">이 작업을 기반으로하는 새로운 &lt;code&gt;Generator&lt;/code&gt; 유형은 항상 &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 메소드를 모두 가지고 있으며 반복 가능한 &lt;code&gt;Iterator&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes" xml:space="preserve">
          <source>Building your first TypeScript file</source>
          <target state="translated">첫 번째 TypeScript 파일 작성</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes" xml:space="preserve">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">이 프로젝트와 &lt;a href=&quot;project-references&quot;&gt;Project References에&lt;/a&gt; 의해 지정된 모든 종속성을 빌드합니다 . 이 플래그는이 페이지의 다른 플래그와 호환되지 않습니다. &lt;a href=&quot;project-references&quot;&gt;여기&lt;/a&gt; 더 참조</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes" xml:space="preserve">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="translated">내장 된 &lt;em&gt;lib&lt;/em&gt; 파일은 &lt;em&gt;tsconfig.json&lt;/em&gt; 의 &lt;code&gt;&quot;lib&quot;&lt;/code&gt; 컴파일러 옵션 과 동일한 방식으로 참조됩니다 (예 : &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; 등이 아닌 &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes" xml:space="preserve">
          <source>Built-in Combinations</source>
          <target state="translated">내장 조합</target>
        </trans-unit>
        <trans-unit id="0f6bebd51ff8927e6e3679a7b2412429e9c60cb6" translate="yes" xml:space="preserve">
          <source>Built-in types</source>
          <target state="translated">내장 유형</target>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="translated">그러나 &lt;em&gt;아닙니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes" xml:space="preserve">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="translated">그러나 조건부 유형이 지연되는 지점의 예를 들어 분기를 선택하는 대신 고정되는 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="280120ab44ab2249440ce6b53b7137cb76018378" translate="yes" xml:space="preserve">
          <source>But it also infers types in a few other places that you may not expect if you&amp;rsquo;ve worked with other C-syntax languages:</source>
          <target state="translated">그러나 다른 C- 구문 언어로 작업 한 적이 있다면 예상하지 못한 몇 가지 다른 위치의 유형도 추론합니다.</target>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="translated">그러나 일반 버전을 사용하는 것이 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes" xml:space="preserve">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="translated">그러나 기본값을 지정하는 것이 매개 변수에 더 일반적이며, 구조화를 사용하여 기본값을 올바르게 설정하는 것은 까다로울 수 있습니다. 우선, 패턴을 기본값보다 먼저 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes" xml:space="preserve">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="translated">그러나 인터페이스 도입에 대한 해결 방법은 사용자에게는 직관적이지 않았습니다. 그리고 원칙적으로 &lt;code&gt;Array&lt;/code&gt; 를 직접 사용 하는 원래 버전의 &lt;code&gt;ValueOrArray&lt;/code&gt; 에는 아무런 문제가 없었습니다 . 컴파일러가 &quot;게으르다&quot;고 필요할 때 &lt;code&gt;Array&lt;/code&gt; 대한 형식 인수 만 계산하면 TypeScript가이를 올바르게 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes" xml:space="preserve">
          <source>By Example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes" xml:space="preserve">
          <source>By Example: Classes</source>
          <target state="translated">예를 들어 : 클래스</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes" xml:space="preserve">
          <source>By Example: Global Functions</source>
          <target state="translated">예를 들어 : 전역 함수</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes" xml:space="preserve">
          <source>By Example: Global Variables</source>
          <target state="translated">예를 들어 : 전역 변수</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes" xml:space="preserve">
          <source>By Example: Objects with Properties</source>
          <target state="translated">예 : 속성이있는 객체</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes" xml:space="preserve">
          <source>By Example: Organizing Types</source>
          <target state="translated">예 : 유형 구성</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes" xml:space="preserve">
          <source>By Example: Overloaded Functions</source>
          <target state="translated">예를 들어 : 오버로드 된 함수</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="translated">예 : 재사용 가능한 유형 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="translated">예 : 재사용 가능한 유형 (유형 별명)</target>
        </trans-unit>
        <trans-unit id="7bae2a3265a68393939ee4d97179b68dd46cb074" translate="yes" xml:space="preserve">
          <source>By default (with &lt;code&gt;esModuleInterop&lt;/code&gt; false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:</source>
          <target state="translated">기본적으로 ( &lt;code&gt;esModuleInterop&lt;/code&gt; false 또는 설정되지 않음) TypeScript는 CommonJS / AMD / UMD 모듈을 ES6 모듈과 유사하게 처리합니다. 이 과정에서 특히 잘못된 가정으로 판명 된 두 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 다른 모든 유형의 하위 유형입니다. 즉, &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 를 &lt;code&gt;number&lt;/code&gt; 와 같은 것으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">기본적으로 AMD 모듈은 익명으로 생성됩니다. 다른 도구를 사용하여 &lt;code&gt;r.js&lt;/code&gt; (예 : r.js ) 와 같은 결과 모듈을 처리 할 때 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">기본적으로 AMD 모듈은 익명으로 생성됩니다. 이로 인해 &lt;code&gt;r.js&lt;/code&gt; (예 : r.js ) 와 같은 다른 모듈을 사용하여 결과 모듈을 처리 할 때 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">기본적으로 &lt;em&gt;보이는&lt;/em&gt; 모든 &quot; &lt;code&gt;@types&lt;/code&gt; &quot;패키지가 컴파일에 포함됩니다. 둘러싸는 폴더의 &lt;code&gt;node_modules/@types&lt;/code&gt; 에있는 패키지는 &lt;em&gt;보이는&lt;/em&gt; 것으로 간주됩니다 . 즉, &lt;code&gt;./node_modules/@types/&lt;/code&gt; , &lt;code&gt;../node_modules/@types/&lt;/code&gt; , &lt;code&gt;../../node_modules/@types/&lt;/code&gt; 등의 패키지를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e8d004cf1198829c9480cb66e1fa5db152e6f49b" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;rdquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;. For example, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">기본적으로 &lt;em&gt;표시되는&lt;/em&gt; 모든 &amp;rdquo; &lt;code&gt;@types&lt;/code&gt; &amp;rdquo;패키지가 컴파일에 포함됩니다. 포함하는 폴더의 &lt;code&gt;node_modules/@types&lt;/code&gt; 에있는 패키지는 &lt;em&gt;보이는&lt;/em&gt; 것으로 간주됩니다 . 예를 들어 &lt;code&gt;./node_modules/@types/&lt;/code&gt; , &lt;code&gt;../node_modules/@types/&lt;/code&gt; , &lt;code&gt;../../node_modules/@types/&lt;/code&gt; 등의 패키지를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bbe14b4afe246d0c7517495f8c1f6da852617e95" translate="yes" xml:space="preserve">
          <source>By default converts to this JavaScript:</source>
          <target state="translated">기본적으로 다음 JavaScript로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes" xml:space="preserve">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">기본적으로 TypeScript 컴파일러는 &lt;code&gt;--allowJs&lt;/code&gt; 사용을 포함하여 .js 파일의 오류를보고하지 않습니다 . 타이프 라이터로 2.3 유형 검사 오류는보고 할 수 &lt;code&gt;.js&lt;/code&gt; 와 파일 &lt;code&gt;--checkJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes" xml:space="preserve">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="translated">기본적으로 출력 줄 바꾸기 문자는 Windows 기반 시스템에서 &lt;code&gt;\r\n&lt;/code&gt; 이고 * nix 기반 시스템에서 &lt;code&gt;\n&lt;/code&gt; 입니다. &lt;code&gt;--newLine&lt;/code&gt; 명령 줄 플래그를 사용하면이 동작을 재정의하고 생성 된 출력 파일에 사용할 줄 바꾸기 문자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes" xml:space="preserve">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="translated">기본적으로 JSX 식의 결과로 입력되어 &lt;code&gt;any&lt;/code&gt; . &lt;code&gt;JSX.Element&lt;/code&gt; 인터페이스 를 지정하여 유형을 사용자 정의 할 수 있습니다 . 그러나이 인터페이스에서 JSX의 요소, 속성 또는 하위에 대한 유형 정보를 검색 할 수 없습니다. 블랙 박스입니다.</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes" xml:space="preserve">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">기본적 으로 함수 내 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;any&lt;/code&gt; 입니다. TypeScript 2.0부터 명시적인 &lt;code&gt;this&lt;/code&gt; 매개 변수를 제공 할 수 있습니다 . &lt;code&gt;this&lt;/code&gt; 매개 변수는 함수의 매개 변수 목록에서 가장 먼저 나오는 가짜 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes" xml:space="preserve">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="translated">이러한 설정으로 기본적으로 &lt;code&gt;tsc&lt;/code&gt; 를 실행 하면 TypeScript는 출력 디렉토리 ( &lt;code&gt;./lib&lt;/code&gt; ) 에서 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 라는 파일을 찾습니다 . 경우 &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; 이 존재하지 않는, 그것은 생성됩니다. 그러나 만약 그렇다면, &lt;code&gt;tsc&lt;/code&gt; 는 그 파일을 사용하여 출력 파일을 점진적으로 타입 검사하고 업데이트하려고 시도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes" xml:space="preserve">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="translated">기본적으로 TypeScript는 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 모든 유형의 도메인에 있다고 가정합니다 . 즉, 유형 &lt;code&gt;number&lt;/code&gt; 선언 된 것은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 일 수 있습니다 . 때문에 &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 자바 스크립트와 타이프 라이터 버그의 이러한 자주 원천, 타이프 라이터는이 &lt;code&gt;strictNullChecks&lt;/code&gt; 의 이러한 문제에 대한 걱정의 당신에게 스트레스를 절약하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="81ae234f340bd85fd153e90ec1d2e0c01b304e39" translate="yes" xml:space="preserve">
          <source>By default, TypeScript will examine the initial set of files for &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;&amp;lt;reference&lt;/code&gt; directives and add these resolved files to your program.</source>
          <target state="translated">기본적으로 TypeScript는 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;&amp;lt;reference&lt;/code&gt; 지시문에 대한 초기 파일 집합을 검사하고 이러한 해결 된 파일을 프로그램에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes" xml:space="preserve">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">기본적으로 열거 형은 &lt;code&gt;0&lt;/code&gt; 부터 시작하여 멤버의 번호를 지정합니다 . 멤버 중 하나의 값을 수동으로 설정하여이를 변경할 수 있습니다. 예를 들어 이전 예제를 &lt;code&gt;0&lt;/code&gt; 대신 &lt;code&gt;1&lt;/code&gt; 에서 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b2f3061b8b67ef271d84bdab07aa0d4586d6daa" translate="yes" xml:space="preserve">
          <source>By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 유형 검사기는 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 것으로 간주 하여 모든 항목에 할당 할 수 있습니다. 사실상 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 모든 유형의 유효한 값입니다. 즉 , 방지하려는 경우에도 어떤 유형에도 할당되는 것을 &lt;em&gt;중지&lt;/em&gt; 할 수 없습니다. &lt;code&gt;null&lt;/code&gt; 의 발명가 인 Tony Hoare는 이것을 &lt;a href=&quot;https://wikipedia.org/wiki/Null_pointer#History&quot;&gt;&quot;10 억 달러의 실수&quot;라고&lt;/a&gt; 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes" xml:space="preserve">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="translated">이렇게하면 빌드 시간을 크게 향상시키고 구성 요소 간 논리적 분리를 시행하며 새롭고 더 나은 방법으로 코드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes" xml:space="preserve">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="translated">TypeScript의 Visual Studio 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="translated">입력 파일없이 tsc를 호출하고 tsconfig.json 파일을 포함하는 디렉토리의 경로를 지정하는 -project (또는 단지 -p) 명령 행 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="translated">입력 파일없이 tsc를 호출 하고 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 포함하는 디렉토리 의 경로 또는 구성을 포함 하는 유효한 &lt;code&gt;.json&lt;/code&gt; 파일 의 경로를 지정 하는 &lt;code&gt;--project&lt;/code&gt; (또는 단지 &lt;code&gt;-p&lt;/code&gt; ) 명령 행 옵션을 사용 하여.</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">입력 파일없이 tsc를 호출하면 컴파일러 는 현재 디렉토리에서 시작하여 상위 디렉토리 체인을 계속 하여 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">입력 파일없이 tsc를 호출하면 컴파일러는 현재 디렉토리에서 시작하여 상위 디렉토리 체인을 계속하여 tsconfig.json 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes" xml:space="preserve">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; 명령 줄 옵션을 전달하면 TypeScript는 상황이 잘못되는 상황에 대한보다 다채로운 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes" xml:space="preserve">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 를 활용 하여 컴파일러에이 매핑을 &lt;code&gt;./#{locale}/messages&lt;/code&gt; 디렉토리가 존재하지 않더라도 ./#{locale}/messages 를 안전하게 해석 할 수 있습니다. 예를 들어, 다음 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes" xml:space="preserve">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="translated">지금까지 &lt;code&gt;var&lt;/code&gt; 에 몇 가지 문제 가 있음을 알아 냈습니다 . 이것이 바로 &lt;code&gt;let&lt;/code&gt; 문이 도입 된 이유 입니다. 별도로 사용되는 키워드에서, &lt;code&gt;let&lt;/code&gt; 문이 같은 방식으로 작성됩니다 &lt;code&gt;var&lt;/code&gt; 에 문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d522062326dbb5972e36c53a7116048922cfac7" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">이 가이드를 읽으면 친숙한 API 표면을 노출하는 복잡한 선언 파일을 작성하는 도구를 갖게됩니다. 이 가이드는 여기에있는 옵션이 더 다양하기 때문에 모듈 (또는 UMD) 라이브러리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">이 안내서를 읽으면 친숙한 API 표면을 노출하는 복잡한 정의 파일을 작성하는 도구가 제공됩니다. 이 가이드는 옵션이 다양하기 때문에 모듈 (또는 UMD) 라이브러리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes" xml:space="preserve">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="translated">여러 프로젝트로 분리하여 유형 검사 및 컴파일 속도를 크게 향상시키고 편집기 사용시 메모리 사용량을 줄이며 프로그램의 논리적 그룹 적용을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes" xml:space="preserve">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="translated">그런데 일부 언어 (예 : C # 및 스칼라)에는 분산 주석 ( &lt;code&gt;out&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; )이 필요하지만 TypeScript의 구조적 유형 시스템으로 인해 일반 유형 내에서 유형 매개 변수를 실제로 사용하면 차이가 자연스럽게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="37a5bb86f5de627c75eefc01c9440b9728e21c0e" translate="yes" xml:space="preserve">
          <source>By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That&amp;rsquo;s how TypeScript knows that &lt;code&gt;helloWorld&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt; in the above example.</source>
          <target state="translated">JavaScript가 작동하는 방식을 이해함으로써 TypeScript는 JavaScript 코드를 받아들이지 만 유형이있는 유형 시스템을 구축 할 수 있습니다. 이것은 코드에서 유형을 명시하기 위해 추가 문자를 추가 할 필요없이 유형 시스템을 제공합니다. 이것이 TypeScript가 위의 예에서 &lt;code&gt;helloWorld&lt;/code&gt; 가 &lt;code&gt;string&lt;/code&gt; 이라는 것을 아는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="970dc4b5ed34cee139d022f1ef1a7253a84f38eb" translate="yes" xml:space="preserve">
          <source>By using babel&amp;rsquo;s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.</source>
          <target state="translated">바벨의 TypeScript 지원을 사용하면 기존 빌드 파이프 라인으로 작업 할 수 있고 Babel이 코드를 입력하지 않기 때문에 JS 방출 시간이 더 빨라질 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="dc7e951244c6dc6091c5c81158c926700438ad75" translate="yes" xml:space="preserve">
          <source>C# and Java are what we might call &lt;em&gt;mandatory OOP&lt;/em&gt; languages. In these languages, the &lt;em&gt;class&lt;/em&gt; is the basic unit of code organization, and also the basic container of all data &lt;em&gt;and&lt;/em&gt; behavior at runtime. Forcing all functionality and data to be held in classes can be a good domain model for some problems, but not every domain &lt;em&gt;needs&lt;/em&gt; to be represented this way.</source>
          <target state="translated">C # 및 Java는 &lt;em&gt;필수 OOP&lt;/em&gt; 언어 라고 할 수 있습니다. 이러한 언어에서 &lt;em&gt;클래스&lt;/em&gt; 는 코드 구성의 기본 단위이며 런타임시 모든 데이터 &lt;em&gt;및&lt;/em&gt; 동작 의 기본 컨테이너이기도합니다 . 모든 기능과 데이터를 클래스에 저장하도록하는 것은 일부 문제에 대해 좋은 도메인 모델이 될 수 있지만 모든 도메인 이 이러한 방식으로 표현 될 &lt;em&gt;필요&lt;/em&gt; 는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes" xml:space="preserve">
          <source>Cache tagged template objects in modules</source>
          <target state="translated">태그가 지정된 템플릿 객체를 모듈에 캐시</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes" xml:space="preserve">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes" xml:space="preserve">
          <source>Callback Types</source>
          <target state="translated">콜백 유형</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="translated">호출 &lt;code&gt;showHello&lt;/code&gt; 는 호출 &lt;code&gt;sayHello&lt;/code&gt; 단락의 텍스트를 변경할 수 있습니다. 이제 gulpfile을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;define(...)&lt;/code&gt; 호출 (...)</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes" xml:space="preserve">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="translated">비 모듈 파일 &lt;code&gt;global-script.ts&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes" xml:space="preserve">
          <source>Case clause fall-throughs</source>
          <target state="translated">사례 조항 실패</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes" xml:space="preserve">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes" xml:space="preserve">
          <source>Caveats for Project References</source>
          <target state="translated">프로젝트 참조를위한주의 사항</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes" xml:space="preserve">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="translated">특정 대상에는 폴리 필 또는 BigInt와 유사한 런타임 객체가 포함될 수 있습니다. 이러한 목적으로 컴파일러 옵션 의 &lt;code&gt;lib&lt;/code&gt; 설정에 &lt;code&gt;esnext.bigint&lt;/code&gt; 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes" xml:space="preserve">
          <source>Changes include:</source>
          <target state="translated">변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9c51be50e36d425334b6ef56e24f1966fdfc5" translate="yes" xml:space="preserve">
          <source>Changes the function called in &lt;code&gt;.js&lt;/code&gt; files when compiling JSX Elements using the classic JSX runtime. The most common change is to use &lt;code&gt;&quot;h&quot;&lt;/code&gt; or &lt;code&gt;&quot;preact.h&quot;&lt;/code&gt; instead of the default &lt;code&gt;&quot;React.createElement&quot;&lt;/code&gt; if using &lt;code&gt;preact&lt;/code&gt;.</source>
          <target state="translated">클래식 JSX 런타임을 사용하여 JSX Elements를 컴파일 할 때 &lt;code&gt;.js&lt;/code&gt; 파일 에서 호출되는 함수를 변경합니다 . 가장 일반적인 변경은 &lt;code&gt;&quot;preact.h&quot;&lt;/code&gt; 사용하는 경우 기본 &lt;code&gt;&quot;React.createElement&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 또는 &quot;preact.h&quot; 를 사용하는 &lt;code&gt;preact&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types/React&lt;/code&gt; 변경</target>
        </trans-unit>
        <trans-unit id="de22ad0ca9b556e61bbb70c5ec83a398c3b619a4" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;module&lt;/code&gt; affects &lt;a href=&quot;#moduleResolution&quot;&gt;&lt;code&gt;moduleResolution&lt;/code&gt;&lt;/a&gt; which &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;also has a reference page&lt;/a&gt;.</source>
          <target state="translated">변경 &lt;code&gt;module&lt;/code&gt; 영향을 &lt;a href=&quot;#moduleResolution&quot;&gt; &lt;code&gt;moduleResolution&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;docs/handbook/module-resolution&quot;&gt; 또한 참조 페이지가 있습니다을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22dba2ca91863c573a72dfc7f990cbc67e554c68" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;target&lt;/code&gt; also changes the default value of &lt;a href=&quot;#lib&quot;&gt;&lt;code&gt;lib&lt;/code&gt;&lt;/a&gt;. You may &amp;ldquo;mix and match&amp;rdquo; &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; settings as desired, but you could just set &lt;code&gt;target&lt;/code&gt; for convenience.</source>
          <target state="translated">변경 &lt;code&gt;target&lt;/code&gt; 도의 기본값 변경 &lt;a href=&quot;#lib&quot;&gt; &lt;code&gt;lib&lt;/code&gt; 디렉토리&lt;/a&gt; . 원하는대로 &lt;code&gt;target&lt;/code&gt; 및 &lt;code&gt;lib&lt;/code&gt; 설정을 &quot;혼합 및 일치&quot; 할 수 있지만 편의를 위해 &lt;code&gt;target&lt;/code&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes" xml:space="preserve">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="translated">단지 변경 &lt;em&gt;내부를&lt;/em&gt; 구현 파일에 필요한 &lt;em&gt;유형 검사&lt;/em&gt; 이 이제까지 새로운 오류가 발생하지 않을지라도, 다시 테스트를</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes" xml:space="preserve">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="translated">변경 사항이 없어도 테스트를 변경하여 구현 유형을 다시 확인해야했습니다.</target>
        </trans-unit>
        <trans-unit id="1dc59cc2161e54b7687bb52a2c3f693c96a5e443" translate="yes" xml:space="preserve">
          <source>Charset - &lt;code&gt;charset&lt;/code&gt;</source>
          <target state="translated">문자셋- &lt;code&gt;charset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfd93b75e5598d54991c74a1d1b0a5f56438c081" translate="yes" xml:space="preserve">
          <source>Check JS - &lt;code&gt;checkJs&lt;/code&gt;</source>
          <target state="translated">JS 확인 &lt;code&gt;checkJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes" xml:space="preserve">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;define&lt;/code&gt; 과 같은 모듈 로더의 점검 또는 사용</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes" xml:space="preserve">
          <source>Children Type Checking</source>
          <target state="translated">어린이 유형 확인</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파일을&lt;/strong&gt; 선택하십시오&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="translated">&lt;strong&gt;새 프로젝트&lt;/strong&gt; 선택 (Ctrl + Shift + N)</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes" xml:space="preserve">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="translated">&quot;삽입&quot;또는 &quot;제거&quot;값을 선택하면 자동 가져 오기, 추출 된 유형 및 TypeScript 서비스에서 제공하는 기타 생성 된 코드의 형식에도 영향을줍니다. 설정을 기본값 인 &quot;무시&quot;로 유지하면 생성 된 코드가 현재 파일에서 감지 된 세미콜론 기본 설정과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes" xml:space="preserve">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="translated">구성 파일 간의 순환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes" xml:space="preserve">
          <source>Class Component</source>
          <target state="translated">클래스 구성 요소</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes" xml:space="preserve">
          <source>Class Decorators</source>
          <target state="translated">클래스 데코레이터</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes" xml:space="preserve">
          <source>Class Field Mitigations</source>
          <target state="translated">클래스 필드 완화</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">수업 종류</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">클래스 표현</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes" xml:space="preserve">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="translated">클래스 및 함수 선언은 기본 내보내기로 직접 작성할 수 있습니다. 기본 내보내기 클래스 및 함수 선언 이름은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes" xml:space="preserve">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="translated">클래스는 &lt;code&gt;.js&lt;/code&gt; 파일의 네임 스페이스입니다 . 예를 들어 클래스를 중첩하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="521ef0588bf6981159e4b30671900a891602e592" translate="yes" xml:space="preserve">
          <source>Classes can be declared as ES6 classes.</source>
          <target state="translated">클래스는 ES6 클래스로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes" xml:space="preserve">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="translated">클래스는 객체 리터럴 유형 및 인터페이스와 비슷하게 작동하지만 정적 유형과 인스턴스 유형이 있습니다. 클래스 유형의 두 객체를 비교할 때는 인스턴스 멤버 만 비교됩니다. 정적 멤버와 생성자는 호환성에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes" xml:space="preserve">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="translated">클래스, 함수 및 객체 리터럴은 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes" xml:space="preserve">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes" xml:space="preserve">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="translated">- &lt;code&gt;--watch&lt;/code&gt; 모드 에서 보다 깨끗한 출력</target>
        </trans-unit>
        <trans-unit id="94996b319b013869345bb5ec0b653754bbab2bb2" translate="yes" xml:space="preserve">
          <source>Co-learning JavaScript</source>
          <target state="translated">공동 학습 JavaScript</target>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes" xml:space="preserve">
          <source>Code Generation for Modules</source>
          <target state="translated">모듈을위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">코드 생성</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes" xml:space="preserve">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="translated">클래스 필드 변경에 영향을받는 코드는 필드 이니셜 라이저를 생성자 본문의 할당으로 변환하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes" xml:space="preserve">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="translated">VS 2015의 JSX 코드 채색</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes" xml:space="preserve">
          <source>Comma-separated list of strings</source>
          <target state="translated">쉼표로 구분 된 문자열 목록</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="translated">명령 줄</target>
        </trans-unit>
        <trans-unit id="d7a06fdc1de7c2a221587196452cc0c3db471910" translate="yes" xml:space="preserve">
          <source>Common CommonJS Patterns</source>
          <target state="translated">일반적인 CommonJS 패턴</target>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes" xml:space="preserve">
          <source>Common Questions</source>
          <target state="translated">일반적인 질문</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes" xml:space="preserve">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="translated">CommonJS / 노드 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes" xml:space="preserve">
          <source>CommonJS modules are supported</source>
          <target state="translated">CommonJS 모듈이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes" xml:space="preserve">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="translated">형식 형식의 CommonJS / Node.js 스타일 가져 오기 &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="721f3299d51791dbb75d2bfe7f0acc090e15e4e0" translate="yes" xml:space="preserve">
          <source>Comparing JavaScript to an example DTS</source>
          <target state="translated">JavaScript와 예제 DTS 비교</target>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes" xml:space="preserve">
          <source>Comparing two functions</source>
          <target state="translated">두 기능 비교</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes" xml:space="preserve">
          <source>Compile a project given a valid configuration file.</source>
          <target state="translated">유효한 구성 파일이 지정된 프로젝트를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes" xml:space="preserve">
          <source>Compiled with:</source>
          <target state="translated">로 컴파일 :</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes" xml:space="preserve">
          <source>Compiler Option</source>
          <target state="translated">컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
          <target state="translated">컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild</source>
          <target state="translated">MSBuild의 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : 매핑</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="83eca665c1a302a482766697ff41e3f51468ae7d" translate="yes" xml:space="preserve">
          <source>Compiler configuration reference.</source>
          <target state="translated">Compiler configuration reference.</target>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes" xml:space="preserve">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="translated">컴파일러 옵션은 MSBuild 프로젝트 내의 MSBuild 속성을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes" xml:space="preserve">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">명령 행에 지정된 컴파일러 옵션은 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일에 지정된 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="7c791e1a441b19fea45de958fa56f9b5653c4878" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using compiler flags in TypeScript 3.8+, and environment variables before that.</source>
          <target state="translated">컴파일러는 TypeScript 3.8+의 컴파일러 플래그와 그 이전의 환경 변수를 사용하여 파일 및 디렉토리를 감시하는 방법을 구성하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="translated">컴파일러는 환경 변수를 사용하여 파일 및 디렉토리를 감시하는 방법 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes" xml:space="preserve">
          <source>Compiles to exactly:</source>
          <target state="translated">정확히 컴파일</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="translated">&lt;code&gt;app.ts&lt;/code&gt; 사용하여 &lt;code&gt;--noResolve&lt;/code&gt; 컴파일 하면 다음 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes" xml:space="preserve">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="translated">출력을 컴파일하고 실행하면 ES3 / ES5 엔진에서 올바르게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc95d4c78f2f929f78993906b2bc165b4228618b" translate="yes" xml:space="preserve">
          <source>Compiling with &lt;code&gt;sourceMap&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; creates the following JavaScript file:</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 컴파일 하면 다음 JavaScript 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes" xml:space="preserve">
          <source>Compiling your code</source>
          <target state="translated">코드 컴파일</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
