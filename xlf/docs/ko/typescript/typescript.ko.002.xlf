<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="521f1850ff33993c5964d68a9803ec6e468bad0b" translate="yes" xml:space="preserve">
          <source>Composing Types</source>
          <target state="translated">유형 작성</target>
        </trans-unit>
        <trans-unit id="523183c97b725cfd5eba763765cb7911d0754153" translate="yes" xml:space="preserve">
          <source>Composite - &lt;code&gt;composite&lt;/code&gt;</source>
          <target state="translated">복합- &lt;code&gt;composite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">복합 프로젝트</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">계산 및 상수 멤버</target>
        </trans-unit>
        <trans-unit id="ca1724f8382a9edb4d244befe1a458fd2670cf7c" translate="yes" xml:space="preserve">
          <source>Computed from the list of input files</source>
          <target state="translated">입력 파일 목록에서 계산</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">계산 된 속성</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--outFile&lt;/code&gt; 을 사용 하여 &lt;code&gt;AMD&lt;/code&gt; 와 &lt;code&gt;System&lt;/code&gt; 모듈 연결</target>
        </trans-unit>
        <trans-unit id="60da387f3f2a8e412f962b386bbaf111b07be7fc" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">출력을 연결하고 단일 파일로 내 보냅니다. 연결 순서는 삼중 슬래시 참조 및 가져 오기와 함께 명령 줄에서 컴파일러에 전달 된 파일 목록에 의해 결정됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out&quot;&gt;출력 파일 주문 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">하나의 파일로 연결하여 출력합니다. 연결 순서는 트리플 슬래시 참조 및 가져 오기와 함께 명령 행에서 컴파일러에 전달 된 파일 목록에 의해 결정됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;출력 파일 순서 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00c20ea179f46b34657af7c3ca762e28ca33f1eb" translate="yes" xml:space="preserve">
          <source>Concepts not in Haskell</source>
          <target state="translated">Haskell에없는 개념</target>
        </trans-unit>
        <trans-unit id="9e542d345cbe531aa5f8452be22d9352fd6b119c" translate="yes" xml:space="preserve">
          <source>Concepts similar to Haskell</source>
          <target state="translated">Haskell과 유사한 개념</target>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">개념적으로, &lt;code&gt;[number, string]&lt;/code&gt; 유형 이 다음 &lt;code&gt;NumStrTuple&lt;/code&gt; 선언과 동등한 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">조건부 유형</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">조건부 유형은 매핑 된 유형과 결합 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">조건부 유형은 순서대로 평가되는 일련의 패턴 일치를 형성하기 위해 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">확인 된 유형이 기본 유형 매개 변수 인 &lt;em&gt;조건부 유형을 분배 조건부 유형&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 분배 조건부 유형은 인스턴스화 중에 유니온 유형에 자동으로 분배됩니다. 예를 들어, &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 의 인스턴스화는 U? 유형 인수가 &lt;code&gt;A | B | C&lt;/code&gt; X : Y | B | &lt;code&gt;T&lt;/code&gt; 에 대한 C 는 &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">구성 상속</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 구성 상속</target>
        </trans-unit>
        <trans-unit id="1901418fbdfe5d2c8f43a50daa474bda691aa7e5" translate="yes" xml:space="preserve">
          <source>Configuring JSX</source>
          <target state="translated">JSX 구성</target>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">시계 구성</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">시계 구성 : 배경</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 를 사용하여 디렉토리 감시 구성</target>
        </trans-unit>
        <trans-unit id="154dfa8a6af04f2d727ad938b2a0b29854531465" translate="yes" xml:space="preserve">
          <source>Configuring file watching using a &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하여 파일 감시 구성</target>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_WATCHFILE&lt;/code&gt; 을 사용하여 파일 감시 구성</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">혼란스럽게도 여기서 콜론 은 유형을 나타내지 &lt;em&gt;않습니다&lt;/em&gt; . 유형을 지정하는 경우 전체 파괴 후에도 유형을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">TypeScript 프런트 엔드를 사용하여 자체 .NET Core 프로젝트를 빌드 한 것을 축하합니다.</target>
        </trans-unit>
        <trans-unit id="9e5193ad94fca6c20c365f83052b979e6e703a9c" translate="yes" xml:space="preserve">
          <source>Congratulations on choosing TypeScript as one of your first languages &amp;mdash; you&amp;rsquo;re already making good decisions!</source>
          <target state="translated">TypeScript를 첫 번째 언어 중 하나로 선택한 것을 축하합니다. 이미 좋은 결정을 내리고 있습니다!</target>
        </trans-unit>
        <trans-unit id="155316928dc20330bb4f13299267e694e6babaed" translate="yes" xml:space="preserve">
          <source>Consequences of Structural Typing</source>
          <target state="translated">구조적 타이핑의 결과</target>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">새로운 생성하는 기능 고려 &lt;code&gt;HTMLElement&lt;/code&gt; 인수로 호출하는 것은 생성 &lt;code&gt;Div&lt;/code&gt; ; 선택적으로 하위 목록도 전달할 수 있습니다. 이전에는 다음과 같이 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">&lt;code&gt;Calculator.ts&lt;/code&gt; 모듈에 정의 된 간단한 계산기 구현을 고려하십시오 . 이 모듈은 또한 입력 문자열 목록을 전달하고 끝에 결과를 작성하여 계산기 기능을 테스트하기 위해 도우미 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">빌드 도구 가 &lt;code&gt;./#{locale}/messages&lt;/code&gt; 와 같은 상대 모듈 경로의 일부로 특수 경로 토큰 (예 : &lt;code&gt;#{locale}&lt;/code&gt; ) 을 보간하여 로케일 특정 번들을 자동으로 생성하는 국제화 시나리오를 고려하십시오 . 이 가상 설정에서이 도구는 지원되는 로캘을 열거하고 추상화 된 경로를 &lt;code&gt;./zh/messages&lt;/code&gt; , &lt;code&gt;./de/messages&lt;/code&gt; 등에 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Animal&lt;/code&gt; 이 &lt;code&gt;Dog&lt;/code&gt; 및 &lt;code&gt;Cat&lt;/code&gt; 의 상위 유형 인 다음 예를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Const 열거 형은 상수 열거 형 식만 사용할 수 있으며 일반 열거 형과 달리 컴파일 중에 완전히 제거됩니다. Const enum 멤버는 사용 사이트에 인라인되어 있습니다. const 열거 형에 계산 멤버를 가질 수 없기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">상수 속성</target>
        </trans-unit>
        <trans-unit id="49d53b0e2ba12586322d0eec2518e118c2445b29" translate="yes" xml:space="preserve">
          <source>Constrained Mixins</source>
          <target state="translated">제한된 믹스 인</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">생성자 함수</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">생성자 함수는 클래스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ca826ddb7dbf23aebcf75ed24ec5bc07d856c905" translate="yes" xml:space="preserve">
          <source>Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;Type&lt;/code&gt; is not a function).</source>
          <target state="translated">생성자 함수 유형의 유형에서 튜플 또는 배열 유형을 생성합니다. 그것은 모든 매개 변수 유형 (또는 유형 튜플 타입 생산 &lt;code&gt;never&lt;/code&gt; 경우 &lt;code&gt;Type&lt;/code&gt; 함수되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9d4b322cc323263a5f94064b1dd22d65f4128610" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type from the types used in the parameters of a function type &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">함수 유형 &lt;code&gt;Type&lt;/code&gt; 의 매개 변수에 사용 된 유형에서 튜플 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">함수 유형 &lt;code&gt;T&lt;/code&gt; 의 매개 변수 유형의 튜플 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제외하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="d5b40d6ba8fbb32a11e5ef0ea59f2a6613cdd70b" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제외하여 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">에서 제외하여 유형 구축 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 모든 속성 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8caddbb3ddee9f5ae43f3e24c9baf74c9d40a4b9" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;ExcludedUnion&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExcludedUnion&lt;/code&gt; 에 할당 할 수있는 모든 공용체 멤버를 &lt;code&gt;Type&lt;/code&gt; 에서 제외하여 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로 할당 가능한 모든 속성을 추출하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b8b9d1c1c29172750935e9c25ec87d393c9cbc4e" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;Type&lt;/code&gt; all union members that are assignable to &lt;code&gt;Union&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Union&lt;/code&gt; 에 할당 할 수있는 모든 공용체 멤버를 &lt;code&gt;Type&lt;/code&gt; 에서 추출하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 모든 속성을 선택한 다음 &lt;code&gt;K&lt;/code&gt; 를 제거 하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="09cc5c4b6a37c1bdbee9dd0d7660c6620a24b5a9" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;Type&lt;/code&gt; and then removing &lt;code&gt;Keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 에서 모든 속성을 선택한 다음 &lt;code&gt;Keys&lt;/code&gt; 를 제거하여 유형을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">속성 집합 &lt;code&gt;K&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 선택하여 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="68c0c0b3c69f4491f5b7e112f6aa41891acb587a" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;Keys&lt;/code&gt; from &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 에서 속성 &lt;code&gt;Keys&lt;/code&gt; 세트를 선택하여 유형을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 필수로 설정된 유형으로 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="932e1b16b3a2393ed1e71294aedc0172a3c58d7f" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required. The opposite of &lt;a href=&quot;#partialtype&quot;&gt;&lt;code&gt;Partial&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필수로 설정된 &lt;code&gt;T&lt;/code&gt; 의 모든 속성으로 구성된 유형을 구성 합니다. &lt;a href=&quot;#partialtype&quot;&gt; &lt;code&gt;Partial&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1f68e6fde23a08ff88d024111ed166b6b258e4fd" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function in &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 에서 생성자 함수의 인스턴스 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">생성자 함수 유형 &lt;code&gt;T&lt;/code&gt; 의 인스턴스 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;T&lt;/code&gt; 의 반환 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="6248af074741172f00aa42821fdc5ca624e3bfe0" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;Type&lt;/code&gt; 의 반환 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 특성 &lt;code&gt;K&lt;/code&gt; 세트로 유형을 구성합니다 . 이 유틸리티를 사용하여 유형의 속성을 다른 유형에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="302b3ef8a60040355be3458fc77a6c0e18ea642f" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;Keys&lt;/code&gt; of type &lt;code&gt;Type&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">속성의 집합 형태를 구축 &lt;code&gt;Keys&lt;/code&gt; 타입의 &lt;code&gt;Type&lt;/code&gt; . 이 유틸리티는 유형의 속성을 다른 유형에 매핑하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 &lt;code&gt;readonly&lt;/code&gt; 로 설정된 유형을 생성합니다 . 즉, 생성 된 유형의 속성을 재 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 선택 사항으로 설정된 유형을 구성합니다 . 이 유틸리티는 주어진 유형의 모든 하위 집합을 나타내는 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f31c4d16e9ff4bfb1cded19332727ccef1b3be41" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 의 모든 속성이 &lt;code&gt;readonly&lt;/code&gt; 로 설정된 형식 을 생성합니다. 즉, 생성 된 형식의 속성을 다시 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6f4cbe62efb06cc53e3a14039a9db23ac8c8cda" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;Type&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; 의 모든 속성이 선택 사항으로 설정된 유형을 구성합니다 . 이 유틸리티는 주어진 유형의 모든 하위 집합을 나타내는 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">수출하는 물건을 사용할 때 모듈 소비자는 가능한 한 마찰이 적어야합니다. 너무 많은 중첩 수준을 추가하면 성가신 경향이 있으므로 구조를 어떻게 구성하고 싶은지 신중하게 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">소비 종속성</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">소비 : 소비</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">소비 : 다운로드</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">소비 : 검색</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">상황 별 타이핑</target>
        </trans-unit>
        <trans-unit id="603feab4fc9b8d65cd86c21a0640771b620b3af7" translate="yes" xml:space="preserve">
          <source>Contextual typing</source>
          <target state="translated">문맥 입력</target>
        </trans-unit>
        <trans-unit id="5ffb5489166008419359898740eeed46cbeb1671" translate="yes" xml:space="preserve">
          <source>Contextual typing also works recursively through object literals, and on unit types that would otherwise be inferred as &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;. And it can infer return types from context:</source>
          <target state="translated">문맥 입력은 객체 리터럴을 통해 재귀 적으로 작동하며 그렇지 않으면 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;number&lt;/code&gt; 로 추론되는 단위 유형에서도 작동합니다 . 그리고 컨텍스트에서 반환 유형을 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">상황 별 타이핑은 많은 경우에 적용됩니다. 일반적인 경우에는 함수 호출에 대한 인수, 할당의 오른쪽, 형식 어설 션, 개체 및 배열 리터럴, return 문이 있습니다. 문맥 유형은 또한 가장 일반적인 유형의 후보 유형으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">제어 흐름 분석 오류</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">제어 흐름 기반 유형 분석</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">제어 가능한 흐름 기반 유형 분석은 nullable 유형이 공용체 유형을 사용하여 표시되므로 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드 에서 특히 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac60e4fabc9d2458046e40ecaa2efebb0c647716" translate="yes" xml:space="preserve">
          <source>Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">JSX 구조가 JavaScript 파일에서 내보내지는 방식을 제어합니다. 이는 &lt;code&gt;.tsx&lt;/code&gt; 파일 에서 시작된 JS 파일의 출력에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="372e1a5c72020e79bfc4592c655c28b0c15b1125" translate="yes" xml:space="preserve">
          <source>Controls whether TypeScript will emit a &lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;byte order mark (BOM)&lt;/a&gt; when writing output files. Some runtime environments require a BOM to correctly interpret a JavaScript files; others require that it is not present. The default value of &lt;code&gt;false&lt;/code&gt; is generally best unless you have a reason to change it.</source>
          <target state="translated">TypeScript가 출력 파일을 쓸 때 &lt;a href=&quot;https://wikipedia.org/wiki/Byte_order_mark&quot;&gt;바이트 순서 표시 (BOM)를&lt;/a&gt; 내보낼 지 여부를 제어합니다 . 일부 런타임 환경에서는 JavaScript 파일을 올바르게 해석하기 위해 BOM이 필요합니다. 다른 사람들은 그것이 존재하지 않을 것을 요구합니다. 기본값 인 &lt;code&gt;false&lt;/code&gt; 는 변경할 이유가없는 한 일반적으로 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">반대로 가져올 때 :</target>
        </trans-unit>
        <trans-unit id="f31b6614a525392ec0858195de4c10be17398d28" translate="yes" xml:space="preserve">
          <source>Converts to this JavaScript:</source>
          <target state="translated">이 JavaScript로 변환 :</target>
        </trans-unit>
        <trans-unit id="d9701bf4f89400101efb5b5908d4ea6d132c91f0" translate="yes" xml:space="preserve">
          <source>Core definitions for all ES3 and ES5 functionality</source>
          <target state="translated">모든 ES3 및 ES5 기능에 대한 핵심 정의</target>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">명령 행에 &lt;code&gt;moduleA&lt;/code&gt; 가 전달 될 때 올바르게 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="ae18f0902f48e8ccca9ad33f1e24aa69738ce04c" translate="yes" xml:space="preserve">
          <source>Correctly predict type system behavior in most cases</source>
          <target state="translated">대부분의 경우 유형 시스템 동작을 올바르게 예측</target>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">&lt;code&gt;@types/React&lt;/code&gt; 의 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스에 &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; 정의 를 추가하기위한 해당 변경 이 여전히 필요합니다. 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba6a73c0093201ece582d1fb4d7bbc3d859ef7a" translate="yes" xml:space="preserve">
          <source>Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:</source>
          <target state="translated">이러한 모든 경우를 처리하려면 실제로 이러한 모든 패턴을 지원하는 JavaScript 코드가 필요합니다. 이러한 많은 패턴을 지원하려면 CommonJS 모듈은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; 만들기</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">프로젝트 디렉토리의 루트에 &lt;code&gt;webpack.config.js&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/greet.ts&lt;/code&gt; 라는 파일을 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;index.html&lt;/code&gt; 이라는 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="72c972c59f1f27b703d41ea9aa9823f618a2d30a" translate="yes" xml:space="preserve">
          <source>Create a new file in the root of your source tree: &lt;code&gt;[libname].d.ts&lt;/code&gt;</source>
          <target state="translated">소스 트리의 루트에 새 파일을 만듭니다. &lt;code&gt;[libname].d.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d670257b5f8858306ee09e6f9274710bd7a4022" translate="yes" xml:space="preserve">
          <source>Create a new folder in &lt;code&gt;node_modules/@types/[libname]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;node_modules/@types/[libname]&lt;/code&gt; 새 폴더를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">새로운 프로젝트 만들기</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">페이지 만들기</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">웹팩 구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="78a14b786be544c7e444994e89b63a1bab9e7ec1" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;index.d.ts&lt;/code&gt; in that folder, and copy the example in</source>
          <target state="translated">만들기 &lt;code&gt;index.d.ts&lt;/code&gt; 해당 폴더를하고있는 예제를 복사</target>
        </trans-unit>
        <trans-unit id="a80520c836bad8ac980c6af04074db460cf2a83d" translate="yes" xml:space="preserve">
          <source>Creating .d.ts Files from .js files</source>
          <target state="translated">Creating .d.ts Files from .js files</target>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">ES3에는 &lt;code&gt;Object.defineProperty&lt;/code&gt; 가 존재하지 않기 때문에 현재 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 는 ES5 이상을 대상으로 할 때만 사용할 수 있습니다 . 비슷한 문제 검사를 수행하기 위해 ES5를 대상으로하고 &lt;code&gt;--noEmit&lt;/code&gt; 을 사용 하여 전체 빌드를 피하는 별도의 프로젝트를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96526436a6307d6465c867047c87cca576ddfe01" translate="yes" xml:space="preserve">
          <source>Currently, the only top-level property that is excluded from inheritance is &lt;a href=&quot;#references&quot;&gt;&lt;code&gt;references&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 상속에서 제외되는 유일한 최상위 속성은 &lt;a href=&quot;#references&quot;&gt; &lt;code&gt;references&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">사용하여 사용자 정의 JSX 공장 &lt;code&gt;--reactNamespace&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts (간단한 발췌)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--jsxFactory&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--outFile&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--skipLibCheck&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">DOM 변경</target>
        </trans-unit>
        <trans-unit id="97bc0d0faf1db6773f46f77993cbfab01aef6415" translate="yes" xml:space="preserve">
          <source>DOM Manipulation</source>
          <target state="translated">DOM 조작</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="d4a6e25daaa79e164346a5df8f97d22e51c38251" translate="yes" xml:space="preserve">
          <source>Declaration - &lt;code&gt;declaration&lt;/code&gt;</source>
          <target state="translated">선언- &lt;code&gt;declaration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83a6e664769b464317ab5bac295d9c6ac3c0507f" translate="yes" xml:space="preserve">
          <source>Declaration Dir - &lt;code&gt;declarationDir&lt;/code&gt;</source>
          <target state="translated">선언 Dir- &lt;code&gt;declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad92a8160441d1375fed7cf194406ee120a09e46" translate="yes" xml:space="preserve">
          <source>Declaration File Theory: A Deep Dive</source>
          <target state="translated">선언 파일 이론 : 심층 분석</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">선언 파일</target>
        </trans-unit>
        <trans-unit id="b50be50c5afb7e54332d8b1bf30d309b0eae0711" translate="yes" xml:space="preserve">
          <source>Declaration Map - &lt;code&gt;declarationMap&lt;/code&gt;</source>
          <target state="translated">선언 맵 &lt;code&gt;declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">선언 병합</target>
        </trans-unit>
        <trans-unit id="851f4d7f22e2bf61aa3d231bae99e9eaaf320d8e" translate="yes" xml:space="preserve">
          <source>Declaration Reference</source>
          <target state="translated">Declaration Reference</target>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">선언 유형</target>
        </trans-unit>
        <trans-unit id="2411670cd38002dcd5a4989aaf25d65b85643783" translate="yes" xml:space="preserve">
          <source>Declaration initialisers are contextually typed by the declaration&amp;rsquo;s type: &lt;code&gt;{ inference: string }&lt;/code&gt;.</source>
          <target state="translated">선언 이니셜 라이저는 선언 유형 : &lt;code&gt;{ inference: string }&lt;/code&gt; 으로 문맥에 따라 유형이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">이니셜 라이저 가없는 경우에도 선언은 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; 로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">선언은 &lt;code&gt;Object.defineProperty&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import * as a from 'b';&lt;/code&gt; 같은 선언 ; 또는 &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">속성이 실제로 존재하면 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="378818e31f6df21ace4ff334a5f33be4e8cb393e" translate="yes" xml:space="preserve">
          <source>Declares the module specifier to be used for importing the &lt;code&gt;jsx&lt;/code&gt; and &lt;code&gt;jsxs&lt;/code&gt; factory functions when using &lt;a href=&quot;#jsx&quot;&gt;&lt;code&gt;jsx&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; which were introduced in TypeScript 4.1.</source>
          <target state="translated">모듈 지정자 수입 사용될 선언한다 &lt;code&gt;jsx&lt;/code&gt; 및 &lt;code&gt;jsxs&lt;/code&gt; 사용시 공장 기능 &lt;a href=&quot;#jsx&quot;&gt; &lt;code&gt;jsx&lt;/code&gt; 을&lt;/a&gt; 같이 &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt; 타이프 4.1에 도입 하였다.</target>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">JavaScript에서 변수 선언은 항상 전통적으로 &lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 수행되었습니다 .</target>
        </trans-unit>
        <trans-unit id="76e978b48c2e7ee378c2b0140f7507fecee38d99" translate="yes" xml:space="preserve">
          <source>Declaring generic classes or types is unsupported.</source>
          <target state="translated">제네릭 클래스 또는 유형 선언은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">형의 변수 선언 &lt;code&gt;void&lt;/code&gt; 만 할당 할 수 있기 때문에 유용하지 않다 &lt;code&gt;null&lt;/code&gt; (경우에만 &lt;code&gt;--strictNullChecks&lt;/code&gt; 가 지정되지 않은, 다음 섹션 참조) 또는 &lt;code&gt;undefined&lt;/code&gt; 그들에게 :</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">데코레이터 구성</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">데코레이터 평가</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">데코레이터 공장</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">데코레이터 &lt;code&gt;readonly&lt;/code&gt; 및 &lt;code&gt;enumerable(false)&lt;/code&gt; 은 클래스 &lt;code&gt;C&lt;/code&gt; 에 설치되기 전에 속성 &lt;code&gt;method&lt;/code&gt; 적용됩니다 . 이를 통해 데코레이터는 구현을 변경할 수 있으며,이 경우 디스크립터를 쓰기 가능 (false 및 enumerable : false)으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9956dce12bd8a076975367fb2d5e9353aca43d48" translate="yes" xml:space="preserve">
          <source>Decorators and Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt;&lt;code&gt;#4881&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">데코레이터와 믹스 인 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/4881&quot;&gt; &lt;code&gt;#4881&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6522aedcbf21b215104c1f4c00a269d73f7737d0" translate="yes" xml:space="preserve">
          <source>Decorators are a language feature which hasn&amp;rsquo;t yet been fully ratified into the JavaScript specification. This means that the implementation version in TypeScript may differ from the implementation in JavaScript when it it decided by TC39.</source>
          <target state="translated">데코레이터는 아직 JavaScript 사양으로 완전히 승인되지 않은 언어 기능입니다. 이것은 TypeScript의 구현 버전이 TC39에 의해 결정되었을 때 JavaScript의 구현과 다를 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">ES3를 타겟팅 할 때 데코레이터가 허용됩니다. 타이프 라이터 1.7 제거합니다의 ES5 특정 사용 &lt;code&gt;reduceRight&lt;/code&gt; 로부터 &lt;code&gt;__decorate&lt;/code&gt; 도우미. 또한 인라인 변경은 이전 버전과 호환되는 방식으로 &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 및 &lt;code&gt;Object.defineProperty&lt;/code&gt; 를 인라인 호출 하여 나중에 언급 된 &lt;code&gt;Object&lt;/code&gt; 메소드 에 대한 다양한 반복 호출을 제거하여 ES5에 대한 이미 터를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">중복 제거 및 리디렉션 된 패키지</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">심해 잠수</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">딥 다이브 : 고급 조합</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">딥 다이브 : 정의 파일 이론 : 딥 다이브</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">딥 다이브 : export = 또는 import와 함께 사용</target>
        </trans-unit>
        <trans-unit id="7924171a48438d5b2e1b6937ed62b292cb09fd2a" translate="yes" xml:space="preserve">
          <source>Deep dive reference materials.</source>
          <target state="translated">Deep dive reference materials.</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">기본 내보내기</target>
        </trans-unit>
        <trans-unit id="af087002f31d0ea4e967c16e89ad0e158cdeb097" translate="yes" xml:space="preserve">
          <source>Default Exports</source>
          <target state="translated">기본 내보내기</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">기본 수출</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">기본 내보내기는 또한 이름 지정된 내보내기 만 기능 보강 할 수 없습니다 (내 보낸 이름으로 내보내기 기능을 보강해야하고 &lt;code&gt;default&lt;/code&gt; 은 예약어이므로 세부 사항 은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;# 14080&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">CommonJS / AMD / UMD 로의 기본 가져 오기가 이제 허용되며 (예 : &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ) 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">유형 매개 변수의 기본 유형은 유형 매개 변수 (있는 경우)의 제한 조건을 충족시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">기본값을 사용하면 속성이 정의되지 않은 경우 기본값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">모든 필수 매개 변수 뒤에 오는 기본 초기화 매개 변수는 선택적으로 처리되며 선택적 매개 변수와 마찬가지로 해당 함수를 호출 할 때 생략 할 수 있습니다. 이는 선택적 매개 변수와 후행 기본 매개 변수가 해당 유형에서 공통성을 공유하므로 둘 다</target>
        </trans-unit>
        <trans-unit id="317bbd656753a9dd8ea52dce97e89a2822b25653" translate="yes" xml:space="preserve">
          <source>Default:</source>
          <target state="translated">Default:</target>
        </trans-unit>
        <trans-unit id="74041b7807a7d4e7910b8959338951cb903fa127" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;&quot;react&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;react&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">기본 선언</target>
        </trans-unit>
        <trans-unit id="990fdad3673f0e5fcfe37a06c68fc3e568969839" translate="yes" xml:space="preserve">
          <source>Defining Types</source>
          <target state="translated">유형 정의</target>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">명확한 할당 어설 션</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">정의 파일 이론 : 심층 분석</target>
        </trans-unit>
        <trans-unit id="3760ef166e35af012373e12d01c8cf9b2e33236e" translate="yes" xml:space="preserve">
          <source>Deno</source>
          <target state="translated">Deno</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">글로벌 라이브러리에 대한 의존성</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">모듈에 대한 의존성</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">UMD 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="918fe5bb958d61b9b61fe33be50330ae07bd5a2b" translate="yes" xml:space="preserve">
          <source>Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at &lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com/tsconfig/bases&lt;/a&gt;. These are &lt;code&gt;tsconfig.json&lt;/code&gt; files which your project extends from which simplifies your &lt;code&gt;tsconfig.json&lt;/code&gt; by handling the runtime support.</source>
          <target state="translated">코드를 실행하려는 JavaScript 런타임 환경에 따라 &lt;a href=&quot;https://github.com/tsconfig/bases/&quot;&gt;github.com/tsconfig/bases&lt;/a&gt; 에서 사용할 수있는 기본 구성이있을 수 있습니다 . 이들은 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 프로젝트가 간소화되는 확장 파일 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 런타임 지원을 처리하여.</target>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">컴파일 중에 지정된 모듈 대상에 따라 컴파일러는 Node.js ( &lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; ), require.js ( &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt; ), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; , &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; 또는 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 기본 모듈&lt;/a&gt; (ES6) 모듈 로딩 시스템에 적합한 코드를 생성 합니다. 생성 된 코드에서 &lt;code&gt;define&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;register&lt;/code&gt; 호출이 수행하는 작업 에 대한 자세한 정보 는 각 모듈 로더의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">모양에도 불구하고 &lt;code&gt;readonly&lt;/code&gt; 유형 수정자는 배열 유형 및 튜플 유형의 구문에만 사용할 수 있습니다. 범용 타입 연산자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">파괴는 함수 선언에서도 작동합니다. 간단한 경우에는이 방법이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">배열 선언은 배열에서 값을 추출하는데도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">선언과 과제의 파괴</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">파괴적인 패턴은 정규 할당 표현식에서도 사용될 수 있습니다. 예를 들어, 두 변수를 바꾸는 것은 단일 파괴 할당으로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">파괴는 이미 선언 된 변수와도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">그들이 최신인지 감지</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">모듈이 어떻게 해결되는지 결정하십시오. 어느 쪽의 &lt;code&gt;&quot;Node&quot;&lt;/code&gt; Node.js를위한은 / 스타일 해상도, 또는 io.js &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; . 보다&lt;a href=&quot;module-resolution&quot;&gt;모듈 확인 설명서를&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c1b1483372c227a508b8463543c7a9308b81a78" translate="yes" xml:space="preserve">
          <source>Diagnostics - &lt;code&gt;diagnostics&lt;/code&gt;</source>
          <target state="translated">진단- &lt;code&gt;diagnostics&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea5a55f6f2e4530ea94d346bb5232949c83852a7" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;childNodes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; 과 자식 &lt;code&gt;childNodes&lt;/code&gt; 차이점</target>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">클래스의 정적 측면과 인스턴스 측면의 차이점</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">언어에 따라 상황에 따라 두 가지 호환성 메커니즘 중 하나가 사용됩니다. 실제적인 목적으로, 유형 호환성은 &lt;code&gt;implements&lt;/code&gt; 및 &lt;code&gt;extends&lt;/code&gt; 의 경우에도 할당 호환성에 의해 결정됩니다 절의 .</target>
        </trans-unit>
        <trans-unit id="95bcb1c49cad60f2d25122fcd19b63040c889429" translate="yes" xml:space="preserve">
          <source>Disable Size Limit - &lt;code&gt;disableSizeLimit&lt;/code&gt;</source>
          <target state="translated">크기 제한 비활성화 &lt;code&gt;disableSizeLimit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a32974e72060c10cc1f472534786de4686092d" translate="yes" xml:space="preserve">
          <source>Disable Solution Searching - &lt;code&gt;disableSolutionSearching&lt;/code&gt;</source>
          <target state="translated">솔루션 검색 비활성화 &lt;code&gt;disableSolutionSearching&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66c23df2605c409c3157537bdcacc045f0801eb0" translate="yes" xml:space="preserve">
          <source>Disable Source Project Reference Redirect - &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</source>
          <target state="translated">소스 프로젝트 참조 리디렉션 비활성화 &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">함수 유형에 대한 이변 량 파라미터 검사를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">JavaScript 프로젝트에서 크기 제한을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">함수 유형에서 일반 서명의 엄격한 검사를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e5a053c8b9e96a66ffa4c28b3bd57ff2472f950d" translate="yes" xml:space="preserve">
          <source>Disables the automatic inclusion of any library files. If this option is set, &lt;code&gt;lib&lt;/code&gt; is ignored.</source>
          <target state="translated">라이브러리 파일의 자동 포함을 비활성화합니다. 이 옵션을 설정하면 &lt;code&gt;lib&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">동일한 파일에 대해 일관되지 않은 참조를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">허용되지 않는 병합</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">차별적 노동 조합</target>
        </trans-unit>
        <trans-unit id="4f995145bd06a1e9b5d7514449a82f5503e6e06f" translate="yes" xml:space="preserve">
          <source>Discriminating Unions</source>
          <target state="translated">차별적 노조</target>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">분배 조건부 유형</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">마 &lt;em&gt;되지&lt;/em&gt; 용도 &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; UMD 라이브러리에 종속성을 선언하는 지침을!</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">트리플 슬래시 참조 또는 모듈 가져 오기 대상을 컴파일 된 파일 목록에 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">모듈 출력에서 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 지시문을 방출하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1ce6e36e455f554889b5d6bc9e169d6efc81747f" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations if any errors were reported.</source>
          <target state="translated">오류가보고 된 경우 JavaScript 소스 코드, 소스 맵 또는 선언과 같은 컴파일러 출력 파일을 내 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0eae0aff266e745600e62273aeb329a274d44532" translate="yes" xml:space="preserve">
          <source>Do not emit compiler output files like JavaScript source code, source-maps or declarations.</source>
          <target state="translated">JavaScript 소스 코드, 소스 맵 또는 선언과 같은 컴파일러 출력 파일을 내 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3eb6ba65f5d19029d630e79f609d97ba6b1be452" translate="yes" xml:space="preserve">
          <source>Do not emit declarations for code that has an &lt;code&gt;@internal&lt;/code&gt; annotation in it&amp;rsquo;s JSDoc comment. This is an internal compiler option; use at your own risk, because the compiler does not check that the result is valid. If you are searching for a tool to handle additional levels of visibility within your &lt;code&gt;d.ts&lt;/code&gt; files, look at &lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractor&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@internal&lt;/code&gt; 주석에 @internal 주석 이있는 코드에 대한 선언을 내 보내지 마십시오 . 이것은 내부 컴파일러 옵션입니다. 컴파일러가 결과가 유효한지 확인하지 않기 때문에 사용자의 책임하에 사용하십시오. &lt;code&gt;d.ts&lt;/code&gt; 파일 내에서 추가 수준의 가시성을 처리하는 도구를 찾고 있다면 &lt;a href=&quot;https://api-extractor.com&quot;&gt;api-extractor를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">오류가보고 된 경우 출력을 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">출력을 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="75e54c4e6371e16cfe8d5e2477971052228922b4" translate="yes" xml:space="preserve">
          <source>Do not erase &lt;code&gt;const enum&lt;/code&gt; declarations in generated code. &lt;code&gt;const enum&lt;/code&gt;s provide a way to reduce the overall memory footprint of your application at runtime by emitting the enum value instead of a reference.</source>
          <target state="translated">생성 된 코드에서 &lt;code&gt;const enum&lt;/code&gt; 선언을 지우지 마십시오 . &lt;code&gt;const enum&lt;/code&gt; 은 참조 대신 열거 형 값을 내보내 런타임에 애플리케이션의 전체 메모리 사용량을 줄이는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="110fa485165295f6412f7a19e4cf78d89958e5a1" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;enums#const-enums&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">생성 된 코드에서 const enum 선언을 지우지 마십시오. 자세한 내용은 &lt;a href=&quot;enums#const-enums&quot;&gt;const 열거 형 문서&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">생성 된 코드에서 const 열거 선언을 지우지 마십시오. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">컴파일 된 출력에서 &lt;code&gt;__extends&lt;/code&gt; 와 같은 사용자 정의 도우미 함수를 생성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">기본 라이브러리 파일 ( &lt;code&gt;lib.d.ts&lt;/code&gt; )을 포함하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">도달 할 수없는 코드에 대한 오류를보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">사용하지 않은 라벨에 오류를보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">심볼릭 링크를 실제 경로로 해결하지 마십시오. 심볼릭 링크 된 파일을 실제 파일처럼 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">오류 메시지를 자르지 마십시오.</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">모듈에서 네임 스페이스를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="4bcbf5a1fc2c5b15cdcbd417c596ae653a2554d0" translate="yes" xml:space="preserve">
          <source>Do you need a build pipeline with multiple potential outputs? Use &lt;code&gt;babel&lt;/code&gt; for transpiling and &lt;code&gt;tsc&lt;/code&gt; for type checking</source>
          <target state="translated">여러 잠재적 출력이있는 빌드 파이프 라인이 필요합니까? 트랜스 파일 에는 &lt;code&gt;babel&lt;/code&gt; 을 사용 하고 유형 검사에는 &lt;code&gt;tsc&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">하지 말아야 할 것</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : Generics</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 콜백의 선택적 파라미터</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">하지 말아야 할 것 : 주문</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 과부하와 콜백</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 반환 유형의 콜백</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 선택적 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 유니온 타입 사용</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">해야 할 것과하지 말아야 할 것</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">라이브러리 를 &lt;code&gt;require&lt;/code&gt; 하거나 가져 오는 방법을 설명하는 문서</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">UMD 라이브러리에 대한 설명서는 종종 &lt;code&gt;require&lt;/code&gt; 를 보여주는&amp;ldquo;Node.js에서 사용&amp;rdquo;예제 와 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 를로드하기 위해 &amp;lt;script&amp;gt; 태그를 사용하는&amp;ldquo;브라우저에서 사용&amp;rdquo;예제를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a885ffddfd2d0e82b05e37f87bbdf798e4f9f6d4" translate="yes" xml:space="preserve">
          <source>Does it add a global object? Does it use &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt; statements?</source>
          <target state="translated">전역 개체를 추가합니까? 그것은 사용 하는가 &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; 문을?</target>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">단계 수에 겁 먹지 마십시오-TypeScript는 여전히 단계 (9)와 (17)에서 디렉토리를 두 ​​번만 뛰어 넘습니다. 이것은 Node.js 자체가하는 것보다 더 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">명령 행에서 전달한 파일의 순서에 대해 걱정하지 마십시오. &lt;code&gt;tsc&lt;/code&gt; 는 필요할 경우 파일 순서를 변경하여 종속성이 항상 먼저 작성되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">타입 가드의 점선 이름</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">문자열 인덱스 서명이있는 유형의 점선 속성</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">하위 비동기 기능</target>
        </trans-unit>
        <trans-unit id="183506505f400de899633b4af1eabf4c89a43b4a" translate="yes" xml:space="preserve">
          <source>Downlevel Iteration - &lt;code&gt;downlevelIteration&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;downlevelIteration&lt;/code&gt; 레벨 반복 -downlevelIteration</target>
        </trans-unit>
        <trans-unit id="294cb786a27af75c6b7bfcf3924fee299a4870ec" translate="yes" xml:space="preserve">
          <source>Downleveling is TypeScript&amp;rsquo;s term for transpiling to an older version of JavaScript. This flag is to enable support for a more accurate implementation of how modern JavaScript iterates through new concepts in older JavaScript runtimes.</source>
          <target state="translated">다운 레벨링은 이전 버전의 JavaScript로 변환하는 TypeScript의 용어입니다. 이 플래그는 최신 JavaScript가 이전 JavaScript 런타임에서 새로운 개념을 반복하는 방식을보다 정확하게 구현할 수 있도록 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; 스크립트를 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">버그로 인해 TypeScript에서 다음과 같은 구문이 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="db11c375055a24f360ae47b840505b64422c9a27" translate="yes" xml:space="preserve">
          <source>During development of this feature, we discovered a large number of inherently unsafe class hierarchies, including some in the DOM. Because of this, the setting only applies to functions written in &lt;em&gt;function&lt;/em&gt; syntax, not to those in &lt;em&gt;method&lt;/em&gt; syntax:</source>
          <target state="translated">이 기능을 개발하는 동안 DOM의 일부를 포함하여 본질적으로 안전하지 않은 클래스 계층 구조를 많이 발견했습니다. 이 때문에 설정 은 &lt;em&gt;메서드&lt;/em&gt; 구문이 아닌 &lt;em&gt;함수&lt;/em&gt; 구문으로 작성된 함수에만 적용됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">TypeScript 3.4에서 형식 인수를 유추하는 동안 함수 형식을 반환하는 일반 함수를 호출하기 위해 TypeScript &lt;em&gt;는&lt;/em&gt; 적절하게 일반 함수 인수의 형식 매개 변수를 결과 함수 형식으로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">동적 &lt;code&gt;import&lt;/code&gt; 표현식은 사용자가 프로그램의 임의의 지점에서 비동기 적으로 모듈을 요청할 수있는 ECMAScript의 새로운 기능이며 일부입니다.</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">동적 가져 오기 표현식</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Node.js에서 동적 모듈로드</target>
        </trans-unit>
        <trans-unit id="e67a2edba452a5455e675d6f3d31c528be815de5" translate="yes" xml:space="preserve">
          <source>ECMA-262 Standard</source>
          <target state="translated">ECMA-262 표준</target>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript를 2,015은 CommonJS (또한, ES2015, ECMAScript를 6, ES6라고도 함), 및 RequireJS는 유사한 개념이 &lt;em&gt;가져 &lt;/em&gt;&lt;em&gt;모듈&lt;/em&gt; . 예를 들어 JavaScript CommonJS (Node.js)에서는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0fa32652049aa2b5542973c2441565a7dd912fa2" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 added several new iteration primitives: the &lt;code&gt;for / of&lt;/code&gt; loop (&lt;code&gt;for (el of arr)&lt;/code&gt;), Array spread (&lt;code&gt;[a, ...b]&lt;/code&gt;), argument spread (&lt;code&gt;fn(...args)&lt;/code&gt;), and &lt;code&gt;Symbol.iterator&lt;/code&gt;. &lt;code&gt;--downlevelIteration&lt;/code&gt; allows for these iteration primitives to be used more accurately in ES5 environments if a &lt;code&gt;Symbol.iterator&lt;/code&gt; implementation is present.</source>
          <target state="translated">ECMAScript 6에는 &lt;code&gt;for / of&lt;/code&gt; 루프 ( &lt;code&gt;for (el of arr)&lt;/code&gt; ), 배열 스프레드 ( &lt;code&gt;[a, ...b]&lt;/code&gt; ), 인수 스프레드 ( &lt;code&gt;fn(...args)&lt;/code&gt; ) 및 &lt;code&gt;Symbol.iterator&lt;/code&gt; 와 같은 몇 가지 새로운 반복 기본 요소가 추가되었습니다 . 반복자 . &lt;code&gt;--downlevelIteration&lt;/code&gt; 을 사용하면 &lt;code&gt;Symbol.iterator&lt;/code&gt; 구현이 있는 경우 ES5 환경에서 이러한 반복 프리미티브를보다 정확하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66e029ab9fd3fb22e4e3981b8b4649135674638a" translate="yes" xml:space="preserve">
          <source>ECMAScript Private Fields</source>
          <target state="translated">ECMAScript 비공개 필드</target>
        </trans-unit>
        <trans-unit id="3e52a38a1db2363571bfdfdb94baa4cbfd95e124" translate="yes" xml:space="preserve">
          <source>ES Module Interop - &lt;code&gt;esModuleInterop&lt;/code&gt;</source>
          <target state="translated">ES 모듈 Interop- &lt;code&gt;esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015에는 클래스에서 속성을 선언하는 수단이 없습니다. 객체 리터럴과 마찬가지로 속성이 동적으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">ES6는 &lt;code&gt;let&lt;/code&gt; 와 &lt;code&gt;const&lt;/code&gt; 를 ES3와 ES5을 대상으로 할 때 선언이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6 모듈</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">ES6 발전기</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6에는 사용자가 단일 이스케이프를 사용하여 유니 코드 코드 포인트를 나타낼 수있는 이스케이프 기능이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">ES7 지수 연산자</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">각 열거 형 멤버에는 &lt;em&gt;상수&lt;/em&gt; 또는 &lt;em&gt;계산&lt;/em&gt; 가능한 값이 있습니다 . 다음과 같은 경우 열거 형 멤버는 상수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">각 모듈은 선택적으로 &lt;code&gt;default&lt;/code&gt; 내보내기를 내보낼 수 있습니다. 기본 내보내기는 키워드 &lt;code&gt;default&lt;/code&gt; 로 표시됩니다 . 모듈 당 하나의 &lt;code&gt;default&lt;/code&gt; 내보내기 만 가능 합니다. &lt;code&gt;default&lt;/code&gt; 내보내기는 다른 가져 오기 양식을 사용하여 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">이러한 각 선언 양식은 새로운 유형 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e60fbc5aa90c5637a80cca5bb6a944053a0e909a" translate="yes" xml:space="preserve">
          <source>Each step represents a move towards a safer type-system, but not every project needs that level of verification.</source>
          <target state="translated">각 단계는 더 안전한 유형 시스템을 향한 움직임을 나타내지 만 모든 프로젝트에 해당 수준의 검증이 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">각 유형의 주요 라이브러리 구조화 패턴은 &lt;a href=&quot;templates&quot;&gt;템플리트&lt;/a&gt; 섹션 에 해당 파일이 있습니다. 이 템플릿으로 시작하여 더 빠르게 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">조기 혜택</target>
        </trans-unit>
        <trans-unit id="b122bd4aba545fcb88070e3be4ef84508e72d3b0" translate="yes" xml:space="preserve">
          <source>Editing the package.json</source>
          <target state="translated">package.json 편집</target>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">Visual Studio 및 Visual Studio Code와 같은 편집자는 빠른 수정, 리팩토링 및 다른 모듈에서 값을 자동으로 가져 오기와 같은 기타 변환을 자동으로 적용 할 수 있습니다. 이러한 변환은 TypeScript에 의해 구동되며 이전 버전의 TypeScript는 모든 명령문 끝에 무조건 세미콜론을 추가했습니다. 불행히도, 이것은 많은 사용자의 스타일 가이드 라인에 동의하지 않았으며, 많은 사용자들은 세미콜론을 삽입하는 에디터에 불만을 가지고있었습니다.</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토 타입입니다.</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">배열 리터럴과 일치하지 않는 배열 바인딩 패턴의 요소는 배열 바인딩 패턴에 기본값이 있어야하며 배열 리터럴 유형에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">식 내장</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">방출 &lt;code&gt;__importStar&lt;/code&gt; 및 &lt;code&gt;__importDefault&lt;/code&gt; 런타임 바벨 에코 시스템과의 호환성을 위해 헬퍼 및 활성화 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 자료형 체계 호환성을.</target>
        </trans-unit>
        <trans-unit id="123d5430b7726bc1ca6fdb384bc205c8fa112251" translate="yes" xml:space="preserve">
          <source>Emit BOM - &lt;code&gt;emitBOM&lt;/code&gt;</source>
          <target state="translated">BOM 방출 &lt;code&gt;emitBOM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b82eac2f5a8d4b5a64f3e121a2d0286cb7295a10" translate="yes" xml:space="preserve">
          <source>Emit Declaration Only - &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">선언 만 방출 &lt;code&gt;emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26ca9b8f663272a641132bd7279ee178b83d3fa3" translate="yes" xml:space="preserve">
          <source>Emit Decorator Metadata - &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</source>
          <target state="translated">데코레이터 메타 데이터 방출 &lt;code&gt;emitDecoratorMetadata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">출력 파일의 시작 부분에서 UTF-8 바이트 순서 표시 (BOM)를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">별도의 파일 대신 소스 맵이있는 단일 파일을 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;built&lt;/code&gt; 모든 출력 파일을 작성하십시오 ( &lt;code&gt;outDir&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">ECMAScript 표준 시맨틱으로 클래스 필드를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">소스에서 장식 된 선언에 대한 디자인 유형 메타 데이터를 방출합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;문제 # 2577&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">단일 파일 내에서 소스 맵과 함께 소스를 방출하십시오. 필요 &lt;code&gt;--inlineSourceMap&lt;/code&gt; 또는 &lt;code&gt;--sourceMap&lt;/code&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b327d3b6deafdd67337cc0d9e334080a73b07f46" translate="yes" xml:space="preserve">
          <source>Empty Types</source>
          <target state="translated">빈 유형</target>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">모든 엄격한 유형 검사 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">이전 컴파일의 정보를 디스크의 파일로 읽고 쓰는 방식으로 증분 컴파일을 활성화합니다. 이 파일은 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 플래그에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">함수 에서 &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 메소드를 보다 엄격하게 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">활성화 &lt;code&gt;jsx&lt;/code&gt; 옵션을</target>
        </trans-unit>
        <trans-unit id="d4a3eed1cf65a963ddf3f9b30f57ca9cb73fcaa1" translate="yes" xml:space="preserve">
          <source>Enables &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;experimental support for decorators&lt;/a&gt;, which is in stage 2 of the TC39 standardization process.</source>
          <target state="translated">활성화 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;장식 실험적 지원&lt;/a&gt; TC39 표준화 프로세스의 스테이지 2에있다.</target>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">ES 데코레이터를 실험적으로 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b4a6f5d796dc27b38b366249d014d055262aaf" translate="yes" xml:space="preserve">
          <source>Enables experimental support for emitting type metadata for decorators which works with the module &lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt;&lt;code&gt;reflect-metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/reflect-metadata&quot;&gt; &lt;code&gt;reflect-metadata&lt;/code&gt; &lt;/a&gt; 모듈과 함께 작동하는 데코레이터의 유형 메타 데이터를 내보내는 실험적 지원을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0d931513b0509143ecae93fe072c8701ba3bef1a" translate="yes" xml:space="preserve">
          <source>Enables the generation of &lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;sourcemap files&lt;/a&gt;. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as &lt;code&gt;.js.map&lt;/code&gt; (or &lt;code&gt;.jsx.map&lt;/code&gt;) files next to the corresponding &lt;code&gt;.js&lt;/code&gt; output file.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;소스 맵 파일&lt;/a&gt; 생성을 활성화합니다 . 이러한 파일을 사용하면 실제로 내 보낸 JavaScript 파일로 작업 할 때 디버거 및 기타 도구에서 원본 TypeScript 소스 코드를 표시 할 수 있습니다. 소스 맵 파일은 해당 &lt;code&gt;.js&lt;/code&gt; 출력 파일 옆에 &lt;code&gt;.js.map&lt;/code&gt; (또는 &lt;code&gt;.jsx.map&lt;/code&gt; ) 파일 로 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">사용 &lt;code&gt;--declarationMap&lt;/code&gt; 함께 &lt;code&gt;--declaration&lt;/code&gt; 것은 방출하는 컴파일러의 원인 &lt;code&gt;.d.ts.map&lt;/code&gt; 출력과 함께 파일을 &lt;code&gt;.d.ts&lt;/code&gt; 의 파일을. 언어 서비스는 이제 이러한 맵 파일을 이해하고이를 사용하여 선언 파일 기반 정의 위치를 ​​사용 가능한 경우 원래 소스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--strict&lt;/code&gt; 를 활성화 하면 &lt;code&gt;--noImplicitAny&lt;/code&gt; , &lt;code&gt;--noImplicitThis&lt;/code&gt; , &lt;code&gt;--alwaysStrict&lt;/code&gt; , &lt;code&gt;--strictBindCallApply&lt;/code&gt; , &lt;code&gt;--strictNullChecks&lt;/code&gt; , &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 및 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 이 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="7e34ed7ff6f716b586d5cdcceccbaca058f72fc3" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;esModuleInterop&lt;/code&gt; will also enable &lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt;&lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 &lt;code&gt;esModuleInterop&lt;/code&gt; 것은 또한 가능하게 할 것이다 &lt;a href=&quot;#allowSyntheticDefaultImports&quot;&gt; &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b00df6ae9f4549f7d57c88d20b001737628bc763" translate="yes" xml:space="preserve">
          <source>Enabling the option allows importing JSON, and validating the types in that JSON file.</source>
          <target state="translated">이 옵션을 활성화하면 JSON을 가져오고 해당 JSON 파일의 유형을 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">강화 된 &lt;code&gt;--init&lt;/code&gt; 출력</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">TypeScript가 프로젝트를 컴파일하기 위해 참조 된 프로젝트의 출력을 찾을 위치를 결정할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">정의되지 않은 클래스 속성이 생성자에서 초기화되었는지 확인하십시오. 이 옵션을 적용하려면 &lt;code&gt;--strictNullChecks&lt;/code&gt; 를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a3144235c8641b90eb9884c83f0c03e49fe7f2e" translate="yes" xml:space="preserve">
          <source>Ensures that your files are parsed in the ECMAScript strict mode, and emit &amp;ldquo;use strict&amp;rdquo; for each source file.</source>
          <target state="translated">파일이 ECMAScript 엄격 모드에서 구문 분석되었는지 확인하고 각 소스 파일에 대해 &quot;엄격 사용&quot;을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">색인 유형 조회 또는 &lt;code&gt;keyof&lt;/code&gt; 를 입력하십시오 . 인덱싱 된 유형의 쿼리 &lt;code&gt;keyof T&lt;/code&gt; 허용 속성 이름의 유형 산출 &lt;code&gt;T&lt;/code&gt; 를 . &lt;code&gt;keyof T&lt;/code&gt; 의 유형의 하위 유형으로 간주됩니다 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">열거 형 멤버 유형</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="988d8f6199e4b6350a2137c1e9bd419a30312b8e" translate="yes" xml:space="preserve">
          <source>Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">열거 형을 사용하면 개발자가 명명 된 상수 집합을 정의 할 수 있습니다. 열거 형을 사용하면 의도를 더 쉽게 문서화하거나 고유 한 사례 집합을 만들 수 있습니다. TypeScript는 숫자 및 문자열 기반 열거 형을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">열거 형을 사용하면 명명 된 상수 집합을 정의 할 수 있습니다. 열거 형을 사용하면 의도를보다 쉽게 ​​문서화하거나 고유 한 사례를 만들 수 있습니다. TypeScript는 숫자 및 문자열 기반 열거 형을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">열거 형은 숫자와 호환되며 숫자는 열거 형과 호환됩니다. 다른 열거 형 유형의 열거 형 값은 호환되지 않는 것으로 간주됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5829a150f7ef6409938f989938645fcde15588e4" translate="yes" xml:space="preserve">
          <source>Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.</source>
          <target state="translated">열거 형은 TypeScript의 몇 가지 기능 중 하나이며 JavaScript의 유형 수준 확장이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">열거 형은 런타임에 존재하는 실제 객체입니다. 예를 들어 다음 열거 형</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">열거 형은 매우 유용하지만 일부 프로그램에는 실제로 생성 된 코드가 필요하지 않으며 열거 형 멤버의 모든 인스턴스를 해당 숫자로 인라인하는 것만으로도 이점이 있습니다. 새로운 &lt;code&gt;const enum&lt;/code&gt; 선언은 형식 안전성을위한 일반 &lt;code&gt;enum&lt;/code&gt; 과 동일하게 작동 하지만 컴파일 타임에 완전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">컴파일 타임에 열거 형</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">런타임에 열거 형</target>
        </trans-unit>
        <trans-unit id="a995ff457a717bdb048c8c9232b3366e472f2af1" translate="yes" xml:space="preserve">
          <source>Erased Structural Types</source>
          <target state="translated">지워진 구조 유형</target>
        </trans-unit>
        <trans-unit id="b14aa42c384f51c886a258b319db2b853b34f4b0" translate="yes" xml:space="preserve">
          <source>Erased Types</source>
          <target state="translated">지워진 유형</target>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">&lt;code&gt;moduleB&lt;/code&gt; 가 전달 되지 않아 찾지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">러시아어 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--checkJs&lt;/code&gt; 가 있는 .js 파일의 오류</target>
        </trans-unit>
        <trans-unit id="4ceaa96be69ab42f127926b9976ca00d796f12ac" translate="yes" xml:space="preserve">
          <source>Errors which already exist in your codebase, which TypeScript has uncovered because the language has refined its understanding of JavaScript.</source>
          <target state="translated">언어가 JavaScript에 대한 이해를 개선했기 때문에 TypeScript가 발견 한 코드베이스에 이미 존재하는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">이 시점에서도 프로젝트를 이해하는 TypeScript의 이점을 얻을 수 있습니다. &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; 또는 &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt; 와 같은 편집기를 열면 완료와 같은 일부 툴링 지원을받을 수 있음을 알 수 있습니다. 다음과 같은 옵션으로 특정 버그를 잡을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">더 좋은 점은 &lt;code&gt;--noImplicitThis&lt;/code&gt; 플래그를 컴파일러에 전달하면이 실수를 할 때 TypeScript가 경고합니다 . 또한 지적 할 &lt;code&gt;this&lt;/code&gt; 에 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; 형이고 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">열거 형은 런타임에 존재하는 실제 객체이지만 &lt;code&gt;keyof&lt;/code&gt; 키워드는 일반적인 객체와 다르게 작동합니다. 대신 &lt;code&gt;keyof typeof&lt;/code&gt; 를 사용 하여 모든 Enum 키를 문자열로 나타내는 Type을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="351b0bfe6af01cc3af80d3c225ca18f3413c36bf" translate="yes" xml:space="preserve">
          <source>Every option is fully explained in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="translated">모든 옵션은 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig 참조&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 하나의 하위 폴더에 상대 모듈 가져 오기를 볼 때마다 &lt;code&gt;rootDirs&lt;/code&gt; 는 , 그것의 각 항목이 수입을 찾기 위해 시도합니다 &lt;code&gt;rootDirs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6a95cb3eaeb836cfc786e3694e94cec3a8b9a84" translate="yes" xml:space="preserve">
          <source>Everyday Types</source>
          <target state="translated">Everyday Types</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 예 :</target>
        </trans-unit>
        <trans-unit id="678e0ce800d6be194877dbcb671642b8653408c3" translate="yes" xml:space="preserve">
          <source>Example: Effects on &lt;code&gt;for / of&lt;/code&gt;</source>
          <target state="translated">예 :에 &lt;code&gt;for / of&lt;/code&gt; 영향</target>
        </trans-unit>
        <trans-unit id="0a1e2321887c3e9bb33ef80db139e7686530c71b" translate="yes" xml:space="preserve">
          <source>Example: Effects on Array Spreads</source>
          <target state="translated">예 : 배열 스프레드에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">글로벌 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">모듈 식 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">UMD 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">초과 자산 점검</target>
        </trans-unit>
        <trans-unit id="8f00aff99521b0b67d7cf2a6f99b9b1382e2bec8" translate="yes" xml:space="preserve">
          <source>Exclude - &lt;code&gt;exclude&lt;/code&gt;</source>
          <target state="translated">제외- &lt;code&gt;exclude&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">명령 행에서 Babel 실행</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">철저한 검사</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">튜플 형식의 스프레드 식을 이산 형 인수로 확장</target>
        </trans-unit>
        <trans-unit id="b718f8c3a83788b1b360cc38380401a994fb4892" translate="yes" xml:space="preserve">
          <source>Experimental</source>
          <target state="translated">Experimental</target>
        </trans-unit>
        <trans-unit id="e63f550a4c8e9f47ff813f81f98e044c934b5e77" translate="yes" xml:space="preserve">
          <source>Experimental Decorators - &lt;code&gt;experimentalDecorators&lt;/code&gt;</source>
          <target state="translated">실험적 데코레이터- &lt;code&gt;experimentalDecorators&lt;/code&gt; 데코레이터</target>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 함수에 대한 실험적 지원</target>
        </trans-unit>
        <trans-unit id="7f86b7832ad902539ef49647ed1b68f24295f259" translate="yes" xml:space="preserve">
          <source>Explain the effects of important compiler options</source>
          <target state="translated">중요한 컴파일러 옵션의 효과 설명</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 의 명시 적 유형</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">가져온 이름을 명시 적으로 나열</target>
        </trans-unit>
        <trans-unit id="b4d49c128ea27c0b476f0c2a2de93b85b8758f3c" translate="yes" xml:space="preserve">
          <source>Explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;플레이 그라운드 예제를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">수출 신고</target>
        </trans-unit>
        <trans-unit id="0d00dcedcb60c65ca444794366f3702bd2f190a2" translate="yes" xml:space="preserve">
          <source>Export all as x</source>
          <target state="translated">모두 x로 내보내기</target>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">가능한 한 최상위 수준에 가깝게 내보내기</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">수출 명세서</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">내보내기 명령문은 소비자의 내보내기 이름을 바꿔야 할 때 편리하므로 위 예제를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">선언 내보내기</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">모듈에서 네임 스페이스를 내보내는 것은 너무 많은 중첩 레이어를 추가하는 예입니다. 네임 스페이스는 때때로 사용되지만 모듈을 사용할 때 추가 수준의 간접 성을 추가합니다. 이것은 사용자에게 빨리 고통의 원인이 될 수 있으며 일반적으로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">모듈에서 내보내기</target>
        </trans-unit>
        <trans-unit id="3f1c3ff321429d2eb6717b5d648a871fa208dfe3" translate="yes" xml:space="preserve">
          <source>Exports of Non-Value Identifiers</source>
          <target state="translated">값이 아닌 식별자 내보내기</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">식 연산자</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">식 연산자는 피연산자 유형에 &lt;code&gt;null&lt;/code&gt; 및 / 또는 &lt;code&gt;undefined&lt;/code&gt; 가 포함되도록 허용 하지만 항상 null이 아닌 유형과 정의되지 않은 유형의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7764ab55f19ed7e0cf007e50b5bc8b2938b82904" translate="yes" xml:space="preserve">
          <source>Extended Diagnostics - &lt;code&gt;extendedDiagnostics&lt;/code&gt;</source>
          <target state="translated">확장 진단- &lt;code&gt;extendedDiagnostics&lt;/code&gt; 진단</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">수업 연장</target>
        </trans-unit>
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">인터페이스 확장</target>
        </trans-unit>
        <trans-unit id="375df0f41528acadecbb25ba2ba1c7a3fb7ba51c" translate="yes" xml:space="preserve">
          <source>Extending a type via intersections</source>
          <target state="translated">교차로를 통해 유형 확장</target>
        </trans-unit>
        <trans-unit id="b0184e831bfb3d0f17bb14cf78557f4879766c11" translate="yes" xml:space="preserve">
          <source>Extending an interface</source>
          <target state="translated">인터페이스 확장</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">식 확장</target>
        </trans-unit>
        <trans-unit id="2c62365e86a53d80330c0805ef1f6ee2b629a938" translate="yes" xml:space="preserve">
          <source>Extends - &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">확장- &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9ec862d01090b18ed0a5b1f9fab74b9212f3809" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;a href=&quot;functions#this-parameters&quot;&gt;this&lt;/a&gt; parameter for a function type, or &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;unknown&lt;/a&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">함수 유형에 &lt;a href=&quot;functions#this-parameters&quot;&gt;대해이&lt;/a&gt; 매개 변수 의 유형을 추출 하거나 함수 유형 &lt;code&gt;this&lt;/code&gt; 매개 변수 가 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type&quot;&gt;없는&lt;/a&gt; 경우 알 수 없음을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">추출물의 유형 &lt;code&gt;this&lt;/code&gt; 함수 유형의 매개 변수 또는 &lt;code&gt;unknown&lt;/code&gt; 함수 타입이없는 경우 &lt;code&gt;this&lt;/code&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">공장 기능</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">빠른 &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 플래그로 더 빠른 후속 빌드</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">커뮤니티의 경험과 자체 경험에 따르면 최신 TypeScript 기능을 활용하는 동시에 이전 버전의 사용자를 수용하는 것이 어렵다는 것을 알 수 있습니다. TypeScript에는 이러한 시나리오를 수용하는 데 도움이되는 &lt;code&gt;typesVersions&lt;/code&gt; 라는 새로운 기능이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="812fb4ba4e595ba2544dd885ed6718d2c6cdeed2" translate="yes" xml:space="preserve">
          <source>File Inclusion</source>
          <target state="translated">파일 포함</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">파일이 존재하지 않습니다. 두 번째 대체로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">파일이 존재. 끝난.</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">파일 경로</target>
        </trans-unit>
        <trans-unit id="0086a262afcd9e4f6a1dcc9082579481ec576eaf" translate="yes" xml:space="preserve">
          <source>Files - &lt;code&gt;files&lt;/code&gt;</source>
          <target state="translated">파일- &lt;code&gt;files&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; 의 파일은 일부 UI 컨트롤의 사용자 코드입니다. 의 파일 &lt;code&gt;generated/templates&lt;/code&gt; UI 템플릿 바인딩 코드가 빌드의 일부로 템플릿 생성기로 자동 생성됩니다. 빌드 단계는 &lt;code&gt;/src/views&lt;/code&gt; 및 &lt;code&gt;/generated/templates/views&lt;/code&gt; 의 파일을 출력의 동일한 디렉토리로 복사합니다 . 런타임시보기는 템플리트가 옆에 존재할 것으로 예상 할 수 있으므로 상대 이름을 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 으로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; 를 사용하여 포함 된 파일 은 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성을 사용하여 필터링 할 수 있습니다 . 그러나 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 특성을 사용하여 명시 적으로 포함 된 파일 은 항상 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 에 관계없이 포함 됩니다. &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 제외에 속성 기본값 &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; , &lt;code&gt;jspm_packages&lt;/code&gt; 은 및 &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; 디렉토리를 지정하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; 를 사용하여 포함 된 파일 은 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성을 사용하여 필터링 할 수 있습니다 . 그러나 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 특성을 사용하여 명시 적으로 포함 된 파일 은 항상 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 에 관계없이 포함 됩니다. &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 제외에 속성 기본값을 &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; 및 &lt;code&gt;jspm_packages&lt;/code&gt; 의 지정되지 않은 경우 디렉토리.</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">최종 결과</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">마지막으로 ES2015는 &lt;code&gt;for..of&lt;/code&gt; 문을 iterable을 반복하는 수단으로 소개했습니다 . 마찬가지로 비동기 반복 제안에서는 비동기 반복 가능을 반복하기 위해 &lt;code&gt;for..await..of&lt;/code&gt; 문을 도입합니다 .</target>
        </trans-unit>
        <trans-unit id="05320552d7f5f92b22b211023dcc2e57253aede5" translate="yes" xml:space="preserve">
          <source>Finally, TypeScript doesn&amp;rsquo;t provide any additional runtime libraries. Your programs will use the same standard library (or external libraries) as JavaScript programs, so there&amp;rsquo;s no additional TypeScript-specific framework to learn.</source>
          <target state="translated">마지막으로 TypeScript는 추가 런타임 라이브러리를 제공하지 않습니다. 프로그램은 JavaScript 프로그램과 동일한 표준 라이브러리 (또는 외부 라이브러리)를 사용하므로 학습 할 추가 TypeScript 관련 프레임 워크가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">마지막으로, &lt;code&gt;src/greet.ts&lt;/code&gt; 를 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">마지막으로 컴파일러에서 모듈을 확인할 수 없으면 오류가 기록됩니다. 이 경우 &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt; 와 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">마지막으로 대상이 ES5 또는 ES3 인 경우 &lt;code&gt;--downlevelIterators&lt;/code&gt; 플래그도 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">마지막으로 클래스를 사용하여 예제를 마지막으로 확장 해 봅시다. TypeScript는 클래스 기반 객체 지향 프로그래밍 지원과 같은 JavaScript의 새로운 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8e6a9c2de74efedbcef22e11a709230e67b2b36f" translate="yes" xml:space="preserve">
          <source>Finally, the Handbook won&amp;rsquo;t cover how TypeScript interacts with other tools, except where necessary. Topics like how to configure TypeScript with webpack, rollup, parcel, react, babel, closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn, or npm are out of scope - you can find these resources elsewhere on the web.</source>
          <target state="translated">마지막으로, 핸드북은 필요한 경우를 제외하고는 TypeScript가 다른 도구와 상호 작용하는 방식을 다루지 않습니다. Webpack, rollup, parcel, react, babel, Closure, lerna, rush, bazel, preact, vue, angular, svelte, jquery, yarn 또는 npm을 사용하여 TypeScript를 구성하는 방법과 같은 항목은 범위를 벗어납니다. 이러한 리소스는 다른 곳에서 찾을 수 있습니다. 웹에서.</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">마지막으로 &lt;code&gt;namespace&lt;/code&gt; 선언을 사용하여 다양한 병합을 수행 할 수 있습니다. 이것은 특히 현실적인 예는 아니지만 모든 종류의 흥미로운 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">마지막으로 믹스 인을 클래스 구현에 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">마지막으로 인덱스에 할당되지 않도록 인덱스 서명을 &lt;code&gt;readonly&lt;/code&gt; 으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">참조 된 모든 프로젝트 찾기</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">선언 파일 찾기 및 설치</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">그 단계로 끝났습니까? 큰! JavaScript에서 TypeScript로 파일을 성공적으로 마이그레이션했습니다!</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">먼저 Webpack이 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">먼저 ES2015에 대한 Babelify 및 Babel 사전 설정을 설치하십시오. Uglify와 마찬가지로 Babelify는 맹글 코드를 작성하므로 비닐 버퍼와 펄프 소스 맵이 필요합니다. 기본적으로 Babelify는 확장자가 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.es&lt;/code&gt; , &lt;code&gt;.es6&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; 인 파일 만 처리 하므로 Babelify의 옵션으로 &lt;code&gt;.ts&lt;/code&gt; 확장자 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">먼저 Uglify를 설치하십시오. Uglify의 핵심은 코드를 엉망으로 만드는 것이므로, 소스 맵이 계속 작동하도록 비닐 버퍼와 gulp-sourcemap을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">우선, TypeScript는 원본 소스 코드를 다시 확인하지 않고도 다른 프로젝트에 대해 유형 검사를 할 수 있기 때문에 중요합니다. TypeScript가 TypeScript를 염두에두고 구축되지 않은 기존 JavaScript 라이브러리와 상호 운용 될 수있게하기 때문에 중요합니다. 마지막으로, 종종 과소 평가되는 이점 : TypeScript &lt;em&gt;및&lt;/em&gt; JavaScript 사용자는 TypeScript 기반의 편집기를 사용하여 더 나은 자동 완성과 같은 작업을 수행 할 때 이러한 파일을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">먼저 몇 가지 용어</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">첫 단계</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">먼저 통합 할 인터페이스를 선언합니다. 각 인터페이스에는 다른 문자열 리터럴 유형 의 &lt;code&gt;kind&lt;/code&gt; 속성이 있습니다. &lt;code&gt;kind&lt;/code&gt; 속성은이라고 &lt;em&gt;판별&lt;/em&gt; 또는 &lt;em&gt;태그&lt;/em&gt; . 다른 속성은 각 인터페이스에 따라 다릅니다. 인터페이스는 현재 관련이 없습니다. 그것들을 노동 조합에 넣자 :</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">먼저 TypeScript에 빌드 방법을 알려줘야합니다. &lt;code&gt;scripts&lt;/code&gt; 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;새 항목을&lt;/strong&gt; 클릭하십시오 . 그런 다음 &lt;strong&gt;TypeScript Configuration File을&lt;/strong&gt; 선택 하고 기본 이름 인 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">먼저 접근자는 ECMAScript 5 이상을 출력하도록 컴파일러를 설정해야합니다. ECMAScript 3 로의 다운 레벨링은 지원되지 않습니다. 둘째, &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 이 없는 접근 자는 자동으로 &lt;code&gt;readonly&lt;/code&gt; 으로 유추됩니다 . 속성의 사용자가 파일을 변경할 수 없다는 것을 알 수 있기 때문에 코드에서 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">첫째, 주어진 유형의 &lt;code&gt;T'&lt;/code&gt; 와 &lt;code&gt;U'&lt;/code&gt; 의 인스턴스화입니다 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 형 매개 변수의 모든 항목이 대체됩니다 &lt;code&gt;any&lt;/code&gt; 경우, &lt;code&gt;T'&lt;/code&gt; 로 할당 할 수없는 &lt;code&gt;U'&lt;/code&gt; 는 조건부 유형에 해결 &lt;code&gt;Y&lt;/code&gt; . 직관적으로, &lt;code&gt;T&lt;/code&gt; 의 가장 허용 가능한 인스턴스화가 &lt;code&gt;U&lt;/code&gt; 의 가장 허용 가능한 인스턴스화에 할당 가능하지 않은 경우 , 우리는 인스턴스화가 없으며 &lt;code&gt;Y&lt;/code&gt; 로 해결할 수 있음을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">먼저 필요한 경우 &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core를&lt;/a&gt; 설치 하십시오. 이 빠른 시작 가이드에는 Visual Studio 2015 또는 2017이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;browserify&lt;/a&gt; , tsify 및 vinyl-source-stream을 설치하십시오. tsify는 gulp-typescript와 같이 TypeScript 컴파일러에 대한 액세스를 제공하는 Browserify 플러그인입니다. 비닐 소스 스트림은 우리가 꿀꺽라는 이해할 수있는 형식으로 Browserify의 뒷면의 파일 출력을 적용 할 수 있습니다 &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;비닐&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">먼저 &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; 유틸리티 라이브러리를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">먼저 컴파일러는 가져온 모듈을 나타내는 파일을 찾습니다. 이를 위해 컴파일러는 &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; 또는 &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; 의 두 가지 전략 중 하나를 따릅니다 . 이러한 전략은 컴파일러에게 &lt;em&gt;어디&lt;/em&gt; 에서 &lt;code&gt;moduleA&lt;/code&gt; 를 찾을 &lt;em&gt;것인지&lt;/em&gt; 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">먼저 &lt;code&gt;--outFile&lt;/code&gt; 플래그를 사용하여 연결된 출력을 사용하여 모든 입력 파일을 단일 JavaScript 출력 파일로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">먼저 TypeScript 선언 파일이 나타낼 수있는 라이브러리 종류를 검토합니다. 우리는 각 종류의 라이브러리가 어떻게 &lt;em&gt;사용&lt;/em&gt; 되는지, 어떻게 &lt;em&gt;작성&lt;/em&gt; 되는지 , 그리고 실제 세계에서 몇 가지 예제 라이브러리를 간략하게 보여줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">먼저 TypeScript의 &lt;code&gt;module&lt;/code&gt; 플래그를 설정하여 일부 모듈 시스템을 활성화해야합니다 . 유효한 옵션은 &lt;code&gt;commonjs&lt;/code&gt; , &lt;code&gt;amd&lt;/code&gt; , &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;umd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">고정 길이 튜플</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">사용하지 않는 선언에 &lt;code&gt;--noUnusedParameters&lt;/code&gt; 및 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="bd3ca27f2fe942c2bbe6da7b0df5ec8ca268ccce" translate="yes" xml:space="preserve">
          <source>Flags which help with debugging</source>
          <target state="translated">디버깅에 도움이되는 플래그</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">이 논리에 따라 컴파일러는 다음과 같이 두 가지 가져 오기를 해결하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">유형 지정에 대한 후속 조치 &lt;code&gt;this&lt;/code&gt; 클래스 또는 인터페이스, 기능 및 방법은 지금의 유형을 선언 할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 그들이 기대합니다.</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">위의 예를 따라 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 가 상대 경로가 아닌 경로를 사용하고 가져 오기가있는 경우 &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; . 그런 다음 노드는 &lt;code&gt;moduleB&lt;/code&gt; 가 작동 할 때까지 각 위치로 모듈 B 를 해결하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">JavaScript 라이브러리 사용자의 경우 &lt;a href=&quot;consumption&quot;&gt;소비&lt;/a&gt; 섹션은 해당 선언 파일을 찾아 설치하는 몇 가지 간단한 단계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">NPM 사용자의 경우 :</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">React의 경우 내장 요소는 문자열 ( &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; )로 생성되지만, 작성한 컴포넌트는 ( &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ) 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">VS 2013의 경우 :</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">VS 2015의 경우 :</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">A의 &lt;code&gt;n in x&lt;/code&gt; 표현, 여기서 &lt;code&gt;n&lt;/code&gt; 은 문자열의 문자 또는 문자열 리터럴 타입이며, &lt;code&gt;x&lt;/code&gt; 노조 타입, 옵션 또는 필수 속성이 유형에 &quot;true&quot;로 지점 좁히는 &lt;code&gt;n&lt;/code&gt; 및 유형에 &quot;거짓&quot;지점 좁아 선택적 또는 누락 된 속성 &lt;code&gt;n&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b6d27cd5a1c972beb5c2e01a0a9c58217f3d2c" translate="yes" xml:space="preserve">
          <source>For certain downleveling operations, TypeScript uses some helper code for operations like extending class, spreading arrays or objects, and async operations. By default, these helpers are inserted into files which use them. This can result in code duplication if the same helper is used in many different modules.</source>
          <target state="translated">특정 하향 조정 작업의 경우 TypeScript는 클래스 확장, 배열 또는 객체 확산 및 비동기 작업과 같은 작업에 일부 도우미 코드를 사용합니다. 기본적으로 이러한 도우미는이를 사용하는 파일에 삽입됩니다. 여러 모듈에서 동일한 도우미를 사용하면 코드가 중복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 빌드 를 작성하기 위해 사용자는 &lt;code&gt;createIncrementalProgram&lt;/code&gt; 및 &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; API를 활용할 수 있습니다 . 사용자는 새로 노출 된 &lt;code&gt;readBuilderProgram&lt;/code&gt; 함수를 사용하여이 API에 의해 생성 된 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 파일 에서 기존 프로그램 인스턴스를 다시 수화 할 수 있습니다. 이 기능은 새 프로그램을 만드는 데만 사용됩니다 (예 : 반환 된 인스턴스를 수정할 수 없음). 에 사용될 &lt;code&gt;oldProgram&lt;/code&gt; 의 다른 파라미터에 &lt;code&gt;create*Program&lt;/code&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM API 또는 &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Iterable&lt;/code&gt; 과 같은 내장 JS 런타임 생성자와 같이 내장 유형을 릴레이하는 선언 파일 작성자의 경우 triple-slash-reference lib 지시문이 권장됩니다. 이전에는 이러한 .d.ts 파일에 이러한 유형의 전달 / 중복 선언을 추가해야했습니다.</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM API 또는 &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Iterable&lt;/code&gt; 과 같은 내장 JS 런타임 생성자와 같은 내장 유형에 의존하는 선언 파일 작성자의 경우 triple-slash-reference lib 지시문이 권장됩니다. 이전에는 이러한 .d.ts 파일에 이러한 유형의 전달 / 중복 선언을 추가해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">컴파일 중에 생성 된 선언 파일의 경우 컴파일러는 자동으로 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 를 추가합니다. 생성 된 선언 파일 의 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 는 결과 파일이 참조 된 패키지의 선언을 사용하는 &lt;em&gt;경우에만&lt;/em&gt; 추가 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 파일 의 &lt;code&gt;@types&lt;/code&gt; 패키지에 대한 종속성을 선언 하려면 대신 명령 행 또는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;--types&lt;/code&gt; 를 사용 하십시오 . 자세한 내용 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;은 &lt;/a&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에서 &lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; 및 &lt;code&gt;types&lt;/code&gt; 사용 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc0c74f5013de3695703ff3f7978efc260f1a6e9" translate="yes" xml:space="preserve">
          <source>For developer platforms like Node will have a certain baselines for the their target depending on their version. You can find a set of community organized TSConfigs at &lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig/bases&lt;/a&gt; for common platforms and their versions.</source>
          <target state="translated">Node와 같은 개발자 플랫폼의 경우 버전에 따라 대상에 대한 특정 기준이 있습니다. 공통 플랫폼 및 해당 버전에 대해 &lt;a href=&quot;https://github.com/tsconfig/bases#centralized-recommendations-for-tsconfig-bases&quot;&gt;tsconfig / bases&lt;/a&gt; 에서 커뮤니티 구성 TSConfig 세트를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들면</target>
        </trans-unit>
        <trans-unit id="2ed40c6f0c1780add8b6c27390450ea1294c1186" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;document.createElement('xyz')&lt;/code&gt; returns a &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; element, clearly not an element that is specified by the HTML specification.</source>
          <target state="translated">예를 들어 &lt;code&gt;document.createElement('xyz')&lt;/code&gt; 는 HTML 사양에 지정된 요소가 아닌 &lt;code&gt;&amp;lt;xyz&amp;gt;&amp;lt;/xyz&amp;gt;&lt;/code&gt; 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">예를 들어이 프로젝트 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e330faf79858eff15ab1fa16b480f9af8a75e723" translate="yes" xml:space="preserve">
          <source>For example if you wanted to use &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt;, you need a tsconfig like:</source>
          <target state="translated">예를 들어 &lt;code&gt;&quot;jsxImportSource&quot;: &quot;preact&quot;&lt;/code&gt; 를 사용하려면 다음과 같은 tsconfig가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d8da11b0efd47b16f48058eb8799a7168124fbd1" translate="yes" xml:space="preserve">
          <source>For example with this TSConfig:</source>
          <target state="translated">예를 들어이 TSConfig의 경우 :</target>
        </trans-unit>
        <trans-unit id="7eea9d386cac8ef8110732486a228ddec7a04971" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript code, &lt;code&gt;users.find&lt;/code&gt; has no guarantee that it will actually find a user, but you can write code as though it will:</source>
          <target state="translated">예를 들어이 TypeScript 코드에서 &lt;code&gt;users.find&lt;/code&gt; 는 실제로 사용자를 찾을 것이라는 보장은 없지만 다음과 같이 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa37fb2b6671c00d8d1e61a2de6e276f5b9d8e6" translate="yes" xml:space="preserve">
          <source>For example with this TypeScript:</source>
          <target state="translated">예를 들어이 TypeScript를 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bf9c1c74c2f780a51e1fe18b7af85788137a273" translate="yes" xml:space="preserve">
          <source>For example with this code:</source>
          <target state="translated">예를 들어이 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="9589441950a7ba70ac32a866e7cbc78c60f18f3b" translate="yes" xml:space="preserve">
          <source>For example, JavaScript provides language primitives like &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and &lt;code&gt;object&lt;/code&gt;, but it doesn&amp;rsquo;t check that you&amp;rsquo;ve consistently assigned these. TypeScript does.</source>
          <target state="translated">예를 들어 JavaScript는 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; 와 같은 언어 프리미티브를 제공 하지만이를 일관되게 할당했는지 확인하지 않습니다. TypeScript는 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 컴파일에서 파일 중 하나에 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 를 추가하는 것은 &lt;code&gt;--lib es2017.string&lt;/code&gt; 을 사용 하여 컴파일하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 같은 import 문 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 의 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 은 위치에 대해 다음 위치 시도 될 것 &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fb0268932a575e89ddaf5adf469f05cd6fb3e89a" translate="yes" xml:space="preserve">
          <source>For example, can you &lt;em&gt;only&lt;/em&gt; get it through npm or only from a CDN?</source>
          <target state="translated">예를 들어 npm 을 &lt;em&gt;통해서만&lt;/em&gt; 얻을 수 있습니까, 아니면 CDN &lt;em&gt;에서만&lt;/em&gt; 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">예를 들어, 데코레이터 &lt;code&gt;@sealed&lt;/code&gt; 를 사용하면 다음과 같이 &lt;code&gt;sealed&lt;/code&gt; 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e1f04886e8aa232b1f5ca87afb79f3e9db1b4b" translate="yes" xml:space="preserve">
          <source>For example, here is the JavaScript</source>
          <target state="translated">예를 들어 다음은 JavaScript입니다.</target>
        </trans-unit>
        <trans-unit id="379a411593e5b86332a2083bee7043e6f9882715" translate="yes" xml:space="preserve">
          <source>For example, if you had networking requests with consistent error handling then you could separate out the error handling into its own type which is merged with types which correspond to a single response type.</source>
          <target state="translated">예를 들어, 일관된 오류 처리가있는 네트워킹 요청이있는 경우 오류 처리를 단일 응답 유형에 해당하는 유형과 병합되는 자체 유형으로 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="23596f0dc1eff87037eef75f96316f4284f9ed16" translate="yes" xml:space="preserve">
          <source>For example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module &lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt;&lt;code&gt;@tsconfig/node12&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어 Node.js 버전 12 이상을 사용하는 프로젝트를 작성하는 경우 npm 모듈 &lt;a href=&quot;https://www.npmjs.com/package/@tsconfig/node12&quot;&gt; &lt;code&gt;@tsconfig/node12&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">예를 들어 선언 파일에 &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; 를 포함하면이 파일이 &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 선언 된 이름을 사용함을 선언합니다 . 따라서이 패키지는 선언 파일과 함께 컴파일에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">예를 들어, 다른 함수에 전달하기 전에 &lt;code&gt;.then()&lt;/code&gt; 을 잊 거나 &lt;code&gt;Promise&lt;/code&gt; 의 내용을 &lt;code&gt;await&lt;/code&gt; 것이 일반적 입니다. TypeScript의 오류 메시지는 이제 특수화되었으며 사용자에게 &lt;code&gt;await&lt;/code&gt; 키워드 사용을 고려해야한다고 알립니다 .</target>
        </trans-unit>
        <trans-unit id="3ad31453ee6f39d96c1afdaaf6077d0e43f26289" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you had this tree:</source>
          <target state="translated">예를 들어 다음과 같은 트리가 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5c6fd2fe67c6fb7f9ef03666af8aa720461e76ff" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you have some input files:</source>
          <target state="translated">예를 들어 다음과 같은 입력 파일이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">예를 들어, &lt;code&gt;npm install&lt;/code&gt; 유형 선언을 가져 오면 가져 오기를 사용하고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">예를 들어 일부 라이브러리는 &lt;code&gt;Array.prototype&lt;/code&gt; 또는 &lt;code&gt;String.prototype&lt;/code&gt; 에 새 함수를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="8be4ce18dfa625c450ddd4bc1142e60f3523955d" translate="yes" xml:space="preserve">
          <source>For example, the class below returns a function which tries to access &lt;code&gt;this.width&lt;/code&gt; and &lt;code&gt;this.height&lt;/code&gt; &amp;ndash; but the context for &lt;code&gt;this&lt;/code&gt; inside the function inside &lt;code&gt;getAreaFunction&lt;/code&gt; is not the instance of the Rectangle.</source>
          <target state="translated">예를 들어, 반환 아래의 클래스에 액세스하려고하는 기능 &lt;code&gt;this.width&lt;/code&gt; 및 &lt;code&gt;this.height&lt;/code&gt; 을 -하지만 대한 상황 &lt;code&gt;this&lt;/code&gt; 내부 함수 내 &lt;code&gt;getAreaFunction&lt;/code&gt; 는 사각형의 인스턴스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">예를 들어, 다음은 함수 유형의 리턴 유형을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">예를 들어 다음 샘플은 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 를 선언 하고 각각 &lt;code&gt;getSomeObject().x&lt;/code&gt; , &lt;code&gt;getSomeObject().y&lt;/code&gt; 및 &lt;code&gt;getSomeObject().z&lt;/code&gt; 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="db47b423be9c6dadb503643273e40da05e66f4c4" translate="yes" xml:space="preserve">
          <source>For example, this TSX file:</source>
          <target state="translated">예를 들어,이 TSX 파일 :</target>
        </trans-unit>
        <trans-unit id="1f64ae55bad6947723cb4c39980b51075ca559f5" translate="yes" xml:space="preserve">
          <source>For example, this is a TypeScript file which has a JSDoc comment:</source>
          <target state="translated">예를 들어 다음은 JSDoc 주석이있는 TypeScript 파일입니다.</target>
        </trans-unit>
        <trans-unit id="1c40d41ae5f1e7ca8179e936e44a9e441a4508b8" translate="yes" xml:space="preserve">
          <source>For example, this is incorrect JavaScript according to the &lt;code&gt;parseFloat&lt;/code&gt; type definition which comes with TypeScript:</source>
          <target state="translated">예를 들어, 이것은 TypeScript와 함께 제공되는 &lt;code&gt;parseFloat&lt;/code&gt; 유형 정의 에 따르면 잘못된 JavaScript입니다 .</target>
        </trans-unit>
        <trans-unit id="e34c291950276ec5991b5d85beb6f5e3667694b8" translate="yes" xml:space="preserve">
          <source>For example, to create an object with an inferred type which includes &lt;code&gt;name: string&lt;/code&gt; and &lt;code&gt;id: number&lt;/code&gt;, you can write:</source>
          <target state="translated">예를 들어 &lt;code&gt;name: string&lt;/code&gt; 및 &lt;code&gt;id: number&lt;/code&gt; 를 포함하는 유추 된 유형으로 객체를 생성하려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac02d1dd1384ae853294c750a143c0f2d98423a5" translate="yes" xml:space="preserve">
          <source>For example, using this &lt;code&gt;async&lt;/code&gt; function in ES5 requires a &lt;code&gt;await&lt;/code&gt;-like function and &lt;code&gt;generator&lt;/code&gt;-like function to run:</source>
          <target state="translated">예를 들어 ES5 에서이 &lt;code&gt;async&lt;/code&gt; 함수를 사용 하려면 &lt;code&gt;await&lt;/code&gt; 와 같은 함수와 &lt;code&gt;generator&lt;/code&gt; 와 같은 함수를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">예를 들어 클래스에 정적 멤버를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9664482ad4cfe889b90b76aeb2032d715f790d" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which extends another library.</source>
          <target state="translated">예를 들어, 다른 라이브러리를 확장하는 JavaScript 코드로 작업하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="8e00ba77940c0426f8b1134fd175e919b0cb5147" translate="yes" xml:space="preserve">
          <source>For example, when you want to work with JavaScript code which looks like:</source>
          <target state="translated">예를 들어 다음과 같은 JavaScript 코드로 작업하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="ba51f2462f3773f1dc6da5083642677ae6d1eee2" translate="yes" xml:space="preserve">
          <source>For example, with this TypeScript:</source>
          <target state="translated">예를 들어 다음 TypeScript를 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f1959c8518d6114cd18bf03e5cd677c322abf43" translate="yes" xml:space="preserve">
          <source>For example, without &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; as true:</source>
          <target state="translated">예를 들어 &lt;code&gt;allowSyntheticDefaultImports&lt;/code&gt; 가 true로 설정 되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="057ce67e6843578753929fc21dae6a5768fef84b" translate="yes" xml:space="preserve">
          <source>For example, you can make a function return different values depending on whether it is passed a string or an array:</source>
          <target state="translated">예를 들어, 함수가 문자열로 전달되는지 배열로 전달되는지에 따라 다른 값을 반환하도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a5f12f7c7d4059c89ae626ee915d1d0eb216e44" translate="yes" xml:space="preserve">
          <source>For example, you may have complex enough types to describe that you choose to namespace them inside your &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;.d.ts&lt;/code&gt; 내에서 네임 스페이스를 지정하도록 선택하는 것을 설명하기에 충분히 복잡한 유형이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">함수 구성 요소 (이전의 SFC)의 경우 ES2015 기본 초기화 프로그램을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">함수 멤버의 경우 동일한 이름의 각 함수 멤버는 동일한 함수의 오버로드를 설명하는 것으로 간주됩니다. 또한 인터페이스 &lt;code&gt;A&lt;/code&gt; 가 이후 인터페이스 &lt;code&gt;A&lt;/code&gt; 와 병합 하는 경우 두 번째 인터페이스가 첫 번째 인터페이스보다 우선 순위가 높다는 점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">함수 유형이 올바르게 유형을 확인하기 위해 매개 변수 이름이 일치하지 않아도됩니다. 예를 들어 위의 예를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">형식 인수가 지정되지 않은 일반 형식의 경우 지정 되지 않은 모든 형식 인수 대신 &lt;code&gt;any&lt;/code&gt; 의 형식 인수를 지정하여 호환성을 검사합니다 . 그런 다음 일반적인 유형이 아닌 경우와 같이 결과 유형의 호환성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;React.Component&lt;/code&gt; 는 &lt;code&gt;Props&lt;/code&gt; 및 &lt;code&gt;State&lt;/code&gt; 의 두 가지 유형 매개 변수를 갖도록 정의됩니다 . A의 &lt;code&gt;.js&lt;/code&gt; 파일의 절을 확장 이러한를 지정하는 법적 방법이 없습니다. 기본적으로 type 인수는 &lt;code&gt;any&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 모듈 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 로 가져 오기 는 런타임시 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">예를 들어 &lt;code&gt;Object&lt;/code&gt; 로 입력 한 것이 있으면 &lt;code&gt;toLowerCase()&lt;/code&gt; 와 같은 메소드를 호출 할 수 없습니다 . 보다 일반적인 있다는 것은 일반적으로이 유형을 덜 할 수 있다는 것을 의미하지만, &lt;code&gt;any&lt;/code&gt; 여전히 당신이 그것으로 아무것도 할 수 있도록하면서 가장 일반적인 유형이 있다는 점에서 특별하다. 당신이 사용할 때마다, 비록 당신이 그것을 호출을 만들 수 있다는 것을 의미합니다 그것에 액세스 특성 등 명심 &lt;code&gt;any&lt;/code&gt; 타이프 라이터가 당신을 제공합니다, 당신은 오류 검사 및 편집기 지원의 대부분을 놓치게.</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">예를 들어 다음 인터페이스가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">내장 요소의 경우 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 의 속성 유형입니다.</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">프로젝트 참조를 활용하기 위해 새로운 &lt;code&gt;createSolutionBuilder&lt;/code&gt; 함수가 노출되어 새로운 유형의 &lt;code&gt;SolutionBuilder&lt;/code&gt; 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">변경에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;여기서 pull 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">구현에 대한 자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;은 기능의 풀 요청을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">이러한 API에 대한 자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;은 원래 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;GitHub의에서 끌어 오기 요청 추가 참조 &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt; 뿐만 아니라, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;사용하는 변화 &lt;code&gt;Omit&lt;/code&gt; 객체 나머지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;은 GitHub의 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">자세한 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;내용은 원래 문제&lt;/a&gt; 와 다시 연결되는 끌어 오기 요청을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;내용은 해당 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;은 GitHub의 원본 PR을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;은 해당 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;은 원래 변경 사항에서 자세히 읽어보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;은 GitHub에서 원본 풀 요청을 확인할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;은 원래 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">자세한 내용은 풀 요청을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">모듈과 네임 스페이스에 대한 자세한 내용은 &lt;a href=&quot;namespaces-and-modules&quot;&gt;네임 스페이스 및 모듈을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">모듈에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 모듈 지원 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d6421ff56f450a4d8627e4516ee9a9c34657258" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">일시적인 데드 존에 대한 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla 개발자 네트워크&lt;/a&gt; 의 관련 콘텐츠를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">임시 데드 존에 대한 자세한 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla 개발자 네트워크&lt;/a&gt; 의 관련 컨텐츠를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ab5ee6f96a4e7a69065dcddd9a55b08eb5aae39" translate="yes" xml:space="preserve">
          <source>For more information on these flags:</source>
          <target state="translated">이러한 플래그에 대한 자세한 내용은 다음을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;비동기 함수&lt;/a&gt; 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;는 관련 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;데코레이터&lt;/a&gt; 제안을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;은 원래 풀 요청을 읽으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;은 이러한 변경에 대한 원래 풀 요청을 살펴보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">상대적이 아닌 모듈 가져 오기의 경우 컴파일러는 가져 오기 파일이 포함 된 디렉토리부터 시작하여 일치하는 정의 파일을 찾으려고 디렉토리 트리를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="d23566da87d8229f77380a239e48562a8a823cce" translate="yes" xml:space="preserve">
          <source>For npm users:</source>
          <target state="translated">npm 사용자의 경우 :</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">우선, TypeScript는 호출의 리턴 유형을 추론 할 수 있습니다. 이것은 경험을 향상시키고 오류를 잡을 수 있습니다. 이제 작동하는 것 :</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">프로그램이 유용하기 위해서는 숫자, 문자열, 구조, 부울 값 등과 같은 가장 간단한 데이터 단위로 작업 할 수 있어야합니다. TypeScript에서는 JavaScript에서 예상하는 것과 거의 동일한 유형을 지원하며 편리한 열거 유형을 사용하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="15f0842c032b4d0063a3b23f1886d7cbeefa49c8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.</source>
          <target state="translated">프로그램이 유용하려면 숫자, 문자열, 구조, 부울 값 등과 같은 가장 간단한 데이터 단위로 작업 할 수 있어야합니다. TypeScript에서 우리는 자바 스크립트에서 기대하는 것과 동일한 유형을 지원하며, 추가 열거 유형을 던져서 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">선언 파일 작동 방식의 기본 메커니즘에 관심이있는 숙련 된 작성자를 위해 &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; 섹션에서는 선언 작성의 많은 고급 개념을 설명하고 이러한 개념을 활용하여보다 명확하고 직관적 인 선언 파일을 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">따라서 하위 수준의 지원을 제공 할 즉각적인 계획은 없습니다. 당신이 BigInts가 목표로 할 때 사용할 수 있습니다, 그래서 밝은 측면에서, 노드 (11)와 크롬의 최신 버전은 이미이 기능을 지원 &lt;code&gt;esnext&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="496e704960f5aa1a3e087ed13654d88d3dfbb5fa" translate="yes" xml:space="preserve">
          <source>For the first definition of &lt;code&gt;createElement&lt;/code&gt;, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt;. This expression defines a generic parameter &lt;code&gt;K&lt;/code&gt; that is &lt;em&gt;constrained&lt;/em&gt; to the keys of the interface &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt;. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; 의 첫 번째 정의를 위해 몇 가지 고급 일반 패턴을 사용하고 있습니다. 일반 표현식 &lt;code&gt;&amp;lt;K extends keyof HTMLElementTagNameMap&amp;gt;&lt;/code&gt; 으로 시작하여 청크로 분할하는 것이 가장 좋습니다 . 이 표현식은 &lt;code&gt;HTMLElementTagNameMap&lt;/code&gt; 인터페이스의 키로 &lt;em&gt;제한&lt;/em&gt; 되는 일반 매개 변수 &lt;code&gt;K&lt;/code&gt; 를 정의합니다 . 맵 인터페이스에는 지정된 모든 HTML 태그 이름과 해당 유형 인터페이스가 포함됩니다. 예를 들어 다음은 처음 5 개의 매핑 된 값입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">대부분의 경우 유형 선언 패키지는 항상 &lt;code&gt;npm&lt;/code&gt; 의 패키지 이름과 이름이 같아야 하지만 접두사가 &lt;code&gt;@types/&lt;/code&gt; 이지만 필요한 경우 &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; 를 확인 하여 패키지를 찾을 수 있습니다 가장 좋아하는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="bf75b06c8fc661aa3a2f64f5da3a4e9c2051e897" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;this Type Search&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">대부분의 경우 유형 선언 패키지는 항상 &lt;code&gt;npm&lt;/code&gt; 의 패키지 이름과 동일한 이름을 가져야 하지만 &lt;code&gt;@types/&lt;/code&gt; 접두사가 붙어야 하지만 필요한 &lt;a href=&quot;https://aka.ms/types&quot;&gt;경우이 유형 검색&lt;/a&gt; 을 확인 하여 좋아하는 라이브러리에 대한 패키지를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">이 기사의 목적 상 &quot;선언 병합&quot;은 컴파일러가 동일한 이름으로 선언 된 두 개의 개별 선언을 단일 정의로 병합 함을 의미합니다. 이 병합 된 정의에는 원래 선언 모두의 기능이 있습니다. 여러 선언을 병합 할 수 있습니다. 단지 두 가지 선언에만 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">선언 파일을 작성하기 위해 변경중인 모듈이 일반 모듈인지 UMD 모듈인지에 관계없이 동일한 코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">이 기능과 단순화 된 소품의 경우 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;최신 버전의 react.d.ts를 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c1668e641a54e156c170e61580f6a7e55c2d3f64" translate="yes" xml:space="preserve">
          <source>For those interested, you can interact with custom tag elements using the &lt;code&gt;document.getElementsByTagName&lt;/code&gt;</source>
          <target state="translated">관심있는 사람들을 위해 &lt;code&gt;document.getElementsByTagName&lt;/code&gt; 을 사용하여 사용자 정의 태그 요소와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">익숙하지 않은 사람들 을 위해 &lt;code&gt;setTimeout&lt;/code&gt; 은 특정 시간 (밀리 초) 후에 함수 실행을 시도합니다 (다른 것이 실행을 멈출 때까지 기다립니다).</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">가치 기반 요소의 경우 조금 더 복잡합니다. 이전에 결정된 &lt;em&gt;요소 인스턴스 유형&lt;/em&gt; 의 특성 &lt;em&gt;유형&lt;/em&gt; 에 따라 결정됩니다. 사용할 특성은 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 에 의해 결정됩니다 . 단일 속성으로 선언해야합니다. 그런 다음 해당 속성의 이름이 사용됩니다. TypeScript 2.8에서 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 가 제공되지 않으면 클래스 요소 생성자의 첫 번째 매개 변수 유형 또는 함수 구성 요소 호출이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec762285a1b4a4ed67329132319bc54b9b6e3580" translate="yes" xml:space="preserve">
          <source>Force Consistent Casing In File Names - &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</source>
          <target state="translated">파일 이름에 일관된 &lt;code&gt;forceConsistentCasingInFileNames&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5aa86e5ed9112fe776d6f8c8f31ff44490232e" translate="yes" xml:space="preserve">
          <source>Free Functions and Data</source>
          <target state="translated">무료 기능 및 데이터</target>
        </trans-unit>
        <trans-unit id="a5600addb2b77d2558fa7ff723f4b60ade1a0397" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7 이상에서는 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining&quot;&gt;선택적 연결&lt;/a&gt; 을 사용하여 nullable 형식 작업을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7 이상에서는 &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;선택적 체인&lt;/a&gt; 을 사용하여 nullable 형식 작업을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="978d60f8509ec4db7ded456faee49383919753b1" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.8 onwards, you can use JSDoc to modify the properties in a class. First are the accessibility modifiers: &lt;code&gt;@public&lt;/code&gt;, &lt;code&gt;@private&lt;/code&gt;, and &lt;code&gt;@protected&lt;/code&gt;. These tags work exactly like &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, and &lt;code&gt;protected&lt;/code&gt; respectively work in TypeScript.</source>
          <target state="translated">TypeScript 3.8부터는 JSDoc을 사용하여 클래스의 속성을 수정할 수 있습니다. 첫 번째는 접근성 수정 자입니다 : &lt;code&gt;@public&lt;/code&gt; , &lt;code&gt;@private&lt;/code&gt; 및 &lt;code&gt;@protected&lt;/code&gt; . 이러한 태그는 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 각각 TypeScript에서 작동하는 것과 똑같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">글로벌 도서관에서</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">모듈 또는 UMD 라이브러리에서</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">PowerShell 명령 창에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b107342b8b3dda22c1b15ba7f4fbcc3adcc5a2ea" translate="yes" xml:space="preserve">
          <source>From here, we&amp;rsquo;d recommend learning some of the JavaScript fundamentals (the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;JavaScript guide at the Mozilla Web Docs&lt;/a&gt; is a good starting point.)</source>
          <target state="translated">여기에서 몇 가지 JavaScript 기본 사항을 배우는 것이 좋습니다 ( &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;Mozilla 웹 문서&lt;/a&gt; 의 JavaScript 가이드 가 좋은 출발점입니다).</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">거기에서 TypeScript 코드에 lodash를 사용할 수 있습니다. 이것은 모듈과 전역 코드 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">이제부터는 디렉토리가 다음과 같이 설정되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">기능 구성 요소 (FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">반응의 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">기능 과부하</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">함수 모수 이변 량</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">기능성 검사</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">기능 유형</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">기능 매개 변수는 한 번에 하나씩 점검되며, 해당하는 각 매개 변수 위치의 유형이 서로 대조됩니다. 유형을 전혀 지정하지 않으려는 경우 함수 값이 &lt;code&gt;SearchFunc&lt;/code&gt; 유형의 변수에 직접 지정되므로 TypeScript의 상황 별 입력이 인수 유형을 유추 할 수 있습니다 . 또한 함수 표현식의 반환 유형은 반환하는 값 (여기서는 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; )으로 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">기능 매개 변수는 기본적으로 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="ed95afc615d05f6e5368c71005cf262d6343db73" translate="yes" xml:space="preserve">
          <source>Function syntax includes parameter names. This is pretty hard to get used to!</source>
          <target state="translated">함수 구문에는 매개 변수 이름이 포함됩니다. 이것은 익숙해지기가 꽤 어렵습니다!</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">함수는 JavaScript에서 모든 응용 프로그램의 기본 구성 요소입니다. 그것들은 추상화 계층, 모방 클래스, 정보 숨기기 및 모듈을 구축하는 방법입니다. TypeScript에는 클래스, 네임 스페이스 및 모듈이 있지만 함수 &lt;em&gt;는&lt;/em&gt; 작업 &lt;em&gt;수행&lt;/em&gt; 방법을 설명하는 데 여전히 중요한 역할을합니다 . TypeScript는 또한 표준 JavaScript 함수에 몇 가지 새로운 기능을 추가하여보다 쉽게 ​​작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">JS에서 값을 반환하지 않는 코드 경로를 가진 함수는 암시 적으로 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다. 이것들은 이제 컴파일러에 의해 암시 적 리턴으로 플래그 될 수 있습니다. 검사는 기본적 으로 &lt;em&gt;해제&lt;/em&gt; 되어 있습니다. 켜 려면 &lt;code&gt;--noImplicitReturns&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">과부하 기능</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">기능 :이</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">또한 TypeScript에는 &lt;code&gt;declare global { }&lt;/code&gt; 형식 의 &lt;em&gt;전역&lt;/em&gt; 기능 보강 개념이 있습니다. 이를 통해 모듈은 필요한 경우 &lt;code&gt;Array&lt;/code&gt; 와 같은 전역 유형을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드에서 제어 흐름 기반 유형 분석에는 &lt;code&gt;undefined&lt;/code&gt; 값을 허용하지 않는 유형의 지역 변수에 대한 &lt;em&gt;명확한 할당 분석이&lt;/em&gt; 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">또한 &lt;code&gt;keyof&lt;/code&gt; 연산자가 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;symbol&lt;/code&gt; 명명 된 키를 지원하므로 숫자 리터럴 (예 : 숫자 열거 형 유형) 및 고유 기호로 색인이 생성 된 객체의 속성에 대한 액세스를 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a55d7b2a4c629fc605606fd7d8bd91685e04a3" translate="yes" xml:space="preserve">
          <source>Future versions of TypeScript may introduce additional stricter checking under this flag, so upgrades of TypeScript might result in new type errors in your program. When appropriate and possible, a corresponding flag will be added to disable that behavior.</source>
          <target state="translated">이후 버전의 TypeScript는이 플래그 아래에서 추가로 더 엄격한 검사를 도입 할 수 있으므로 TypeScript를 업그레이드하면 프로그램에서 새로운 유형 오류가 발생할 수 있습니다. 적절하고 가능한 경우 해당 동작을 비활성화하기 위해 해당 플래그가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="31aa08b13ef05b660d703277cd9eaf4495dd69d5" translate="yes" xml:space="preserve">
          <source>Generally, you won&amp;rsquo;t need to use this.</source>
          <target state="translated">일반적으로 이것을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b96ccfadf72cdc8e8186c38b80b976cc57f7091" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.d.ts&lt;/code&gt; files for every TypeScript or JavaScript file inside your project. These &lt;code&gt;.d.ts&lt;/code&gt; files are type definition files which describe the external API of your module. With &lt;code&gt;.d.ts&lt;/code&gt; files, tools like TypeScript can provide intellisense and accurate types for un-typed code.</source>
          <target state="translated">프로젝트 내의 모든 TypeScript 또는 JavaScript 파일에 대해 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성 합니다. 이러한 &lt;code&gt;.d.ts&lt;/code&gt; 파일은 모듈의 외부 API를 설명하는 유형 정의 파일입니다. &lt;code&gt;.d.ts&lt;/code&gt; 파일을 사용하면 TypeScript 와 같은 도구가 형식화되지 않은 코드에 대해 지능적이고 정확한 형식을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437f20984d6e132889941d988b14b86cfa9f9862" translate="yes" xml:space="preserve">
          <source>Generate CPU Profile - &lt;code&gt;generateCpuProfile&lt;/code&gt;</source>
          <target state="translated">CPU 프로파일을 생성 - &lt;code&gt;generateCpuProfile&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">생성 된 JS 코드 :</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">주어진 경로에서 CPU 프로파일을 생성합니다. 파일 경로 대신 기존 디렉토리 이름을 전달하면 해당 디렉토리에 타임 스탬프 이름이 지정된 프로파일이 대신 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="dfdc500a2df569ef69f2127f8241641852a3dbd0" translate="yes" xml:space="preserve">
          <source>Generates a source map for &lt;code&gt;.d.ts&lt;/code&gt; files which map back to the original &lt;code&gt;.ts&lt;/code&gt; source file. This will allow editors such as VS Code to go to the original &lt;code&gt;.ts&lt;/code&gt; file when using features like &lt;em&gt;Go to Definition&lt;/em&gt;.</source>
          <target state="translated">원래 &lt;code&gt;.ts&lt;/code&gt; 소스 파일에 다시 매핑되는 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 대한 소스 맵을 생성 합니다. 이렇게하면 &lt;em&gt;정의로 이동&lt;/em&gt; 과 같은 기능을 사용할 때 VS Code와 같은 편집기가 원본 &lt;code&gt;.ts&lt;/code&gt; 파일 로 이동할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">해당하는 '.d.ts'파일 각각에 대한 소스 맵을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ba70dfbfb3ac05d2ef01a114d8d061e0873111b" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">각 해당 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 대한 소스 맵을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">해당 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">해당 &lt;code&gt;.map&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5 / ES3의 생성기 및 반복</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">일반 클래스</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">일반 제약</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">제네릭 형식</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">일반 오브젝트 레스트 변수 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">일반 매개 변수 기본값</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">일반 휴식 매개 변수</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">일반 휴식 매개 변수 및 해당 튜플 유형의 추론.</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">객체 리터럴의 일반 스프레드 표현식</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">제네릭 형식 별칭</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX 요소의 제네릭 형식 인수</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">일반 태그 템플릿의 일반 유형 인수</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="db53d33f081c24d027b3c7e1e7024838559d94b2" translate="yes" xml:space="preserve">
          <source>Generics provide variables to types. A common example is an array. An array without generics could contain anything. An array with generics can describe the values that the array contains.</source>
          <target state="translated">제네릭은 유형에 변수를 제공합니다. 일반적인 예는 배열입니다. 제네릭이없는 배열에는 모든 것이 포함될 수 있습니다. 제네릭이있는 배열은 배열에 포함 된 값을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">제네릭 : 유형</target>
        </trans-unit>
        <trans-unit id="bd2cb051773a703fdbabd8c09f218722870e6d61" translate="yes" xml:space="preserve">
          <source>Get Started</source>
          <target state="translated">시작하다</target>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">간단한 TypeScript 앱으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">선언 파일 얻기</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">더 엄격한 검사 받기</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">이러한 점검을 해결하는 것은 실제로 매우 간단합니다. 가장 쉬운 방법은 형식 어설 션을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">ES6 / ES2015 기본 제공 API 선언은 &lt;code&gt;target: ES6&lt;/code&gt; 으로 만 제한되었습니다 . &lt;code&gt;--lib&lt;/code&gt; 를 입력하십시오 . 함께 &lt;code&gt;--lib&lt;/code&gt; 당신이 API 선언 그룹의 내장의 목록을 지정할 수 있습니다 당신은 당신의 프로젝트에 포함하기로 결정했습니다 수있다. 예를 들어, 런타임에서 &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt; (예 : 오늘날 상록 브라우저)를 지원할 것으로 예상되는 경우 &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; 를 포함하십시오 . 마찬가지로 &lt;code&gt;--lib es5,es6&lt;/code&gt; 을 사용하여 노드 프로젝트에서 작업중인 경우 프로젝트에 포함하지 않으려는 선언을 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">TypeScript 2.0 이상에서 형식 선언을 가져 오려면 npm 이외의 도구가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ad931cf8eb2acc56be9415f5e0a4f34de91ca82" translate="yes" xml:space="preserve">
          <source>Getting type declarations requires no tools apart from npm.</source>
          <target state="translated">유형 선언을 얻으려면 npm 외에 도구가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">을 감안할 때 &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; 의 &lt;em&gt;요소 클래스 유형&lt;/em&gt; 의 유형입니다 &lt;code&gt;Expr&lt;/code&gt; . 위의 예에서 &lt;code&gt;MyComponent&lt;/code&gt; 가 ES6 클래스 인 경우 클래스 유형은 해당 클래스의 생성자 및 정적입니다. 경우 &lt;code&gt;MyComponent&lt;/code&gt; 공장 기능이고, 클래스 타입은 함수가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">모듈 파일에서 &lt;code&gt;Pet&lt;/code&gt; 클래스를 선언하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">이름이 주어 , 우리는 세 가지 다른 의미까지 찾을 수 있습니다 유형, 값 또는 네임 스페이스 :. 이름이 해석되는 방법은 사용되는 컨텍스트에 따라 다릅니다. 예를 들어 선언에서 &lt;code&gt;let m: A.A = A;&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 다음의 값으로, 다음 형태의 이름과 같은 공간으로 먼저 사용된다. 이러한 의미는 완전히 다른 선언을 의미 할 수 있습니다! &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="368b78c1924bb611f6364ba9c26348188f7788e5" translate="yes" xml:space="preserve">
          <source>Given a simplified &lt;em&gt;index.html&lt;/em&gt; file:</source>
          <target state="translated">단순화 된 &lt;em&gt;index.html&lt;/em&gt; 파일이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">제약 조건 &lt;code&gt;X&lt;/code&gt; 가있는 파라 메트릭 유형 &lt;code&gt;T&lt;/code&gt; 의 표현식 &lt;code&gt;Base&lt;/code&gt; 가 주어지면 , 믹스 인 클래스 &lt;code&gt;class C extends Base {...}&lt;/code&gt; 는 &lt;code&gt;Base&lt;/code&gt; 에 유형 &lt;code&gt;X&lt;/code&gt; 가 있고 결과 유형이 &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 의 교차 유형 인 것처럼 처리됩니다 . 즉, 믹스 인 클래스는 믹스 인 클래스 생성자 유형과 파라 메트릭 기본 클래스 생성자 유형 사이의 교차로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 객체 유형이 주어지면 X 의 &lt;code&gt;keyof X&lt;/code&gt; 는 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">범위 지정 의미가 비슷한 두 가지 유형의 선언이 있기 때문에 어느 것을 사용해야하는지 스스로 찾는 것이 당연합니다. 가장 광범위한 질문과 마찬가지로 대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c71bdff34c04312e874f58b0595438841c748916" translate="yes" xml:space="preserve">
          <source>Given the &lt;code&gt;state&lt;/code&gt; field is common in every type inside &lt;code&gt;NetworkState&lt;/code&gt; - it is safe for your code to access without an existence check.</source>
          <target state="translated">주어진 &lt;code&gt;state&lt;/code&gt; 필드 것은 내부의 모든 유형에 공통 &lt;code&gt;NetworkState&lt;/code&gt; - 그것이 생존 확인없이 액세스 코드에 대한 안전합니다.</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">이 프로젝트 구조가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 에서 전역 지원</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">세계적 지원이 여기 있습니다! Glob 지원은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;가장 많이 요청 된 기능 중 하나입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">전 세계와 유사한 파일 패턴은 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 두 가지 특성이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cc9c6744751ed4cf4a2b29e9b22ac831592172b" translate="yes" xml:space="preserve">
          <source>Global .d.ts</source>
          <target state="translated">글로벌 .d.ts</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">글로벌 함수</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">글로벌 라이브러리</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">글로벌 라이브러리 템플릿</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">글로벌 확대</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">글로벌 기능 보강은 모듈 기능 보강과 동일한 동작 및 한계를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">전역 라이브러리 코드는 일반적으로 매우 간단합니다. 글로벌&amp;ldquo;Hello, world&amp;rdquo;라이브러리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">글로벌 플러그인은 일반적으로 문서에서 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">전역 수정 모듈은 일반적으로 문서에서 쉽게 식별 할 수 있습니다. 일반적으로 글로벌 플러그인과 비슷하지만 효과를 활성화 &lt;code&gt;require&lt;/code&gt; 호출이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="985e370903f557eb77f2957da19dbd086883f48f" translate="yes" xml:space="preserve">
          <source>Global: Modifying Module</source>
          <target state="translated">글로벌 : 모듈 수정</target>
        </trans-unit>
        <trans-unit id="bc6922ba498ce785a869200f44c3ccbf5a4f68f2" translate="yes" xml:space="preserve">
          <source>Global: Plugin</source>
          <target state="translated">글로벌 : 플러그인</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">이동 &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">이동 &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86d8b5a249b3cc55d73040fe87c867b93ac1ecb6" translate="yes" xml:space="preserve">
          <source>Going back to the idea of &lt;em&gt;types as sets&lt;/em&gt;, we can think of &lt;code&gt;obj&lt;/code&gt; as being a member of both the &lt;code&gt;Pointlike&lt;/code&gt; set of values and the &lt;code&gt;Named&lt;/code&gt; set of values.</source>
          <target state="translated">&lt;em&gt;유형이 집합&lt;/em&gt; 이라는 개념으로 돌아가서 &lt;code&gt;obj&lt;/code&gt; 를 &lt;code&gt;Pointlike&lt;/code&gt; 값 집합과 &lt;code&gt;Named&lt;/code&gt; 값 집합의 구성원으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e05780e3cac998950011571da3d75ed12a7e2108" translate="yes" xml:space="preserve">
          <source>Gradual typing</source>
          <target state="translated">점진적 타이핑</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">모듈 구조화에 대한 지침</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">Gulp : 코드에 모듈 추가</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">꿀꺽 : 바벨</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">펄프 : Browserify</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp : gulpfile.js 만들기</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">꿀꺽 : 페이지 만들기</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Gulp : 프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Gulp : 의존성 설치</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">Gulp : 최소 프로젝트</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Gulp : 결과 앱 테스트</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">꿀꺽 꿀꺽 마시다</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">꿀꺽 : Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">Gulp : 간단한 예제 작성</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">함수 표현식에서 숫자 또는 문자열을 반환 한 경우 형식 검사기는 반환 형식이 &lt;code&gt;SearchFunc&lt;/code&gt; 인터페이스에 설명 된 반환 형식과 일치하지 않음을 나타내는 오류를 발생 시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="048279b51d66beecd8037dba2d0ea88f2006f017" translate="yes" xml:space="preserve">
          <source>Handbook</source>
          <target state="translated">Handbook</target>
        </trans-unit>
        <trans-unit id="60e7f26d0bfbb76e605b8559ae9629c763bda244" translate="yes" xml:space="preserve">
          <source>Handbook Reference</source>
          <target state="translated">Handbook Reference</target>
        </trans-unit>
        <trans-unit id="025c00357defd4539f61638601fbe4d91d8be15e" translate="yes" xml:space="preserve">
          <source>Handbook v2: Beta</source>
          <target state="translated">Handbook v2: Beta</target>
        </trans-unit>
        <trans-unit id="47336902c998cc0d39cea91a005587dbb3655556" translate="yes" xml:space="preserve">
          <source>Handling Many Consuming Import</source>
          <target state="translated">많은 소비 수입 처리</target>
        </trans-unit>
        <trans-unit id="8c3f9ca937ff27ba265d41da2558bebb545acf05" translate="yes" xml:space="preserve">
          <source>Have recompiles in &lt;code&gt;--incremental&lt;/code&gt; and &lt;code&gt;--watch&lt;/code&gt; assume that changes within a file will only affect files directly depending on it</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 및 &lt;code&gt;--watch&lt;/code&gt; 에서 다시 컴파일 하면 파일 내의 변경 사항이 파일에 직접적으로 영향을 미친 다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">제네릭 세계</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;asserts val is string&lt;/code&gt; 임을 주장 합니다. &lt;code&gt;assertIsString&lt;/code&gt; 을 호출 한 후 전달 된 모든 변수는 &lt;code&gt;string&lt;/code&gt; 로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">여기서 &lt;code&gt;map.ts&lt;/code&gt; 는 &lt;code&gt;observable.ts&lt;/code&gt; 에서 &lt;code&gt;Observable&lt;/code&gt; 유형을 내부적으로 패치 하고 &lt;code&gt;map&lt;/code&gt; 메소드를 추가 할 것이라고 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7da085e82459c85f19fe707c9181a9e46b7b5cc" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">다음은 &lt;code&gt;.ts&lt;/code&gt; 파일 과 비교하여 &lt;code&gt;.js&lt;/code&gt; 파일 에서 검사가 작동하는 방식에 대한 몇 가지 주목할만한 차이점입니다 .</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">다음은 &lt;code&gt;.ts&lt;/code&gt; 파일 과 비교하여 &lt;code&gt;.js&lt;/code&gt; 파일 에서 검사가 작동하는 방식에 대한 몇 가지 주목할만한 차이점입니다 .</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">사용 가능한 API 그룹 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">다음은 잘 알려진 기호 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">다음은 노출 된 &lt;code&gt;test&lt;/code&gt; 기능을 사용한 간단한 계산기 테스트 입니다.</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="translated">다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">다음은 이러한 차이점을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">여기서 구문은 혼란스러워지기 시작합니다. &lt;code&gt;a: newName1&lt;/code&gt; 을 &quot; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &quot; 로 읽을 수 있습니다 . 당신이 쓴 것처럼 방향은 왼쪽에서 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="38b470aca3704e2927b6fc439cdffa46d4653713" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;rdquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">여기서 구문이 혼란스러워지기 시작합니다. &lt;code&gt;a: newName1&lt;/code&gt; as&amp;rdquo; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &amp;rdquo;을 읽을 수 있습니다 . 당신이 쓴 것처럼 방향은 왼쪽에서 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">여기서 우리는 &lt;code&gt;T&lt;/code&gt; 를 함수 호출에 대한 인수 중 하나로 &lt;code&gt;string&lt;/code&gt; 로 명시 적으로 설정 하고 &lt;code&gt;()&lt;/code&gt; 대신 인수 주위에 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 사용하여 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">여기서는 이웃 맵을 유지하기 위해 변수를 만들어야 초기화 할 수 있습니다. TypeScript 1.5를 사용하면 컴파일러에서 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">여기서 &lt;code&gt;Omit&lt;/code&gt; 도우미를 사용하여 &lt;code&gt;location&lt;/code&gt; 를 제외한 &lt;code&gt;Person&lt;/code&gt; 의 모든 속성을 복사 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">여기 에서는 생성자와 몇 개의 공개 필드가 있는 &lt;code&gt;Student&lt;/code&gt; 클래스 를 만듭니다 . 클래스와 인터페이스는 서로 잘 어울리므로 프로그래머는 올바른 추상화 수준을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">다음은 TypeScript에 몇 가지 사항을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb80aa21b4ae837ee53363a494d841d8934317d2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a basic example with &lt;code&gt;strictFunctionTypes&lt;/code&gt; off:</source>
          <target state="translated">다음은 &lt;code&gt;strictFunctionTypes&lt;/code&gt; 를 끈 기본 예입니다 .</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">다음은 수정 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">도달 할 수없는 코드 오류의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">이 패턴의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="213ae2c641322b822eadac21eb578a78502cdaed" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how the error happens:</source>
          <target state="translated">오류가 발생하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">다음은 &lt;strong&gt;인덱스 유형 쿼리&lt;/strong&gt; 및 &lt;strong&gt;인덱스 액세스&lt;/strong&gt; 연산자를 사용하여 TypeScript에서이 함수를 작성하고 사용하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">&lt;code&gt;T[P]&lt;/code&gt; 가 &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; 클래스에 래핑 된 예가 하나 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a63587f4e1d9560ec04fcfe839944b3ae506477b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some example output for this file:</source>
          <target state="translated">다음은이 파일의 출력 예입니다.</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">여기서 &lt;code&gt;SomeType&lt;/code&gt; 은 &lt;code&gt;import&lt;/code&gt; 선언과 로컬 &lt;code&gt;interface&lt;/code&gt; 선언 모두에서 시작된 것으로 보입니다 . 놀랍게도 모듈 내부에서 &lt;code&gt;SomeType&lt;/code&gt; 은 &lt;code&gt;import&lt;/code&gt; 정의를 독점적으로 참조 하며 로컬 선언 &lt;code&gt;SomeType&lt;/code&gt; 은 다른 파일에서 가져올 때만 사용할 수 있습니다. 이것은 매우 혼란스럽고 매우 적은 수의 코드 사례를 검토 한 결과 개발자는 일반적으로 뭔가 다른 일이 일어나고 있다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">여기서 &lt;code&gt;Up&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 값을 , &lt;code&gt;Down&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 등을 갖습니다 .이 자동 증가 동작은 멤버 값 자체는 신경 쓰지 않지만 각 값이 같은 다른 값과 구별되는 경우에 유용합니다. 열거 형.</target>
        </trans-unit>
        <trans-unit id="7add7dc4368781c75bdc4173ec3100b108107d32" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it because the error message includes the missing type name.</source>
          <target state="translated">여기서 &lt;code&gt;assertNever&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;never&lt;/code&gt; 유형 인지 확인합니다 . 다른 모든 경우가 제거 된 후 남은 유형입니다. 케이스를 잊은 경우 &lt;code&gt;s&lt;/code&gt; 는 실제 유형을 가지며 유형 오류가 발생합니다. 이 방법을 사용하려면 추가 함수를 정의해야하지만 오류 메시지에 누락 된 유형 이름이 포함되어 있기 때문에 잊어 버린 경우 훨씬 더 분명합니다.</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">여기에서 &lt;code&gt;assertNever&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;never&lt;/code&gt; 유형 인지 확인합니다 . 다른 모든 사례가 제거 된 후 남은 유형입니다. 대소 문자를 잊어 버린 경우 &lt;code&gt;s&lt;/code&gt; 는 실제 유형을 가지며 유형 오류가 발생합니다. 이 방법을 사용하려면 추가 기능을 정의해야하지만 잊었을 때 훨씬 더 분명합니다.</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">여기서 &lt;code&gt;let Greeter&lt;/code&gt; 에 생성자 함수가 할당되도록합니다. &lt;code&gt;new&lt;/code&gt; 를 호출 하고이 함수를 실행하면 클래스의 인스턴스를 얻습니다. 생성자 함수에는 클래스의 모든 정적 멤버도 포함됩니다. 각 클래스를 생각하는 또 다른 방법은 &lt;em&gt;인스턴스&lt;/em&gt; 측과 &lt;em&gt;정적&lt;/em&gt; 측 이 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a0aeea38a3dd24023c3fa8431f6367d7d758da1c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;n: number&lt;/code&gt; in this example also, despite the fact that &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have not been inferred before the call. In fact, after &lt;code&gt;[1,2,3]&lt;/code&gt; has been used to infer &lt;code&gt;T=number&lt;/code&gt;, the return type of &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; is used to infer &lt;code&gt;U=string&lt;/code&gt;, causing &lt;code&gt;sns&lt;/code&gt; to have the type &lt;code&gt;string[]&lt;/code&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;n: number&lt;/code&gt; 이 예제에서도 숫자 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가 호출 전에 추론되지 않았 음에도 불구하고 . 실제로 &lt;code&gt;[1,2,3]&lt;/code&gt; 을 사용하여 &lt;code&gt;T=number&lt;/code&gt; 를 추론 한 후 &lt;code&gt;n =&amp;gt; n.toString()&lt;/code&gt; 의 반환 유형을 사용하여 &lt;code&gt;U=string&lt;/code&gt; 을 추론 하여 &lt;code&gt;sns&lt;/code&gt; 가 &lt;code&gt;string[]&lt;/code&gt; 유형을 갖도록합니다 .</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">여기서 TypeScript는 &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; 패키지를 찾는 &lt;code&gt;node_modules&lt;/code&gt; 폴더를 위로 올립니다 . 이러한 각 패키지에 대해 TypeScript는 먼저 &lt;code&gt;package.json&lt;/code&gt; 에 &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; 필드 가 포함되어 있는지 확인 하고, 포함되어 있으면 TypeScript는 해당 필드에서 구성 파일을로드하려고 시도합니다. 둘 다 존재하지 않으면 TypeScript는 루트 의 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 읽습니다 . 이는 Node에서 사용하는 패키지의 &lt;code&gt;.js&lt;/code&gt; 파일 조회 프로세스와 TypeScript에서 이미 사용 하는 &lt;code&gt;.d.ts&lt;/code&gt; 조회 프로세스와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">여기서 패키지는 &lt;code&gt;browserify&lt;/code&gt; 및 &lt;code&gt;typescript&lt;/code&gt; 패키지 에 따라 다릅니다 . &lt;code&gt;browserify&lt;/code&gt; 는 선언 파일을 npm 패키지와 함께 제공하지 않으므로 선언을 위해 &lt;code&gt;@types/browserify&lt;/code&gt; 를 사용해야했습니다 . 반면에 &lt;code&gt;typescript&lt;/code&gt; 는 선언 파일을 패키지하므로 추가 종속성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">여기서 &lt;code&gt;pickCard&lt;/code&gt; 함수는 사용자가 전달한 내용에 따라 서로 다른 두 가지를 반환합니다. 사용자가 데크를 나타내는 객체를 전달하면 함수가 카드를 선택합니다. 사용자가 카드를 선택하면 선택한 카드를 알려줍니다. 그러나 이것을 유형 시스템에 어떻게 설명합니까?</target>
        </trans-unit>
        <trans-unit id="eaeffdb6112e2f8dae638c67608f6ba2778d3117" translate="yes" xml:space="preserve">
          <source>Here, the TypeScript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">여기서 TypeScript 유형 검사기는 &lt;code&gt;Window.onmousedown&lt;/code&gt; 함수의 유형을 사용하여 할당의 오른쪽에있는 함수 표현식의 유형을 추론했습니다. 그렇게했을 때, 추론 할 수 있었다 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/MouseEvent&quot;&gt;유형&lt;/a&gt; 의 &lt;code&gt;mouseEvent&lt;/code&gt; 포함하지 파라미터, &lt;code&gt;button&lt;/code&gt; 속성을 아니지만 &lt;code&gt;kangaroo&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">여기서 Typescript type checker는 &lt;code&gt;Window.onmousedown&lt;/code&gt; 함수의 유형을 사용하여 할당 오른쪽에 함수 표현식의 유형을 유추했습니다. 그렇게했을 때, 추론 할 수 있었다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;유형&lt;/a&gt; 의 &lt;code&gt;mouseEvent&lt;/code&gt; 포함하지 파라미터, &lt;code&gt;button&lt;/code&gt; 속성을 아니지만 &lt;code&gt;kangaroo&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="5c595f669d2beb3aaae563a230a33b04db9bfa77" translate="yes" xml:space="preserve">
          <source>Here, the object literal &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; has a matching literal type &lt;code&gt;{ x: string, extra: number }&lt;/code&gt;. That type is assignable to &lt;code&gt;{ x: string }&lt;/code&gt; since it has all the required properties and those properties have assignable types. The extra property doesn&amp;rsquo;t prevent assignment, it just makes it a subtype of &lt;code&gt;{ x: string }&lt;/code&gt;.</source>
          <target state="translated">여기서 객체 리터럴 &lt;code&gt;{ x: &quot;hi&quot;, extra: 1 }&lt;/code&gt; 에는 일치하는 리터럴 유형 &lt;code&gt;{ x: string, extra: number }&lt;/code&gt; 있습니다. 이 유형은 모든 필수 속성이 있고 해당 속성에는 할당 가능한 유형이 있으므로 &lt;code&gt;{ x: string }&lt;/code&gt; 할당 할 수 있습니다. 추가 속성은 할당을 방지하지 않고 &lt;code&gt;{ x: string }&lt;/code&gt; 의 하위 유형으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">여기서는 &lt;code&gt;isAdministrator&lt;/code&gt; 를 호출하는 것을 잊어 버렸습니다. 이 코드를 사용하면 관리자가 아닌 사용자가 구성을 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">여기에 비 블로킹 비동기 방식으로 이미지를 읽는 &lt;code&gt;readImage&lt;/code&gt; 함수가 있습니다 . 뿐만 아니라 &lt;code&gt;readImage&lt;/code&gt; , 우리는에 편리한 기능을 제공 한 &lt;code&gt;readImage&lt;/code&gt; 자체라는 &lt;code&gt;readImage.sync&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">여기에는 두 개의 지역 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 있습니다. &lt;code&gt;a&lt;/code&gt; 의 범위는 &lt;code&gt;f&lt;/code&gt; 의 본문으로 제한 되고 &lt;code&gt;b&lt;/code&gt; 의 범위는 포함하는 &lt;code&gt;if&lt;/code&gt; 문의 블록으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">여기서는 &lt;code&gt;Validation&lt;/code&gt; 네임 스페이스를 여러 파일로 분할 합니다. 파일이 분리되어 있어도 각각 동일한 네임 스페이스에 기여할 수 있으며 마치 한 곳에서 모두 정의 된 것처럼 사용할 수 있습니다. 파일 간에는 종속성이 있으므로 참조 태그를 추가하여 컴파일러에게 파일 간의 관계를 알려줍니다. 우리의 테스트 코드는 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">여기, 우리가 말할 때 &lt;code&gt;let greeter: Greeter&lt;/code&gt; , 우리가 사용하고있는 &lt;code&gt;Greeter&lt;/code&gt; 클래스의 인스턴스의 유형으로 &lt;code&gt;Greeter&lt;/code&gt; . 이것은 다른 객체 지향 언어의 프로그래머에게는 거의 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">이종 열거 형</target>
        </trans-unit>
        <trans-unit id="fc6421364e8a88466f0b8a656c2d54672e0df2a5" translate="yes" xml:space="preserve">
          <source>High Level libraries</source>
          <target state="translated">높은 수준의 라이브러리</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">제네릭 생성자의 고차 형 추론</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">일반 함수의 고차 형 추론</target>
        </trans-unit>
        <trans-unit id="836a8611eb0ab70ee1d218e7f51d504c7581df05" translate="yes" xml:space="preserve">
          <source>Higher-kinded types</source>
          <target state="translated">더 높은 종류의 유형</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">적중 &lt;code&gt;Install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347baca49873f29800c610e216fe9cd584b6b62d" translate="yes" xml:space="preserve">
          <source>How Does A Mixin Work?</source>
          <target state="translated">Mixin은 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.js가 모듈을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScript가 모듈을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="54183e0fc7898d58bfb00430e9606ee2944f7524" translate="yes" xml:space="preserve">
          <source>How do you obtain the library?</source>
          <target state="translated">도서관은 어떻게 구합니까?</target>
        </trans-unit>
        <trans-unit id="0752a189682fd73c97a85ecfb50c84d4af385645" translate="yes" xml:space="preserve">
          <source>How does TypeScript relate to JavaScript, though?</source>
          <target state="translated">하지만 TypeScript는 JavaScript와 어떤 관련이 있습니까?</target>
        </trans-unit>
        <trans-unit id="5bd674995e2b8b711665e2c0340b40adea0356b1" translate="yes" xml:space="preserve">
          <source>How is this Handbook Structured</source>
          <target state="translated">이 핸드북은 어떻게 구성되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="e505420e927902bf517a25b3ee02c1df4f205b0d" translate="yes" xml:space="preserve">
          <source>How to program in JavaScript, the good parts.</source>
          <target state="translated">JavaScript로 프로그래밍하는 방법, 좋은 부분.</target>
        </trans-unit>
        <trans-unit id="a165cba49bf6f53be535d3bada5e871711caec2e" translate="yes" xml:space="preserve">
          <source>How to use TypeScript-powered JavaScript tooling.</source>
          <target state="translated">How to use TypeScript-powered JavaScript tooling.</target>
        </trans-unit>
        <trans-unit id="88bab0a4785a544d72f7174abbe7378f0e4c5e6b" translate="yes" xml:space="preserve">
          <source>How would you import it?</source>
          <target state="translated">어떻게 가져 오시겠습니까?</target>
        </trans-unit>
        <trans-unit id="62e32177f5bf0ee0e14e3a31c7e50429ce2039cd" translate="yes" xml:space="preserve">
          <source>However, TypeScript is a &lt;em&gt;typed&lt;/em&gt; superset, meaning that it adds rules about how different kinds of values can be used. The earlier error about &lt;code&gt;obj.heigth&lt;/code&gt; was not a &lt;em&gt;syntax&lt;/em&gt; error: it is an error of using some kind of value (a &lt;em&gt;type&lt;/em&gt;) in an incorrect way.</source>
          <target state="translated">그러나 TypeScript는 &lt;em&gt;유형이 지정된&lt;/em&gt; 상위 집합이므로 다양한 종류의 값을 사용할 수있는 방법에 대한 규칙을 추가합니다. &lt;code&gt;obj.heigth&lt;/code&gt; 에 대한 이전 오류 는 &lt;em&gt;구문&lt;/em&gt; 오류 가 아닙니다 . 잘못된 방식으로 어떤 종류의 값 ( &lt;em&gt;유형&lt;/em&gt; ) 을 사용하는 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">그러나 TypeScript는이 코드에 버그가있을 수 있다고 생각합니다. 객체 리터럴은 다른 변수에 할당하거나 인수로 전달할 때 특별한 처리를 받고 &lt;em&gt;과도한 속성 검사를&lt;/em&gt; 받습니다 . 객체 리터럴에 &quot;대상 유형&quot;에없는 속성이 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">그러나 TypeScript는 대신 원래 코드를 다음 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">그러나 개체에 특별한 방식으로 사용되는 추가 속성이있을 수있는 경우 문자열 인덱스 서명을 추가하는 것이 더 나은 방법 일 수 있습니다. 경우 &lt;code&gt;SquareConfig&lt;/code&gt; 가 있을 수 있습니다 &lt;code&gt;color&lt;/code&gt; 과 &lt;code&gt;width&lt;/code&gt; 위의 유형과 특성을 할 수도 있지만 &lt;em&gt;또한&lt;/em&gt; 다른 속성의 번호를 가지고, 우리는 너무 좋아 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">그러나 많은 경우에 자체 &lt;code&gt;.d.ts&lt;/code&gt; 파일 이 없을 수있는 기존 모듈을 가져오고 싶을 수도 있습니다 . 이전에는 오류였습니다. TypeScript 2.1부터는 훨씬 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="f0b057c2f8bc22925ee5d37f69c394f9bb4475bc" translate="yes" xml:space="preserve">
          <source>However, a useful heuristic could be:</source>
          <target state="translated">그러나 유용한 휴리스틱은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">그러나 두 가지를 순진하게 결합하면 오류가 발생할 수 있습니다. 예를 들어 &lt;code&gt;createSquare&lt;/code&gt; 사용하여 마지막 예제를 보자 .</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">그러나 타입이 프리미티브인지 알아내는 함수를 정의하는 것은 일종의 고통입니다. 운좋게도, TypeScript는 그것을 type type으로 인식하기 때문에 &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; 를 자체 함수로 추상화 할 필요가 없습니다 . 즉,이 검사를 인라인으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">그러나 위의 예제에서 &lt;code&gt;FruitEater&lt;/code&gt; 와 &lt;code&gt;ColorConsumer&lt;/code&gt; 는 모두 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; 문자열을 가져와 &lt;code&gt;number&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 을 반환 할 수 있어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">그러나 다음 예에서는 대체 사례가 비어 있기 때문에 오류가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">그러나 타입 별칭이 선언의 오른쪽에 나타날 수는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">그러나 제약 조건에서 형식 변수를 지우고 대신 조건부 형식을 지정하면 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876ffd4a2dccce5f7851ed0c26a166758d84a1c1" translate="yes" xml:space="preserve">
          <source>However, none of these options are the default, so they are not consistently used in TypeScript code.</source>
          <target state="translated">그러나 이러한 옵션 중 어느 것도 기본값이 아니므로 TypeScript 코드에서 일관되게 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">그러나 인덱스 서명이 속성 유형의 합집합 인 경우 다른 유형의 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">그러나 &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;상대&lt;/a&gt; 가 아닌 모듈 이름의 해결 방법 은 다르게 수행됩니다. Node는 &lt;code&gt;node_modules&lt;/code&gt; 라는 특수 폴더에서 모듈을 찾습니다 . &lt;code&gt;node_modules&lt;/code&gt; 는 폴더 디렉토리 체인의 최대 높은 현재 파일과 같은 수준에, 또는 수 있습니다. 노드는 로드하려고 시도한 모듈을 찾을 때까지 각 &lt;code&gt;node_modules&lt;/code&gt; 통해 디렉토리 체인 을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">그러나 명심해야 할 두 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">그러나,이 코드는 로그인 할 &lt;code&gt;undefined&lt;/code&gt; 이후 &lt;code&gt;uiEvent&lt;/code&gt; 라는 프로퍼티가 없습니다 &lt;code&gt;button&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">그러나 이것은 오류가 발생하기 쉽습니다. 사용자가 실수로 유효한 여유 값 중 하나를 잘못 철자하는 것을 막을 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a8176fb9274a3dbc59832e6bbcd686e944cd704" translate="yes" xml:space="preserve">
          <source>However, this is observably different in certain rare cases. For example, if an array has a &amp;ldquo;hole&amp;rdquo; in it, the missing index will create an &lt;em&gt;own&lt;/em&gt; property if spreaded, but will not if built using &lt;code&gt;concat&lt;/code&gt;:</source>
          <target state="translated">그러나 이것은 드문 경우에 눈에 띄게 다릅니다. 예를 들어 배열에 &quot;구멍&quot;이있는 경우 누락 된 인덱스는 분산 된 경우 &lt;em&gt;고유 한&lt;/em&gt; 속성 을 생성 하지만 &lt;code&gt;concat&lt;/code&gt; 을 사용하여 구축 된 경우에는 생성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">그러나 이것은 원래 예제에서는 약간 엄격했습니다. 가능한 &lt;code&gt;S&lt;/code&gt; 값의 정확한 유형을 알아 내면 실제로 &lt;code&gt;T&lt;/code&gt; 의 유형과 정확히 일치 함을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">그러나 &lt;code&gt;private&lt;/code&gt; 멤버 와 &lt;code&gt;protected&lt;/code&gt; 멤버 가있는 유형을 비교할 때 이러한 유형을 다르게 취급합니다. 두 유형이 호환 가능한 것으로 간주 되려면 두 유형 중 하나에 &lt;code&gt;private&lt;/code&gt; 구성원 이있는 경우 다른 유형에 동일한 선언에서 시작한 &lt;code&gt;private&lt;/code&gt; 구성원이 있어야합니다 . &lt;code&gt;protected&lt;/code&gt; 회원 에게도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그를 사용하는 경우 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;any&lt;/code&gt; 해당 유형 에만 할당 할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 는 예외로 도 &lt;code&gt;void&lt;/code&gt; 에 할당 할 수 있음 ). 이것은 &lt;em&gt;많은&lt;/em&gt; 일반적인 오류를 피하는 데 도움이됩니다 . &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 전달하려는 경우 공용체 유형 &lt;code&gt;string | null | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="047dbc98484657ac4d0055ecd2b94304fd075dce" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;unknown&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그를 사용할 때 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;unknown&lt;/code&gt; , &lt;code&gt;any&lt;/code&gt; 및 해당 유형 에만 할당 할 수 있습니다 (한 가지 예외는 &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 에 할당 할 수도 있음 ). 이것은 &lt;em&gt;많은&lt;/em&gt; 일반적인 오류를 방지하는 데 도움이됩니다 . &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 전달하려는 경우 공용체 유형 &lt;code&gt;string | null | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac716fe1287c18ff224c30b0e3ef28c757beb2fe" translate="yes" xml:space="preserve">
          <source>However, you may have intended for &lt;code&gt;core&lt;/code&gt; to be part of the output directory structure. By setting &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="translated">그러나 &lt;code&gt;core&lt;/code&gt; 가 출력 디렉토리 구조의 일부 가되도록 의도했을 수 있습니다 . &lt;code&gt;rootDir: &quot;.&quot;&lt;/code&gt; 설정 : &quot;.&quot; 에 &lt;code&gt;tsconfig.json&lt;/code&gt; , 타이프 라이터는이 나무를 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">하이브리드 타입</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">네임 스페이스 선언으로서의 IIFE</target>
        </trans-unit>
        <trans-unit id="b0e5d24c6bc89831f1e2de048c03becf6f8a2dab" translate="yes" xml:space="preserve">
          <source>Ideally this should stay at 0 (the default), and &lt;code&gt;d.ts&lt;/code&gt; files should be used to explicitly define the shape of modules. However, there are cases where you may want to turn this on at the expense of speed and potential accuracy.</source>
          <target state="translated">이상적으로는 0 (기본값)으로 유지되어야하며 &lt;code&gt;d.ts&lt;/code&gt; 파일을 사용하여 모듈의 모양을 명시 적으로 정의해야합니다. 그러나 속도와 잠재적 인 정확도를 희생하면서이 기능을 켜고 싶은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">이상적으로 &lt;code&gt;zoo&lt;/code&gt; 을 &lt;code&gt;Animal[]&lt;/code&gt; 로 추론하기를 원할 수 있지만 배열에 &lt;code&gt;Animal&lt;/code&gt; 유형의 객체가 없으므로 배열 요소 유형에 대해서는 유추하지 않습니다. 이를 정정하려면, 다른 유형의 모든 유형의 수퍼 유형이없는 경우 유형을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">이상적으로는 브라우저 내에서 React 모듈을 가져 오지만 대부분의 브라우저는 아직 모듈을 지원하지 않습니다. 대신 라이브러리는 전통적으로 &lt;code&gt;jQuery&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt; 와 같은 단일 전역 변수를 사용하여 사용할 수 있습니다 . 이것을&amp;ldquo;네임 스페이스 패턴&amp;rdquo;이라고하며, 웹팩을 사용하면 이런 방식으로 작성된 라이브러리를 계속 활용할 수 있습니다. 우리의 항목으로 &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; , 웹팩은 모든 수입하기 위해 마법을 작동합니다 &lt;code&gt;&quot;react&quot;&lt;/code&gt; (가)에서 부하를 &lt;code&gt;React&lt;/code&gt; 변수를.</target>
        </trans-unit>
        <trans-unit id="0f435dc0d9d21e95947646e4a4aa314593787165" translate="yes" xml:space="preserve">
          <source>Identical Types</source>
          <target state="translated">동일한 유형</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">라이브러리의 종류 식별</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">코드에서 글로벌 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">코드에서 모듈 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">UMD 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">글로벌 플러그인 식별</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">전역 수정 모듈 식별</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">라이브러리의 구조를 식별하는 것은 선언 파일을 작성하는 첫 번째 단계입니다. &lt;em&gt;사용법&lt;/em&gt; 과 &lt;em&gt;코드를&lt;/em&gt; 기반으로 구조를 식별하는 방법에 대한 힌트를 제공합니다 . 라이브러리의 문서 및 구성에 따라 하나가 다른 것보다 쉬울 수 있습니다. 더 편한 것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">'default'및 'clean'작업이 표시되지 않으면 탐색기를 새로 고치십시오.</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">경우 &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; 가 지정되지 않은 시스템에 설치된 최신 컴파일러 버전은 빌드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 에 숫자 색인 서명이 포함 된 경우 &lt;code&gt;keyof X&lt;/code&gt; 는 &lt;code&gt;number&lt;/code&gt; 와 문자열 유사 및 기호 유사 특성을 나타내는 리터럴 유형 의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 에 문자열 인덱스 서명이 포함 된 경우 &lt;code&gt;keyof X&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; 및 기호와 유사한 속성을 나타내는 리터럴 유형 의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="f0343e4e3ae4fdd7375e56cd9c4d11af9cc6df5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isolatedModules&lt;/code&gt; is set, all implementation files must be &lt;em&gt;modules&lt;/em&gt; (which means it has some form of &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;). An error occurs if any file isn&amp;rsquo;t a module:</source>
          <target state="translated">경우 &lt;code&gt;isolatedModules&lt;/code&gt; 가 설정되어, 모든 실행 파일이 있어야합니다 &lt;em&gt;모듈&lt;/em&gt; (이 방법은 어떤 형태가 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; ). 모듈이 아닌 파일이 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71c3593112427fc1b30c2239c25266a482dc1c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;amd&lt;/code&gt;, all module files will also be concatenated into this file after all global content.</source>
          <target state="translated">경우 &lt;code&gt;module&lt;/code&gt; 입니다 &lt;code&gt;system&lt;/code&gt; 또는 &lt;code&gt;amd&lt;/code&gt; , 모든 모듈 파일은 모든 글로벌 컨텐츠 후이 파일로 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="67882abab18e10cbd606e356f6ed753bf2457955" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noResolve&lt;/code&gt; is set, this process doesn&amp;rsquo;t happen. However, &lt;code&gt;import&lt;/code&gt; statements are still checked to see if they resolve to a valid module, so you&amp;rsquo;ll need to make sure this is satisfied by some other means.</source>
          <target state="translated">&lt;code&gt;noResolve&lt;/code&gt; 가 설정되어 있으면 이 프로세스가 발생하지 않습니다. 그러나 &lt;code&gt;import&lt;/code&gt; 문은 유효한 모듈로 확인되는지 확인하기 위해 여전히 확인되므로 다른 방법으로 이것이 충족되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">경우 &lt;code&gt;typeRoots&lt;/code&gt; 가 지정된 경우 &lt;em&gt;에만&lt;/em&gt; 아래 패키지 &lt;code&gt;typeRoots&lt;/code&gt; 이 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76e7b062f347c8ed5beb7e6e8b7549983806fc75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included in the global scope. For instance:</source>
          <target state="translated">경우 &lt;code&gt;types&lt;/code&gt; 지정되어 나열에만 패키지는 전역 범위에 포함됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">경우 &lt;code&gt;types&lt;/code&gt; 지정되어 나열에만 패키지가 포함됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">결정 적으로 내려 오는 경우 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;{}&lt;/code&gt; , 당신이 선호한다 &lt;code&gt;{}&lt;/code&gt; . 그것들은 대부분 동일하지만 기술적으로 &lt;code&gt;{}&lt;/code&gt; 는 특정한 난해한 경우 &lt;code&gt;Object&lt;/code&gt; 보다 더 일반적인 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">기본 유형이 지정되고 유추가 후보를 선택할 수없는 경우 기본 유형이 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="c71457b71cd95a1cb2a171eb57463a371dcaec7c" translate="yes" xml:space="preserve">
          <source>If a glob pattern doesn&amp;rsquo;t include a file extension, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default, with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">glob 패턴에 파일 확장자가 포함되지 않은 경우 지원되는 확장자를 가진 파일 만 포함됩니다 (예 : 기본적으로 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; , &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; 포함 ).</target>
        </trans-unit>
        <trans-unit id="75f219ce45668d5a735796fec9609c181f98317e" translate="yes" xml:space="preserve">
          <source>If a module should not be automatically acquired, for example if the library is available in your &lt;code&gt;node_modules&lt;/code&gt; but your team has agreed to not use it:</source>
          <target state="translated">모듈이 자동으로 획득되지 않아야하는 경우 (예 : &lt;code&gt;node_modules&lt;/code&gt; 에서 라이브러리를 사용할 수 있지만 팀에서 사용하지 않기로 동의 한 경우) :</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">glob 패턴의 세그먼트에 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;.*&lt;/code&gt; 만 포함 된 경우 지원되는 확장자를 가진 파일 만 포함됩니다 (예 : &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 기본적으로 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; 와 함께 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="bec2b2f64a8b9ad3998bf7f229a2fbb020be7798" translate="yes" xml:space="preserve">
          <source>If absent, then &amp;ldquo;main&amp;rdquo; is used</source>
          <target state="translated">없으면 &quot;main&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">(A)의 경우에는 피연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , 또는 &lt;code&gt;in&lt;/code&gt; 오퍼레이터 널이다.</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">(A)의 경우에는 피연산자 &lt;code&gt;+&lt;/code&gt; 의 운영자는 널없고, 둘 피연산자 타입 인 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">(A)의 경우, 피연산자 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 연산자는 널 입력 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; 가 true로 설정되면 파일의 상위 디렉토리를 감시합니다 ( &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; 와 동일 ). 그렇지 않으면 파일 의 시간 초과 가 &lt;code&gt;250ms&lt;/code&gt; 인 &lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용하여 파일을 감시 하십시오.</target>
        </trans-unit>
        <trans-unit id="d06262f17b6e967b3001fc6098e3202e17df154f" translate="yes" xml:space="preserve">
          <source>If not specified, &lt;code&gt;.js&lt;/code&gt; files will be emitted in the same directory as the &lt;code&gt;.ts&lt;/code&gt; files they were generated from:</source>
          <target state="translated">지정하지 않으면 &lt;code&gt;.js&lt;/code&gt; 파일 이 생성 된 &lt;code&gt;.ts&lt;/code&gt; 파일 과 동일한 디렉토리에서 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">클래스 본문에 속성을 설정하지 않으면 알 수없는 것으로 간주됩니다. 클래스에 읽을 수있는 속성이있는 경우 JSDoc을 사용하여 생성자에 선언을 추가 한 다음 주석을 달아 유형을 지정하십시오. 나중에 초기화 될 경우 값을 제공 할 필요조차 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a4ad169ba84bf7c2bddecab5b752919e9c60ee2" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;.js&lt;/code&gt; (as well as &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.js.map&lt;/code&gt;, etc.) files will be emitted into this directory. The directory structure of the original source files is preserved; see &lt;a href=&quot;#rootDir&quot;&gt;rootDir&lt;/a&gt; if the computed root is not what you intended.</source>
          <target state="translated">지정되면 &lt;code&gt;.js&lt;/code&gt; (및 &lt;code&gt;.d.ts&lt;/code&gt; , &lt;code&gt;.js.map&lt;/code&gt; 등) 파일이이 디렉토리로 내보내집니다. 원본 소스 파일의 디렉토리 구조는 유지됩니다. 계산 된 루트가 의도 한 것이 아닌 경우 &lt;a href=&quot;#rootDir&quot;&gt;rootDir을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c82e3245bf395bde8ad50d56147266b35e02cbd" translate="yes" xml:space="preserve">
          <source>If specified, all &lt;em&gt;global&lt;/em&gt; (non-module) files will be concatenated into the single output file specified.</source>
          <target state="translated">지정된 경우 모든 &lt;em&gt;전역&lt;/em&gt; (모듈이 아닌) 파일이 지정된 단일 출력 파일로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">그래도 작동하지 않고 모듈 이름이 상대 이름이 아닌 경우 ( &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 의 경우 ), 컴파일러는 &lt;a href=&quot;modules#ambient-modules&quot;&gt;주변 모듈 선언&lt;/a&gt; 을 찾으려고 시도합니다 . 다음은 상대적이지 않은 수입을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">그 소리가 너무 느슨하면 그 행동을 강화할 수 있습니다. 예를 들어, 오류가 발생하여 &lt;code&gt;noEmitOnError&lt;/code&gt; 가 JavaScript로 컴파일 &lt;em&gt;되지 않게&lt;/em&gt; 하려면 noEmitOnError 옵션을 사용할 수 있습니다 . 그런 의미에서 TypeScript에는 엄격함에 다이얼이 있으며 원하는만큼 노브를 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">이 경우 작성한 파일은 TypeScript에 대한 입력으로 사용되며 생성 된 출력을 실행합니다. JS에서 TS로 마이그레이션하는 동안 TypeScript가 덮어 쓰지 않도록 입력 파일을 분리해야합니다. 출력 파일이 특정 디렉토리에 있어야하는 경우 출력 디렉토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 모두 컴파일러의 모든 타이프 라이터를 포함하여 기본값 (지정되지 않은 상태입니다 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; 을 하고 &lt;code&gt;.tsx&lt;/code&gt; 은 Using 제외 제외) 파일을 포함하는 디렉토리 및 하위 디렉토리 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성. &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 JS 파일 ( &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; )도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 모두 컴파일러의 모든 타이프 라이터를 포함하여 기본값 (지정되지 않은 상태입니다 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; 을 하고 &lt;code&gt;.tsx&lt;/code&gt; 은 Using 제외 제외) 파일을 포함하는 디렉토리 및 하위 디렉토리 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성. &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 JS 파일 ( &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; )도 포함됩니다 . 경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성이 지정되어, 컴파일러는이 두 속성으로 포함 된 파일의 조합을 포함하는 대신합니다. &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 을 사용하여 지정된 디렉토리의 파일 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 특성이 지정되지 않으면 컴파일러 옵션이 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성이 지정되어, 컴파일러는이 두 속성으로 포함 된 파일의 조합을 포함하는 대신합니다. &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 컴파일러 옵션을 사용하여 지정된 디렉토리의 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 은 &quot;files&quot; 특성을 통해 명시 적으로 포함되지 않는 한 ( &quot; &lt;code&gt;exclude&lt;/code&gt; &quot;특성이 지정된 경우에도) 항상 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9d1e0016c3b073e477b87823fb48c212a972f04" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;importHelpers&lt;/code&gt; flag is on, these helper functions are instead imported from the &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; module. You will need to ensure that the &lt;code&gt;tslib&lt;/code&gt; module is able to be imported at runtime. This only affects modules; global script files will not attempt to import modules.</source>
          <target state="translated">&lt;code&gt;importHelpers&lt;/code&gt; 플래그가 켜져 있으면 이러한 도우미 함수는 대신 &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;tslib&lt;/a&gt; 모듈 에서 가져옵니다 . &lt;code&gt;tslib&lt;/code&gt; 모듈을 런타임에 가져올 수 있는지 확인해야 합니다. 이것은 모듈에만 영향을 미칩니다. 전역 스크립트 파일은 모듈 가져 오기를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">접근 자 데코레이터가 값을 반환 하면 멤버 의 &lt;em&gt;속성 설명&lt;/em&gt; 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;--noResolve&lt;/code&gt; 를 지정하면 삼중 슬래시 참조가 무시됩니다. 새 파일을 추가하거나 제공된 파일의 순서를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6404fc019a0ea10b80a74ad6d4f189ca7a5e6cf0" translate="yes" xml:space="preserve">
          <source>If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">팩토리가 &lt;code&gt;React.createElement&lt;/code&gt; (기본값) 로 정의 된 경우 컴파일러는 전역 &lt;code&gt;JSX&lt;/code&gt; 를 확인하기 전에 &lt;code&gt;React.JSX&lt;/code&gt; 를 확인합니다 . 팩토리가 &lt;code&gt;h&lt;/code&gt; 로 정의 되면 글로벌 &lt;code&gt;JSX&lt;/code&gt; 이전 에 &lt;code&gt;h.JSX&lt;/code&gt; 를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">메소드 데코레이터가 값을 리턴하면 해당 메소드의 &lt;em&gt;특성 설명&lt;/em&gt; 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e2ec078a41809b3ea00769455fcd98c66227dc0" translate="yes" xml:space="preserve">
          <source>If the object or class has all the required properties, TypeScript will say they match, regardless of the implementation details.</source>
          <target state="translated">객체 또는 클래스에 필요한 모든 속성이 있으면 TypeScript는 구현 세부 정보에 관계없이 일치한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">a의 피연산자 경우 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; , 또는 &lt;code&gt;--&lt;/code&gt; 단항 연산자는 널 입력이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">참조 된 프로젝트가 &lt;code&gt;outFile&lt;/code&gt; 을 생성하면이 프로젝트 에서 출력 파일 &lt;code&gt;.d.ts&lt;/code&gt; 파일의 선언이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 연산자 의 오른쪽 피연산자 가 널 입력 가능 인 경우.</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">이 함수가 문맥 상으로 입력 된 위치에 있지 않은 경우 함수의 인수는 암시 적으로 유형 &lt;code&gt;any&lt;/code&gt; 를 가지게 되고 &lt;code&gt;--noImplicitAny&lt;/code&gt; 옵션을 사용하지 않는 한 오류가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">공용체 유형의 값이있는 경우 공용체의 모든 유형에 공통적 인 멤버에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="935377e4091dae4bb943432ee7eeb7b9ff3cef2c" translate="yes" xml:space="preserve">
          <source>If we have a value that is a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">공용체 유형의 값이있는 경우 공용체의 모든 유형에 공통 인 멤버에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">데코레이터가 선언에 적용되는 방식을 사용자 정의하려면 데코레이터 팩토리를 작성할 수 있습니다. &lt;em&gt;실내 장식 공장은&lt;/em&gt; 단순히 런타임에 장식으로 호출되는 표현을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">원한다면 이니셜 라이저를 완전히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">&lt;a href=&quot;#decorator-factories&quot;&gt;데코레이터 팩토리&lt;/a&gt; 를 사용 하는 경우 다음 예제 를 사용 하여이 평가 순서를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 을 추가하면 해당 컨텍스트의 일부로 간주되지 않는 TypeScript 파일이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="776111b439c21b6cb775099faee4d16246e9ab8d" translate="yes" xml:space="preserve">
          <source>If you are coming to TypeScript without a JavaScript background, with the intention of TypeScript being your first language, we recommend you first start reading the documentation &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;on JavaScript at the Mozilla Web Docs&lt;/a&gt;. If you have experience in other languages, you should be able to pick up JavaScript syntax quite quickly by reading the handbook.</source>
          <target state="translated">TypeScript를 모국어로 사용하려는 의도로 JavaScript 배경없이 TypeScript를 사용하는 경우 먼저 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Guide&quot;&gt;Mozilla Web Docs에서 JavaScript에 대한&lt;/a&gt; 문서 를 읽기 시작하는 것이 좋습니다 . 다른 언어에 대한 경험이 있다면 핸드북을 읽으면 JavaScript 구문을 매우 빠르게 익힐 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="085d3fb970c36076b70083b38db4b956effc131e" translate="yes" xml:space="preserve">
          <source>If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:</source>
          <target state="translated">모든 사람이 사용할 수 있도록 이러한 변경 사항을 DefinitelyTyped에 제출할 계획이라면 다음을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">개발 및 디버깅 경험을 위해 다른 빌드 도구를 사용하여 프로젝트 (예 : gulp, grunt 등) 및 VS를 빌드하는 경우 프로젝트에서 &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; 를 설정하십시오. 이렇게하면 F5를 누를 때 모든 편집 지원이 제공되지만 빌드는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">빌드 출력 ( &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; , &lt;code&gt;.d.ts.map&lt;/code&gt; 등) 을 체크인하는 경우 소스 제어 도구의 보존 여부에 따라 특정 소스 제어 조작 후 &lt;code&gt;--force&lt;/code&gt; 빌드 를 실행해야 할 수도 있습니다 로컬 사본과 원격 사본 사이의 시간 소인.</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">새 모듈을 사용하기 전에 선언을 작성하는 데 시간이 걸리지 않는 경우 이제 간단한 선언을 사용하여 빠르게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">새 모듈을 사용하기 전에 선언을 작성하지 않으려는 경우 속기 선언을 사용하여 빠르게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">TypeScript가 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 라고 생각하는 값을 가지고 있지만 더 잘 알고 있다면 접미사를 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 그렇지 않으면 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d58bbe6abf7e68dae13856af53d691d0dfa849" translate="yes" xml:space="preserve">
          <source>If you find yourself searching for something like &amp;ldquo;how to sort a list in TypeScript&amp;rdquo;, remember: &lt;strong&gt;TypeScript is JavaScript&amp;rsquo;s runtime with a compile-time type checker&lt;/strong&gt;. The way you sort a list in TypeScript is the same way you do so in JavaScript. If you find a resource that uses TypeScript directly, that&amp;rsquo;s great too, but don&amp;rsquo;t limit yourself to thinking you need TypeScript-specific answers for everyday questions about how to accomplish runtime tasks.</source>
          <target state="translated">&quot;TypeScript에서 목록을 정렬하는 방법&quot;과 같은 것을 검색하는 경우 &lt;strong&gt;TypeScript는 컴파일 타임 유형 검사기가있는 JavaScript의 런타임입니다&lt;/strong&gt; . TypeScript에서 목록을 정렬하는 방법은 JavaScript에서 수행하는 방법과 동일합니다. TypeScript를 직접 사용하는 리소스를 찾으면 그것도 좋지만 런타임 작업을 수행하는 방법에 대한 일상적인 질문에 TypeScript 관련 답변이 필요하다고 생각하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="33efe22b92b7f2005e7eb656f1a76dbf3fcbc9bb" translate="yes" xml:space="preserve">
          <source>If you get tired of imports always looking like &lt;code&gt;&quot;../&quot;&lt;/code&gt; or &lt;code&gt;&quot;./&quot;&lt;/code&gt;. Or needing to change as you move files, this is a great way to fix that.</source>
          <target state="translated">항상 &lt;code&gt;&quot;../&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;./&quot;&lt;/code&gt; 처럼 보이는 수입품에 질리면 . 또는 파일을 이동할 때 변경해야하는 경우이를 수정하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">다음과 같은 Node / CommonJS 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;tests&lt;/code&gt; 당신의 외부 폴더 &lt;code&gt;src&lt;/code&gt; 디렉토리를 하나있을 수 있습니다 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;src&lt;/code&gt; 에, 하나를 &lt;code&gt;tests&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="37eded98e17f199e9a0f317e547c4692b3b985a7" translate="yes" xml:space="preserve">
          <source>If you have a lot of JavaScript files you want to add errors to then you can switch to using a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;jsconfig.json&lt;/code&gt;&lt;/a&gt;. You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to files.</source>
          <target state="translated">오류를 추가하려는 JavaScript 파일이 많은 경우 &lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;jsconfig.json&lt;/code&gt; &lt;/a&gt; 사용으로 전환 할 수 있습니다 . 파일에 &lt;code&gt;// @ts-nocheck&lt;/code&gt; 주석을 추가하여 일부 파일 검사를 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5daacb30eeb58b2f2dd8eeb43af27c13d0f6e359" translate="yes" xml:space="preserve">
          <source>If you have a module which when imported, makes changes to other modules use template &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">가져올 때 다른 모듈을 변경하는 모듈이있는 경우 &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt; 템플릿을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e25661d3416deb409f63475049ffc70db498f494" translate="yes" xml:space="preserve">
          <source>If you have a specific module which should be included (but isn&amp;rsquo;t in &lt;code&gt;node_modules&lt;/code&gt;):</source>
          <target state="translated">포함되어야하는 특정 모듈이있는 경우 ( &lt;code&gt;node_modules&lt;/code&gt; 에 포함되지 않음 ) :</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">숫자 색인 서명이있는 유형이있는 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 &lt;code&gt;number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="036ed4bc42cb6365f2fcac60d2ef2dafe759c7d5" translate="yes" xml:space="preserve">
          <source>If you have a variable with an unknown type, you can narrow it to something more specific by doing &lt;code&gt;typeof&lt;/code&gt; checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:</source>
          <target state="translated">알 수없는 유형의 변수가있는 경우 &lt;code&gt;typeof&lt;/code&gt; 검사, 비교 검사 또는 이후 장에서 설명 할 고급 유형 가드를 수행하여 더 구체적인 변수로 좁힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">msbuild 프로젝트가있는 경우 다음을 추가하여 빌드 모드를 활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="29f75b30082c5ae8c9dd501dc68ec9c17ab2e182" translate="yes" xml:space="preserve">
          <source>If you have been asked by a TypeScript compiler engineer to give the results using this flag in a compile, in which there is no harm in using &lt;a href=&quot;#extendedDiagnostics&quot;&gt;&lt;code&gt;--extendedDiagnostics&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">TypeScript 컴파일러 엔지니어가 컴파일에서이 플래그를 사용하여 결과를 제공하도록 요청받은 경우 대신 &lt;a href=&quot;#extendedDiagnostics&quot;&gt; &lt;code&gt;--extendedDiagnostics&lt;/code&gt; &lt;/a&gt; 를 사용해도 해가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9958ebfa05a47b2e603ba5d2a6dfd282d81623dc" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and modules.</source>
          <target state="translated">아직 읽지 &lt;a href=&quot;../basic-types&quot;&gt;않았다면 TypeScript 핸드북&lt;/a&gt; 을 읽고 기본 개념, 특히 유형과 모듈에 익숙해 져야합니다.</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">함수를 호출하지 않고 테스트하려는 경우 &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 을 포함하도록 함수 정의를 수정 하거나 &lt;code&gt;!!&lt;/code&gt; 강요가 의도적임을 나타내는 &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; 와 같은 것을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="5a96d27a06b8980e6a4f2196b4ba66f129bc78de" translate="yes" xml:space="preserve">
          <source>If you move some code from a JavaScript file to a TypeScript file, you might see &lt;em&gt;type errors&lt;/em&gt; depending on how the code is written. These may be legitimate problems with the code, or TypeScript being overly conservative. Throughout this guide we&amp;rsquo;ll demonstrate how to add various TypeScript syntax to eliminate such errors.</source>
          <target state="translated">JavaScript 파일에서 TypeScript 파일로 일부 코드를 이동 하면 코드 작성 방법에 따라 &lt;em&gt;유형 오류&lt;/em&gt; 가 표시 될 수 있습니다 . 이는 코드의 합법적 인 문제이거나 TypeScript가 지나치게 보수적 일 수 있습니다. ㅇ ㅇㄴㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 가이드 전체에서 이러한 오류를 제거하기 위해 다양한 TypeScript 구문을 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba807eb4e0eaeb772cb84988d65f758637aa63a7" translate="yes" xml:space="preserve">
          <source>If you need to learn the good parts of JavaScript, read &lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript: The Good Parts&lt;/a&gt;. You may be able to skip the book if you know how to write programs in a call-by-value lexically scoped language with lots of mutability and not much else. &lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R&lt;sup&gt;4&lt;/sup&gt;RS Scheme&lt;/a&gt; is a good example.</source>
          <target state="translated">JavaScript의 좋은 부분을 배우고 싶다면 &lt;a href=&quot;http://shop.oreilly.com/product/9780596517748.do&quot;&gt;JavaScript : The Good Parts를&lt;/a&gt; 읽어 보세요. 많은 가변성을 가진 call-by-value 어휘 범위 언어로 프로그램을 작성하는 방법을 알고 있다면 책을 건너 뛸 수 있습니다. &lt;a href=&quot;https://people.csail.mit.edu/jaffer/r4rs.pdf&quot;&gt;R &lt;sup&gt;4&lt;/sup&gt; RS Scheme&lt;/a&gt; 이 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">사용 가능한보다 엄격한 설정을 사용하려는 경우 지금 설정하는 것이 가장 좋습니다 ( 아래의 &lt;a href=&quot;#getting-stricter-checks&quot;&gt;보다 엄격한 검사 받기&lt;/a&gt; 참조). 당신이 타이프 라이터가 자동으로 추론하고 싶지는 않을 경우 예를 들어, &lt;code&gt;any&lt;/code&gt; 사용자가 명시 적으로 그렇게 말을하지 않고 유형을, 당신은 사용할 수 있습니다 &lt;code&gt;noImplicitAny&lt;/code&gt; 을 당신이 당신의 파일을 수정하기 전에. 다소 압도적으로 느껴질 수 있지만 장기적인 이익은 훨씬 빨리 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5184246af95057dfb4d9aaab56132b936756e920" translate="yes" xml:space="preserve">
          <source>If you provide an object that doesn&amp;rsquo;t match the interface you have provided, TypeScript will warn you:</source>
          <target state="translated">제공 한 인터페이스와 일치하지 않는 개체를 제공하면 TypeScript에서 다음과 같이 경고합니다.</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">이전 예제를 기억하는 경우 유형 집합의 기능에 대한 지식이있는 유형 집합에서 작동하는 일반 함수를 작성하려고 할 수 있습니다. 우리에 &lt;code&gt;loggingIdentity&lt;/code&gt; 의 예를 들어, 우리는 액세스 할 수 있기를 원 &lt;code&gt;.length&lt;/code&gt; 의 의 자산 &lt;code&gt;arg&lt;/code&gt; 하지만 컴파일러는 모든 종류의가 있다고 증명할 수 &lt;code&gt;.length&lt;/code&gt; 우리가이 가정을 할 수 있음을 경고, 그래서 속성을.</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">라이브러리 코드, 특히 파일 맨 위에 &lt;code&gt;typeof define&lt;/code&gt; , &lt;code&gt;typeof window&lt;/code&gt; 또는 &lt;code&gt;typeof module&lt;/code&gt; 에 대한 테스트가 표시되는 경우 거의 항상 UMD 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">TypeScript 가져 오기로 변환을 시작한 경우 &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; 과 같은 오류가 발생할 수 있습니다. . 여기서 문제는 라이브러리를 설명 할 &lt;em&gt;선언 파일&lt;/em&gt; 이 없을 수 있다는 것 입니다. 다행히 이것은 매우 쉽습니다. 타이프 라이터 같은 패키지에 대해 불평하는 경우 &lt;code&gt;lodash&lt;/code&gt; , 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">형식 매개 변수의 제약 조건이 지원하지 않는 방식으로 &lt;code&gt;y&lt;/code&gt; 를 사용 하면 오류가 올바르게 발생합니다. 이 경우 &lt;code&gt;T&lt;/code&gt; 의 제한 조건 은 (암시 적으로) &lt;code&gt;{}&lt;/code&gt; 이므로 마지막 예제는 적절하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5e5165e11849a0b5581c2dad31e4b0f7f73cb5bb" translate="yes" xml:space="preserve">
          <source>If you would like to disable or customize this feature, create a &lt;code&gt;jsconfig.json&lt;/code&gt; in the root of your project:</source>
          <target state="translated">이 기능을 비활성화하거나 사용자 지정 하려면 프로젝트 루트에 &lt;code&gt;jsconfig.json&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="87cb46c60d30559d817b085b18b7cb967b9fe7cd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to write tests for your .d.ts files, try &lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;tsd&lt;/a&gt;.</source>
          <target state="translated">.d.ts 파일에 대한 테스트를 작성하려면 tsd를 시도 &lt;a href=&quot;https://github.com/SamVerschueren/tsd&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">명시적인 것을 선호하는 경우 명시 적인 반환 유형을 사용하여 &lt;code&gt;yield&lt;/code&gt; 표현식 에서 반환, 산출 및 평가할 수있는 값 유형을 적용 할 수도 있습니다 . 다음, &lt;code&gt;next()&lt;/code&gt; 에서만 호출 할 수 있습니다 &lt;code&gt;boolean&lt;/code&gt; 들, 그리고 값에 따라 &lt;code&gt;done&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 중 하나입니다 &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="342b7134b6ae686fafbfd59ad7d6e4b1867ceab4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a Java or C# programmer that is new to JavaScript in general, we recommend learning a little bit of JavaScript &lt;em&gt;without&lt;/em&gt; types first to understand JavaScript&amp;rsquo;s runtime behaviors. Because TypeScript doesn&amp;rsquo;t change how your code &lt;em&gt;runs&lt;/em&gt;, you&amp;rsquo;ll still have to learn how JavaScript works in order to write code that actually does something!</source>
          <target state="translated">일반적으로 JavaScript를 처음 접하는 Java 또는 C # 프로그래머라면 JavaScript의 런타임 동작을 이해하기 위해 먼저 유형이 &lt;em&gt;없는&lt;/em&gt; JavaScript &lt;em&gt;를&lt;/em&gt; 조금 배우는 것이 좋습니다 . TypeScript는 코드 &lt;em&gt;실행&lt;/em&gt; 방식을 변경하지 않기 때문에 실제로 작업을 수행하는 코드를 작성하려면 JavaScript가 어떻게 작동하는지 배워야합니다!</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">네임 스페이스에서 모듈로 프로그램을 변환하는 경우 다음과 같은 파일로 쉽게 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">여러 개체를 내보내는 경우 모두 최상위 수준에 두십시오.</target>
        </trans-unit>
        <trans-unit id="d824a46b68a6c563ea08418e176071b76786c629" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with JavaScript already but are primarily a Java or C# programmer, this introductory page can help explain some of the common misconceptions and pitfalls you might be susceptible to. Some of the ways that TypeScript models types are quite different from Java or C#, and it&amp;rsquo;s important to keep these in mind when learning TypeScript.</source>
          <target state="translated">이미 JavaScript에 익숙하지만 주로 Java 또는 C # 프로그래머 인 경우이 소개 페이지는 사용자가 취약 할 수있는 일반적인 오해와 함정을 설명하는 데 도움이 될 수 있습니다. TypeScript 모델 유형 중 일부는 Java 또는 C #과 매우 다르며 TypeScript를 학습 할 때이를 염두에 두는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">React 프로젝트를 변환하려면 먼저 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">단일 &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;function&lt;/code&gt; 만 내보내는 경우 &lt;code&gt;export default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">이 안내서를 읽고 있다면 아마도 아마도 TypeScript의 유형이 무엇인지 이미 알고있을 것입니다. 좀 더 명확하게하기 위해, &lt;em&gt;타입&lt;/em&gt; 은 다음과 같이 소개됩니다 :</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">새로운 프로젝트를 시작하는 경우 먼저 &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React 빠른 시작 안내서를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">Gulp를 어떤 방식으로 &lt;a href=&quot;gulp&quot;&gt;사용&lt;/a&gt; 하는 경우 TypeScript와 함께 Gulp 를 사용 하고 Browserify, Babelify 및 Uglify와 같은 일반적인 빌드 도구와 통합하는 방법 에 대한 자습서가 있습니다 . 더 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonjs&lt;/code&gt; 이외의 모듈 옵션을 사용하는 경우 &lt;code&gt;moduleResolution&lt;/code&gt; 옵션을 &lt;code&gt;node&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">일반 JavaScript로 작성하는 경우 &lt;code&gt;.js&lt;/code&gt; 파일이 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;lib&lt;/code&gt; 또는 &lt;code&gt;dist&lt;/code&gt; 디렉토리 에있는 JavaScript를 직접 실행 한 다음 원하는대로 실행했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; type guard 에 대해 읽고 JavaScript 의 &lt;code&gt;instanceof&lt;/code&gt; 연산자에 익숙 하다면 이 섹션의 내용을 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">자바 스크립트를 불쾌하게 사용한 경우 다음 섹션에서 메모리를 새로 고칠 수 있습니다. JavaScript에서 &lt;code&gt;var&lt;/code&gt; 선언 의 모든 단점에 친숙한 경우 건너 뛰기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e114215a3320f3e8d3e8f7df80ee0813862362" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;outDir&lt;/code&gt; was &lt;code&gt;dist&lt;/code&gt;, TypeScript would write this tree:</source>
          <target state="translated">귀하의 경우 &lt;code&gt;outDir&lt;/code&gt; 있었다 &lt;code&gt;dist&lt;/code&gt; , 타이프 라이터는이 나무를 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">함수가 이름이 지정된 속성 키만 처리 할 수 있는 경우 선언에서 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">모든 속성 키를 처리 할 수있는 기능이 열려 있으면 변경을 다운 스트림으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">글로벌 라이브러리가 UMD 모듈에 의존하는 경우 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">라이브러리가 글로벌 라이브러리에 의존하는 경우 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">라이브러리가 모듈에 의존하는 경우 &lt;code&gt;import&lt;/code&gt; 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d7e714b624bcbe3efa868c9a33be75efd1d5cd0" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">모듈이 호출 가능하지 않거나 구성 가능하지 않은 경우 &lt;a href=&quot;module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; 파일을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">모듈을 호출하거나 구성 할 수없는 경우 &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; 파일을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">모듈 또는 UMD 라이브러리가 UMD 라이브러리에 의존하는 경우 &lt;code&gt;import&lt;/code&gt; 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">패키지에 기본 &lt;code&gt;.js&lt;/code&gt; 파일 이있는 경우 &lt;code&gt;package.json&lt;/code&gt; 파일에도 기본 선언 파일을 표시해야합니다 . 번들 속성 선언 파일을 가리 키도록 &lt;code&gt;types&lt;/code&gt; 속성을 설정 하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">패키지가 TypeScript로 작성되지 않은 경우 두 번째 방법이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">패키지가 TypeScript로 작성된 경우 첫 번째 방법이 선호됩니다. 선언 파일을 생성 하려면 &lt;code&gt;--declaration&lt;/code&gt; 플래그를 사용하십시오 . 이렇게하면 선언과 JavaScript가 항상 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="557fe20ea364d4b85526f359a785f2b91d2a48b9" translate="yes" xml:space="preserve">
          <source>If your project is large, you can use the flag &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; to disable the automatic loading of all projects. Instead, projects are loaded dynamically as you open files through your editor.</source>
          <target state="translated">프로젝트가 큰 경우 &lt;code&gt;disableReferencedProjectLoad&lt;/code&gt; 플래그 를 사용하여 모든 프로젝트의 자동로드를 비활성화 할 수 있습니다 . 대신 편집기를 통해 파일을 열 때 프로젝트가 동적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">유형 정의가 다른 패키지에 의존하는 경우 :</target>
        </trans-unit>
        <trans-unit id="55d1f300034ec5a2f0ab70c4ab7606f20472a2c0" translate="yes" xml:space="preserve">
          <source>If your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt;&lt;code&gt;--declaration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 소스 코드에 의해 생성 된 경우 소스 코드와 함께 유형을 게시하십시오. 두 타이프 라이터와 자바 스크립트 프로젝트를 통해 유형을 생성 할 수 있습니다 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#declaration&quot;&gt; &lt;code&gt;--declaration&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">암시적인 오류</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">암시 적 인덱스 서명</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">암시 적 반환</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="e388bb159f67517527bff80832c050cc9caf92f8" translate="yes" xml:space="preserve">
          <source>Import Helpers - &lt;code&gt;importHelpers&lt;/code&gt;</source>
          <target state="translated">가져 오기 도우미 &lt;code&gt;importHelpers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">부작용 전용 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">모듈에서 단일 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">가져 오기 선언도 선택적 &lt;code&gt;as&lt;/code&gt; 절을 사용하여 가져 오기에 다른 로컬 이름을 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">가져 오기 발광 헬퍼 (예 : &lt;code&gt;__extends&lt;/code&gt; , &lt;code&gt;__rest&lt;/code&gt; 에서, 등) &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">전체 모듈을 단일 변수로 가져 와서이를 사용하여 모듈 내보내기에 액세스</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">수입 유형</target>
        </trans-unit>
        <trans-unit id="104faef181cd8882668103e771e8eba923a2dcd8" translate="yes" xml:space="preserve">
          <source>Importantly, &lt;code&gt;rootDir&lt;/code&gt;&lt;strong&gt;does not affect which files become part of the compilation&lt;/strong&gt;. It has no interaction with the &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;exclude&lt;/code&gt;, or &lt;code&gt;files&lt;/code&gt;&lt;code&gt;tsconfig.json&lt;/code&gt; settings.</source>
          <target state="translated">중요한 것은 &lt;code&gt;rootDir&lt;/code&gt; &lt;strong&gt;가 컴파일의 일부가되는 파일에 영향을주지 않는다는 것입니다&lt;/strong&gt; . &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;exclude&lt;/code&gt; 또는 &lt;code&gt;files&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 설정 과 상호 작용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aa34d39c6555134662f510867cd143b4479edd11" translate="yes" xml:space="preserve">
          <source>Importing Types</source>
          <target state="translated">유형 가져 오기</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">모듈에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">가져 오기는 모듈에서 내보내는 것만 큼 쉽습니다. 내 보낸 선언은 아래 의 &lt;code&gt;import&lt;/code&gt; 양식 중 하나를 사용하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">참조 된 프로젝트에서 모듈을 가져 오면 대신 &lt;em&gt;출력&lt;/em&gt; 선언 파일 ( &lt;code&gt;.d.ts&lt;/code&gt; ) 이로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">모듈 로더 확장 (예 : &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt; )을 사용하여 비 코드 자원을 가져 오는 것은 쉽지 않았습니다. 이전에는 각 리소스에 대해 주변 모듈 선언을 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c444c4e966092782432f42e431dba46820d67082" translate="yes" xml:space="preserve">
          <source>Imports Not Used As Values - &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</source>
          <target state="translated">값으로 사용되지 않는 가져 오기 &lt;code&gt;importsNotUsedAsValues&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe0a4c588d4f7e13fddfb1185a854f0eb29bd646" translate="yes" xml:space="preserve">
          <source>Imports fine with &lt;code&gt;allowJs&lt;/code&gt; enabled:</source>
          <target state="translated">&lt;code&gt;allowJs&lt;/code&gt; 가 활성화 된 상태에서 잘 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">개선 된 &lt;code&gt;any&lt;/code&gt; 추론</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">교차로 유형으로 키 &lt;code&gt;keyof&lt;/code&gt; 개선</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">약속 된 UX 개선</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">조합 유형 호출에 대한 개선 된 동작</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 문 검사 개선</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">객체 리터럴 파괴 검사 개선</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">매핑 된 유형 수정 자에 대한 향상된 제어</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">공용체 유형에서 초과 속성 점검 개선</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">구조적으로 동일한 클래스 및 표현식 &lt;code&gt;instanceof&lt;/code&gt; 처리 개선</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">제네릭에 대한 향상된 추론</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015에서 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 대한 지원 개선</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">객체 리터럴에 대한 형식 유추 개선</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">통합 / 교차 유형 추론 개선</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 튜플 개선</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">에서 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 새 파일을 작성할 때 유용한 시작점 역할을 선언 파일의 번호를 찾을 수 있습니다. 사용할 템플릿 파일을 확인하려면 &lt;a href=&quot;library-structures&quot;&gt;라이브러리 구조&lt;/a&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">에서 &lt;code&gt;--strictNullChecks&lt;/code&gt; 의 모드, &lt;code&gt;?&lt;/code&gt; 수정자는 선택적 매개 변수와 유사한 요소 유형에 &lt;code&gt;undefined&lt;/code&gt; 자동으로 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">에서는 &lt;code&gt;getProperty&lt;/code&gt; 에 , &lt;code&gt;o: T&lt;/code&gt; 및 &lt;code&gt;propertyName: K&lt;/code&gt; , 그래서 수단 &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; . &lt;code&gt;T[K]&lt;/code&gt; 결과 를 반환하면 컴파일러는 키의 실제 유형을 인스턴스화하므로 &lt;code&gt;getProperty&lt;/code&gt; 의 반환 유형은 요청한 속성에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="0dd13518438c7329cf2fbf854c20974ad59ee4e1" translate="yes" xml:space="preserve">
          <source>In C# or Java, any given value or object has one exact type - either &lt;code&gt;null&lt;/code&gt;, a primitive, or a known class type. We can call methods like &lt;code&gt;value.GetType()&lt;/code&gt; or &lt;code&gt;value.getClass()&lt;/code&gt; to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can&amp;rsquo;t use two classes with similar shapes in lieu of each other unless there&amp;rsquo;s an explicit inheritance relationship or commonly-implemented interface.</source>
          <target state="translated">C # 또는 Java에서 주어진 값 또는 객체에는 하나의 정확한 유형 ( &lt;code&gt;null&lt;/code&gt; , 기본 또는 알려진 클래스 유형)이 있습니다. &lt;code&gt;value.GetType()&lt;/code&gt; 또는 &lt;code&gt;value.getClass()&lt;/code&gt; 와 같은 메서드를 호출 하여 런타임에 정확한 유형을 쿼리 할 수 ​​있습니다. 이 유형의 정의는 어떤 이름을 가진 클래스에 상주하며 명시적인 상속 관계 나 일반적으로 구현되는 인터페이스가없는 한 서로를 대신하여 비슷한 모양을 가진 두 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6827479b1d6256b64a352469a1cd16d7c9ad22a" translate="yes" xml:space="preserve">
          <source>In C# or Java, it&amp;rsquo;s meaningful to think of a one-to-one correspondence between runtime types and their compile-time declarations.</source>
          <target state="translated">C # 또는 Java에서 런타임 유형과 해당 컴파일 시간 선언 간의 일대일 대응을 생각하는 것은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c08d2e6fe05992c2156e08cd3c91dcc0de0788" translate="yes" xml:space="preserve">
          <source>In CommonJS you can export any value as the default export, for example here is a regular expression module:</source>
          <target state="translated">CommonJS에서는 모든 값을 기본 내보내기로 내보낼 수 있습니다. 예를 들어 다음은 정규식 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">ES2015에서 객체를 반환 생성자 암시 값 대신 &lt;code&gt;this&lt;/code&gt; 어느 호출자 &lt;code&gt;super()&lt;/code&gt; . 결과적으로, 잠재적 인 &lt;code&gt;super()&lt;/code&gt; 의 리턴 값을 캡처 하여이를 &lt;code&gt;this&lt;/code&gt; 로 대체해야 합니다 . 이 변경으로 &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;사용자 정의 요소&lt;/a&gt; 작업이 가능해 지며,이를 통해 사용자 작성 생성자로 브라우저 할당 요소를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">ES6 모듈 로더에서 최상위 레벨 오브젝트 (여기서 &lt;code&gt;exp&lt;/code&gt; 로 가져 오기 )는 특성 만 가질 수 있습니다. 최상위 모듈 객체는 호출 할 수 &lt;em&gt;없습니다&lt;/em&gt; . 여기서 가장 일반적인 해결책 은 호출 가능 / 구성 가능 오브젝트에 대한 &lt;code&gt;default&lt;/code&gt; 내보내기 를 정의하는 것입니다. 일부 모듈 로더 shim은이 상황을 자동으로 감지하여 최상위 수준 개체를 &lt;code&gt;default&lt;/code&gt; 내보내기로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="73164a9f408dbb559f1ff8a82aed1d6f3a2cf1a3" translate="yes" xml:space="preserve">
          <source>In ES6-compl module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object can &lt;em&gt;never&lt;/em&gt; be callable.</source>
          <target state="translated">ES6-compl 모듈 로더에서 최상위 객체 (여기서는 &lt;code&gt;exp&lt;/code&gt; 로 가져옴 )는 속성 만 가질 수 있습니다. 최상위 모듈 객체는 &lt;em&gt;절대로&lt;/em&gt; 호출 할 수 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">Edge에서 F12를 누르고 디버거 탭을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">JSDoc 참조에서</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">JavaScript에서는 속성 이름을 매개 변수로 사용하는 API를 사용하는 것이 일반적이지만 지금까지 이러한 API에서 발생하는 형식 관계를 표현할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;this&lt;/code&gt; 함수가 호출 될 때 설정되는 변수입니다. 이것은 매우 강력하고 유연한 기능이지만, 함수가 실행되는 컨텍스트에 대해 항상 알아야하는 비용이 발생합니다. 특히 함수를 리턴하거나 함수를 인수로 전달할 때 혼동을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">JavaScript에서 &lt;code&gt;var&lt;/code&gt; 선언은 포함 범위의 맨 위로 &quot;게양&quot;됩니다. 이로 인해 혼란스러운 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">JavaScript에서 모든 매개 변수는 선택 사항이며 사용자는 원하는대로 매개 변수를 그대로 둘 수 있습니다. 그들이 할 때, 그들의 가치는 &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;?&lt;/code&gt; 를 추가하면 TypeScript에서이 기능을 사용할 수 있습니다 . 매개 변수의 끝까지 우리는 선택 사항이되고 싶습니다. 예를 들어 위에서 성 매개 변수를 선택적으로 사용한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="67651f3f892a0de5974b0da9cae101fc0f274b31" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions can live anywhere, and data can be passed around freely without being inside a pre-defined &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;. This flexibility is extremely powerful. &amp;ldquo;Free&amp;rdquo; functions (those not associated with a class) working over data without an implied OOP hierarchy tends to be the preferred model for writing programs in JavaScript.</source>
          <target state="translated">JavaScript에서 함수는 어디에나있을 수 있으며 데이터는 사전 정의 된 &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 내부에 있지 않고도 자유롭게 전달할 수 있습니다 . 이러한 유연성은 매우 강력합니다. 묵시적인 OOP 계층 구조없이 데이터에 대해 작동하는 &quot;자유&quot;함수 (클래스와 연관되지 않음)는 JavaScript로 프로그램을 작성하는 데 선호되는 모델 인 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a818fdd28b569608ea92c5b8fbf2223393403d4" translate="yes" xml:space="preserve">
          <source>In JavaScript, mutability is the default, although it allows variable declarations with &lt;code&gt;const&lt;/code&gt; to declare that the &lt;em&gt;reference&lt;/em&gt; is immutable. The referent is still mutable:</source>
          <target state="translated">JavaScript에서는 가변성이 기본값이지만 &lt;code&gt;const&lt;/code&gt; 를 사용하여 변수 선언 이 &lt;em&gt;참조&lt;/em&gt; 가 변경 불가능 함 을 선언 할 수 있도록 허용합니다 . 지시 대상은 여전히 ​​변경 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">Node.js에서 대부분의 작업은 하나 이상의 모듈을로드하여 수행됩니다. 최상위 내보내기 선언 을 사용하여 각 모듈을 자체 &lt;code&gt;.d.ts&lt;/code&gt; 파일로 정의 할 수 있지만 더 큰 &lt;code&gt;.d.ts&lt;/code&gt; 파일 로 작성하는 것이 더 편리 합니다. 이를 위해 앰비언트 네임 스페이스와 유사한 구성을 사용하지만 나중에 가져올 수 있는 &lt;code&gt;module&lt;/code&gt; 키워드와 인용 된 이름을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">TypeScript 1.4에서는 모든 대상에 대한 템플릿 문자열에 대한 지원이 추가되었으며 ES6에 대해서만 태그가 지정된 템플릿이 추가되었습니다. &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe가&lt;/a&gt; 수행 한 상당한 작업 덕분 에 ES3 및 ES5에서 태그가 지정된 템플릿의 격차를 해소했습니다.</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">최신 버전의 react.d.ts (위 참조)가있는 TypeScript 1.8에서는 &lt;code&gt;props&lt;/code&gt; 유형 의 선언을 크게 단순화했습니다 .</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">TypeScript 2.0에서는 선언 파일을 가져 와서 사용하고 찾는 데있어 선언 파일을 사용하는 것이 훨씬 쉬워졌습니다. 이 페이지는 세 가지 방법을 모두 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">TypeScript 2.3에서 TS는 &lt;em&gt;하위&lt;/em&gt; 유형 검사를 도입했습니다 . &lt;em&gt;children&lt;/em&gt; 은 자식 &lt;em&gt;JSXExpression&lt;/em&gt; 이 속성에 삽입 되는 &lt;em&gt;요소 속성 유형&lt;/em&gt; 의 특수 속성입니다 . TS는 사용하는 방법과 유사 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 을 의 이름을 결정하기 위해 &lt;em&gt;소품&lt;/em&gt; , TS는 사용 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 을 의 이름을 결정하기 위해 &lt;em&gt;어린이&lt;/em&gt; 들 소품 이내입니다. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 는 단일 속성으로 선언해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">TypeScript 2.4에서는 속성이 겹치지 않으면 약한 유형에 아무것도 할당하지 않는 것이 오류입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">TypeScript 2.4에서 오른쪽의 함수는 암시 적으로 형식 매개 변수를 &lt;em&gt;얻으며 &lt;/em&gt; &lt;code&gt;y&lt;/code&gt; 는 해당 형식 매개 변수의 형식을 갖는 것으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">TypeScript 2.6 및 이전 버전에서 &lt;code&gt;[number, string, string]&lt;/code&gt; 은 &lt;code&gt;[number, string]&lt;/code&gt; 의 하위 유형으로 간주되었습니다 . 이것은 TypeScript의 구조적 특성에 의해 동기가 부여되었습니다. (A)의 제 1 및 제 2 요소 &lt;code&gt;[number, string, string]&lt;/code&gt; 각각의 제 1 및 제 2 요소의 서브 타입이다 &lt;code&gt;[number, string]&lt;/code&gt; . 그러나 실제 튜플 사용을 조사한 결과, 이것이 허용 된 대부분의 상황이 일반적으로 바람직하지 않다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">TypeScript 2.7에서는 다른 속성의 튜플을 더 이상 서로 할당 할 수 없습니다. &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt; 의 풀 요청 덕분에 이제 튜플 유형은 해당 &lt;code&gt;length&lt;/code&gt; 속성 의 유형으로 arity를 ​​인코딩 합니다. 이는 숫자 리터럴 유형을 활용하여 튜플을 다른 인종의 튜플과 구별 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">TypeScript 3.1에서 튜플과 배열에 매핑 된 객체 유형 &lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 은 이제 &lt;code&gt;push()&lt;/code&gt; , &lt;code&gt;pop()&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 같은 멤버 가 변환 되는 새 유형을 만드는 대신 새로운 튜플 / 배열을 생성합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">TypeScript 3.2에서 객체 리터럴은 이제 &lt;code&gt;Object.assign&lt;/code&gt; 함수 및 JSX 리터럴과 유사한 교차 유형을 생성하는 일반 스프레드 식을 허용 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">TypeScript 3.3에서 &lt;code&gt;--build&lt;/code&gt; 모드의 &lt;code&gt;--watch&lt;/code&gt; 플래그 &lt;em&gt;는&lt;/em&gt; 증분 파일 감시도 활용합니다. 즉 &lt;code&gt;--build --watch&lt;/code&gt; 에서 빌드가 훨씬 빨라질 수 있습니다 . 테스트에서이 기능은 원래 &lt;code&gt;--build --watch&lt;/code&gt; 시간 의 &lt;strong&gt;빌드 시간&lt;/strong&gt; 을 &lt;strong&gt;50 %에서 75 %까지 &lt;/strong&gt;줄였습니다 . 특정 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;풀을보기 위해 변경에 대한 원래 풀 요청에 대해 자세히 읽을 수&lt;/a&gt; 있지만 대부분의 복합 프로젝트 사용자는 여기에서 상당한 승리를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">TypeScript 3.3에서는 이러한 서명의 매개 변수가 서로 &lt;em&gt;교차&lt;/em&gt; 하여 새 서명을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">TypeScript 3.3에서는 더 이상 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4 및 이전 버전에서는 실제로 초과해서는 안되는 상황에서 특정 초과 속성이 허용되었습니다. 예를 들어, 타이프 3.4 잘못된 허용 된 &lt;code&gt;name&lt;/code&gt; 의 유형 사이에 일치하지 않는 경우에도 객체 리터럴 재산 &lt;code&gt;Point&lt;/code&gt; 와 &lt;code&gt;Label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">TypeScript 3.4 및 이전 버전에서는 다음 예제가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">TypeScript 3.4 에서 매핑 된 형식 의 &lt;code&gt;readonly&lt;/code&gt; 수정자는 배열과 같은 형식을 해당 &lt;code&gt;readonly&lt;/code&gt; 형식으로 자동 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">TypeScript 3.4에서는 다음과 같이 함수를 반환하는 일반 함수에 대한 추론이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">TypeScript 3.5에서 형식 검사기는 제공된 모든 속성이 &lt;em&gt;일부&lt;/em&gt; 공용체 멤버에 속 하고 적절한 형식을 가지고 있는지 확인합니다. 즉, 위의 샘플에서 오류가 올바르게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.5에서는 &lt;code&gt;T&lt;/code&gt; 와 같이 구별 속성이있는 유형에 할당 할 때 실제로 언어 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;S&lt;/code&gt; 와 같은 유형을 가능한 모든 거주 유형의 결합으로 분해 합니다. 이 경우, &lt;code&gt;boolean&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 의 결합 이므로 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 및 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 의 결합으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">TypeScript 3.5에서는 다음과 같은 UMD 전역 선언을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">TypeScript 3.6에서 검사기는 이제 첫 번째 예제에서 &lt;code&gt;curr.value&lt;/code&gt; 의 올바른 유형 이 &lt;code&gt;string&lt;/code&gt; 이어야한다는 것을 알고 있으며 마지막 예제에서 &lt;code&gt;next()&lt;/code&gt; 를 호출 할 때 올바르게 오류가 발생합니다 . 몇 가지 새로운 형식 매개 변수를 포함 하도록 &lt;code&gt;Iterator&lt;/code&gt; 및 &lt;code&gt;IteratorResult&lt;/code&gt; 형식 선언 의 일부 변경 과 TypeScript가 &lt;code&gt;Generator&lt;/code&gt; 형식 이라는 생성기를 나타내는 데 사용하는 새로운 형식 덕분 입니다.</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">TypeScript 3.7에서는 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;이제 중복 식별자 오류로 올바르게 식별됩니다&lt;/a&gt; . 올바른 수정은 작성자의 원래 의도에 따라 다르며 사례별로 해결해야합니다. 일반적으로 명명 충돌은 의도하지 않은 것이며 가장 좋은 방법은 가져온 유형의 이름을 바꾸는 것입니다. 가져온 유형을 기능 보강하려는 경우 대신 적절한 모듈 기능 보강을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">TypeScript 3.7에서는 컴파일러 자체가이 기능을 활용하므로 생성 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일도 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 접근 자를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">TypeScript 3.7에서 컴파일러는이 기능을 활용 하여 &lt;code&gt;.js&lt;/code&gt; 파일 에서 생성 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일 이 클래스와 유사한 함수의 호출 가능성과 구성 가능성을 적절히 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">TypeScript 3.7에서 이는 가능한 오류로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">TypeScript 3.7에서는 종속성이있는 프로젝트를 열 때 TypeScript가 자동으로 소스 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 파일을 사용합니다. 즉, 프로젝트 참조를 사용하는 프로젝트는 시맨틱 작업이 최신 상태이고 &quot;정상적으로 작동하는&quot;향상된 편집 환경을 볼 수 있습니다. 컴파일러 옵션 &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; 를 사용하여이 동작을 비활성화 할 수 있습니다.이 변경은이 변경이 편집 성능에 영향을 줄 수있는 매우 큰 프로젝트에서 작업 할 때 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35647c7752475abd065982be5bc1b280eb87d72" translate="yes" xml:space="preserve">
          <source>In TypeScript 4.1, we added the ability to disable the special-casing where a filename would trigger type acquisition:</source>
          <target state="translated">TypeScript 4.1에서는 파일 이름이 유형 획득을 트리거하는 특수 케이스를 비활성화하는 기능을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">TypeScript 또는 ES6에서 &lt;code&gt;import&lt;/code&gt; 키워드는 동일한 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">TypeScript에서 선언은 네임 스페이스, 유형 또는 값의 세 그룹 중 하나 이상에 엔터티를 만듭니다. 네임 스페이스 생성 선언은 점으로 구분 된 표기법을 사용하여 액세스하는 이름이 포함 된 네임 스페이스를 만듭니다. 형식 작성 선언은 다음과 같이합니다. 선언 된 모양으로 표시되고 지정된 이름에 바인딩 된 형식을 만듭니다. 마지막으로, 가치 창출 선언은 출력 JavaScript에서 볼 수있는 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScript에서 &lt;code&gt;undefined&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 은 실제로 각각 &lt;code&gt;undefined&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 이라는 자체 유형을 갖습니다 . &lt;code&gt;void&lt;/code&gt; 와 마찬가지로 , 자체적으로 매우 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="376a74b14286aaed0718f841b6819ef69ddf714d" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScript에서 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 은 실제로 각각 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 이라는 유형을 갖습니다 . &lt;code&gt;void&lt;/code&gt; 와 매우 비슷하지만 그 자체로는 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">TypeScript에서는 모든 매개 변수가 함수에 필요하다고 가정합니다. 이것은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 지정할 수 없다는 것을 의미하는 것이 아니라 함수가 호출 될 때 사용자가 각 매개 변수에 대한 값을 제공했는지 확인합니다. 또한 컴파일러는 이러한 매개 변수가 함수에 전달 될 유일한 매개 변수라고 가정합니다. 간단히 말해서 함수에 주어진 인수의 수는 함수가 기대하는 매개 변수의 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="740a107698ee1408e32efe4710e0a388e20d2757" translate="yes" xml:space="preserve">
          <source>In TypeScript, it&amp;rsquo;s better to think of a type as a &lt;em&gt;set of values&lt;/em&gt; that share something in common. Because types are just sets, a particular value can belong to &lt;em&gt;many&lt;/em&gt; sets at the same time.</source>
          <target state="translated">TypeScript에서는 유형 을 공통점을 공유 하는 &lt;em&gt;일련의 값&lt;/em&gt; 으로 생각하는 것이 좋습니다 . 유형은 세트 일 뿐이므로 특정 값은 동시에 &lt;em&gt;여러&lt;/em&gt; 세트에 속할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">ECMAScript 2015에서와 마찬가지로 TypeScript에서는 최상위 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 가 포함 된 모든 파일 이 모듈로 간주됩니다. 반대로 최상위 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 선언이 없는 파일 은 전역 범위에서 모듈을 사용할 수있는 내용의 스크립트로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5a8756023ca1bc1f9c910f749b9c017f2449d68f" translate="yes" xml:space="preserve">
          <source>In TypeScript, objects are &lt;em&gt;not&lt;/em&gt; of a single exact type. For example, if we construct an object that satisfies an interface, we can use that object where that interface is expected even though there was no declarative relationship between the two.</source>
          <target state="translated">TypeScript에서 객체는 정확한 단일 유형 이 &lt;em&gt;아닙니다&lt;/em&gt; . 예를 들어 인터페이스를 만족하는 객체를 구성하면 둘 사이에 선언적 관계가 없더라도 해당 인터페이스가 예상되는 곳에 해당 객체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">TypeScript에는 명시 적 형식 주석이 없을 때 형식 정보를 제공하기 위해 형식 유추가 사용되는 여러 곳이 있습니다. 예를 들어이 코드에서</target>
        </trans-unit>
        <trans-unit id="f94b6ab9fb3640d8233848ba38c368f3d8f60f94" translate="yes" xml:space="preserve">
          <source>In TypeScript, this becomes very natural once you realize that every type is just a set. How do you describe a value that either belongs in the &lt;code&gt;string&lt;/code&gt; set or the &lt;code&gt;number&lt;/code&gt; set? It simply belongs to the &lt;em&gt;union&lt;/em&gt; of those sets: &lt;code&gt;string | number&lt;/code&gt;.</source>
          <target state="translated">TypeScript에서는 모든 유형이 집합에 불과하다는 사실을 알게되면 매우 자연스럽게됩니다. &lt;code&gt;string&lt;/code&gt; 세트 또는 &lt;code&gt;number&lt;/code&gt; 세트에 속하는 값을 어떻게 설명 합니까? 그것은 단순히 그 집합 들의 &lt;em&gt;합집합&lt;/em&gt; 에 속합니다 : &lt;code&gt;string | number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01387e736054bef643d83587b4cbec5e0463e320" translate="yes" xml:space="preserve">
          <source>In TypeScript, union types are untagged. In other words, they are not discriminated unions like &lt;code&gt;data&lt;/code&gt; in Haskell. However, you can often discriminate types in a union using built-in tags or other properties.</source>
          <target state="translated">TypeScript에서 공용체 유형은 태그가 없습니다. 즉, Haskell의 &lt;code&gt;data&lt;/code&gt; 처럼 차별적 인 결합이 아닙니다 . 그러나 내장 태그 또는 기타 속성을 사용하여 공용체에서 유형을 구별 할 수있는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">TypeScript에서는 사용자가 매개 변수를 제공하지 않거나 사용자가 대신 &lt;code&gt;undefined&lt;/code&gt; 로 전달하는 경우 매개 변수가 할당되는 값을 설정할 수도 있습니다 . 이를 기본 초기화 매개 변수라고합니다. 이전 예제를 취하고 성을 기본적으로 &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; 로 하자 .</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">TypeScript에서는 일반적인 객체 지향 패턴을 사용할 수 있습니다. 클래스 기반 프로그래밍에서 가장 기본적인 패턴 중 하나는 상속을 사용하여 기존 클래스를 확장하여 새 클래스를 만들 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8e346034f4b9c87e315e751122dc5fbf7c51de0" translate="yes" xml:space="preserve">
          <source>In TypeScript, when you reference a &lt;code&gt;const enum&lt;/code&gt; member, the reference is replaced by its actual value in the emitted JavaScript. Changing this TypeScript:</source>
          <target state="translated">TypeScript에서 &lt;code&gt;const enum&lt;/code&gt; 멤버 를 참조 할 때 참조는 내 보낸 JavaScript의 실제 값으로 대체됩니다. 이 TypeScript 변경 :</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">TypeScript에서는 이러한 인수를 변수로 모을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2921849633d9d452ad28f4123936c20449f9b7e" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can import a &lt;em&gt;type&lt;/em&gt; and then subsequently export it:</source>
          <target state="translated">TypeScript에서 &lt;em&gt;유형&lt;/em&gt; 을 가져온 다음 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">TypeScript에서는 &lt;code&gt;export =&lt;/code&gt; construct를 사용하여이를 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27303aa11138b00840e8f1322a88fdb13ab539ac" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, TypeScript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일, 타이프 라이터는 CommonJS 모듈 형식을 이해한다. &lt;code&gt;exports&lt;/code&gt; 및 &lt;code&gt;module.exports&lt;/code&gt; 에 대한 할당 은 내보내기 선언으로 인식됩니다. 마찬가지로 &lt;code&gt;require&lt;/code&gt; 함수 호출은 모듈 가져 오기로 인식됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일, 타이프 라이터는 CommonJS 모듈 형식을 이해한다. &lt;code&gt;exports&lt;/code&gt; 및 &lt;code&gt;module.exports&lt;/code&gt; 에 대한 지정 은 내보내기 선언으로 인식됩니다. 이와 유사하게, &lt;code&gt;require&lt;/code&gt; 함수 호출이 모듈 수입으로 인식하고 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일, 클래스 본문 내부의 속성 할당에서 컴파일러를 추론 속성. 속성의 유형은 정의되지 않았거나 생성자의 유형이 정의되지 않았거나 null이 아닌 한 생성자에 지정된 유형입니다. 이 경우 유형은 이러한 할당에서 모든 오른쪽 값 유형의 합집합입니다. 생성자에 정의 된 속성은 항상 존재하는 것으로 간주되는 반면 메서드, getter 또는 setter에 정의 된 속성은 선택적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일 형식은 종종 그냥 같이 추정 할 수있다 &lt;code&gt;.ts&lt;/code&gt; 파일입니다. 마찬가지로 형식을 유추 할 수없는 경우 형식 주석이 &lt;code&gt;.ts&lt;/code&gt; 파일 에서 사용되는 것과 같은 방식으로 JSDoc을 사용하여 형식을 지정할 수 있습니다 . Typescript와 &lt;code&gt;--noImplicitAny&lt;/code&gt; 는 컴파일러가 형식을 유추 할 수없는 곳에 오류를 제공합니다. (오픈 엔드 객체 리터럴을 제외하고 자세한 내용은 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="25a5bd4d9bac97fbf88351aa757a14e4470bc35e" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred. When types can&amp;rsquo;t be inferred, they can be specified using JSDoc syntax.</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일 형식은 종종 유추 할 수있다. 유형을 추론 할 수없는 경우 JSDoc 구문을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">A의 &lt;code&gt;.ts&lt;/code&gt; 파일을 변수 선언을 초기화 객체 리터럴은 선언 유형을 제공한다. 원래 리터럴에 지정되지 않은 새 멤버를 추가 할 수 없습니다. 이 규칙은 &lt;code&gt;.js&lt;/code&gt; 파일 에서 완화 됩니다. 객체 리터럴에는 원래 정의되지 않은 속성을 추가하고 조회 할 수있는 개방형 형식 (인덱스 서명)이 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">a는에 &lt;code&gt;for...in&lt;/code&gt; 일반적인 유형의 개체에 대한 문 &lt;code&gt;T&lt;/code&gt; , 반복 변수의 추론 유형은 이전이었다 &lt;code&gt;keyof T&lt;/code&gt; 하지만 지금 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; . 즉, 문자열과 같은 값만 포함 하는 &lt;code&gt;keyof T&lt;/code&gt; 의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">반환 유형 주석이없는 함수 표현식 또는 화살표 함수에서 함수에 &lt;code&gt;return&lt;/code&gt; 문이 없거나 유형 표현식이있는 &lt;code&gt;return&lt;/code&gt; 문 만 있는 경우 &lt;code&gt;never&lt;/code&gt; 있고 함수의 끝점에 도달 할 수없는 경우 (제어 플로우 분석에 의해 결정됨) 함수에 대한 유추 된 반환 유형은 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">명시 적으로 함수에서 &lt;code&gt;never&lt;/code&gt; 반환 유형 약어, 모든 &lt;code&gt;return&lt;/code&gt; 문 (있는 경우) 형태의 표현이 없어야합니다 &lt;code&gt;never&lt;/code&gt; 및 함수의 끝 지점에 도달 할 수 없습니다해야합니다.</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">매핑 된 형태 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; , 각 캐릭터 문자 타입 &lt;code&gt;K&lt;/code&gt; 는 문자열 이름의 속성은, 각각의 숫자 문자 유형 도입 &lt;code&gt;K&lt;/code&gt; 가 있는 숫자 이름의 속성, 각각 고유 심볼 유형 도입 &lt;code&gt;K&lt;/code&gt; 의 소개를 고유 한 심볼 이름을 가진 속성 또한 &lt;code&gt;K&lt;/code&gt; 에 &lt;code&gt;string&lt;/code&gt; 유형이 포함 된 경우 문자열 인덱스 서명이 도입되고 &lt;code&gt;K&lt;/code&gt; 에 유형 &lt;code&gt;number&lt;/code&gt; 포함 된 경우 숫자 색인 서명이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">어떤 의미에서, 명확한 할당 어설 션 연산자는 null이 아닌 어설 션 연산자 ( &lt;em&gt;표현식&lt;/em&gt; 에 &lt;code&gt;!&lt;/code&gt; 로 포스트 고정 되는)의 이중이며, 이 예제에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">비슷한 예에서 일반 매개 변수를 전체 인터페이스의 매개 변수로 이동하려고 할 수 있습니다. 이를 통해 일반적인 유형을 확인할 수 있습니다 (예 : &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; 이 아니라 단지보다는 &lt;code&gt;Dictionary&lt;/code&gt; ). 이렇게하면 인터페이스의 다른 모든 멤버가 type 매개 변수를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73ef161e383c012e8b216e70c23095705c0088c" translate="yes" xml:space="preserve">
          <source>In a structural type system, if two objects have the same shape, they are considered to be of the same type.</source>
          <target state="translated">구조 유형 시스템에서 두 개체의 모양이 동일한 경우 동일한 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">이외에도 &lt;code&gt;AMD&lt;/code&gt; 와 &lt;code&gt;CommonJS&lt;/code&gt; 모듈 로더, 타이프 해주기 발광 모듈 지원 &lt;code&gt;UMD&lt;/code&gt; ( &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;범용 모듈 정의&lt;/a&gt; ) 및&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; 모듈 형식.</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">이외에 &lt;code&gt;Partial&lt;/code&gt; 매핑 된 부분 Partial 유형에 대한 많은 유용한 변환을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">위와 같은 구성 패턴 외에도 일반 생성자에 대한이 새로운 추론은 React와 같은 특정 UI 라이브러리의 클래스 구성 요소에서 작동하는 함수가 일반 클래스 구성 요소에서 더 정확하게 작동 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">멤버의 속성 이름으로 객체를 만드는 것 외에도 숫자 열거 형 멤버는 &lt;em&gt;역 매핑을&lt;/em&gt; 얻습니다.&lt;em&gt;&lt;/em&gt; 열거 형 값에서 열거 형 이름 됩니다. 예를 들어,이 예에서 :</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">제네릭 인터페이스 외에도 제네릭 클래스를 만들 수도 있습니다. 일반 열거 형과 네임 스페이스를 만들 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca19e30943988803be9117e262453a87e81dfc67" translate="yes" xml:space="preserve">
          <source>In addition to that, Babel cannot create &lt;code&gt;.d.ts&lt;/code&gt; files for your TypeScript which can make it harder to work with your project if it is a library.</source>
          <target state="translated">또한 Babel은 &lt;code&gt;.d.ts&lt;/code&gt; 용 .d.ts 파일을 만들 수 없으므로 프로젝트가 라이브러리 인 경우 작업하기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 로 선언을 장식하는 기존 TypeScript 지원 외에도 별도의 내보내기 선언을 사용하여 모듈 멤버 를 내보낼 수 있으며 선택적 &lt;code&gt;as&lt;/code&gt; 절을 사용하여 내보내기에 다른 이름을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">내부 클래스의 패턴 외에도 함수를 작성한 다음 함수에 특성을 추가하여 함수를 추가로 확장하는 JavaScript 실습에 익숙 할 수 있습니다. TypeScript는 선언 병합을 사용하여 형식이 안전한 방식으로 이와 같은 정의를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="87ddb0a5f5f96059703ab579dd4aebc339c8a186" translate="yes" xml:space="preserve">
          <source>In addition to unions, TypeScript also has intersections:</source>
          <target state="translated">공용체 외에도 TypeScript에는 교차점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">사용자 정의 기호 외에도 잘 알려진 내장 기호가 있습니다. 내장 기호는 내부 언어 동작을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">또한 엔티티는 여러 상황에서 &lt;em&gt;암시 적으로&lt;/em&gt; 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">다른 모든 경우에는 열거 형 멤버가 계산 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 제거 할 수없는 경우 형식 어설 션 연산자를 사용하여 수동으로 제거 할 수 있습니다. 구문은 postfix입니다 &lt;code&gt;!&lt;/code&gt; : &lt;code&gt;identifier!&lt;/code&gt; &lt;code&gt;identifier&lt;/code&gt; 유형에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="772971872a07a06b821a02e99558860d312742f3" translate="yes" xml:space="preserve">
          <source>In cases where you don&amp;rsquo;t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use &lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 타입을 받아들이고 싶은지 모르거나, 어떤 것을 받아들이고 싶은 경우, 상호 작용하지 않고 맹목적으로 통과 할 것이기 때문에, &lt;a href=&quot;https://www.typescriptlang.org/play/#example/unknown-and-never&quot;&gt; &lt;code&gt;unknown&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">이전 버전의 TypeScript에서는 배열 유형에서 다르게 작동하도록 매핑 된 유형을 일반화했습니다. 이것은 &lt;code&gt;Boxify&lt;/code&gt; 와 같은 매핑 된 유형이 배열 및 튜플에서 모두 작동 할 수 있음을 의미했습니다 .</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">정확하게 말하면 &lt;code&gt;--strict&lt;/code&gt; 옵션은 &lt;em&gt;기본값을&lt;/em&gt; 설정합니다&lt;em&gt;&lt;/em&gt; 위에 나열된 컴파일러 옵션 . 즉, 옵션을 개별적으로 제어 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">extends 절</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">함수 호출에서</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">일반적으로 상대 모듈을 사용하여 리포지토리를 전환하는 데 필요한 것은별로 없습니다. 단순히 배치 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 주어진 상위 폴더의 각 하위 디렉토리에 파일을 추가합니다 &lt;code&gt;reference&lt;/code&gt; 하여 프로그램의 적층 구성에 맞게 이러한 설정 파일에들. 당신이 중 하나를 설정을해야합니다 &lt;code&gt;outDir&lt;/code&gt; 출력 폴더의 명시 적 하위 폴더, 또는 설정 &lt;code&gt;rootDir&lt;/code&gt; 모든 프로젝트 폴더의 일반적인 루트.</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">분배 조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 인스턴스화에서 U? X : Y , 조건 유형 내의 &lt;code&gt;T&lt;/code&gt; 에 대한 참조 는 조합 유형의 개별 구성 요소로 해석됩니다 (즉, &lt;code&gt;T&lt;/code&gt; 는 조건 유형이 결합 유형에 분배 된 &lt;em&gt;후&lt;/em&gt; 개별 구성 요소를 나타냄 ). 또한 &lt;code&gt;X&lt;/code&gt; 내의 &lt;code&gt;T&lt;/code&gt; 에 대한 참조 에는 추가 유형 매개 변수 제약 조건 &lt;code&gt;U&lt;/code&gt; 가 있습니다 (즉, &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 내의 &lt;code&gt;U&lt;/code&gt; 에 할당 가능한 것으로 간주 됨 ).</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">C # 및 Java와 같은 언어에서 재사용 가능한 컴포넌트를 작성하기위한 도구 상자의 주요 도구 중 하나는 &lt;em&gt;제네릭입니다.&lt;/em&gt; . 즉, 단일 유형이 아닌 다양한 유형에서 작동 할 수있는 컴포넌트를 작성할 수 있습니다. 이를 통해 사용자는 이러한 구성 요소를 소비하고 자체 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">대부분의 경우 열거 형은 완벽하게 유효한 솔루션입니다. 그러나 때로는 요구 사항이 더 엄격합니다. 열거 형 값에 액세스 할 때 추가로 생성 된 코드 및 추가 간접비를 지불하지 않기 위해 &lt;code&gt;const&lt;/code&gt; 열거 형 을 사용할 수 있습니다 . Const 열거 형은 열거 형의 &lt;code&gt;const&lt;/code&gt; 한정자를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">대부분의 경우 형식 유추는 간단합니다. 다음 섹션에서는 유형을 유추하는 방법에 대한 몇 가지 뉘앙스를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8275babe4b4f5b3a44f6ddcca26a506ab31a4496" translate="yes" xml:space="preserve">
          <source>In multi-project TypeScript programs, TypeScript will load all of the available projects into memory in order to provide accurate results for editor responses which require a full knowledge graph like &amp;lsquo;Find All References&amp;rsquo;.</source>
          <target state="translated">다중 프로젝트 TypeScript 프로그램에서 TypeScript는 '모든 참조 찾기'와 같은 완전한 지식 그래프가 필요한 편집기 응답에 대한 정확한 결과를 제공하기 위해 사용 가능한 모든 프로젝트를 메모리에로드합니다.</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">C # 또는 Java와 같은 명목 유형 언어에서 &lt;code&gt;Person&lt;/code&gt; 클래스는 자신을 &lt;code&gt;Named&lt;/code&gt; 의 구현 자로 명시 적으로 설명하지 않기 때문에 해당 코드가 오류 가됩니다. 인터페이스 됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 TypeScript에서는 유형 별칭을 확장하거나 구현할 수 없었습니다 (다른 유형을 확장 / 구현할 수도 없음). 버전 2.7 &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; 유형과 같은 새 교차 유형을 작성하여 유형 별명을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">이전 버전에서 TypeScript는 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 와 같은 다른 유형 변수에서 유추 할 때 빈 객체 유형 ( &lt;code&gt;{}&lt;/code&gt; )을 유추합니다. .</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">컴파일러가 올바른 유형 검사를 선택하려면 기본 JavaScript와 유사한 프로세스를 따릅니다. 오버로드 목록을보고 첫 번째 오버로드를 진행하면서 제공된 매개 변수를 사용하여 함수를 호출하려고 시도합니다. 일치하는 것을 찾으면이 과부하를 올바른 과부하로 선택합니다. 이러한 이유로 과부하를 가장 구체적으로 또는 덜 구체적으로 주문하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">함수 가 모든 코드 경로에서 &lt;code&gt;undefined&lt;/code&gt; 거나 효과적으로 반환 되지 않도록하려면, TypeScript 는 함수의 끝에서 &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 같은 구문 신호가 필요했습니다 . 따라서 사용자는 자신 이 실패한 기능을 &lt;code&gt;return&lt;/code&gt; 한다는 것을 알았습니다 .</target>
        </trans-unit>
        <trans-unit id="a5553c9db2df72c8e161b64c0bb7751b40bdbd3c" translate="yes" xml:space="preserve">
          <source>In order to provide rich debugging tools and crash reports which make sense to developers, TypeScript supports emitting additional files which conform to the JavaScript Source Map standards.</source>
          <target state="translated">개발자가 이해할 수있는 풍부한 디버깅 도구와 충돌 보고서를 제공하기 위해 TypeScript는 JavaScript 소스 맵 표준을 준수하는 추가 파일 생성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">JSX로 유형 검사를 이해하려면 먼저 고유 요소와 값 기반 요소의 차이점을 이해해야합니다. JSX 표현을 감안할 때 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; , &lt;code&gt;expr&lt;/code&gt; 중 하나 (환경에 뭔가 고유 참조 할 수 있습니다 예를 들면 &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;span&lt;/code&gt; 는 DOM 환경에서) 또는 사용자가 만든 것으로 사용자 정의 구성 요소. 이것은 두 가지 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">JSX를 사용하려면 두 가지 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">다시 말해 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 와 비교할 때 &lt;code&gt;1&lt;/code&gt; 이어야합니다. 위의 검사가 유효하지 않은 비교를하고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">즉, TypeScript는 이제 위의 버그를 발견하여 일부 사용자에게는 큰 변화가 될 수 있지만 크게 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">즉, 타격 이동 - 투 - 정의 a에서 선언에 &lt;code&gt;.d.ts&lt;/code&gt; 의 과 생성 된 파일 &lt;code&gt;--declarationMap&lt;/code&gt; 는 소스 파일 (당신을 데려 갈 것이다 &lt;code&gt;.ts&lt;/code&gt; 그 선언이 정의 된) 위치 및하지로 &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">즉, 유형을 생성하는 대신</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">이 예에서는 &lt;code&gt;x&lt;/code&gt; 의 모든 사용 이 초기화되므로 null이 아닌 어설 션보다 명확한 대입 어설 션을 사용하는 것이 더 합리적이라는 것을 알고있었습니다 .</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">우리의 예에서, 우리는 프로그램 전체에서 선언 한 멤버들에게 자유롭게 접근 할 수있었습니다. 다른 언어의 수업에 익숙하다면 위의 예에서 이것을 달성하기 위해 &lt;code&gt;public&lt;/code&gt; 이라는 단어를 사용할 필요가 없었 음을 알 수 있습니다 . 예를 들어 C #에서는 각 멤버를 명시 적으로 &lt;code&gt;public&lt;/code&gt; 으로 표시 해야합니다. TypeScript에서 각 멤버는 &lt;code&gt;public&lt;/code&gt; 기본적으로 입니다.</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">인터페이스를 사용하는 첫 번째 예에서 TypeScript를 사용하면 &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 만 예상 뭔가 &lt;code&gt;{ label: string; }&lt;/code&gt; . 우리는 또한 선택적 속성과 이른바&amp;ldquo;옵션 백&amp;rdquo;을 설명 할 때 유용한 속성에 대해 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">마지막 예제에서는 &lt;code&gt;Octopus&lt;/code&gt; 클래스 에서 읽기 전용 멤버 &lt;code&gt;name&lt;/code&gt; 과 생성자 매개 변수 &lt;code&gt;theName&lt;/code&gt; 을 선언해야했습니다 . 이는 &lt;code&gt;Octopus&lt;/code&gt; 생성자가 실행 된 후 &lt;code&gt;theName&lt;/code&gt; 의 값에 액세스 할 수 있도록 하기 위해 필요합니다 . &lt;em&gt;매개 변수 속성&lt;/em&gt; 을 사용하면 한 곳에서 멤버를 만들고 초기화 할 수 있습니다. 다음 은 매개 변수 속성을 사용하는 이전 &lt;code&gt;Octopus&lt;/code&gt; 클래스 의 추가 개정판입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">예제를 사용하면 방정식의 한쪽에만 유형이 있더라도 TypeScript 컴파일러가 유형을 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">실질적으로 엄격한 null 확인 모드를 사용하려면 컴파일의 모든 파일이 null 및 undefined를 인식해야합니다.</target>
        </trans-unit>
        <trans-unit id="948caf57846c2d397905854f03d5c34bfc0a420b" translate="yes" xml:space="preserve">
          <source>In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">실제로 문자열 리터럴 유형은 공용체 유형, 유형 가드 및 유형 별칭과 잘 결합됩니다. 이러한 기능을 함께 사용하여 문자열에 대한 열거 형 동작을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">ES2015 이전의 목표에서 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; 루프 및 배열 확산과 같은 구성에 대해 가장 충실한 방출 은 약간 무거울 수 있습니다. 이러한 이유로 TypeScript는 기본적으로 배열 유형 만 지원하고 &lt;code&gt;--downlevelIteration&lt;/code&gt; 플래그를 사용하여 다른 유형에 대한 반복을 지원하는 더 간단한 이미 터를 사용합니다 . &lt;code&gt;--downlevelIteration&lt;/code&gt; 이 없는 느슨한 기본값 은 상당히 잘 작동합니다. 그러나 배열 스프레드의 변환에 상당한 차이가있는 몇 가지 일반적인 경우가있었습니다. 예를 들어 스프레드가 포함 된 다음 배열</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">이전 섹션에서는 다양한 유형에서 작동하는 일반 ID 함수를 작성했습니다. 이 섹션에서는 함수 자체의 유형과 일반 인터페이스를 만드는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">이전 버전의 TypeScript에서는 모든 상황에서 클래스와 함수를 병합하는 것이 오류였습니다. 이제 앰비언트 클래스 및 함수 ( &lt;code&gt;declare&lt;/code&gt; &lt;code&gt;.d.ts&lt;/code&gt; 사용하는 클래스 / 함수 또는 .d.ts 파일)가 병합 될 수 있습니다. 이것은 이제 다음을 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">이전 버전의 TypeScript에서 언어는 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; -d 클래스 또는 일반적으로 &lt;code&gt;.d.ts&lt;/code&gt; 파일) 에서 접근자를 &lt;code&gt;get&lt;/code&gt; 오고 &lt;code&gt;set&lt;/code&gt; 수 없었습니다 . 이론적 근거는 접근 자들이 이러한 속성에 대해 읽고 쓰는 한 속성과 구별되지 않았다는 것입니다. 그러나 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;ECMAScript의 클래스 필드 제안은 기존 버전의 TypeScript&lt;/a&gt; 와 동작이 다를 수 있으므로 서브 클래스에 적절한 오류를 제공하기 위해이 다른 동작을 전달하는 방법이 필요하다는 것을 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="d06dc1f53a697259b064554b5aae5fbdd8fa0f1e" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.</source>
          <target state="translated">이전 버전의 TypeScript에서는 디스크에서 텍스트 파일을 읽을 때 사용 된 인코딩을 제어했습니다. 오늘날 TypeScript는 UTF-8 인코딩을 가정하지만 UTF-16 (BE 및 LE) 또는 UTF-8 BOM을 올바르게 감지합니다.</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">이전 버전의 TypeScript에서는 호출 가능한 형식의 공용체 가 동일한 매개 변수 목록이있는 경우 &lt;em&gt;에만&lt;/em&gt; 호출 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">일정한 유형 검사 모드에서의 유추 형 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;any&lt;/code&gt; 때문에 넓히는하지만의 유추 형 모드에서 검사 엄격한 널 &lt;code&gt;z&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; (따라서, 타입 주석 결석 &lt;code&gt;null&lt;/code&gt; 유일한 가능한 값 &lt;code&gt;z&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">간단히 말해서이 일반 유형을 사용하면 &lt;code&gt;defaultProps&lt;/code&gt; 와 같은 것들에 대한 React의 특정 행동을 모델링 할 수 있습니다 및 &lt;code&gt;propTypes&lt;/code&gt; 와 .</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">즉, 이것이 의미하는 바는 반복자를 직접 처리 할 때 반복기의 값을 적절하게 좁힐 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24b474a2b5b3fe83952a8beed2dac6888a114bac" translate="yes" xml:space="preserve">
          <source>In some cases where no type annotations are present, TypeScript will fall back to a type of &lt;code&gt;any&lt;/code&gt; for a variable when it cannot infer the type.</source>
          <target state="translated">유형 어노테이션이없는 경우에 TypeScript는 유형을 추론 할 수 없을 때 변수 에 &lt;code&gt;any&lt;/code&gt; 유형으로 폴백 합니다.</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">경우에 따라 특정 조건에서만 모듈을로드 할 수 있습니다. TypeScript에서는 아래에 표시된 패턴을 사용하여 유형 및 기타 고급 로딩 시나리오를 구현하여 유형 안전성을 잃지 않고 모듈 로더를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8107f519ee938815a808bcba6bd65a28adcacb9" translate="yes" xml:space="preserve">
          <source>In some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">일부 상황에서는 모든 유형 정보를 사용할 수 없거나 해당 선언에 부적절한 노력이 필요합니다. TypeScript 또는 타사 라이브러리없이 작성된 코드의 값에 대해 이러한 문제가 발생할 수 있습니다. 이 경우 유형 검사를 거부 할 수 있습니다. 이를 위해 이러한 값에 &lt;code&gt;any&lt;/code&gt; 유형으로 레이블을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">엄격한 null 확인 모드에서 컴파일러는 가능한 모든 선행 코드 경로에서 해당 변수에 대한 할당이 앞에 &lt;code&gt;undefined&lt;/code&gt; 되지 않은 포함 되지 않은 유형의 로컬 변수에 대한 모든 참조가 필요 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
