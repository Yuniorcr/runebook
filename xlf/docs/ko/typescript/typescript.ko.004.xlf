<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="7ac670e2b8d400f3afe02add218c2edb8400544b" translate="yes" xml:space="preserve">
          <source>Run the compiler</source>
          <target state="translated">컴파일러 실행</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">감시 모드에서 컴파일러를 실행하십시오. 입력 파일을보고 변경시 재 컴파일을 트리거하십시오. 감시 파일 및 디렉토리의 구현은 환경 변수를 사용하여 구성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;configuring-watch&quot;&gt;시계 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">프로젝트를 실행</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">&lt;code&gt;tsc --build&lt;/code&gt; ( 짧게는 &lt;code&gt;tsc -b&lt;/code&gt; ) 를 실행 하면 다음이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c0aa1e021efe3fc4486d609d25246d6751785f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; locally will compile the closest project defined by a &lt;code&gt;tsconfig.json&lt;/code&gt;, you can compile a set of TypeScript files by passing in a glob of files you want.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 를 로컬로 실행 하면 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 정의 된 가장 가까운 프로젝트가 컴파일되며 원하는 파일의 glob을 전달하여 TypeScript 파일 집합을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a53f5887ae342b4a1cd086cadce904823bf70ae" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc&lt;/code&gt; with these settings moves the files into the specified &lt;code&gt;dist&lt;/code&gt; folder:</source>
          <target state="translated">이러한 설정으로 &lt;code&gt;tsc&lt;/code&gt; 를 실행 하면 파일이 지정된 &lt;code&gt;dist&lt;/code&gt; 폴더 로 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">TypeScript 웹앱 실행</target>
        </trans-unit>
        <trans-unit id="2ccf2f0429535a5298f720be36cb9ea9f08e1bc4" translate="yes" xml:space="preserve">
          <source>Runtime Behavior</source>
          <target state="translated">런타임 동작</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">샘플 : System.js의 동적 모듈로드</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">샘플 : require.js의 동적 모듈로드</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">스키마는 &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">범위 지정 규칙</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; 를 검색 하십시오.</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">검색 &lt;strong&gt;.NET 핵심&lt;/strong&gt; 프로젝트 검색 창에</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">둘째, &lt;code&gt;--importHelpers&lt;/code&gt; 를 사용하여 파일을 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcf02982afce00389878abc0de341f295e01470c" translate="yes" xml:space="preserve">
          <source>Second, the TypeScript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">둘째, TypeScript 컴파일러는 제네릭 함수에서 유형 매개 변수의 확산을 허용하지 않습니다. 이 기능은 향후 버전의 언어에서 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">둘째, Typescript 컴파일러는 일반 함수에서 형식 매개 변수의 확산을 허용하지 않습니다. 이 기능은 향후 버전의 언어에서 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">둘째, 클래스 필드를 사용하여 기본 클래스의 속성을 특수화하는 것도 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../project-references&quot;&gt;프로젝트 참조 핸드북 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;모듈 확인&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;문제 # 1256&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;JavaScript 파일 형식 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader에 대한 자세한 내용은 여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aaee337bc1d3ed089284b88a7fb251a773a6ed9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.typescriptlang.org/5bc00d38ab2cd134cf9690e7a4343bf5/module-function.d.ts.md&quot;&gt;Module: Functions&lt;/a&gt; for details of how that works, and the &lt;a href=&quot;../../modules&quot;&gt;Modules reference&lt;/a&gt; page.</source>
          <target state="translated">참조 &lt;a href=&quot;https://www.typescriptlang.org/5bc00d38ab2cd134cf9690e7a4343bf5/module-function.d.ts.md&quot;&gt;모듈 : 함수&lt;/a&gt; 어떻게 작품의 자세한 내용 및 &lt;a href=&quot;../../modules&quot;&gt;모듈 참조&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d47a58ff1cef92314017a04dfa6b2492cbc2ccce" translate="yes" xml:space="preserve">
          <source>See how both lists change. &lt;code&gt;children&lt;/code&gt; now only contains the &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element, and the &lt;code&gt;childNodes&lt;/code&gt; contains a &lt;code&gt;text&lt;/code&gt; node rather than two &lt;code&gt;p&lt;/code&gt; nodes. The &lt;code&gt;text&lt;/code&gt; part of the &lt;code&gt;NodeList&lt;/code&gt; is the literal &lt;code&gt;Node&lt;/code&gt; containing the text &lt;code&gt;TypeScript!&lt;/code&gt;. The &lt;code&gt;children&lt;/code&gt; list does not contain this &lt;code&gt;Node&lt;/code&gt; because it is not considered an &lt;code&gt;HTMLElement&lt;/code&gt;.</source>
          <target state="translated">두 목록이 어떻게 변경되는지 확인하세요. 이제 &lt;code&gt;children&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; 요소 만 포함되고 &lt;code&gt;childNodes&lt;/code&gt; 에는 두 개의 &lt;code&gt;p&lt;/code&gt; 노드가 아닌 &lt;code&gt;text&lt;/code&gt; 노드가 포함 됩니다. &lt;code&gt;NodeList&lt;/code&gt; 의 &lt;code&gt;text&lt;/code&gt; 부분은 &lt;code&gt;TypeScript!&lt;/code&gt; 텍스트를 포함하는 리터럴 &lt;code&gt;Node&lt;/code&gt; 입니다 ! . &lt;code&gt;children&lt;/code&gt; 목록이 포함되지 않은 &lt;code&gt;Node&lt;/code&gt; 그가 고려되지 않기 때문에 &lt;code&gt;HTMLElement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd93541328dd959138d1a2b853dfd1eceeacb71d" translate="yes" xml:space="preserve">
          <source>See main content</source>
          <target state="translated">주요 내용보기</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json 위키 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b065cbab34dec1a1806260f05403e1952398509" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about ES Modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about TypeScript namespaces.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; ES 모듈에 대한 자세한 내용은 문서를. 참고 항목 &lt;a href=&quot;namespaces&quot;&gt;네임 스페이스&lt;/a&gt; 타이프 라이터 네임 스페이스에 대한 자세한 내용은 문서를.</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 모듈에 대한 자세한 내용은 문서를. 참고 항목 &lt;a href=&quot;namespaces&quot;&gt;네임 스페이스&lt;/a&gt; 네임 스페이스에 대한 자세한 내용은 문서를.</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">TypeScript에서 JSX를 사용하는 방법에 대한 자세한 내용은 [[JSX]] 위키 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2260a25895164f2770eb15c55e0e16389d6b104b" translate="yes" xml:space="preserve">
          <source>See where your usage of the module breaks, and start to fill out the index.d.ts</source>
          <target state="translated">모듈 사용이 중단되는 부분을 확인하고 색인 작성을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">&lt;strong&gt;ASP.NET Core Web Application을&lt;/strong&gt; 선택 하고 &lt;em&gt;다음&lt;/em&gt; 버튼을 누릅니다</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">세미콜론 포맷터 옵션</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">세미콜론 인식 코드 편집</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">순차적으로 추가 된 속성</target>
        </trans-unit>
        <trans-unit id="1676c891c1accface87dfecc3ee263cbd0629e6e" translate="yes" xml:space="preserve">
          <source>Set to false to disable warnings about unused labels.</source>
          <target state="translated">사용하지 않는 레이블에 대한 경고를 비활성화하려면 false로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">빌드 설정</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">서버 설정</target>
        </trans-unit>
        <trans-unit id="c027e79283f2d26edaa3eee382f8854c8daded5d" translate="yes" xml:space="preserve">
          <source>Sets the module system for the program. See the &lt;a href=&quot;docs/handbook/modules&quot;&gt;Modules&lt;/a&gt; reference page for more information. You very likely want &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; for node projects.</source>
          <target state="translated">프로그램의 모듈 시스템을 설정합니다. 자세한 내용은 &lt;a href=&quot;docs/handbook/modules&quot;&gt;모듈&lt;/a&gt; 참조 페이지를 참조하십시오. 노드 프로젝트에 &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; 를 원할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; 을 설정 하면 컴파일러에게 모듈을 찾을 위치를 알려줍니다. 상대 이름이 아닌 모든 모듈 가져 오기는 &lt;code&gt;baseUrl&lt;/code&gt; 과 관련이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f2b91c337f2f0946708a5154da2e0832a39c7b5b" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;strictNullChecks&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; will raise an error that you have not made a guarantee that the &lt;code&gt;loggedInUser&lt;/code&gt; exists before trying to use it.</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 &lt;code&gt;loggedInUser&lt;/code&gt; 가 사용을 시도하기 전에 존재 한다는 보장을하지 않았다는 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">최상위 속성 &lt;code&gt;compileOnSave&lt;/code&gt; 를 설정하면 저장된 tsconfig.json에 대한 모든 파일을 생성하도록 IDE에 신호를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild 프로젝트&lt;/a&gt; 에서 컴파일러 옵션 설정 .</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">&lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt; 파일 에서 컴파일러 옵션 설정</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">새 컴파일러 플래그 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 를 설정하면 모듈 로더가 가져온 .ts 또는 .d.ts에 표시되지 않은 일종의 합성 기본 가져 오기 멤버 작성을 수행함을 나타냅니다. 컴파일러는 전체 모듈 자체의 모양을 가진 &lt;code&gt;default&lt;/code&gt; 내보내기가 있음을 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">디렉토리 설정</target>
        </trans-unit>
        <trans-unit id="62cd1351e8c4eaed3d7e33f00093319c1143b315" translate="yes" xml:space="preserve">
          <source>Setting up your Project to emit .d.ts files</source>
          <target state="translated">.d.ts 파일을 내보내도록 프로젝트 설정</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">더 명확한 코드를 작성하려면 &lt;em&gt;일반적으로&lt;/em&gt; 섀도 잉을 피해야합니다. 이를 활용하기에 적합한 시나리오가 있지만 최선의 판단을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">속기 주변 모듈 선언</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">속기 주변 모듈</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">진단 정보를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">자세한 진단 정보 표시</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문과 유사하게, &lt;em&gt;의존성&lt;/em&gt; 선언으로 사용 되며, &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문은 패키지에 대한 의존성을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">배열 확산과 유사하게 객체를 펼치면 얕은 사본을 얻는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">결합 유형과 교차 유형과 마찬가지로 조건 유형은 재귀 적으로 자신을 참조 할 수 없습니다. 예를 들어 다음은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">마찬가지로 &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; 와 동등한 CommonJS / AMD / UMD 모듈에 대한 기본 가져 오기 (예 : &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ) .default . 오늘날 사용 가능한 대부분의 CommonJS / AMD / UMD 모듈에는 &lt;code&gt;default&lt;/code&gt; 비 ES 모듈을 가져올 실질적으로 사용할 수 없게이 수입 패턴을 만들기 수출 (즉, CommonJS / AMD / UMD). 예를 들어 &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; 또는 &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">인터페이스를 사용하여 함수 유형을 설명하는 방법과 유사하게, &lt;code&gt;a[10]&lt;/code&gt; 또는 &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; 과 같이 &quot;인덱싱&quot;할 수있는 유형도 설명 할 수 있습니다 . 인덱싱 가능한 형식에는 인덱싱 할 때 해당 반환 형식과 함께 개체를 인덱싱하는 데 사용할 수있는 형식을 설명 하는 &lt;em&gt;인덱스 서명&lt;/em&gt; 이 있습니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">인터페이스와 마찬가지로 이름이 같은 네임 스페이스도 멤버를 병합합니다. 네임 스페이스는 네임 스페이스와 값을 모두 생성하므로이 둘이 어떻게 병합되는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--target ES2017&lt;/code&gt; 은 컴파일러에게 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 와 같은 ES2017 관련 기능을 변환하지 않도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">마찬가지로 비 상대 가져 오기는 Node.js 확인 논리를 따라 먼저 파일을 찾은 다음 해당 폴더를 찾습니다. 따라서 소스 파일 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 의 &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; 에서 {b}를 가져 오면 다음과 같은 조회가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">마찬가지로, 함수 매개 변수 선언에서 구조 해제를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">마찬가지로 네임 스페이스를 사용하여 정적 멤버로 열거를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">마찬가지로 &lt;code&gt;declare global&lt;/code&gt; 선언을 사용하여 모듈에서 전역 범위를 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">마찬가지로, greeter 호출에 대한 모든 인수를 제거하십시오. TypeScript는 예기치 않은 수의 매개 변수를 사용하여이 함수를 호출했음을 알려줍니다. 두 경우 모두 TypeScript는 코드 구조와 제공하는 형식 주석을 기반으로 정적 분석을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 여러 다른 개체를 병합 할 수 있습니다. 다음 예제에서 &lt;code&gt;merged&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 의 속성을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">마찬가지로 &lt;code&gt;readonly&lt;/code&gt; -ness 를 제거하고 읽기 &lt;code&gt;readonly&lt;/code&gt; 배열 컨테이너를 변경 가능한 등가 로 변환 하는 &lt;code&gt;Writable&lt;/code&gt; 매핑 된 유형과 같은 유틸리티 유형을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">간단한 조합 : 하나의 이름, 여러 의미</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">React의 간단한 &lt;code&gt;props&lt;/code&gt; 유형 관리</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">이후 &lt;code&gt;keyof&lt;/code&gt; 가 지금 형을 포함하여 숫자 인덱스 서명의 존재 반영 &lt;code&gt;number&lt;/code&gt; 키 유형을, 같은 종류의 매핑 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 숫자 인덱스 서명 개체 유형에 적용 할 때 제대로 일을 :</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">JavaScript 는 줄 끝에서 &lt;code&gt;return&lt;/code&gt; 문을 자동으로 종료하므로 객체 리터럴이 블록이됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f102f64416cbc39d1e3262772e0a216eb7ce37" translate="yes" xml:space="preserve">
          <source>Since JavaScript supports classes and object-oriented programming, so does TypeScript. You can use an interface declaration with classes:</source>
          <target state="translated">JavaScript는 클래스와 객체 지향 프로그래밍을 지원하므로 TypeScript도 지원합니다. 클래스와 함께 인터페이스 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">한 파일의 선언은 다른 파일의 유형 검사에 영향을 줄 수 있으므로 &lt;code&gt;--skipLibCheck&lt;/code&gt; 를 지정 하면 일부 오류가 감지되지 않을 수 있습니다 . 예를 들어 선언 파일이 아닌 파일이 선언 파일에 선언 된 형식을 보강하면 선언 파일을 확인할 때만 오류가보고 될 수 있습니다. 그러나 실제로 그러한 상황은 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">nullable 형식은 노동 조합으로 구현되기 때문에, 당신은 없애 유형 가드를 사용할 필요가 &lt;code&gt;null&lt;/code&gt; . 다행히도 이것은 JavaScript로 작성할 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">범위가 겹칠 가능성이 있으므로 적용 할 리디렉션을 결정하는 것은 주문마다 다릅니다. 이는 위의 예에서 &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; 매 처가 모두 TypeScript 3.2 이상을 지원하더라도 순서를 반대로하면 동작이 다를 수 있으므로 위의 샘플은 다음과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">위의 구문은 &lt;code&gt;.tsx&lt;/code&gt; 파일 에서 사용할 수 없으므로 대체 형식 어설 션 연산자를 사용해야합니다. &lt;code&gt;as&lt;/code&gt; . &lt;code&gt;as&lt;/code&gt; 연산자를 사용하여 예제를 쉽게 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">클래스는 &lt;code&gt;this&lt;/code&gt; 유형을 사용하므로 이를 확장 할 수 있으며 새 클래스는 기존 메소드를 변경하지 않고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">엄격한 검사는 이전에보고되지 않은 오류를 발견 할 수 있으므로 &lt;code&gt;--strict&lt;/code&gt; 모드 의 주요 변경 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Javascript에서 일반 유형 매개 변수를 지정하기위한 자연적인 구문이 없으므로 지정되지 않은 유형 매개 변수의 기본값은 &lt;code&gt;any&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">ES2015 이전 Javascript에서는 매개 변수에 선택적을 지정할 수있는 방법이 없으므로 &lt;code&gt;.js&lt;/code&gt; 파일의 모든 함수 매개 변수는 선택적으로 간주됩니다. 선언 된 매개 변수 수보다 적은 수의 인수를 가진 호출이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">이는 중대한 변경 사항이므로 엄격한 객체 리터럴 검사와 동일한 해결 방법에 대해 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="29a785f99454f565683fe81e09a33e40c8e76702" translate="yes" xml:space="preserve">
          <source>Single-file transpilers don&amp;rsquo;t know whether &lt;code&gt;someType&lt;/code&gt; produces a value or not, so it&amp;rsquo;s an error to export a name that only refers to a type.</source>
          <target state="translated">여부를 단일 파일 transpilers 몰라 &lt;code&gt;someType&lt;/code&gt; 이 값을 생성 여부에만 타입을 사용하는 이름을 수출하는 오류, 그래서.</target>
        </trans-unit>
        <trans-unit id="3e13335331cc080e9ba88a13ad1230b8a0576896" translate="yes" xml:space="preserve">
          <source>Skip Default Lib Check - &lt;code&gt;skipDefaultLibCheck&lt;/code&gt;</source>
          <target state="translated">기본 Lib 검사 건너 뛰기 &lt;code&gt;skipDefaultLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="234395dee2758492ba2797c4d5cd3f566645aff3" translate="yes" xml:space="preserve">
          <source>Skip Lib Check - &lt;code&gt;skipLibCheck&lt;/code&gt;</source>
          <target state="translated">라이브러리 검사 건너 뛰기 &lt;code&gt;skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;기본 라이브러리 선언 파일&lt;/a&gt; 의 유형 검사를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">모든 선언 파일의 유형 검사를 건너 뜁니다 ( &lt;code&gt;*.d.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d66051d7634cd7ff52bac26aa8397aa830ebea55" translate="yes" xml:space="preserve">
          <source>Skip type checking of declaration files.</source>
          <target state="translated">선언 파일의 유형 검사를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="597c64f117d2aa2c1f26f6d20a44dfe498e5769f" translate="yes" xml:space="preserve">
          <source>Smaller samples for different types of libraries</source>
          <target state="translated">다양한 유형의 라이브러리에 대한 더 작은 샘플</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">똑똑한 자동 가져 오기 구문</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">똑똑한 조합 유형 검사</target>
        </trans-unit>
        <trans-unit id="4597cc07c4a8e366226dba892e751bcdcaed8c3c" translate="yes" xml:space="preserve">
          <source>So far, the handbook has covered types which are atomic objects. However, as you model more types you find yourself looking for tools which let you compose or combine existing types instead of creating them from scratch.</source>
          <target state="translated">지금까지 핸드북은 원자 객체 인 유형을 다루었습니다. 그러나 더 많은 유형을 모델링함에 따라 기존 유형을 처음부터 작성하는 대신 구성하거나 결합 할 수있는 도구를 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">지금까지 언어 사양에 정의 된 용어가 아닌 &quot;호환&quot;을 사용했습니다. TypeScript에는 하위 유형과 할당의 두 가지 호환성이 있습니다. 다음은 해당 과제에 차이가와에서 할당을 허용하는 규칙을 하위 호환성을 확장 &lt;code&gt;any&lt;/code&gt; 하고,과에서 &lt;code&gt;enum&lt;/code&gt; 숫자 값을 대응.</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">따라서 다음 입력이 주어지면 결과 &lt;code&gt;.js&lt;/code&gt; 파일은 &lt;code&gt;tslib&lt;/code&gt; 로 가져 오기를 포함하고 인라인 대신 &lt;code&gt;__assign&lt;/code&gt; 도우미를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; 에서 가져 오는 경우 &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (및 기타 관련 항목) 에서 해결하려고합니다. TypeScript 3.1에서 실행될 때). 우리가 가져올 경우 &lt;code&gt;package-name/foo&lt;/code&gt; , 우리가 찾기 위해 노력할 것이다 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; 및 &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">따라서 컴파일에서 파일을 제외하려면 해당 파일과 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문 이있는 &lt;strong&gt;모든&lt;/strong&gt; 파일 을 제외해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d182650064f5464ef393db53c7c8e6d35c2c988e" translate="yes" xml:space="preserve">
          <source>Some elements do not exhibit unique properties and so they just return &lt;code&gt;HTMLElement&lt;/code&gt;, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement &lt;code&gt;HTMLElement&lt;/code&gt;).</source>
          <target state="translated">일부 요소는 고유 한 속성을 나타내지 않으므로 &lt;code&gt;HTMLElement&lt;/code&gt; 를 반환 하지만 다른 유형에는 고유 한 속성 및 메서드가 있으므로 특정 인터페이스 ( &lt;code&gt;HTMLElement&lt;/code&gt; 에서 확장되거나 구현 됨 ) 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="70e17d206c518dbadda1af7b806ce18ec461ecfb" translate="yes" xml:space="preserve">
          <source>Some examples of code which does not work when &lt;code&gt;isolatedModules&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;isolatedModules&lt;/code&gt; 가 활성화 되었을 때 작동하지 않는 코드의 몇 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 반환 하지 않는 함수의 예 :</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 반환 하지 않는 함수 사용의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">일부 예제 는 &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;실험 메타 데이터 API를&lt;/a&gt; 위한 폴리 필을 추가하는 &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리를 사용합니다 . 이 라이브러리는 아직 ECMAScript (JavaScript) 표준의 일부가 아닙니다. 그러나 일단 데코레이터가 공식적으로 ECMAScript 표준의 일부로 채택되면 이러한 확장을 채택 할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">일부 선언은 여러 선언에 걸쳐 결합 될 수 있습니다. 예를 들어, &lt;code&gt;class C { }&lt;/code&gt; 와 &lt;code&gt;interface C { }&lt;/code&gt; 는 공존 할 수 있으며 둘 다 &lt;code&gt;C&lt;/code&gt; 유형 에 특성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">일부 라이브러리는 많은 모듈 로더에서 사용되거나 모듈로드 (글로벌 변수)없이 사용되도록 설계되었습니다. 이것을 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; 모듈 이라고 합니다. 이 라이브러리는 가져 오기 또는 전역 변수를 통해 액세스 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">일부 라이브러리는 많은 모듈 로더에서 사용되거나 모듈로드 (글로벌 변수)없이 사용되도록 설계되었습니다. 이를 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; 또는 &lt;a href=&quot;http://isomorphic.net&quot;&gt;동형&lt;/a&gt; 모듈이라고합니다. 이 라이브러리는 가져 오기 또는 전역 변수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">일부 라이브러리는 모듈 로더 환경에서만 작동합니다. 예를 들어, &lt;code&gt;express&lt;/code&gt; 는 Node.js에서만 작동하며 CommonJS &lt;code&gt;require&lt;/code&gt; 함수를 사용하여로드 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; 와 같은 일부 모듈 로더는 JavaScript 이외의 컨텐츠를 가져올 수 있습니다. 이들은 일반적으로 접두사 또는 접미사를 사용하여 특수한 로딩 시맨틱을 나타냅니다. 이러한 경우를 처리하기 위해 와일드 카드 모듈 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9daed87f8143d8fb1626c2d066b5622304dcdba" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.md#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/LoaderPlugins.md&quot;&gt;AMD&lt;/a&gt; 와 같은 일부 모듈 로더 에서는 비 JavaScript 콘텐츠를 가져올 수 있습니다. 일반적으로 접두사 또는 접미사를 사용하여 특수 로딩 의미를 나타냅니다. 이러한 경우를 처리하기 위해 와일드 카드 모듈 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">TypeScript의 고유 한 개념 중 일부는 유형 수준에서 JavaScript 객체의 모양을 설명합니다. TypeScript에 고유 한 한 가지 예는 '선언 병합'개념입니다. 이 개념을 이해하면 기존 JavaScript로 작업 할 때 유리합니다. 또한보다 고급화 된 추상화 개념의 문을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">어떤 사람들은 객체를 만들고 다음과 같이 즉시 속성을 추가하는 것이 더 미학적으로 기쁘게 생각합니다.</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">일부 플러그인은 기존 모듈에서 최상위 레벨 내보내기를 추가하거나 수정합니다. CommonJS 및 기타 로더에서는 이것이 합법적이지만 ES6 모듈은 변경 불가능한 것으로 간주되며이 패턴은 불가능합니다. TypeScript는 로더에 구애받지 않기 때문에이 정책은 컴파일 타임에 적용되지 않지만 ES6 모듈 로더로 전환하려는 개발자는이를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">일부 속성은 객체가 처음 생성 될 때만 수정 가능해야합니다. 속성 이름 앞에 &lt;code&gt;readonly&lt;/code&gt; 지정하여이를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">일부 독자는이 예제에서 이중 테이크를 할 수 있습니다. 변수 &lt;code&gt;x&lt;/code&gt; 는 &lt;em&gt; &lt;code&gt;if&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 블록 &lt;/em&gt;&lt;em&gt;내에서&lt;/em&gt; 선언 되었지만 해당 블록 외부에서 액세스 할 수있었습니다. &lt;code&gt;var&lt;/code&gt; 선언은 포함 블록에 관계없이 포함 함수, 모듈, 네임 스페이스 또는 전역 범위 내에서 액세스 할 수 있기 때문 입니다. 어떤 사람들은이 전화 &lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt; 또는 &lt;em&gt;함수 범위 지정을&lt;/em&gt; . 매개 변수도 기능 범위가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">일부 팀은 tsconfig 파일 이 페어링 된 관리 프로젝트 와 동일한 &lt;em&gt;암시 적&lt;/em&gt; 그래프 순서를 갖는 msbuild 기반 워크 플로를 설정했습니다 . 솔루션이 이와 같은 경우 프로젝트 참조와 함께 &lt;code&gt;msbuild&lt;/code&gt; 를 &lt;code&gt;tsc -p&lt;/code&gt; 와 함께 계속 사용할 수 있습니다 . 이들은 완전히 상호 운용이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">참고 로 블록 범위 변수를 선언하기 전에 &lt;em&gt;캡처&lt;/em&gt; 할 수 있습니다 . 유일한 문제는 선언하기 전에 해당 함수를 호출하는 것이 불법이라는 것입니다. ES2015를 대상으로하는 경우 최신 런타임은 오류를 발생시킵니다. 그러나 현재 TypeScript는 허용되며이를 오류로보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">때때로 모듈은 &lt;em&gt;baseUrl&lt;/em&gt; 바로 아래에 위치하지 않습니다 . 예를 들어, 모듈 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 로 가져 오기 는 런타임시 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 로 변환 됩니다. 로더는 맵핑 구성을 사용하여 런타임시 모듈 이름을 파일에 맵핑합니다 ( &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs 문서&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS 문서 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37b66ff014eda83e2b1e8f0a114fdd628d5f0100" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">때로는 모듈이 &lt;em&gt;baseUrl&lt;/em&gt; 아래에 직접 위치하지 않습니다 . 예를 들어, 모듈 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 에 대한 가져 오기 는 런타임에 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 로 변환 됩니다. 로더는 매핑 구성을 사용하여 런타임에 모듈 이름을 파일에 매핑합니다 . &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs 문서&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths&quot;&gt;SystemJS 문서를&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">때때로 모듈은 &lt;em&gt;baseUrl&lt;/em&gt; 바로 아래에 위치하지 않습니다 . 로더는 맵핑 구성을 사용하여 런타임시 모듈 이름을 파일에 맵핑합니다 ( &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs 문서&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS 문서 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">때로는 컴파일 타임에 여러 디렉토리의 프로젝트 소스가 모두 결합되어 단일 출력 디렉토리를 생성합니다. 소스 디렉토리 세트가 &quot;가상&quot;디렉토리를 작성하는 것으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; 및 &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; &lt;code&gt;FolderA\FolderB\&lt;/code&gt; 은 출력 구조 미러링 FolderA \ FolderB \를 생성하는 것과 같이 바람직하지 않습니다 . 이제 새 파일 &lt;code&gt;FolderA\3.ts&lt;/code&gt; 가 입력에 추가되면 출력 구조가 &lt;code&gt;FolderA\&lt;/code&gt; 를 미러링하도록 튀어 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">때로는 TypeScript보다 값에 대해 더 많이 알고있는 상황에 처할 수 있습니다. 일반적으로 일부 엔티티 유형이 현재 유형보다 더 구체적 일 수 있음을 알고있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db9ad13d4e098d7519b16265367b7512e89b4d5d" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually, this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">때로는 TypeScript보다 값에 대해 더 많이 알게되는 상황에 처하게 될 것입니다. 일반적으로 이것은 어떤 엔티티의 유형이 현재 유형보다 더 구체적 일 수 있다는 것을 알고있을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">때로는 내보내기 개체를 완전히 덮어 씁니다. 이것은 사람들이이 스 니펫 에서처럼 모듈을 즉시 호출 할 수있게하는데 사용하는 일반적인 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d728f725e5c3a9034a8a3fe4df81013d14f602c4" translate="yes" xml:space="preserve">
          <source>Source Map - &lt;code&gt;sourceMap&lt;/code&gt;</source>
          <target state="translated">소스 맵 &lt;code&gt;sourceMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">소스 맵</target>
        </trans-unit>
        <trans-unit id="cfa38cdf5131675218c181d7b11184e4109a5125" translate="yes" xml:space="preserve">
          <source>Source Root - &lt;code&gt;sourceRoot&lt;/code&gt;</source>
          <target state="translated">소스 루트 &lt;code&gt;sourceRoot&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ada52d888ccf16d2711b8a6377768a782af5c30e" translate="yes" xml:space="preserve">
          <source>Sources:</source>
          <target state="translated">Sources:</target>
        </trans-unit>
        <trans-unit id="48eef677f8e006bcedd3e0792da013d963078bac" translate="yes" xml:space="preserve">
          <source>Specifically, the Handbook does not fully introduce core JavaScript basics like functions, classes, and closures. Where appropriate, we&amp;rsquo;ll include links to background reading that you can use to read up on those concepts.</source>
          <target state="translated">특히이 핸드북은 함수, 클래스 및 클로저와 같은 핵심 JavaScript 기본 사항을 완전히 소개하지 않습니다. 해당되는 경우 해당 개념을 읽는 데 사용할 수있는 배경 자료에 대한 링크를 포함 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="efbbb58a99e1f76d9d3034bd2b5e0e968683bf5a" translate="yes" xml:space="preserve">
          <source>Specifies an allowlist of files to include in the program. An error occurs if any of the files can&amp;rsquo;t be found.</source>
          <target state="translated">프로그램에 포함 할 파일 허용 목록을 지정합니다. 파일을 찾을 수 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c74f7553e5ec8cdb8bab2e09b9d4de6b751389a2" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns that should be skipped when resolving &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 를 확인할 때 건너 뛸 파일 이름 또는 패턴의 배열을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a89dfbe46f3600605d13d83998972af673fa40e0" translate="yes" xml:space="preserve">
          <source>Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">프로그램에 포함 할 파일 이름 또는 패턴의 배열을 지정합니다. 이러한 파일 이름은 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 포함 된 디렉토리를 기준으로 확인 됩니다.</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">디버거가 소스 위치 대신 TypeScript 파일을 찾을 위치를 지정합니다. 소스가 디자인 타임과 다른 위치에 런타임에 위치 할 경우이 플래그를 사용하십시오. 지정된 위치는 sourceMap에 임베드되어 소스 파일이있는 디버거를 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">디버거가 생성 된 위치 대신 맵 파일을 찾아야하는 위치를 지정합니다. .map 파일이 런타임에 .js 파일과 다른 위치에있는 경우이 플래그를 사용하십시오. 지정된 위치는 sourceMap에 임베드되어 맵 파일이 위치 할 디버거를 지시합니다. 이 플래그는 지정된 경로를 작성하지 않고 해당 위치에 맵 파일을 생성합니다. 대신 파일을 지정된 경로로 이동하는 빌드 후 단계를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">&lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX 방출을 대상으로 할 때 &lt;code&gt;createElement&lt;/code&gt; 및 &lt;code&gt;__spread&lt;/code&gt; 에 대해 호출 된 객체를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">입력 파일의 루트 디렉토리를 지정합니다. &lt;code&gt;--outDir&lt;/code&gt; 을 사용하여 출력 디렉토리 구조를 제어하는 데만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt; 패키지의 자동 포함을 비활성화하려면 &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; 를 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">ECMAScript 대상 버전을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">모듈 코드 생성을 &lt;code&gt;&quot;None&quot;&lt;/code&gt; , &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; , &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">반응 JSX 방출을 타겟팅 할 때 사용할 JSX 팩토리 함수를 지정하십시오 (예 : &lt;code&gt;React.createElement&lt;/code&gt; 또는 &lt;code&gt;h&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="94543a650f9ea4384e3c9b4aac1aeb2ec999debb" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit with &lt;code&gt;jsxFactory&lt;/code&gt; compiler option is specified, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsxFactory&lt;/code&gt; 컴파일러 옵션이 지정된 반응 JSX 방출을 대상으로 할 때 사용할 JSX 단편 팩토리 함수를 지정하십시오 (예 : &lt;code&gt;Fragment&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="78e9087ffaa1788a738669c2468f437d80a3e672" translate="yes" xml:space="preserve">
          <source>Specify the JSX fragment factory function to use when targeting react JSX emit, e.g. &lt;code&gt;Fragment&lt;/code&gt;.</source>
          <target state="translated">반응 JSX 방출을 대상으로 할 때 사용할 JSX 조각 팩토리 함수를 지정합니다 (예 : &lt;code&gt;Fragment&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="006fc315897b9c6dedc4127db9dec8f57c88bcec" translate="yes" xml:space="preserve">
          <source>Specify the end of line sequence to be used when emitting files: &amp;lsquo;CRLF&amp;rsquo; (dos) or &amp;lsquo;LF&amp;rsquo; (unix).</source>
          <target state="translated">파일을 내보낼 때 사용할 행의 끝 순서를 지정하십시오 : 'CRLF'(dos) 또는 'LF'(unix).</target>
        </trans-unit>
        <trans-unit id="2563c439e791b9170655cc14e7d00ffe51b0db65" translate="yes" xml:space="preserve">
          <source>Specify the location where a debugger should locate TypeScript files instead of relative source locations. This string is treated verbatim inside the source-map where you can use a path or a URL:</source>
          <target state="translated">디버거가 상대 소스 위치 대신 TypeScript 파일을 찾아야하는 위치를 지정합니다. 이 문자열은 경로 또는 URL을 사용할 수있는 소스 맵 내에서 그대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e93da90b91643eb92c65e310443608e67c5f5f30" translate="yes" xml:space="preserve">
          <source>Specify the location where debugger should locate map files instead of generated locations. This string is treated verbatim inside the source-map, for example:</source>
          <target state="translated">디버거가 생성 된 위치 대신 맵 파일을 찾아야하는 위치를 지정하십시오. 이 문자열은 소스 맵 내에서 그대로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33c04e27a5ae61b1904c200b896f04e66fb3130e" translate="yes" xml:space="preserve">
          <source>Specify the module resolution strategy: &lt;code&gt;'node'&lt;/code&gt; (Node.js) or &lt;code&gt;'classic'&lt;/code&gt; (used in TypeScript before the release of 1.6). You probably won&amp;rsquo;t need to use &lt;code&gt;classic&lt;/code&gt; in modern code.</source>
          <target state="translated">모듈 확인 전략을 지정합니다 : &lt;code&gt;'node'&lt;/code&gt; (Node.js) 또는 &lt;code&gt;'classic'&lt;/code&gt; (1.6 릴리스 이전에 TypeScript에서 사용됨). 현대 코드 에서는 &lt;code&gt;classic&lt;/code&gt; 을 사용할 필요가 없을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">증분 빌드 정보를 저장할 파일을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">&lt;code&gt;--module amd&lt;/code&gt; 또는 &lt;code&gt;--module system&lt;/code&gt; 과 함께 &lt;code&gt;--outFile&lt;/code&gt; 을 지정 하면 컴파일의 모든 모듈이 여러 모듈 클로저를 포함하는 단일 출력 파일로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">유형 지정 &lt;code&gt;this&lt;/code&gt; 기능을</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">속도 개선</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">파일 간 분할</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">튜플 형식의 스프레드 식</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">안정적인 패키지는 여기에서 구할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">출력 장치가 화려한 텍스트에 적용 가능한 경우 TypeScript 2.9 시작 오류가 기본적으로 &lt;code&gt;--pretty&lt;/code&gt; 아래에 표시됩니다 . TypeScript는 출력 스팀에 &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">릴리스 1.6부터 TypeScript 컴파일러는 'commonjs'를 대상으로 할 때 다른 규칙 세트를 사용하여 모듈 이름을 분석합니다. 이 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;규칙&lt;/a&gt; 은 노드에서 사용하는 모듈 조회 절차를 모델링하려고 시도했습니다. 이는 노드 모듈이 타이핑에 대한 정보를 포함 할 수 있고 TypeScript 컴파일러가이를 찾을 수 있음을 의미합니다. 그러나 사용자는 &lt;code&gt;--moduleResolution&lt;/code&gt; 명령 줄 옵션 을 사용하여 컴파일러가 선택한 모듈 확인 규칙을 무시할 수 있습니다 . 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">시작</target>
        </trans-unit>
        <trans-unit id="b8e934aecb8f4ca462a04840430ac40704a0da90" translate="yes" xml:space="preserve">
          <source>Starting up are the root options in the TSConfig - these options relate to how your TypeScript or JavaScript project is set up.</source>
          <target state="translated">시작은 TSConfig의 루트 옵션입니다.이 옵션은 TypeScript 또는 JavaScript 프로젝트 설정 방법과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">ECMAScript 2015부터 &lt;code&gt;symbol&lt;/code&gt; 은 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 과 같은 기본 데이터 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">ECMAScript 2015부터 JavaScript에는 모듈 개념이 있습니다. TypeScript는이 개념을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">ECMAScript 2015부터 모듈은 언어의 기본 요소이며 모든 호환 엔진 구현에서 지원되어야합니다. 따라서 새 프로젝트의 경우 모듈이 권장되는 코드 구성 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">TypeScript 1.8부터는 공식 NuGet 패키지를 Typescript 컴파일러 ( &lt;code&gt;tsc.exe&lt;/code&gt; )와 MSBuild 통합 ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; 및 &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; )에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">TypeScript 1.8로 시작 :</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">TypeScript 2.3부터 &lt;code&gt;tsc --init&lt;/code&gt; 에 의해 생성 된 기본 &lt;code&gt;tsconfig.json&lt;/code&gt; 은 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 섹션 의 &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; 설정을 포함합니다 . 따라서 &lt;code&gt;tsc --init&lt;/code&gt; 로 시작한 새 프로젝트는 기본적으로 가장 높은 수준의 유형 안전을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">런타임시 실행되지 않는 명령문은 이제 도달 할 수없는 코드 오류로 올바르게 플래그 지정됩니다. 예를 들어 무조건 &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;continue&lt;/code&gt; 문 뒤에 나오는 명령문은 도달 할 수없는 것으로 간주됩니다. 연결할 수없는 코드 감지 및보고를 비활성화 하려면 &lt;code&gt;--allowUnreachableCode&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4834b04199e24094cfa37dc3df47bc9740ccc20d" translate="yes" xml:space="preserve">
          <source>Static Classes</source>
          <target state="translated">정적 클래스</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">정적 속성</target>
        </trans-unit>
        <trans-unit id="1e94b9fe73132ea714175037fe0cd997356ca7ce" translate="yes" xml:space="preserve">
          <source>Static Property Mixins &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/17829&quot;&gt;&lt;code&gt;#17829&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">정적 속성 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/17829&quot;&gt; &lt;code&gt;#17829&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">내 보낸 클래스의 정적 메서드에는 비슷한 문제가 있습니다. 클래스 자체에 중첩 레이어가 추가됩니다. 명확하게 유용한 방식으로 표현력이나 의도를 높이 지 않는 한 단순히 도우미 함수를 내보내는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="11dc9e1952928d4ca947651277656b4d8b55fffc" translate="yes" xml:space="preserve">
          <source>Status:</source>
          <target state="translated">Status:</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="c5a651c6a5ca45d3200e3822a71c808cfc9ddee0" translate="yes" xml:space="preserve">
          <source>Strict - &lt;code&gt;strict&lt;/code&gt;</source>
          <target state="translated">엄격한 - &lt;code&gt;strict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">엄격한 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 검사</target>
        </trans-unit>
        <trans-unit id="7db7be7d078caf461b753e0214a03c98e722bffe" translate="yes" xml:space="preserve">
          <source>Strict Bind Call Apply - &lt;code&gt;strictBindCallApply&lt;/code&gt;</source>
          <target state="translated">엄격한 바인딩 호출 적용 &lt;code&gt;strictBindCallApply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d933d28761202efe8959a2abfc0ee0653e25ea29" translate="yes" xml:space="preserve">
          <source>Strict Checks</source>
          <target state="translated">엄격한 검사</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">엄격한 클래스 초기화</target>
        </trans-unit>
        <trans-unit id="117936c45339446360a285051720e74fb1e1a712" translate="yes" xml:space="preserve">
          <source>Strict Function Types - &lt;code&gt;strictFunctionTypes&lt;/code&gt;</source>
          <target state="translated">엄격한 함수 유형 &lt;code&gt;strictFunctionTypes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="138584497ea8db53d6fe3a0d2d6a889f35fd24b1" translate="yes" xml:space="preserve">
          <source>Strict Null Checks - &lt;code&gt;strictNullChecks&lt;/code&gt;</source>
          <target state="translated">엄격한 Null 검사 &lt;code&gt;strictNullChecks&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73209b516ae52a149a4f72b4ba6803dd3a89c92b" translate="yes" xml:space="preserve">
          <source>Strict Property Initialization - &lt;code&gt;strictPropertyInitialization&lt;/code&gt;</source>
          <target state="translated">엄격한 속성 초기화 &lt;code&gt;strictPropertyInitialization&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">콜백 매개 변수에 대한 엄격한 모순</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">엄격한 기능 유형</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">더 엄격한 발전기</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">엄격한 제네릭</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">일반 기능에 대한 엄격한 검사</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">더 엄격한 객체 리터럴 할당 검사</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">문자열 열거 형</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">문자열 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">문자열 열거 형</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">문자열 열거 형은 비슷한 개념이지만 아래에 설명 된대로 약간의 &lt;a href=&quot;#enums-at-runtime&quot;&gt;런타임 차이&lt;/a&gt; 가 있습니다. 문자열 열거 형에서 각 멤버는 문자열 리터럴 또는 다른 문자열 열거 형 멤버를 사용하여 상수 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">문자열 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">문자열 리터럴 유형을 사용하면 문자열에 필요한 정확한 값을 지정할 수 있습니다. 실제로 문자열 리터럴 유형은 공용체 유형, 유형 가드 및 유형 별명과 잘 결합됩니다. 이러한 기능을 함께 사용하여 문자열과 열거 형과 유사한 동작을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">오버로드를 구별하기 위해 문자열 리터럴 유형을 동일한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">문자열, 숫자 및 부울 리터럴 유형 (예 : &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; )은 이전에 명시 적 유형 주석이있는 경우에만 추론되었습니다. TypeScript 2.1부터는 리터럴 유형이 &lt;code&gt;const&lt;/code&gt; 변수 및 &lt;code&gt;readonly&lt;/code&gt; 속성에 대해 &lt;em&gt;항상&lt;/em&gt; 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">객체 유형의 문자열과 유사한 속성은 식별자, 문자열 리터럴 또는 문자열 리터럴 유형의 계산 된 속성 이름을 사용하여 선언 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="67a09ff3eda42cceb49c2b8ebb950c7b003be45b" translate="yes" xml:space="preserve">
          <source>Strip Internal - &lt;code&gt;stripInternal&lt;/code&gt;</source>
          <target state="translated">스트립 내부 &lt;code&gt;stripInternal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfbdcec4c2b576f7ec50907da018377d2da918dc" translate="yes" xml:space="preserve">
          <source>Strips all comments from TypeScript files when converting into JavaScript. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">JavaScript로 변환 할 때 TypeScript 파일에서 모든 주석을 제거합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9844396a455fe52a669fba664343368aae3a4790" translate="yes" xml:space="preserve">
          <source>Structural Type System</source>
          <target state="translated">구조적 유형 시스템</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">구조적 타이핑</target>
        </trans-unit>
        <trans-unit id="03e7907c7ea5243abaf83cc6cc7257a835787796" translate="yes" xml:space="preserve">
          <source>Structural typing is a familiar concept to most functional programmers, although Haskell and most MLs are not structurally typed. Its basic form is pretty simple:</source>
          <target state="translated">구조적 유형은 대부분의 기능적 프로그래머에게 친숙한 개념이지만 Haskell과 대부분의 ML은 구조적으로 유형이 지정되지 않습니다. 기본 형식은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">구조적으로 동일하지만 구별되는 클래스 유형은 이제 하나를 제외한 모든 유형을 제거하는 대신 통합 유형으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">outFiles 구조화</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">상대 모듈 구조화</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">원하는 정확한 API 모양을 제공하는 모듈 구조는 까다로울 수 있습니다. 예를 들어, &lt;code&gt;new&lt;/code&gt; 유형을 사용하거나 사용하지 않고 호출 하여 다양한 유형을 생성하고 계층에 다양한 명명 된 유형을 노출하며 모듈 객체에 대한 일부 속성을 갖는 모듈을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d1df78833ce77fa7da034e63ad69c3819501b68" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context, this is on by default &amp;mdash; offers you a chance to have less terse, single colored messages from the compiler.</source>
          <target state="translated">색상과 컨텍스트를 사용하여 오류와 메시지를 스타일 화합니다.이 옵션은 기본적으로 설정되어 있습니다. 컴파일러에서 덜 간결한 단일 색상 메시지를 가질 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">색상과 컨텍스트를 사용하여 오류 및 메시지를 양식화하십시오.</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">숭고한 텍스트</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">하위 유형 대 할당</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">'module : es6'으로 'target : es5'지원</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">지원 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;symbol&lt;/code&gt; 와 특성 이름 &lt;code&gt;keyof&lt;/code&gt; 및 매핑 유형</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">에서 지원 JSX &lt;code&gt;.tsx&lt;/code&gt; 파일 : &lt;code&gt;&quot;react&quot;&lt;/code&gt; , &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; , &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; . &lt;a href=&quot;jsx&quot;&gt;JSX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">지원 &lt;code&gt;--target ES2016&lt;/code&gt; , &lt;code&gt;--target ES2017&lt;/code&gt; 및 &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">지원 &lt;code&gt;--target ES6&lt;/code&gt; 와 &lt;code&gt;--module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">&lt;code&gt;UMD&lt;/code&gt; 및 &lt;code&gt;System&lt;/code&gt; 모듈 출력 지원</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">SystemJS와의 &lt;code&gt;default&lt;/code&gt; 가져 오기 interop 지원</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">JSX 에서 &lt;code&gt;defaultProps&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">지원 &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; 와 CommonJS 모듈에서 &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">믹스 인 클래스 지원</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">UMD 모듈 정의 지원</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">ES3를 대상으로 할 때 데코레이터 지원</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">외부 헬퍼 라이브러리 지원 ( &lt;code&gt;tslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">일반 JavaScript 파일 지원 ( &lt;code&gt;allowJS&lt;/code&gt; 및 선택적으로 사용) &lt;code&gt;checkJs&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">JSX 요소 하위에서 스프레드 연산자 지원</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">IPC 기반 파일로 출력 지원</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">지원되는 JSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">억제 &lt;code&gt;--noImplicitAny&lt;/code&gt; 의 인덱스 서명이 결여 된 인덱싱 된 개체의 오류. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;이슈 # 1232&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73191a43587818ef0ca4822c9bcaeab0705aafe7" translate="yes" xml:space="preserve">
          <source>Suppress Excess Property Errors - &lt;code&gt;suppressExcessPropertyErrors&lt;/code&gt;</source>
          <target state="translated">억제 초과 속성 오류 - &lt;code&gt;suppressExcessPropertyErrors&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77daf91d977b3d49eec9b3c6d5f3a69ff849e689" translate="yes" xml:space="preserve">
          <source>Suppress Implicit Any Index Errors - &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt;</source>
          <target state="translated">암시 적 모든 인덱스 오류 &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">'// @ ts-ignore'주석을 사용하여 .ts 파일에서 오류 억제</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">객체 리터럴에 대한 과도한 속성 검사를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="9e53c6e8e58d38245a243cf6a1ed6b86dd7097bc" translate="yes" xml:space="preserve">
          <source>Svelte</source>
          <target state="translated">Svelte</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">객체 유형의 심볼과 유사한 속성은 고유 한 심볼 유형의 계산 된 속성 이름을 사용하여 선언 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">심볼은 불변이고 고유합니다.</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">심볼을 계산 된 속성 선언과 결합하여 객체 속성과 클래스 멤버를 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">기호 : 일치</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">기호 : 분할</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">시스템 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">시스템 모듈은 기본적으로이 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fc1f7c12fc55ff47463b0071310d36fbecc062ae" translate="yes" xml:space="preserve">
          <source>TS Build Info File - &lt;code&gt;tsBuildInfoFile&lt;/code&gt;</source>
          <target state="translated">TS 빌드 정보 파일 &lt;code&gt;tsBuildInfoFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="translated">TS for Functional Programmers</target>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="translated">TS for Java/C# Programmers</target>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="translated">TS for the New Programmer</target>
        </trans-unit>
        <trans-unit id="db6b15580278437277b53f9bfd85bf02c341afd0" translate="yes" xml:space="preserve">
          <source>TSConfig</source>
          <target state="translated">TSConfig</target>
        </trans-unit>
        <trans-unit id="f0d1d3519955d1c177014af7b8de56104426d555" translate="yes" xml:space="preserve">
          <source>TSConfig Bases</source>
          <target state="translated">TSConfig베이스</target>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="translated">TSConfig Reference</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">ES3 / ES5에서 태그가 지정된 템플릿 문자열</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">태그가 지정된 템플릿은 ECMAScript 2015에 도입 된 호출 형식입니다. 호출 표현식과 마찬가지로 일반 함수는 태그가 지정된 템플릿에 사용될 수 있으며 TypeScript는 사용 된 유형 인수를 유추합니다.</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">태그 조합 유형</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">다음 코드 조각의 출력이 무엇인지 추측하기 위해 잠깐 시간을 내십시오.</target>
        </trans-unit>
        <trans-unit id="f7a6cee3faadf5126dbb6508921d3788cba5ee9b" translate="yes" xml:space="preserve">
          <source>Target - &lt;code&gt;target&lt;/code&gt;</source>
          <target state="translated">타겟- &lt;code&gt;target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">ECMAScript 2015 이상 타겟팅</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">ES5 및 ES3 타겟팅</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">기술적으로 열거 형은 문자열 및 숫자 멤버와 혼합 될 수 있지만 왜 그렇게하고 싶을지는 분명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="426c95cfc85b6cd93af3f2a51c05fff5f6d8d622" translate="yes" xml:space="preserve">
          <source>Tells TypeScript to save information about the project graph from the last compilation to files stored on disk. This creates a series of &lt;code&gt;.tsbuildinfo&lt;/code&gt; files in the same folder as your compilation output. They are not used by your JavaScript at runtime and can be safely deleted. You can read more about the flag in the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag&quot;&gt;3.4 release notes&lt;/a&gt;.</source>
          <target state="translated">마지막 컴파일의 프로젝트 그래프에 대한 정보를 디스크에 저장된 파일에 저장하도록 TypeScript에 지시합니다. 이렇게하면 컴파일 출력과 동일한 폴더에 일련의 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 파일 이 생성 됩니다. 런타임시 JavaScript에서 사용되지 않으며 안전하게 삭제할 수 있습니다. &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#faster-subsequent-builds-with-the---incremental-flag&quot;&gt;3.4 릴리스 노트&lt;/a&gt; 에서 플래그에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">템플릿 문자열</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="8988c52340753c090a90538d2331c181cc676927" translate="yes" xml:space="preserve">
          <source>Templates For Modules</source>
          <target state="translated">모듈 용 템플릿</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">gulp를 실행 한 다음 &lt;code&gt;dist/index.html&lt;/code&gt; 을 열어 페이지를 테스트하십시오. 브라우저에서 . 페이지에 &quot;Hello from TypeScript&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">결과 앱 테스트</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="b57f29315e481e12c1ed5e16efc76553f50ab9b4" translate="yes" xml:space="preserve">
          <source>Testing your types</source>
          <target state="translated">유형 테스트</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho의&lt;/a&gt; 작업 덕분에 TypeScript 2.5는 사용자가 &lt;code&gt;catch&lt;/code&gt; 절 에서 변수를 생략 할 수있는 새로운 ECMAScript 기능을 구현합니다 . 예를 들어 &lt;code&gt;JSON.parse&lt;/code&gt; 를 사용할 때 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 를 사용하여 함수에 대한 호출을 래핑해야 할 수도 있지만 입력이 잘못되었을 때 발생 하는 &lt;code&gt;SyntaxError&lt;/code&gt; 를 사용하지 않을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">그 &lt;code&gt;@types/&lt;/code&gt; 접두사 수단을 우리는 또한 반응하고 반작용-DOM에 대한 선언 파일을받을 것인지. 일반적으로 &lt;code&gt;&quot;react&quot;&lt;/code&gt; 와 같은 경로를 가져 오면 &lt;code&gt;react&lt;/code&gt; 패키지 내부를 살펴 봅니다 . 그러나 모든 패키지에 선언 파일이 포함되어있는 것은 아니므로 TypeScript는 &lt;code&gt;@types/react&lt;/code&gt; 도 찾습니다. 패키지 . 우리는 나중에 이것에 대해 생각할 필요가 없다는 것을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">즉, 예에서 :</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">마지막 예제는 실제로 타입 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">즉 분할하여이 발생할 수 있습니다 &lt;code&gt;undefined&lt;/code&gt; 에서 이유입니다, &lt;code&gt;strictNullChecks&lt;/code&gt; , 다음은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="f0f467baf30c5d87a58b511c11bcb6972b602339" translate="yes" xml:space="preserve">
          <source>That said, you can still use classes if you like! Some problems are well-suited to being solved by a traditional OOP hierarchy, and TypeScript&amp;rsquo;s support for JavaScript classes will make these models even more powerful. TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.</source>
          <target state="translated">즉, 원하는 경우 클래스를 계속 사용할 수 있습니다! 일부 문제는 전통적인 OOP 계층 구조로 해결하기에 적합하며 TypeScript의 JavaScript 클래스 지원은 이러한 모델을 더욱 강력하게 만들 것입니다. TypeScript는 인터페이스, 상속 및 정적 메서드 구현과 같은 많은 일반적인 패턴을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">그것은 &lt;code&gt;tsconfig.json&lt;/code&gt; 자동 포함이었습니다. 위에서 설명한 모듈 해상도는 포함하지 않습니다. 컴파일러가 파일을 모듈 가져 오기의 대상으로 식별 한 경우 이전 단계에서 제외되었는지 여부에 관계없이 파일이 컴파일에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 또는 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 할당 할 수 없기 때문 입니다. 왜? &lt;code&gt;S&lt;/code&gt; 의 &lt;code&gt;done&lt;/code&gt; 속성은 충분히 구체적이지 않기 때문에 &lt;code&gt;boolean&lt;/code&gt; 이지만 &lt;code&gt;T&lt;/code&gt; 의 각 구성 요소는 구체적으로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 &lt;code&gt;done&lt;/code&gt; 속성을 갖습니다 . 그것이 우리가 개별적으로 검사하는 각 구성 유형이 의미하는 바입니다. TypeScript는 각 속성을 함께 결합하지 않고 &lt;code&gt;S&lt;/code&gt; 가 그에 할당 가능한지 확인 합니다. 그렇다면 잘못된 코드가 다음과 같이 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">이것이 바로 TypeScript 3.7이 도입 한 내용입니다. 타입 별칭의 &quot;최상위 레벨&quot;에서 TypeScript는 이러한 패턴을 허용하기 위해 타입 인수를 연기합니다.</target>
        </trans-unit>
        <trans-unit id="caa5997b70498ef9dc82ab15a96dfd070e25828b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">블록 범위 변수가 함수 범위 변수로 선언 될 수 없다는 것은 아닙니다. 블록 범위 변수는 뚜렷하게 다른 블록 내에서 선언하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">즉, 블록 범위 변수는 함수 범위 변수로 선언 할 수 없습니다. 블록 범위 변수는 분명히 다른 블록 내에서 선언하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">옵션 체인이 갖는&amp;ldquo;단락&amp;rdquo;동작은 제한된 속성 액세스, 호출, 요소 액세스입니다. 이러한 식에서 더 이상 확장되지 않습니다. 다시 말해,</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">1.1 컴파일러는 일반적으로 이전 릴리스보다 약 4 배 빠릅니다. &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;인상적인 차트에&lt;/a&gt; 대해서는 이 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;비동기 반복 제안서&lt;/a&gt; 또한 부분 연산 결과를 생성하는 데 사용될 수있는 비동기 기능 소개 &quot;비동기 발전기&quot;. 비동기 생성기는 &lt;code&gt;yield*&lt;/code&gt; 를 통해 반복 가능 또는 비동기 반복 가능에 호출을 위임 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f02cc7fd88e051d39dd94c7b8ad656951cb0464f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt;&lt;code&gt;--strictNullChecks&lt;/code&gt;&lt;/a&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig#strictNullChecks&quot;&gt; &lt;code&gt;--strictNullChecks&lt;/code&gt; &lt;/a&gt; 플래그 수정이 : 당신이 변수를 선언 할 때, 자동으로 포함되지 않습니다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; . 공용체 유형을 사용하여 명시 적으로 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;라이브러리 구조의&lt;/a&gt; 가이드는 어떻게 각 형식에 대한 올바른 선언 파일을 작성하는 일반적인 라이브러리 형식과를 이해하는 데 도움이됩니다. 기존 파일을 편집하는 경우이 섹션을 읽을 필요가 없습니다. 새 선언 파일의 작성자는 라이브러리의 형식이 선언 파일 작성에 미치는 영향을 올바르게 이해하려면이 섹션을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="227e047dd56cbfa40dd19f72261ee33cba429b50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a proper declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">&lt;a href=&quot;library-structures&quot;&gt;라이브러리 구조의&lt;/a&gt; 가이드는 어떻게 각 형식에 대한 적절한 선언 파일을 작성하는 일반적인 라이브러리 형식과를 이해하는 데 도움이됩니다. 기존 파일을 편집하는 경우이 섹션을 읽을 필요가 없습니다. 새로운 선언 파일의 작성자는 라이브러리 형식이 선언 파일 작성에 어떤 영향을 미치는지 올바르게 이해하기 위해이 섹션을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">&lt;a href=&quot;publishing&quot;&gt;게시&lt;/a&gt; 섹션에서는 선언 NPM 패키지 파일 및 부양 패키지를 관리하는 방법을 보여줍니다를 게시하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 속성은 컴파일러의 기본값이 사용되는 경우에는 생략 할 수 있습니다. 지원되는 &lt;a href=&quot;compiler-options&quot;&gt;컴파일러 옵션&lt;/a&gt; 의 전체 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0001ea5843eb39fe0b55fd06eada6c514b9a65f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 속성은 컴파일러의 기본값이 사용되는 경우에는 생략 할 수 있습니다. 지원되는 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;컴파일러 옵션&lt;/a&gt; 의 전체 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; 속성은 상대 또는 절대 파일 경로의 목록을합니다. &lt;code&gt;&quot;include&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성 글로브와 같은 파일 패턴 목록을. 지원되는 glob 와일드 카드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자 추가 &lt;code&gt;null&lt;/code&gt; 및 / 또는 &lt;code&gt;undefined&lt;/code&gt; 왼쪽 피연산자의 형태로 존재하고있는 권리에 따라 피연산자의 유형 &lt;code&gt;||&lt;/code&gt; 연산자는 결과 공용체 유형의 왼쪽 피연산자 유형에서 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 모두 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; 플래그</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; 의 타이프 라이터의 플래그는 우리가 생성 할 수 있습니다 &lt;code&gt;.d.ts&lt;/code&gt; 의 타이프 라이터 소스 파일에서 파일 (선언 파일) (즉, &lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일). 이 &lt;code&gt;.d.ts&lt;/code&gt; 파일은 몇 가지 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; 컴파일러 옵션이 아닌 명령 줄에서 전달되지 않은 편집에 파일을 &quot;추가&quot;를 컴파일러에 지시합니다. 여전히 모듈을 파일로 해석하려고 시도하지만 파일을 지정하지 않으면 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">&lt;code&gt;--preserveSymlinks&lt;/code&gt; 컴파일러 플래그</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; ( &lt;code&gt;-p&lt;/code&gt; ) 플래그는 이제 모든 파일 경로를 취할 수</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; 명령 줄 옵션은 원래 단지를 포함하는 폴더 경로를 취할 수 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 . 빌드 구성에 대한 다양한 시나리오를 고려할 때 &lt;code&gt;--project&lt;/code&gt; 가 다른 호환 가능한 JSON 파일을 가리 키도록하는 것이 합리적 입니다. 예를 들어, 사용자는 Node 5 용 CommonJS 모듈로 ES2015를 대상으로하고 브라우저 용 AMD 모듈로 ES5를 대상으로 할 수 있습니다. 이 새로운 작업을 통해 사용자는 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 별도의 디렉토리에 배치하는 등의 해킹 방법을 수행하지 않고도 &lt;code&gt;tsc&lt;/code&gt; 만 사용하여 두 개의 개별 빌드 대상을 쉽게 관리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그 수정이 : 당신이 변수를 선언 할 때, 자동으로 포함되지 않습니다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; . 공용체 유형을 사용하여 명시 적으로 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55039ea9d10371eccc73bd4e7f114e096aeca2ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on using &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; which are provided by node, both of these methods have pros and cons.</source>
          <target state="translated">컴파일러 의 &lt;code&gt;--watch&lt;/code&gt; 구현은 노드에서 제공하는 &lt;code&gt;fs.watch&lt;/code&gt; 및 &lt;code&gt;fs.watchFile&lt;/code&gt; 사용에 의존하며 ,이 두 방법 모두 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d240e7152b3bafeb38e60b7f07cc2b34d2b2256a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.d.ts&lt;/code&gt; syntax intentionally looks like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES Modules&lt;/a&gt; syntax. ES Modules was ratified by TC39 in 2019, while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:</source>
          <target state="translated">&lt;code&gt;.d.ts&lt;/code&gt; 은 의도적으로 같은 외모 구문 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES 모듈&lt;/a&gt; 구문을. ES 모듈은 2019 년 TC39에 의해 비준되었으며 오랫동안 트랜스 파일러를 통해 사용할 수 있었지만 ES 모듈을 사용하는 JavaScript 코드베이스가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="a22cea6dc461395ba18169f7540ed681c6226e15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.js&lt;/code&gt; files will in turn contain a sourcemap comment to indicate to tools where the files are to external tools, for example:</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일은 다시 파일을 예를 들어, 외부 도구에있는 도구를 나타 내기 위해 sourcemap 주석을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시는이 그룹의 가장 일반적이다. 파일 간의 &lt;em&gt;종속성&lt;/em&gt; 선언으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;??&lt;/code&gt; 연산자는 &lt;code&gt;||&lt;/code&gt; 기본값을 사용하려고 할 때. 예를 들어, 다음 코드 스 니펫은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt; 에 마지막으로 저장된 볼륨을 가져 오려고 시도합니다 (있는 경우). 그러나 &lt;code&gt;||&lt;/code&gt; 를 사용하기 때문에 버그가 있습니다. .</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; 의 태그는 구성원 특정 유형의 모든입니다 객체 리터럴을 만들 수 있습니다. Javascript의 대부분의 객체 리터럴과 달리 다른 멤버는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">&lt;code&gt;@enumerable(false)&lt;/code&gt; 여기에 장식이있다 &lt;a href=&quot;#decorator-factories&quot;&gt;장식 공장&lt;/a&gt; . 때 &lt;code&gt;@enumerable(false)&lt;/code&gt; 장식가 호출 될 때, 그것은 수정 &lt;code&gt;enumerable&lt;/code&gt; 속성 기술자의 속성을.</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">&lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; 여기서 장식은이다 &lt;a href=&quot;#decorator-factories&quot;&gt;장식 공장&lt;/a&gt; . 때 &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; 라고하며, 이는 사용하여 속성에 대한 메타 데이터 항목을 추가 &lt;code&gt;Reflect.metadata&lt;/code&gt; 의 로부터 기능 &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리를. &lt;code&gt;getFormat&lt;/code&gt; 이 호출 되면 형식의 메타 데이터 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">&lt;code&gt;@required&lt;/code&gt; 장식은 마크 파라미터가 필요로하는 메타 데이터 항목을 추가한다. &lt;code&gt;@validate&lt;/code&gt; 의 장식은 기존 랩 &lt;code&gt;greet&lt;/code&gt; 원래 메소드를 호출하기 전에 인자를 검증하는 기능의 방법.</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">&lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 우리가 생성자 함수 유형의 모든 매개 변수 유형을 추출 할 수 있습니다. 모든 매개 변수 유형 (또는 &lt;code&gt;T&lt;/code&gt; 가 함수가 아닌 경우 &lt;code&gt;never&lt;/code&gt; 유형)이있는 튜플 유형을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="83d02d02d5620960b36d464619c7937c85cc9171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Document&lt;/code&gt; Interface</source>
          <target state="translated">&lt;code&gt;Document&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; 유형은 이제 사용자가 굴복 유형, 반환 유형 및 그 유형을 지정 할 수 있습니다 &lt;code&gt;next&lt;/code&gt; 받아 들일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c806f2503a2c301fc142862aa6123f9229b59408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">&lt;code&gt;Omit&lt;/code&gt; 도우미 유형</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 의 유형에 대해 설명 &lt;code&gt;Array&lt;/code&gt; 만 읽을 수 있습니다들. &lt;code&gt;ReadonlyArray&lt;/code&gt; 에 대한 참조가있는 변수 는 배열의 요소를 추가, 제거 또는 교체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; 마커 인터페이스 단순히 선언 빈 인터페이스 &lt;code&gt;lib.d.ts&lt;/code&gt; . 컨텍스트 유형의 객체 리터럴에서 인식되는 것 외에도 인터페이스는 빈 인터페이스처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">&lt;code&gt;amd-dependency&lt;/code&gt; 지시어는 선택 사양 할 수 있습니다 &lt;code&gt;name&lt;/code&gt; 속성, 이를 통해 amd- 종속성에 대한 선택적 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">&lt;code&gt;amd-module&lt;/code&gt; 지시자는 컴파일러에 옵션 모듈의 이름을 전달 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3a42e83d7ce322bb05576e69237c913e674e94ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation.</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 유형의 수, 자바 스크립트를 기존 작업 할 강력한 방법입니다 당신에게 점차적으로 옵트 인 및 옵트 아웃 유형 검사의 컴파일하는 동안.</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 유형의 수, 자바 스크립트를 기존 작업 할 강력한 방법입니다 당신에게 점차적으로 옵트 인 및 옵트 아웃 유형 검사의 컴파일하는 동안. 다른 언어에서와 마찬가지로 &lt;code&gt;Object&lt;/code&gt; 가 유사한 역할을 수행 할 것으로 예상 할 수 있습니다 . 그러나 &lt;code&gt;Object&lt;/code&gt; 유형의 변수는 값을 지정할 수만 있습니다. 실제로 존재하는 메소드조차도 임의의 메소드를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 당신이 유형의 일부를 알고 있지만, 아마도 모든 그것의 경우 종류도 편리합니다. 예를 들어, 배열이 있지만 배열에 다른 유형이 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1d41de80e1caf6129e3e280267f6e09abe3bf99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; will continue to propagate through your objects:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 사용자의 객체를 통해 전파 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 연산자는 모두 사용할 &lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일 및 각도 브래킷 유형 선언 스타일로 행동 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3eeb3c7a58b8f984aa019a2e9e3c1db1552b14c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;composite&lt;/code&gt; option enforces certain constraints which make it possible for build tools (including TypeScript itself, under &lt;code&gt;--build&lt;/code&gt; mode) to quickly determine if a project has been built yet.</source>
          <target state="translated">&lt;code&gt;composite&lt;/code&gt; 옵션 (아래, 타이프 라이터 자체를 포함하여 빌드 도구가 가능하게 특정 제약 조건 적용 &lt;code&gt;--build&lt;/code&gt; 프로젝트가 아직 구축되어있는 경우 신속하게 결정하는 모드).</target>
        </trans-unit>
        <trans-unit id="dec99f693ec8e29469547cb939cd2051d5a6580d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;document.getElementById&lt;/code&gt; function returns an &lt;code&gt;HTMLElement&lt;/code&gt;. &lt;code&gt;HTMLElement&lt;/code&gt; interface extends the &lt;code&gt;Element&lt;/code&gt; interface which extends the &lt;code&gt;Node&lt;/code&gt; interface. This prototypal extension allows for all &lt;code&gt;HTMLElements&lt;/code&gt; to utilize a subset of standard methods. In the code snippet, we use a property defined on the &lt;code&gt;Node&lt;/code&gt; interface to append the new &lt;code&gt;p&lt;/code&gt; element to the website.</source>
          <target state="translated">&lt;code&gt;document.getElementById&lt;/code&gt; 를의 함수는 반환 &lt;code&gt;HTMLElement&lt;/code&gt; . &lt;code&gt;HTMLElement&lt;/code&gt; 인터페이스 는 &lt;code&gt;Node&lt;/code&gt; 인터페이스 를 확장하는 &lt;code&gt;Element&lt;/code&gt; 인터페이스를 확장합니다 . 이 프로토 타입 확장을 사용하면 모든 &lt;code&gt;HTMLElements&lt;/code&gt; 가 표준 메서드의 하위 집합을 활용할 수 있습니다 . 코드 조각에서는 &lt;code&gt;Node&lt;/code&gt; 인터페이스 에 정의 된 속성을 사용 하여 웹 사이트에 새 &lt;code&gt;p&lt;/code&gt; 요소를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; 목록은 wilcards 지원하지 않습니다. 단순히 파일 및 / 또는 디렉토리의 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 구문 지정 모듈로부터 익스포트되는 단일 객체. 클래스, 인터페이스, 네임 스페이스, 함수 또는 열거 형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">클래스 의 &lt;code&gt;extends&lt;/code&gt; 절은 이전에 형식 참조를 지정해야했습니다. 이제 선택적으로 유형 인수 목록이 오는 표현식을 허용합니다. 표현식의 유형은 &lt;code&gt;extends&lt;/code&gt; 절에 지정된 유형 인수의 수와 동일한 수의 유형 매개 변수를 갖는 구성 서명이 하나 이상있는 생성자 함수 유형이어야합니다 . 일치하는 구문 서명의 반환 유형은 클래스 인스턴스 유형이 상속하는 기본 유형입니다. 이를 통해 실제 클래스와 &quot;클래스 유사&quot;표현식을 &lt;code&gt;extends&lt;/code&gt; 절에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 에서 최상위 속성입니다 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 (함께 &lt;code&gt;compilerOptions&lt;/code&gt; 는 , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; ). &lt;code&gt;extends&lt;/code&gt; 'value는 상속 할 다른 구성 파일의 경로를 포함하는 문자열입니다. 경로는 Node.js 스타일 해상도를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;for-await-of&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">&lt;code&gt;for..await..of&lt;/code&gt; 문은 비동기 기능 또는 비동기 발전기 내에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">&lt;code&gt;getWidget&lt;/code&gt; 의 함수는 숫자를 받아 위젯을 반환하거나 문자열 반환 위젯 배열을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;greeter&lt;/code&gt; 객체는 파일에 로그인하거나 경고를 표시 할 수 있습니다. LogOptions를 &lt;code&gt;.log(...)&lt;/code&gt; 하고 경고 옵션을 &lt;code&gt;.alert(...)&lt;/code&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681ed2c77b2f124166709179044128a1509b2444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator also acts as a narrowing expression for types.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 연산자는 타입 좁아 식으로 작용한다.</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 오퍼레이터는 이제 유형 좁아 식으로 작용한다.</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">선택적 요소가있는 튜플 유형 의 &lt;code&gt;length&lt;/code&gt; 특성은 가능한 길이를 나타내는 숫자 리터럴 유형의 결합입니다. 예를 들어, 튜플 유형 &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; 의 &lt;code&gt;length&lt;/code&gt; 속성 유형 은 &lt;code&gt;1 | 2 | 3&lt;/code&gt; 2 | 3 .</target>
        </trans-unit>
        <trans-unit id="edc3cf84bfebfe901fb4d4669024b6fb12e9c7d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moment&lt;/code&gt; import would be fully typed.</source>
          <target state="translated">가져 오기가 완전히 입력 되는 &lt;code&gt;moment&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 유형은 다음과 같은 특징이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 유형은의 하위 유형, 그리고 모든 종류의에 할당 할; 그러나 &lt;em&gt;어떤&lt;/em&gt; 유형도 &lt;code&gt;never&lt;/code&gt; 의 하위 유형이거나 할당 할 수 없습니다 ( &lt;code&gt;never&lt;/code&gt; 제외 ). 심지어 &lt;code&gt;any&lt;/code&gt; 에 할당 할 수없는 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09dccd3b70d3efcf8ad49b20ad7c607d29406b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 유형은 발생하지 않을 것으로 값의 유형을 나타냅니다. 예를 들어, &lt;code&gt;never&lt;/code&gt; 는 항상 예외를 발생시키는 함수 식이나 화살표 함수 식의 반환 유형이거나 절대 반환하지 않는 식입니다. 변수는 참일 수없는 유형 가드에 의해 좁혀 질 때 &lt;code&gt;never&lt;/code&gt; 유형을 얻지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 유형은 발생하지 않을 것으로 값의 유형을 나타냅니다. 예를 들어, &lt;code&gt;never&lt;/code&gt; 함수 표현식 또는 항상 예외 또는 하나 결코 수익을 던졌습니다 화살표 기능 식에 대한 반환 형식이 없다; 변수는 또한 결코 진실이 될 수없는 유형 가드에 의해 좁혀 질 때 유형을 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 메타 속성은 ES2015에 도입 된 새로운 구문입니다. &lt;code&gt;new&lt;/code&gt; 를 통해 생성자의 인스턴스를 &lt;code&gt;new.target&lt;/code&gt; 의 값은 처음에 인스턴스를 할당하는 데 사용 된 생성자 함수에 대한 참조로 설정됩니다. &lt;code&gt;new&lt;/code&gt; 를 통해 생성되지 않고 함수를 호출 하면 &lt;code&gt;new.target&lt;/code&gt; 이 &lt;code&gt;undefined&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 유형은 &lt;em&gt;하지&lt;/em&gt; 로 확대 &lt;code&gt;any&lt;/code&gt; 엄격한 널 검사 모드.</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 제거는 여기에 꽤 분명하다,하지만 당신은 terser 연산자도 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ce2eedc44ab0659afbd8a1934f33562f60e3a770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; option computes the final file location in a way that is not predictable or consistent. This option is retained for backward compatibility only and is deprecated.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 옵션은 예측 또는 일치하지 않는 방식으로 최종 파일의 위치를 계산한다. 이 옵션은 이전 버전과의 호환성을 위해서만 유지되며 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">각 참조 의 &lt;code&gt;path&lt;/code&gt; 특성은 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 포함하는 디렉토리 또는 구성 파일 자체 (이름이있을 수 있음)를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2afabb5c4140f687a8b8b854febbb675c40d2812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;point&lt;/code&gt; variable is never declared to be a &lt;code&gt;Point&lt;/code&gt; type. However, TypeScript compares the shape of &lt;code&gt;point&lt;/code&gt; to the shape of &lt;code&gt;Point&lt;/code&gt; in the type-check. They have the same shape, so the code passes.</source>
          <target state="translated">&lt;code&gt;point&lt;/code&gt; 변수는 선언되지 않습니다 &lt;code&gt;Point&lt;/code&gt; 유형입니다. 그러나, 타이프 라이터는 모양 비교 &lt;code&gt;point&lt;/code&gt; 의 모양에 &lt;code&gt;Point&lt;/code&gt; 유형 검사한다. 모양이 같으므로 코드가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; 출력의 일부로 JSX 식을 유지할 모드 또 다른 변환 단계에서 소비된다. &lt;em&gt;또한 출력의 파일 확장자 는 &lt;code&gt;.jsx&lt;/code&gt; 입니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 수정은 거의 같은 역할을 &lt;code&gt;private&lt;/code&gt; 회원이 선언 된 것을 제외하고 수정 &lt;code&gt;protected&lt;/code&gt; 도 파생 클래스 내에서 액세스 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6d895e4e8795254dd65da4c62b6624de0640eaf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelector&lt;/code&gt; and &lt;code&gt;querySelectorAll&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;querySelector&lt;/code&gt; 및 &lt;code&gt;querySelectorAll&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="6fb559dc4cb94749b099fdff9ab41761d1224d04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;querySelectorAll&lt;/code&gt; definition is similar to &lt;code&gt;getElementsByTagName&lt;/code&gt;, except it returns a new type: &lt;code&gt;NodeListOf&lt;/code&gt;. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing &lt;code&gt;NodeListOf&amp;lt;E&amp;gt;&lt;/code&gt; with &lt;code&gt;E[]&lt;/code&gt; would result in a very similar user experience. &lt;code&gt;NodeListOf&lt;/code&gt; only implements the following properties and methods: &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;item(index)&lt;/code&gt;, &lt;code&gt;forEach((value, key, parent) =&amp;gt; void)&lt;/code&gt; , and numeric indexing. Additionally, this method returns a list of &lt;em&gt;elements&lt;/em&gt;, not &lt;em&gt;nodes&lt;/em&gt;, which is what &lt;code&gt;NodeList&lt;/code&gt; was returning from the &lt;code&gt;.childNodes&lt;/code&gt; method. While this may appear as a discrepancy, take note that interface &lt;code&gt;Element&lt;/code&gt; extends from &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;querySelectorAll&lt;/code&gt; 의 정의와 유사하다 &lt;code&gt;getElementsByTagName&lt;/code&gt; 은 새로운 형식을 반환 제외 : &lt;code&gt;NodeListOf&lt;/code&gt; . 이 반환 유형은 기본적으로 표준 JavaScript 목록 요소의 사용자 정의 구현입니다. 틀림없이 &lt;code&gt;NodeListOf&amp;lt;E&amp;gt;&lt;/code&gt; 를 &lt;code&gt;E[]&lt;/code&gt; 바꾸면 매우 유사한 사용자 경험을 얻을 수 있습니다. &lt;code&gt;NodeListOf&lt;/code&gt; 는 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;item(index)&lt;/code&gt; , &lt;code&gt;forEach((value, key, parent) =&amp;gt; void)&lt;/code&gt; 및 숫자 인덱싱과 같은 속성 및 메서드 만 구현 합니다. 또한이 메소드는 &lt;em&gt;노드가&lt;/em&gt; 아닌 &lt;em&gt;요소&lt;/em&gt; 목록을 반환합니다. 이것이 바로 &lt;code&gt;NodeList&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt; &lt;code&gt;.childNodes&lt;/code&gt; 메서드 에서 반환되었습니다 . 불일치로 보일 수 있지만 interface &lt;code&gt;Element&lt;/code&gt; 는 &lt;code&gt;Node&lt;/code&gt; 에서 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; 방출합니다 모드 &lt;code&gt;React.createElement&lt;/code&gt; 는 사용하기 전에 JSX 변환을 통해 갈 필요하지 않으며, 출력은 것 &lt;code&gt;.js&lt;/code&gt; 파일 확장자를.</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 및 &lt;code&gt;key&lt;/code&gt; 특성은 모든 구성 요소에 대한 올바른 유형이 나타납니다</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 속성이 올바르게 비 저장 기능 구성 요소의 인스턴스에서 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="ac59872f32d7b3a719d54a776ba1d5030bee34ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 설정, 명시 적으로 설정하지 않는 경우는 포함하는 디렉토리에 대한 기본값 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일을.</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 설정, 명시 적으로 들어있는 디렉토리로, 기본값을 설정하지 않을 경우 &lt;code&gt;tsconfig&lt;/code&gt; 의 파일을</target>
        </trans-unit>
        <trans-unit id="e8756ccc79f64c7c4f7907edf57709c722c3dc27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the &lt;em&gt;strict mode family&lt;/em&gt; options, which are outlined below. You can then turn off individual strict mode family checks as needed.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; 플래그는 유형 검사 행동의 넓은 범위를 가능하게 프로그램 정확성의 강력한 보장 결과 그. 이 기능을 켜는 것은 아래에 설명 된 모든 &lt;em&gt;엄격 모드 제품군&lt;/em&gt; 옵션 을 활성화 하는 것과 같습니다. 그런 다음 필요에 따라 개별 엄격 모드 가족 확인을 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 옵션 (사용자가 밖으로 전환 할 수 &lt;code&gt;es5&lt;/code&gt; 에 &lt;code&gt;es3&lt;/code&gt; , &lt;code&gt;es2015&lt;/code&gt; , &lt;code&gt;esnext&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="d58e04ff8c5c532dba7b8207798261684e83b514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; setting changes which JS features are downleveled and which are left intact. For example, an arrow function &lt;code&gt;() =&amp;gt; this&lt;/code&gt; will be turned into an equivalent &lt;code&gt;function&lt;/code&gt; expression if &lt;code&gt;target&lt;/code&gt; is ES5 or lower.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; JS 기능 downleveled되고, 설정 변경은 그대로 유지된다. 예를 들어, 화살표 함수 &lt;code&gt;() =&amp;gt; this&lt;/code&gt; &lt;code&gt;target&lt;/code&gt; ES5 이하 이면 동등한 &lt;code&gt;function&lt;/code&gt; 표현식 으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형은 사용의 믹스 인 스타일의 패턴이 상속을 설명하는 것을 라이브러리를 기술의 교차로 유형 (예 : Ember.js)에 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="22032c123849dac540221c1f0c198bc84d0e5030" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsconfig.json&lt;/code&gt; Schema can be found at &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;the JSON Schema Store&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 스키마에서 찾을 수 있습니다 &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;JSON 스키마 스토어&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; 플래그와 &lt;code&gt;declare&lt;/code&gt; 속성 수정</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">멤버 의 &lt;em&gt;속성 설명자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">&lt;em&gt;nullish 병합 연산자는&lt;/em&gt; 옵션 체인과 손을 가고, 어떤 팀이 TC39에 옹호와 관련 된 다른 다가오는 인 ECMAScript 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">Async Iteration 은 &lt;code&gt;Iterator&lt;/code&gt; 와 유사한 &lt;code&gt;AsyncIterator&lt;/code&gt; 를 소개합니다 . 차이점은 &lt;code&gt;AsyncIterator&lt;/code&gt; 의 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 메소드가 결과 자체가 아니라 반복 결과에 대한 &lt;code&gt;Promise&lt;/code&gt; 을 반환 한다는 사실에 있습니다. 이를 통해 호출자는 &lt;code&gt;AsyncIterator&lt;/code&gt; 가 값을 생성하는 시점까지 진행된 시간 동안 비동기 알림에 참여할 수 있습니다 . &lt;code&gt;AsyncIterator&lt;/code&gt; 는 다음과 같은 형태를 갖는다 :</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">기초</target>
        </trans-unit>
        <trans-unit id="264fd8a4a9ece4731967069d64f52539be927716" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is broken down into the following sections.</source>
          <target state="translated">선언 파일 섹션은 다음 섹션으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="8f7ab3e11b9b6277a216f46b871ce84ce2b9abe1" translate="yes" xml:space="preserve">
          <source>The Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.</source>
          <target state="translated">선언 파일 섹션은 고품질 TypeScript 선언 파일을 작성하는 방법을 알려줍니다. 시작하려면 TypeScript 언어에 대한 기본적인 지식이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">실시 예</target>
        </trans-unit>
        <trans-unit id="6e513416df8e3dfac45e1c52226655ef81089278" translate="yes" xml:space="preserve">
          <source>The Handbook also isn&amp;rsquo;t intended to be a replacement for a language specification. In some cases, edge cases or formal descriptions of behavior will be skipped in favor of high-level, easier-to-understand explanations. Instead, there are separate reference pages that more precisely and formally describe many aspects of TypeScript&amp;rsquo;s behavior. The reference pages are not intended for readers unfamiliar with TypeScript, so they may use advanced terminology or reference topics you haven&amp;rsquo;t read about yet.</source>
          <target state="translated">핸드북은 또한 언어 사양을 대체하기위한 것이 아닙니다. 어떤 경우에는 높은 수준의 이해하기 쉬운 설명을 위해 엣지 케이스 또는 동작에 대한 공식적인 설명을 건너 뛸 수 있습니다. 대신 TypeScript 동작의 여러 측면을보다 정확하고 공식적으로 설명하는 별도의 참조 페이지가 있습니다. 참조 페이지는 TypeScript에 익숙하지 않은 독자를위한 것이 아니므로 아직 읽지 않은 고급 용어 나 참조 주제를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8fc72f4ed0ac1173879adc908fcb0666497c3e" translate="yes" xml:space="preserve">
          <source>The Handbook is also intended to be a concise document that can be comfortably read in a few hours. Certain topics won&amp;rsquo;t be covered in order to keep things short.</source>
          <target state="translated">핸드북은 또한 몇 시간 안에 편안하게 읽을 수있는 간결한 문서로 제작되었습니다. 짧게 유지하기 위해 특정 주제는 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">ES6이 모듈 호출 서명에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">모듈 플러그인에 대한 ES6의 영향</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Iterator 프로토콜은 또한 &lt;code&gt;for..of&lt;/code&gt; 및 spread 연산자와 같은 ES2015 기능 중 일부의 대상을 정의하고 어사 인은 할당 제거 네트워크를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">JSX 결과 유형</target>
        </trans-unit>
        <trans-unit id="2d7cc01d800025ab217a381f554be9b732cc9fcf" translate="yes" xml:space="preserve">
          <source>The JavaScript output is still the same.</source>
          <target state="translated">JavaScript 출력은 여전히 ​​동일합니다.</target>
        </trans-unit>
        <trans-unit id="318584735a5f4a0cd6e19d4529dc37491fd1acf3" translate="yes" xml:space="preserve">
          <source>The TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:</source>
          <target state="translated">TSConfig는 컴파일러 플래그를 모두 구성하고 파일을 찾을 위치를 선언하는 jsonc 파일입니다. 이 경우 다음과 같은 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="translated">The TypeScript Handbook</target>
        </trans-unit>
        <trans-unit id="2b5f2e3eae34731098e1b7b55bd45c047f7f4695" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook is intended to be a comprehensive document that explains TypeScript to everyday programmers. You can read the handbook by going from top to bottom in the left-hand navigation.</source>
          <target state="translated">TypeScript 핸드북은 일상적인 프로그래머에게 TypeScript를 설명하는 포괄적 인 문서입니다. 왼쪽 탐색 메뉴에서 위에서 아래로 이동하여 핸드북을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">TypeScript 컴파일러에는 최종 출력을 생성하기 위해 소스에 발생할 것으로 예상되는 변환을 컴파일러에 &lt;em&gt;알리는&lt;/em&gt; 추가 플래그 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">TypeScript 컴파일러는 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에서 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 특성을 사용하여 이러한 맵핑 선언을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">TypeScript 컴파일러는 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에서 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 특성을 사용하여 이러한 맵핑 선언을 지원 합니다. 다음은 &lt;code&gt;jquery&lt;/code&gt; 에 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 속성 을 지정하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">TypeScript 컴파일러는 &lt;code&gt;@Reflect.metadata&lt;/code&gt; 데코레이터를 사용하여 디자인 타임 유형 정보를 삽입 합니다. 다음 TypeScript와 동일하다고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">TypeScript 컴파일러는 해당 버전을 대상으로 할 때 for..of 배열을 관용적 ES3 / ES5 JavaScript로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7c695dd66f4a120dfae2df4de90b84e627a92bcc" translate="yes" xml:space="preserve">
          <source>The TypeScript playground can show you the &lt;code&gt;.d.ts&lt;/code&gt; equivalent for JavaScript code. You can &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA&quot;&gt;try it yourself here&lt;/a&gt;.</source>
          <target state="translated">TypeScript 플레이 그라운드는 JavaScript 코드에 해당 하는 &lt;code&gt;.d.ts&lt;/code&gt; 를 보여줄 수 있습니다. &lt;a href=&quot;https://www.typescriptlang.org/play?useJavaScript=true#code/GYVwdgxgLglg9mABAcwKZQIICcsEMCeAMqmMlABYAUuOAlIgN6IBQiiW6IWSNWAdABsSZcswC+zCAgDOURAFtcADwAq5GKUQBeRAEYATM2by4AExBC+qJQAc4WKNO2NWKdNjxFhFADSvFquqk4sxAA&quot;&gt;여기에서 직접 시도해&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">TypeScript 놀이터는 편리한 새 기능으로 많이 필요합니다! 새로운 놀이터는 대부분 커뮤니티 회원들이 점점 더 많이 사용하는 &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt; 의 &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript 놀이터&lt;/a&gt; 의 포크입니다 . 우리는 Artem에게 큰 도움을주었습니다.</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">TypeSript 컴파일러는 필요할 때 &lt;code&gt;__extends&lt;/code&gt; 와 같은 몇 가지 도우미를 내 보냅니다 . 헬퍼는 참조 된 모든 파일에서 생성됩니다. 모든 헬퍼를 한 곳에서 통합하거나 기본 동작을 무시하려면 &lt;code&gt;--noEmitHelpers&lt;/code&gt; 를 사용하여 컴파일러가 지시하지 않도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">위의 코드는 문자열을 숫자로 나눌 수 없으므로 오류가 발생합니다. &lt;code&gt;preserve&lt;/code&gt; 옵션을 사용할 때의 출력 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">위의 해결 방법은 &lt;code&gt;squareOptions&lt;/code&gt; 와 &lt;code&gt;SquareConfig&lt;/code&gt; 사이에 공통 속성이있는 한 작동 합니다. 이 예에서는 property &lt;code&gt;width&lt;/code&gt; 입니다. 그러나 변수에 공통 객체 속성이 없으면 실패합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">보다 중첩 된 범위에서 새 이름을 도입하는 것을 &lt;em&gt;섀도 잉&lt;/em&gt; 이라고 합니다. 우발적 인 그림자 발생시 특정 버그를 발생시키는 동시에 특정 버그를 예방할 수 있다는 점에서 양날의 칼입니다. 예를 들어 &lt;code&gt;let&lt;/code&gt; 변수를 사용하여 이전 &lt;code&gt;sumMatrix&lt;/code&gt; 함수를 작성했다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">선택적 속성의 장점은 이러한 가능한 속성을 설명하면서 인터페이스의 일부가 아닌 속성을 계속 사용할 수 없다는 것입니다. 예를 들어 &lt;code&gt;createSquare&lt;/code&gt; 에서 &lt;code&gt;color&lt;/code&gt; 속성 의 이름을 잘못 입력하면 다음과 같은 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">대안은 언어가 코드를 분석 할 수 있도록 코드를 다시 작성하는 것이었지만 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e538489907af6acf36979924fc373420776d09" translate="yes" xml:space="preserve">
          <source>The answer is that you can&amp;rsquo;t learn TypeScript without learning JavaScript! TypeScript shares syntax and runtime behavior with JavaScript, so anything you learn about JavaScript is helping you learn TypeScript at the same time.</source>
          <target state="translated">대답은 JavaScript를 배우지 않고는 TypeScript를 배울 수 없다는 것입니다! TypeScript는 구문 및 런타임 동작을 JavaScript와 공유하므로 JavaScript에 대해 배우는 모든 것이 동시에 TypeScript를 배우는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">답은 과부하 목록과 동일한 기능에 대해 여러 기능 유형을 제공하는 것입니다. 이 목록은 컴파일러가 함수 호출을 해결하는 데 사용하는 것입니다. &lt;code&gt;pickCard&lt;/code&gt; 가 수락하는 것과 반환 하는 것을 설명하는 오버로드 목록을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">인수는 유효한 JSON 구성 파일의 파일 경로이거나 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 포함 된 디렉토리의 디렉토리 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">as 연산자</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">타이프의 구조 타입 시스템에 대한 기본 규칙, 즉 &lt;code&gt;x&lt;/code&gt; 가 호환 &lt;code&gt;y&lt;/code&gt; 경우 &lt;code&gt;y&lt;/code&gt; 같은 적어도 동일한 부재 갖는 &lt;code&gt;x&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c55521452311c3ac39fa2cd2823a7857ecfdacde" translate="yes" xml:space="preserve">
          <source>The best part about the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the &lt;code&gt;HTMLElement&lt;/code&gt; interface is documented by this &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement page&lt;/a&gt; on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#htmlelement&quot;&gt;W3C Recommendation for HTMLElement&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;lib.dom.d.ts&lt;/em&gt; 유형 정의 의 가장 좋은 부분은 MDN (Mozilla Developer Network) 문서 사이트에 주석이 추가 된 유형을 반영한다는 것입니다. 예를 들어, &lt;code&gt;HTMLElement&lt;/code&gt; 인터페이스는 MDN 의이 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/HTMLElement&quot;&gt;HTMLElement 페이지&lt;/a&gt; 에서 문서화됩니다 . 이 페이지에는 사용 가능한 모든 속성, 메서드 및 경우에 따라 예제가 나열됩니다. 페이지의 또 다른 장점은 해당 표준 문서에 대한 링크를 제공한다는 것입니다. 다음은 &lt;a href=&quot;https://www.w3.org/TR/html52/dom.html#htmlelement&quot;&gt;HTMLElement&lt;/a&gt; 에 대한 W3C 권장 사항에 대한 링크 입니다.</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">주의 사항은 문자열로 초기화 된 열거 형을 역 열거하여 원래 열거 형 멤버 이름을 얻을 수 없다는 것입니다. 다시 말해, 문자열 &lt;code&gt;&quot;Red&quot;&lt;/code&gt; 를 얻기 위해 &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; 를 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">입력 파일의 문자 세트</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">&lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;Options&lt;/code&gt; -&amp;gt; &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; &lt;code&gt;Fonts and Colors&lt;/code&gt; 페이지를 통해 &lt;code&gt;VB XML&lt;/code&gt; 색상 및 글꼴 설정 의 글꼴 및 색상 설정을 변경하여 분류를 추가로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a2f1531f75511fb5bed9929c49deede45519a7c" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;data&lt;/code&gt; is a union of types with discriminant properties, normally called discriminated unions in TypeScript:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 가장 가까운 것은 일반적으로 TypeScript에서 판별 된 공용체라고하는 판별 속성이있는 유형의 공용체입니다.</target>
        </trans-unit>
        <trans-unit id="75bd7d1cbccc678687cdc4d4130a670d13f976d9" translate="yes" xml:space="preserve">
          <source>The closest equivalent to &lt;code&gt;newtype&lt;/code&gt; is a &lt;em&gt;tagged intersection&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;newtype&lt;/code&gt; 에 가장 가까운 것은 &lt;em&gt;태그&lt;/em&gt; 가 &lt;em&gt;지정된 교차점입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">코드 샘플은 믹스 인 역할을하는 두 클래스로 시작합니다. 각 활동이 특정 활동이나 기능에 집중되어 있음을 알 수 있습니다. 나중에 두 기능을 모두 사용하여 새로운 클래스를 만들기 위해 이들을 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">주석 pragma 버전은 다음과 같이 사용될 수 있습니다 (TypeScript 2.8에서).</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">컴파일러는 작업 할 컨텍스트가있을 때 일반적 &lt;code&gt;this&lt;/code&gt; 유형을 알아낼 수 있습니다 . 그렇지 않은 경우, 당신은 명시 적으로 유형을 지정할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 와 &lt;code&gt;@this&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">컴파일러는 &lt;code&gt;manufacturer&lt;/code&gt; 와 &lt;code&gt;model&lt;/code&gt; 이 실제로 &lt;code&gt;Car&lt;/code&gt; 의 속성 인지 확인합니다 . 이 예에서는 몇 가지 새로운 유형 연산자를 소개합니다. 첫 번째는 &lt;code&gt;keyof T&lt;/code&gt; 의 &lt;strong&gt;인덱스 유형 질의 연산자&lt;/strong&gt; . 모든 유형 &lt;code&gt;T&lt;/code&gt; 의 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 알려진 공용 속성 이름 &lt;code&gt;T&lt;/code&gt; 의 통합 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">컴파일러는 &lt;em&gt;제어 흐름 기반 유형 분석&lt;/em&gt; 을 수행하여 변수가 정확히 할당되었는지 확인합니다 . 이 주제에 대한 자세한 내용은 나중에 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">컴파일러는 방출 된 JavaScript에서 각 모듈이 사용되는지 여부를 감지합니다. 오직 타입 주석의 일부로 사용하지 않고 표현으로, 다음에는 결코 식별자 모듈의 경우 &lt;code&gt;require&lt;/code&gt; 호출은 해당 모듈에 대한 방출된다. 사용되지 않은 참조를 제거하면 성능을 최적화 할 수 있으며 해당 모듈을 옵션으로로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">컴파일러는이 속성 할당을 기반으로 생성자 함수를 유추하지만 &lt;code&gt;@constructor&lt;/code&gt; 태그 를 추가하면 더 엄격하고 제안을 더 잘 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">컴파일러는 입력 파일에서 사전 처리 패스를 수행하여 모든 삼중 슬래시 참조 지시문을 해결합니다. 이 과정에서 추가 파일이 컴파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">컴파일러는 파일에있는 참조 태그를 기반으로 출력 파일을 자동으로 정렬합니다. 각 파일을 개별적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">컴파일러는 &lt;code&gt;for..of&lt;/code&gt; 루프에 대한 간단한 &lt;code&gt;for&lt;/code&gt; 루프를 생성합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">컴파일러는 이제 &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; 에서 &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; 하여 툴링 목적으로 './zh/messages'에서 메시지 를 가져 와서 설계 시간 지원을 훼손하지 않고 로케일에 상관없이 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">컴파일러는 찾기 위해 노력할 것입니다 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; 다음과 &lt;code&gt;.d.ts&lt;/code&gt; 적절한 경로를. 특정 파일을 찾을 수 없으면 컴파일러는 &lt;em&gt;앰비언트 모듈 선언을&lt;/em&gt; 찾습니다 . 이것들은 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 선언되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">기본 파일의 구성이 먼저로드 된 다음 상속되는 구성 파일의 구성으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ca65192f8fe43f587bc1a3d765c8a0613852b7" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">기본 파일의 구성이 먼저로드 된 다음 상속하는 구성 파일의 구성으로 재정의됩니다. 구성 파일에서 찾은 모든 상대 경로는 원래 구성 파일을 기준으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">기본 파일의 구성이 먼저로드 된 다음 상속되는 구성 파일의 구성으로 대체됩니다. 원형이 발생하면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">mixin 클래스의 생성자 (있는 경우)는 &lt;code&gt;any[]&lt;/code&gt; 유형의 단일 rest 매개 변수를 가져야하며 스프레드 연산자를 사용하여 해당 매개 변수를 &lt;code&gt;super(...args)&lt;/code&gt; 호출 에서 인수로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">패턴의 핵심 아이디어는 &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; 문으로 모듈에 의해 노출 된 유형에 액세스 할 수 있다는 것입니다. 아래 &lt;code&gt;if&lt;/code&gt; 블록에 표시된 것처럼 모듈 로더는 &lt;code&gt;require&lt;/code&gt; 를 통해 동적으로 호출 됩니다. 이 기능은 기준 제거 최적화를 활용하므로 필요할 때만 모듈을로드 할 수 있습니다. 이 패턴이 작동하려면 &lt;code&gt;import&lt;/code&gt; 를 통해 정의 된 기호 가 형식 위치에서만 사용되어야합니다 (즉, JavaScript로 방출되는 위치에서는 사용되지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">해당 &lt;code&gt;tsconfig.json&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">이 예제에서 &lt;code&gt;Animals&lt;/code&gt; 의 선언 병합 :</target>
        </trans-unit>
        <trans-unit id="70be9c837970cfde212fa7a4b8b2cbb0b2ae3596" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;const enum&lt;/code&gt; behavior is to convert any &lt;code&gt;Album.Something&lt;/code&gt; to the corresponding number literal, and to remove a reference to the enum from the JavaScript completely.</source>
          <target state="translated">기본 &lt;code&gt;const enum&lt;/code&gt; 동작은 &lt;code&gt;Album.Something&lt;/code&gt; 을 해당 숫자 리터럴 로 변환 하고 JavaScript에서 열거 형에 대한 참조를 완전히 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">TypeScript 컴파일러의 기본 동작은 유형 오류가있는 경우 (예 : &lt;code&gt;string&lt;/code&gt; 을 &lt;code&gt;number&lt;/code&gt; 에 할당하려는 경우) .js 파일을 내보내는 것 입니다. 빌드 서버 또는 &quot;깨끗한&quot;빌드의 출력 만 필요한 다른 시나리오에서는 바람직하지 않습니다. 새 플래그 &lt;code&gt;noEmitOnError&lt;/code&gt; 는 오류가있는 경우 컴파일러가 .js 코드를 생성하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">기본 속성은 &lt;code&gt;defaultProps&lt;/code&gt; 속성 유형 에서 유추됩니다 . 명시 적 유형 주석이 추가 된 경우 (예 : &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; 컴파일러는 &lt;code&gt;defaultProps&lt;/code&gt; 유형 에 &lt;code&gt;Props&lt;/code&gt; 의 모든 속성이 포함 되므로 기본값이있는 속성을 식별 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">확정 할당 어설 션은 &lt;code&gt;!&lt;/code&gt; TypeScript의 분석에서 감지 할 수없는 경우에도 변수가 실제로 모든 의도와 목적으로 할당되도록 TypeScript에 릴레이하기 위해 인스턴스 속성 및 변수 선언 뒤에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="2f7101961a50144f9479602939dcc578c0e8ab45" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;super-greeter&amp;rdquo;:</source>
          <target state="translated">&quot;초인&quot;의 정의 :</target>
        </trans-unit>
        <trans-unit id="c352ae274c34e758530bef83a57917473d389588" translate="yes" xml:space="preserve">
          <source>The definition for this method is (I have omitted the &lt;em&gt;deprecated&lt;/em&gt; definition):</source>
          <target state="translated">이 메서드의 정의는 다음과 같습니다 ( &lt;em&gt;사용되지 않는&lt;/em&gt; 정의를 생략했습니다 ).</target>
        </trans-unit>
        <trans-unit id="259a9b27dc71c892950403f889ab6e29b1d0b36a" translate="yes" xml:space="preserve">
          <source>The definition for this method is as follows:</source>
          <target state="translated">이 방법의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">조건부 유형의 분배 특성은 유니온 유형 을 &lt;em&gt;필터링&lt;/em&gt; 하는 데 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d56b3f7891cbe61db5bb0920e006dd158d21b55" translate="yes" xml:space="preserve">
          <source>The downside to using babel is that you don&amp;rsquo;t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.</source>
          <target state="translated">babel 사용의 단점은 TS에서 JS로 전환하는 동안 유형 검사를받지 않는다는 것입니다. 이것은 편집기에서 놓친 유형 오류가 프로덕션 코드에 잠입 할 수 있음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">이 중 이중은 &lt;em&gt;조회 유형&lt;/em&gt; 이라고도하는 &lt;em&gt;인덱싱 된 액세스 &lt;/em&gt;&lt;em&gt;유형&lt;/em&gt; 입니다. 문법적으로는 요소 액세스와 똑같이 보이지만 유형으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 사용 여부를 기억하는 가장 쉬운 방법 은 변수 또는 속성에서 사용 중인지 묻는 것입니다. 변수는 &lt;code&gt;const&lt;/code&gt; 를 사용하고 속성은 &lt;code&gt;readonly&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">인터페이스의 작동 방식을 확인하는 가장 쉬운 방법은 간단한 예제로 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">요소 속성 유형은 JSX에서 속성을 유형 확인하는 데 사용됩니다. 선택적 및 필수 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">요소 인스턴스 유형은 &lt;code&gt;JSX.ElementClass&lt;/code&gt; 에 지정 가능해야하기 때문에 흥미 롭습니다. 그렇지 않으면 오류가 발생합니다. 기본적으로 &lt;code&gt;JSX.ElementClass&lt;/code&gt; 는 &lt;code&gt;{}&lt;/code&gt; 이지만 JSX 사용을 적절한 인터페이스를 따르는 유형으로 제한하도록 기능을 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">생략 부호는 나머지 매개 변수가있는 함수 유형에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4206f608291d0b44e696abdeb0d5bfe75f33351e" translate="yes" xml:space="preserve">
          <source>The emitted JavaScript from TypeScript is:</source>
          <target state="translated">TypeScript에서 내 보낸 JavaScript는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">열거 형 멤버는 상수 열거 형 표현식으로 초기화됩니다. 상수 열거 형 식은 컴파일 타임에 완전히 평가할 수있는 TypeScript 식의 하위 집합입니다. 식은 다음과 같은 경우 상수 열거 형 식입니다.</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsx: react&lt;/code&gt; 컴파일러 옵션 에서 사용하는 정확한 팩토리 기능을 구성 할 수 있습니다. 그것은 중 하나를 사용하여 설정할 수 있습니다 &lt;code&gt;jsxFactory&lt;/code&gt; 명령 줄 옵션 또는 인라인 &lt;code&gt;@jsx&lt;/code&gt; 의 파일 단위로 설정하는 코멘트 프라그를. 예를 들어, 사용자가 설정 한 &lt;code&gt;jsxFactory&lt;/code&gt; 을 에 &lt;code&gt;createElement&lt;/code&gt; 와 , &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 로 방출됩니다 &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; 대신 &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">또한이 예제는 기본 클래스의 메소드를 서브 클래스에 특화된 메소드로 대체하는 방법을 보여줍니다. 여기서 &lt;code&gt;Snake&lt;/code&gt; 와 &lt;code&gt;Horse&lt;/code&gt; 는 &lt;code&gt;Animal&lt;/code&gt; 에서 &lt;code&gt;move&lt;/code&gt; 을 재정의 하는 &lt;code&gt;move&lt;/code&gt; 메소드를 작성 하여 각 클래스에 고유 한 기능을 제공합니다. &lt;code&gt;tom&lt;/code&gt; 이 &lt;code&gt;Animal&lt;/code&gt; 로 선언되어 있지만 값이 &lt;code&gt;Horse&lt;/code&gt; 이므로 &lt;code&gt;tom.move(34)&lt;/code&gt; 를 호출하면 &lt;code&gt;Horse&lt;/code&gt; 의 재정의 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">컴파일러가 중첩 함수 내에서 null을 제거 할 수 없기 때문에이 예제에서는 중첩 함수를 사용합니다 (즉시 호출 된 함수 표현식 제외). 중첩 함수에 대한 모든 호출을 추적 할 수 없기 때문에, 특히 외부 함수에서 호출하면 추적 할 수 없기 때문입니다. 함수가 호출되는 위치를 모르면 본문이 실행될 때 &lt;code&gt;name&lt;/code&gt; 의 유형이 무엇인지 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">접근 자 데코레이터의 표현식은 런타임에 다음 세 가지 인수와 함께 함수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">클래스 데코레이터의 표현식은 런타임에 함수로 호출되며 데코 레이팅 된 클래스의 생성자는 유일한 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">메소드 데코레이터의 표현식은 런타임에 다음 세 개의 인수와 함께 함수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">매개 변수 데코레이터의 표현식은 런타임시 다음 세 개의 인수와 함께 함수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">속성 데코레이터의 표현식은 런타임에 다음 두 개의 인수와 함께 함수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">각 데코레이터의 표현은 위에서 아래로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca9fb0afa1d2d7ae4017f7909cdf00932efdab7" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one.</source>
          <target state="translated">선택한 팩토리는 &lt;code&gt;JSX&lt;/code&gt; 것으로 폴백 하기 전에 JSX 네임 스페이스가 조회 되는 위치 (유형 검사 정보 용) 에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">선택된 팩토리는 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스가 조회 되는 곳 (유형 확인 정보)에 영향을 미쳐 글로벌 네임 스페이스로 되돌아갑니다. 팩토리가 &lt;code&gt;React.createElement&lt;/code&gt; (기본값) 로 정의 된 경우 컴파일러는 글로벌 &lt;code&gt;JSX&lt;/code&gt; 를 확인하기 전에 &lt;code&gt;React.JSX&lt;/code&gt; 를 확인합니다 . 팩토리가 &lt;code&gt;h&lt;/code&gt; 로 정의 되면 글로벌 &lt;code&gt;JSX&lt;/code&gt; 전에 &lt;code&gt;h.JSX&lt;/code&gt; 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">첫 번째 과제는 이제 오류입니다. 실제로 &lt;code&gt;T&lt;/code&gt; 는 함수 유형 매개 변수 위치에서만 사용되므로 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; 에서 반 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">첫 번째 할당은 기본 유형 검사 모드에서 허용되지만 엄격한 기능 유형 모드에서는 오류로 표시됩니다. 직관적으로, 기본 모드는 사운드 일 &lt;em&gt;가능성&lt;/em&gt; 이 있기 때문에 할당을 허용하는 반면, 엄격한 함수 유형 모드는 사운드 가 아닐 &lt;em&gt;수&lt;/em&gt; 있으므로 오류를 발생 시킵니다. 어느 모드에서나 세 번째 할당은 소리 가 &lt;em&gt;나지&lt;/em&gt; 않기 때문에 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">첫 번째는 열거 형 멤버도 유형이된다는 것입니다! 예를 들어, 우리는 특정 회원 수 있다고 말할 수 있습니다 &lt;em&gt;만&lt;/em&gt; 열거 멤버의 값을 가지고 :</target>
        </trans-unit>
        <trans-unit id="f1597b8ab64d75c9fce4d84614baa27283e2feea" translate="yes" xml:space="preserve">
          <source>The first is that the &lt;em&gt;empty type&lt;/em&gt; seems to defy expectation:</source>
          <target state="translated">첫 번째는 &lt;em&gt;빈 유형&lt;/em&gt; 이 기대를 거스르는 것처럼 보인다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82698594e79b48b6fa7cb117ffc18b411c17a2c9" translate="yes" xml:space="preserve">
          <source>The first line of the TypeScript code uses a global variable &lt;code&gt;document&lt;/code&gt;. Inspecting the variable shows it is defined by the &lt;code&gt;Document&lt;/code&gt; interface from the &lt;em&gt;lib.dom.d.ts&lt;/em&gt; file. The code snippet contains calls to two methods, &lt;code&gt;getElementById&lt;/code&gt; and &lt;code&gt;createElement&lt;/code&gt;.</source>
          <target state="translated">TypeScript 코드의 첫 번째 줄은 전역 변수 &lt;code&gt;document&lt;/code&gt; 사용합니다 . 변수를 검사하면 &lt;em&gt;lib.dom.d.ts&lt;/em&gt; 파일 의 &lt;code&gt;Document&lt;/code&gt; 인터페이스에 의해 정의 된 것으로 표시 됩니다. 코드 스 니펫에는 &lt;code&gt;getElementById&lt;/code&gt; 및 &lt;code&gt;createElement&lt;/code&gt; 두 메서드에 대한 호출이 포함되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">첫 번째 줄은 빌드가 완료된 후 Visual Studio에 작업을 'default'로 실행하도록 지시합니다. 또한 Visual Studio에서 빌드를 정리하도록 요청할 때 'clean'작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">속성을 검사하는 첫 번째 단계는 &lt;em&gt;요소 속성 유형&lt;/em&gt; 을 결정하는 것 입니다. 이것은 본질적 요소와 가치 기반 요소간에 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">위의 첫 번째 사항 은 &lt;code&gt;SmartObject&lt;/code&gt; 클래스 에서 &lt;code&gt;Disposable&lt;/code&gt; 및 &lt;code&gt;Activatable&lt;/code&gt; 을 확장하는 대신 &lt;code&gt;SmartObject&lt;/code&gt; 인터페이스 에서 확장 한다는 것입니다 . &lt;a href=&quot;declaration-merging&quot;&gt;선언 병합&lt;/a&gt; 으로 인해 &lt;code&gt;SmartObject&lt;/code&gt; 인터페이스가 &lt;code&gt;SmartObject&lt;/code&gt; 클래스에 혼합됩니다 .</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">첫 번째 유형의 어설 션 서명은 Node의 &lt;code&gt;assert&lt;/code&gt; 기능이 작동 하는 방식을 모델링 합니다. 포함하는 범위의 나머지 부분에 대해 점검중인 조건이 참인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 의 유연성 은 논리적으로 병합되는 물리적 소스 디렉토리 목록을 지정하는 것으로 제한되지 않습니다. 제공된 배열은 존재 여부에 관계없이 임의의 임의의 임의의 디렉토리 이름을 포함 할 수 있습니다. 이를 통해 컴파일러는 조건부 포함 및 프로젝트 특정 로더 플러그인과 같은 정교한 번들링 및 런타임 기능을 안전한 유형으로 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">다음 예는 공변량 위치에서 동일한 유형 변수에 대한 여러 후보가 결합 유형을 유추하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;Greeter&lt;/code&gt; 클래스에 적용된 클래스 데코레이터 ( &lt;code&gt;@sealed&lt;/code&gt; ) 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;Greeter&lt;/code&gt; 클래스 의 메서드에 적용된 메서드 데코레이터 ( &lt;code&gt;@enumerable&lt;/code&gt; ) 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;Greeter&lt;/code&gt; 클래스 멤버의 매개 변수에 적용되는 매개 변수 데코레이터 ( &lt;code&gt;@required&lt;/code&gt; ) 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;Point&lt;/code&gt; 클래스 의 멤버에 적용된 접근 자 데코레이터 ( &lt;code&gt;@configurable&lt;/code&gt; ) 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="78b3414d6c6279a9a7d36fd763a26f60ecb80162" translate="yes" xml:space="preserve">
          <source>The following tags have open issues to support them:</source>
          <target state="translated">다음 태그에는이를 지원하는 미해결 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb147db5e9640faf772e0ff23a000f02eb6a9092" translate="yes" xml:space="preserve">
          <source>The following types have built-in predicates:</source>
          <target state="translated">다음 유형에는 기본 제공 술어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">글로벌 변수 &lt;code&gt;foo&lt;/code&gt; 는 존재하는 위젯 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">전역 변수 &lt;code&gt;myLib&lt;/code&gt; 에는 인사말을 만들기위한 &lt;code&gt;makeGreeting&lt;/code&gt; 함수 와 지금까지 인사말 수를 나타내는 &lt;code&gt;numberOfGreetings&lt;/code&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">이 가이드는 다음 섹션으로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a089c228c5ebe31ca69e3f47fd0070706f6094d2" translate="yes" xml:space="preserve">
          <source>The handbook is split into two sections:</source>
          <target state="translated">핸드북은 두 부분으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="604cbcf9b1655f8dee840e0d141897f7e64d6d7e" translate="yes" xml:space="preserve">
          <source>The handbook reference is built to provide a richer understanding of how a particular part of TypeScript works. You can read it top-to-bottom, but each section aims to provide a deeper explanation of a single concept - meaning there is no aim for continuity.</source>
          <target state="translated">핸드북 참조는 TypeScript의 특정 부분이 작동하는 방식에 대한 풍부한 이해를 제공하기 위해 작성되었습니다. 위에서부터 아래까지 읽을 수 있지만 각 섹션은 단일 개념에 대한 더 깊은 설명을 제공하는 것을 목표로합니다. 즉, 연속성에 대한 목표가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">&lt;code&gt;getDisplayName&lt;/code&gt; 및 &lt;code&gt;getLength&lt;/code&gt; 는 쉽게 참조 할 수있는 유형을 사용 하므로 추론 프로세스는 매우 간단합니다 . 그러나 TypeScript 3.3 및 이전 버전에서는 다른 일반 함수를 전달할 때 &lt;code&gt;compose&lt;/code&gt; 와 같은 일반 함수 가 제대로 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">함수의 유추 된 리턴 유형은 함수 내에서 로컬로 선언 된 유형일 수 있습니다. 함수 호출자가 이러한 로컬 유형을 참조하는 것은 불가능하지만 물론 구조적으로 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78b1c8f9ed0f4d721027df616536d2627988df99" translate="yes" xml:space="preserve">
          <source>The inferred value for &lt;code&gt;rootDir&lt;/code&gt; is the longest common path of all non-declaration input files, which in this case is &lt;code&gt;core/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 의 유추 된 값 은 모든 비 선언 입력 파일의 가장 긴 공통 경로이며,이 경우에는 &lt;code&gt;core/&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">인터페이스 선언을 사용하여 앰비언트 클래스 선언의 인스턴스 측을 확장 할 수 있습니다. 클래스 생성자 객체는 수정되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 리턴 하지 않는 함수의 의도는 결코 리턴 하지 않는 것입니다. 예외가 발생했거나 중지 오류 조건이 발생했거나 프로그램이 종료되었음을 나타냅니다. 예를 들어 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt; &lt;code&gt;@types/node&lt;/code&gt; &lt;/a&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; 는 &lt;code&gt;never&lt;/code&gt; 반환하도록 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">&lt;code&gt;LabeledValue&lt;/code&gt; 인터페이스 는 이전 예제의 요구 사항을 설명하는 데 사용할 수있는 이름입니다. 여전히 &lt;code&gt;string&lt;/code&gt; 유형의 &lt;code&gt;label&lt;/code&gt; 이라는 단일 특성이 있음을 나타냅니다 . &lt;code&gt;printLabel&lt;/code&gt; 에 전달하는 객체가 다른 언어에서와 같이이 인터페이스를 구현 한다고 명시 적으로 말할 필요는 없습니다 . 여기서 중요한 것은 모양뿐입니다. 함수에 전달한 객체가 나열된 요구 사항을 충족하면 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">주요 차이점은 구문이 아니라 의미론에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">튜플 유형의 마지막 요소는 &lt;code&gt;...X&lt;/code&gt; 형식의 나머지 요소 일 수 있습니다. 여기서 &lt;code&gt;X&lt;/code&gt; 는 배열 유형입니다. 나머지 요소는 튜플 유형이 개방형이며 배열 요소 유형의 추가 요소가 0 개 이상있을 수 있음을 나타냅니다. 예를 들어, &lt;code&gt;[number, ...string[]]&lt;/code&gt; 은 &lt;code&gt;number&lt;/code&gt; 요소와 임의의 수의 &lt;code&gt;string&lt;/code&gt; 요소 가있는 튜플을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="ea7d1078a9be532038ef2deef32790daf490bb8c" translate="yes" xml:space="preserve">
          <source>The last line of the code snippet is &lt;code&gt;app?.appendChild(p)&lt;/code&gt;. The previous, &lt;code&gt;document.getElementById&lt;/code&gt; , section detailed that the &lt;em&gt;optional chaining&lt;/em&gt; operator is used here because &lt;code&gt;app&lt;/code&gt; can potentially be null at runtime. The &lt;code&gt;appendChild&lt;/code&gt; method is defined by:</source>
          <target state="translated">코드 조각의 마지막 줄은 &lt;code&gt;app?.appendChild(p)&lt;/code&gt; 입니다. 이전 &lt;code&gt;document.getElementById&lt;/code&gt; 섹션에서는 &lt;code&gt;app&lt;/code&gt; 이 런타임에 잠재적으로 null 일 수 있기 때문에 여기 에서 &lt;em&gt;선택적 연결&lt;/em&gt; 연산자가 사용됨을 자세히 설명했습니다 . &lt;code&gt;appendChild&lt;/code&gt; 방법에 의해 정의된다 :</target>
        </trans-unit>
        <trans-unit id="5a1fa816d66a94a39a64dba4ddbbaa3fb384695f" translate="yes" xml:space="preserve">
          <source>The last line of the previous code sample would raise an error in TypeScript, but it doesn&amp;rsquo;t by default in a JS project. To enable errors in your JavaScript files add: &lt;code&gt;// @ts-check&lt;/code&gt; to the first line in your &lt;code&gt;.js&lt;/code&gt; files to have TypeScript raise it as an error.</source>
          <target state="translated">이전 코드 샘플의 마지막 줄은 TypeScript에서 오류를 발생 시키지만 JS 프로젝트에서는 기본적으로 발생하지 않습니다. JavaScript 파일에서 오류를 활성화하려면 &lt;code&gt;// @ts-check&lt;/code&gt; 를 &lt;code&gt;.js&lt;/code&gt; 파일 의 첫 번째 줄에 추가하여 TypeScript가 오류를 발생 시키도록합니다.</target>
        </trans-unit>
        <trans-unit id="3425f6446014efd7d54ccc807ba0bd462046777c" translate="yes" xml:space="preserve">
          <source>The latter style is more common but both are allowed, even in the same file.</source>
          <target state="translated">후자의 스타일이 더 일반적이지만 동일한 파일에서도 둘 다 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">선언 파일의 레이아웃은 라이브러리의 레이아웃을 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">그런 다음 라이브러리를 모듈 내에서 가져 오기로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">아래 목록은 JSDoc 어노테이션을 사용하여 JavaScript 파일에 유형 정보를 제공 할 때 현재 지원되는 구문을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">오류 메시지 (예 : en-us)를 표시하는 데 사용되는 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">이 핸드북의 대부분은 &lt;code&gt;let&lt;/code&gt; 선언을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d5361e797afb54e7fafd11ab7165d6157098d98b" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under &lt;code&gt;node_modules&lt;/code&gt; and load JavaScript files.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 에서 검색 하고 JavaScript 파일을로드 할 최대 종속성 깊이 입니다.</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">node_modules에서 검색하고 JavaScript 파일을로드하기위한 최대 종속성 깊이. &lt;code&gt;--allowJs&lt;/code&gt; 에만 적용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="617a4a49e4615a56e38ae287aca4e940a80853ed" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at &lt;a href=&quot;https://jsdoc.app&quot;&gt;jsdoc.app&lt;/a&gt;. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">의미는 일반적으로 &lt;a href=&quot;https://jsdoc.app&quot;&gt;jsdoc.app에&lt;/a&gt; 제공된 태그의 의미와 동일하거나 상위 집합 입니다. 아래 코드는 차이점을 설명하고 각 태그의 몇 가지 사용 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">의미는 일반적으로 usejsdoc.org에 제공된 태그의 의미와 동일하거나 수퍼 세트입니다. 아래 코드는 차이점을 설명하고 각 태그의 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="942184e9d11609161fd758335e2cb598f79fd707" translate="yes" xml:space="preserve">
          <source>The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.</source>
          <target state="translated">믹스 인 패턴은 코드 흐름 분석을 통해 TypeScript 컴파일러 내에서 기본적으로 지원됩니다. 기본 지원의 가장자리를 칠 수있는 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">모듈 이름은 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; 모듈 지정자와 동일한 방식으로 해결 됩니다. 자세한 내용은 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 을 참조하십시오. 그런 다음 기능 보강의 선언은 마치 원본과 동일한 파일에 선언 된 것처럼 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ef072c2703c60524da107c05a2dfe78d02a391" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than TypeScript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascript의 모듈 지원은 TypeScript의 모듈 지원보다 구문 적으로 훨씬 관대합니다. 대부분의 할당 및 선언 조합이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Javascript의 모듈 지원은 Typescript의 모듈 지원보다 구문 상 훨씬 더 관대합니다. 대부분의 할당 및 선언 조합이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">가장 기본적인 데이터 유형은 JavaScript 및 TypeScript가 &lt;code&gt;boolean&lt;/code&gt; 값을 호출하는 단순 true / false 값입니다.</target>
        </trans-unit>
        <trans-unit id="a03cd6c7e32b9f93ac936ffc0acd7964734f63ea" translate="yes" xml:space="preserve">
          <source>The most common case for learning how .d.ts files work is that you&amp;rsquo;re typing an npm package with no types. In that case, you can jump straight to &lt;a href=&quot;templates/module-d-ts&quot;&gt;Modules .d.ts&lt;/a&gt;.</source>
          <target state="translated">.d.ts 파일의 작동 방식을 배우는 가장 일반적인 경우는 유형이없는 npm 패키지를 입력하는 것입니다. 이 경우 &lt;a href=&quot;templates/module-d-ts&quot;&gt;Modules .d.ts로&lt;/a&gt; 바로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7640814a5033d876fc4ba4a5004fadadb312ca3" translate="yes" xml:space="preserve">
          <source>The most common kinds of errors that programmers write can be described as type errors: a certain kind of value was used where a different kind of value was expected. This could be due to simple typos, a failure to understand the API surface of a library, incorrect assumptions about runtime behavior, or other errors. The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).</source>
          <target state="translated">프로그래머가 작성하는 가장 일반적인 종류의 오류는 유형 오류로 설명 할 수 있습니다. 다른 종류의 값이 예상되는 곳에 특정 종류의 값이 사용되었습니다. 이는 단순한 오타, 라이브러리의 API 표면 이해 실패, 런타임 동작에 대한 잘못된 가정 또는 기타 오류 때문일 수 있습니다. TypeScript의 목표는 JavaScript 프로그램의 정적 유형 검사기입니다. 즉, 코드가 실행되기 전에 실행되고 (정적) 프로그램 유형이 올바른지 (유형 검사 됨) 확인하는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="a9f7f6f667f2904bbc6c5b01fab0ba1c74724d50" translate="yes" xml:space="preserve">
          <source>The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export. Typescript can handle this for you, if you have &lt;a href=&quot;https://www.typescriptlang.org/tsconfig/#esModuleInterop&quot;&gt;&lt;code&gt;&quot;esModuleInterop&quot;: true&lt;/code&gt;&lt;/a&gt; in tsconfig.json.</source>
          <target state="translated">여기서 가장 일반적인 솔루션 은 호출 가능 / 구성 가능한 객체에 대한 &lt;code&gt;default&lt;/code&gt; 내보내기 를 정의하는 것입니다. 모듈 로더는 일반적으로이 상황을 자동으로 감지하고 최상위 오브젝트를 &lt;code&gt;default&lt;/code&gt; 내보내기로 대체합니다 . tsconfig.json에 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig/#esModuleInterop&quot;&gt; &lt;code&gt;&quot;esModuleInterop&quot;: true&lt;/code&gt; &lt;/a&gt; 있는 경우 Typescript가이를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">이 기능의 가장 강력한 결과는 약간 미묘 할 수 있습니다. TypeScript 3.7을 사용하면 JSDoc 주석 JavaScript로 라이브러리를 작성하고 TypeScript 사용자를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">동기 부여 예제는 콜백을 수행하여 예측 가능하지만 (프로그래머에게는) 알 수없는 (타입 시스템에는) 많은 인수로 호출하는 함수의 공통 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">모듈 기능 보강의 이름은 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 선언 에서 모듈 지정자와 동일한 규칙 세트를 사용하여 분석됩니다 . 모듈 기능 보강의 선언은 동일한 파일에서 선언 된 것과 동일한 방식으로 기존 선언과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">회원의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">새로운 &lt;code&gt;--showConfig&lt;/code&gt; 플래그</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">새로운 &lt;code&gt;--strict&lt;/code&gt; 컴파일러 옵션은 여러 유형 검사 옵션의 권장 설정을 나타냅니다. 특히 &lt;code&gt;--strict&lt;/code&gt; 를 지정하면 다음 옵션을 모두 지정하는 것과 일치하며 나중에 더 많은 옵션이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">새로운 &lt;code&gt;amd-dependency name&lt;/code&gt; 속성을 사용하면 amd- 종속성에 대한 선택적 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">새로운 &lt;code&gt;amd-module name&lt;/code&gt; 태그를 사용하면 선택적 모듈 이름을 컴파일러에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">클래스 의 새로운 &lt;code&gt;protected&lt;/code&gt; 수정자는 C ++, C # 및 Java와 같은 익숙한 언어에서와 같이 작동합니다. 클래스 의 &lt;code&gt;protected&lt;/code&gt; 멤버는 클래스가 선언 된 클래스의 서브 클래스에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">이제 TypeScript에서 지원되는 새로운 ES6 키워드 &lt;code&gt;let&lt;/code&gt; 은보다 직관적 인 &quot;블록&quot;의미로 변수를 선언합니다. &lt;code&gt;let&lt;/code&gt; 변수는 선언 이후 언급 될 수 있으며,이 정의 된 구문 블록 범위된다 :</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">새로운 팩토리 이름은 &lt;code&gt;createElement&lt;/code&gt; 및 &lt;code&gt;__spread&lt;/code&gt; 함수 를 호출하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">새로운 기능은 엄격한 null 확인 모드와 일반 유형 확인 모드에서 모두 사용할 수 있도록 설계되었습니다. 특히 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 유형은 일반 유형 검사 모드 (다른 모든 유형의 하위 유형이므로)에서 공용체 유형에서 자동으로 지워집니다 &lt;code&gt;!&lt;/code&gt; 널이 아닌 어설 션 표현식 연산자는 허용되지만 일반 유형 검사 모드에는 영향을 미치지 않습니다. 따라서 널 및 정의되지 않은 인식 유형을 사용하도록 업데이트 된 선언 파일은 이전 버전과의 호환성을 위해 일반 유형 검사 모드에서 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="translated">The new handbook which is a work in progress.</target>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">새로운 구현은 또한 tsserver에서 시청 성능을 향상시킵니다. 변경 이벤트에보다 빠르게 응답하도록 감시자 논리가 완전히 다시 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">새 모듈 &lt;code&gt;ProgrammerCalculator&lt;/code&gt; 는 원래 &lt;code&gt;Calculator&lt;/code&gt; 모듈 과 유사한 API 모양을 내보내지만 원래 모듈의 개체는 보강하지 않습니다. ProgrammerCalculator 클래스에 대한 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">새로운 놀이터는 이제 다음을 포함한 많은 새로운 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">나이틀리는 사용할 수 있습니다 &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">야간 빌드에는 현재 전체 플러그인 설정이 포함되어 있지 않지만 야간에 설치 프로그램을 게시하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">디렉토리가 주어진 경우 이전 동작은 여전히 ​​동일합니다. 컴파일러는 &lt;code&gt;tsconfig.json&lt;/code&gt; 디렉토리에서 파일을 찾으려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">스프레드 작업을 지정하는 순서에 따라 결과 개체에서 어떤 속성이 만들어 질지 결정됩니다. 나중에 속성은 이전에 생성 된 속성보다 &quot;확실&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">함수의 매개 변수 목록에있는 매개 변수의 서수 색인입니다.</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">다른 변화는 열거 형 자체가 효과적으로 각 열거 형 멤버 의 &lt;em&gt;합집합&lt;/em&gt; 이된다는 것 입니다. 우리는 아직 &lt;a href=&quot;advanced-types#union-types&quot;&gt;유니온 유형에&lt;/a&gt; 대해 논의 하지는 않았지만 유니온 열거 형을 사용하면 유형 시스템이 열거 형 자체에 존재하는 정확한 값 세트를 알고 있다는 사실을 활용할 수 있다는 것만 알면됩니다. 이 때문에 TypeScript는 값을 잘못 비교하는 어리석은 버그를 잡을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a3f850fae27464de0a91f4fe484b577d056f476" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">또 다른 변경 사항은 열거 형 형식 자체가 각 열거 형 멤버 의 &lt;em&gt;합집합&lt;/em&gt; 이된다는 것 입니다. 공용체 열거 형을 사용하면 유형 시스템이 열거 형 자체에 존재하는 정확한 값 집합을 알고 있다는 사실을 활용할 수 있습니다. 이 때문에 TypeScript는 값을 잘못 비교하는 버그를 잡을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">TypeScript에서 지원되는 다른 새로운 ES6 선언 유형은 &lt;code&gt;const&lt;/code&gt; 입니다. &lt;code&gt;const&lt;/code&gt; 변수에 할당 할 수 없습니다 수 있으며,이 선언되는 경우 초기화해야합니다. 초기화 후 값을 변경하지 않으려는 선언에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">다른 유형의 어설 션 서명은 조건을 확인하지 않고 대신 특정 변수 나 속성의 유형이 다르다는 것을 TypeScript에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="26c97f765ee648970cd74d22ecbbec1a076a2371" translate="yes" xml:space="preserve">
          <source>The other version is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">다른 버전은 &quot;angle-bracket&quot;구문입니다.</target>
        </trans-unit>
        <trans-unit id="3c65d0a0ca356ee8f50f381bfb9e081e37ee13c6" translate="yes" xml:space="preserve">
          <source>The pattern relies on using Generics with class inheritance to extend a base class. TypeScript&amp;rsquo;s best mixin support is done via the class expression pattern. You can read more about how this pattern works in &lt;a href=&quot;https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;JavaScript here&lt;/a&gt;.</source>
          <target state="translated">패턴은 클래스 상속과 함께 Generics를 사용하여 기본 클래스를 확장합니다. TypeScript의 최상의 믹스 인 지원은 클래스 표현식 패턴을 통해 수행됩니다. 이 패턴이 &lt;a href=&quot;https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/&quot;&gt;JavaScript에서&lt;/a&gt; 작동하는 방법에 대한 자세한 내용은 여기 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">널리 사용되는 라이브러리 D3은 &lt;code&gt;d3&lt;/code&gt; 이라는 전역 객체에서 기능을 정의합니다 . 이 라이브러리는 모듈 로더 대신 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 통해로드되므로 선언시 네임 스페이스를 사용하여 모양을 정의합니다. TypeScript 컴파일러가이 형태를보기 위해 앰비언트 네임 스페이스 선언을 사용합니다. 예를 들어 다음과 같이 작성을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97b95eb4ae7f59dc40bbd1fbc533cb87a64d1c85" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the TypeScript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">앞의 두 유형은 TypeScript 유형 &lt;code&gt;{ [x: string]: number }&lt;/code&gt; 및 &lt;code&gt;{ [x: number]: any }&lt;/code&gt; 합니다. 컴파일러는 두 구문을 모두 이해합니다.</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">앞의 두 유형은 Typescript 유형 &lt;code&gt;{ [x: string]: number }&lt;/code&gt; 및 &lt;code&gt;{ [x: number]: any }&lt;/code&gt; . 컴파일러는 두 구문을 모두 이해합니다.</target>
        </trans-unit>
        <trans-unit id="c60fafa2ef6625ee2c00e943de3aab278fabf81d" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project.</source>
          <target state="translated">a의 존재 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 디렉토리에있는 파일은 디렉토리가 타이프 프로젝트의 루트 인 것을 나타냅니다. &lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일은 루트 파일과 프로젝트를 컴파일하는 데 필요한 컴파일러 옵션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">디렉토리에 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 이 있으면 디렉토리가 TypeScript 프로젝트의 루트임을 나타냅니다. &lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일은 루트 파일과 프로젝트를 컴파일하는 데 필요한 컴파일러 옵션을 지정합니다. 프로젝트는 다음 방법 중 하나로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="a2cfab90b0c3ba6c1eea59f4039e7816d4601aa6" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; in the above example is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;padLeft&lt;/code&gt; 의 문제점 은 &lt;code&gt;padding&lt;/code&gt; 매개 변수가 &lt;code&gt;any&lt;/code&gt; 로 입력 된다는 것 입니다. 즉, &lt;code&gt;number&lt;/code&gt; 도 &lt;code&gt;string&lt;/code&gt; 도 아닌 인수로 호출 할 수 있지만 TypeScript는 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">&lt;code&gt;padLeft&lt;/code&gt; 의 문제점 은 &lt;code&gt;padding&lt;/code&gt; 매개 변수가 &lt;code&gt;any&lt;/code&gt; 로 입력 된다는 것 입니다. 즉, &lt;code&gt;number&lt;/code&gt; 나 &lt;code&gt;string&lt;/code&gt; 이 아닌 인수로 호출 할 수 있지만 TypeScript는 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="25342fc4c0a8b53d44f277b4df381a59c493566a" translate="yes" xml:space="preserve">
          <source>The process of going from an infinite number of potential cases (there are an infinite number of possible string values) to a smaller, finite number of potential case (in &lt;code&gt;helloWorld&lt;/code&gt;&amp;rsquo;s case: 1) is called narrowing.</source>
          <target state="translated">무한한 수의 잠재적 케이스 (가능한 문자열 값의 무한대)에서 더 작고 유한 한 수의 잠재적 케이스 ( &lt;code&gt;helloWorld&lt;/code&gt; 의 경우 : 1) 로 이동하는 프로세스를 축소라고합니다.</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">이러한 패키지 이름을 확인하는 프로세스는 &lt;code&gt;import&lt;/code&gt; 문 에서 모듈 이름을 확인하는 프로세스와 유사 합니다. 트리플 슬래시 참조 형식 지시문을 쉽게 생각할 수있는 방법 은 선언 패키지 의 &lt;code&gt;import&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">프로세스는 &lt;em&gt;루트 파일&lt;/em&gt; 세트로 시작 &lt;em&gt;합니다&lt;/em&gt; . 이들은 명령 행 또는 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 의 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 목록에 지정된 파일 이름 입니다. 이 루트 파일은 지정된 순서대로 전처리됩니다. 파일이 목록에 추가되기 전에 파일의 모든 삼중 슬래시 참조가 처리되고 대상이 포함됩니다. 트리플 슬래시 참조는 파일에서 본 순서대로 깊이 우선적으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="1064046bee0ce7e01c8bf16c1b03dac0a5d9f8ee" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;ldquo;.</source>
          <target state="translated">프로그램은 &quot;Hello from TypeScript!&quot;를 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">프로그램은 &quot;Hello from TypeScript!&quot;를 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">이 안내서의 목적은 고품질 정의 파일을 작성하는 방법을 가르쳐주기위한 것입니다. 이 안내서는 일부 API에 대한 문서와 해당 API의 샘플 사용법 및 해당 선언 작성 방법을 설명하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">여기서 참조 태그를 사용하면 앰비언트 모듈에 대한 선언이 포함 된 선언 파일을 찾을 수 있습니다. 이것은 여러 TypeScript 샘플이 사용 하는 &lt;code&gt;node.d.ts&lt;/code&gt; 파일이 사용되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">이 섹션의 나머지 부분에서는 &lt;code&gt;typescript@next&lt;/code&gt; 가 이미 설치되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">결과는 제공 한 것과 동일한 JavaScript를 포함하는 &lt;code&gt;greeter.js&lt;/code&gt; 파일 이됩니다. JavaScript 앱에서 TypeScript를 사용하여 시작되었습니다!</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">병합 된 &lt;code&gt;Document&lt;/code&gt; 의 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">속성의 결과 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">그런 다음 결과는 위에서 아래로 함수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6d00e7101737114bac2225ce67379aba61f8af21" translate="yes" xml:space="preserve">
          <source>The return type of a call uses the contextual type for inferences, so the compiler infers that &lt;code&gt;T={ inference: string }&lt;/code&gt;.</source>
          <target state="translated">호출의 반환 유형은 추론에 컨텍스트 유형을 사용하므로 컴파일러는 &lt;code&gt;T={ inference: string }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">매개 변수 데코레이터의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 의 오른쪽 은 생성자 함수 여야하며 TypeScript는 다음과 같이 좁 힙니다.</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">이러한 &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;각주에&lt;/a&gt; 동일한 각주가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e77f3244150969c173e8b081e427e7953f3f7fd4" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;awesome-typescript-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">동일은 간다 &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;멋진-타이프 라이터 로더&lt;/a&gt; , 웹팩 또 다른 타이프 라이터 로더. &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;여기&lt;/a&gt; 에서 둘의 차이점에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">동일은 간다 &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;TS-로더&lt;/a&gt; , 웹팩 또 다른 타이프 라이터 로더. 두 가지 차이점에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">선택적 속성에 대해서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">함수 호출 인수를 확인할 때 동일한 할당 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">빈 배열에 대해서도 같은 종류의 추적이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">통상 튜플로부터 연장 종류 것과 같은 방식으로 &lt;code&gt;Array&lt;/code&gt; - 유형의 요소 터플 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; , ... &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 로부터 연장 &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; 튜플로부터 연장 종류 &lt;code&gt;ReadonlyArray&lt;/code&gt; . 그래서 &lt;code&gt;readonly&lt;/code&gt; 요소 튜플 &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ,&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; 은 &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; 에 없는 필수 두 번째 매개 변수가 있으므로 두 번째 지정은 오류 이므로 지정이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">두 번째 블록은 다음과 같은 이름 의미를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bb7b2f9c2d9be074838810a47661fb544c2c7a54" translate="yes" xml:space="preserve">
          <source>The second example failed because the array&amp;rsquo;s &lt;code&gt;find&lt;/code&gt; function looks a bit like this simplification:</source>
          <target state="translated">두 번째 예제는 배열의 &lt;code&gt;find&lt;/code&gt; 함수가 다음과 같이 단순화 되었기 때문에 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">두 번째 방법은 컴파일러가 철저한 검사를 위해 사용하는 &lt;code&gt;never&lt;/code&gt; 유형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">제 연산자는 &lt;code&gt;T[K]&lt;/code&gt; 는 &lt;strong&gt;인덱스 액세스 연산자&lt;/strong&gt; . 여기서 형식 구문은 식 구문을 반영합니다. 이는 &lt;code&gt;person['name']&lt;/code&gt; 이 &lt;code&gt;Person['name']&lt;/code&gt; 유형을 가짐을 의미 &lt;code&gt;string&lt;/code&gt; . 이 예에서는 string 입니다. 그러나 인덱스 유형 쿼리와 마찬가지로 &lt;code&gt;T[K]&lt;/code&gt; 를 일반적인 컨텍스트에서 사용할 수 있습니다.이 컨텍스트는 실제 성능이 실현되는 곳입니다. 타입 변수 &lt;code&gt;K extends keyof T&lt;/code&gt; 하는지 확인하면 됩니다. 다음은 &lt;code&gt;getProperty&lt;/code&gt; 라는 함수가있는 또 다른 예입니다 .</target>
        </trans-unit>
        <trans-unit id="395e59dd3d587260540f24beb9cdd8492f3b1ca0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;taxi[&quot;manufacturer&quot;]&lt;/code&gt; has the type &lt;code&gt;Car[&quot;manufacturer&quot;]&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">제 연산자는 &lt;code&gt;T[K]&lt;/code&gt; 는 &lt;strong&gt;인덱스 액세스 연산자&lt;/strong&gt; . 여기서 유형 구문은 표현식 구문을 반영합니다. 즉, &lt;code&gt;taxi[&quot;manufacturer&quot;]&lt;/code&gt; 는 &lt;code&gt;Car[&quot;manufacturer&quot;]&lt;/code&gt; 유형을 갖습니다 . 이 예에서는 &lt;code&gt;string&lt;/code&gt; 입니다. 그러나 인덱스 유형 쿼리와 마찬가지로 일반 컨텍스트에서 &lt;code&gt;T[K]&lt;/code&gt; 를 사용할 수 있습니다. 이 경우 실제 성능이 실현됩니다. 타입 변수 &lt;code&gt;K extends keyof T&lt;/code&gt; 하는지 확인하기 만하면 됩니다. &lt;code&gt;getProperty&lt;/code&gt; 라는 함수가있는 또 다른 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">두 번째 부분은 반환 유형입니다. 매개 변수와 반환 유형 사이에 굵은 화살표 ( &lt;code&gt;=&amp;gt;&lt;/code&gt; ) 를 사용하여 반환 유형이 어느 것인지 명확하게 알 수 있습니다 . 앞에서 언급했듯이 이것은 함수 유형의 필수 부분이므로 함수가 값을 반환하지 않으면 &lt;code&gt;void&lt;/code&gt; 을 사용 하지 않고 void 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ee75b3015ae814b5df851e6a3b58e1c66c58fec3" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using an arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">두 번째 부분은 반환 유형입니다. 매개 변수와 반환 유형 사이에 화살표 ( &lt;code&gt;=&amp;gt;&lt;/code&gt; ) 를 사용하여 반환 유형이 무엇인지 명확히 합니다. 앞서 언급했듯이 이것은 함수 유형의 필수 부분이므로 함수가 값을 반환하지 않으면 값 을 그대로 두는 대신 &lt;code&gt;void&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">두 번째 이유는 소비자가 TypeScript의 &quot;엄격한 null 검사&quot;기능을 사용하기 때문입니다. 지정되지 않은 매개 변수는 &lt;code&gt;undefined&lt;/code&gt; 는 JavaScript에서 정의되지 않은 일반적 으로 선택적 인수를 사용 하여 명시 적 &lt;code&gt;undefined&lt;/code&gt; 함수를 함수 에 전달하는 것이 좋습니다. 예를 들어이 코드는 엄격한 null에서 정상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ddaeafe60f623f16494e16010fd0027a89f657dc" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;mdash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">두 번째 방법은 아마도 가장 일반적인 방법 일 것입니다. 여기서 우리는 &lt;em&gt;타입 인자 추론&lt;/em&gt; 을 사용 &lt;em&gt;합니다.&lt;/em&gt; 즉, 우리 가 전달하는 인자의 타입에 따라 컴파일러가 자동으로 &lt;code&gt;T&lt;/code&gt; 값을 설정하기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">두 번째 방법은 아마도 가장 일반적 일 것입니다. 여기서 우리는&lt;em&gt; 형식 인수 유추를 합니다.&lt;/em&gt; 즉, 전달하는 인수의 유형에 따라 컴파일러가 &lt;code&gt;T&lt;/code&gt; 값을 자동으로 설정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">두 번째 방법은 일반적인 배열 유형 인 &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc5448e0198755908cad47574593cb637412ed51" translate="yes" xml:space="preserve">
          <source>The shape-matching only requires a subset of the object&amp;rsquo;s fields to match.</source>
          <target state="translated">모양 일치에는 일치시킬 개체 필드의 하위 집합 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">가장 간단한 형태의 소멸은 배열 소멸 할당입니다.</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">가장 단순하고 가장 일반적인 선언 병합 유형은 인터페이스 병합입니다. 가장 기본적인 수준에서, 병합은 두 선언의 멤버를 동일한 이름의 단일 인터페이스에 기계적으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">위의 스 니펫은 형식 유추의 예이며 핸드북에서 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ecda9eae0951be3e74181af1517711ce10156b9c" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;ESNext&lt;/code&gt; value refers to the highest version your version of TypeScript supports. This setting should be used with caution, since it doesn&amp;rsquo;t mean the same thing between different TypeScript versions and can make upgrades less predictable.</source>
          <target state="translated">특수 &lt;code&gt;ESNext&lt;/code&gt; 값은 TypeScript 버전이 지원하는 가장 높은 버전을 나타냅니다. 이 설정은 다른 TypeScript 버전간에 동일한 의미가 아니며 업그레이드를 예측하기 어렵게 만들 수 있으므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">스프레드 연산자도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">스프레드 연산자는 해체와 반대입니다. 배열을 다른 배열이나 다른 개체로 펼칠 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="347a245a04ce2dd0b84ae05cdc6937a6bfd2e8ec" translate="yes" xml:space="preserve">
          <source>The strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality.</source>
          <target state="translated">재귀 적 파일 감시 기능이없는 시스템에서 전체 디렉토리 트리를 감시하는 방법에 대한 전략입니다.</target>
        </trans-unit>
        <trans-unit id="ed87e7da393e9ebf4b65dddbe2b2c6508ed02ce5" translate="yes" xml:space="preserve">
          <source>The strategy for how individual files are watched.</source>
          <target state="translated">개별 파일을 감시하는 방법에 대한 전략입니다.</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">컴파일러가 따르는 전략</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">엄격한 검사는 메소드 또는 생성자 선언에서 시작된 &lt;em&gt;것을 제외한&lt;/em&gt; 모든 함수 유형에 적용됩니다 . 제네릭 클래스와 인터페이스 (예 : &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; )가 대부분 공변 적으로 계속 연관 되도록하기 위해 메소드가 특별히 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">반복 할 속성 이름이 포함 된 문자열 리터럴 union &lt;code&gt;Keys&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">지원되는 glob 와일드 카드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">구문은 &lt;code&gt;for .. in&lt;/code&gt; 가있는 인덱스 서명의 구문과 유사합니다 . 세 부분이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">이전에 C # 또는 Java를 사용한 적이 있다면 구문이 익숙해 보일 것입니다. 우리는 새로운 클래스 &lt;code&gt;Greeter&lt;/code&gt; 를 선언합니다 . 이 클래스에는 세 개의 멤버가 있습니다 : &lt;code&gt;greeting&lt;/code&gt; 이라는 속성 , 생성자 및 메서드 &lt;code&gt;greet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt; 템플리트 파일 은 예제 라이브러리 &lt;code&gt;myLib&lt;/code&gt; 를 정의합니다 . &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;이름 충돌 방지&amp;rdquo;각주&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4661397a216a4756287dc9945d770b9dd77b8574" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">템플릿 파일 &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt; 는 예제 라이브러리 &lt;code&gt;myLib&lt;/code&gt; 를 정의합니다 . &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&quot;이름 충돌 방지&quot;각주를&lt;/a&gt; 반드시 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">테스트 파일은 구현 파일을 가져오고 몇 가지 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">세 개의 인터페이스가 병합되어 단일 선언을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">여기서 &lt;code&gt;Shapes&lt;/code&gt; 최상위 모듈은 이유없이 &lt;code&gt;Triangle&lt;/code&gt; 과 &lt;code&gt;Square&lt;/code&gt; 을 마무리합니다 . 이것은 모듈 소비자에게 혼란스럽고 성가신 일입니다.</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">가장 큰 두 가지 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">이 두 가지 옵션은 더 많이 남아있었습니다. 모든 파일에 헬퍼를 묶는 것은 패키지 크기를 작게 유지하려는 고객에게는 어려움이었습니다. 헬퍼를 포함하지 않았기 때문에 고객은 자신의 헬퍼 라이브러리를 유지해야했습니다.</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">두 샘플은 동일합니다. 하나를 다른 것보다 사용하는 것이 대부분 선호하는 선택입니다. 그러나 JSX와 함께 TypeScript를 사용할 &lt;code&gt;as&lt;/code&gt; -style 어설 션 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">위의 유형 은 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;U&lt;/code&gt; 에 할당 할 수 있는 경우 유형이 &lt;code&gt;X&lt;/code&gt; 이고, 그렇지 않으면 유형이 &lt;code&gt;Y&lt;/code&gt; 임을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">타입 체커는 &lt;code&gt;printLabel&lt;/code&gt; 호출을 확인합니다 . &lt;code&gt;printLabel&lt;/code&gt; 의 기능은 전달 된 개체라는 속성이 있어야 하나의 매개 변수가 &lt;code&gt;label&lt;/code&gt; 형식의 &lt;code&gt;string&lt;/code&gt; . 우리의 객체는 실제로 이것보다 더 많은 속성을 가지고 있지만 컴파일러 &lt;em&gt;는 적어도&lt;/em&gt; 필요한 것이 존재하고 필요한 유형과 일치 합니다. TypeScript가 관대하지 않은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">타입 체커는 이전에 &lt;code&gt;null&lt;/code&gt; 로 &lt;code&gt;undefined&lt;/code&gt; 할 수 없는 것으로 간주했습니다 . 실제로 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 &lt;em&gt;모든&lt;/em&gt; 유형 의 유효한 값 이므로이를 구체적으로 제외 할 수 없었으므로 잘못 사용하는 것을 감지 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">타입 주석이없는 &lt;code&gt;const&lt;/code&gt; 변수 또는 &lt;code&gt;readonly&lt;/code&gt; 속성에 대해 유추 된 타입은 리터럴 초기화 프로그램의 타입입니다. 이니셜 라이저가 있고 형식 주석이없는 &lt;code&gt;let&lt;/code&gt; 변수, &lt;code&gt;var&lt;/code&gt; 변수, 매개 변수 또는 비 &lt;code&gt;readonly&lt;/code&gt; 속성에 대해 유추 된 형식 은 이니셜 라이저의 확장 리터럴 형식입니다. 문자열 리터럴 유형에 대한 확대 타입 인 경우 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; 숫자 문자 유형, &lt;code&gt;boolean&lt;/code&gt; 에 대한 &lt;code&gt;true&lt;/code&gt; 혹은 &lt;code&gt;false&lt;/code&gt; 및 열거 문자 유형에 포함하는 열거.</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">제공된 유형 정보는 도구와 함께 작동하여 응용 프로그램 규모에서 JavaScript를 사용할 수 있습니다. TypeScript에서 가능한 것에 대한 더 많은 예는 웹 사이트의 샘플 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 의 유형은 글로벌 &lt;code&gt;ImportMeta&lt;/code&gt; 입니다. 에 정의 된 유형 &lt;code&gt;lib.es5.d.ts&lt;/code&gt; . 이 인터페이스는 매우 제한적입니다. 노드 또는 브라우저에 대해 잘 알려진 특성을 추가하려면 인터페이스 병합 및 컨텍스트에 따라 글로벌 기능 보강이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8e56de6acd1d580bed0b7dbc97a0025ddbff4368" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;o&lt;/code&gt; is determined to be &lt;code&gt;{ inference: string }&lt;/code&gt; because</source>
          <target state="translated">유형 &lt;code&gt;o&lt;/code&gt; 것으로 결정 &lt;code&gt;{ inference: string }&lt;/code&gt; 때문에</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 문에 선언 된 변수의 유형 은 암시 적으로 &lt;code&gt;string&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">제네릭 함수의 유형은 제네릭이 아닌 함수의 유형과 동일하며 함수 선언과 유사하게 유형 매개 변수가 먼저 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">나머지 요소가있는 튜플 유형 의 &lt;code&gt;length&lt;/code&gt; 속성 유형은 &lt;code&gt;number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 변수 의 유형은 &lt;code&gt;number&lt;/code&gt; 로 추론됩니다 . 이러한 종류의 추론은 변수 및 멤버를 초기화하고 매개 변수 기본값을 설정하고 함수 반환 유형을 결정할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 표현식 의 유형 매개 변수 유형은 mixin 생성자 유형으로 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">타입 시스템은 소스 함수의 리턴 타입이 타겟 타입의 리턴 타입의 서브 타입이되도록합니다.</target>
        </trans-unit>
        <trans-unit id="80a0ca38923f448a6bc1a30ea77dea5fb6863b0e" translate="yes" xml:space="preserve">
          <source>The type system in TypeScript has different levels of strictness when working with a codebase:</source>
          <target state="translated">TypeScript의 유형 시스템은 코드베이스로 작업 할 때 서로 다른 수준의 엄격함을가집니다.</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">유형 변수 &lt;code&gt;K&lt;/code&gt; 는 각 속성에 차례로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">JSX 요소에 전달되는 속성 유형은 다르게 조회해야합니다. 본질적인 요소 속성은 &lt;em&gt;본질적&lt;/em&gt; 으로 알고 있어야합니다.&lt;em&gt;&lt;/em&gt; 하지만 구성 요소는 한 속성 세트를 지정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fe3cafbbb2e988a60a62d633a3631e8dd7b2a154" translate="yes" xml:space="preserve">
          <source>The types which are exported can then be re-used by consumers of the modules using either &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;import type&lt;/code&gt; in TypeScript code or &lt;a href=&quot;../../jsdoc-supported-types#import-types&quot;&gt;JSDoc imports&lt;/a&gt;.</source>
          <target state="translated">그런 다음 내 보낸 &lt;code&gt;import type&lt;/code&gt; 은 TypeScript 코드의 가져 &lt;code&gt;import&lt;/code&gt; 또는 가져 오기 유형 또는 &lt;a href=&quot;../../jsdoc-supported-types#import-types&quot;&gt;JSDoc 가져 &lt;/a&gt;오기를 사용하여 모듈 소비자가 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">프로젝트 파일 의 &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; 속성 값은 빌드하는 데 사용할 컴파일러 버전을 식별합니다 (이 예에서는 1.7). 이를 통해 프로젝트는 다른 컴퓨터에서 동일한 버전의 컴파일러에 대해 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff912358477db4602c58e3b0cd86822e8bf58dbb" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 의 값은 상속 할 다른 구성 파일의 경로를 포함하는 문자열입니다. 경로는 Node.js 스타일 해상도를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 값은 상속 할 다른 구성 파일의 경로가 포함 된 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">TypeScript가 변수에 문제가 있음을 나타 내기 위해 변수를 반드시 블록 범위로 지정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">병합 된 멤버의 가시성 규칙은 '네임 스페이스 병합'섹션에 설명 된 것과 동일하므로 &lt;code&gt;AlbumLabel&lt;/code&gt; 을 내 보내야합니다. 병합 된 클래스 클래스를 볼 수 있습니다. 최종 결과는 다른 클래스 내에서 관리되는 클래스입니다. 네임 스페이스를 사용하여 기존 클래스에 더 많은 정적 멤버를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="243a2c277506b9bd8ad79e2eb6c0a571a75e9611" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &lt;a href=&quot;declaration-merging#merging-namespaces&quot;&gt;Merging Namespaces&lt;/a&gt; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">병합 된 멤버의 가시성 규칙은 &lt;a href=&quot;declaration-merging#merging-namespaces&quot;&gt;네임 스페이스 병합&lt;/a&gt; 섹션에 설명 된 것과 동일 하므로 병합 된 클래스를 보려면 &lt;code&gt;AlbumLabel&lt;/code&gt; 클래스를 내 보내야 합니다. 최종 결과는 다른 클래스 내부에서 관리되는 클래스입니다. 네임 스페이스를 사용하여 기존 클래스에 더 많은 정적 멤버를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">노드에서 기본적으로 재귀 디렉토리 감시를 지원하지 않는 플랫폼에서의 디렉토리 감시는 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 에 의해 선택된 다른 옵션을 사용하여 하위 디렉토리에 대한 디렉토리 감시자를 재귀 적으로 작성함으로써 지원됩니다 . 기본 재귀 디렉토리 감시 (예 : 창)를 지원하는 플랫폼에서는이 환경 변수의 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">TypeScript가 컴파일러 및 언어 버전의 일치 여부를 결정하는 방법은 Node의 &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges를 사용하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">이것이 작동하는 방식은 &lt;code&gt;allowJs&lt;/code&gt; 를 사용할 때 TypeScript가 일반적인 JavaScript 패턴을 이해하기위한 최선의 분석을 수행한다는 것입니다. 그러나 일부 패턴이 JavaScript로 표현되는 방식이 TypeScript에서 해당 패턴과 동일하게 보일 필요는 없습니다. 때 &lt;code&gt;declaration&lt;/code&gt; 개의 발광가 켜져있는 가장 좋은 방법 밖으로 타이프 라이터 수치는 출력처럼 JSDoc 주석과 유효한 타입 선언에 CommonJS 수출하고 변환하는 &lt;code&gt;.d.ts&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">그런 다음 소비했습니다.</target>
        </trans-unit>
        <trans-unit id="b4e2cc009128e2db8e40c27a6eddddf19f0ce8db" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file.</source>
          <target state="translated">그런 다음 &lt;code&gt;inlineSourceMap&lt;/code&gt; 이 활성화 된 상태에서 빌드를 활성화하면 파일의 소스 맵을 포함하는 파일 하단에 주석이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e16808203379c44a60c8ea98dbc5730307f3ef5" translate="yes" xml:space="preserve">
          <source>Then enable building it with &lt;code&gt;inlineSources&lt;/code&gt; and &lt;code&gt;inlineSourceMap&lt;/code&gt; enabled there is a comment at the bottom of the file which includes a source-map for the file. Note that the end is different from the example in &lt;a href=&quot;#inlineSourceMap&quot;&gt;&lt;code&gt;inlineSourceMap&lt;/code&gt;&lt;/a&gt; because the source-map now contains the original source code also.</source>
          <target state="translated">그런 다음 &lt;code&gt;inlineSources&lt;/code&gt; 및 &lt;code&gt;inlineSourceMap&lt;/code&gt; 을 사용 하여 빌드 할 수 있도록 파일의 소스 맵을 포함하는 파일 맨 아래에 주석이 있습니다. 소스 맵에는 이제 원본 소스 코드도 포함되어 있으므로 끝 부분이 &lt;a href=&quot;#inlineSourceMap&quot;&gt; &lt;code&gt;inlineSourceMap&lt;/code&gt; &lt;/a&gt; 의 예제와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="87bfce3f975bdf3b7775facbf050990abd13d246" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for TypeScript.</source>
          <target state="translated">그런 다음 프로젝트의 개발 종속성에 &lt;code&gt;typescript&lt;/code&gt; , &lt;code&gt;gulp&lt;/code&gt; 및 &lt;code&gt;gulp-typescript&lt;/code&gt; 를 설치하십시오. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; 는 TypeScript 용 gulp 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">그런 다음 프로젝트의 개발자 종속성에 &lt;code&gt;typescript&lt;/code&gt; , &lt;code&gt;gulp&lt;/code&gt; 및 &lt;code&gt;gulp-typescript&lt;/code&gt; 를 설치하십시오. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; 는 Typescript 용 gulp 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">그런 다음 &lt;code&gt;defaults&lt;/code&gt; &lt;code&gt;food&lt;/code&gt; 속성은 &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; 덮어 씁니다 .이 경우에는 우리가 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="becbc2214d8bce0fa238270073a5869333572174" translate="yes" xml:space="preserve">
          <source>Then turning on both &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#downlevelIteration&quot;&gt; &lt;code&gt;downlevelIteration&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;importHelpers&lt;/code&gt; 를 모두 켭니다 .</target>
        </trans-unit>
        <trans-unit id="4b0de2b0a81fcb1c9fa6824131d9c2d4117e4121" translate="yes" xml:space="preserve">
          <source>Then use the template &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; 처럼 &lt;em&gt;호출&lt;/em&gt; 할 수있는 경우 module-function.d.ts 템플릿을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ee7e9ae9703590946457d53a865fb4cbb6b63b7c" translate="yes" xml:space="preserve">
          <source>Then you can create mixins which only work when you have a particular base to build on:</source>
          <target state="translated">그런 다음 빌드 할 특정 기반이있을 때만 작동하는 믹스 인을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b21ce8f02b992c174e280059fa4ec67556da04" translate="yes" xml:space="preserve">
          <source>Then you need a type and a factory function which returns a class expression extending the base class.</source>
          <target state="translated">그런 다음 기본 클래스를 확장하는 클래스 표현식을 반환하는 유형과 팩토리 함수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">그런 다음, 유형 주어진 &lt;code&gt;T''&lt;/code&gt; 의 실체화 &lt;code&gt;T&lt;/code&gt; 모든 &lt;code&gt;infer&lt;/code&gt; 경우 타입 변수가 이전 단계에서 추론 유형으로 대체됩니다, &lt;code&gt;T''&lt;/code&gt; 것입니다 &lt;em&gt;확실히 할당&lt;/em&gt; 에 &lt;code&gt;U&lt;/code&gt; , 조건 유형에 해결 &lt;code&gt;X&lt;/code&gt; . 확실히 할당 가능한 관계는 형식 변수 제약 조건이 고려되지 않는다는 점을 제외하고는 정규 할당 가능한 관계와 동일합니다. 직관적으로 유형이 다른 유형에 확실히 할당 될 수 있는 경우 해당 유형의 &lt;em&gt;모든 인스턴스화&lt;/em&gt; 에 대해 유형 이 할당 될 수 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">그런 다음 기본 이니셜 라이저 대신 비 구조화 된 특성의 선택적 특성에 대한 기본값을 제공해야합니다. 기억 &lt;code&gt;C&lt;/code&gt; 가 정의 된 &lt;code&gt;b&lt;/code&gt; 선택 :</target>
        </trans-unit>
        <trans-unit id="6d2f25ea43cbbc9a4a4d0cca6420fdb8cc7a3eaa" translate="yes" xml:space="preserve">
          <source>There are already a small set of primitive types available in JavaScript: &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt;, which you can use in an interface. TypeScript extends this list with a few more, such as &lt;code&gt;any&lt;/code&gt; (allow anything), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;unknown&lt;/code&gt;&lt;/a&gt; (ensure someone using this type declares what the type is), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt;&lt;code&gt;never&lt;/code&gt;&lt;/a&gt; (it&amp;rsquo;s not possible that this type could happen), and &lt;code&gt;void&lt;/code&gt; (a function which returns &lt;code&gt;undefined&lt;/code&gt; or has no return value).</source>
          <target state="translated">자바 스크립트에서 사용할 수있는 작은 기본 유형 집합이 이미 있습니다 : &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; , 인터페이스에서 사용할 수 있습니다. TypeScript는 &lt;code&gt;any&lt;/code&gt; (무엇이든 허용), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt; &lt;code&gt;unknown&lt;/code&gt; &lt;/a&gt; (이 유형을 사용하는 누군가가 유형이 무엇인지 선언하는지 확인), &lt;a href=&quot;https://www.typescriptlang.org/play#example/unknown-and-never&quot;&gt; &lt;code&gt;never&lt;/code&gt; &lt;/a&gt; (이 유형이 발생할 수 없음) 및 &lt;code&gt;void&lt;/code&gt; (반환하는 함수 ) 등 몇 가지 추가로이 목록을 확장 합니다. &lt;code&gt;undefined&lt;/code&gt; 거나 반환 값이 없음).</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; 에 특정한 플래그도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">여기에는 기본적으로 세 가지 변경 사항이 있지만 코드를 약간 리 팩터해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">TypeScript가 특정 유형이 무엇인지 파악하지 못하는 경우가 있습니다. 가능한 한 관대로 일하기 위해서는 유형을 사용하기로 결정합니다 &lt;code&gt;any&lt;/code&gt; 그 자리에. 이 마이그레이션에 좋은 곳입니다 동안 사용하는 &lt;code&gt;any&lt;/code&gt; 사용자가 모든 유형의 안전을받지 못하고 있다는 것을 의미, 당신은 당신이 다른 곳에서 얻을 것 같은 도구 지원을받지 않습니다. TypeScript에 이러한 위치를 플래그 지정하고 &lt;code&gt;noImplicitAny&lt;/code&gt; 옵션으로 오류를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">속성이 간접적으로 초기화 될 수있는 시나리오가있을 수 있습니다 (아마도 도우미 메서드 또는 종속성 주입 라이브러리에 의해).이 경우 속성에 새로운 &lt;em&gt;명확한 어설 션 어설 션 수정자를&lt;/em&gt; 사용할 수 있습니다 (아래에 설명 됨).</target>
        </trans-unit>
        <trans-unit id="eba634610df41341637e71be5bcbf8bb0ed87e8f" translate="yes" xml:space="preserve">
          <source>There are four templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; 의&lt;/a&gt; 네 가지 템플릿을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e36d4bfc03b98451d8b8eedb5746119736591728" translate="yes" xml:space="preserve">
          <source>There are many ways to import a module in modern consuming code:</source>
          <target state="translated">최신 소비 코드에서 모듈을 가져 오는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dea4fb6f37fc741965c275705e62ed0016df0d89" translate="yes" xml:space="preserve">
          <source>There are many, many resources available for programmers to learn JavaScript; you should &lt;em&gt;not&lt;/em&gt; ignore these resources if you&amp;rsquo;re writing TypeScript. For example, there are about 20 times more StackOverflow questions tagged &lt;code&gt;javascript&lt;/code&gt; than &lt;code&gt;typescript&lt;/code&gt;, but &lt;em&gt;all&lt;/em&gt; of the &lt;code&gt;javascript&lt;/code&gt; questions also apply to TypeScript.</source>
          <target state="translated">프로그래머가 JavaScript를 배울 수있는 많은 리소스가 있습니다. TypeScript를 작성하는 경우 이러한 리소스를 무시 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . 예를 들어, 약 20 배 이상 StackOverflow의 질문에 태그가 &lt;code&gt;javascript&lt;/code&gt; 보다 &lt;code&gt;typescript&lt;/code&gt; 하지만, &lt;em&gt;모두&lt;/em&gt; 의 &lt;code&gt;javascript&lt;/code&gt; 질문은 타이프 라이터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b49ffaf8a00ef0b4948f5d604ea58ab037be14" translate="yes" xml:space="preserve">
          <source>There are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:</source>
          <target state="translated">JSX를 사용자 정의하는 데 사용할 수있는 여러 컴파일러 플래그가 있습니다. 이는 컴파일러 플래그 및 인라인 파일 별 pragma를 통해 작동합니다. 자세한 내용은 tsconfig 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">라이브러리에는 여러 종류의 종속성이 있습니다. 이 섹션에서는 선언 파일로 가져 오는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54d5d5df37f41afa88246489b4794d1549724fce" translate="yes" xml:space="preserve">
          <source>There are three sets of literal types available in TypeScript today: strings, numbers, and booleans; by using literal types you can allow an exact value which a string, number, or boolean must have.</source>
          <target state="translated">오늘날 TypeScript에는 문자열, 숫자, 부울의 세 가지 리터럴 유형이 있습니다. 리터럴 유형을 사용하면 문자열, 숫자 또는 부울에 있어야하는 정확한 값을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb53f7de48cbccf0073a458e4977f8e2bef7683" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; 의&lt;/a&gt; 세 가지 템플릿을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈에 사용할 수있는 템플릿은 &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3175acff50e94eb51400e6dbf17df6396ef9e4b3" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript available for your project:</source>
          <target state="translated">프로젝트에 사용할 수있는 TypeScript를 얻는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">TypeScript 도구를 얻는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">두 가지 패키지가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">두 가지 가능한 모듈 확인 전략이 있습니다 : &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; 및 &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; . &lt;code&gt;--moduleResolution&lt;/code&gt; 플래그를 사용하여 모듈 확인 전략을 지정할 수 있습니다 . 지정하지 않으면 기본값은 &lt;a href=&quot;#classic&quot;&gt;클래식&lt;/a&gt; 에 대한 &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; 그렇지 않으면 ES2015 또는 &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb5339d9e6a87194928e1205da42e556f4c0c78" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; for &lt;code&gt;--module commonjs&lt;/code&gt;, and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; otherwise (including when &lt;code&gt;--module&lt;/code&gt; is set to &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;umd&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.).</source>
          <target state="translated">두 가지 가능한 모듈 분석 전략이 있습니다 : &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; 및 &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; . &lt;code&gt;--moduleResolution&lt;/code&gt; 플래그를 사용하여 모듈 해결 전략을 지정할 수 있습니다 . 지정되지 않은 경우, 기본값은 &lt;a href=&quot;#node&quot;&gt;노드&lt;/a&gt; 에 대한 &lt;code&gt;--module commonjs&lt;/code&gt; 하고, &lt;a href=&quot;#classic&quot;&gt;클래식&lt;/a&gt; , 그렇지 않으면 (때를 포함 &lt;code&gt;--module&lt;/code&gt; 이 설정되어 &lt;code&gt;amd&lt;/code&gt; , &lt;code&gt;system&lt;/code&gt; , &lt;code&gt;umd&lt;/code&gt; , &lt;code&gt;es2015&lt;/code&gt; , &lt;code&gt;esnext&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">지원되는 인덱스 서명에는 문자열과 숫자의 두 가지 유형이 있습니다. 두 가지 유형의 인덱서를 모두 지원할 수 있지만 숫자 형 인덱서에서 반환 된 유형은 문자열 인덱서에서 반환 된 유형의 하위 유형이어야합니다. &lt;code&gt;number&lt;/code&gt; 인덱싱 할 때 JavaScript는 실제로 객체로 인덱싱하기 전에 &lt;code&gt;string&lt;/code&gt; 로 변환 하기 때문입니다. 즉, &lt;code&gt;100&lt;/code&gt; ( &lt;code&gt;number&lt;/code&gt; )을 사용한 색인 작성은 &lt;code&gt;&quot;100&quot;&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; )을 사용 하는 색인 작성과 동일 하므로 두 항목이 일관되어야합니다.</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">값 기반 요소를 정의하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">이를 수행하는 두 가지 방법이 있습니다. 첫 번째는 &lt;code&gt;--strictNullChecks&lt;/code&gt; 를 켜고 리턴 유형을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf2a0ce7bafc915c076e238a70bcad502f45e2dc" translate="yes" xml:space="preserve">
          <source>There have been cases where a feature is compelling enough to be an exception to that rule, and these live as experimental compiler flags. It is possible that a version of these features may be different when/if they are added to the JavaScript language, and thus are considered risky.</source>
          <target state="translated">특정 기능이 해당 규칙에 대한 예외가 될만큼 강력한 경우가 있었으며 이들은 실험적인 컴파일러 플래그로 존재합니다. 이러한 기능의 버전은 JavaScript 언어에 추가 될 때 / 해당하는 경우 다를 수 있으므로 위험하다고 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007f160b174984bad6b726d50666ccbaf286b22c" translate="yes" xml:space="preserve">
          <source>There is a handbook reference page on &lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;Module Resolution&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;docs/handbook/module-resolution&quot;&gt;모듈 해결&lt;/a&gt; 에 대한 핸드북 참조 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">계산되지 않은 상수 열거 형 멤버의 특수 하위 집합 인 리터럴 열거 형 멤버가 있습니다. 리터럴 열거 형 멤버는 초기화 된 값이 없거나 값이 초기화 된 상수 열거 형 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">클래스 내부의 다양한 선언에 데코레이터를 적용하는 방법은 다음과 같이 잘 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c03a7a9feb4e16d6584fcc6c1888330ee99b47fa" translate="yes" xml:space="preserve">
          <source>There is no case requirement, but type parameters are conventionally single uppercase letters. Type parameters can also be constrained to a type, which behaves a bit like type class constraints:</source>
          <target state="translated">대소 문자 요구 사항은 없지만 유형 매개 변수는 일반적으로 단일 대문자입니다. 타입 매개 변수는 타입 클래스 제약과 비슷하게 동작하는 타입으로 제약 될 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="59854d2178396e55e332123995b42b2847acef61" translate="yes" xml:space="preserve">
          <source>There is no difference between how classes and objects conform to shapes:</source>
          <target state="translated">클래스와 객체가 모양을 따르는 방법에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">대부분의 프로젝트 유형 에는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 대한 템플릿이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">기능의 특정 세트있다 &lt;code&gt;throw&lt;/code&gt; 예상치 못한 일이 발생하면 오류가. 이를 &quot;어설 션&quot;기능이라고합니다. 예를 들어 Node.js에는 &lt;code&gt;assert&lt;/code&gt; 라는 전용 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;선택적 call&lt;/em&gt; 이 있는데 , 표현식이 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 아닌 경우 조건부로 표현식을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">내장 된 최신 검사 기능이 없으므로 항상 &lt;code&gt;tsc&lt;/code&gt; 를 두 번 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">이 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 파일은 안전하게 삭제 될 수 있으며 런타임에 코드에 영향을 미치지 않습니다. 순전히 컴파일 속도를 높이는 데 사용됩니다. 원하는 이름을 지정하고 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 플래그를 사용하여 원하는 위치에 배치 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4432967bf84b9c64e93637b08f3be2a8d76030ec" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; can be one of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; operator&amp;rsquo;s return values&lt;/a&gt; (&lt;code&gt;&quot;undefined&quot;&lt;/code&gt;, &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;, &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;, &lt;code&gt;&quot;object&quot;&lt;/code&gt;, or &lt;code&gt;&quot;function&quot;&lt;/code&gt;). While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">이러한 &lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; 유형 가드&lt;/em&gt; 는 &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; 및 &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; , 여기서 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; 은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; 연산자의 반환 값&lt;/a&gt; 중 하나 일 수 있습니다 ( &lt;code&gt;&quot;undefined&quot;&lt;/code&gt; , &lt;code&gt;&quot;number&quot;&lt;/code&gt; , &lt;code&gt;&quot;string&quot;&lt;/code&gt; , &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; , &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; , &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; , &lt;code&gt;&quot;object&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;function&quot;&lt;/code&gt; ). TypeScript는 다른 문자열과 비교하는 것을 멈추지 않지만 언어는 이러한 표현을 유형 가드로 인식하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">이러한 &lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; type guard&lt;/em&gt; 는 두 가지 다른 형식으로 인식됩니다 : &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; 및 &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; , 여기서 &lt;code&gt;&quot;typename&quot;&lt;/code&gt; 은 &lt;code&gt;&quot;number&quot;&lt;/code&gt; , &lt;code&gt;&quot;string&quot;&lt;/code&gt; , &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; 이어야합니다. &quot; . TypeScript는 다른 문자열과 비교하는 것을 막지 않지만 언어는 이러한 표현식을 유형 가드로 인식하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e2d65d5a90ac869c2cc90b8e3534ec2395fdf41" translate="yes" xml:space="preserve">
          <source>These are emitted as &lt;code&gt;.map&lt;/code&gt; files which live alongside the file they represent.</source>
          <target state="translated">이들은 그들이 나타내는 파일과 함께 존재하는 &lt;code&gt;.map&lt;/code&gt; 파일 로 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">이것들은 명시 적으로 작성되지 않았지만 문제를 좁힐 때 유용하고 버그를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07491a8375f8e779f9a5bd9a9bd4a7fcc0120b03" translate="yes" xml:space="preserve">
          <source>These aspects describe a &lt;em&gt;reified, nominal&lt;/em&gt; type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.</source>
          <target state="translated">이러한 측면은 수정 &lt;em&gt;된 공칭&lt;/em&gt; 유형 시스템을 설명 합니다. 코드에서 작성한 유형은 런타임에 존재하며 유형은 구조가 아니라 선언을 통해 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">이 어설 션 서명은 유형 술어 서명 작성과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">이것들은 다음과 같이 가져올 수 있습니다</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">이러한 예는 대략적으로 복잡성이 증가하는 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c149ccf644eec42a0be9ed6e4d8cf9bb1991cb19" translate="yes" xml:space="preserve">
          <source>These limitations can cause runtime problems with some TypeScript features like &lt;code&gt;const enum&lt;/code&gt;s and &lt;code&gt;namespace&lt;/code&gt;s. Setting the &lt;code&gt;isolatedModules&lt;/code&gt; flag tells TypeScript to warn you if you write certain code that can&amp;rsquo;t be correctly interpreted by a single-file transpilation process.</source>
          <target state="translated">이러한 제한으로 인해 &lt;code&gt;const enum&lt;/code&gt; 및 &lt;code&gt;namespace&lt;/code&gt; 와 같은 일부 TypeScript 기능에서 런타임 문제가 발생할 수 있습니다 . &lt;code&gt;isolatedModules&lt;/code&gt; 플래그를 설정하면 단일 파일 변환 프로세스에서 올바르게 해석 할 수없는 특정 코드를 작성하는 경우 TypeScript가 경고하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">이 옵션은 운동장 샘플에 대한 링크를 공유 할 때도 지속되므로 사용자는 수신자에게&amp;ldquo;오, &lt;code&gt;noImplicitAny&lt;/code&gt; 옵션 을 켜는 것을 잊지 마십시오 !&amp;rdquo; 라고 말하지 않고도 예제를보다 안정적으로 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e044a651893f38dabaa6219c410c2660102bcf0" translate="yes" xml:space="preserve">
          <source>These options make up the bulk of TypeScript&amp;rsquo;s configuration and it covers how the language should work.</source>
          <target state="translated">이 옵션은 TypeScript 구성의 대부분을 구성하며 언어 작동 방식을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">이러한 범위 지정 규칙은 여러 유형의 실수를 일으킬 수 있습니다. 그들이 악화시키는 한 가지 문제는 동일한 변수를 여러 번 선언하는 것이 오류가 아니라는 사실입니다.</target>
        </trans-unit>
        <trans-unit id="869e555c5337a018666cb0666e0939a7d84b21dd" translate="yes" xml:space="preserve">
          <source>These settings are used to define the runtime expectations of your project, how and where you want the JavaScript to be emitted and the level of integration you want with existing JavaScript code.</source>
          <target state="translated">이러한 설정은 프로젝트의 런타임 기대치, JavaScript를 내보내는 방법 및 위치, 기존 JavaScript 코드와의 통합 수준을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfb58f6d95b6c9be936d843cbb719495c0847fb" translate="yes" xml:space="preserve">
          <source>These settings help you ensure that TypeScript picks up the right files.</source>
          <target state="translated">이러한 설정은 TypeScript가 올바른 파일을 선택하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bed62e5cae7d2c803744fdf8f9b3ad988309267c" translate="yes" xml:space="preserve">
          <source>These warnings are only about code which is provably unreachable due to the use of JavaScript syntax, for example:</source>
          <target state="translated">이러한 경고는 JavaScript 구문 사용으로 인해 도달 할 수없는 코드에 대해서만 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">&lt;code&gt;--out&lt;/code&gt; 또는 &lt;code&gt;--outFile&lt;/code&gt; 을 사용할 때 출력을 정렬하는 방법으로도 사용됩니다 . 파일은 사전 처리 패스 후 입력과 동일한 순서로 출력 파일 위치로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">또한 &lt;code&gt;exports&lt;/code&gt; 개체를 사용자 지정 단일 개체로 바꾸는 것도 지원 합니다. 기본 내보내기는이 동작의 대체 역할을합니다. 그러나 둘은 호환되지 않습니다. TypeScript는 기존 CommonJS 및 AMD 워크 플로우를 모델링하기 위해 &lt;code&gt;export =&lt;/code&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">그것들은 &lt;code&gt;let&lt;/code&gt; 선언과 같지만, 이름에서 알 수 있듯이 일단 바인딩되면 값을 변경할 수 없습니다. 즉, &lt;code&gt;let&lt;/code&gt; 과 동일한 범위 지정 규칙이 있지만 다시 할당 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ba589ad465e9addde0a355ab070f5063bbe5659" translate="yes" xml:space="preserve">
          <source>They can also be declared as constructor functions, as described in the next section:</source>
          <target state="translated">다음 섹션에 설명 된대로 생성자 함수로 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">그들은 거의 가질 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">주의 사항</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">이 &lt;code&gt;package.json&lt;/code&gt; 은 TypeScript에게 현재 버전의 TypeScript가 실행 중인지 확인하도록 지시합니다. 3.1 이상인 경우 패키지와 관련하여 가져온 경로를 &lt;code&gt;ts3.1&lt;/code&gt; 하고 패키지의 ts3.1 폴더 에서 읽습니다 . 이것이 바로 &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; 의미입니다. 오늘날 경로 매핑에 익숙하다면 정확하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2359d0122889cba1caee9c6fd11f3a61b8a57f14" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/jest&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">이 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에는 &lt;code&gt;./node_modules/@types/node&lt;/code&gt; , &lt;code&gt;./node_modules/@types/jest&lt;/code&gt; 및 &lt;code&gt;./node_modules/@types/express&lt;/code&gt; &lt;em&gt;만&lt;/em&gt; 포함됩니다 . &lt;code&gt;node_modules/@types/*&lt;/code&gt; 아래의 다른 패키지는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">이 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에는 &lt;code&gt;./node_modules/@types/node&lt;/code&gt; , &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; 및 &lt;code&gt;./node_modules/@types/express&lt;/code&gt; &lt;em&gt;만&lt;/em&gt; 포함됩니다 . &lt;code&gt;node_modules/@types/*&lt;/code&gt; 다른 패키지는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ee5dcc9ee441574b7eb98ac0562e02ba448d0a4" translate="yes" xml:space="preserve">
          <source>This TSX file:</source>
          <target state="translated">이 TSX 파일 :</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">이렇게하면 &lt;code&gt;copy-html&lt;/code&gt; 작업 이 추가되고 &lt;code&gt;default&lt;/code&gt; 의 종속성으로 추가됩니다 . 즉 , &lt;code&gt;default&lt;/code&gt; 이 실행될 때마다 &lt;code&gt;copy-html&lt;/code&gt; 이 먼저 실행되어야합니다. 또한 gulp-typescript 대신 tsify 플러그인으로 Browserify를 호출하도록 &lt;code&gt;default&lt;/code&gt; 을 변경했습니다 . 편리하게도 둘 다 동일한 옵션 객체를 TypeScript 컴파일러에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d926e2aab031119cddb8cc6d74ab38f013eea1" translate="yes" xml:space="preserve">
          <source>This allows for creating classes which only work with constrained base classes:</source>
          <target state="translated">이렇게하면 제한된 기본 클래스에서만 작동하는 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">이것은 숫자 및 문자열 리터럴에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4819d75c2e64c6891ffbc7a26bcbfbdf36fb3616" translate="yes" xml:space="preserve">
          <source>This also means that TypeScript never changes the &lt;em&gt;behavior&lt;/em&gt; of your program based on the types it inferred. The bottom line is that while you might see type errors during compilation, the type system itself has no bearing on how your program works when it runs.</source>
          <target state="translated">이것은 또한 TypeScript 가 추론 한 유형에 따라 프로그램 의 &lt;em&gt;동작&lt;/em&gt; 을 변경하지 않음을 의미합니다 . 결론은 컴파일 중에 유형 오류를 볼 수 있지만 유형 시스템 자체는 프로그램이 실행될 때 작동하는 방식과 관련이 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">이것은 또한 JSDoc 주석에서 작동하여 &lt;code&gt;.js&lt;/code&gt; 의 다른 모듈의 유형을 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">이것은 클래스와도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">변수 &lt;code&gt;bar&lt;/code&gt; 가 &lt;code&gt;foo&lt;/code&gt; 유형을 갖도록합니다 . TypeScript는 형식 어설 션에 꺾쇠 괄호를 사용하기 때문에 JSX의 구문과 결합하면 특정 구문 분석 문제가 발생합니다. 결과적으로 TypeScript는 &lt;code&gt;.tsx&lt;/code&gt; 파일 에서 꺾쇠 괄호 형식 어설 션을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f85fb60fbb15b3106e3e22c3ddc01338d2c58122" translate="yes" xml:space="preserve">
          <source>This can be considered a &amp;lsquo;fast &amp;amp; loose&amp;rsquo; implementation of the watching algorithm, which can drastically reduce incremental rebuild times at the expense of having to run the full build occasionally to get all compiler error messages.</source>
          <target state="translated">이는 감시 알고리즘의 '빠르고 느슨한'구현으로 간주 될 수 있으며, 모든 컴파일러 오류 메시지를 얻기 위해 가끔 전체 빌드를 실행해야하는 비용으로 증분 재 빌드 시간을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5432dead64ccc9df023d2796e15b77df708ad37" translate="yes" xml:space="preserve">
          <source>This can be described by the following &lt;code&gt;.d.ts&lt;/code&gt;:</source>
          <target state="translated">다음 &lt;code&gt;.d.ts&lt;/code&gt; 로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="162b366ea578762d34bc51102f5149c7ad80c399" translate="yes" xml:space="preserve">
          <source>This can be described with:</source>
          <target state="translated">이것은 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">이것은 명령들 사이에 출력을 파이프하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">상속을 사용하는 기존 코드에 대해 약간의 오류가 발생할 수 있습니다. 우선, 기본 클래스의 &lt;code&gt;set&lt;/code&gt; 접근자는 트리거되지 않습니다. 완전히 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec76fbaf129c54c7b42ac5e553e9239c220251e5" translate="yes" xml:space="preserve">
          <source>This can cause some errors to be missed, for example:</source>
          <target state="translated">이로 인해 일부 오류가 누락 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">TypeScript의 &lt;code&gt;enum&lt;/code&gt; 구문 을 사용하지 않기로 선택하면 일반 JavaScript 코드에서 &lt;code&gt;enum&lt;/code&gt; 과 같은 패턴 을 활성화하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">이것은 &lt;code&gt;@param&lt;/code&gt; 태그 를 사용하는 기본 기능을 넘어 설 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608ec68b1f29faf0c91c96f151172e130a6c7a7f" translate="yes" xml:space="preserve">
          <source>This can save time during compilation at the expense of type-system accuracy. For example, two libraries could define two copies of the same &lt;code&gt;type&lt;/code&gt; in an inconsistent way. Rather than doing a full check of all &lt;code&gt;d.ts&lt;/code&gt; files, TypeScript will type check the code you specifically refer to in your app&amp;rsquo;s source code.</source>
          <target state="translated">이렇게하면 유형 시스템 정확도를 희생하면서 컴파일하는 동안 시간을 ​​절약 할 수 있습니다. 예를 들어, 두 개의 라이브러리가 일관되지 않은 방식으로 동일한 &lt;code&gt;type&lt;/code&gt; 의 두 사본을 정의 할 수 있습니다. 모든 &lt;code&gt;d.ts&lt;/code&gt; 파일을 전체적으로 검사하는 대신 TypeScript는 앱의 소스 코드에서 특별히 참조하는 코드를 유형 검사합니다.</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">이 변경으로 인해 &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등과 같은 내장 클래스 확장 동작이 중단됩니다 . 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;확장 내장 주요 변경 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">이 검사는 주요 변경 사항이지만 이러한 이유로 검사는 매우 보수적입니다. 이 오류는 &lt;code&gt;if&lt;/code&gt; 조건 에서만 발생 하며 &lt;code&gt;strictNullChecks&lt;/code&gt; 가 해제되어 있거나 나중에 &lt;code&gt;if&lt;/code&gt; 의 본문 내에서 함수가 호출 된 경우 선택적 특성에서는 발행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="374f1cb2ee64d2f9699be7c65dce331865c022ca" translate="yes" xml:space="preserve">
          <source>This code raises an error because there isn&amp;rsquo;t a &lt;code&gt;default&lt;/code&gt; object which you can import. Even though it feels like it should. For convenience, transpilers like Babel will automatically create a default if one isn&amp;rsquo;t created. Making the module look a bit more like:</source>
          <target state="translated">가져올 수 있는 &lt;code&gt;default&lt;/code&gt; 개체 가 없기 때문에이 코드는 오류를 발생시킵니다 . 그래야 할 것 같지만. 편의를 위해 Babel과 같은 변환기는 기본값이 생성되지 않은 경우 자동으로 생성합니다. 모듈을 좀 더 비슷하게 만들기 :</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">이 비교 프로세스는 각 멤버와 서브 멤버의 유형을 탐색하면서 재귀 적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="afe60521b82bce04c80aea228c02c6ad2c6227cb" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt; and &lt;code&gt;./vendor/types&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;. All paths are relative to the &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">이 설정 파일이 포함됩니다 &lt;em&gt;모두&lt;/em&gt; 에서 패키지 &lt;code&gt;./typings&lt;/code&gt; 및 &lt;code&gt;./vendor/types&lt;/code&gt; 에서, 그리고 패키지 없음 &lt;code&gt;./node_modules/@types&lt;/code&gt; 을 . 모든 경로는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">이 설정 파일이 포함됩니다 &lt;em&gt;모두&lt;/em&gt; 에서 패키지 &lt;code&gt;./typings&lt;/code&gt; 에서, 그리고 패키지 없음 &lt;code&gt;./node_modules/@types&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">기본값으로 &lt;code&gt;package.json&lt;/code&gt; 파일 이 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">이것은 &lt;code&gt;o.a&lt;/code&gt; 와 &lt;code&gt;o.b&lt;/code&gt; 에서 새로운 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 만듭니다 . 필요하지 않은 경우 &lt;code&gt;c&lt;/code&gt; 를 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 라는 두 개의 새로운 변수가 생성 됩니다. 이것은 인덱싱을 사용하는 것과 동일하지만 훨씬 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a31ee5e23e03dea8a90fcb22ead8da9a4160723e" translate="yes" xml:space="preserve">
          <source>This defaults to &lt;code&gt;false&lt;/code&gt;, making it easier to work with TypeScript in a watch-like environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved.</source>
          <target state="translated">기본값은 &lt;code&gt;false&lt;/code&gt; 이므로 모든 오류가 해결되었는지 확인하기 전에 다른 환경에서 코드 변경 결과를 확인하려는 시계와 같은 환경에서 TypeScript로 작업하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">이 지시문은 파일이 기존의 내장 &lt;em&gt;lib&lt;/em&gt; 파일 을 명시 적으로 포함하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">이 지시어는 컴파일러에게 컴파일에 기본 라이브러리 (예 : &lt;code&gt;lib.d.ts&lt;/code&gt; )를 포함 &lt;em&gt;시키지 않도록&lt;/em&gt; 지시합니다 . 여기에서의 영향 은 명령 줄에서 &lt;code&gt;--noLib&lt;/code&gt; 를 전달하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">이 지시문은 파일을 &lt;em&gt;기본 라이브러리&lt;/em&gt; 로 표시합니다 . 이 주석은 &lt;code&gt;lib.d.ts&lt;/code&gt; 의 상단 과 다양한 변형에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4de1039913e973b35b634a72b6cbe6e6a97bca6" translate="yes" xml:space="preserve">
          <source>This disables reporting of excess property errors, such as the one shown in the following example:</source>
          <target state="translated">이렇게하면 다음 예에 표시된 것과 같은 초과 속성 오류보고가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9d44ce0ab64cf8784d2c30b139d5f95c5d7e18fd" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;mdash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">이 구분은 미묘하고 중요합니다. 여기서 &lt;code&gt;A.B&lt;/code&gt; 는 반드시 유형이나 값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">이 차이는 미묘하고 중요합니다. 여기서 &lt;code&gt;A.B&lt;/code&gt; 는 유형 또는 값일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a93e12d2539079ddf00741243f25ccfa0ea0beac" translate="yes" xml:space="preserve">
          <source>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</source>
          <target state="translated">이 문서는 일상적인 코드에서 사용하는 구문과 유형에 대한 높은 수준의 개요입니다. 여기에서 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f2afe5428bad556646a3ee1b89d282383eef7d8" translate="yes" xml:space="preserve">
          <source>This does not affect errors on the basis of code which &lt;em&gt;appears&lt;/em&gt; to be unreachable due to type analysis.</source>
          <target state="translated">이는 유형 분석으로 인해 도달 할 수없는 것으로 &lt;em&gt;보이는&lt;/em&gt; 코드를 기반으로하는 오류에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="235deb669a8da9c7c9faf57f9268bb2d8bdddfcd" translate="yes" xml:space="preserve">
          <source>This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to work via those relative paths at runtime.</source>
          <target state="translated">이것은 TypeScript가 JavaScript를 내보내는 방법에 영향을주지 않으며 런타임시 해당 상대 경로를 통해 작업 할 수 있다는 가정 만 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="8238728f0c2b5909a1676078b8fa412e525129da" translate="yes" xml:space="preserve">
          <source>This essentially makes such &lt;code&gt;const enums&lt;/code&gt; a source-code feature only, with no runtime traces.</source>
          <target state="translated">이것은 본질적으로 그러한 &lt;code&gt;const enums&lt;/code&gt; 런타임 추적없이 소스 코드 기능으로 만 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">이 예는 이전에 언급하지 않은 몇 가지 다른 기능을 다룹니다. 다시 말하지만, 우리는 볼 &lt;code&gt;extends&lt;/code&gt; 의 두 가지 새로운 서브 클래스를 작성하는 데 사용되는 키워드 &lt;code&gt;Animal&lt;/code&gt; : &lt;code&gt;Horse&lt;/code&gt; 과 &lt;code&gt;Snake&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7234716f41fc7048658a32b671efefbe1e85d8e" translate="yes" xml:space="preserve">
          <source>This example is a good case for &lt;a href=&quot;../../generics#generic-types&quot;&gt;using generics&lt;/a&gt; to provide richer type information:</source>
          <target state="translated">이 예제는 보다 풍부한 유형 정보를 제공하기 위해 &lt;a href=&quot;../../generics#generic-types&quot;&gt;제네릭&lt;/a&gt; 을 사용 하는 좋은 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">이 예제는 가장 기본적인 상속 기능을 보여줍니다. 클래스는 기본 클래스에서 속성과 메서드를 상속합니다. 여기서 &lt;code&gt;Dog&lt;/code&gt; 는 &lt;code&gt;extends&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;Animal&lt;/code&gt; &lt;em&gt;기본&lt;/em&gt; 클래스 에서 &lt;em&gt;파생 된 파생&lt;/em&gt; 클래스입니다 . 파생 클래스를 종종 &lt;em&gt;서브 클래스&lt;/em&gt; 라고 하고 기본 클래스를 &lt;em&gt;수퍼 클래스&lt;/em&gt; 라고 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">이 기능은 대규모 조직 또는 많은 분산 종속성이있는 프로젝트에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="be730b705da0032c97a8590e06766b7025ca507f" translate="yes" xml:space="preserve">
          <source>This feature differs from &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; in that it is about specifying only the exact types you want included, whereas &lt;a href=&quot;#typeRoots&quot;&gt;&lt;code&gt;typeRoots&lt;/code&gt;&lt;/a&gt; supports saying you want particular folders.</source>
          <target state="translated">이 기능은 포함하려는 정확한 유형 만 지정한다는 점에서 &lt;a href=&quot;#typeRoots&quot;&gt; &lt;code&gt;typeRoots&lt;/code&gt; &lt;/a&gt; 와 다른 반면 &lt;a href=&quot;#typeRoots&quot;&gt; &lt;code&gt;typeRoots&lt;/code&gt; &lt;/a&gt; 는 특정 폴더를 원한다는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">이 기능은 현재 Visual Studio 2015에서 TypeScript 1.8.4 이상 및 &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; 플러그인 과 함께 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">이 기능은 컴파일러에 대한 불변성을 암시하는 데 사용되는 유형은 종종 생략 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">이 기능은 TypeScript 2.1 이전에 지원되었지만 ES6 / ES2015를 대상으로하는 경우에만 지원되었습니다. TypeScript 2.1은 ES3 및 ES5 런타임에 기능을 제공하므로 사용중인 환경에 관계없이 자유롭게 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9421d77a04111011ab6beef18cfeb6c8d63af606" translate="yes" xml:space="preserve">
          <source>This file can be opened in a chromium based browser like Chrome or Edge Developer in &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;the CPU profiler&lt;/a&gt; section. You can learn more about understanding the compilers performance in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;TypeScript wiki section on performance&lt;/a&gt;.</source>
          <target state="translated">이 파일은 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution&quot;&gt;CPU 프로파일 러&lt;/a&gt; 섹션 의 Chrome 또는 Edge Developer와 같은 크롬 기반 브라우저에서 열 수 있습니다 . 성능에 대한 &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance&quot;&gt;TypeScript 위키 섹션&lt;/a&gt; 에서 컴파일러 성능 이해에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03daf218ff5e7e04ba0dbd060b544935bee12587" translate="yes" xml:space="preserve">
          <source>This flag also exhibits the opposite behavior to Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; option (i.e. setting TypeScript&amp;rsquo;s &lt;code&gt;preserveSymlinks&lt;/code&gt; to true parallels setting Webpack&amp;rsquo;s &lt;code&gt;resolve.symlinks&lt;/code&gt; to false, and vice-versa).</source>
          <target state="translated">이 플래그는 또한 Webpack의 &lt;code&gt;resolve.symlinks&lt;/code&gt; 옵션 과 반대 동작을 나타냅니다 (즉, TypeScript의 &lt;code&gt;preserveSymlinks&lt;/code&gt; 를 true parallels로 설정하여 Webpack의 &lt;code&gt;resolve.symlinks&lt;/code&gt; 를 false로 설정 하고 그 반대도 마찬가지).</target>
        </trans-unit>
        <trans-unit id="5b3c28c49643333e70e3aa93241b77d9ccca003c" translate="yes" xml:space="preserve">
          <source>This flag can be used as a way to incrementally add TypeScript files into JS projects by allowing the &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files to live along-side existing JavaScript files.</source>
          <target state="translated">이 플래그는 &lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일이 기존 JavaScript 파일과 함께 존재 하도록 허용하여 JS 프로젝트에 TypeScript 파일을 점진적으로 추가하는 방법으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="beef474bfe013c43dfd3fc9834ca6f76a220aa71" translate="yes" xml:space="preserve">
          <source>This flag can be used to remove that check.</source>
          <target state="translated">이 플래그를 사용하여 해당 검사를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02550f5639d55abc97d434d6a95eabab62ce1e5d" translate="yes" xml:space="preserve">
          <source>This flag changes the &lt;code&gt;keyof&lt;/code&gt; type operator to return &lt;code&gt;string&lt;/code&gt; instead of &lt;code&gt;string | number&lt;/code&gt; when applied to a type with a string index signature.</source>
          <target state="translated">이 플래그는 변경 &lt;code&gt;keyof&lt;/code&gt; 반환에 유형 연산자 &lt;code&gt;string&lt;/code&gt; 대신 &lt;code&gt;string | number&lt;/code&gt; 문자열 인덱스 서명이있는 유형에 적용될 때 숫자 입니다.</target>
        </trans-unit>
        <trans-unit id="92fdd70a602e988b83dd1c9ee9e588260d2cf64b" translate="yes" xml:space="preserve">
          <source>This flag controls how &lt;code&gt;import&lt;/code&gt; works, there are 3 different options:</source>
          <target state="translated">이 플래그는 &lt;code&gt;import&lt;/code&gt; 작동 방식을 제어 하며 다음과 같은 세 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="398bb4b75ca048c92726a3040a7e54918a529c96" translate="yes" xml:space="preserve">
          <source>This flag does not affect the JavaScript emitted by TypeScript, it only for the type checking. This option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.</source>
          <target state="translated">이 플래그는 TypeScript에 의해 생성 된 JavaScript에 영향을주지 않으며 유형 검사에만 적용됩니다. 이 옵션은 Babel과 함께 TypeScript의 동작을 인라인으로 가져 오며, 모듈의 기본 내보내기를보다 인체 공학적으로 사용하도록 추가 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1c54f09bdcf2f574ecdbd28c8e632480e1cbf37e" translate="yes" xml:space="preserve">
          <source>This flag is can only be used when &lt;a href=&quot;#allowJs&quot;&gt;&lt;code&gt;allowJs&lt;/code&gt;&lt;/a&gt; is enabled, and is used if you want to have TypeScript infer types for all of the JavaScript inside your &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="translated">이 플래그는 경우에만 사용할 수 있습니다 &lt;a href=&quot;#allowJs&quot;&gt; &lt;code&gt;allowJs&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 당신이 당신의 내부에 자바 스크립트의 모든 타이프의 추론 유형이 원하는 경우에 사용됩니다 &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abe930b46ead3b4863a06b153b429c72e1989bb9" translate="yes" xml:space="preserve">
          <source>This flag is something you can use to increase responsiveness in large composite projects.</source>
          <target state="translated">이 플래그는 대규모 복합 프로젝트에서 응답 성을 높이는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c5bbc71b97120a03c50e10dd688658f1a73436" translate="yes" xml:space="preserve">
          <source>This flag is used as part of migrating to the upcoming standard version of class fields. TypeScript introduced class fields many years before it was ratified in TC39. The latest version of the upcoming specification has a different runtime behavior to TypeScript&amp;rsquo;s implementation but the same syntax.</source>
          <target state="translated">이 플래그는 곧 출시 될 클래스 필드의 표준 버전으로 마이그레이션하는 데 사용됩니다. TypeScript는 TC39에서 비준되기 몇 년 전에 클래스 필드를 도입했습니다. 다가오는 사양의 최신 버전은 TypeScript의 구현과 런타임 동작이 다르지만 구문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c7614651c915d92a89c51c2b71b121f1d197ef79" translate="yes" xml:space="preserve">
          <source>This flag is used to help people keep this behavior from &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types&quot;&gt;before TypeScript 2.9&amp;rsquo;s release&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 사람들이 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html#support-number-and-symbol-named-properties-with-keyof-and-mapped-types&quot;&gt;TypeScript 2.9의 릴리스 이전부터이&lt;/a&gt; 동작을 유지하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f97d0d2ab256285ee26208bdac4978420f77519" translate="yes" xml:space="preserve">
          <source>This flag is useful in two cases:</source>
          <target state="translated">이 플래그는 다음 두 가지 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69247477a2922fa672b9ac6953e5f0f9de79aa95" translate="yes" xml:space="preserve">
          <source>This flag switches to the upcoming ECMA runtime behavior.</source>
          <target state="translated">이 플래그는 예정된 ECMA 런타임 동작으로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="386f8e03fb6e0f7dc1ee712a3c5377db2629c8d3" translate="yes" xml:space="preserve">
          <source>This flag was added to help people migrate to the stricter checking of new object literals in &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks&quot;&gt;TypeScript 1.6&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 사람들이 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks&quot;&gt;TypeScript 1.6&lt;/a&gt; 에서 새로운 개체 리터럴을보다 엄격하게 검사하는 데 도움이되도록 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="281c5c0d6057938bd9f41eb87fb85816e087f3c9" translate="yes" xml:space="preserve">
          <source>This flag works because you can use &lt;code&gt;import type&lt;/code&gt; to explicitly create an &lt;code&gt;import&lt;/code&gt; statement which should never be emitted into JavaScript.</source>
          <target state="translated">이 플래그는 &lt;code&gt;import type&lt;/code&gt; 을 사용 하여 JavaScript로 내 보내면 안되는 &lt;code&gt;import&lt;/code&gt; 문 을 명시 적으로 만들 수 있기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">이것은 plusPlus에 &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; 합니다. 확산은 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 번째 의 얕은 사본을 만듭니다 . 스프레드에 의해 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">이를 통해 사용자는 내부 클래스를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">이 지침은 또한 선언 파일 사용자를 중단하지 않고 라이브러리를 UMD로 전환 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">이 안내서는 고품질 TypeScript 선언 파일을 작성하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">이 안내서는 TypeScript와 &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; 및 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; 을 연결하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">JavaScript에서 TypeScript가 이전 유형 ( &lt;strong&gt;매핑&lt;/strong&gt; 된 유형)을 기반으로 새 유형을 작성하는 방법을 제공하는 경우가 종종 발생 &lt;strong&gt;합니다&lt;/strong&gt; . 매핑 된 유형에서 새 유형은 동일한 방식으로 이전 유형의 각 속성을 변환합니다. 예를 들어, 유형의 모든 속성을 &lt;code&gt;readonly&lt;/code&gt; 또는 선택적으로 만들 수 있습니다 . 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="fc63d58d10daddcb3a784f47122524cdbfabe76f" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties optional or of a type &lt;code&gt;readonly&lt;/code&gt;. Here are a couple of examples:</source>
          <target state="translated">이것은 TypeScript가 이전 유형 ( &lt;strong&gt;매핑&lt;/strong&gt; 된 유형)을 기반으로 새 유형을 생성하는 방법을 제공하는 JavaScript에서 자주 발생 &lt;strong&gt;합니다&lt;/strong&gt; . 매핑 된 유형에서 새 유형은 이전 유형의 각 속성을 동일한 방식으로 변환합니다. 예를 들어 모든 속성을 선택 사항으로 만들거나 &lt;code&gt;readonly&lt;/code&gt; 유형으로 만들 수 있습니다 . 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="b99783df1b2487790d2f6fc6e2f815d703f49e8c" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;mdash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">이것은 매우 특정한 의미를 가지고 있습니다. &lt;code&gt;done&lt;/code&gt; 콜백은 1 개의 인수로 호출되거나 2 개의 인수로 호출 될 수 있습니다. 작성자는 콜백이 &lt;code&gt;elapsedTime&lt;/code&gt; 매개 변수를 신경 쓰지 않을 수 있다고 말하려고 했지만이를 수행하기 위해 매개 변수를 선택적으로 만들 필요는 없습니다. 인수를 더 적게받는 콜백을 제공하는 것은 항상 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">이는 매우 구체적인 의미를 갖습니다. &lt;code&gt;done&lt;/code&gt; 콜백은 1 개의 인수로 호출되거나 2 개의 인수로 호출 될 수 있습니다. 저자는 아마도 콜백이 &lt;code&gt;elapsedTime&lt;/code&gt; 매개 변수를 신경 쓰지 않을 것이라고 말하려고 했지만 매개 변수를 선택적으로 만들 필요는 없습니다. 더 적은 인수를 허용하는 콜백을 제공하는 것이 항상 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">이것은 중복 정의 오류의 일반적인 원인 중 하나입니다. 인터페이스에서 동일한 멤버를 정의하는 여러 선언 파일</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">위에서 언급 한 것과 같은 문제가 있습니다. &lt;code&gt;getDistance&lt;/code&gt; 의 철자가 잘못되어 오류가 발생하지 않았습니다. 이러한 이유로 TypeScript에는 &lt;code&gt;noImplicitThis&lt;/code&gt; 옵션이 있습니다. 이 옵션을 설정하면 때, 타이프 라이터 오류를 발행합니다 &lt;code&gt;this&lt;/code&gt; 명시 적으로 (또는 추정) 타입없이 사용됩니다. 수정은 &lt;code&gt;this&lt;/code&gt; -parameter 를 사용 하여 인터페이스 또는 함수 자체에 명시 적 유형을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7f4508bf6985c57eb5ac26662f4d0528d2a5b77d" translate="yes" xml:space="preserve">
          <source>This introduction does not cover object-oriented programming. In practice, object-oriented programs in TypeScript are similar to those in other popular languages with OO features.</source>
          <target state="translated">이 소개에서는 객체 지향 프로그래밍을 다루지 않습니다. 실제로 TypeScript의 객체 지향 프로그램은 OO 기능이있는 다른 인기있는 언어의 프로그램과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="83dcbc6c7495e940551fddfd7a52d3f6c2bfa958" translate="yes" xml:space="preserve">
          <source>This introduction is designed for working Haskell or ML programmers who want to learn TypeScript. It describes how the type system of TypeScript differs from Haskell&amp;rsquo;s type system. It also describes unique features of TypeScript&amp;rsquo;s type system that arise from its modelling of JavaScript code.</source>
          <target state="translated">이 소개는 TypeScript를 배우고 싶은 Haskell 또는 ML 프로그래머를 위해 설계되었습니다. TypeScript의 유형 시스템이 Haskell의 유형 시스템과 어떻게 다른지 설명합니다. 또한 JavaScript 코드 모델링에서 발생하는 TypeScript 유형 시스템의 고유 한 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">이것은 중대한 변화입니다. 이전에는 &lt;code&gt;keyof&lt;/code&gt; 연산자와 매핑 된 유형 만 속성으로 명명 된 &lt;code&gt;string&lt;/code&gt; 만 지원했습니다 . &lt;code&gt;keyof T&lt;/code&gt; 로 입력 된 값 이 항상 &lt;code&gt;string&lt;/code&gt; 이라고 가정 한 코드 는 이제 오류로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0826ad129c5fa63f6532465e3caa896ed6cad2" translate="yes" xml:space="preserve">
          <source>This is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.</source>
          <target state="translated">이것은 JavaScript 코드베이스에서 TypeScript로 포팅되었을 수있는 기존 빌드 인프라가있는 프로젝트의 일반적인 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">이것은 &lt;code&gt;GenericNumber&lt;/code&gt; 클래스 의 문자 그대로 사용 이지만 &lt;code&gt;number&lt;/code&gt; 유형 만 사용하도록 제한하는 것은 없습니다 . 대신 &lt;code&gt;string&lt;/code&gt; 이나 더 복잡한 객체 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">이것은 합리적인 제한 때문에의 사용 &lt;code&gt;Foo&lt;/code&gt; 로 대체 될 필요가 &lt;code&gt;Foo&lt;/code&gt; 로 대체 될 필요가있는 &lt;code&gt;Foo&lt;/code&gt; 로 대체 될 필요가 &lt;code&gt;Foo&lt;/code&gt; ... 음, 잘하면 당신은 아이디어를 얻을! 결국 &lt;code&gt;Foo&lt;/code&gt; 대신에 적합한 유형이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">이는 두 개의 새로운 유형의 도입에 의해 달성된다 &lt;code&gt;CallableFunction&lt;/code&gt; 및 &lt;code&gt;NewableFunction&lt;/code&gt; 을 에서는 &lt;code&gt;lib.d.ts&lt;/code&gt; . 이 유형에는 &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 일반 함수 및 생성자 함수에 각각 &lt;code&gt;apply&lt;/code&gt; 특수한 일반 메소드 선언이 포함되어 있습니다 . 이 선언은 일반 휴식 매개 변수 (# 24897 참조)를 사용하여 매개 변수 목록을 강력한 형식으로 캡처하고 반영합니다. 에서 &lt;code&gt;--strictBindCallApply&lt;/code&gt; 모드 이러한 선언은 형에 의해 제공되는 (매우 관대 한) 선언 대신에 사용되는 &lt;code&gt;Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07d4ef20e57dcee6e52ef28b64c55fa254a3690c" translate="yes" xml:space="preserve">
          <source>This is an array spread:</source>
          <target state="translated">이것은 배열 스프레드입니다.</target>
        </trans-unit>
        <trans-unit id="0babfe78fc11f36da1fdc5ec919d6b94975c4775" translate="yes" xml:space="preserve">
          <source>This is an overloaded function definition. The second overload is simplest and works a lot like the &lt;code&gt;getElementById&lt;/code&gt; method does. Pass it any &lt;code&gt;string&lt;/code&gt; and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.</source>
          <target state="translated">이것은 오버로드 된 함수 정의입니다. 두 번째 오버로드는 가장 간단하며 &lt;code&gt;getElementById&lt;/code&gt; 메서드 와 비슷하게 작동합니다 . 임의의 &lt;code&gt;string&lt;/code&gt; 하면 표준 HTMLElement를 반환합니다. 이 정의를 통해 개발자는 고유 한 HTML 요소 태그를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e698f027e54b69d38b4a233c428be4f83585527" translate="yes" xml:space="preserve">
          <source>This is an overview, from here you should read &lt;a href=&quot;intro&quot;&gt;through the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;</source>
          <target state="translated">이것은 개요입니다. 여기 &lt;a href=&quot;intro&quot;&gt;에서 핸드북을&lt;/a&gt; 읽 거나 &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;플레이 그라운드 예제를&lt;/a&gt; 탐색해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">클래스가 인터페이스를 구현할 때 클래스의 인스턴스 측만 검사하기 때문입니다. 생성자는 정적쪽에 있으므로이 검사에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">이것을 유형 추론의 한 형태 인 &quot;문맥 입력&quot;이라고합니다. 이렇게하면 프로그램 유형을 유지하기위한 노력을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">이것은 다음 과 같이 &lt;code&gt;sentence&lt;/code&gt; 을 선언하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;다른 언어가 유형 별칭을 처리하는 방식과&lt;/a&gt; 상당히 일치 하지만 사용자가 기능을 활용하는 방법에 대한 약간 놀라운 시나리오를 유발합니다. 예를 들어 TypeScript 3.6 및 이전 버전에서는 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">충돌을 일으키지 않는 한 합법적입니다. 일반적인 경험 법칙은 값이 &lt;code&gt;namespace&lt;/code&gt; 로 선언되지 않는 한 항상 같은 이름의 다른 값과 충돌하고, 유형 별칭 선언 ( &lt;code&gt;type s = string&lt;/code&gt; ) 으로 선언 된 경우 유형이 충돌 하며 네임 스페이스는 절대로 충돌하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">이것은 더 이상 사실이 아닙니다-TypeScript는 이제 클래스의 인스턴스 메소드 내부에서 &lt;code&gt;this&lt;/code&gt; 라고 불리는 특별한 유형을 갖도록 유추 &lt;code&gt;this&lt;/code&gt; . &lt;code&gt;this&lt;/code&gt; 유형도록 작성 기본적 &quot;메소드 호출의 도트 왼쪽의 형태&quot;를 의미한다.</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">이것이 현재 MSBuild 프로젝트의 기본값입니다. 이렇게하면 출력이 클린 빌드에서만 생성되므로 MSBuild 증분 빌드가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="17ee6c7a17ecddf72cfa4cd21d7420a20690b42c" translate="yes" xml:space="preserve">
          <source>This is often what people expect, but it&amp;rsquo;s not 100% compliant with ECMAScript iteration protocol. Certain strings, such as emoji (😜), have a &lt;code&gt;.length&lt;/code&gt; of 2 (or even more!), but should iterate as 1 unit in a &lt;code&gt;for-of&lt;/code&gt; loop. See &lt;a href=&quot;https://blog.jonnew.com/posts/poo-dot-length-equals-two&quot;&gt;this blog post by Jonathan New&lt;/a&gt; for a longer explanation.</source>
          <target state="translated">이것은 종종 사람들이 기대하는 것이지만 ECMAScript 반복 프로토콜과 100 % 호환되지는 않습니다. 그림 이모티콘 (😜)과 같은 특정 문자열은 &lt;code&gt;.length&lt;/code&gt; 가 2 (또는 그 이상!)이지만 &lt;code&gt;for-of&lt;/code&gt; 루프 에서 1 단위로 반복되어야 합니다. 자세한 설명 &lt;a href=&quot;https://blog.jonnew.com/posts/poo-dot-length-equals-two&quot;&gt;은 Jonathan New의이 블로그 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;--noImplicitAny&lt;/code&gt; 가 설정된 경우에만 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">이것은 소비자에게 최적입니다. 그들은 당신 이 원하는대로 당신의 유형의 이름을 지정할 수 있습니다 ( 이 경우에는 &lt;code&gt;t&lt;/code&gt; ). 물체를 찾기 위해 과도한 도팅을 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">이것은 여전히 ​​TypeScript 3.3에서 훨씬 더 강력하며 명시 적 유형 주석을 추가하면 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">사용자가 인터페이스를 도입하여 동일한 코드를 효과적으로 작성할 수 있다는 점에서 기술적으로 아무런 문제가 없기 때문에 이상합니다.</target>
        </trans-unit>
        <trans-unit id="a85985f698519bc5006290fca9b3c770afc4331a" translate="yes" xml:space="preserve">
          <source>This is to reflect the same flag in Node.js; which does not resolve the real path of symlinks.</source>
          <target state="translated">이것은 Node.js에서 동일한 플래그를 반영하기위한 것입니다. 심볼릭 링크의 실제 경로를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">이것은 타입 시스템 관점에서는 좋지 않지만 런타임 관점에서는 일반적으로 해당 위치에 &lt;code&gt;undefined&lt;/code&gt; 를 전달 하는 것이 대부분의 함수에 해당 하므로 선택적 매개 변수에 대한 아이디어는 제대로 적용 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">상속 계층 구조가 크지 만 코드가 특정 속성이있는 서브 클래스에서만 작동하도록 지정하려는 경우에 유용합니다. 서브 클래스는 기본 클래스에서 상속하는 것 외에 관련 될 필요가 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edfa7337b75e8a1603e456ce30e9130e6824a45e" translate="yes" xml:space="preserve">
          <source>This is useful when you only have a small number of files and don&amp;rsquo;t need to use a glob to reference many files. If you need that then use &lt;a href=&quot;#include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 파일 수가 적고 많은 파일을 참조하기 위해 glob을 사용할 필요가 없을 때 유용합니다. 필요한 경우 &lt;a href=&quot;#include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c743dac20c102f17500a10837b687c3c8b807f9f" translate="yes" xml:space="preserve">
          <source>This is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;homepage&lt;/a&gt; has a list of editors which have TypeScript plugins.</source>
          <target state="translated">이것은 TypeScript를 사용하는 편집기를 사용하여 자동 완성, 기호로 이동 및 이름 바꾸기와 같은 리팩토링 도구와 같은 도구를 제공하는 경우입니다. &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;홈페이지는&lt;/a&gt; 타이프 라이터 플러그인이 편집자의 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f5993fdefbd1dda848027db50f46bbc6c1c3844" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the sort of code you would want in your codebase however.</source>
          <target state="translated">그러나 이것은 코드베이스에서 원하는 종류의 코드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">이러한 종류의 반복자는 배열의 요소 또는 맵의 키와 같이 동 기적으로 사용 가능한 값을 반복하는 데 유용합니다. 반복을 지원하는 객체 는 &lt;code&gt;Iterator&lt;/code&gt; 객체 를 반환하는 &lt;code&gt;Symbol.iterator&lt;/code&gt; 메서드 가있는 경우 &quot;반복 가능&quot;하다고 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e9d1d03b4a1362369564c77ee95ce233702dd8" translate="yes" xml:space="preserve">
          <source>This lets your &lt;code&gt;tsconfig.json&lt;/code&gt; focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we&amp;rsquo;re hoping the community can add more for different environments.</source>
          <target state="translated">이렇게하면 &lt;code&gt;tsconfig.json&lt;/code&gt; 이 모든 런타임 메커니즘이 아닌 프로젝트의 고유 한 선택에 집중할 수 있습니다 . 이미 몇 가지 tsconfig 기반이 있으며 커뮤니티가 다른 환경에 대해 더 많은 것을 추가 할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="5bd6b551c716ce479c9efb44f5745eec1d50b86b" translate="yes" xml:space="preserve">
          <source>This list may be out of date, you can see the full list in the &lt;a href=&quot;https://github.com/microsoft/TypeScript/tree/master/lib&quot;&gt;TypeScript source code&lt;/a&gt;.</source>
          <target state="translated">이 목록은 오래되었을 수 있으며 &lt;a href=&quot;https://github.com/microsoft/TypeScript/tree/master/lib&quot;&gt;TypeScript 소스 코드&lt;/a&gt; 에서 전체 목록을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffa1d11a7b7e51ebc3e166a5662abdb4c99a2fdc" translate="yes" xml:space="preserve">
          <source>This makes room for another tool like &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt;, or &lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt; to handle converting the TypeScript file to a file which can run inside a JavaScript environment.</source>
          <target state="translated">이렇게하면 &lt;a href=&quot;https://babeljs.io&quot;&gt;Babel&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/swc-project/swc&quot;&gt;swc&lt;/a&gt; 와 같은 다른 도구 가 TypeScript 파일을 JavaScript 환경 내에서 실행할 수있는 파일로 변환 할 수있는 공간이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">혼란스러워 보일 수 있지만 지나치게 과부하가 걸리지 않는 한 실제로 매우 편리합니다. 이 결합 동작의 유용한 측면을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="acc607e6369c64f4e86ed2006f7e56509541116e" translate="yes" xml:space="preserve">
          <source>This may seem surprising, but it&amp;rsquo;s ultimately a very similar relationship to one enforced in nominal OOP languages. A subclass cannot &lt;em&gt;remove&lt;/em&gt; a property of its base class, because doing so would destroy the natural subtype relationship between the derived class and its base. Structural type systems simply identify this relationship implicitly by describing subtypes in terms of having properties of compatible types.</source>
          <target state="translated">이것은 놀랍게 보일 수 있지만 궁극적으로 명목 OOP 언어에서 시행되는 것과 매우 유사한 관계입니다. 하위 클래스는 기본 클래스의 속성을 &lt;em&gt;제거&lt;/em&gt; 할 수 없습니다. 그렇게하면 파생 클래스와 해당 기본 간의 자연적인 하위 유형 관계가 파괴되기 때문입니다. 구조적 유형 시스템은 호환 가능한 유형의 속성을 갖는 측면에서 하위 유형을 설명하여이 관계를 암시 적으로 식별합니다.</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">이것은 JSON을 나타내는 다음과 같은 코드를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="935744b5a109e03d6e5fdd0bc4f2ed2b0d65c339" translate="yes" xml:space="preserve">
          <source>This means that having a file like &lt;code&gt;jquery.js&lt;/code&gt; in your project would not automatically download the types for JQuery from DefinitelyTyped.</source>
          <target state="translated">즉, 프로젝트에 &lt;code&gt;jquery.js&lt;/code&gt; 와 같은 파일이 있으면 DefinitelyTyped에서 JQuery 유형을 자동으로 다운로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbc1af0b95468e7c0be508ef7ed287acbbf8bf7a" translate="yes" xml:space="preserve">
          <source>This means that if you move code from JavaScript to TypeScript, it is &lt;strong&gt;guaranteed&lt;/strong&gt; to run the same way, even if TypeScript thinks that the code has type errors.</source>
          <target state="translated">당신은 타이프 라이터로 자바 스크립트에서 코드를 이동하는 경우이 방법, 것을 &lt;strong&gt;보장&lt;/strong&gt; 타이프 코드 유형의 오류가 있다고 생각하는 경우에도 같은 방법을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">이것은 공용체 유형과 &lt;code&gt;instanceof&lt;/code&gt; 가 구조적으로 동일한 클래스를 올바르게 구별 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">이것은 다른 모듈과 라이브러리를 조건부로 그리고 게으르게 가져올 수 있음을 의미합니다. 예를 들어 다음은 필요할 때만 유틸리티 라이브러리를 가져 오는 &lt;code&gt;async&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="43b4176bbe758e3980ce4c378a5b0c74800846b0" translate="yes" xml:space="preserve">
          <source>This means that your comments will show up in the JavaScript code.</source>
          <target state="translated">이는 귀하의 의견이 JavaScript 코드에 표시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="524598ce79eaafea873d07fe2c5f1daf5dd60c42" translate="yes" xml:space="preserve">
          <source>This means that your existing working JavaScript code is also TypeScript code. The main benefit of TypeScript is that it can highlight unexpected behavior in your code, lowering the chance of bugs.</source>
          <target state="translated">이는 기존의 작동 JavaScript 코드도 TypeScript 코드임을 의미합니다. TypeScript의 주요 이점은 코드에서 예기치 않은 동작을 강조하여 버그 발생 가능성을 낮출 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="33df278507c445ec5629c94f1025fbe3e4d0c772" translate="yes" xml:space="preserve">
          <source>This method works similarly to the &lt;code&gt;createElement&lt;/code&gt; method as the generic parameter &lt;code&gt;T&lt;/code&gt; is inferred from the &lt;code&gt;newChild&lt;/code&gt; argument. &lt;code&gt;T&lt;/code&gt; is &lt;em&gt;constrained&lt;/em&gt; to another base interface &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">이 메서드 는 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;newChild&lt;/code&gt; 인수 에서 유추 되므로 &lt;code&gt;createElement&lt;/code&gt; 메서드 와 유사하게 작동합니다 . &lt;code&gt;T&lt;/code&gt; 는 다른 기본 인터페이스 &lt;code&gt;Node&lt;/code&gt; 로&lt;em&gt;제한&lt;/em&gt; 됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57b9c67d02646774dbf2986763ff463559dd77f1" translate="yes" xml:space="preserve">
          <source>This mis-match causes these two issues:</source>
          <target state="translated">이 불일치로 인해 다음 두 가지 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">이 모드는 라이브러리 내에서 라이브러리가 선언 한 전역을 모듈 내에서도 항상 사용할 수있는 타사 라이브러리를 혼합하고 일치시킬 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">이 네임 스페이스 병합 모델은 시작하기에 유용하지만 내 보내지 않은 멤버의 상황을 이해해야합니다. 내 보내지 않은 멤버는 병합되지 않은 원래 네임 스페이스에서만 볼 수 있습니다. 이는 병합 후 다른 선언에서 가져온 병합 멤버는 내 보내지 않은 멤버를 볼 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">이 새로운 동작은 공용체에서 최대 하나의 유형에 여러 개의 과부하가 있고 공용체에서 최대 하나의 형식에 일반 서명이있는 경우에만 시작됩니다. 즉, &lt;code&gt;number[] | string[]&lt;/code&gt; &lt;code&gt;map&lt;/code&gt; 과 같은 string [] 은 여전히 ​​호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">이 새로운 완화 기능을 통해 튜플의 유형 별칭을 재귀 적으로 참조 할 수도 있습니다. 오류에 사용 된 다음 코드는 이제 유효한 TypeScript 코드입니다.</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">이 이상한 패턴은 실제로 꽤 일반적입니다. &lt;code&gt;i&lt;/code&gt; 매개 변수 목록에서 실제로 그림자 &lt;code&gt;i&lt;/code&gt; 선언 &lt;code&gt;for&lt;/code&gt; 루프,하지만 우리는 그들에게 같은 이름 때문에, 우리는 너무 많은 루프 본문을 수정하지 않았다.</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">이것은 종종 코드를 작성하는 매우 우아한 방법을 열어줍니다. 그러나 &lt;code&gt;BasicCalculator&lt;/code&gt; 에서 확장하려는 클래스에는 문제가 있었습니다 . 사용자가 &lt;code&gt;ScientificCalculator&lt;/code&gt; 작성을 시작하려고한다고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">&lt;em&gt;명시 적&lt;/em&gt; 문자열 인덱스 서명 이있는 유형에만 적용됩니다 . 를 사용하여 유형의 알 수없는 속성에 액세스하는 것은 여전히 ​​오류 &lt;code&gt;.&lt;/code&gt; 표기법.</target>
        </trans-unit>
        <trans-unit id="8eb687938c9fb814d547d871195ddff75c8d4f13" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/** @jsx h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#custom&quot;&gt;Babel의 &lt;code&gt;/** @jsx h */&lt;/code&gt; 지시어&lt;/a&gt; 와 너무 유사한 파일 단위로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdba5f3f1154fdf39f0e94523953d163115e35ae" translate="yes" xml:space="preserve">
          <source>This option can be used on a per-file basis too similar to &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments&quot;&gt;Babel&amp;rsquo;s &lt;code&gt;/* @jsxFrag h */&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#fragments&quot;&gt;Babel의 &lt;code&gt;/* @jsxFrag h */&lt;/code&gt; 지시어&lt;/a&gt; 와 너무 유사한 파일 단위로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6106ecf0ac5a2b09e236e72c0e2cedcd5d1ae862" translate="yes" xml:space="preserve">
          <source>This option can only be used from the CLI via: &lt;code&gt;--generateCpuProfile tsc-output.cpuprofile&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 다음을 통해 CLI에서만 사용할 수 있습니다. &lt;code&gt;--generateCpuProfile tsc-output.cpuprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c327bf1c9c3b71c013b7f4a7d7fedc6e7d7f8e7" translate="yes" xml:space="preserve">
          <source>This option does not affect how &lt;code&gt;@types/*&lt;/code&gt; are included in your application code, for example if you had the above &lt;code&gt;compilerOptions&lt;/code&gt; example with code like:</source>
          <target state="translated">이 옵션은 &lt;code&gt;@types/*&lt;/code&gt; 가 애플리케이션 코드에 포함되는 방식에 영향을주지 않습니다. 예를 들어 다음과 같은 코드 가있는 위 &lt;code&gt;compilerOptions&lt;/code&gt; 예제 가있는 경우</target>
        </trans-unit>
        <trans-unit id="57239aa523124655738236cda5cd80c7601972ef" translate="yes" xml:space="preserve">
          <source>This option gives you the chance to have TypeScript emit a v8 CPU profile during the compiler run. The CPU profile can provide insight into why your builds may be slow.</source>
          <target state="translated">이 옵션을 사용하면 컴파일러 실행 중에 TypeScript가 v8 CPU 프로필을 내보내도록 할 수 있습니다. CPU 프로필은 빌드가 느린 이유에 대한 통찰력을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">이 옵션은 비슷합니다 &lt;code&gt;UseFsEvents&lt;/code&gt; 사용하여 시계를 만드는 데 실패 제외 &lt;code&gt;fs.watch&lt;/code&gt; 을 시청 대체가 (에 설명 된대로 동적 폴링 대기열을 통해 발생 &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8d193ba5c4532991da9bb0f8500297f04dae9a97" translate="yes" xml:space="preserve">
          <source>This option offers a way to configure the place where TypeScript keeps track of the files it stores on the disk to indicate a project&amp;rsquo;s build state &amp;mdash; by default, they are in the same folder as your emitted JavaScript.</source>
          <target state="translated">이 옵션은 TypeScript가 프로젝트의 빌드 상태를 나타 내기 위해 디스크에 저장하는 파일을 추적하는 위치를 구성하는 방법을 제공합니다. 기본적으로 파일은 내 보낸 JavaScript와 동일한 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">이 옵션은 &lt;code&gt;fs.watch&lt;/code&gt; (파일 시스템 이벤트 사용)로 파일 의 상위 디렉토리를 감시 하므로 CPU가 적지 만 정확성을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc504c6e0f3c053460e82d0c935b1ef42c4c0ed5" translate="yes" xml:space="preserve">
          <source>This page covers all of the different flags available inside a TSConfig file. It starts with an overview of every flag, then moves into the root attributes in the JSON file, then the &lt;code&gt;compilerOptions&lt;/code&gt; which are the bulk of the options and wraps up with &lt;code&gt;watchOptions&lt;/code&gt;.</source>
          <target state="translated">이 페이지는 TSConfig 파일 내에서 사용할 수있는 모든 다른 플래그를 다룹니다. 그것은 모든 플래그의 개요로 시작, 다음 다음 JSON 파일의 루트 속성의로 이동 &lt;code&gt;compilerOptions&lt;/code&gt; 옵션의 대부분이며, 함께 랩 &lt;code&gt;watchOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c7ae2cfaba7b6eecc420557a0116e17b9d17b15" translate="yes" xml:space="preserve">
          <source>This page lists some of the more advanced ways in which you can model types, it works in tandem with the &lt;a href=&quot;utility-types&quot;&gt;Utility Types&lt;/a&gt; doc which includes types which are included in TypeScript and available globally.</source>
          <target state="translated">이 페이지에는 유형을 모델링 할 수있는 몇 가지 고급 방법이 나열 되어 있으며 TypeScript에 포함되고 전역 적으로 사용 가능한 유형을 포함 하는 &lt;a href=&quot;utility-types&quot;&gt;유틸리티 유형&lt;/a&gt; 문서 와 함께 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e58c92c51ad6f1ff869baee49d21faa7424e2034" translate="yes" xml:space="preserve">
          <source>This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.</source>
          <target state="translated">이 패턴은 컴파일러에 덜 의존하고 코드베이스에 더 많이 의존하여 런타임과 유형 시스템이 모두 동기화 상태로 올바르게 유지되도록합니다.</target>
        </trans-unit>
        <trans-unit id="e01e7dba8069ec2ba7bcc3ad7e5d0d4b677661b1" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using modules and namespaces in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">이 게시물은 TypeScript의 모듈과 네임 스페이스를 사용하여 코드를 구성하는 다양한 방법에 대해 설명합니다. 또한 네임 스페이스와 모듈을 사용하는 방법에 대한 몇 가지 고급 주제를 살펴보고 TypeScript에서 사용할 때 일반적인 함정을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">이 게시물에서는 TypeScript에서 네임 스페이스 (이전의 &quot;내부 모듈&quot;)를 사용하여 코드를 구성하는 다양한 방법을 간략하게 설명합니다. 용어에 대한 언급에서 언급했듯이&amp;ldquo;내부 모듈&amp;rdquo;은 이제&amp;ldquo;네임 스페이스&amp;rdquo;라고합니다. 또한 내부 모듈을 선언 할 때 &lt;code&gt;module&lt;/code&gt; 키워드가 사용 된 모든 위치 에서 &lt;code&gt;namespace&lt;/code&gt; 키워드를 대신 사용할 수 있으며 사용해야합니다. 이렇게하면 비슷한 이름의 용어로 새 사용자를 오버로드하여 혼동을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">이 게시물에서는 TypeScript에서 네임 스페이스와 모듈을 사용하여 코드를 구성하는 다양한 방법을 간략하게 설명합니다. 또한 네임 스페이스와 모듈을 사용하는 방법에 대한 고급 주제를 다루고 TypeScript에서 네임 스페이스와 모듈을 사용할 때의 일반적인 함정을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">이것은 간단한 진입 점을 제공합니다. 예를 들어 TypeScript 저장소 에서는 &lt;code&gt;src/tsconfig.json&lt;/code&gt; 에 모든 하위 프로젝트를 나열하기 때문에 &lt;code&gt;tsc -b src&lt;/code&gt; 를 실행 하여 모든 엔드 포인트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">이것은 소비 코드를 파괴 할 수있는 좋은 기회입니다.</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">이 빠른 시작 가이드는 방법으로 타이프 라이터를 구축하는 방법을 가르 칠 것입니다 &lt;a href=&quot;http://gulpjs.com&quot;&gt;꿀꺽&lt;/a&gt; 하고 추가 &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt; , &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;추하게&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify을&lt;/a&gt; 꿀꺽 파이프 라인. 이 안내서는 &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify를&lt;/a&gt; 사용하여 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 기능 을 추가하는 방법도 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">이 해결 전략 은 런타임시 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 모듈 확인 메커니즘 을 모방하려고 합니다. 전체 Node.js 분석 알고리즘은 &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js 모듈 문서에&lt;/a&gt; 요약되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87bf34158eb20c72cb4fd37812305a408c19d43a" translate="yes" xml:space="preserve">
          <source>This restriction doesn&amp;rsquo;t apply to &lt;code&gt;.d.ts&lt;/code&gt; files</source>
          <target state="translated">이 제한은 &lt;code&gt;.d.ts&lt;/code&gt; 파일 에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">결과적으로 생성 된 JS</target>
        </trans-unit>
        <trans-unit id="6111a68e7f42d3cedbb929558c29d3873d82bb3c" translate="yes" xml:space="preserve">
          <source>This sample code:</source>
          <target state="translated">이 샘플 코드 :</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">이 섹션에서는 모듈에 대한 기본 지식이 있다고 가정합니다. 자세한 내용은 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="349a068c7f9dd73c8443e8d5def76fa3544a4bfe" translate="yes" xml:space="preserve">
          <source>This set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find &lt;a href=&quot;../type-checking-javascript-files#supported-jsdoc&quot;&gt;the reference here&lt;/a&gt;.</source>
          <target state="translated">이 설정은 프로젝트를 TypeScript로 이식하거나 코드베이스에 .d.ts 파일을 유지하지 않고도 TypeScript 기반 편집기의 편집기 환경을 소유 할 수 있음을 의미합니다. TypeScript는 대부분의 JSDoc 태그를 지원하며 &lt;a href=&quot;../type-checking-javascript-files#supported-jsdoc&quot;&gt;여기에서 참조를&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2e978dce6e27d24e2aafb780acc90f0cc8b6fb6" translate="yes" xml:space="preserve">
          <source>This setting is useful in two cases:</source>
          <target state="translated">이 설정은 다음 두 가지 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3bd3157d320740251f355d5814d6ffa211bfc011" translate="yes" xml:space="preserve">
          <source>This setting lets you specify a file for storing incremental compilation information as a part of composite projects which enables faster building of larger TypeScript codebases. You can read more about composite projects &lt;a href=&quot;docs/handbook/project-references&quot;&gt;in the handbook&lt;/a&gt;.</source>
          <target state="translated">이 설정을 사용하면 더 큰 TypeScript 코드베이스를 더 빠르게 빌드 할 수있는 복합 프로젝트의 일부로 증분 컴파일 정보를 저장하기위한 파일을 지정할 수 있습니다. &lt;a href=&quot;docs/handbook/project-references&quot;&gt;핸드북에서&lt;/a&gt; 복합 프로젝트 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">이것들이 참조하는 값이 &lt;em&gt;불변&lt;/em&gt; 이라는 생각과 혼동되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">이 간단한 예제는 가져 오기 및 내보내기 중에 사용 된 이름이 모듈로드 코드로 변환되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="acb7a478bd6024141f079e21fce02f772fec3fbc" translate="yes" xml:space="preserve">
          <source>This syntactically-legal program prints &lt;code&gt;Infinity&lt;/code&gt;. TypeScript, though, considers division of number by an array to be a nonsensical operation, and will issue an error:</source>
          <target state="translated">이 구문 론적 합법적 프로그램은 &lt;code&gt;Infinity&lt;/code&gt; 를 인쇄합니다 . 그러나 TypeScript는 배열로 숫자를 나누는 작업을 무의미한 작업으로 간주하고 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f0d828b3379cd2b4debebfb5ffcff651af177e54" translate="yes" xml:space="preserve">
          <source>This syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields&quot;&gt;release notes&lt;/a&gt;.</source>
          <target state="translated">이 구문은 자바 스크립트 런타임에 내장되어 있으며 각 비공개 필드의 격리에 대해 더 나은 보장을 제공 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 현재 이러한 비공개 필드에 대한 최고의 문서는 TypeScript 3.8 &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#ecmascript-private-fields&quot;&gt;릴리스 노트에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1008cf885d8164f0c0972e2e3403d26e6889f71" translate="yes" xml:space="preserve">
          <source>This takes all of the dependencies from a module and makes it an exported field, you could import it like this:</source>
          <target state="translated">모듈에서 모든 종속성을 가져 와서 내 보낸 필드로 만듭니다. 다음과 같이 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2adafebdcb218187a19ac5c230d995b12afd1bc7" translate="yes" xml:space="preserve">
          <source>This technique is a hybrid approach, using Babel&amp;rsquo;s &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-typescript&quot;&gt;preset-typescript&lt;/a&gt; to generate your JS files, and then using TypeScript to do type checking and &lt;code&gt;.d.ts&lt;/code&gt; file generation.</source>
          <target state="translated">이 기술은 Babel의 &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-typescript&quot;&gt;사전 설정 유형 스크립트&lt;/a&gt; 를 사용하여 JS 파일을 생성 한 다음 TypeScript를 사용하여 유형 검사 및 &lt;code&gt;.d.ts&lt;/code&gt; 파일 생성 을 수행 하는 하이브리드 접근 방식 입니다.</target>
        </trans-unit>
        <trans-unit id="83f579bee1621a210e4228f42fa55f672b307fc3" translate="yes" xml:space="preserve">
          <source>This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file&amp;rsquo;s location. For example &lt;code&gt;./src/index.ts&lt;/code&gt; can import the file &lt;code&gt;./src/css/main.css&lt;/code&gt; and TypeScript will be aware of the bundler&amp;rsquo;s behavior for that filetype via the corresponding generated declaration file.</source>
          <target state="translated">이 기술을 사용하면 코드가 아닌 소스 파일에 대한 유형을 미리 생성 할 수 있습니다. 그런 다음 가져 오기는 소스 파일의 위치에 따라 자연스럽게 작동합니다. 예를 들어 &lt;code&gt;./src/index.ts&lt;/code&gt; 이 파일 가져올 수 있습니다 &lt;code&gt;./src/css/main.css&lt;/code&gt; 을 하고 타이프는 해당 생성 선언 파일을 통해 해당 파일 형식에 대한 들러의 행동을 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">이것은 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 패턴과 일치하는 모든 모듈 임포트 (즉, 모든 값)에 대해 컴파일러에게 두 위치를 찾도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">클래스를 인터페이스로 취급하고 Disposable 및 Activatable 뒤에있는 유형 만 구현이 아닌 SmartObject 유형으로 혼합합니다. 이것은 우리가 수업에서 구현을 제공해야 함을 의미합니다. 제외하고는 믹스 인을 사용하여 피하고 싶은 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c25450c61dcd13ee0d8fae944687b4f32fa002e" translate="yes" xml:space="preserve">
          <source>This tutorial provides a brief overview of TypeScript, focusing on its type system.</source>
          <target state="translated">이 튜토리얼은 타입 시스템에 초점을 맞춘 TypeScript에 대한 간략한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">이것은 TypeScript의 기본 해결 전략이었습니다. 오늘날이 전략은 주로 이전 버전과의 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="93a8071076c50e947fcd54554c47e1e5fc4fac05" translate="yes" xml:space="preserve">
          <source>This uses &lt;a href=&quot;../../declaration-merging&quot;&gt;declaration merging&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;../../declaration-merging&quot;&gt;선언 병합을&lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f1cd525962f56ec03ce869171a31b0c1c0befaf8" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;a href=&quot;functions#this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">이 유틸리티는 변환 된 유형을 리턴하지 않습니다. 대신 &lt;a href=&quot;functions#this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; 유형 의 문맥에 대한 마커 역할을합니다 . 있습니다 &lt;code&gt;--noImplicitThis&lt;/code&gt; 플래그가이 유틸리티를 사용하도록 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">이 유틸리티는 변환 된 유형을 반환하지 않습니다. 대신, &lt;code&gt;this&lt;/code&gt; 유형 의 상황에 대한 마커 역할을합니다 . 있습니다 &lt;code&gt;--noImplicitThis&lt;/code&gt; 플래그가이 유틸리티를 사용하도록 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="84c1c214044cdc8f4303327fab0eacb4bcad4a14" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">이 유틸리티는 런타임에 실패 할 할당 표현식을 나타내는 데 유용합니다 (즉, &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;고정 된 객체의&lt;/a&gt; 속성을 다시 할당하려고 할 때 ).</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">이 유틸리티는 런타임시 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;고정 된 객체의&lt;/a&gt; 속성을 재 할당하려는 경우) 할당 식을 나타내는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">내부 루프이기 때문에 루프의이 버전은 실제로 제대로 요약을 수행합니다 &lt;code&gt;i&lt;/code&gt; 그림자 &lt;code&gt;i&lt;/code&gt; 외부 루프에서.</target>
        </trans-unit>
        <trans-unit id="8382d7d850d9a5a4ffcaae61d648e575486c6e4e" translate="yes" xml:space="preserve">
          <source>This was a brief overview of the syntax and tools used in everyday TypeScript. From here, you can:</source>
          <target state="translated">이것은 일상적인 TypeScript에서 사용되는 구문과 도구에 대한 간략한 개요입니다. 여기에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">이것은 화살표 함수가 &lt;code&gt;this&lt;/code&gt; 를 사용하기 때문에 작동하므로 항상 &lt;code&gt;this: void&lt;/code&gt; 기대하는 것에 전달할 수 있습니다 : void . 단점은 Handler 유형의 오브젝트마다 하나의 화살표 함수가 작성된다는 것입니다. 반면에 메소드는 한 번만 작성되어 핸들러의 프로토 타입에 첨부됩니다. Handler 유형의 모든 오브젝트간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">이것은 TypeScript에서도 잘 작동하지만 컴파일러는 &lt;code&gt;Observable.prototype.map&lt;/code&gt; 에 대해 알지 못합니다 . 모듈 기능 보강을 사용하여 컴파일러에 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">이것은 충분히 잘 작동하지만 &lt;code&gt;SomeType&lt;/code&gt; 과 &lt;code&gt;SomeVar&lt;/code&gt; 는 이름이 같도록 밀접하게 관련되어 있다고 상상할 수 있습니다 . 우리는 결합을 사용하여 동일한 이름 &lt;code&gt;Bar&lt;/code&gt; 아래에있는 두 가지 다른 객체 (값과 유형)를 제시 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b919e153a19bd055003acaa3a57d606c66fa69e5" translate="yes" xml:space="preserve">
          <source>This would allow you to be able to write &lt;code&gt;import &quot;jquery&quot;&lt;/code&gt;, and get all of the correct typing locally.</source>
          <target state="translated">이렇게하면 &lt;code&gt;import &quot;jquery&quot;&lt;/code&gt; 를 작성 하고 모든 올바른 입력을 로컬에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57eefd52c82d3d36b6718a0eea84949e73f282d" translate="yes" xml:space="preserve">
          <source>This would have the following &lt;code&gt;.d.ts&lt;/code&gt; equivalent:</source>
          <target state="translated">이것은 다음과 같은 &lt;code&gt;.d.ts&lt;/code&gt; 를 가질 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">권장되지는 않지만 일부 모듈은 다른 모듈에서 사용할 수있는 일부 전역 상태를 설정합니다. 이 모듈에는 수출이 없거나 소비자가 수출에 관심이 없습니다. 이 모듈을 가져 오려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">따라서 다음 호출은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="789b874f65900275e1feb81853ccba2146efe3f2" translate="yes" xml:space="preserve">
          <source>To add creation of .d.ts files in your project, you will need to do up-to four steps:</source>
          <target state="translated">프로젝트에 .d.ts 파일 생성을 추가하려면 최대 4 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">반환 된 값과 생성 된 값을 구별 할 수 있도록 TypeScript 3.6은 &lt;code&gt;IteratorResult&lt;/code&gt; 형식을 구별 된 공용체 형식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dab773ebdeb56f5d4d302abac7504ce08a873ba8" translate="yes" xml:space="preserve">
          <source>To avoid a possible memory bloat issues when working with very large JavaScript projects, there is an upper limit to the amount of memory TypeScript will allocate. Turning this flag on will remove the limit.</source>
          <target state="translated">매우 큰 JavaScript 프로젝트로 작업 할 때 가능한 메모리 팽창 문제를 방지하기 위해 TypeScript가 할당 할 메모리 양에 대한 상한이 있습니다. 이 플래그를 켜면 제한이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">JavaScript에서와 마찬가지로 TypeScript 함수는 명명 된 함수 또는 익명 함수로 만들 수 있습니다. 이를 통해 API에서 함수 목록을 작성하든 일회성 함수를 사용하여 다른 함수로 전달하든 애플리케이션에 가장 적합한 접근 방식을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;y&lt;/code&gt; 에 할당 가능한지 확인하기 위해 먼저 매개 변수 목록을 봅니다. &lt;code&gt;x&lt;/code&gt; 의 각 매개 변수 는 호환 가능한 유형의 &lt;code&gt;y&lt;/code&gt; 에 해당 매개 변수가 있어야합니다 . 매개 변수의 이름은 해당 유형 만 고려되지 않습니다. 이 경우 &lt;code&gt;x&lt;/code&gt; 의 모든 매개 변수는 &lt;code&gt;y&lt;/code&gt; 의 해당하는 호환 가능한 매개 변수를 가지므로 할당이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 에 할당 될 수 있는지 확인하기 위해 컴파일러는 &lt;code&gt;x&lt;/code&gt; 의 각 속성을 검사 하여 &lt;code&gt;y&lt;/code&gt; 에서 해당하는 호환 가능한 속성을 찾습니다 . 이 경우 &lt;code&gt;y&lt;/code&gt; 에는 문자열 인 &lt;code&gt;name&lt;/code&gt; 이라는 멤버가 있어야 합니다. 그렇게하므로 할당이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">컴파일하려면 명령 행에 모듈 대상을 지정해야합니다. Node.js의 경우 &lt;code&gt;--module commonjs&lt;/code&gt; 를 사용하십시오 . require.js의 경우 &lt;code&gt;--module amd&lt;/code&gt; 를 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bd0f12b21d35f79d32b5a8c2a9e7ab064c0bb0a" translate="yes" xml:space="preserve">
          <source>To control which folders you want to the files to be built to, use the config option &lt;a href=&quot;#tsBuildInfoFile&quot;&gt;&lt;code&gt;tsBuildInfoFile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일을 빌드 할 폴더를 제어하려면 구성 옵션 &lt;a href=&quot;#tsBuildInfoFile&quot;&gt; &lt;code&gt;tsBuildInfoFile&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">nextScript &lt;code&gt;next()&lt;/code&gt; 호출에서 생성자로 전달 될 수있는 유형을 올바르게 나타 내기 위해 TypeScript 3.6 은 생성기 함수 본문 내에서 특정 &lt;code&gt;yield&lt;/code&gt; 사용을 유추 합니다.</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">타입 가드를 정의하려면 반환 타입이 &lt;em&gt;타입 술어&lt;/em&gt; 인 함수를 정의하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">인터페이스로 함수 유형을 설명하기 위해 인터페이스에 호출 서명을 제공합니다. 이것은 매개 변수 목록과 반환 유형 만 제공된 함수 선언과 같습니다. 매개 변수 목록의 각 매개 변수에는 이름과 유형이 모두 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">TypeScript로 작성되지 않은 라이브러리의 모양을 설명하려면 라이브러리가 노출하는 API를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">TypeScript로 작성되지 않은 라이브러리의 모양을 설명하려면 라이브러리가 노출하는 API를 선언해야합니다. 대부분의 JavaScript 라이브러리는 소수의 최상위 개체 만 노출하므로 네임 스페이스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">접근 자 관련 문제를 감지하기 위해 TypeScript 3.7에서는 이제 &lt;code&gt;.d.ts&lt;/code&gt; 파일 에서 접근 자 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 접근 자를 내보내 므로 TypeScript에서 재정의 된 접근자를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">이를 위해 제약 조건을 설명하는 인터페이스를 만듭니다. 여기에서는 단일 &lt;code&gt;.length&lt;/code&gt; 속성이있는 인터페이스를 만든 다음이 인터페이스와 &lt;code&gt;extends&lt;/code&gt; 키워드를 사용하여 제약 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">이를 위해서는 입력 파일 목록과 모든 컴파일 설정을 포함하는 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 작성해야합니다 . &lt;code&gt;tsconfig.json&lt;/code&gt; 이라는 프로젝트 루트에 새 파일을 작성하고 다음 내용으로 채우십시오.</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">데코레이터에 대한 실험 지원을 활성화하려면 명령 행 또는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;experimentalDecorators&lt;/code&gt; 컴파일러 옵션을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">위에서 설명한 재귀 유형 별칭 패턴을 활성화하기 위해 &lt;code&gt;typeArguments&lt;/code&gt; 속성이 &lt;code&gt;TypeReference&lt;/code&gt; 인터페이스 에서 제거되었습니다 . 대신 &lt;code&gt;TypeChecker&lt;/code&gt; 인스턴스 에서 &lt;code&gt;getTypeArguments&lt;/code&gt; 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">기호를 고유 리터럴로 취급 할 수 있도록 새로운 유형의 &lt;code&gt;unique symbol&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;unique symbol&lt;/code&gt; 의 하위 유형 인 &lt;code&gt;symbol&lt;/code&gt; , 만 호출에서 생산되는 &lt;code&gt;Symbol()&lt;/code&gt; 또는 &lt;code&gt;Symbol.for()&lt;/code&gt; , 또는 명시 적 유형의 주석에서. 새 유형은 &lt;code&gt;const&lt;/code&gt; 선언 및 &lt;code&gt;readonly static&lt;/code&gt; 속성 에서만 허용되며 특정 고유 기호를 참조하려면 &lt;code&gt;typeof&lt;/code&gt; 연산자 를 사용해야합니다 . &lt;code&gt;unique symbol&lt;/code&gt; 대한 각 참조 는 주어진 선언과 연결된 완전히 고유 한 ID를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a2a8ede1fa38a59757413a66a422de02420747b4" translate="yes" xml:space="preserve">
          <source>To fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; and ensuring these flags are enabled:</source>
          <target state="translated">이러한 문제를 해결하려면 TSC를 사용하여 프로젝트를 입력하는 명령을 설정하는 것이 좋습니다. 이는 바벨 구성의 일부를 해당 &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 에&lt;/a&gt; 복제 하고 다음 플래그가 활성화되어 있는지 확인 하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2ca735a8b247a6d501055cf55a7c32e4798d2f35" translate="yes" xml:space="preserve">
          <source>To get an error when TypeScript produces an &lt;code&gt;any&lt;/code&gt;, use &lt;code&gt;&quot;noImplicitAny&quot;: true&lt;/code&gt;, or &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">타이프 라이터가 발생하면 오류를 얻으려면 &lt;code&gt;any&lt;/code&gt; 사용 &lt;code&gt;&quot;noImplicitAny&quot;: true&lt;/code&gt; , 또는 &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; 에 &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">좀 더 구체적으로, 동기 부여를 구축하고 다음 &lt;code&gt;compose&lt;/code&gt; 기능을 고려하자 :</target>
        </trans-unit>
        <trans-unit id="45a47ec78d51136ebeb7c0035a7c5da00cc87248" translate="yes" xml:space="preserve">
          <source>To get started, we&amp;rsquo;ll need a class which will have the mixin&amp;rsquo;s applied on top of:</source>
          <target state="translated">시작하려면 믹스 인이 적용되는 클래스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d66869d0f99755ea08df36056766e3e90f0cd610" translate="yes" xml:space="preserve">
          <source>To get the same code working via property accessors, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">속성 접근자를 통해 작동하는 동일한 코드를 얻으려면 유형 어설 션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">동일한 코드를 작동 시키려면 형식 어설 션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="35beccf47f973d38e356b224393b06f7953333cd" translate="yes" xml:space="preserve">
          <source>To give you an idea of how all these pieces can come together, here is a reference &lt;code&gt;.d.ts&lt;/code&gt; to start with when making a new module</source>
          <target state="translated">이 모든 부분이 어떻게 결합 될 수 있는지에 대한 아이디어를 제공하기 위해 새 모듈을 만들 때 시작할 참조 &lt;code&gt;.d.ts&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fec9382d2cac44b5a2760a5f5fd406c2cf32f49" translate="yes" xml:space="preserve">
          <source>To handle both importing via UMD and modules:</source>
          <target state="translated">UMD 및 모듈을 통한 가져 오기를 모두 처리하려면 :</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">두 번째 문제를 완화하기 위해 명시 적 이니셜 라이저를 추가하거나 &lt;code&gt;declare&lt;/code&gt; 수정자를 추가 하여 속성에 방출이 없어야 함을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a579a27d8288d6f9fa099e50e47bee7c5f5359" translate="yes" xml:space="preserve">
          <source>To help with string manipulation around template string literals, TypeScript includes a set of types which can be used in string manipulation within the type system. You can</source>
          <target state="translated">템플릿 문자열 리터럴 주변의 문자열 조작을 돕기 위해 TypeScript에는 유형 시스템 내에서 문자열 조작에 사용할 수있는 유형 집합이 포함되어 있습니다. 당신은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">위의 예에서 &lt;code&gt;x&lt;/code&gt; 의 유형을 유추하려면 각 배열 요소의 유형을 고려해야합니다. 여기에는 배열 유형에 대해 두 가지 선택 사항이 있습니다 : &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; . 가장 일반적인 유형 알고리즘은 각 후보 유형을 고려하고 다른 모든 후보와 호환되는 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c3a042083562f94184f2e9a526e92d4624f7a75c" translate="yes" xml:space="preserve">
          <source>To learn all of the features available in JSDoc, see &lt;a href=&quot;jsdoc-supported-types&quot;&gt;the reference&lt;/a&gt;.</source>
          <target state="translated">JSDoc에서 사용할 수있는 모든 기능을 배우려면 &lt;a href=&quot;jsdoc-supported-types&quot;&gt;참조를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e2445c46ae38decbdcceb4e18f8e4d29d8ec207" translate="yes" xml:space="preserve">
          <source>To learn more about how JavaScript is interpreted by TypeScript read &lt;a href=&quot;type-checking-javascript-files&quot;&gt;How TS Type Checks JS&lt;/a&gt;</source>
          <target state="translated">TypeScript에서 JavaScript를 해석하는 방법에 대해 자세히 알아 보려면 &lt;a href=&quot;type-checking-javascript-files&quot;&gt;TS 유형이 JS를 확인하는 방법을&lt;/a&gt; 읽어보세요.</target>
        </trans-unit>
        <trans-unit id="808177508af689c394e654a499a68e6b1a4ab02a" translate="yes" xml:space="preserve">
          <source>To learn more about the hundreds of configuration options in the &lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/tsconfig&quot;&gt;TSConfig Reference&lt;/a&gt; 에서 수백 가지 구성 옵션에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;은 GitHub에서 원본 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d48e164ebf0706bbeef6b8d4d1ffab98e9301fa2" translate="yes" xml:space="preserve">
          <source>To learn the type of a variable, use &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">변수 유형을 알아 보려면 &lt;code&gt;typeof&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">타입 안전을 유지하기 위해 &lt;code&gt;typeof&lt;/code&gt; 키워드를 사용할 수 있습니다 . &lt;code&gt;typeof&lt;/code&gt; 키워드는 입력 위치에 사용되는 경우,이 경우에는, 모듈의 유형 값의 유형을 생성한다.</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">네임 스페이스 값을 병합하려면 각 선언 사이트에서 네임 스페이스가 지정된 이름으로 이미 존재하는 경우 기존 네임 스페이스를 사용하고 두 번째 네임 스페이스의 내 보낸 멤버를 첫 번째에 추가하여 네임 스페이스 값을 더 확장합니다.</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">네임 스페이스를 병합하기 위해 각 네임 스페이스에 선언 된 내 보낸 인터페이스의 유형 정의가 자체적으로 병합되어 내부에 병합 된 인터페이스 정의가 포함 된 단일 네임 스페이스를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="601f6a1ad7b275eaa55ff8112b05048d0ec9e5bc" translate="yes" xml:space="preserve">
          <source>To model this, we modify the original constructor type to accept a generic argument.</source>
          <target state="translated">이를 모델링하기 위해 일반 인수를 허용하도록 원래 생성자 유형을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">기존 기능을 유지하기 위해 &lt;code&gt;fullName&lt;/code&gt; 을 수정하지 않은 간단한 getter도 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">접근자가 현재 값의 길이를 확인하고 있음을 증명하기 위해 10자를 초과하는 이름을 할당하고 오류가 발생하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">JavaScript에서이 두 가지 접근 방식을 빠르게 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">어설 션 서명에 대한 자세한 내용을 보려면 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;원래 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">모듈 내용을 네임 스페이스로 사용하지 말아야하는 이유를 반복하기 위해 네임 스페이스 지정의 일반적인 아이디어는 구문의 논리적 그룹화를 제공하고 이름 충돌을 방지하는 것입니다. 모듈 파일 자체는 이미 논리적 그룹이며 최상위 이름은 가져 오는 코드로 정의되므로 내 보낸 객체에 추가 모듈 레이어를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ea09d0dcf7792b419d55f46f04da3421ddf5acc" translate="yes" xml:space="preserve">
          <source>To see these methods in action modify the existing code to:</source>
          <target state="translated">이러한 메서드가 작동하는지 보려면 기존 코드를 다음과 같이 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">컴파일러와의 관계를 지정하려면 &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; 는 내용이 런타임에 병합 될 것으로 예상되는 &lt;em&gt;루트&lt;/em&gt; 목록을 지정합니다 . 예를 들어, &lt;code&gt;tsconfig.json&lt;/code&gt; 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">먼저 제네릭의 &quot;hello world&quot;인 identity 함수를 해 봅시다. identity 함수는 전달 된 모든 것을 되돌려주는 함수입니다. &lt;code&gt;echo&lt;/code&gt; 명령 과 비슷한 방식으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">시작하기 위해 다음과 같은 방식으로 프로젝트를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="3c02e0a11dcbbd64ac3f3d468a0774d3ea7e3a4b" translate="yes" xml:space="preserve">
          <source>To summarize, we have a language that was designed for quick uses, and then grew to a full-fledged tool to write applications with millions of lines. Every language has its own &lt;em&gt;quirks&lt;/em&gt; &amp;mdash; oddities and surprises, and JavaScript&amp;rsquo;s humble beginning makes it have &lt;em&gt;many&lt;/em&gt; of these. Some examples:</source>
          <target state="translated">요약하면, 우리는 빠른 사용을 위해 설계된 언어가 있으며 수백만 줄의 응용 프로그램을 작성하는 본격적인 도구로 성장했습니다. 모든 언어는 그 자체가 &lt;em&gt;단점이&lt;/em&gt; 기이과 놀라움, 그리고 자바 스크립트의 겸손 시작은해야한다 - &lt;em&gt;많은&lt;/em&gt; 이들합니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="ae9fedcb5b02e069b5600cc79446eace7ee0e944" translate="yes" xml:space="preserve">
          <source>To this JavaScript:</source>
          <target state="translated">이 JavaScript에 :</target>
        </trans-unit>
        <trans-unit id="cff04291bfbc2b0841bede7f6b8fa3e70667afd9" translate="yes" xml:space="preserve">
          <source>To understand how namespaces work in &lt;code&gt;.d.ts&lt;/code&gt; files read the &lt;a href=&quot;../deep-dive&quot;&gt;&lt;code&gt;.d.ts&lt;/code&gt; deep dive&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.d.ts&lt;/code&gt; 파일 에서 네임 스페이스가 작동하는 방식을 이해하려면 &lt;a href=&quot;../deep-dive&quot;&gt; &lt;code&gt;.d.ts&lt;/code&gt; 심층 분석을&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">전체 영향을 이해하려면 &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt; &lt;code&gt;useDefineForClassFields&lt;/code&gt; &lt;/a&gt; 플래그 에 대한 위의 섹션을 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">TS 컴파일러가 수행 할 단계를 이해하려면 Node.js 모듈에 대해 간략히 설명해야합니다. 일반적으로 Node.js의 가져 오기는 &lt;code&gt;require&lt;/code&gt; 라는 함수를 호출하여 수행됩니다 . Node.js가 취하는 행동은 &lt;code&gt;require&lt;/code&gt; 에 상대 경로 또는 비 상대 경로가 제공 되는지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">JSX를 React와 함께 사용하려면 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React 타이핑을&lt;/a&gt; 사용해야합니다 . 이러한 유형 지정 은 React와 함께 사용하기 위해 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스를 적절하게 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">JSX 지원을 React와 함께 사용하려면 &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React 타이핑을&lt;/a&gt; 사용해야합니다 . 이러한 유형 지정은 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스를 정의하여 TypeScript가 JSX 표현식에서 React를 올바르게 확인할 수 있도록합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">오늘날 가장 널리 사용되는 세계적으로 액세스 가능한 라이브러리는 실제로 UMD 라이브러리로 작성됩니다 (아래 참조). UMD 라이브러리 문서는 글로벌 라이브러리 문서와 구별하기가 어렵습니다. 글로벌 선언 파일을 작성하기 전에 라이브러리가 실제로 UMD가 아닌지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">(1)과 (2) 는 함께 &lt;code&gt;default&lt;/code&gt; 작업 에서 &lt;code&gt;browserify&lt;/code&gt; 하기 위해 전화를 이동해야 함을 의미합니다 . Watchify와 Gulp 모두 호출해야하므로 &lt;code&gt;default&lt;/code&gt; 함수 이름을 지정해야합니다. (3)으로 로깅을 추가하는 것은 선택 사항이지만 설정을 디버깅하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eff2d319ea219f2ac59917c5f301c263edd3b652" translate="yes" xml:space="preserve">
          <source>Together with &lt;a href=&quot;unions-and-intersections&quot;&gt;intersection&lt;/a&gt; types, we can make some pretty mind-bending types:</source>
          <target state="translated">&lt;a href=&quot;unions-and-intersections&quot;&gt;교차로&lt;/a&gt; 유형 과 함께 우리는 마음을 구부리는 몇 가지 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">교차 유형과 함께, 우리는 꽤 마음을 굽히는 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">너무 많거나 너무 적은 인수</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">최상위 &lt;code&gt;var&lt;/code&gt; 문 또는 &lt;code&gt;function&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="bfe242d3ed392dcc4dc72844403f2e430bfe4d50" translate="yes" xml:space="preserve">
          <source>Trace Resolution - &lt;code&gt;traceResolution&lt;/code&gt;</source>
          <target state="translated">추적 &lt;code&gt;traceResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">추적 모듈 확인</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">모듈의 절충</target>
        </trans-unit>
        <trans-unit id="b8db22bc5c87c60fca81d73b716c1fab4571ecab" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">전통적인 자바 스크립트는 함수와 프로토 타입 기반 상속을 사용하여 재사용 가능한 구성 요소를 구축하지만, 프로그래머는 클래스가 기능을 상속하고 객체가 이러한 클래스에서 빌드되는 객체 지향 접근 방식에 더 익숙해지면 다소 어색 할 수 있습니다. ECMAScript 6이라고도하는 ECMAScript 2015부터 JavaScript 프로그래머는이 객체 지향 클래스 기반 접근 방식을 사용하여 애플리케이션을 구축 할 수 있습니다. TypeScript에서는 개발자가 지금 이러한 기술을 사용하고 다음 버전의 JavaScript를 기다릴 필요없이 모든 주요 브라우저 및 플랫폼에서 작동하는 JavaScript로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">전통적인 JavaScript는 함수와 프로토 타입 기반 상속을 사용하여 재사용 가능한 컴포넌트를 구축하지만, 클래스가 기능을 상속하고 객체가이 클래스에서 빌드되는 객체 지향 접근 방식에 더 익숙한 프로그래머에게는 다소 어색한 느낌이들 수 있습니다. ECMAScript 6이라고도하는 ECMAScript 2015부터 JavaScript 프로그래머는이 객체 지향 클래스 기반 접근 방식을 사용하여 응용 프로그램을 빌드 할 수 있습니다. TypeScript에서는 개발자가 이러한 기술을 사용하여 다음 버전의 JavaScript를 기다릴 필요없이 모든 주요 브라우저와 플랫폼에서 작동하는 JavaScript로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">함수 매개 변수 및 인수 목록의 후행 쉼표가 이제 허용됩니다. 이것은 유효한 ES3 / ES5 / ES6로 방출 되는 &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript 제안에&lt;/a&gt; 대한 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">함수 매개 변수 및 인수 목록에서 후행 쉼표</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">최신 JavaScript 구문을 ECMAScript 5와 같은 이전 버전으로 변환합니다 ( &lt;code&gt;target&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">트리플 슬래시 지시어</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">트리플 슬래시 지시문은 포함 파일의 맨 위에서 &lt;strong&gt;만&lt;/strong&gt; 유효합니다. 트리플 슬래시 지시문은 다른 트리플 슬래시 지시문을 포함하여 단일 또는 여러 줄 주석 만 앞에 올 수 있습니다. 이들이 진술이나 선언에 뒤 따르면 규칙적인 한 줄 주석으로 취급되며 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">트리플 슬래시 지시문은 단일 XML 태그를 포함하는 한 줄 주석입니다. 주석의 내용은 컴파일러 지시문으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">트리플 슬래시 참조는 컴파일 프로세스에 추가 파일을 포함하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="209d1157417fde29537d214407cbb04f2fb26b89" translate="yes" xml:space="preserve">
          <source>Trying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn&amp;rsquo;t provide enough tools to describe the exports then you can use &lt;code&gt;namespaces&lt;/code&gt;.</source>
          <target state="translated">JavaScript 코드의 런타임 관계를 설명하는 것은 까다로울 수 있습니다. ES 모듈과 유사한 구문이 내보내기를 설명하는 데 충분한 도구를 제공하지 않으면 &lt;code&gt;namespaces&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">튜플 파괴</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">튜플 유형</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">튜플 유형을 사용하면 유형이 알려진 고정 된 수의 요소로 배열을 표현할 수 있지만 동일 할 필요는 없습니다. 예를 들어, 값을 &lt;code&gt;string&lt;/code&gt; 과 &lt;code&gt;number&lt;/code&gt; 의 쌍으로 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">튜플 형식은 특정 요소의 형식이 알려진 배열을 나타내지 만 같을 필요는 없습니다. 예를 들어, 위치 0에 &lt;code&gt;string&lt;/code&gt; 있고 위치 1에 &lt;code&gt;number&lt;/code&gt; 가 있는 배열을 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">튜플 타입은 이제 &lt;code&gt;?&lt;/code&gt; 요소 유형에 대한 postfix는 요소가 선택적임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">나머지 매개 변수 및 확산 표현식의 튜플</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">튜플은 배열처럼 구조화 될 수 있습니다. 파괴 변수는 해당 튜플 요소의 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="13179f7189ca168af29df9bd58b2fd52c0614eb0" translate="yes" xml:space="preserve">
          <source>Turning &lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; on suppresses reporting the error about implicit anys when indexing into objects, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;suppressImplicitAnyIndexErrors&lt;/code&gt; 를 켜면 다음 예제와 같이 객체로 인덱싱 할 때 암시 적 anys에 대한 오류보고를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="1a6db2244dd129bbdb09e4163ada76293caa34a3" translate="yes" xml:space="preserve">
          <source>Turning on &lt;a href=&quot;#downlevelIteration&quot;&gt;&lt;code&gt;downlevelIteration&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;importHelpers&lt;/code&gt; is still false:</source>
          <target state="translated">켜기 &lt;a href=&quot;#downlevelIteration&quot;&gt; &lt;code&gt;downlevelIteration&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;importHelpers&lt;/code&gt; 은 여전히 거짓 :</target>
        </trans-unit>
        <trans-unit id="0352b1bc1bd302b11a3202f8ca77b3b6a6074227" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;esModuleInterop&lt;/code&gt; will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler,the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</source>
          <target state="translated">&lt;code&gt;esModuleInterop&lt;/code&gt; 을 켜면 TypeScript에 의해 트랜스 파일 된 코드에서 이러한 문제가 모두 수정됩니다. 첫 번째는 컴파일러의 동작을 변경하고 두 번째는 생성 된 JavaScript에서 호환성을 보장하기 위해 shim을 제공하는 두 개의 새로운 도우미 함수로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f09cc50104b5125d833de6822dd696f449bdb66" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noImplicitAny&lt;/code&gt; however TypeScript will issue an error whenever it would have inferred &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">그러나 noImplicitAny를 켜면 &lt;code&gt;noImplicitAny&lt;/code&gt; 는 다음을 추론 &lt;code&gt;any&lt;/code&gt; 때마다 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5dda13edded0b19f61e1d98b9a246afd41365ec8" translate="yes" xml:space="preserve">
          <source>Turning on &lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; will add &lt;code&gt;undefined&lt;/code&gt; to any un-declared field in the type.</source>
          <target state="translated">&lt;code&gt;noUncheckedIndexedAccess&lt;/code&gt; 를 설정 하면 유형의 선언되지 않은 필드에 &lt;code&gt;undefined&lt;/code&gt; 가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="0bdb148b80769233155853c95838bff4924234bc" translate="yes" xml:space="preserve">
          <source>Type Acquisition - &lt;code&gt;typeAcquisition&lt;/code&gt;</source>
          <target state="translated">유형 획득 &lt;code&gt;typeAcquisition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">별칭</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">유형 별명</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">타입 확인</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">JavaScript 파일 형식 확인</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">JavaScript 파일 형식 확인 : @enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">JavaScript 파일 검사 유형 : @this</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">JavaScript 파일 형식 검사 : @type</target>
        </trans-unit>
        <trans-unit id="e19333b8380c7528aa2f3c6afed5b2505d7443bf" translate="yes" xml:space="preserve">
          <source>Type Checking and d.ts file generation</source>
          <target state="translated">유형 검사 및 d.ts 파일 생성</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">타입 호환성</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">유형 호환성 : 열거 형</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="translated">타입 선언</target>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">타입 가드</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">타입 가드 및 차별화 유형</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">타입 추론</target>
        </trans-unit>
        <trans-unit id="c50d144660c5c67e814a21e78a048bb4d4c2ec30" translate="yes" xml:space="preserve">
          <source>Type Parameters</source>
          <target state="translated">유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="b024dbff803f7c06dae7d9c5ea0e61258a676b0c" translate="yes" xml:space="preserve">
          <source>Type Roots - &lt;code&gt;typeRoots&lt;/code&gt;</source>
          <target state="translated">유형 루트 &lt;code&gt;typeRoots&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">별칭 입력</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">타입 별칭은 원래 타입과 정확히 동일합니다. 그들은 단순히 다른 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0a723dcef74bc94a2959e3631f83bac96553dbc6" translate="yes" xml:space="preserve">
          <source>Type aliases are mere aliases, just like &lt;code&gt;type&lt;/code&gt; in Haskell. The compiler will attempt to use the alias name wherever it was used in the source code, but does not always succeed.</source>
          <target state="translated">유형 별칭은 Haskell의 &lt;code&gt;type&lt;/code&gt; 과 마찬가지로 단순한 별칭 입니다. 컴파일러는 소스 코드에서 사용 된 별칭 이름을 사용하려고 시도하지만 항상 성공하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">유형 별명은 유형의 새 이름을 작성합니다. 타입 별칭은 때때로 인터페이스와 비슷하지만 프리미티브, 공용체, 튜플 및 기타 직접 작성해야하는 다른 타입의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">유형 별칭은 항상 &quot;재귀 적으로&quot;참조 될 수있는 방법에 제한이있었습니다. 그 이유는 유형 별명을 사용하면 별명으로 대체 할 수 있어야하기 때문입니다. 경우에 따라 가능하지 않으므로 컴파일러는 다음과 같은 특정 재귀 별칭을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">타입 주석</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">TypeScript의 유형 주석은 의도 한 함수 또는 변수 계약을 기록하는 간단한 방법입니다. 이 경우 단일 문자열 매개 변수로 greeter 함수를 호출하려고합니다. 대신 배열을 전달하기 위해 호출 인사말을 변경해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">&lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; 모드 에서 어설 션 / 캐스트 구문을 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">타입 주장</target>
        </trans-unit>
        <trans-unit id="e17ca89e78f9f5ce2baa8b85a25ab01c83ae36fb" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms.</source>
          <target state="translated">유형 어설 션에는 두 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">형식 어설 션에는 두 가지 형태가 있습니다. 하나는&amp;ldquo;각괄호&amp;rdquo;구문입니다.</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 연산자 의 유형 검사 는 이제 왼쪽 피연산자 의 유형이 오른쪽 피연산자가 나타내는 유형 (구조적 하위 유형 검사와 반대) &lt;em&gt;에서 파생&lt;/em&gt; 되는지 여부를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">TypeScript의 형식 호환성은 구조적 하위 유형을 기반으로합니다. 구조적 타이핑은 멤버만을 기준으로 유형을 관련시키는 방법입니다. 이것은 공칭 타이핑과 대조적입니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">타입 가드 및 타입 어설 션</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">점으로 구분 된 이름에 대한 유형 가드는 사용자 정의 유형 가드 기능 및 &lt;code&gt;typeof&lt;/code&gt; 및 &lt;code&gt;instanceof&lt;/code&gt; 연산자와 함께 작동하며 &lt;code&gt;--strictNullChecks&lt;/code&gt; 컴파일러 옵션 에 의존하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">유형 가드에서 추론 &lt;code&gt;in&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">공동 재산에 경비원을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">타입 가드는 이전에는 로컬 변수 및 매개 변수 검사 만 지원했습니다. 유형 가드는 이제 변수 또는 매개 변수 이름과 하나 이상의 속성 액세스로 구성된 &quot;점 이름&quot;확인을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">상자에 입력하고 중단 점이 TypeScript 코드에 부딪 히고 검사가 올바르게 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">TypeScript에서는 유형 추론이 &quot;다른 방향&quot;으로도 작동합니다. 이것을 &quot;문맥 입력&quot;이라고합니다. 상황 별 타이핑은 식의 유형이 해당 위치에 의해 암시 될 때 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">조건부 유형의 유형 유추</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">컨텍스트 유형에서 유형 매개 변수 유추</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">제약 조건으로 형식 매개 변수</target>
        </trans-unit>
        <trans-unit id="638d8954b09678865ded4d60dc34a31605942b14" translate="yes" xml:space="preserve">
          <source>Type syntax of a C-descended language.</source>
          <target state="translated">C-descended 언어의 유형 구문입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
