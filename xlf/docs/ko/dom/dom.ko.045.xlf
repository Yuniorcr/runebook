<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="dom">
    <body>
      <group id="dom">
        <trans-unit id="2e23abc3ee3c262a49b42bfda14d6aa71276ade7" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.peerIdentity' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.peerIdentity'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="22dabcbb6797b1b9078847ee878fa46f6df64124" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.pendingLocalDescription' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.pendingLocalDescription'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dba848a0d091c392a154900fa3fcfbffda75f654" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.pendingRemoteDescription' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.pendingRemoteDescription'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="16d4f1466a16f413d83584388c1f379fd4f379d9" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.remoteDescription' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.remoteDescription'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d45713089587a55bbf58cb9be683668057934ec7" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.removeStream()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.removeStream ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="abfda2c9d905b34260f65d96b8a35036b78ef43c" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.removeTrack()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.removeTrack ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="032ca2e578720947e6087f267d11361bd511e8f9" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.sctp' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.sctp'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="87b5d64d1b70886e8c77ad4dbb8304cce2838a07" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.setIdentityProvider()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.setIdentityProvider ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e3da3700132e3dfe31ab7ea988475522af60054d" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.setLocalDescription()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.setLocalDescription ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c60abb13143b39823606511a70252aa2c0092041" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.setRemoteDescription()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.setRemoteDescription ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dfda964f989dbd4d56d4e51edf34eac60192ec32" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnection.signalingState' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnection.signalingState'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="98d47524808722fc6f9de2a2cdd531f334455c0f" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnectionIceEvent' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnectionIceEvent'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0bbb42c23f393374d6634d829941e46a8d036faa" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnectionIceEvent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnectionIceEvent ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="026fa7a9b2623be85056c9d7275d90c3c9964fd9" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCPeerConnectionIceEvent.candidate' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCPeerConnectionIceEvent.candidate'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c83eb142dbfb3f7695b6b63837164a672b7b24bd" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpContributingSource' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpContributingSource'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0a8dbfd1abe8537666993d034c729f06881d1d8e" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpReceiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpReceiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3723243571ae418f8398f5ebe97072b0b17311b5" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpReceiver.getStats()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpReceiver.getStats ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c87f88c4569c1441a0b3244394b138935249abe0" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpSender' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpSender'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2bd407f12211c0b9e4b31d625726a77c10766772" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpSender.dtmf' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpSender.dtmf'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="21e6ddba55ace7f29155f34da1092cafcb4ad3d2" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpSender.getStats()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpSender.getStats ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3288961714e475a0cdf61d676f87154cb18b56fa" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpSender.replaceTrack()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpSender.replaceTrack ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="08853a45b1c4fac8f7ac2be47eb428951e9ac73a" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpSynchronizationSource' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpSynchronizationSource'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="613ebc21c4206498e78a28e44bbb3f3423ca4933" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c01bc7c31b90101c688dbfd31dcd06b7103758a4" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.currentDirection' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.currentDirection'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dfb1314c71c1a678d53f6be9c8dde56313523f4a" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.direction' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.direction'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="933e6c573ae094944651a33e47c18a144c5e6a96" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.mid' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.mid'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="770f0bd2b1929aea2c59d1d8f58c6c6ef286008d" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.receiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.receiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="569b260c4888fd54834c001fa1e235e224c7f890" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.sender' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.sender'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1d63922f65b88f403778be498318dbe38820f9d1" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.setCodecPreferences()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.setCodecPreferences ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="827fb5dde65bb53442464515b3575b0ca33b0408" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.stop()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.stop ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="61ff405a02c4e0bd06a646f4bf2e9bbdff3b9fc1" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiver.stopped' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiver.stopped'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0adce9ad491e896e57e9b66e4be30251988849cc" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiverDirection' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiverDirection'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="989fa0072634e94d012c1384278920952da0ce27" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCRtpTransceiverInit' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCRtpTransceiverInit'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="19ec75c0c9481e4de9ef76585e55427ad942edd8" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSctpTransport' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSctpTransport'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5a9ecb1ae931febb79e608d72ed7ee51424dae84" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSessionDescription' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSessionDescription'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ebbf0049efb8786d9d1fa65785bddab750b517ca" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSessionDescription()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSessionDescription ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="030201346d7ae32cf7b7a9c665b597bd43e36a7b" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSessionDescription.sdp' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSessionDescription.sdp'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9f59a765bfe4534710f46b03da17af1165662ddb" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSessionDescription.type' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSessionDescription.type'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="87afdbc0e5dd567e25c61aaced6faf2f9c8e8e4b" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCSessionDescription: toJSON()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCSessionDescription : toJSON ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0815cda888ad51defa599056a368c54e91ee2589" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCStats' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCStats'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ea3b912b2d1bdd01a46f3347351d40e5757b64bd" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCStats.id' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCStats.id'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e77417d47c2981e0a032d519a09f3ffc00bf3d2e" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCStats.timestamp' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCStats.timestamp'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d2c34098773ccceee3f27ab52490d9983f00651b" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCStats.type' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCStats.type'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4712d15c1f418ae99573da0bc730b0c463cafd46" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCStatsReport' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCStatsReport'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="312e71a764290f38f29eb839d0f03b9920994f25" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a461f9f1b0edda575b3df6d3cef9fa9e07f5a43" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bfedb771dbd7efb9afb26cb60e235a8b4fed4f0b" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent.receiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent.receiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5306c6d572ebf1d8a96f79251c8af35410a7b885" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent.streams' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent.streams'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3558bd19ffdad824b837810d00722d12a133d44d" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent.track' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent.track'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="24c7bef15774772494ba264fd35a0d19df2ffece" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEvent.transceiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEvent.transceiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2aea0f5c0baa764c4af990aac3dc07d17c8e2dda" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEventInit' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEventInit'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8a74587c7dfa976a48fe870b0058f0cb391bae9b" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEventInit.receiver' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEventInit.receiver'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6392b540311321e43e7aa1ebef709c84bbb5dbf8" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEventInit.streams' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEventInit.streams'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d6a75a82dcb79a778605b5698a701437dc063aba" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'RTCTrackEventInit.track' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'RTCTrackEventInit.track'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c993243595f6a1ad81e901666240b38ef6b410b4" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'audioLevel' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'audioLevel'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="893f2ce0da1b2b93745f9e88e144138ebeec7eb8" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'createAnswer()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'createAnswer ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9d2a64b10dccd20d16c9e66e7e9d2b67c7b75d35" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'createDataChannel()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'createDataChannel ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c200637b90a5e83f1cbaa3db3bc3e60f59251e02" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'createOffer()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'createOffer ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8b10ca6e98a7d276ca11c57ab8578cddf5f777ae" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'generateCertificate()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'generateCertificate ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6c31f69d452a7b5bffc147bb57f72c74589eb208" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'getConfiguration()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getConfiguration ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="98076190dc7324fa5fba30113f8a0be0ddfaafc7" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'getContributingSources()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getContributingSources ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="97ece2e32a747c92c02ef6a62ebc07baf08b59e1" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'getParameters()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getParameters ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="aa605b391ca7b82d691a49c8b444af26c37b04f0" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'getSynchronizationSources()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getSynchronizationSources ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2b823d4fe6e60e53a410c53b759b6f55b3865151" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'ontonechange' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'ontonechange'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5293f3f1535b8a517a29ff44ad3f28c484f4f031" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'setConfiguration()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'setConfiguration ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cd693914dab4b2310aed3a7851376f640aed0886" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'setParameters()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'setParameters ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cfeffb6714e251cd4a5b44350246a6d83b9e363e" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'source' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 '소스'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b2582ff4717898ab41725b998d3de656ac1cdee1" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'timestamp' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 '타임 스탬프'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d3c4c8763bc0971c79c0dcc370c205ce86a97d2e" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'track' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 '트랙'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c36852ff96a6dec6cbceb91b473bd27d0f8cc1a8" translate="yes" xml:space="preserve">
          <source>WebRTC 1.0: Real-time Communication Between Browsers&lt;br/&gt;&lt;small&gt;The definition of 'voiceActivityFlag' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebRTC 1.0 : 브라우저 간 실시간 통신 &lt;br/&gt;&lt;small&gt;해당 사양에서 'voiceActivityFlag'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f8358ae745f7d57210c46c0b98f65c455f6a2e95" translate="yes" xml:space="preserve">
          <source>WebRTC API</source>
          <target state="translated">WebRTC API</target>
        </trans-unit>
        <trans-unit id="78a3d75e9cf522cd2a40689c70e908d56b5b6224" translate="yes" xml:space="preserve">
          <source>WebRTC API: Connectivity</source>
          <target state="translated">WebRTC API : 연결</target>
        </trans-unit>
        <trans-unit id="facc31e0f4a74710c2ea9bff936c7d8d25a99b2d" translate="yes" xml:space="preserve">
          <source>WebRTC API: Intro to RTP</source>
          <target state="translated">WebRTC API : RTP 소개</target>
        </trans-unit>
        <trans-unit id="8b1761208a889c1424116a2507892f4855137bcc" translate="yes" xml:space="preserve">
          <source>WebRTC API: Protocols</source>
          <target state="translated">WebRTC API : 프로토콜</target>
        </trans-unit>
        <trans-unit id="5075fbb85fae0280b4c6d742fb222272ddbf5aae" translate="yes" xml:space="preserve">
          <source>WebRTC API: Session lifetime</source>
          <target state="translated">WebRTC API : 세션 수명</target>
        </trans-unit>
        <trans-unit id="86d7955221150739591f0e2b89e16c8515a0d7a8" translate="yes" xml:space="preserve">
          <source>WebRTC API: Signaling and video calling</source>
          <target state="translated">WebRTC API : 신호 및 화상 통화</target>
        </trans-unit>
        <trans-unit id="9ad738e0cdeaf59b5157919cd5ae285a02f7d14f" translate="yes" xml:space="preserve">
          <source>WebRTC API: Simple RTCDataChannel sample</source>
          <target state="translated">WebRTC API : 간단한 RTCDataChannel 샘플</target>
        </trans-unit>
        <trans-unit id="3d862bebd2c63fecd43f008ecbf7751e2b0c9c71" translate="yes" xml:space="preserve">
          <source>WebRTC API: Taking still photos</source>
          <target state="translated">WebRTC API : 스틸 사진 촬영</target>
        </trans-unit>
        <trans-unit id="58d911147b1d95f278fa31b4945f00703fb91072" translate="yes" xml:space="preserve">
          <source>WebRTC API: Using DTMF</source>
          <target state="translated">WebRTC API : DTMF 사용</target>
        </trans-unit>
        <trans-unit id="9981036ae8bc1f01b29b54a1534a088be3de80ef" translate="yes" xml:space="preserve">
          <source>WebRTC API: Using data channels</source>
          <target state="translated">WebRTC API : 데이터 채널 사용</target>
        </trans-unit>
        <trans-unit id="ecbff5a1529e8f88bbda45f8a0ff2e077e6a712f" translate="yes" xml:space="preserve">
          <source>WebRTC API: adapter.js</source>
          <target state="translated">WebRTC API : adapter.js</target>
        </trans-unit>
        <trans-unit id="4c7f3297fc78c69c75acf43313c735383c75e179" translate="yes" xml:space="preserve">
          <source>WebRTC architecture overview</source>
          <target state="translated">WebRTC 아키텍처 개요</target>
        </trans-unit>
        <trans-unit id="6bc2aa86a2f80a3477760ed0642097f9ab216cfd" translate="yes" xml:space="preserve">
          <source>WebRTC concepts and usage</source>
          <target state="translated">WebRTC 개념 및 사용법</target>
        </trans-unit>
        <trans-unit id="0756d6a679b21d5362598f4fe045f53c269d37c5" translate="yes" xml:space="preserve">
          <source>WebRTC connectivity</source>
          <target state="translated">WebRTC 연결</target>
        </trans-unit>
        <trans-unit id="3a186c33361f55c632b711ad2904fa8ddfba8206" translate="yes" xml:space="preserve">
          <source>WebRTC consists of several interrelated APIs and protocols which work together to achieve this. The documentation you'll find here will help you understand the fundamentals of WebRTC, how to set up and use both data and media connections, and more.</source>
          <target state="translated">WebRTC는이를 달성하기 위해 함께 작동하는 여러 상호 관련된 API 및 프로토콜로 구성됩니다. 여기에서 찾을 수있는 문서는 WebRTC의 기본 사항, 데이터 및 미디어 연결 설정 및 사용 방법 등을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="04e80e24c439a580332f7ddf990f5a284eac9bb5" translate="yes" xml:space="preserve">
          <source>WebRTC data channels (see &lt;a href=&quot;rtcdatachannel/onmessage&quot;&gt;&lt;code&gt;RTCDataChannel.onmessage&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">WebRTC 데이터 채널 ( &lt;a href=&quot;rtcdatachannel/onmessage&quot;&gt; &lt;code&gt;RTCDataChannel.onmessage&lt;/code&gt; &lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b410d893d4781b12e727274958c7d94afb7abdec" translate="yes" xml:space="preserve">
          <source>WebRTC data channels support buffering of outbound data. This is handled automatically. While there's no way to control the size of the buffer, you can learn how much data is currently buffered, and you can choose to be notified by an event when the buffer starts to run low on queued data. This makes it easy to write efficient routines that make sure there's always data ready to send without over-using memory or swamping the channel completely.</source>
          <target state="translated">WebRTC 데이터 채널은 아웃 바운드 데이터의 버퍼링을 지원합니다. 이것은 자동으로 처리됩니다. 버퍼 크기를 제어 할 수있는 방법은 없지만 현재 버퍼링 된 데이터의 양을 알 수 있으며 큐에 대기중인 데이터에서 버퍼가 부족해지기 시작하면 이벤트 알림을 받도록 선택할 수 있습니다. 따라서 효율적인 루틴을 쉽게 작성할 수 있으므로 메모리를 과도하게 사용하거나 채널을 완전히 휩쓸 지 않고도 항상 데이터를 전송할 준비가되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4925746b775b247833ae038640d782e23242406" translate="yes" xml:space="preserve">
          <source>WebRTC doesn't send DTMF codes as audio data. Instead, they're sent out-of-band, as RTP payloads. Note, however, that although it's possible to &lt;em&gt;send&lt;/em&gt; DTMF using WebRTC, there is currently no way to detect or receive &lt;em&gt;incoming&lt;/em&gt; DTMF. WebRTC currently ignores these payloads; this is because WebRTC's DTMF support is primarily intended for use with legacy telephone services that rely on DTMF tones to perform tasks such as:</source>
          <target state="translated">WebRTC는 DTMF 코드를 오디오 데이터로 보내지 않습니다. 대신 RTP 페이로드로 대역 외로 전송됩니다. 그러나 WebRTC를 사용하여 DTMF 를 &lt;em&gt;보낼&lt;/em&gt; 수는 있지만 현재 &lt;em&gt;들어오는&lt;/em&gt; DTMF 를 감지하거나 수신 할 수있는 방법은 없습니다 . WebRTC는 현재 이러한 페이로드를 무시합니다. WebRTC의 DTMF 지원은 주로 DTMF 톤을 사용하여 다음과 같은 작업을 수행하는 레거시 전화 서비스와 함께 사용하기위한 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="98f31e3acb2462a2e9a8791581d703e71fe715af" translate="yes" xml:space="preserve">
          <source>WebRTC interfaces</source>
          <target state="translated">WebRTC 인터페이스</target>
        </trans-unit>
        <trans-unit id="226b6f4e92677bc1f2b570c828b056fbbd0a3d78" translate="yes" xml:space="preserve">
          <source>WebRTC lets you build peer-to-peer communication of arbitrary data, audio, or video&amp;mdash;or any combination thereof&amp;mdash;into a browser application. In this article, we'll look at the lifetime of a WebRTC session, from establishing the connection all the way through closing the connection when it's no longer needed.</source>
          <target state="translated">WebRTC를 사용하면 브라우저 응용 프로그램에 임의의 데이터, 오디오 또는 비디오 또는 이들의 조합으로 피어 투 피어 통신을 구축 할 수 있습니다. 이 기사에서는 WebRTC 세션의 수명을 살펴보고 더 이상 필요하지 않을 때 연결을 닫는 방식으로 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c49098ed693b509d8e422578cbffce2c3edb7499" translate="yes" xml:space="preserve">
          <source>WebRTC serves multiple purposes, and overlaps substantially with the Media Capture and Streams API. Together, they provide powerful multimedia capabilities to the Web, including support for audio and video conferencing, file exchange, identity management, and interfacing with legacy telephone systems by sending &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DTMF&quot;&gt;DTMF&lt;/a&gt; signals. Connections between peers can be made without requiring any special drivers or plug-ins, and can often be made without any intermediary servers.</source>
          <target state="translated">WebRTC는 다양한 용도로 사용되며 미디어 캡처 및 스트림 API와 실질적으로 겹칩니다. 또한 오디오 및 비디오 회의, 파일 교환, ID 관리 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DTMF&quot;&gt;DTMF&lt;/a&gt; 신호 를 전송하여 레거시 전화 시스템과의 인터페이스 지원을 비롯하여 강력한 멀티미디어 기능을 웹에 제공 합니다. 피어 간의 연결은 특별한 드라이버 나 플러그인 없이도 가능하며 중개 서버 없이도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6a399d925b44802a8f9712657b960eb8a5b967ea" translate="yes" xml:space="preserve">
          <source>WebRTC's support for interacting with gateways that link to old-school telephone systems includes support for sending DTMF tones using the &lt;a href=&quot;rtcdtmfsender&quot;&gt;&lt;code&gt;RTCDTMFSender&lt;/code&gt;&lt;/a&gt; interface. This guide shows how to do so.</source>
          <target state="translated">구식 전화 시스템에 연결된 게이트웨이와의 상호 작용을위한 WebRTC의 지원에는 &lt;a href=&quot;rtcdtmfsender&quot;&gt; &lt;code&gt;RTCDTMFSender&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 DTMF 톤을 보내는 기능이 포함 됩니다. 이 안내서는 그렇게하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca36faf2305b4c44b364cab825d592b9dcaef084" translate="yes" xml:space="preserve">
          <source>WebRTC-proper protocols</source>
          <target state="translated">WebRTC 적절한 프로토콜</target>
        </trans-unit>
        <trans-unit id="fd2fe2179b44fad347e37ec201d26ab520f15318" translate="yes" xml:space="preserve">
          <source>WebSocket</source>
          <target state="translated">WebSocket</target>
        </trans-unit>
        <trans-unit id="576299b897ca4628805815218b0baed1fb7b7632" translate="yes" xml:space="preserve">
          <source>WebSocket API Specification</source>
          <target state="translated">WebSocket API 사양</target>
        </trans-unit>
        <trans-unit id="038986d5a9a9cbcf9565fef683bb53d6512064c8" translate="yes" xml:space="preserve">
          <source>WebSocket client applications use the &lt;a href=&quot;../websockets_api&quot;&gt;WebSocket API&lt;/a&gt; to communicate with &lt;a href=&quot;writing_websocket_servers&quot;&gt;WebSocket servers&lt;/a&gt; over the WebSocket protocol.</source>
          <target state="translated">WebSocket 클라이언트 애플리케이션은 &lt;a href=&quot;../websockets_api&quot;&gt;WebSocket API&lt;/a&gt; 를 사용 하여 WebSocket 프로토콜을 통해 &lt;a href=&quot;writing_websocket_servers&quot;&gt;WebSocket 서버&lt;/a&gt; 와 통신 합니다.</target>
        </trans-unit>
        <trans-unit id="ef5f4858a871335a8aa3461355c11222bf1f693f" translate="yes" xml:space="preserve">
          <source>WebSocket codes, extensions, subprotocols, etc. are registered at the &lt;a href=&quot;http://www.iana.org/assignments/websocket/websocket.xml&quot;&gt;IANA WebSocket Protocol Registry&lt;/a&gt;.</source>
          <target state="translated">WebSocket 코드, 확장, 하위 프로토콜 등은 &lt;a href=&quot;http://www.iana.org/assignments/websocket/websocket.xml&quot;&gt;IANA WebSocket Protocol Registry에 등록되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c45187c0b8bec5627c054882ec80f7caf91ccae" translate="yes" xml:space="preserve">
          <source>WebSocket codes, extensions, subprotocols, etc. are registered at the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml&quot;&gt;IANA WebSocket Protocol Registry&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6224da2143fbb8efd488a6793e72cb526ad97b2c" translate="yes" xml:space="preserve">
          <source>WebSocket extensions and subprotocols are negotiated via headers during &lt;a href=&quot;#Handshake&quot;&gt;the handshake&lt;/a&gt;. Sometimes extensions and subprotocols seem too similar to be different things, but there is a clear distinction. Extensions control the WebSocket &lt;strong&gt;frame&lt;/strong&gt; and &lt;strong&gt;modify&lt;/strong&gt; the payload, while subprotocols structure the WebSocket &lt;strong&gt;payload&lt;/strong&gt; and &lt;strong&gt;never modify&lt;/strong&gt; anything. Extensions are optional and generalized (like compression); subprotocols are mandatory and localized (like ones for chat and for MMORPG games).</source>
          <target state="translated">WebSocket 확장 및 하위 프로토콜은 &lt;a href=&quot;#Handshake&quot;&gt;핸드 셰이크&lt;/a&gt; 중에 헤더를 통해 협상됩니다 . 때때로 확장과 서브 프로토콜이 너무 비슷해 보이지만 분명한 차이점이 있습니다. 확장은 웹 소켓의 제어 &lt;strong&gt;프레임&lt;/strong&gt; 및 &lt;strong&gt;수정&lt;/strong&gt; 의 하위 프로토콜은 웹 소켓 구조하는 동안, 페이로드를 &lt;strong&gt;페이로드&lt;/strong&gt; 및 &lt;strong&gt;수정 결코&lt;/strong&gt; 아무것도. 확장은 선택적이고 일반화됩니다 (압축과 같은). 서브 프로토콜은 필수적이며 현지화되어 있습니다 (채팅 및 MMORPG 게임과 같은).</target>
        </trans-unit>
        <trans-unit id="41045a465a50dfc5d5dc8025fc8fcd1d4fd74d19" translate="yes" xml:space="preserve">
          <source>WebSocket handshake library in C++</source>
          <target state="translated">C ++의 WebSocket 핸드 셰이크 라이브러리</target>
        </trans-unit>
        <trans-unit id="39be1e3a1d449510eb1b828fe1847ba870790760" translate="yes" xml:space="preserve">
          <source>WebSocket.binaryType</source>
          <target state="translated">WebSocket.binaryType</target>
        </trans-unit>
        <trans-unit id="1424bf66ff76c342b95c7bab693a34fbcb7eb093" translate="yes" xml:space="preserve">
          <source>WebSocket.bufferedAmount</source>
          <target state="translated">WebSocket.bufferedAmount</target>
        </trans-unit>
        <trans-unit id="5123243db38955a29aa6997fd33a7a9c16f93fc8" translate="yes" xml:space="preserve">
          <source>WebSocket.close</source>
          <target state="translated">WebSocket.close</target>
        </trans-unit>
        <trans-unit id="71282c0a106934a46f1b46206c8e5cc95a916f79" translate="yes" xml:space="preserve">
          <source>WebSocket.constructor</source>
          <target state="translated">WebSocket.constructor</target>
        </trans-unit>
        <trans-unit id="65ff0efaaccf347156267dfcd559ff04e8f7c3f2" translate="yes" xml:space="preserve">
          <source>WebSocket.extensions</source>
          <target state="translated">WebSocket.extensions</target>
        </trans-unit>
        <trans-unit id="bca30ed1a797bae0d04d92518f1a416e243d6efb" translate="yes" xml:space="preserve">
          <source>WebSocket.onclose</source>
          <target state="translated">WebSocket.onclose</target>
        </trans-unit>
        <trans-unit id="76625fe619a50e208c2df30852585086ea13d0cf" translate="yes" xml:space="preserve">
          <source>WebSocket.onerror</source>
          <target state="translated">WebSocket.onerror</target>
        </trans-unit>
        <trans-unit id="47d69feb9f69fd5cf86fc2394efb8a5ab2ec8f65" translate="yes" xml:space="preserve">
          <source>WebSocket.onmessage</source>
          <target state="translated">WebSocket.onmessage</target>
        </trans-unit>
        <trans-unit id="cbae529b31272db2b5a2bcf4bf2f46a70df04060" translate="yes" xml:space="preserve">
          <source>WebSocket.onopen</source>
          <target state="translated">WebSocket.onopen</target>
        </trans-unit>
        <trans-unit id="30ada3de46b20297c98d799144c3001954ae1b8c" translate="yes" xml:space="preserve">
          <source>WebSocket.protocol</source>
          <target state="translated">WebSocket.protocol</target>
        </trans-unit>
        <trans-unit id="56f7dabc7d66c27b0b2c8b16e69e91633295ebfe" translate="yes" xml:space="preserve">
          <source>WebSocket.readyState</source>
          <target state="translated">WebSocket.readyState</target>
        </trans-unit>
        <trans-unit id="dfb673f4b33614106a2ed583024ee67aff538f14" translate="yes" xml:space="preserve">
          <source>WebSocket.send</source>
          <target state="translated">WebSocket.send</target>
        </trans-unit>
        <trans-unit id="da6cc56cf140f2ed0d8b14abefcba008bbbbac16" translate="yes" xml:space="preserve">
          <source>WebSocket.url</source>
          <target state="translated">WebSocket.url</target>
        </trans-unit>
        <trans-unit id="56d0e53e6a7114caaeb10b3ceba94b42ba2520e2" translate="yes" xml:space="preserve">
          <source>WebSockets</source>
          <target state="translated">WebSockets</target>
        </trans-unit>
        <trans-unit id="6710b14e8572af88f20d9c396cdde13b818c160a" translate="yes" xml:space="preserve">
          <source>WebSockets API: WebSocket Server Vb.NET</source>
          <target state="translated">WebSockets API : WebSocket 서버 Vb.NET</target>
        </trans-unit>
        <trans-unit id="251780f6314a16b99122edf56e7e086f4ffe87ce" translate="yes" xml:space="preserve">
          <source>WebSockets API: Writing WebSocket client applications</source>
          <target state="translated">WebSockets API : WebSocket 클라이언트 애플리케이션 작성</target>
        </trans-unit>
        <trans-unit id="2e223500b3688e88b13fa2c7d0d5caf3dbef9649" translate="yes" xml:space="preserve">
          <source>WebSockets API: Writing WebSocket server</source>
          <target state="translated">WebSockets API : WebSocket 서버 작성</target>
        </trans-unit>
        <trans-unit id="393d3c1195f4edb188e45c88faf9ce82e583bf38" translate="yes" xml:space="preserve">
          <source>WebSockets API: Writing WebSocket servers</source>
          <target state="translated">WebSockets API : WebSocket 서버 작성</target>
        </trans-unit>
        <trans-unit id="564af2fd25d946939ac05c4015db0fa92f9d7eb4" translate="yes" xml:space="preserve">
          <source>WebSockets API: Writing a WebSocket server in Java</source>
          <target state="translated">WebSockets API : Java로 WebSocket 서버 작성</target>
        </trans-unit>
        <trans-unit id="cf3e411585d22cacb3a2cc9c820a62922ff3ab84" translate="yes" xml:space="preserve">
          <source>WebSockets communicate over a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; connection. Java's &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html&quot;&gt;ServerSocket&lt;/a&gt; class is located in the &lt;em&gt;java.net&lt;/em&gt; package.</source>
          <target state="translated">WebSocket은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; 연결을 통해 통신 합니다. Java의 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html&quot;&gt;ServerSocket&lt;/a&gt; 클래스는 &lt;em&gt;java.net&lt;/em&gt; 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="30004dae2680aec7f61f5f7429870caece3cc05d" translate="yes" xml:space="preserve">
          <source>WebSockets communicate over a &lt;a href=&quot;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; connection. Luckily, C# has a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.sockets.tcplistener.aspx&quot;&gt;TcpListener&lt;/a&gt; class which does as the name suggests. It is in the &lt;em&gt;System.Net.Sockets&lt;/em&gt; namespace.</source>
          <target state="translated">WebSocket은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; 연결을 통해 통신 합니다. 다행히 C #에는 이름에서 알 수 있듯이 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.net.sockets.tcplistener.aspx&quot;&gt;TcpListener&lt;/a&gt; 클래스가 있습니다. 그것은에 &lt;em&gt;System.Net.Sockets의&lt;/em&gt; 네임 스페이스.</target>
        </trans-unit>
        <trans-unit id="c6305fad2da81030208ae58b83ca52755adb4287" translate="yes" xml:space="preserve">
          <source>WebSockets communicate over a &lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; connection. Java's &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html&quot;&gt;ServerSocket&lt;/a&gt; class is located in the &lt;em&gt;java.net&lt;/em&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495ef5b5acadd64407d52ec44f82a67afb13f057" translate="yes" xml:space="preserve">
          <source>WebSockets communicate over a &lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/a&gt; connection. Luckily, C# has a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.net.sockets.tcplistener.aspx&quot;&gt;TcpListener&lt;/a&gt; class which does as the name suggests. It is in the &lt;em&gt;System.Net.Sockets&lt;/em&gt; namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea42ad424127dc4662c0210251ef537ed2eb8d0" translate="yes" xml:space="preserve">
          <source>WebSockets is an event-driven API; when messages are received, a &quot;message&quot; event is delivered to the &lt;code&gt;onmessage&lt;/code&gt; function. To begin listening for incoming data, you can do something like this:</source>
          <target state="translated">WebSockets는 이벤트 중심 API입니다. 메시지가 수신되면 &quot;메시지&quot;이벤트가 &lt;code&gt;onmessage&lt;/code&gt; 기능으로 전달됩니다 . 들어오는 데이터를 듣기 위해 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30be1272cfac37ff003a03ee52d247085a887f2" translate="yes" xml:space="preserve">
          <source>WebSockets should not be used in a mixed content environment; that is, you shouldn't open a non-secure WebSocket connection from a page loaded using HTTPS or vice-versa. In fact, some browsers explicitly forbid this, including Firefox 8 and later.</source>
          <target state="translated">혼합 컨텐츠 환경에서는 WebSocket을 사용해서는 안됩니다. 즉, HTTPS를 사용하거나 그 반대로로드 된 페이지에서 비보안 WebSocket 연결을 열면 안됩니다. 실제로 Firefox 8 이상을 포함하여 일부 브라우저는이를 명시 적으로 금지합니다.</target>
        </trans-unit>
        <trans-unit id="cb1500981530133e78f412d5520c65354ad6934b" translate="yes" xml:space="preserve">
          <source>WebSockets support in Firefox is continuing to track the evolving WebSocket specification. Firefox 6 implements version 7 of the underlying protocol, while Firefox 7 implements version 8 (as specified by IETF draft 10). Firefox mobile received WebSocket support in Firefox mobile 7.0.</source>
          <target state="translated">Firefox에서 WebSockets 지원은 진화하는 WebSocket 사양을 계속 추적하고 있습니다. Firefox 6은 기본 프로토콜의 버전 7을 구현하는 반면 Firefox 7은 IETF 초안 10에 지정된 버전 8을 구현합니다. Firefox 모바일은 Firefox mobile 7.0에서 WebSocket 지원을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="8e9de9acb012daf63fc0a1d108431b5ffdded290" translate="yes" xml:space="preserve">
          <source>WebUSB</source>
          <target state="translated">WebUSB</target>
        </trans-unit>
        <trans-unit id="a608db591212d3199a6fff48dbbd0894020c9461" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'USB' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'USB'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ed09961743d63f77ceb00e7e062521a8862292b5" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'USBDevice' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'USBDevice'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="05f34352157d7bde664f0c768283341c0480ef8f" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'claimInterface()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'claimInterface ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7dff949784afefb826c5fa8212aff088f90de262" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'clearHalt()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'clearHalt ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5fd925b6fefe42d679d4b884dd2e4855472c2bc7" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'close()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'close ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="775e67789647b45e52566bd8865a0216d6428847" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'configuration' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 '구성'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e22804235bc3d222d6816fc28c320886d53c9919" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'configurations' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 '구성'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="54204f9c9c2740e1aca5dced3aab9796fe2d0d8f" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'controlTransferIn()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'controlTransferIn ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d3eb229797fa3eaa942b1c3f9bd69ec26ff8fd40" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'controlTransferOut()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'controlTransferOut ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e77a57b40903fdd0783e89169fa7e57a164e43a9" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceClass' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceClass'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="91ea9a447be37a7864517fb80f70499fbf50a49f" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceProtocol' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceProtocol'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="feeba0f57b95a9b3d57a3ba8375f3d206bc11169" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceSubclass' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceSubclass'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1870b14aea3d70cf91c460231039023cb5c43e13" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceVersionMajor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceVersionMajor'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="baf6ef0f4300283a3115c3ac7495e06da8e22313" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceVersionMinor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceVersionMinor'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="af93e48d950e855dbcfb2679fbebac27eaa3a25a" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'deviceVersionSubminor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'deviceVersionSubminor'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6da783d74ef13a171cf60aa61655ebcb65cb6" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'getDevices' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'getDevices'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="83e71440c7b4b671346dc5473a44e5a09b60a1c0" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'isochronousTransferIn()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'isochronousTransferIn ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="45eb7ca94077b3b4d4a0cd476bb8a2afe77a8637" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'isochronousTransferOut()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'isochronousTransferOut ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="df37bebf7d000bb943f2bc07d60c8ff393a19987" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'manufacturerName' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'manufacturerName'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fc6f93ea5b7dc8830d37cd2606cc5ea0b0d3db7a" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'onconnect' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'onconnect'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="14875a19121e739e088ebb45893bf5bf06fdb633" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'ondisconnect' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'ondisconnect'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f686f24133c324b9de0aa0beeaafff5905f0e5db" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'open()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'open ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9df7df068b7606f46188b53d2fe92a5c340f8ab6" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'opened' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 '열린'정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="33534827829fb5aef4c879ac1601f6044941297f" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'productID' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'productID'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="24c40fabef23e71749a23972bce37d245412406d" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'productName' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'productName'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="84c25bcade49b488757f25cadc34b31631665472" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'releaseInterface()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'releaseInterface ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bce868411500f924cd8a120698b8148e16a6ed8c" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'requestDevice' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'requestDevice'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4c446fd9fc5bd738e64296ca4a30c1f2d4a8eee7" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'reset()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'reset ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1822240b3806672c51f9d4338bf7b14c5c3d7" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'selectAlternateInterface()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'selectAlternateInterface ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9119a841a8e47b99171c2a45e0260ad3325c6d43" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'selectConfiguration' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'selectConfiguration'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c70f9295d481445061df6996a0479610936e42b6" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'serialNumber' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'serialNumber'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9bb624ed43d11a9a30c24ec7d0ac4a949e4de7e6" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'transferIn()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'transferIn ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dbea2e3d88bd1ccd94c7f5d3c2be6b04bc9790ff" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'transferOut()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'transferOut ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bbe88668befda3e2583cf0dad1916477317fa370" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'usbVersionMajor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'usbVersionMajor'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d492344b443ce8022d63c9f065bda5bb4069dcdc" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'usbVersionMinor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'usbVersionMinor'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="058b0283beb775497ed9687887af388a355c834d" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'usbVersionSubminor' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'usbVersionSubminor'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dfa677d2b647dee84a47f279954539e362066f34" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'vendorID' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebUSB &lt;br/&gt;&lt;small&gt;해당 사양에서 'vendorID'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cbf03bfb03463036b390c3040a60e17abcc0ae30" translate="yes" xml:space="preserve">
          <source>WebVR</source>
          <target state="translated">WebVR</target>
        </trans-unit>
        <trans-unit id="d5b3205d2f50f8459df98f434927a9961edb8576" translate="yes" xml:space="preserve">
          <source>WebVR 1.1</source>
          <target state="translated">WebVR 1.1</target>
        </trans-unit>
        <trans-unit id="59af5d9afd866430a0789c0448673b8b0c2fd755" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRDisplay' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRDisplay'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6d0a97cc40405483442ad2258f77adf38a2c437e" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRDisplayCapabilities' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRDisplayCapabilities'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2c13df3e98fb5d62896f5fb956461dae24275299" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRDisplayEvent' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRDisplayEvent'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d7174db17e878100001003219f6119ada22e612a" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRDisplayEvent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRDisplayEvent ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1a9d6dae0a0952f0c52aae7ddae4f5a93658b568" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VREyeParameters' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VREyeParameters'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e67718560a458237243d01859c0d0c8b5714fb82" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRFieldOfView' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRFieldOfView'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1f216bc26867745a5ef57cc341962173f6ef6a73" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRFrameData()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRFrameData ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a379eaab341495736196732b4a2e511ae9b98016" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRLayerInit' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRLayerInit'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3d7cbb917837d5cf05c3ef8d660a6de634af5433" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRPose' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRPose'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fa9c130ba43855af0fc9068adaf297a051a24521" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'VRStageParameters' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VRStageParameters'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="02397c4d95436837679656a59f4de18f98fbd724" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'angularAcceleration' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'angularAcceleration'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7751e0a0a33c8c4aa88c8296739906da87718ba9" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'angularVelocity' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'angularVelocity'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="26d0be1ba0207b8de23e26e4c4338ced7267aefd" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'canPresent' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'canPresent'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c9a1442d9e241f23e2a488ab201d71b37944ac9d" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'cancelAnimationFrame()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'cancelAnimationFrame ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="97c13d9586cd4af8d4f3331bbc675e12a5b22e53" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'capabilities' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '기능'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5f5097bfce6658d7271c15b9afc8dacfd385bfd0" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'depthFar' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'depthFar'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3c30dae77cc6eb3e60a7866737bfde52fd81cc50" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'depthNear' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'depthNear'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="048a4660e73c9373108c8d8a1b44fce493e0f889" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'display' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '디스플레이'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c43e9f16f4b212865196d4057863ae23344bb5f6" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'displayId' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'displayId'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="be351235869e5db1ee952cfcf176653c5a50282d" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'displayName' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'displayName'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3616886548da3a0fd6ab0d487fc20e9bf1749d3d" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'downDegrees' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'downDegrees'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0f20b3e1c7ed3774664a8b6e360640072a552720" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'exitPresent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'exitPresent ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2db08dc214b7769da90a71ba62ff5704c82c5099" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'fieldOfView' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'fieldOfView'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a7958972975dd775f0b4b1d6aa47efa91ef8560f" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'getEyeParameters()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getEyeParameters ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="603aac8e296bf98925a925995692453f8ac371e7" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'getLayers()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'getLayers ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f6ddd340002ffa81d28381595cafccbf7c387668" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'hasExternalDisplay' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'hasExternalDisplay'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="57b5a83d0ef11ab92ae93acda55a15baacce6b52" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'hasOrientation' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'hasOrientation'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2bb2cd9fc1b345d0bf43c85bcc47d91ba2793948" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'hasPosition' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'hasPosition'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3c655ea8a1f493d20fc7d2b29a23c8e36e282a1c" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'isConnected' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'isConnected'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="054b796a79ed97acdce35dcdb7778ad059039d1f" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'isPresenting' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'isPresenting'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a9e210b5adefc9895d56e04f63c20e4d469768ac" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'leftBounds' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'leftBounds'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="73a36651b292a577ff388616f2a6185cb927f395" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'leftDegrees' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'leftDegrees'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eda8cb7e67ea8bac7665b43b43ad4d59e7067021" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'leftProjectionMatrix' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'leftProjectionMatrix'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c03db19e5725ef4f47d3903bbd5180da0436ec6f" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'leftViewMatrix' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'leftViewMatrix'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c18d665818b649e071deb0ee41a4fedd2a63d1c0" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'linearAcceleration' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'linearAcceleration'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="31ee81ad0fb561f6975e5dcdff7b9b0938b7f46b" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'linearVelocity' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'linearVelocity'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8e865ac4afb98ac5d853118f510c3b86d52679e0" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'maxLayers' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'maxLayers'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3277d32dbb28a84ab80d8b293e4faffc1c081b71" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'offset' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '오프셋'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="956effa638eca1fe8ecea86bdcfe18312280eb99" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplayactivate' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplayactivate'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="11a01fbf76bdb37a438b2d8c87f8fa5b0d333bb1" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplayblur' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplayblur'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="13da7e3449a48e1bc4f67b404c218e02a54a0e58" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplayconnect' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplayconnect'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1401019741591bb28af4d3a9e60094eb6f0b6399" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplaydeactivate' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplaydeactivate'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d4e4f413e87cbd67e4dc75487dd8a9b448b05a47" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplaydisconnect' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplaydisconnect'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c939bdbe987e07ae229a95cd709975931b38661" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplayfocus' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplayfocus'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="290087754c0f1a7bb82b030c763d864bbb2837ae" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'onvrdisplaypresentchange' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'onvrdisplaypresentchange'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6edb5940fcb9b37c59a0193b5e9e5018961c8d0a" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'orientation' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '방향'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="578c08be5e595f3f01da3e96ba21e87ae8a6e8c1" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'pose' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '포즈'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4605071136ee2c35f9cf951effd28953b56cf034" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'position' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '위치'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="81549592f51ae12f07f82d2672d9a53cad60dd49" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'reason' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '이유'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eace4f6e0a0eb1c161f8e11875ac21eb410d172c" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'renderHeight' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'renderHeight'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="96c53b77609cce3ccd487c2862ac6b8a910d6813" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'renderWidth' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'renderWidth'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fb66c2e79e8e33d0e83953ac3427527c07709f41" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'requestAnimationFrame()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'requestAnimationFrame ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="20ffb648bee7786403cc2e2ebc7fa1fe8e7865fd" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'requestPresent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'requestPresent ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d501c58b4e63d5f8b74a979e61903b9402eaff3a" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'rightBounds' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'rightBounds'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="203932b000d1df445a3c2e2d0dd24ef07ca20542" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'rightDegrees' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'rightDegrees'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9e1b7b827b4c9ce110adb8f40bf1aec761f7c4e9" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'rightProjectionMatrix' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'rightProjectionMatrix'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9d7ba20a0a5879c49f00182c0d5bb457fd30ee7b" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'rightViewMatrix' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'rightViewMatrix'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="944587eef3ca9e93714d2e0d7e33ca6a117e292b" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'sittingToStandingTransform' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;small&gt;해당 사양에서 '&lt;/small&gt; sittingToStandingTransform &lt;br/&gt;&lt;small&gt;'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0628288f0ec8088ae9b99acdab34964e3ec24055" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'sizeX' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'sizeX'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="22f391c796d38f22d600c1921595134064dc899e" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'sizeY' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'sizeY'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ac1d6215cb523236e812f2646390a54e9f510bd4" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'source' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '소스'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="93f5367c3e870018b79d56dfe9efcfb11f2c3a72" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'stageParameters' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'stageParameters'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5423f0cf44df3176b0d2917af91b8ddd1812e029" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'submitFrame()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'submitFrame ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4b2a78c38abc11f8a1e313a81f8684f69d6228cc" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'timestamp' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 '타임 스탬프'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3c81090b083e1e036b4362be80acf35414cd1cb0" translate="yes" xml:space="preserve">
          <source>WebVR 1.1&lt;br/&gt;&lt;small&gt;The definition of 'upDegrees' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVR 1.1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'upDegrees'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b84b1e6bc473c24bf5017e621c5e956c8688c42b" translate="yes" xml:space="preserve">
          <source>WebVR API</source>
          <target state="translated">WebVR API</target>
        </trans-unit>
        <trans-unit id="d20a4975ac1578b3770c2bd07e0b9bdb56bbced6" translate="yes" xml:space="preserve">
          <source>WebVR API homepage</source>
          <target state="translated">WebVR API 홈페이지</target>
        </trans-unit>
        <trans-unit id="63bfac0c233bb36fd64ac2cddf05772e69db75b3" translate="yes" xml:space="preserve">
          <source>WebVR API: Concepts</source>
          <target state="translated">WebVR API : 개념</target>
        </trans-unit>
        <trans-unit id="25b8a04b9e6b18aece64983b57aeefa1edc57f77" translate="yes" xml:space="preserve">
          <source>WebVR API: Using VR controllers with WebVR</source>
          <target state="translated">WebVR API : WebVR과 함께 VR 컨트롤러 사용</target>
        </trans-unit>
        <trans-unit id="0deebb8fdd42ed0b0f6a55e8edee15465c61ca12" translate="yes" xml:space="preserve">
          <source>WebVR API: Using the WebVR API</source>
          <target state="translated">WebVR API : WebVR API 사용</target>
        </trans-unit>
        <trans-unit id="95355cb293f200d590ef89c1bb18d2810b7a1314" translate="yes" xml:space="preserve">
          <source>WebVR Interfaces</source>
          <target state="translated">WebVR 인터페이스</target>
        </trans-unit>
        <trans-unit id="08da27ca1761cc40d26fbe4ed79f779cdb80a2e6" translate="yes" xml:space="preserve">
          <source>WebVR events</source>
          <target state="translated">WebVR 이벤트</target>
        </trans-unit>
        <trans-unit id="c65ceab5cd8fc9739026a6ca9e2d5c69d9a3cc7f" translate="yes" xml:space="preserve">
          <source>WebVR provides support for exposing virtual reality devices &amp;mdash; for example head-mounted displays like the Oculus Rift or HTC Vive &amp;mdash; to web apps, enabling developers to translate position and movement information from the display into movement around a 3D scene. This has numerous, interesting applications, from virtual product tours and interactive training apps to immersive first person games.</source>
          <target state="translated">WebVR은 가상 현실 장치 (예 : Oculus Rift 또는 HTC Vive와 같은 헤드 마운트 디스플레이)를 웹 앱에 노출시켜 개발자가 디스플레이의 위치 및 이동 정보를 3D 장면 주위의 움직임으로 변환 할 수 있도록 지원합니다. 여기에는 가상 제품 둘러보기 및 대화식 교육 앱에서 몰입 형 일인칭 게임에 이르기까지 수많은 흥미로운 응용 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b46e11ab296ee8ef01c3f1f94fe9ffd64893f99" translate="yes" xml:space="preserve">
          <source>WebVR's dedicated &lt;a href=&quot;../vrdisplay/requestanimationframe&quot;&gt;&lt;code&gt;VRDisplay.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; method is used to run the app's rendering loop at the correct refresh rate for the display.</source>
          <target state="translated">WebVR의 전용 &lt;a href=&quot;../vrdisplay/requestanimationframe&quot;&gt; &lt;code&gt;VRDisplay.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 메서드는 디스플레이의 올바른 화면 주사율로 앱의 렌더링 루프를 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2edff5ace2bd2df4e5879898ff4ed40dc1e71983" translate="yes" xml:space="preserve">
          <source>WebVR's dedicated &lt;a href=&quot;vrdisplay/requestanimationframe&quot;&gt;&lt;code&gt;VRDisplay.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; method is used to run the app's rendering loop at the correct refresh rate for the display.</source>
          <target state="translated">WebVR의 전용 &lt;a href=&quot;vrdisplay/requestanimationframe&quot;&gt; &lt;code&gt;VRDisplay.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 메서드는 디스플레이의 올바른 화면 주사율로 앱의 렌더링 루프를 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b493ef16fc72100a0de2047ed78ad4120e3f7f5" translate="yes" xml:space="preserve">
          <source>WebVTT</source>
          <target state="translated">WebVTT</target>
        </trans-unit>
        <trans-unit id="aa49c79d1247f2cf9b999d79795cfba011b37fb8" translate="yes" xml:space="preserve">
          <source>WebVTT API</source>
          <target state="translated">WebVTT API</target>
        </trans-unit>
        <trans-unit id="06047f0a2d403c41ecaef342cb431d9d7f7cb1c7" translate="yes" xml:space="preserve">
          <source>WebVTT body</source>
          <target state="translated">WebVTT 바디</target>
        </trans-unit>
        <trans-unit id="39319eb7f217052b46d5b19784d9ca19a9c5a4ee" translate="yes" xml:space="preserve">
          <source>WebVTT comments</source>
          <target state="translated">WebVTT 의견</target>
        </trans-unit>
        <trans-unit id="55fa4614ad2df3a23e5a6436d106b6bf0aa86308" translate="yes" xml:space="preserve">
          <source>WebVTT cues</source>
          <target state="translated">WebVTT 큐</target>
        </trans-unit>
        <trans-unit id="dc6e8d65518c3b714ffc7a0dfe21a5db12f58286" translate="yes" xml:space="preserve">
          <source>WebVTT files</source>
          <target state="translated">WebVTT 파일</target>
        </trans-unit>
        <trans-unit id="0ece3d8d4336694ed4fb0bb94ada44a4951c85e8" translate="yes" xml:space="preserve">
          <source>WebVTT was implemented in Firefox 24 behind the preference &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/Mozilla/Preferences/Preference_reference/media.webvtt.enabled&quot;&gt;media.webvtt.enabled&lt;/a&gt;&lt;/code&gt;, which is disabled by default; you can enable it by setting this preference to &lt;code&gt;true&lt;/code&gt;. WebVTT is enabled by default starting in Firefox 31 and can be disabled by setting the preference to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">WebVTT는 환경 설정 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/Mozilla/Preferences/Preference_reference/media.webvtt.enabled&quot;&gt;media.webvtt.enabled&lt;/a&gt;&lt;/code&gt; 뒤에 Firefox 24에서 구현 되었으며 기본적으로 비활성화되어 있습니다. 이 환경 설정을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 사용할 수 있습니다 . WebVTT는 Firefox 31부터 기본적으로 활성화되어 있으며 환경 설정을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e72ae545706a44a8b42f44f11fc0b2e98a4feca3" translate="yes" xml:space="preserve">
          <source>WebVTT: The Web Video Text Tracks Format</source>
          <target state="translated">WebVTT : 웹 비디오 텍스트 트랙 형식</target>
        </trans-unit>
        <trans-unit id="b3d7522e7cce897dd24e0e3fb95666bd89a1480d" translate="yes" xml:space="preserve">
          <source>WebVTT: The Web Video Text Tracks Format&lt;br/&gt;&lt;small&gt;The definition of 'VTTCue()' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVTT : 웹 비디오 텍스트 트랙 형식 &lt;br/&gt;&lt;small&gt;해당 사양에서 'VTTCue ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b2272fca31fc0ad8671945db7c893398c6da179d" translate="yes" xml:space="preserve">
          <source>WebVTT: The Web Video Text Tracks Format&lt;br/&gt;&lt;small&gt;The definition of 'mode' in that specification.&lt;/small&gt;</source>
          <target state="translated">WebVTT : 웹 비디오 텍스트 트랙 형식 &lt;br/&gt;&lt;small&gt;해당 사양에서 '모드'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d66de80c22964cdbfe40bf6069302060e26f38f3" translate="yes" xml:space="preserve">
          <source>Webkit-based browsers (Google Chrome and Safari, for example) do not fire keypress events on the arrow keys</source>
          <target state="translated">웹킷 기반 브라우저 (예 : Chrome 및 Safari)는 화살표 키에서 키 누르기 이벤트를 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4603a691679e550a20f0e8b14342fe643af35723" translate="yes" xml:space="preserve">
          <source>Webkit-based browsers don't follow the spec for the dialog box. An almost cross-browser working example would be close to the below example.</source>
          <target state="translated">웹킷 기반 브라우저는 대화 상자의 스펙을 따르지 않습니다. 거의 크로스 브라우저 작업 예제는 아래 예제와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="bf13209424bfcfc0d62650fecda1e87ee8878db3" translate="yes" xml:space="preserve">
          <source>Websockets API</source>
          <target state="translated">웹 소켓 API</target>
        </trans-unit>
        <trans-unit id="a488f96116afc1bde67c0b0faf728c1b719ded1a" translate="yes" xml:space="preserve">
          <source>What about Pointer Events?</source>
          <target state="translated">포인터 이벤트는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="9b0228c5d574144761e59b2167fc4ee012cfbf41" translate="yes" xml:space="preserve">
          <source>What adapter.js does</source>
          <target state="translated">adapter.js의 기능</target>
        </trans-unit>
        <trans-unit id="fde8cf68d9cdfff49c0221a1710d1371c2031b58" translate="yes" xml:space="preserve">
          <source>What are you hoping to achieve with this push notification?</source>
          <target state="translated">이 푸시 알림으로 무엇을 달성하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="f1f54e2595da8ad8935eacab78952faec3da608b" translate="yes" xml:space="preserve">
          <source>What data can be passed to a USB device and how it is passed is particular and unique to each device.</source>
          <target state="translated">USB 장치에 전달할 수있는 데이터와 전달 방법은 각 장치마다 고유하고 고유합니다.</target>
        </trans-unit>
        <trans-unit id="036bed5732956d0567ab813afba86c56a1848f23" translate="yes" xml:space="preserve">
          <source>What does the DOM Level 1 Core let me do?</source>
          <target state="translated">DOM Level 1 Core로 무엇을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2f932432eff5106be70528a97b01a7ac600b6f24" translate="yes" xml:space="preserve">
          <source>What exactly happens when you set value of &lt;code&gt;innerHTML&lt;/code&gt;? Doing so causes the user agent to follow these steps:</source>
          <target state="translated">&lt;code&gt;innerHTML&lt;/code&gt; 의 값을 설정하면 정확히 어떻게됩니까 ? 그렇게하면 사용자 에이전트는 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3f3411d3cec9f45f01f629ac1a3dc8bdd6285a3e" translate="yes" xml:space="preserve">
          <source>What happens when a web page element needs to be visible on screen regardless of the visible portion of a web page? For example, what if you need a set of image controls to remain on screen regardless of the pinch zoom level of the device? Current browsers vary in how they handle this. Visual viewport lets web developers solve this by positioning elements relative to what's shown on screen.</source>
          <target state="translated">웹 페이지의 보이는 부분에 관계없이 웹 페이지 요소를 화면에 표시해야하는 경우 어떻게됩니까? 예를 들어, 장치의 핀치 줌 레벨에 관계없이 화면에 이미지 컨트롤을 유지하려면 어떻게해야합니까? 현재 브라우저는이를 처리하는 방법이 다양합니다. 시각적 뷰포트를 통해 웹 개발자는 화면에 표시된 것과 관련하여 요소를 배치하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="713c03e5f5976173474700739054677d438ef529" translate="yes" xml:space="preserve">
          <source>What is a URL?</source>
          <target state="translated">URL이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0eb38c512b62ab87543363903646483d96fa8df7" translate="yes" xml:space="preserve">
          <source>What is a content tree?</source>
          <target state="translated">컨텐츠 트리 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2fa02612a65a46913e3128a95626c5c036901574" translate="yes" xml:space="preserve">
          <source>What is a transformation matrix?</source>
          <target state="translated">변환 행렬이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c78470ea04d7397e1b635563a52f407add3b34c3" translate="yes" xml:space="preserve">
          <source>What is the DOM?</source>
          <target state="translated">DOM이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2f217a795fb3f8aa290c838106a4ca7a6fb9dea0" translate="yes" xml:space="preserve">
          <source>What is the JavaScript relationship between the main window and the secondary window?</source>
          <target state="translated">기본 창과 보조 창 사이의 JavaScript 관계는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0b112cd6cd2cde8a3a6f88e66b9b3f8dff0510f2" translate="yes" xml:space="preserve">
          <source>What technologies use browser data storage?</source>
          <target state="translated">어떤 기술이 브라우저 데이터 스토리지를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="6b6b287a85e933401b0201f18933c78a98ee5553" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s more, if we only wanted to specify the duration of the animation and not its iterations (by default, animations iterate once), we could pass in the milliseconds alone:</source>
          <target state="translated">또한 애니메이션의 지속 시간 만 지정하고 (반복적으로 애니메이션은 한 번만 반복됨) 애니메이션의 지속 시간 만 지정하려는 경우 밀리 초 만 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6145b5e9cc0dbf52f495d0804afaf9484d39173" translate="yes" xml:space="preserve">
          <source>What's the size of the displayed content?</source>
          <target state="translated">표시된 콘텐츠의 크기는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="e3990fb381cffa32deefa8eea8b2d9a4fde47ff2" translate="yes" xml:space="preserve">
          <source>Whatever data the event was initialized with.</source>
          <target state="translated">이벤트가 초기화 된 데이터</target>
        </trans-unit>
        <trans-unit id="ca2bd465b4479fcd4305d5529322e84da770b5f5" translate="yes" xml:space="preserve">
          <source>Whatever size the incoming video is, we're going to scale the resulting image to be 320 pixels wide.</source>
          <target state="translated">들어오는 비디오의 크기에 관계없이 결과 이미지의 크기를 320 픽셀로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="f6659608df6a4cd3b250e285d66a49c50d0e7861" translate="yes" xml:space="preserve">
          <source>Whatever type naturally results from the given expression.</source>
          <target state="translated">어떤식이든지 자연스럽게 주어진 표현에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9a04144c12aa6a0a70aca28f6f197de1ab5301" translate="yes" xml:space="preserve">
          <source>WheelEvent</source>
          <target state="translated">WheelEvent</target>
        </trans-unit>
        <trans-unit id="fac1d1fe0b0eb1f81b9953da28f4aeedd86e0579" translate="yes" xml:space="preserve">
          <source>WheelEvent.constructor</source>
          <target state="translated">WheelEvent.constructor</target>
        </trans-unit>
        <trans-unit id="619d9aee0be6aff1b941215bce7beae317f5fe99" translate="yes" xml:space="preserve">
          <source>WheelEvent.deltaMode</source>
          <target state="translated">WheelEvent.deltaMode</target>
        </trans-unit>
        <trans-unit id="530df52f25e16ad15ad340a5b773eece6ddc3ee2" translate="yes" xml:space="preserve">
          <source>WheelEvent.deltaX</source>
          <target state="translated">WheelEvent.deltaX</target>
        </trans-unit>
        <trans-unit id="89b1d314d69781a23de7f5488f35d0044ad8b642" translate="yes" xml:space="preserve">
          <source>WheelEvent.deltaY</source>
          <target state="translated">WheelEvent.deltaY</target>
        </trans-unit>
        <trans-unit id="90f29909b596bdf728d01e3605ff4cb90d980f6d" translate="yes" xml:space="preserve">
          <source>WheelEvent.deltaZ</source>
          <target state="translated">WheelEvent.deltaZ</target>
        </trans-unit>
        <trans-unit id="b366f165fc87766c0508dfc10f0646226aea680a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;http://kb.mozillazine.org/Layout.scrollbar.side&quot;&gt;&lt;code&gt;layout.scrollbar.side&lt;/code&gt; preference&lt;/a&gt; is set to 1 or to 3 and when the text-direction is set to RTL, &lt;strong&gt;then the vertical scrollbar is positioned on the left&lt;/strong&gt; and this impacts the way clientLeft is computed.</source>
          <target state="translated">경우 &lt;a href=&quot;http://kb.mozillazine.org/Layout.scrollbar.side&quot;&gt; &lt;code&gt;layout.scrollbar.side&lt;/code&gt; 바람직한 것은&lt;/a&gt; 1 ~ 3 및 텍스트 방향이 RTL로 설정 될 때, 설정 &lt;strong&gt;한 다음 수직 스크롤 왼쪽에 위치&lt;/strong&gt; clientLeft 계산하는 방법이 영향.</target>
        </trans-unit>
        <trans-unit id="e488ef5c9a134f84e6efedf8ff60639bff9a986f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; is in effect, many of the timing properties' values are returned as zero unless the server's access policy permits these values to be shared. This requires the server providing the resource to send the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin&quot;&gt;&lt;code&gt;Timing-Allow-Origin&lt;/code&gt;&lt;/a&gt; HTTP response header with a value specifying the origin or origins which are allowed to get the restricted timestamp values.</source>
          <target state="translated">때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS가&lt;/a&gt; 적용되는 서버의 액세스 정책이 값이 공유 할 수 있도록 허용하지 않는 한, 타이밍 속성 '값의 대부분은 0으로 반환됩니다. 이것은 제한된 타임 스탬프 값을 얻을 수있는 오리진을 지정하는 값과 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin&quot;&gt; &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; &lt;/a&gt; HTTP 응답 헤더 를 보내도록 리소스를 제공하는 서버가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="5a454513a6b81081f3d2aef6d48aad89ba8a4646" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; is in effect, many of these values are returned as zero unless the server's access policy permits these values to be shared. This requires the server providing the resource to send the &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; HTTP response header with a value specifying the origin or origins which are allowed to get the restricted timestamp values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 가 유효 할 때 , 서버의 액세스 정책이이 값을 공유 할 수 없으면이 값 중 많은 값이 0으로 리턴됩니다. 이것은 제한된 타임 스탬프 값을 얻을 수있는 오리진을 지정하는 값과 함께 &lt;code&gt;Timing-Allow-Origin&lt;/code&gt; HTTP 응답 헤더 를 보내도록 리소스를 제공하는 서버가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="ce481846e8420903b17f96a18592dd80a1507e54" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;onmessage&quot;&gt;&lt;code&gt;ServiceWorkerContainer.onmessage&lt;/code&gt;&lt;/a&gt; is set up to handle the messages.</source>
          <target state="translated">때 &lt;a href=&quot;onmessage&quot;&gt; &lt;code&gt;ServiceWorkerContainer.onmessage&lt;/code&gt; 이&lt;/a&gt; 설정되어있는 메시지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="37fd3604d60c32592bfbfaf24607fa98c4f3c539" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;requestdata&quot;&gt;&lt;code&gt;MediaRecorder.requestData()&lt;/code&gt;&lt;/a&gt; is called, all media data which has been captured since recording began or the last time a &lt;code&gt;dataavailable&lt;/code&gt; event occurred is delivered; then a new &lt;code&gt;Blob&lt;/code&gt; is created and media capture continues into that blob.</source>
          <target state="translated">경우 &lt;a href=&quot;requestdata&quot;&gt; &lt;code&gt;MediaRecorder.requestData()&lt;/code&gt; &lt;/a&gt; 라고하며, 기록이 마지막으로 시작된 이후 또는 캡처 된 모든 미디어 데이터 &lt;code&gt;dataavailable&lt;/code&gt; 이벤트 전달 발생; 새 &lt;code&gt;Blob&lt;/code&gt; 이 생성되고 미디어 캡처가 해당 Blob으로 계속 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f6f1d5463a817a8412c973fc90283e44e94a28" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;stop&quot;&gt;&lt;code&gt;MediaRecorder.stop()&lt;/code&gt;&lt;/a&gt; is called, all media data which has been captured since recording began or the last time a &lt;code&gt;dataavailable&lt;/code&gt; event occurred is delivered in a &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt;; after this, capturing ends.</source>
          <target state="translated">경우 &lt;a href=&quot;stop&quot;&gt; &lt;code&gt;MediaRecorder.stop()&lt;/code&gt; &lt;/a&gt; 라고하며, 기록이 시작 또는 마지막 시간 이후 포착 된 모든 미디어 데이터 &lt;code&gt;dataavailable&lt;/code&gt; 이벤트 발생이 전달되는 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; ; 그 후 캡처가 끝납니다.</target>
        </trans-unit>
        <trans-unit id="444d9ddf12c8b2fbe8221fd6a24193577f11408a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;my-paragraph&amp;gt;&lt;/code&gt; is used in the document, the slot is populated by a slotable element by including it inside the element with a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/slot&quot;&gt;slot&lt;/a&gt;&lt;/code&gt; attribute with the value &lt;code&gt;my-text&lt;/code&gt;. Here is one such example:</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;my-paragraph&amp;gt;&lt;/code&gt; 문서에서 사용되는 슬롯은 함께 내부 요소를 포함하여 slotable 요소로 채워진 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/slot&quot;&gt;slot&lt;/a&gt;&lt;/code&gt; 의 값과 속성 &lt;code&gt;my-text&lt;/code&gt; . 다음은 그러한 예 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="04aa822d8bbcb068bdc21f48b0f5fdbce29cf5d3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;click()&lt;/code&gt; is used with supported elements (such as an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt;), it fires the element's click event. This event then bubbles up to elements higher in the document tree (or event chain) and fires their click events.</source>
          <target state="translated">시 &lt;code&gt;click()&lt;/code&gt; 지지 요소로 사용된다 (예로서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; ), 상기 원소의 클릭 이벤트를 발생. 그런 다음이 이벤트는 문서 트리 (또는 이벤트 체인)에서 더 높은 요소로 버블 링되어 클릭 이벤트를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="65132caee31533c9af57be2ac85820664bff4824" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;createOffer()&lt;/code&gt; succeeds (fulfilling the promise), we pass the created offer information into &lt;a href=&quot;../rtcpeerconnection/setlocaldescription&quot;&gt;&lt;code&gt;myPeerConnection.setLocalDescription()&lt;/code&gt;&lt;/a&gt;, which configures the connection and media configuration state for the caller's end of the connection.</source>
          <target state="translated">때 &lt;code&gt;createOffer()&lt;/code&gt; (약속을 이행) 성공, 우리는로 만들어 제공하는 정보를 전달 &lt;a href=&quot;../rtcpeerconnection/setlocaldescription&quot;&gt; &lt;code&gt;myPeerConnection.setLocalDescription()&lt;/code&gt; &lt;/a&gt; 연결의 호출자의 끝의 연결 및 미디어 구성 상태를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="12ec6aa7138de9024fcd3345e1aa9a0dd14cd3b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;deleteDatabase()&lt;/code&gt; is called, any other open connections to this particular database will get a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/versionchange_indexedDB&quot;&gt;versionchange&lt;/a&gt; event.</source>
          <target state="translated">때 &lt;code&gt;deleteDatabase()&lt;/code&gt; 호출이 특정 데이터베이스에 열려있는 다른 모든 연결은 얻을 것이다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/versionchange_indexedDB&quot;&gt;versionchange의&lt;/a&gt; 이벤트를.</target>
        </trans-unit>
        <trans-unit id="88e071aadd18ccb69785f866fc1f84d139dd262d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;getData()&lt;/code&gt; is run, we create a new request using the &lt;a href=&quot;../request/request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor, then use it to fetch a specific &lt;code&gt;.txt&lt;/code&gt; file. When the fetch is successful, we read a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/USVString&quot;&gt;&lt;code&gt;USVString&lt;/code&gt;&lt;/a&gt; (text) object out of the response using &lt;code&gt;text()&lt;/code&gt;, then set the &lt;a href=&quot;../element/innerhtml&quot;&gt;&lt;code&gt;innerHTML&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/a&gt; element equal to the text object.</source>
          <target state="translated">때 &lt;code&gt;getData()&lt;/code&gt; 실행되고, 우리가 사용하여 새 요청을 생성 &lt;a href=&quot;../request/request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 생성자를 다음 특정의 가져 오기 위해 사용 &lt;code&gt;.txt&lt;/code&gt; 파일을. 가져 오기에 성공 하면 &lt;code&gt;text()&lt;/code&gt; 사용하여 응답 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/USVString&quot;&gt; &lt;code&gt;USVString&lt;/code&gt; &lt;/a&gt; (text) 객체를 읽은 다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article&quot;&gt; &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;a href=&quot;../element/innerhtml&quot;&gt; &lt;code&gt;innerHTML&lt;/code&gt; &lt;/a&gt; 을 텍스트 객체와 동일하게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="65336506141e49ced35ca01c93a7db42dd169288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;gl.linkProgram&lt;/code&gt; is called, WebGL creates a list of active uniforms. These are possible values of the &lt;code&gt;name&lt;/code&gt; attribute of return values of &lt;a href=&quot;getactiveuniform&quot;&gt;&lt;code&gt;getActiveUniform&lt;/code&gt;&lt;/a&gt;. WebGL generates one or more entries in the list depending on the declared type of the uniform in the shader:</source>
          <target state="translated">때 &lt;code&gt;gl.linkProgram&lt;/code&gt; 이 라고, WebGL을 활성화 유니폼의 목록을 만듭니다. 이것들은 &lt;a href=&quot;getactiveuniform&quot;&gt; &lt;code&gt;getActiveUniform&lt;/code&gt; &lt;/a&gt; 의 반환 값의 &lt;code&gt;name&lt;/code&gt; 속성 값입니다 . WebGL은 셰이더에서 유니폼의 선언 된 유형에 따라 목록에서 하나 이상의 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1c00a4a6c6d9b8d9fd384dfd4eb97749f8c59ee3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key 2&lt;/code&gt; is pressed, another &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event is fired for this new key press, and the &lt;code&gt;key&lt;/code&gt; property value for the event is set to be the string &lt;code&gt;&quot;@&quot;&lt;/code&gt; for the U.S keyboard type and &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; for the UK keyboard type, because of the active modifier &lt;code&gt;shift&lt;/code&gt; key. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; events are fired next because a character key has been produced. As we keep holding the key, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event continues to fire repeatedly and the &lt;a href=&quot;repeat&quot;&gt;&lt;code&gt;KeyboardEvent.repeat&lt;/code&gt;&lt;/a&gt; property is set to &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; events are fired repeatedly as well.</source>
          <target state="translated">때 &lt;code&gt;key 2&lt;/code&gt; 를 누르면, 다른 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트는이 새로운 키를 눌러 해고되고, &lt;code&gt;key&lt;/code&gt; 이벤트에 대한 속성 값은 문자열로 설정되어 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 미국 키보드 유형 및 대한 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 때문에, 영국 키보드 유형을 활성 수정의 &lt;code&gt;shift&lt;/code&gt; 키를 누릅니다. &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; 문자 키가 생성 되었기 때문에 이벤트가 다음에 발사된다. 우리가 키를 계속 누르고으로, &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트가 반복적으로 발생하는 것을 계속하고 &lt;a href=&quot;repeat&quot;&gt; &lt;code&gt;KeyboardEvent.repeat&lt;/code&gt; &lt;/a&gt; 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; 그리고 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; 이벤트도 반복해서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6c34cb56b17056af52fb7c99cb87c7ae6314aa8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key 2&lt;/code&gt; is pressed, another &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event is fired for this new key press, and the &lt;code&gt;key&lt;/code&gt; property value for the event is set to the string &lt;code&gt;&quot;@&quot;&lt;/code&gt; for the U.S keyboard type and &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; for the UK keyboard type, because of the active modifier &lt;code&gt;shift&lt;/code&gt; key. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; events are fired next because a character key has been produced.</source>
          <target state="translated">때 &lt;code&gt;key 2&lt;/code&gt; 를 누르면, 다른 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트는이 새로운 키를 눌러 해고되고, &lt;code&gt;key&lt;/code&gt; 이벤트에 대한 속성 값은 문자열로 설정되어 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 미국 키보드 유형 및 대한 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 의 때문에, 영국 키보드 유형 활성 개질제 &lt;code&gt;shift&lt;/code&gt; 키. &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/beforeinput&quot;&gt;beforeinput&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/input&quot;&gt;input&lt;/a&gt;&lt;/code&gt; 이벤트는 문자 키가 생성 되었기 때문에 옆 소성.</target>
        </trans-unit>
        <trans-unit id="2c8480c2a81a09eeb0c87d28ff0a9ce7012aead0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nodeValue&lt;/code&gt; is defined to be &lt;code&gt;null&lt;/code&gt;, setting it has no effect.</source>
          <target state="translated">때 &lt;code&gt;nodeValue&lt;/code&gt; 를가 정의됩니다 &lt;code&gt;null&lt;/code&gt; 을 설정, 그것은 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e52de17b252d5880c31877f43fc934f53773c5e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;observe()&lt;/code&gt; is called, the specified options are &lt;code&gt;attributes&lt;/code&gt; and &lt;code&gt;attributeOldValue&lt;/code&gt;, which means that changes to attribute values will be reported, and each mutation record will include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord/oldValue&quot;&gt;&lt;code&gt;oldValue&lt;/code&gt;&lt;/a&gt; property specifying the attribute's previous value.</source>
          <target state="translated">때 &lt;code&gt;observe()&lt;/code&gt; 를 호출, 지정된 옵션은 &lt;code&gt;attributes&lt;/code&gt; 및 &lt;code&gt;attributeOldValue&lt;/code&gt; 수단이 속성 값에 대한 변경 사항이보고 될 것으로, 각 돌연변이 레코드가 포함됩니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord/oldValue&quot;&gt; &lt;code&gt;oldValue&lt;/code&gt; 입니다&lt;/a&gt; 속성의 이전 값을 지정하는 속성을.</target>
        </trans-unit>
        <trans-unit id="4b1c9bf5952bdd20fdec294520df81e00480d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;observe()&lt;/code&gt; is called, the specified options include both &lt;code&gt;attributeFilter&lt;/code&gt; and &lt;a href=&quot;subtree&quot;&gt;&lt;code&gt;subtree&lt;/code&gt;&lt;/a&gt;, so that we monitor the attribute values for all of the nodes contained within the subtree rooted at the node with the ID &lt;code&gt;&quot;userlist&quot;&lt;/code&gt;. The &lt;a href=&quot;attributeoldvalue&quot;&gt;&lt;code&gt;attributeOldValue&lt;/code&gt;&lt;/a&gt; option is set to &lt;code&gt;true&lt;/code&gt; because we want the prior value of the changed attributes recorded and reported in the mutation records we receive.</source>
          <target state="translated">&lt;code&gt;observe()&lt;/code&gt; 가 호출 될 때 지정된 옵션에는 &lt;code&gt;attributeFilter&lt;/code&gt; 와 &lt;a href=&quot;subtree&quot;&gt; &lt;code&gt;subtree&lt;/code&gt; 가&lt;/a&gt; 모두 포함 되어 있으므로 ID가 &lt;code&gt;&quot;userlist&quot;&lt;/code&gt; 인 노드에서 루트로 지정된 서브 트리 내에 포함 된 모든 노드의 속성 값을 모니터합니다 . &lt;a href=&quot;attributeoldvalue&quot;&gt; &lt;code&gt;attributeOldValue&lt;/code&gt; 의&lt;/a&gt; 옵션이 설정되어 &lt;code&gt;true&lt;/code&gt; 우리가 기록하고 우리가받는 돌연변이 기록에보고 변경된 속성의 이전 값을 원하기 때문에.</target>
        </trans-unit>
        <trans-unit id="c9c343d598c9e96a7a03caf3c687ec12d1d09163" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;containsNode()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when a part of the node is part of the selection. When &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;containsNode()&lt;/code&gt; only returns &lt;code&gt;true&lt;/code&gt; when the entire node is part of the selection. If not specified, the default value &lt;code&gt;false&lt;/code&gt; is used.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;containsNode()&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 노드의 일부가 선택의 일부가됩니다. 때 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;containsNode()&lt;/code&gt; 단지 반환 &lt;code&gt;true&lt;/code&gt; 전체 노드가 선택의 일부가됩니다. 지정하지 않으면 기본값 &lt;code&gt;false&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1757cf49fb75cb499296668fa0e7aa95bef7e4ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enabled&lt;/code&gt; indicates that the track is permitted to render its actual media to the output. When &lt;code&gt;enabled&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the track only generates empty frames.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;enabled&lt;/code&gt; 트랙이 출력에 실제 미디어를 렌더링 할 수 있다는 것을 표시합니다. &lt;code&gt;enabled&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 트랙은 빈 프레임 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="345021d319f05760aca16e21f0fe5435e012d3af" translate="yes" xml:space="preserve">
          <source>When Mozilla parses a document, it builds a content tree and then uses it to display the document.</source>
          <target state="translated">Mozilla는 문서를 구문 분석 할 때 컨텐츠 트리를 작성한 다음이를 사용하여 문서를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ca4d8728e537e63f8bff68b844691beb5929709a" translate="yes" xml:space="preserve">
          <source>When Pointer lock is enabled, the standard &lt;a href=&quot;mouseevent&quot;&gt;&lt;code&gt;MouseEvent&lt;/code&gt;&lt;/a&gt; properties &lt;a href=&quot;mouseevent/clientx&quot;&gt;&lt;code&gt;clientX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mouseevent/clienty&quot;&gt;&lt;code&gt;clientY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mouseevent/screenx&quot;&gt;&lt;code&gt;screenX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mouseevent/screeny&quot;&gt;&lt;code&gt;screenY&lt;/code&gt;&lt;/a&gt; are held constant, as if the mouse is not moving. The &lt;a href=&quot;mouseevent/movementx&quot;&gt;&lt;code&gt;movementX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;mouseevent/movementy&quot;&gt;&lt;code&gt;movementY&lt;/code&gt;&lt;/a&gt; properties continue to provide the mouse's change in position. There is no limit to &lt;a href=&quot;mouseevent/movementx&quot;&gt;&lt;code&gt;movementX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;mouseevent/movementy&quot;&gt;&lt;code&gt;movementY&lt;/code&gt;&lt;/a&gt; values if the mouse is continuously moving in a single direction. The concept of the mouse cursor does not exist and the cursor cannot move off the window or be clamped by a screen edge.</source>
          <target state="translated">포인터 잠금이 활성화되면 마우스가 움직이지 않는 것처럼 표준 &lt;a href=&quot;mouseevent&quot;&gt; &lt;code&gt;MouseEvent&lt;/code&gt; &lt;/a&gt; 속성 &lt;a href=&quot;mouseevent/clientx&quot;&gt; &lt;code&gt;clientX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mouseevent/clienty&quot;&gt; &lt;code&gt;clientY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mouseevent/screenx&quot;&gt; &lt;code&gt;screenX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mouseevent/screeny&quot;&gt; &lt;code&gt;screenY&lt;/code&gt; &lt;/a&gt; 가 일정하게 유지됩니다. &lt;a href=&quot;mouseevent/movementx&quot;&gt; &lt;code&gt;movementX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mouseevent/movementy&quot;&gt; &lt;code&gt;movementY&lt;/code&gt; &lt;/a&gt; 속성은 위치에 마우스의 변화를 지속적으로 제공. 마우스가 한 방향으로 계속 움직이면 &lt;a href=&quot;mouseevent/movementx&quot;&gt; &lt;code&gt;movementX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mouseevent/movementy&quot;&gt; &lt;code&gt;movementY&lt;/code&gt; &lt;/a&gt; 값에 제한이 없습니다 . 마우스 커서의 개념이 없으며 커서가 창 밖으로 이동하거나 화면 가장자리에 의해 고정 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2cc019597471a6524f1bac1cf983ebeb02ba98ae" translate="yes" xml:space="preserve">
          <source>When a &quot;message&quot; event occurs on the remote channel, our &lt;code&gt;handleReceiveMessage()&lt;/code&gt; method is called as the event handler.</source>
          <target state="translated">&quot;메시지&quot;이벤트가 원격 채널에서 발생하면 &lt;code&gt;handleReceiveMessage()&lt;/code&gt; 메소드가 이벤트 핸들러로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="db8d7aef4a6cbdd35681f9dc8ef8559bbe58481c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt; object is created, its &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection-binarytype&quot;&gt;&lt;code&gt;binaryType&lt;/code&gt;&lt;/a&gt; IDL attribute &lt;em&gt;MUST&lt;/em&gt; be set to the string &quot;&lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-binarytype-arraybuffer&quot;&gt;&lt;code&gt;arraybuffer&lt;/code&gt;&lt;/a&gt;&quot;. Upon getting, the attribute &lt;em&gt;MUST&lt;/em&gt; return its most recent value (the value it was last set as). Upon setting, the user agent &lt;em&gt;MUST&lt;/em&gt; set the IDL attribute to the new value.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 객체가 생성 될 때 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection-binarytype&quot;&gt; &lt;code&gt;binaryType&lt;/code&gt; &lt;/a&gt; IDL 속성 &lt;em&gt;은 반드시&lt;/em&gt; 문자열 &quot; &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dom-binarytype-arraybuffer&quot;&gt; &lt;code&gt;arraybuffer&lt;/code&gt; &lt;/a&gt; &quot; 로 설정되어야합니다 . 가져 오면 속성 &lt;em&gt;은&lt;/em&gt; 가장 최근 값 (마지막으로 설정된 값)을 반환 &lt;em&gt;해야&lt;/em&gt; 합니다. 설정시 사용자 에이전트는 &lt;em&gt;반드시&lt;/em&gt; IDL 속성을 새 값으로 설정 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5c1ea3d0e0172f80b7df79e8cf8711be3effa5e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationrequest&quot;&gt;&lt;code&gt;&lt;code&gt;PresentationRequest&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; is constructed, the given &lt;code&gt;urls&lt;/code&gt;&lt;em&gt;MUST&lt;/em&gt; be used as the list of</source>
          <target state="translated">때 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationrequest&quot;&gt; &lt;code&gt;&lt;code&gt;PresentationRequest&lt;/code&gt;&lt;/code&gt; 가&lt;/a&gt; 구성되고, 주어진 &lt;code&gt;urls&lt;/code&gt; &lt;em&gt;반드시&lt;/em&gt; 리스트로서 사용될</target>
        </trans-unit>
        <trans-unit id="f15de1917621493e40f0358221679fb1576990bf" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;web_authentication_api&quot;&gt;WebAuthn&lt;/a&gt; authenticator creates a new &lt;a href=&quot;publickeycredential&quot;&gt;PublicKeyCredential&lt;/a&gt; via a &lt;a href=&quot;credentialscontainer/create&quot;&gt;create()&lt;/a&gt; call, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/response&quot;&gt;&lt;code&gt;PublicKeyCredential.response&lt;/code&gt;&lt;/a&gt; value will be an AuthenticatorAttestationResponse object. This object contains two properties: 1) a clientDataJSON property inherited from &lt;a href=&quot;authenticatorresponse&quot;&gt;AuthenticatorResponse&lt;/a&gt;; and 2) an attestationObject that is an authenticator's way of providing a root of trust for the newly created keypair.</source>
          <target state="translated">때 &lt;a href=&quot;web_authentication_api&quot;&gt;WebAuthn의&lt;/a&gt; 인증은 새로운 생성 &lt;a href=&quot;publickeycredential&quot;&gt;PublicKeyCredential를&lt;/a&gt; 비아 &lt;a href=&quot;credentialscontainer/create&quot;&gt;생성 ()&lt;/a&gt; 호출은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/response&quot;&gt; &lt;code&gt;PublicKeyCredential.response&lt;/code&gt; 의&lt;/a&gt; 값은 AuthenticatorAttestationResponse 객체가 될 것이다. 이 객체에는 두 가지 속성이 있습니다. 1) &lt;a href=&quot;authenticatorresponse&quot;&gt;AuthenticatorResponse&lt;/a&gt; 에서 상속 된 clientDataJSON 속성 ; 그리고 2) 새로 생성 된 키 쌍에 대한 신뢰의 루트를 제공하는 인증 자의 방법 인 증명 객체.</target>
        </trans-unit>
        <trans-unit id="8e8dbe9d1d32e1d29a72a5f4a20a1d66a5043d36" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;web_authentication_api&quot;&gt;WebAuthn&lt;/a&gt; authenticator peforms an authentication via the &lt;a href=&quot;credentialscontainer/get&quot;&gt;get()&lt;/a&gt; call, the result is a new &lt;a href=&quot;publickeycredential&quot;&gt;PublicKeyCredential&lt;/a&gt;, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/response&quot;&gt;&lt;code&gt;PublicKeyCredential.response&lt;/code&gt;&lt;/a&gt; value will be an AuthenticatorAssertionResponse object. This object contains both the client data (i.e. - browser data) for the authentication as well as the data from the authenticator to cryptographically prove that the authentication is valid.</source>
          <target state="translated">때 &lt;a href=&quot;web_authentication_api&quot;&gt;WebAuthn의&lt;/a&gt; 비아 인증 자 peforms 인증 &lt;a href=&quot;credentialscontainer/get&quot;&gt;GET ()&lt;/a&gt; 호출이 결과는 새로운 &lt;a href=&quot;publickeycredential&quot;&gt;PublicKeyCredential&lt;/a&gt; 상기 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/response&quot;&gt; &lt;code&gt;PublicKeyCredential.response&lt;/code&gt; 의&lt;/a&gt; 값은 AuthenticatorAssertionResponse 객체가 될 것이다. 이 객체에는 인증을위한 클라이언트 데이터 (예 : 브라우저 데이터)와 인증 자로부터의 데이터가 모두 포함되어 인증이 유효하다는 것을 암호화 적으로 증명합니다.</target>
        </trans-unit>
        <trans-unit id="fa34bac4d5b78f5f1179d4b152cfc4ae7349c7a9" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; event occurs, here's what happens:</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; 이벤트가 발생, 여기에 무슨이다 :</target>
        </trans-unit>
        <trans-unit id="f6d89216914f956d4fbebbcc7442ca653da053ff" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; event is fired, different functions are called depending on the value of the event's &lt;code&gt;pressure&lt;/code&gt; property.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; 의 이벤트가 시작되어, 다른 기능은 이벤트의 값에 따라 호출되는 &lt;code&gt;pressure&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="d1bc0127174ea8c77a00aefc46589818ea9560ff" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; event is fired, different functions are called depending on the value of the event's &lt;code&gt;tangentialPressure&lt;/code&gt; property.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; 의 이벤트가 시작되어, 다른 기능은 이벤트의 값에 따라이라고 &lt;code&gt;tangentialPressure&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="eaab6831a7831a72438145e6c037c253150aa3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; event is fired, different functions are called depending on the value of the event's &lt;code&gt;twist&lt;/code&gt; property.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; 의 이벤트가 시작되어, 다른 기능은 이벤트의 값에 따라이라고 &lt;code&gt;twist&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c22521f8ba3e847b30e6eac77cb27b3d878f164a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; event occurs, indicating that a new touch on the surface has occurred, the &lt;code&gt;handleStart()&lt;/code&gt; function below is called.</source>
          <target state="translated">표면에 새로운 터치가 발생했음을 나타내는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerdown&quot;&gt;pointerdown&lt;/a&gt;&lt;/code&gt; 이벤트가 발생 하면 아래 &lt;code&gt;handleStart()&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8a2d44dfe13d1de375d1c7d01d298004d9defbcc" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; event occurs, indicating that a new touch on the surface has occurred, the &lt;code&gt;handleStart()&lt;/code&gt; function below is called.</source>
          <target state="translated">표면에 새로운 터치가 발생했음을 나타내는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchstart&quot;&gt;touchstart&lt;/a&gt;&lt;/code&gt; 이벤트가 발생 하면 아래 &lt;code&gt;handleStart()&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdd910e97d79fa321f055c4dc8dfdbb7c055e66" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MediaRecorder&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;pause()&lt;/code&gt;method is called, the browser queues a task that runs the below steps:</source>
          <target state="translated">때 &lt;code&gt;MediaRecorder&lt;/code&gt; 의 객체의 &lt;code&gt;pause()&lt;/code&gt; 메소드가 호출 될 때, 브라우저는 단계 아래 실행되는 작업을 큐 :</target>
        </trans-unit>
        <trans-unit id="4cc16ebe21ea63886b323aaaf83b81d8d5338f84" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MediaRecordingErrorEvent&lt;/code&gt; occurs, you can determine to some extent what went wrong by examining the &lt;code&gt;error&lt;/code&gt; property within the &lt;code&gt;MediaRecorderErrorEvent&lt;/code&gt; received by the &lt;code&gt;MediaRecorder&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; event handler, &lt;a href=&quot;../mediarecorder/onerror&quot;&gt;&lt;code&gt;onerror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;MediaRecordingErrorEvent&lt;/code&gt; 가 발생, 당신은 검사에 의해 잘못 됐는지 어느 정도 확인할 수 있습니다 &lt;code&gt;error&lt;/code&gt; 내에서 속성을 &lt;code&gt;MediaRecorderErrorEvent&lt;/code&gt; 가 에 의해받은 &lt;code&gt;MediaRecorder&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러 &lt;a href=&quot;../mediarecorder/onerror&quot;&gt; &lt;code&gt;onerror&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71f659da0089676b3e8bb144ea5c6b801b333ea1" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MediaSource&lt;/code&gt; object is played by an HTML media element, this property will return a &lt;a href=&quot;timeranges&quot;&gt;&lt;code&gt;TimeRanges&lt;/code&gt;&lt;/a&gt; object that contains the time ranges that the user is able to seek to.</source>
          <target state="translated">때 &lt;code&gt;MediaSource&lt;/code&gt; 의 객체가 HTML 미디어 요소에 의해 재생이 속성은 반환 &lt;a href=&quot;timeranges&quot;&gt; &lt;code&gt;TimeRanges&lt;/code&gt; 는&lt;/a&gt; 그 사용자가 추구 할 수있는 시간 범위를 포함 객체.</target>
        </trans-unit>
        <trans-unit id="b974a471a5e235abc87ad5ee3a086ae97c3d72ba" translate="yes" xml:space="preserve">
          <source>When a &lt;strong&gt;JavaScript runtime error&lt;/strong&gt; (including syntax errors and exceptions thrown within handlers) occurs, an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; event using interface &lt;a href=&quot;../errorevent&quot;&gt;&lt;code&gt;ErrorEvent&lt;/code&gt;&lt;/a&gt; is fired at &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;window.onerror()&lt;/code&gt; is invoked (as well as handlers attached by &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt;&lt;code&gt;window.addEventListener&lt;/code&gt;&lt;/a&gt; (not only capturing)).</source>
          <target state="translated">때 &lt;strong&gt;자바 스크립트 런타임 오류&lt;/strong&gt; (핸들러 내에서 발생 구문 오류 및 예외 포함)가 발생 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 이벤트 &lt;a href=&quot;../errorevent&quot;&gt; &lt;code&gt;ErrorEvent&lt;/code&gt; &lt;/a&gt; 에서 발사되는 &lt;a href=&quot;../window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;window.onerror()&lt;/code&gt; 호출 (뿐만 아니라 의해 부착 핸들러되어 &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt; &lt;code&gt;window.addEventListener&lt;/code&gt; &lt;/a&gt; (만 캡처되지 않음) ).</target>
        </trans-unit>
        <trans-unit id="91d3918a3715a5bbab51c7f40a0a631eeb86426f" translate="yes" xml:space="preserve">
          <source>When a PublicKeyCredential has been created with the &lt;a href=&quot;credentialscontainer/create&quot;&gt;create()&lt;/a&gt; call, it will include an AuthenticatorAttestationResponse. This is the authenticator's way of providing a cryptographic root of trust for the new key pair that has been generated.</source>
          <target state="translated">&lt;a href=&quot;credentialscontainer/create&quot;&gt;create ()&lt;/a&gt; 호출 로 PublicKeyCredential을 만들면 AuthenticatorAttestationResponse가 포함됩니다. 이는 생성 된 새 키 쌍에 대해 암호화 신뢰 루트를 제공하는 인증 자의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="da7b9855efbd15898a4a422fcac4f21fb9b47476" translate="yes" xml:space="preserve">
          <source>When a PublicKeyCredential is the result of a &lt;a href=&quot;credentialscontainer/get&quot;&gt;get()&lt;/a&gt; call, it will include an AuthenticatorAssertionResponse. This is the authenticator's way of proving to a service that it has the key pair and that the authentication request is valid and approved.</source>
          <target state="translated">PublicKeyCredential이 &lt;a href=&quot;credentialscontainer/get&quot;&gt;get ()&lt;/a&gt; 호출 의 결과 인 경우 AuthenticatorAssertionResponse가 포함됩니다. 인증자가 키 쌍을 가지고 있고 인증 요청이 유효하고 승인되었음을 서비스에 증명하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ab1f8980074555e16cfbb37c2ce666ecd656410c" translate="yes" xml:space="preserve">
          <source>When a binary message is received on the data channel, the resulting &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/message&quot;&gt;message&lt;/a&gt;&lt;/code&gt; event's &lt;a href=&quot;../messageevent/data&quot;&gt;&lt;code&gt;MessageEvent.data&lt;/code&gt;&lt;/a&gt; property is an object of the type specified by the &lt;code&gt;binaryType&lt;/code&gt;.</source>
          <target state="translated">데이터 채널에서 이진 메시지가 수신되면 결과 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/message&quot;&gt;message&lt;/a&gt;&lt;/code&gt; 이벤트의 &lt;a href=&quot;../messageevent/data&quot;&gt; &lt;code&gt;MessageEvent.data&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;binaryType&lt;/code&gt; 에 의해 지정된 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="ee33e03c75654a7dfc5bc4d68ca37f09202ca87b" translate="yes" xml:space="preserve">
          <source>When a buffer plays, you will hear the left most sample frame, and then the one right next to it, etc. In the case of stereo, you will hear both channels at the same time. Sample frames are very useful, because they are independent of the number of channels, and represent time, in a useful way for doing precise audio manipulation.</source>
          <target state="translated">버퍼가 재생되면 가장 왼쪽에있는 샘플 프레임이 들리고 그 다음에 오른쪽에있는 프레임이 들립니다. 스테레오의 경우 두 채널을 동시에들을 수 있습니다. 샘플 프레임은 채널 수에 독립적이며 정확한 오디오 조작을위한 유용한 방법으로 시간을 나타내므로 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5919c1e5e00e624eabdba7fd27e2625bb0eb4713" translate="yes" xml:space="preserve">
          <source>When a button is pressed, the generation is stopped, the stream is closed using &lt;a href=&quot;../readablestreamdefaultcontroller/close&quot;&gt;&lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt;&lt;/a&gt;, and another function is run, which reads the data back out of the stream.</source>
          <target state="translated">버튼을 누르면 생성이 중지되고 &lt;a href=&quot;../readablestreamdefaultcontroller/close&quot;&gt; &lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt; &lt;/a&gt; 사용하여 스트림이 닫히고 다른 함수가 실행되어 스트림에서 데이터를 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6ceabaaf43dd282fe0e74a6660b5b256c897f70e" translate="yes" xml:space="preserve">
          <source>When a button is pressed, the generation is stopped, the stream is closed using &lt;a href=&quot;close&quot;&gt;&lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt;&lt;/a&gt;, and another function is run, which reads the data back out of the stream.</source>
          <target state="translated">버튼을 누르면 생성이 중지되고 &lt;a href=&quot;close&quot;&gt; &lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt; &lt;/a&gt; 사용하여 스트림이 닫히고 다른 함수가 실행되어 스트림에서 데이터를 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5f1b6e8981c958a39fac0d9a6265ac5fc03e11dc" translate="yes" xml:space="preserve">
          <source>When a button is pressed, the generation is stopped, the stream is closed using &lt;a href=&quot;readablestreamdefaultcontroller/close&quot;&gt;&lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt;&lt;/a&gt;, and another function is run, which reads the data back out of the stream.</source>
          <target state="translated">버튼을 누르면 생성이 중지되고 &lt;a href=&quot;readablestreamdefaultcontroller/close&quot;&gt; &lt;code&gt;ReadableStreamDefaultController.close()&lt;/code&gt; &lt;/a&gt; 사용하여 스트림이 닫히고 다른 함수가 실행되어 스트림에서 데이터를 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="bb6938d0c8bb2150829e80674b04f1b098a9ab09" translate="yes" xml:space="preserve">
          <source>When a client connects to a server, it sends a GET request to upgrade the connection to a WebSocket from a simple HTTP request. This is known as handshaking.</source>
          <target state="translated">클라이언트가 서버에 연결하면 간단한 HTTP 요청에서 WebSocket으로의 연결을 업그레이드하기 위해 GET 요청을 보냅니다. 이것을 핸드 쉐이킹이라고합니다.</target>
        </trans-unit>
        <trans-unit id="be49d99cffd1e6757e32c1e4eaeba72132d012f7" translate="yes" xml:space="preserve">
          <source>When a database is first created, its version is the integer 1. Each database has one version at a time; a database can't exist in multiple versions at once. The only way to change the version is by opening it with a greater version than the current one. This will start a &lt;a href=&quot;../idbversionchangerequest&quot;&gt;&lt;code&gt;versionchange&lt;/code&gt;&lt;/a&gt;&lt;em&gt;transaction&lt;/em&gt; and fire an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Reference/Events/upgradeneeded_indexedDB&quot;&gt;&lt;code&gt;upgradeneeded&lt;/code&gt;&lt;/a&gt; event. The only place where the schema of the database can be updated is inside the handler of that event.</source>
          <target state="translated">데이터베이스가 처음 작성 될 때 해당 버전은 정수 1입니다. 각 데이터베이스는 한 번에 하나의 버전을 갖습니다. 데이터베이스는 한 번에 여러 버전으로 존재할 수 없습니다. 버전을 변경하는 유일한 방법은 현재 버전보다 큰 버전으로 여는 것입니다. 이것은 시작됩니다 &lt;a href=&quot;../idbversionchangerequest&quot;&gt; &lt;code&gt;versionchange&lt;/code&gt; 의&lt;/a&gt;&lt;em&gt; 거래를&lt;/em&gt; 하고 화재 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Reference/Events/upgradeneeded_indexedDB&quot;&gt; &lt;code&gt;upgradeneeded&lt;/code&gt; &lt;/a&gt; 이벤트를. 데이터베이스의 스키마를 업데이트 할 수있는 유일한 위치는 해당 이벤트의 핸들러 내부입니다.</target>
        </trans-unit>
        <trans-unit id="c3cdcafef0d709455ed24ef9f1099fd59b09176a" translate="yes" xml:space="preserve">
          <source>When a drag occurs, a translucent image is generated from the drag target (the element the &quot;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt;&quot; event is fired at), and follows the mouse pointer during the drag. This image is created automatically, so you do not need to create it yourself. However, you can use &lt;a href=&quot;../datatransfer/setdragimage&quot;&gt;&lt;code&gt;setDragImage()&lt;/code&gt;&lt;/a&gt; to specify a custom drag feedback image.</source>
          <target state="translated">드래그가 발생하면 드래그 대상 ( &quot; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; &quot;이벤트가 시작된 요소)에서 반투명 이미지가 생성되고 드래그 하는 동안 마우스 포인터를 따라갑니다. 이 이미지는 자동으로 만들어 지므로 직접 만들 필요는 없습니다. 그러나 &lt;a href=&quot;../datatransfer/setdragimage&quot;&gt; &lt;code&gt;setDragImage()&lt;/code&gt; &lt;/a&gt; 를 사용하여 사용자 정의 드래그 피드백 이미지를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b766074238c14a92fcafc2b3f8a96a6e2c023745" translate="yes" xml:space="preserve">
          <source>When a drag occurs, a translucent image is generated from the drag target (the element the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; event is fired at), and follows the mouse pointer during the drag. This image is created automatically, so you do not need to create it yourself. However, if a custom image is desired, the &lt;code&gt;DataTransfer.setDragImage()&lt;/code&gt; method can be used to set the custom image to be used.</source>
          <target state="translated">드래그가 발생하면 드래그 대상 ( &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; 이벤트가 발생한 요소)에서 반투명 이미지가 생성되고 드래그 중에 마우스 포인터를 따라갑니다. 이 이미지는 자동으로 만들어 지므로 직접 만들 필요는 없습니다. 그러나 사용자 지정 이미지가 필요한 경우 &lt;code&gt;DataTransfer.setDragImage()&lt;/code&gt; 메서드를 사용하여 사용할 사용자 지정 이미지를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c776bdeb340d9fa318a532c906d85aa61b493b96" translate="yes" xml:space="preserve">
          <source>When a drag occurs, data must be associated with the drag which identifies &lt;em&gt;what&lt;/em&gt; is being dragged. For example, when dragging the selected text within a textbox, the data associated with the &lt;em&gt;drag data item&lt;/em&gt; is the text itself. Similarly, when dragging a link on a web page, the drag data item is the URL of the link.</source>
          <target state="translated">드래그가 발생하면 데이터가 식별 드래그와 연결되어 있어야합니다 &lt;em&gt;무엇을&lt;/em&gt; 끌고있다. 예를 들어, 텍스트 상자 내에서 선택한 텍스트를 드래그 할 때 &lt;em&gt;드래그 데이터 항목&lt;/em&gt; 과 관련된 &lt;em&gt;데이터&lt;/em&gt; 는 텍스트 자체입니다. 마찬가지로, 웹 페이지에서 링크를 드래그 할 때 드래그 데이터 항목은 링크의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="a11780b7bd6fe28eef00dc6958f4cd8f037839ea" translate="yes" xml:space="preserve">
          <source>When a frame &lt;a href=&quot;../performanceobserver&quot;&gt;&lt;code&gt;observer&lt;/code&gt;&lt;/a&gt; is invoked, the observer callback is given one argument that is a &lt;a href=&quot;../performanceobserverentrylist&quot;&gt;&lt;code&gt;PerformanceObserverEntryList&lt;/code&gt;&lt;/a&gt; object. This object has three methods to retrieve frame data:</source>
          <target state="translated">프레임 &lt;a href=&quot;../performanceobserver&quot;&gt; &lt;code&gt;observer&lt;/code&gt; &lt;/a&gt; 가 호출되면 옵저버 콜백에는 &lt;a href=&quot;../performanceobserverentrylist&quot;&gt; &lt;code&gt;PerformanceObserverEntryList&lt;/code&gt; &lt;/a&gt; 객체 인 하나의 인수가 제공 됩니다. 이 객체에는 프레임 데이터를 검색하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="042fbea73c1a13406e05a52337d95b9965f1a347" translate="yes" xml:space="preserve">
          <source>When a frame &lt;a href=&quot;performanceobserver&quot;&gt;&lt;code&gt;observer&lt;/code&gt;&lt;/a&gt; is invoked, frame &lt;a href=&quot;performanceentry&quot;&gt;&lt;code&gt;performance entries&lt;/code&gt;&lt;/a&gt; can be retrieved by calling &lt;a href=&quot;performanceobserverentrylist/getentriesbytype&quot;&gt;&lt;code&gt;PerformanceObserverEntryList.getEntriesByType()&lt;/code&gt;&lt;/a&gt; with an argument of &quot;&lt;code&gt;frame&lt;/code&gt;&quot;. This method returns a list of &quot;&lt;code&gt;frame&lt;/code&gt;&quot; &lt;a href=&quot;performanceentry&quot;&gt;&lt;code&gt;PerformanceEntry&lt;/code&gt;&lt;/a&gt; objects. Each frame object's &lt;a href=&quot;performanceentry/duration&quot;&gt;&lt;code&gt;duration&lt;/code&gt;&lt;/a&gt; property returns the timestamp of two consecutive frames. If this value is greater than the time needed to provide a good user experience, further analysis might be warranted.</source>
          <target state="translated">프레임 &lt;a href=&quot;performanceobserver&quot;&gt; &lt;code&gt;observer&lt;/code&gt; &lt;/a&gt; 가 호출되면 &quot; &lt;code&gt;frame&lt;/code&gt; &quot; 인수로 &lt;a href=&quot;performanceobserverentrylist/getentriesbytype&quot;&gt; &lt;code&gt;PerformanceObserverEntryList.getEntriesByType()&lt;/code&gt; &lt;/a&gt; 을 호출하여 프레임 &lt;a href=&quot;performanceentry&quot;&gt; &lt;code&gt;performance entries&lt;/code&gt; &lt;/a&gt; 을 검색 할 수 있습니다 . 이 메소드는 &quot; &lt;code&gt;frame&lt;/code&gt; &quot; &lt;a href=&quot;performanceentry&quot;&gt; &lt;code&gt;PerformanceEntry&lt;/code&gt; &lt;/a&gt; 오브젝트 목록을 리턴 합니다. 각 프레임 객체의 &lt;a href=&quot;performanceentry/duration&quot;&gt; &lt;code&gt;duration&lt;/code&gt; &lt;/a&gt; 속성은 두 개의 연속 프레임의 타임 스탬프를 반환합니다. 이 값이 좋은 사용자 경험을 제공하는 데 필요한 시간보다 큰 경우 추가 분석이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b05eb447d40c5628cdff3ad6200c0663384f50" translate="yes" xml:space="preserve">
          <source>When a fullscreen request fails</source>
          <target state="translated">전체 화면 요청이 실패한 경우</target>
        </trans-unit>
        <trans-unit id="fefc52221985e22854158222b2b4b4a5defd08e4" translate="yes" xml:space="preserve">
          <source>When a key is pressed and held down, it begins to auto-repeat. This results in a sequence of events similar to the following being dispatched:</source>
          <target state="translated">키를 누르고 있으면 자동 반복이 시작됩니다. 이로 인해 다음과 유사한 일련의 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="133685e99bcb9b218dcbb3752147ab7232da05c2" translate="yes" xml:space="preserve">
          <source>When a matching performance entry is recorded, the performance observer's callback function&amp;mdash;set when creating the &lt;a href=&quot;../performanceobserver&quot;&gt;&lt;code&gt;PerformanceObserver&lt;/code&gt;&lt;/a&gt;&amp;mdash;is invoked.</source>
          <target state="translated">일치하는 성능 항목이 기록되면 &lt;a href=&quot;../performanceobserver&quot;&gt; &lt;code&gt;PerformanceObserver&lt;/code&gt; 를&lt;/a&gt; 만들 때 설정된 성능 관찰자의 콜백 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4d198decaba87bd6ce67f8bf13e6212a66b1708c" translate="yes" xml:space="preserve">
          <source>When a member returns an object of type &lt;code&gt;document&lt;/code&gt; (e.g., the &lt;code&gt;ownerDocument&lt;/code&gt; property of an element returns the &lt;code&gt;document&lt;/code&gt; to which it belongs), this object is the root &lt;code&gt;document&lt;/code&gt; object itself. The &lt;a href=&quot;../document&quot;&gt;DOM &lt;code&gt;document&lt;/code&gt; Reference&lt;/a&gt; chapter describes the &lt;code&gt;document&lt;/code&gt; object.</source>
          <target state="translated">멤버가 &lt;code&gt;document&lt;/code&gt; 유형의 객체를 반환 할 때 (예 : 요소 의 &lt;code&gt;ownerDocument&lt;/code&gt; 속성은 자신이 속한 &lt;code&gt;document&lt;/code&gt; 를 반환 함 )이 객체는 루트 &lt;code&gt;document&lt;/code&gt; 객체 자체입니다. &lt;a href=&quot;../document&quot;&gt;DOM의 &lt;code&gt;document&lt;/code&gt; 참조&lt;/a&gt; 장에서는 설명 &lt;code&gt;document&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="0e69a282b1bde286b333215515ee4bf3da48c9d5" translate="yes" xml:space="preserve">
          <source>When a message comes back through the port from the worker, we check what result type it is, then insert the calculation result inside the appropriate result paragraph.</source>
          <target state="translated">작업자가 포트를 통해 메시지를 다시 받으면 결과 유형을 확인한 다음 계산 결과를 해당 결과 단락에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="e7a23055becad5a5ab49e2c79537dfa81b4ff116" translate="yes" xml:space="preserve">
          <source>When a message is posted, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/message&quot;&gt;message&lt;/a&gt;&lt;/code&gt; event will be dispatched to each &lt;a href=&quot;broadcastchannel&quot;&gt;&lt;code&gt;BroadcastChannel&lt;/code&gt;&lt;/a&gt; object connected to this channel. There is no action by default, but a new function can be implemented using the &lt;a href=&quot;broadcastchannel/onmessage&quot;&gt;&lt;code&gt;onmessage&lt;/code&gt;&lt;/a&gt; event handler.</source>
          <target state="translated">메시지가 게시되면 이 채널에 연결된 각 &lt;a href=&quot;broadcastchannel&quot;&gt; &lt;code&gt;BroadcastChannel&lt;/code&gt; &lt;/a&gt; 객체 로 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/message&quot;&gt;message&lt;/a&gt;&lt;/code&gt; 이벤트가 전달됩니다 . 기본적으로 조치는 없지만 &lt;a href=&quot;broadcastchannel/onmessage&quot;&gt; &lt;code&gt;onmessage&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러를 사용하여 새 함수를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81ff5b65239523a22a2f35d28d53f3fd560e8ccb" translate="yes" xml:space="preserve">
          <source>When a message is received back from the IFrame confirming that the original message was received successfully, this simply outputs the confirmation to a paragraph and empties the text input ready for the next message to be sent.</source>
          <target state="translated">원본 메시지가 성공적으로 수신되었음을 확인하는 메시지가 IFrame에서 다시 수신되면 확인 메시지를 단락에 출력하고 다음 메시지를 보낼 준비가 된 텍스트 입력을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="be50c957d65a4fa4d687ef1b2a8c69414c6771ad" translate="yes" xml:space="preserve">
          <source>When a message is received back from the IFrame, the &lt;code&gt;onMessage&lt;/code&gt; function simply outputs the message to a paragraph.</source>
          <target state="translated">메시지가 IFrame에서 다시 수신되면 &lt;code&gt;onMessage&lt;/code&gt; 함수는 단순히 메시지를 단락에 출력합니다.</target>
        </trans-unit>
        <trans-unit id="728f0a5e189d08adedb9b6d267511274c079f761" translate="yes" xml:space="preserve">
          <source>When a message is received from the main page we create a list item and insert it in the unordered list, setting the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TextContent&quot;&gt;&lt;code&gt;Node.textContent&lt;/code&gt;&lt;/a&gt; of the list item equal to the event's &lt;code&gt;data&lt;/code&gt; attribute (this contains the actual message).</source>
          <target state="translated">메인 페이지에서 메시지가 수신되면 목록 항목을 생성하고 순서가없는 목록에 삽입하여 목록 항목의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TextContent&quot;&gt; &lt;code&gt;Node.textContent&lt;/code&gt; &lt;/a&gt; 를 이벤트의 &lt;code&gt;data&lt;/code&gt; 속성 (실제 메시지 포함) 과 동일하게 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="636dd19456e18454dd44615b7ce025d00b407d41" translate="yes" xml:space="preserve">
          <source>When a native &lt;code&gt;TextEncoder&lt;/code&gt; implementation is not available, the most light-weight solution would be to use &lt;a href=&quot;https://github.com/coolaj86/TextEncoderLite&quot;&gt;TextEncoderLite&lt;/a&gt; with &lt;a href=&quot;https://github.com/beatgammit/base64-js&quot;&gt;base64-js&lt;/a&gt;. Use the browser implementation when you can.</source>
          <target state="translated">네이티브 &lt;code&gt;TextEncoder&lt;/code&gt; 구현을 사용할 수없는 경우 가장 가벼운 솔루션은 &lt;a href=&quot;https://github.com/beatgammit/base64-js&quot;&gt;base64-js&lt;/a&gt; 와 함께 &lt;a href=&quot;https://github.com/coolaj86/TextEncoderLite&quot;&gt;TextEncoderLite&lt;/a&gt; 를 사용하는 것 입니다 . 가능하면 브라우저 구현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7f673776cd153c79228324d5ca3fd61e3c251da1" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;../headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; object is created using the &lt;a href=&quot;../headers/headers&quot;&gt;&lt;code&gt;Headers()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/constructor&quot;&gt;constructor&lt;/a&gt;, its guard is set to &lt;code&gt;none&lt;/code&gt; (the default). When a &lt;a href=&quot;../request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../response&quot;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; object is created, it has an associated &lt;a href=&quot;../headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; object whose guard is set as summarized below:</source>
          <target state="translated">&lt;a href=&quot;../headers/headers&quot;&gt; &lt;code&gt;Headers()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/constructor&quot;&gt; 생성자를&lt;/a&gt; 사용하여 새 &lt;a href=&quot;../headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 객체를 만들면 보호가 &lt;code&gt;none&lt;/code&gt; (기본값)으로 설정됩니다 . 때 &lt;a href=&quot;../request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../response&quot;&gt; &lt;code&gt;Response&lt;/code&gt; &lt;/a&gt; 객체가 생성되고, 그것이 연결된 갖는 &lt;a href=&quot;../headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 가진 보호 설정 아래 요약 된 바와 같이 객체 :</target>
        </trans-unit>
        <trans-unit id="cabe0c91d8040d5324bf88423d69380576cff377" translate="yes" xml:space="preserve">
          <source>When a new &lt;code&gt;Request&lt;/code&gt; object is constructed, you can pass it a &lt;a href=&quot;readablestream&quot;&gt;&lt;code&gt;ReadableStream&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;body&lt;/code&gt; property of its &lt;code&gt;RequestInit&lt;/code&gt; dictionary. This &lt;code&gt;Request&lt;/code&gt; could then be passed to a &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt;&lt;code&gt;WindowOrWorkerGlobalScope.fetch()&lt;/code&gt;&lt;/a&gt; to commence fetching the stream.</source>
          <target state="translated">새 &lt;code&gt;Request&lt;/code&gt; 객체가 생성되면 &lt;code&gt;RequestInit&lt;/code&gt; 사전 의 &lt;code&gt;body&lt;/code&gt; 속성 에서 &lt;a href=&quot;readablestream&quot;&gt; &lt;code&gt;ReadableStream&lt;/code&gt; &lt;/a&gt; 을 전달할 수 있습니다 . 그런 다음 이 &lt;code&gt;Request&lt;/code&gt; &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt; &lt;code&gt;WindowOrWorkerGlobalScope.fetch()&lt;/code&gt; &lt;/a&gt; 로 전달 하여 스트림 페치를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158b4de7c3246cceff025412ef67392dad8ad5d8" translate="yes" xml:space="preserve">
          <source>When a new ICE candidate is received by your signaling code from the remote peer, you need to construct the &lt;code&gt;RTCIceCandidate&lt;/code&gt; object that encapsulates it. This is done in the event handler for the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; event. If your client-side signaling layer builds and transmits a JSON string including the candidate to the remote peer, the remote peer might handle receiving that JSON message like this:</source>
          <target state="translated">시그널링 코드가 원격 피어로부터 새로운 ICE 후보를 수신하면이를 캡슐화 하는 &lt;code&gt;RTCIceCandidate&lt;/code&gt; 오브젝트 를 구성해야 합니다. 이것은 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; 이벤트 에 대한 이벤트 핸들러에서 수행됩니다 . 클라이언트 측 신호 계층이 후보를 포함하여 JSON 문자열을 빌드하고 원격 피어에 전송하는 경우 원격 피어는 다음과 같이 해당 JSON 메시지 수신을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="669e5c87da7047d5828d69e231022ad6513921d4" translate="yes" xml:space="preserve">
          <source>When a non-empty string is assigned to the &lt;code&gt;returnValue&lt;/code&gt; Event property, a dialog box appears, asking the users for confirmation to leave the page (see example below). When no value is provided, the event is processed silently. Some implementations only show the dialog box if the frame or any embedded frame receives a user gesture or user interaction. See &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; for more information.</source>
          <target state="translated">비어 있지 않은 문자열이 &lt;code&gt;returnValue&lt;/code&gt; Event 속성에 할당 되면 사용자에게 페이지를 떠날 것인지 묻는 대화 상자가 나타납니다 (아래 예 참조). 값이 제공되지 않으면 이벤트가 자동으로 처리됩니다. 일부 구현은 프레임 또는 내장 프레임이 사용자 제스처 또는 사용자 상호 작용을 수신하는 경우에만 대화 상자를 표시합니다. 자세한 내용은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c4eccf648008c891ebef61dfd08acd3a932ab689" translate="yes" xml:space="preserve">
          <source>When a proxy is used, if a tunnel connection is established, this property returns the ALPN Protocol ID of the tunneled protocol. Otherwise, this property returns the ALPN Protocol ID of the first hop to the proxy.</source>
          <target state="translated">프록시를 사용할 때 터널 연결이 설정되면이 속성은 터널링 된 프로토콜의 ALPN 프로토콜 ID를 반환합니다. 그렇지 않으면이 속성은 첫 번째 홉의 ALPN 프로토콜 ID를 프록시에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="403ec2b5941417a15ea748c74c346d7e0bc012a8" translate="yes" xml:space="preserve">
          <source>When a resource (such as an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt;) &lt;strong&gt;fails to load&lt;/strong&gt;, an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; event using interface &lt;a href=&quot;../event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; is fired at the element that initiated the load, and the &lt;code&gt;onerror()&lt;/code&gt; handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a single capturing &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt;&lt;code&gt;window.addEventListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자원 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; ) &lt;strong&gt;이로드에 실패하면로드&lt;/strong&gt; 를 시작한 요소에서 &lt;a href=&quot;../event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용 하는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 이벤트 가 발생하고 요소의 &lt;code&gt;onerror()&lt;/code&gt; 핸들러가 호출됩니다. 이 오류 이벤트는 창까지 버블 링되지 않지만 (최소한 Firefox에서는) 단일 캡처 &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt; &lt;code&gt;window.addEventListener&lt;/code&gt; &lt;/a&gt; 로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfc9969839577a4f8eca330fab60572ce9c27a5b" translate="yes" xml:space="preserve">
          <source>When a runtime error occurs in the worker, its &lt;code&gt;onerror&lt;/code&gt; event handler is called. It receives an event named &lt;code&gt;error&lt;/code&gt; which implements the &lt;code&gt;ErrorEvent&lt;/code&gt; interface.</source>
          <target state="translated">작업자에서 런타임 오류가 발생하면 &lt;code&gt;onerror&lt;/code&gt; 이벤트 핸들러가 호출됩니다. &lt;code&gt;ErrorEvent&lt;/code&gt; 인터페이스 를 구현하는 &lt;code&gt;error&lt;/code&gt; 라는 이벤트를받습니다 .</target>
        </trans-unit>
        <trans-unit id="970b4e51027433267f3cf90a50675eb985d6c262" translate="yes" xml:space="preserve">
          <source>When a second argument is present: If the second argument evaluates to &lt;code&gt;true&lt;/code&gt;, add the specified class value, and if it evaluates to &lt;code&gt;false&lt;/code&gt;, remove it.</source>
          <target state="translated">두 번째 인수가있는 경우 : 두 번째 인수가 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 지정된 클래스 값을 추가하고 &lt;code&gt;false&lt;/code&gt; 로 평가 되면 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="53e6d3428e5f0918f19321a59276085f24d3a592" translate="yes" xml:space="preserve">
          <source>When a service worker is initially registered, pages won't use it until they next load. The &lt;code&gt;claim()&lt;/code&gt; method causes those pages to be controlled immediately. Be aware that this results in your service worker controlling pages that loaded regularly over the network, or possibly via a different service worker.</source>
          <target state="translated">서비스 워커가 처음 등록되면 다음에로드 될 때까지 페이지가 사용되지 않습니다. &lt;code&gt;claim()&lt;/code&gt; 메소드가 그 페이지를 바로 제어되도록한다. 이로 인해 서비스 담당자가 네트워크를 통해 또는 다른 서비스 담당자를 통해 정기적으로로드되는 페이지를 제어하게됩니다.</target>
        </trans-unit>
        <trans-unit id="df8554fb4c299242d90854e2bbaf813f88a104b3" translate="yes" xml:space="preserve">
          <source>When a single user interaction with an input device generates a series of different input events, the &lt;code&gt;sourceCapabilities&lt;/code&gt; property for all of them will point to the same instance of &lt;code&gt;InputDeviceCapabilities&lt;/code&gt;. For example, when a user lifts their finger off of a touchscreen, several UIEvents may be generated including &lt;code&gt;touchend&lt;/code&gt;, &lt;code&gt;mousedown&lt;/code&gt;, &lt;code&gt;click&lt;/code&gt;, and &lt;code&gt;focus&lt;/code&gt;. All of these events must have the same &lt;code&gt;sourceCapabilities&lt;/code&gt; representing the touchscreen.</source>
          <target state="translated">입력 장치와의 단일 사용자 상호 작용이 일련의 서로 다른 입력 이벤트를 생성하면 모든 입력 이벤트에 대한 &lt;code&gt;sourceCapabilities&lt;/code&gt; 속성은 동일한 &lt;code&gt;InputDeviceCapabilities&lt;/code&gt; 인스턴스를 가리 킵니다 . 예를 들어, 사용자가 터치 스크린에서 손가락을 떼면 &lt;code&gt;touchend&lt;/code&gt; , &lt;code&gt;mousedown&lt;/code&gt; , &lt;code&gt;click&lt;/code&gt; 및 &lt;code&gt;focus&lt;/code&gt; 를 포함한 여러 UIEvents가 생성 될 수 있습니다 . 이러한 모든 이벤트는 터치 스크린을 나타내는 동일한 &lt;code&gt;sourceCapabilities&lt;/code&gt; 를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="03af423f8479c469120bee40c436b45f37f71578" translate="yes" xml:space="preserve">
          <source>When a syntax&lt;strong&gt;(?)&lt;/strong&gt; error occurs in a script, loaded from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;different origin&lt;/a&gt;, the details of the syntax error are not reported to prevent leaking information (see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=363897&quot;&gt;bug 363897&lt;/a&gt;). Instead the error reported is simply &lt;code&gt;&lt;strong&gt;&quot;Script error.&quot;&lt;/strong&gt;&lt;/code&gt; This behavior can be overriden in some browsers using the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; and having the server send the appropriate &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt; HTTP response headers. A workaround is to isolate &quot;Script error.&quot; and handle it knowing that the error detail is only viewable in the browser console and not accessible via JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;다른 출처&lt;/a&gt; 에서로드 된 스크립트에서 구문 &lt;strong&gt;(?)&lt;/strong&gt; 오류가 발생 하면 정보 유출을 막기 위해 구문 오류의 세부 정보가보고되지 않습니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=363897&quot;&gt;버그 363897&lt;/a&gt; 참조 ). 대신보고 된 오류는 단순히 &lt;code&gt;&lt;strong&gt;&quot;Script error.&quot;&lt;/strong&gt;&lt;/code&gt; 이 동작은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 속성을 사용 하고 서버가 적절한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt; HTTP 응답 헤더를 보내도록하는 일부 브라우저에서 무시 될 수 있습니다 . 해결 방법은 &quot;스크립트 오류&quot;를 격리하는 것입니다. 오류 세부 사항은 브라우저 콘솔에서만 볼 수 있고 JavaScript를 통해 액세스 할 수 없다는 것을 알고 처리하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b324ca6e987a2a4bdc1ae63b3db4593c1860f48" translate="yes" xml:space="preserve">
          <source>When a table has its &lt;code&gt;dir&lt;/code&gt; set to &lt;code&gt;&quot;rtl&quot;&lt;/code&gt;, the column order is arranged from right to left.</source>
          <target state="translated">테이블의 &lt;code&gt;dir&lt;/code&gt; 이 &lt;code&gt;&quot;rtl&quot;&lt;/code&gt; 로 설정 되면 열 순서는 오른쪽에서 왼쪽으로 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="abec9a1a8685db55cc230635f0f0ba89d164c690" translate="yes" xml:space="preserve">
          <source>When a tone finishes playing</source>
          <target state="translated">톤 재생이 끝나면</target>
        </trans-unit>
        <trans-unit id="866ab665a070b9ef16e08881606071408ab6a91a" translate="yes" xml:space="preserve">
          <source>When a user begins to drag, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; event is fired. In this example the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; listener is added to the draggable element itself; however, you could listen to a higher ancestor as drag events bubble up as most other events do. Within the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; event, you can specify the drag data, the feedback image, and the drag effects, all of which are described below. However, only the drag data is required; the default image and drag effects are suitable in many situations.</source>
          <target state="translated">사용자가 드래그를 시작하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; 이벤트가 시작됩니다 . 이 예제에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; 리스너는 draggable 요소 자체에 추가됩니다. 그러나 대부분의 다른 이벤트와 마찬가지로 드래그 이벤트가 발생하여 상위 조상을들을 수 있습니다. &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragstart&quot;&gt;dragstart&lt;/a&gt;&lt;/code&gt; 이벤트 내에서 아래에 설명 된 끌기 데이터, 피드백 이미지 및 끌기 효과를 지정할 수 있습니다. 그러나 드래그 데이터 만 필요합니다. 기본 이미지 및 드래그 효과는 여러 상황에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f349802d88e07efb840260a3059d9b2644d98333" translate="yes" xml:space="preserve">
          <source>When a user clicks on a notification generated by an app, you will be notified of this event in two different ways, depending on the circumstance:</source>
          <target state="translated">사용자가 앱에서 생성 된 알림을 클릭하면 상황에 따라 두 가지 다른 방식으로이 이벤트에 대한 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="2a45702911c0b317c0f3c1bd1861825561f965d4" translate="yes" xml:space="preserve">
          <source>When a user holds their mouse down or presses their finger on the cake on a touch screen, we can now call &lt;code&gt;growAlice&lt;/code&gt; to make all the animations play:</source>
          <target state="translated">사용자가 터치 스크린에서 케이크를 마우스로 누르고 있거나 손가락을 누르면 이제 &lt;code&gt;growAlice&lt;/code&gt; 를 호출 하여 모든 애니메이션을 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20dd8949ca26d674218a330eef44fef26005a7e1" translate="yes" xml:space="preserve">
          <source>When a user starts a WebRTC call to another user, a special description is created called an &lt;strong&gt;offer&lt;/strong&gt;. This description includes all the information about the caller's proposed configuration for the call. The recipient then responds with an &lt;strong&gt;answer&lt;/strong&gt;, which is a description of their end of the call. In this way, both devices share with one another the information needed in order to exchange media data. This exchange is handled using Interactive Connectivity Establishment (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt;, a protocol which lets two devices use an intermediary to exchange offers and answers even if the two devices are separated by Network Address Translation (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/NAT&quot;&gt;NAT&lt;/a&gt;).</source>
          <target state="translated">사용자가 다른 사용자에게 WebRTC 호출을 시작하면 &lt;strong&gt;오퍼&lt;/strong&gt; 라는 특별 설명이 작성 됩니다. 이 설명에는 발신자가 제안한 통화 구성에 대한 모든 정보가 포함됩니다. 받는 사람은 다음으로 응답 &lt;strong&gt;대답&lt;/strong&gt; 호출의 최종의 설명이다. 이러한 방식으로 두 장치는 미디어 데이터를 교환하는 데 필요한 정보를 서로 공유합니다. 이 교환은 두 장치가 네트워크 주소 변환 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/NAT&quot;&gt;NAT&lt;/a&gt; )에 의해 분리 된 경우에도 두 장치가 중개자를 사용하여 오퍼와 응답을 교환 할 수있게하는 프로토콜 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; (Interactive Connectivity Establishment)를 사용하여 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="371a0ba3dc469c6c8bb3908bda0b22274054ffa1" translate="yes" xml:space="preserve">
          <source>When a web site or app using &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; agent by calling &lt;code&gt;&lt;strong&gt;RTCPeerConnection.addIceCandidate()&lt;/strong&gt;&lt;/code&gt;. This adds this new remote candidate to the &lt;code&gt;RTCPeerConnection&lt;/code&gt;'s remote description, which describes the state of the remote end of the connection.</source>
          <target state="translated">&lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; 을&lt;/a&gt; 사용하는 웹 사이트 또는 앱 이 신호 채널을 통해 원격 피어로부터 새로운 ICE 후보를 수신하면 &lt;code&gt;&lt;strong&gt;RTCPeerConnection.addIceCandidate()&lt;/strong&gt;&lt;/code&gt; 를 호출 하여 새로 수신 한 후보를 브라우저의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; 에이전트에 전달합니다 . 이렇게하면이 새로운 원격 후보가 &lt;code&gt;RTCPeerConnection&lt;/code&gt; 의 원격 설명에 추가되어 연결의 원격 끝 상태를 설명합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88565eca7559efba83c52264975d1ec20453c872" translate="yes" xml:space="preserve">
          <source>When a web site or app using &lt;a href=&quot;rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; receives a new ICE candidate from the remote peer over its signaling channel, it delivers the newly-received candidate to the browser's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; agent by calling &lt;code&gt;&lt;strong&gt;RTCPeerConnection.addIceCandidate()&lt;/strong&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; 을&lt;/a&gt; 사용하는 웹 사이트 또는 앱 이 신호 채널을 통해 원격 피어로부터 새로운 ICE 후보를 수신하면 &lt;code&gt;&lt;strong&gt;RTCPeerConnection.addIceCandidate()&lt;/strong&gt;&lt;/code&gt; 를 호출 하여 새로 수신 한 후보를 브라우저의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; 에이전트에 전달합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ed2e4a83c718be1dd5a45ab96f19ce8a766b521" translate="yes" xml:space="preserve">
          <source>When a window is loaded in an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, its parent is the window with the element embedding the window.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 윈도우가로드되면 부모는 윈도우를 포함하는 요소가있는 윈도우입니다.</target>
        </trans-unit>
        <trans-unit id="54a534817fac9161b0cf7b643b11d95186685ec8" translate="yes" xml:space="preserve">
          <source>When a window is opened from another window (using &lt;a href=&quot;open&quot;&gt;&lt;code&gt;Window.open&lt;/code&gt;&lt;/a&gt; or a link with its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; attribute set), it maintains a reference to that first window as &lt;code&gt;&lt;strong&gt;window.opener&lt;/strong&gt;&lt;/code&gt;. If the current window has no opener, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt; &lt;code&gt;Window.open&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; 속성이 설정된 링크를 사용하여 다른 창에서 창을 열면 첫 번째 창에 대한 참조가 &lt;code&gt;&lt;strong&gt;window.opener&lt;/strong&gt;&lt;/code&gt; 로 유지됩니다 . 현재 윈도우에 오프너가 없으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="46a9ca0fb610dce55642aedb923c4a90aea5ea16" translate="yes" xml:space="preserve">
          <source>When a writer is created and starts writing to a stream (an &lt;strong&gt;active writer&lt;/strong&gt;), it is said to be &lt;strong&gt;locked&lt;/strong&gt; to it. Only one writer can write to a writable stream at one time. If you want another writer to start writing to your stream, you typically need to abort it before you then attach another writer to it.</source>
          <target state="translated">라이터가 작성되어 스트림 (쓰기 &lt;strong&gt;중인 라이터&lt;/strong&gt; )에 쓰기를 시작 하면 &lt;strong&gt;잠겨&lt;/strong&gt; 있다고합니다. 한 번에 한 명의 작성자 만 쓰기 가능한 스트림에 쓸 수 있습니다. 다른 작가가 스트림에 쓰기를 시작하도록하려면 일반적으로 다른 작가를 첨부하기 전에 중단해야합니다.</target>
        </trans-unit>
        <trans-unit id="e06683457253a33529df8734e44861ff2b6ce711" translate="yes" xml:space="preserve">
          <source>When abort is closed, any previously enqueued chunks are just thrown away immediately and then the stream is moved to an errored state. This also triggers any &lt;code&gt;abort()&lt;/code&gt; method specified in the &lt;code&gt;WritableStream()&lt;/code&gt; constructor to be invoked.</source>
          <target state="translated">중단이 닫히면 이전에 대기중인 청크가 즉시 버려지고 스트림이 오류 상태로 이동합니다. 또한 &lt;code&gt;WritableStream()&lt;/code&gt; 생성자에 지정된 &lt;code&gt;abort()&lt;/code&gt; 메서드 가 호출되도록 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="cda570069962d7f4e3a6a927f44c9fdbf9272c41" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;IntersectionObserver&lt;/code&gt; is created, it's configured to watch for given ratios of visibility within the root. The configuration cannot be changed once the &lt;code&gt;IntersectionObserver&lt;/code&gt; is created, so a given observer object is only useful for watching for specific changes in degree of visibility; however, you can watch multiple target elements with the same observer.</source>
          <target state="translated">때 &lt;code&gt;IntersectionObserver&lt;/code&gt; 가 생성되고, 루트 내에서 가시성의 주어진 비율을 감시하도록 구성된. &lt;code&gt;IntersectionObserver&lt;/code&gt; 가 작성된 후에는 구성을 변경할 수 없으므로 지정된 옵저버 오브젝트는 가시성 정도의 특정 변경 사항을 관찰 할 때만 유용합니다. 그러나 동일한 관찰자로 여러 대상 요소를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d8efeb3cba38ce566a8e9d561e4019de2631f5" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;attribute&lt;/code&gt; is returned by a member (e.g., by the &lt;code&gt;createAttribute()&lt;/code&gt; method), it is an object reference that exposes a special (albeit small) interface for attributes. Attributes are nodes in the DOM just like elements are, though you may rarely use them as such.</source>
          <target state="translated">&lt;code&gt;attribute&lt;/code&gt; 이 멤버에 의해 리턴 될 때 (예를 들어, &lt;code&gt;createAttribute()&lt;/code&gt; 메소드에 의해), 속성에 대한 특별한 (작지만) 인터페이스를 노출하는 객체 참조입니다. 속성은 요소와 마찬가지로 DOM의 노드이지만 거의 사용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="903a5a1b65ebe370e7e8eb7764e8ba8dc906f3a6" translate="yes" xml:space="preserve">
          <source>When an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; tag is found in the document;</source>
          <target state="translated">문서에 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그가있는 경우</target>
        </trans-unit>
        <trans-unit id="e612122137d18dae39e4f6e3595f7689bba611e4" translate="yes" xml:space="preserve">
          <source>When an HTML document has been switched to &lt;code&gt;&lt;a href=&quot;designmode&quot;&gt;designMode&lt;/a&gt;&lt;/code&gt;, its &lt;code&gt;document&lt;/code&gt; object exposes an &lt;code&gt;execCommand&lt;/code&gt; method to run commands that manipulate the current editable region, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;form inputs&lt;/a&gt; or &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable&quot;&gt;contentEditable&lt;/a&gt;&lt;/code&gt; elements.</source>
          <target state="translated">HTML 문서가 &lt;code&gt;&lt;a href=&quot;designmode&quot;&gt;designMode&lt;/a&gt;&lt;/code&gt; 로 전환 되면 해당 &lt;code&gt;document&lt;/code&gt; 객체는 &lt;code&gt;execCommand&lt;/code&gt; 메소드를 노출하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;양식 입력&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable&quot;&gt;contentEditable&lt;/a&gt;&lt;/code&gt; 요소 와 같은 현재 편집 가능한 영역을 조작하는 명령을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="81e5ac6dfb671acf25b9969d1cf4166072a97f3f" translate="yes" xml:space="preserve">
          <source>When an animation is cancelled, its &lt;a href=&quot;starttime&quot;&gt;&lt;code&gt;startTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;currenttime&quot;&gt;&lt;code&gt;currentTime&lt;/code&gt;&lt;/a&gt; are set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 취소되면 &lt;a href=&quot;starttime&quot;&gt; &lt;code&gt;startTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;currenttime&quot;&gt; &lt;code&gt;currentTime&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e53d60f44bbc93773243d5eaea948fd212da7233" translate="yes" xml:space="preserve">
          <source>When an attribute is set, it's value is always converted into a string. For example &lt;code&gt;null&lt;/code&gt; is converted into the string &quot;null&quot;.</source>
          <target state="translated">속성이 설정되면 값은 항상 문자열로 변환됩니다. 예를 들어 &lt;code&gt;null&lt;/code&gt; 은 &quot;null&quot;문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0ce4f0a286821a32375960340a04bc9603c700" translate="yes" xml:space="preserve">
          <source>When an audio signal is processed, &lt;strong&gt;sampling&lt;/strong&gt; means the conversion of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_signal&quot;&gt;continuous signal&lt;/a&gt; to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_signal&quot;&gt;discrete signal&lt;/a&gt;; or put another way, a continuous sound wave, such as a band playing live, is converted to a sequence of samples (a discrete-time signal) that allow a computer to handle the audio in distinct blocks.</source>
          <target state="translated">오디오 신호가 처리 될 때, &lt;strong&gt;샘플링&lt;/strong&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuous_signal&quot;&gt;연속 신호&lt;/a&gt; 를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_signal&quot;&gt;이산 신호&lt;/a&gt; 로 변환하는 것을 의미하고 ; 달리 말하면, 라이브 밴드 연주와 같은 연속 음파는 컴퓨터가 별개의 블록으로 오디오를 처리 할 수 ​​있도록 샘플 시퀀스 (이산 신호)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9faebab65940967c2e6f9c4fd02d4a6fab07057c" translate="yes" xml:space="preserve">
          <source>When an authenticator registers a new key pair with a service, the authenticator signs the public key with an attestation certificate. The attestation certificate is built in to the authenticator during manufacturing time and is specific to a device model. That is, all &quot;Samsung Galaxy S8&quot; phones, manufactured at a specific time or particular manufacturing run, have the same attestation certificate.</source>
          <target state="translated">인증자가 서비스에 새 키 페어를 등록하면 인증자는 공개 키에 증명 인증서로 서명합니다. 증명 인증서는 제조 시간 동안 인증 자에 내장되며 장치 모델에 따라 다릅니다. 즉, 특정 시간 또는 특정 제조 실행에서 제조 된 모든 &quot;Samsung Galaxy S8&quot;전화는 동일한 증명 인증서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="81053fbdec3400a9964b77dd50e33ec3335b3152" translate="yes" xml:space="preserve">
          <source>When an element has its dir set to &lt;code&gt;&quot;auto&quot;&lt;/code&gt;, the direction of the element is determined based on its first strong directionality character, or default to the directionality of its parent element.</source>
          <target state="translated">요소의 디렉토리가 &lt;code&gt;&quot;auto&quot;&lt;/code&gt; 로 설정된 경우 요소의 방향은 첫 번째 강한 방향성 문자를 기반으로 결정되거나 기본적으로 상위 요소의 방향성으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0d2327121fb5c86c1043b0857e58fbf959aa4c" translate="yes" xml:space="preserve">
          <source>When an error occurs while attempting to add the ICE candidate, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by this method is rejected, returning one of the errors below as the &lt;a href=&quot;../domexception/name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; attribute in the specified &lt;a href=&quot;../domexception&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; object passed to the rejection handler.</source>
          <target state="translated">ICE 후보를 추가하는 중에 오류가 발생하면 이 메소드가 리턴 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 거부되고 아래 오류 중 하나가 지정된 &lt;a href=&quot;../domexception&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 오브젝트 의 &lt;a href=&quot;../domexception/name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 속성으로 거부 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cf27f65291186cc9d89e2e779675d8c18f1dd3b3" translate="yes" xml:space="preserve">
          <source>When an incoming connection is created, a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-receiving-user-agent&quot;&gt;receiving user agent&lt;/a&gt;&lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-firing-an-event&quot;&gt;fires&lt;/a&gt; a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-trusted-event&quot;&gt;trusted event&lt;/a&gt;, named &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-connectionavailable&quot;&gt;&lt;code&gt;connectionavailable&lt;/code&gt;&lt;/a&gt;, on a &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationreceiver&quot;&gt;&lt;code&gt;PresentationReceiver&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-trusted-event&quot;&gt;trusted event&lt;/a&gt; is fired at the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-controllers-monitor&quot;&gt;presentation controller's monitor&lt;/a&gt;, using the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnectionavailableevent&quot;&gt;&lt;code&gt;PresentationConnectionAvailableEvent&lt;/code&gt;&lt;/a&gt; interface, with the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnectionavailableevent-connection&quot;&gt;&lt;code&gt;connection&lt;/code&gt;&lt;/a&gt; attribute set to the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt;&lt;code&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; object that was created.</source>
          <target state="translated">들어오는 연결이 생성되면, &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-receiving-user-agent&quot;&gt;수신 사용자 에이전트는 &lt;/a&gt;&lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-firing-an-event&quot;&gt;화재 &lt;/a&gt;&lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-trusted-event&quot;&gt;신뢰할 수있는 이벤트&lt;/a&gt; 라는 이름의, &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-connectionavailable&quot;&gt; &lt;code&gt;connectionavailable&lt;/code&gt; &lt;/a&gt; A의, &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationreceiver&quot;&gt; &lt;code&gt;PresentationReceiver&lt;/code&gt; 을&lt;/a&gt; . &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-trusted-event&quot;&gt;신뢰할 수있는 이벤트는&lt;/a&gt; 상기 발사되는 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-presentation-controllers-monitor&quot;&gt;프리젠 테이션 컨트롤러의 모니터&lt;/a&gt; 사용 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnectionavailableevent&quot;&gt; &lt;code&gt;PresentationConnectionAvailableEvent&lt;/code&gt; 의&lt;/a&gt; 으로 인터페이스를 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnectionavailableevent-connection&quot;&gt; &lt;code&gt;connection&lt;/code&gt; &lt;/a&gt; 받는 속성 세트 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#idl-def-presentationconnection&quot;&gt; &lt;code&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/code&gt; 의&lt;/a&gt; 생성 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1265604bfd664331bda197329b2c494bff23064c" translate="yes" xml:space="preserve">
          <source>When an object or array is stored, the properties and values in that object or array can also be anything that is a valid value.</source>
          <target state="translated">객체 또는 배열이 저장되면 해당 객체 또는 배열의 속성 및 값도 유효한 값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="411678c3b54d93aaff6705f227fed426c41ab733" translate="yes" xml:space="preserve">
          <source>When an user chooses to log in to a service, the server sends a challenge and the authenticator signs over it with a key pair previously registered to that service. This creates an assertion. Unlike the attestation, the format of the assertion is always the same regardless of the device being used.</source>
          <target state="translated">사용자가 서비스에 로그인하기로 선택하면 서버는 챌린지를 보내고 인증자는 해당 서비스에 이전에 등록 된 키 페어를 사용하여 챌린지를 서명합니다. 어설 션이 생성됩니다. 증명과 달리 어설 션 형식은 사용중인 장치에 관계없이 항상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="85ab0909ff1646029a52e229bfa6d68a560ba970" translate="yes" xml:space="preserve">
          <source>When called on an HTML document, &lt;code&gt;getElementsByTagName()&lt;/code&gt; lower-cases its argument before proceeding. This is undesirable when trying to match camelCase SVG elements in a subtree in an HTML document. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/document/getElementsByTagNameNS&quot;&gt;&lt;code&gt;document.getElementsByTagNameNS()&lt;/code&gt;&lt;/a&gt; is useful in that case. See also &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=499656&quot;&gt;bug 499656&lt;/a&gt;.</source>
          <target state="translated">HTML 문서에서 호출되면 &lt;code&gt;getElementsByTagName()&lt;/code&gt; 계속하기 전에 인수를 소문자로 만듭니다. HTML 문서의 하위 트리에서 camelCase SVG 요소를 일치 시키려고 할 때 바람직하지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/document/getElementsByTagNameNS&quot;&gt; &lt;code&gt;document.getElementsByTagNameNS()&lt;/code&gt; &lt;/a&gt; 가 유용합니다. &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=499656&quot;&gt;버그 499656&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b471b97ba5c05c78e6b2c1d11787b884e9db030" translate="yes" xml:space="preserve">
          <source>When called on an HTML element in a DOM flagged as an HTML document, &lt;code&gt;getAttribute()&lt;/code&gt; lower-cases its argument before proceeding.</source>
          <target state="translated">HTML 문서로 플래그가 지정된 DOM의 HTML 요소에서 호출되면 &lt;code&gt;getAttribute()&lt;/code&gt; 는 계속하기 전에 인수를 소문자로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5cc5bf1c9e7f7d38fd44810ce93519458e7f53a8" translate="yes" xml:space="preserve">
          <source>When called on an HTML element in a DOM flagged as an HTML document, &lt;code&gt;getAttributeNode&lt;/code&gt; lower-cases its argument before proceeding.</source>
          <target state="translated">HTML 문서로 플래그가 지정된 DOM의 HTML 요소에서 호출되면 &lt;code&gt;getAttributeNode&lt;/code&gt; 는 진행하기 전에 인수를 소문자로 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="bb5c037a6d7ef05123d621bcd49a8d0ff98b576a" translate="yes" xml:space="preserve">
          <source>When called on an HTML element in an HTML document, &lt;code&gt;getElementsByTagName&lt;/code&gt; lower-cases the argument before searching for it. This is undesirable when trying to match camel-cased SVG elements (such as &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient&quot;&gt;&amp;lt;linearGradient&amp;gt;&lt;/a&gt;&lt;/code&gt;) in an HTML document. Instead, use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/element/getElementsByTagNameNS&quot;&gt;&lt;code&gt;Element.getElementsByTagNameNS()&lt;/code&gt;&lt;/a&gt;, which preserves the capitalization of the tag name.</source>
          <target state="translated">HTML 문서의 HTML 요소에서 호출되면 &lt;code&gt;getElementsByTagName&lt;/code&gt; 은 인수를 검색하기 전에 소문자를 사용합니다. HTML 문서에서 낙타로 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient&quot;&gt;&amp;lt;linearGradient&amp;gt;&lt;/a&gt;&lt;/code&gt; SVG 요소 (예 : &amp;lt;linearGradient&amp;gt; ) 를 일치 시키려고 할 때 바람직하지 않습니다. 대신, 태그 이름의 대문자를 유지하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/element/getElementsByTagNameNS&quot;&gt; &lt;code&gt;Element.getElementsByTagNameNS()&lt;/code&gt; &lt;/a&gt; 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="816badb97c9734b8cbe51bdd349e805a002aae56" translate="yes" xml:space="preserve">
          <source>When cast to string, either by appending an empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) or using &lt;a href=&quot;../selection/tostring&quot;&gt;&lt;code&gt;Selection.toString()&lt;/code&gt;&lt;/a&gt;, this object returns the text selected.</source>
          <target state="translated">빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )을 추가하거나 &lt;a href=&quot;../selection/tostring&quot;&gt; &lt;code&gt;Selection.toString()&lt;/code&gt; &lt;/a&gt; 사용하여 문자열로 캐스트 할 때이 객체는 선택된 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1dbf2de15b458ada3ef751c3a72df9fba9e96b1" translate="yes" xml:space="preserve">
          <source>When changing the description by calling &lt;code&gt;setLocalDescription()&lt;/code&gt; or &lt;code&gt;setRemoteDescription()&lt;/code&gt;, the specified description is set as the pending description, and the WebRTC layer begins to evaluate whether or not it's acceptable. Once the proposed description has been agreed upon, the value of &lt;code&gt;currentLocalDescription&lt;/code&gt; or &lt;code&gt;currentRemoteDescription&lt;/code&gt; is changed to the pending description, and the pending description is set to null again, indicating that there isn't a pending description.</source>
          <target state="translated">&lt;code&gt;setLocalDescription()&lt;/code&gt; 또는 &lt;code&gt;setRemoteDescription()&lt;/code&gt; 을 호출하여 설명을 변경하면 지정된 설명이 보류중인 설명으로 설정되고 WebRTC 계층이 수용 가능한지 여부를 평가하기 시작합니다. 제안 된 설명에 동의하면 &lt;code&gt;currentLocalDescription&lt;/code&gt; 또는 &lt;code&gt;currentRemoteDescription&lt;/code&gt; 의 값이 보류중인 설명으로 변경되고 보류중인 설명이 다시 null로 설정되어 보류중인 설명이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e38e4089f23e3ef4d5c0fc14fa2f4b901475d06e" translate="yes" xml:space="preserve">
          <source>When changing the gain value of a &lt;a href=&quot;../gainnode&quot;&gt;&lt;code&gt;GainNode&lt;/code&gt;&lt;/a&gt;, Google Chrome prior to version 64 (January 2018) would perform a smooth interpolation to prevent dezippering. Starting with version 64, the value is changed instantly to bring it in line with the Web Audio spec. See &lt;a href=&quot;https://www.chromestatus.com/feature/5287995770929152&quot;&gt;Chrome Platform Status&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;../gainnode&quot;&gt; &lt;code&gt;GainNode&lt;/code&gt; &lt;/a&gt; 의 게인 값을 변경할 때 버전 64 (2018 년 1 월) 이전의 Chrome 은 디퍼 퍼링 을 방지하기 위해 부드러운 보간을 수행합니다. 버전 64부터는 Web Audio 사양에 맞게 값이 즉시 변경됩니다. 자세한 내용은 &lt;a href=&quot;https://www.chromestatus.com/feature/5287995770929152&quot;&gt;Chrome 플랫폼 상태&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ddc976224eb774f41a2720b96b89e93aa27d49e7" translate="yes" xml:space="preserve">
          <source>When clearing site storage units, an origin's box is treated as a single entity; if the user agent needs to clear it and the user approves, the entire data store is cleared rather than providing some means of clearing only data from individual APIs.</source>
          <target state="translated">사이트 저장 단위를 지울 때 원점 상자는 단일 엔티티로 취급됩니다. 사용자 에이전트가이를 지우고 사용자가 승인하는 경우 개별 API에서 데이터 만 지우는 방법을 제공하지 않고 전체 데이터 저장소가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f32e4911e272d05e79a05d66034ae9be65522134" translate="yes" xml:space="preserve">
          <source>When constructing an instance of the &lt;a href=&quot;../paymentrequest&quot;&gt;&lt;code&gt;PaymentRequest&lt;/code&gt;&lt;/a&gt;, you are able to supply an custom id via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentDetailsInit&quot;&gt;&lt;code&gt;PaymentDetailsInit&lt;/code&gt;&lt;/a&gt; dictionary's &lt;code&gt;id&lt;/code&gt; member. If none is provided, the browser automatically sets the id value to a UUID.</source>
          <target state="translated">&lt;a href=&quot;../paymentrequest&quot;&gt; &lt;code&gt;PaymentRequest&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 구성 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentDetailsInit&quot;&gt; &lt;code&gt;PaymentDetailsInit&lt;/code&gt; &lt;/a&gt; 사전의 &lt;code&gt;id&lt;/code&gt; 멤버 를 통해 사용자 정의 ID를 제공 할 수 있습니다. 제공되지 않으면 브라우저는 자동으로 id 값을 UUID로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ecb8b41e45656211d9a015af5ac0f02efc16838d" translate="yes" xml:space="preserve">
          <source>When content overflows window viewport dimensions, then scrollbar(s) (or some scrolling mechanism) are necessary to ensure that content can be accessed by users. Content can overflow window dimensions for several reasons which are outside the control of web authors:</source>
          <target state="translated">내용이 창 뷰포트 크기를 초과하면 사용자가 내용에 액세스 할 수 있도록 스크롤 막대 (또는 일부 스크롤 메커니즘)가 필요합니다. 웹 작성자가 제어 할 수없는 몇 가지 이유로 인해 컨텐츠가 창 크기를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547dede46448d778fb1b2d3d4a1e76f56ac72076" translate="yes" xml:space="preserve">
          <source>When copying a directory, the copy is always recursive; you can't leave out subfolders.</source>
          <target state="translated">디렉토리를 복사 할 때 사본은 항상 재귀 적입니다. 하위 폴더를 남길 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d3847c2cd2e45986477e1f72c1bfe78af504d9e" translate="yes" xml:space="preserve">
          <source>When creating a graph that has a cycle, it is mandatory to have at least one &lt;code&gt;DelayNode&lt;/code&gt; in the cycle, or the nodes taking part in the cycle will be muted.</source>
          <target state="translated">주기가있는 그래프를 작성할 때주기에 하나 이상의 &lt;code&gt;DelayNode&lt;/code&gt; 가 있어야합니다. 그렇지 않으면주기에 참여하는 노드가 음소거됩니다.</target>
        </trans-unit>
        <trans-unit id="2a437ce003ff81d7c01e0f2ba43107a075d4502c" translate="yes" xml:space="preserve">
          <source>When creating an IIR filter, we pass in the &lt;code&gt;feedforward&lt;/code&gt; and &lt;code&gt;feedback&lt;/code&gt; coefficients as options (coefficients is how we describe the values). Both of these parameters are arrays, neither of which can be larger than 20 items.</source>
          <target state="translated">IIR 필터를 만들 때 &lt;code&gt;feedforward&lt;/code&gt; 및 &lt;code&gt;feedback&lt;/code&gt; 계수를 옵션으로 전달합니다 (계수는 값을 설명하는 방법입니다). 이 두 매개 변수는 모두 배열이며, 둘 중 20 개보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e07e5358a6134e954bdac49f2b8e2f8621ed48c" translate="yes" xml:space="preserve">
          <source>When creating the &lt;a href=&quot;../nodeiterator&quot;&gt;&lt;code&gt;NodeIterator&lt;/code&gt;&lt;/a&gt;, the filter object is passed in as the third parameter, and the object method &lt;code&gt;acceptNode(&lt;em&gt;node&lt;/em&gt;)&lt;/code&gt; is called on every single node to determine whether or not to accept it. This function should return the constant &lt;code&gt;NodeFilter.FILTER_ACCEPT&lt;/code&gt; for cases when the node should be accepted and &lt;code&gt;NodeFilter.FILTER_REJECT&lt;/code&gt; for cases when the node should be rejected.</source>
          <target state="translated">&lt;a href=&quot;../nodeiterator&quot;&gt; &lt;code&gt;NodeIterator&lt;/code&gt; 를&lt;/a&gt; 작성할 때 필터 오브젝트는 세 번째 매개 변수로 전달되며, 오브젝트 메소드 &lt;code&gt;acceptNode(&lt;em&gt;node&lt;/em&gt;)&lt;/code&gt; 가 모든 단일 노드에서 호출되어이를 승인할지 여부를 판별합니다. 이 함수는 노드를 승인해야하는 경우 상수 &lt;code&gt;NodeFilter.FILTER_ACCEPT&lt;/code&gt; 를 리턴 하고 노드를 거부해야하는 경우 &lt;code&gt;NodeFilter.FILTER_REJECT&lt;/code&gt; 를 리턴 해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9bdad8d3b8ff0e476d64b1474adafe7bb9f43b0" translate="yes" xml:space="preserve">
          <source>When creating the &lt;code&gt;TreeWalker&lt;/code&gt;, the filter object is passed in as the third parameter, and its method &lt;a href=&quot;../nodefilter/acceptnode&quot;&gt;&lt;code&gt;NodeFilter.acceptNode()&lt;/code&gt;&lt;/a&gt; is called on every single node to determine whether or not to accept it.</source>
          <target state="translated">&lt;code&gt;TreeWalker&lt;/code&gt; 를 작성할 때 , 필터 오브젝트는 세 번째 매개 변수로 전달되며, 해당 노드 의 메소드 &lt;a href=&quot;../nodefilter/acceptnode&quot;&gt; &lt;code&gt;NodeFilter.acceptNode()&lt;/code&gt; &lt;/a&gt; 가 모든 단일 노드에서 호출되어이를 승인할지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="a55232b0345014c3ebefa7487379a5c33f26eecd" translate="yes" xml:space="preserve">
          <source>When dealing with security, the whole &lt;strong&gt;system&lt;/strong&gt; must be considered. In the case of the Web Crypto API, Web developers shouldn't consider only the security of the script, but the security of the connection to the server, because using Web Crypto over HTTP is not secure. The overall security can't be stronger than the security of the weakest part of the overall system.</source>
          <target state="translated">보안을 다룰 때는 전체 &lt;strong&gt;시스템&lt;/strong&gt; 을 고려해야합니다. Web Crypto API의 경우 웹 개발자는 HTTP를 통한 Web Crypto 사용이 안전하지 않기 때문에 스크립트의 보안 만 고려하지 말고 서버에 대한 연결 보안을 고려해야합니다. 전체 보안은 전체 시스템의 가장 취약한 부분의 보안보다 강력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0d22632065225e2a7e489aad461a84719ffd1c4" translate="yes" xml:space="preserve">
          <source>When defining the &lt;a href=&quot;#scope&quot;&gt;scope&lt;/a&gt;, specify only the object stores you need. This way, you can run multiple transactions with non-overlapping scopes concurrently.</source>
          <target state="translated">&lt;a href=&quot;#scope&quot;&gt;범위를&lt;/a&gt; 정의 할 때 필요한 오브젝트 저장소 만 지정하십시오. 이렇게하면 겹치지 않는 범위를 가진 여러 트랜잭션을 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ba34fb991d0b4af72fe2e8cdb499b5e8f75197" translate="yes" xml:space="preserve">
          <source>When defining the scope, specify only the object stores you need. This way, you can run multiple transactions with non-overlapping scopes concurrently.</source>
          <target state="translated">범위를 정의 할 때 필요한 오브젝트 저장소 만 지정하십시오. 이렇게하면 겹치지 않는 범위를 가진 여러 트랜잭션을 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde041ca7649d46132ca411c0292d941a4d98727" translate="yes" xml:space="preserve">
          <source>When describing a codec for an &lt;a href=&quot;rtcrtpsender&quot;&gt;&lt;code&gt;RTCRtpSender&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;codecPayloadType&lt;/code&gt; is a single 8-bit byte (or octet) specifying the codec to use for sending the stream.</source>
          <target state="translated">하는 코덱을 기술 할 때 &lt;a href=&quot;rtcrtpsender&quot;&gt; &lt;code&gt;RTCRtpSender&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;codecPayloadType&lt;/code&gt; 은 스트림을 전송하기 위해 사용하는 코덱을 지정하는 단일 8 비트 바이트 (또는 옥텟)이다.</target>
        </trans-unit>
        <trans-unit id="8808ea74a5c2279ba6319595f36fe2e06fe5b174" translate="yes" xml:space="preserve">
          <source>When dragging text, use the &lt;code&gt;text/plain&lt;/code&gt; type. The data should be the string to drag. For example:</source>
          <target state="translated">텍스트를 드래그 할 때 &lt;code&gt;text/plain&lt;/code&gt; 유형을 사용하십시오 . 데이터는 드래그 할 문자열이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2954ff4e77855af015954dd82532bda673b7b4ab" translate="yes" xml:space="preserve">
          <source>When dragging, there are several operations that may be performed. The &lt;code&gt;copy&lt;/code&gt; operation is used to indicate that the data being dragged will be copied from its present location to the drop location. The &lt;code&gt;move&lt;/code&gt; operation is used to indicate that the data being dragged will be moved, and the &lt;code&gt;link&lt;/code&gt; operation is used to indicate that some form of relationship or connection will be created between the source and drop locations.</source>
          <target state="translated">드래그 할 때 수행 할 수있는 몇 가지 작업이 있습니다. &lt;code&gt;copy&lt;/code&gt; 동작이 존재 드래그 데이터가 드롭 위치에 그것의 현재 위치로부터 복사 될 것을 나타 내기 위해 사용된다. &lt;code&gt;move&lt;/code&gt; 동작은 드래그되는 데이터가 이동 될 것을 나타 내기 위해 사용되며, &lt;code&gt;link&lt;/code&gt; 동작 관계 또는 연결의 일부 형태는 소스 놓기 위치 사이에 생성된다는 것을 나타 내기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="06ec3d3fadb5877cf06936dfc1d912ef1e4adffe" translate="yes" xml:space="preserve">
          <source>When each octave element has been built, it's appended to the keyboard.</source>
          <target state="translated">각 옥타브 요소가 만들어지면 키보드에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8812c50481c1e217f21b51f9cdc3812019218753" translate="yes" xml:space="preserve">
          <source>When each peer's ICE layer begins to send candidates, it enters into an exchange among the various points in the chain that looks like this:</source>
          <target state="translated">각 피어의 ICE 레이어는 후보를 보내기 시작하면 다음과 같은 체인의 여러 지점간에 교환을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4dfd6c654a0a0250253e02d1f153430ef3910bcf" translate="yes" xml:space="preserve">
          <source>When element has &lt;code&gt;display: inline&lt;/code&gt;, then &lt;code&gt;clientLeft&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt; regardless of the element's border.</source>
          <target state="translated">요소가있는 경우 &lt;code&gt;display: inline&lt;/code&gt; , 다음 &lt;code&gt;clientLeft&lt;/code&gt; 는 반환 &lt;code&gt;0&lt;/code&gt; 에 관계없이 요소의 테두리.</target>
        </trans-unit>
        <trans-unit id="538ffb5a52d165254694445488d91a187d048b52" translate="yes" xml:space="preserve">
          <source>When extreme changes in context are explicitly identified before they occur, then the users can determine if they wish to proceed or so they can be prepared for the change: not only they will not be confused or feel disoriented, but more experienced users can better decide how to open such links (in a new window or not, in the same window, in a new tab or not, in &quot;background&quot; or not).</source>
          <target state="translated">상황의 극단적 인 변화가 발생하기 전에 명시 적으로 식별되면, 사용자는 진행 여부를 결정할 수 있고 변화를 준비 할 수 있습니다. 혼란 스럽거나 혼란스러워하지 않을뿐만 아니라보다 숙련 된 사용자가 더 잘 결정할 수 있습니다. 이러한 링크를 여는 방법 (새 창에서 또는 같은 창에서 새 탭으로 또는 &quot;백그라운드&quot;에서 또는 아닌).</target>
        </trans-unit>
        <trans-unit id="85e428bd96cda0422ff18a3ca8b64602f93eeece" translate="yes" xml:space="preserve">
          <source>When fetching a resource, if there are multiple HTTP redirects, and any of the redirects have an origin that is different from the current document, and the timing allow check algorithm passes for each redirected resource, this property returns the time immediately after receiving the last byte of the response of the last redirect; otherwise, zero is returned.</source>
          <target state="translated">리소스를 가져올 때 여러 HTTP 리디렉션이 있고 리디렉션 중 하나에 현재 문서와 다른 원점이 있고 타이밍 허용 검사 알고리즘이 각 리디렉션 된 리소스에 대해 통과하면이 속성은 마지막을받은 직후에 시간을 반환합니다. 마지막 리디렉션의 응답 바이트; 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d73d4840da1d9031b50cfa8215efcb73b3c6b6a" translate="yes" xml:space="preserve">
          <source>When firing a CustomEvent from privileged code (i.e. an extension) to non-privileged code (i.e. a webpage), security issues should be considered. Firefox and other Gecko applications restrict an object created in one context from being directly used for another, which will automatically prevent security holes, but these restrictions may also prevent your code from running as expected.</source>
          <target state="translated">권한있는 코드 (예 : 확장명)에서 권한없는 코드 (예 : 웹 페이지)로 CustomEvent를 실행할 때 보안 문제를 고려해야합니다. Firefox 및 기타 Gecko 응용 프로그램은 한 컨텍스트에서 작성된 오브젝트가 다른 컨텍스트에 직접 사용되는 것을 제한하여 보안 허점을 자동으로 방지하지만 이러한 제한 사항으로 인해 코드가 예상대로 실행되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="931d837e34bb032e20136eec2d3ae2d5e3429093" translate="yes" xml:space="preserve">
          <source>When fullscreen mode is successfully engaged, the document which contains the element receives a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; event. When fullscreen mode is exited, the document again receives a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; event. Note that the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; event doesn't provide any information itself as to whether the document is entering or exiting fullscreen mode, but if the document has a non null &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/fullscreenElement&quot;&gt;&lt;code&gt;fullscreenElement&lt;/code&gt;&lt;/a&gt;, you know you're in fullscreen mode.</source>
          <target state="translated">전체 화면 모드가 성공적으로 적용되면 요소가 포함 된 문서가 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; 이벤트를 받습니다 . 전체 화면 모드가 종료되면 문서가 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; 이벤트를 다시받습니다 . 있습니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/fullscreenchange&quot;&gt;fullscreenchange&lt;/a&gt;&lt;/code&gt; 의 이벤트가 문서를 입력하거나 전체 화면 모드를 종료되는지 여부에 관한 정보 자체를 제공하지 않지만 문서가 null 이외의 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/fullscreenElement&quot;&gt; &lt;code&gt;fullscreenElement&lt;/code&gt; 을&lt;/a&gt; , 당신은 전체 화면 모드에서 거 알아.</target>
        </trans-unit>
        <trans-unit id="60fe4a51fbe090f163da5e58b1c3a616f0cfe554" translate="yes" xml:space="preserve">
          <source>When getModifierState() returns true on Gecko?</source>
          <target state="translated">Gecko에서 getModifierState ()가 true를 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="1d83c9a78b9cb84edd50601936994946a34f9673" translate="yes" xml:space="preserve">
          <source>When getting data from &lt;code&gt;getFloatFrequencyData()&lt;/code&gt; or &lt;code&gt;getByteFrequencyData()&lt;/code&gt;, any frequencies with an amplitude of &lt;code&gt;maxDecibels&lt;/code&gt; or higher will be returned as &lt;code&gt;+1.0&lt;/code&gt; or &lt;code&gt;255&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;getFloatFrequencyData()&lt;/code&gt; 또는 &lt;code&gt;getByteFrequencyData()&lt;/code&gt; 에서 데이터를 가져올 때 진폭이 &lt;code&gt;maxDecibels&lt;/code&gt; 이상인 주파수는 각각 &lt;code&gt;+1.0&lt;/code&gt; 또는 &lt;code&gt;255&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7503c6eee2649d91a08bc3af27dcaf170236ee9" translate="yes" xml:space="preserve">
          <source>When getting data from &lt;code&gt;getFloatFrequencyData()&lt;/code&gt; or &lt;code&gt;getByteFrequencyData()&lt;/code&gt;, any frequencies with an amplitude of &lt;code&gt;minDecibels&lt;/code&gt; or lower will be returned as &lt;code&gt;0.0&lt;/code&gt; or 0, respectively.</source>
          <target state="translated">&lt;code&gt;getFloatFrequencyData()&lt;/code&gt; 또는 &lt;code&gt;getByteFrequencyData()&lt;/code&gt; 에서 데이터를 가져올 때 진폭이 &lt;code&gt;minDecibels&lt;/code&gt; 이하인 주파수는 각각 &lt;code&gt;0.0&lt;/code&gt; 또는 0 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="15548a1742c25ed6b58a6ae244f9ddfee215eb08" translate="yes" xml:space="preserve">
          <source>When implementing PushManager subscriptions, it is vitally important that you protect against CSRF/XSRF issues in your app. See the following articles for more information:</source>
          <target state="translated">PushManager 구독을 구현할 때는 앱의 CSRF / XSRF 문제를 방지하는 것이 매우 중요합니다. 자세한 내용은 다음 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="215e93c5ac585100289cb5066a79c08d009bdcb1" translate="yes" xml:space="preserve">
          <source>When in quirks mode, the &lt;code&gt;scrollingElement&lt;/code&gt; attribute returns the HTML &lt;code&gt;body&lt;/code&gt; element if it exists and is not &lt;a href=&quot;https://drafts.csswg.org/cssom-view/#potentially-scrollable&quot;&gt;potentially scrollable&lt;/a&gt;, otherwise it returns null.</source>
          <target state="translated">쿼크 모드 인 경우 &lt;code&gt;scrollingElement&lt;/code&gt; 속성은 HTML &lt;code&gt;body&lt;/code&gt; 요소가 있고 &lt;a href=&quot;https://drafts.csswg.org/cssom-view/#potentially-scrollable&quot;&gt;잠재적으로 스크롤 할 수&lt;/a&gt; 없는 경우 HTML 본문 요소를 반환하고 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9d2f403fbee5a0371152e5fc775872d7db309a0" translate="yes" xml:space="preserve">
          <source>When inserting HTML into a page by using &lt;code&gt;insertAdjacentHTML&lt;/code&gt; be careful not to use user input that hasn't been escaped.</source>
          <target state="translated">&lt;code&gt;insertAdjacentHTML&lt;/code&gt; 을 사용하여 페이지에 HTML을 삽입 할 때 이스케이프되지 않은 사용자 입력을 사용하지 않도록주의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2face5f0b7ed1967344712b4040f658774097aef" translate="yes" xml:space="preserve">
          <source>When invoked with a string consisting of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths&quot;&gt;SVG path&lt;/a&gt; data, a new path is created from that description.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths&quot;&gt;SVG 경로&lt;/a&gt; 데이터 로 구성된 문자열로 호출하면 해당 설명에서 새 경로가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="0fa37dd444c1b5ffb1f12145e2d0e3f7ca6c2394" translate="yes" xml:space="preserve">
          <source>When invoked with another &lt;code&gt;Path2D&lt;/code&gt; object, a copy of the &lt;code&gt;path&lt;/code&gt; argument is created.</source>
          <target state="translated">다른 &lt;code&gt;Path2D&lt;/code&gt; 객체 와 함께 호출되면 &lt;code&gt;path&lt;/code&gt; 인수 의 복사본 이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a53e08ee8aa6ac62cf922d2234ff6a1c6f09852a" translate="yes" xml:space="preserve">
          <source>When invoked, will empty all keys out of the storage.</source>
          <target state="translated">호출되면 모든 키가 스토리지에서 비워집니다.</target>
        </trans-unit>
        <trans-unit id="7c6de2a28bfed4b9ba32899cd8c2429a452cb375" translate="yes" xml:space="preserve">
          <source>When invoking this method directly, no submit event is raised (in particular, the form's &lt;code&gt;onsubmit&lt;/code&gt; event handler is not run), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation&quot;&gt;constraint validation&lt;/a&gt; is not triggered either.</source>
          <target state="translated">이 메소드를 직접 호출하면 제출 이벤트가 발생하지 않으며 (특히 양식의 &lt;code&gt;onsubmit&lt;/code&gt; 이벤트 핸들러가 실행되지 않음) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation&quot;&gt;제한 조건 유효성 검증&lt;/a&gt; 도 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62d45ca92f9517f71a3f209b5b95a09ac458d113" translate="yes" xml:space="preserve">
          <source>When it gets this request, the &lt;strong&gt;server&lt;/strong&gt; should send a pretty odd-looking (but still HTTP) response that looks like this (remember each header ends with &lt;code&gt;\r\n&lt;/code&gt; and put an extra &lt;code&gt;\r\n&lt;/code&gt; after the last one):</source>
          <target state="translated">이이 요청을 얻을 때, &lt;strong&gt;서버는&lt;/strong&gt; 이 같은 외모 (각 헤더의 끝을 기억하는 아주 이상한 보이는 (하지만 여전히 HTTP) 응답을 전송한다 &lt;code&gt;\r\n&lt;/code&gt; 하고 추가로 넣어 &lt;code&gt;\r\n&lt;/code&gt; 마지막 후) :</target>
        </trans-unit>
        <trans-unit id="1c1692e30bcef2404cee756389d9cea218936288" translate="yes" xml:space="preserve">
          <source>When it takes a positive value it is a real gain, when negative it is an attenuation.</source>
          <target state="translated">양수 값을 사용하면 실제 게인이되고 음수이면 감쇠입니다.</target>
        </trans-unit>
        <trans-unit id="0ae5bee557d9c9272e102b88fbfad4d5a969d111" translate="yes" xml:space="preserve">
          <source>When its value changes, as the user's preferred languages are changed a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/languagechange&quot;&gt;languagechange&lt;/a&gt;&lt;/code&gt; event is fired on the &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;Window&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">값이 변경되면 사용자가 선호하는 언어가 변경됨에 따라 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/languagechange&quot;&gt;languagechange&lt;/a&gt;&lt;/code&gt; 변경 이벤트가 &lt;a href=&quot;../window&quot;&gt; &lt;code&gt;Window&lt;/code&gt; &lt;/a&gt; 객체에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="90cf237ff8e56b11687a19c6737df3ce64a1017c" translate="yes" xml:space="preserve">
          <source>When looping is enabled, the sound begins playing at the time specified as the start point when &lt;a href=&quot;start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is called. When the time specified by the &lt;a href=&quot;loopend&quot;&gt;&lt;code&gt;loopEnd&lt;/code&gt;&lt;/a&gt; property is reached, playback continues at the time specified by &lt;a href=&quot;loopstart&quot;&gt;&lt;code&gt;loopStart&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">루핑이 활성화되면 &lt;a href=&quot;start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 시작 지점으로 지정된 시간에 사운드가 재생되기 시작합니다 . 에 의해 지정된 시간 때 &lt;a href=&quot;loopend&quot;&gt; &lt;code&gt;loopEnd&lt;/code&gt; 의&lt;/a&gt; 특성에 도달 할 때, 재생에 의해 지정된 시간에 계속 &lt;a href=&quot;loopstart&quot;&gt; &lt;code&gt;loopStart&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6a2d424ecb60622519388a142a990319875abb6" translate="yes" xml:space="preserve">
          <source>When moving a directory, the move is always recursive; you can't leave out subfolders.</source>
          <target state="translated">디렉토리를 이동할 때 이동은 항상 재귀 적입니다. 하위 폴더를 남길 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1bf6915fcb0876cbfb452bd4523b334fcdef515" translate="yes" xml:space="preserve">
          <source>When new tracks are added to the &lt;code&gt;RTCPeerConnection&lt;/code&gt;&amp;mdash; either by calling its &lt;a href=&quot;../rtcpeerconnection/addtrack&quot;&gt;&lt;code&gt;addTrack()&lt;/code&gt;&lt;/a&gt; method or because of renegotiation of the stream's format&amp;mdash;a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/track&quot;&gt;track&lt;/a&gt;&lt;/code&gt; event is set to the &lt;code&gt;RTCPeerConnection&lt;/code&gt; for each track added to the connection. Making use of newly added media requires implementing a handler for the &lt;code&gt;track&lt;/code&gt; event. A common need is to attach the incoming media to an appropriate HTML element. In our example, we add the track's stream to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element that displays the incoming video:</source>
          <target state="translated">새로운 트랙이 추가되면 &lt;code&gt;RTCPeerConnection&lt;/code&gt; - 그 호출 중 &lt;a href=&quot;../rtcpeerconnection/addtrack&quot;&gt; &lt;code&gt;addTrack()&lt;/code&gt; &lt;/a&gt; 메소드 또는 때문에 스트림의 포맷 (A)의 재협상 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/track&quot;&gt;track&lt;/a&gt;&lt;/code&gt; 의 이벤트로 설정 &lt;code&gt;RTCPeerConnection&lt;/code&gt; 연결 추가 트랙마다. 새로 추가 된 미디어를 사용하려면 &lt;code&gt;track&lt;/code&gt; 이벤트 처리기를 구현해야합니다 . 일반적으로 들어오는 미디어를 적절한 HTML 요소에 연결해야합니다. 이 예에서는 수신 비디오를 표시하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 트랙 스트림을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8fa282965910599814d2e295744e01e2115ba58e" translate="yes" xml:space="preserve">
          <source>When no pages are using the current version, the new worker activates and becomes responsible for fetches.</source>
          <target state="translated">현재 버전을 사용중인 페이지가 없으면 새 작업자가 활성화되어 가져 오기를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="7b667f6155d8918de818445c7301cf5daf675998" translate="yes" xml:space="preserve">
          <source>When numbers are extremely large (or extremely small) on computers they begin to become less and less precise because there are only so many ones and zeros that are used to represent them. The more operations that are done on larger numbers, the more and more errors accumulate into the result. When dividing by w, this can effectively increase the precision of very large numbers by operating on two potentially smaller, less error-prone numbers.</source>
          <target state="translated">컴퓨터에서 숫자가 매우 크거나 매우 작 으면 숫자를 나타내는 데 사용되는 1과 0이 너무 많기 때문에 점점 정확도가 떨어지기 시작합니다. 더 많은 수의 작업을 수행할수록 결과에 더 많은 오류가 누적됩니다. w로 나눌 때, 이것은 잠재적으로 더 작고 오류가 덜 발생하는 두 개의 숫자에서 작동함으로써 매우 큰 숫자의 정밀도를 효과적으로 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081a8cdbc8e662c681be1eefd201a61d32f6a8d4" translate="yes" xml:space="preserve">
          <source>When only one argument is present: Toggle the class value; i.e., if the class exists then remove it and return &lt;code&gt;false&lt;/code&gt;, if not, then add it and return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인수가 하나 뿐인 경우 : 클래스 값을 토글하십시오. 즉, 클래스가 존재하면 클래스를 제거하고 &lt;code&gt;false&lt;/code&gt; 를 리턴 하고 그렇지 않은 경우 클래스 를 추가하고 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad839b2f539650a13de37b86845dc0102ff323ec" translate="yes" xml:space="preserve">
          <source>When our button is clicked, we prevent the form from submitting as normal and then send the value entered in our text input to the IFrame via the &lt;a href=&quot;../messagechannel&quot;&gt;&lt;code&gt;MessageChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버튼을 클릭하면 양식이 정상적으로 제출되는 것을 방지 한 다음 텍스트 입력에 입력 한 값을 &lt;a href=&quot;../messagechannel&quot;&gt; &lt;code&gt;MessageChannel&lt;/code&gt; 을&lt;/a&gt; 통해 IFrame으로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="37586336583587a213a08db4df01979dde4b3ffc" translate="yes" xml:space="preserve">
          <source>When passed a key name and value, will add that key to the storage, or update that key's value if it already exists.</source>
          <target state="translated">키 이름과 값을 전달하면 해당 키를 스토리지에 추가하거나 해당 키 값이 이미있는 경우이를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="be2997d2b3ccc462a2263e8660cd2a4d0fa0ffe7" translate="yes" xml:space="preserve">
          <source>When passed a key name, will remove that key from the storage.</source>
          <target state="translated">키 이름을 전달하면 스토리지에서 해당 키가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7a49270cc6131e60ab2563477a2294fb09d3b2ca" translate="yes" xml:space="preserve">
          <source>When passed a key name, will return that key's value.</source>
          <target state="translated">키 이름을 전달하면 해당 키 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1113729c3b7579559ff96b61dada291309f8c0be" translate="yes" xml:space="preserve">
          <source>When passed a number n, this method will return the name of the nth key in the storage.</source>
          <target state="translated">숫자 n을 전달하면이 메소드는 스토리지에서 n 번째 키의 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8095e25b62d000e13eb6255863c379be3b074531" translate="yes" xml:space="preserve">
          <source>When passed a valid media configuration, it returns a promise with information as to whether the media type is supported, and whether decoding such media would be smooth and power efficient.</source>
          <target state="translated">유효한 미디어 구성을 통과하면 미디어 유형이 지원되는지 여부와 이러한 미디어의 디코딩이 원활하고 전력 효율적인지에 대한 정보가 담긴 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7cc6fdf4f61b0a31f3b2ea3f41b6a93345e0d8e" translate="yes" xml:space="preserve">
          <source>When passed a valid media configuration, it returns a promise with information as to whether the media type is supported, and whether encoding such media would be smooth and power efficient.</source>
          <target state="translated">유효한 미디어 구성을 전달하면 미디어 유형이 지원되는지 여부 및 이러한 미디어를 인코딩하는 것이 매끄럽고 전력 효율적인지 여부에 대한 정보가 담긴 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b5dbb8016e4e618bf1d6de3834052f9e1c14f2dd" translate="yes" xml:space="preserve">
          <source>When playing sound on the web, it's important to allow the user to control it. Depending on the use case, there's a myriad of options, but we'll provide functionality to play/pause the sound, alter the track's volume, and pan it from left to right.</source>
          <target state="translated">웹에서 사운드를 재생할 때 사용자가 사운드를 제어 할 수 있도록하는 것이 중요합니다. 사용 사례에 따라 다양한 옵션이 있지만 사운드 재생 / 일시 정지, 트랙 음량 변경 및 왼쪽에서 오른쪽으로 이동하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25caa96ed56e35d7d2b9bc8eaa2fad4a2feb8036" translate="yes" xml:space="preserve">
          <source>When pointer capture is set, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerover&quot;&gt;&lt;code&gt;pointerover&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerout&quot;&gt;&lt;code&gt;pointerout&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerenter&quot;&gt;&lt;code&gt;pointerenter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerleave&quot;&gt;&lt;code&gt;pointerleave&lt;/code&gt;&lt;/a&gt; events are only generated when crossing the boundary of the element that has capture set since other elements can no longer be targeted by the pointer. This has the effect of suppressing these events on all other elements.</source>
          <target state="translated">포인터 캡처가 설정되면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerover&quot;&gt; &lt;code&gt;pointerover&lt;/code&gt; 는&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerout&quot;&gt; &lt;code&gt;pointerout&lt;/code&gt; 의&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerenter&quot;&gt; &lt;code&gt;pointerenter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerleave&quot;&gt; &lt;code&gt;pointerleave&lt;/code&gt; &lt;/a&gt; 다른 요소가 더 이상 포인터의 대상이 될 수 있기 때문에 캡처 설정되지 않은 요소의 경계를 횡단 할 때 이벤트 만 생성됩니다. 이는 다른 모든 요소에서 이러한 이벤트를 억제하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="803eb401ef9424c0dd1a55a8c44174f01a800482" translate="yes" xml:space="preserve">
          <source>When possible, avoid polling &lt;code&gt;muted&lt;/code&gt; to monitor the track's muting status. Instead, add event listeners for the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/mute&quot;&gt;mute&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unmute&quot;&gt;unmute&lt;/a&gt;&lt;/code&gt; events.</source>
          <target state="translated">가능 하면 트랙의 음소거 상태를 모니터링하기 위해 &lt;code&gt;muted&lt;/code&gt; 폴링을 피 하십시오. 대신, &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/mute&quot;&gt;mute&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unmute&quot;&gt;unmute&lt;/a&gt;&lt;/code&gt; 이벤트에 대한 이벤트 리스너를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1912c7e2a7ad62198a0f08bd99551faf6ff11ae" translate="yes" xml:space="preserve">
          <source>When preparing to open an &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;, you can change the codec parameters from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent's&lt;/a&gt; default configuration by calling &lt;code&gt;setCodecParameters()&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; calling either &lt;a href=&quot;../rtcpeerconnection/createoffer&quot;&gt;&lt;code&gt;RTCPeerConnection.createOffer()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rtcpeerconnection/createanswer&quot;&gt;&lt;code&gt;createAnswer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 을 열 준비를 할 때 &lt;a href=&quot;../rtcpeerconnection/createoffer&quot;&gt; &lt;code&gt;RTCPeerConnection.createOffer()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../rtcpeerconnection/createanswer&quot;&gt; &lt;code&gt;createAnswer()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 를&lt;/em&gt; 호출 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;setCodecParameters()&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 호출 하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트의&lt;/a&gt; 기본 구성 에서 코덱 매개 변수를 변경할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ee6493009b6431b9980b49942a6355d2a9ef723" translate="yes" xml:space="preserve">
          <source>When problems occur (such as a network timeout or issues pertaining to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS&quot;&gt;access control&lt;/a&gt;), an error event is generated. You can take action on this programmatically by implementing the &lt;code&gt;onerror&lt;/code&gt; callback on the EventSource object:</source>
          <target state="translated">네트워크 시간 초과 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS&quot;&gt;액세스 제어&lt;/a&gt; 관련 문제와 같은 문제가 발생 하면 오류 이벤트가 생성됩니다. EventSource 객체 에서 &lt;code&gt;onerror&lt;/code&gt; 콜백을 구현하여 프로그래밍 방식으로 조치를 취할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43967ee727b9fa7d551a4702810bf536a051500b" translate="yes" xml:space="preserve">
          <source>When put all together with the rest of the HTML and the CSS not shown above, it looks and works like this:</source>
          <target state="translated">위에 표시되지 않은 나머지 HTML 및 CSS와 모두 함께 사용하면 다음과 같이 보이고 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1d22a87170e59c2c29ea0fb54d09a04db32671bb" translate="yes" xml:space="preserve">
          <source>When reading the description (returned by &lt;a href=&quot;../rtcpeerconnection/localdescription&quot;&gt;&lt;code&gt;RTCPeerConnection.localDescription&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../rtcpeerconnection/remotedescription&quot;&gt;&lt;code&gt;RTCPeerConnection.remoteDescription&lt;/code&gt;&lt;/a&gt;), the returned value is the value of &lt;code&gt;pendingLocalDescription&lt;/code&gt;/&lt;code&gt;pendingRemoteDescription&lt;/code&gt; if there's a pending description (that is, the pending description isn't &lt;code&gt;null&lt;/code&gt;); otherwise, the current description (&lt;code&gt;currentLocalDescription&lt;/code&gt;/&lt;code&gt;currentRemoteDescription&lt;/code&gt;) is returned.</source>
          <target state="translated">설명을 읽을 때 ( &lt;a href=&quot;../rtcpeerconnection/localdescription&quot;&gt; &lt;code&gt;RTCPeerConnection.localDescription&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../rtcpeerconnection/remotedescription&quot;&gt; &lt;code&gt;RTCPeerConnection.remoteDescription&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 됨 ) 보류중인 설명이있는 경우 리턴되는 값은 &lt;code&gt;pendingLocalDescription&lt;/code&gt; / &lt;code&gt;pendingRemoteDescription&lt;/code&gt; 의 값입니다 (즉, 보류중인 설명이 &lt;code&gt;null&lt;/code&gt; 이 아님 ). 그렇지 않으면 현재 설명 ( &lt;code&gt;currentLocalDescription&lt;/code&gt; / &lt;code&gt;currentRemoteDescription&lt;/code&gt; )이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8612bf8e013b9fd3e94709a3077ed536e8f96a80" translate="yes" xml:space="preserve">
          <source>When recording has stopped, the &lt;code&gt;state&lt;/code&gt; property returns a value of &quot;inactive&quot;, and a stop event is fired. We register an event handler for this using &lt;a href=&quot;../mediarecorder/onstop&quot;&gt;&lt;code&gt;mediaRecorder.onstop&lt;/code&gt;&lt;/a&gt;, and finalize our blob there from all the chunks we have received:</source>
          <target state="translated">기록이 중지되면 &lt;code&gt;state&lt;/code&gt; 속성은 &quot;inactive&quot;값을 반환하고 중지 이벤트가 발생합니다. &lt;a href=&quot;../mediarecorder/onstop&quot;&gt; &lt;code&gt;mediaRecorder.onstop&lt;/code&gt; 을&lt;/a&gt; 사용하여 이벤트 핸들러를 등록하고 수신 한 모든 청크에서 Blob을 마무리합니다.</target>
        </trans-unit>
        <trans-unit id="cdeaeeb318f26705d3a5c755ea0f3c87fa0ffab4" translate="yes" xml:space="preserve">
          <source>When retrieving a dropped link, you should ensure you handle the case where multiple links may have been dragged, including any comments that appear in the data. For convenience, the special type &lt;code&gt;URL&lt;/code&gt; may be used to refer to the first valid link within the data for the &lt;code&gt;text/uri-list&lt;/code&gt; type. You should not add data using the &lt;code&gt;URL&lt;/code&gt; type; attempting to do so will just set the value of the &lt;code&gt;text/uri-list&lt;/code&gt; type instead.</source>
          <target state="translated">삭제 된 링크를 검색 할 때 데이터에 나타나는 주석을 포함하여 여러 개의 링크가 드래그 된 경우를 처리해야합니다. 편의상, 특수 유형 &lt;code&gt;URL&lt;/code&gt; 은 &lt;code&gt;text/uri-list&lt;/code&gt; 유형에 대한 데이터 내의 첫 번째 유효한 링크를 참조하는 데 사용될 수 있습니다 . &lt;code&gt;URL&lt;/code&gt; 유형을 사용하여 데이터를 추가해서는 안됩니다 . 그렇게하려고하면 &lt;code&gt;text/uri-list&lt;/code&gt; 유형 의 값이 대신 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="696d52160b1e3be1741d07cdf9d07723c2cf0c7f" translate="yes" xml:space="preserve">
          <source>When set to &lt;var&gt;no or 0&lt;/var&gt;, this feature removes the system close command icon and system close menu item. It will only work for dialog windows (&lt;code&gt;dialog&lt;/code&gt; feature set). &lt;code&gt;close=no&lt;/code&gt; will override &lt;code&gt;minimizable=yes&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;no or 0&lt;/var&gt; 설정하면 이 기능은 시스템 닫기 명령 아이콘 및 시스템 닫기 메뉴 항목을 제거합니다. 대화 상자 창 ( &lt;code&gt;dialog&lt;/code&gt; 기능 세트) 에서만 작동합니다 . &lt;code&gt;close=no&lt;/code&gt; 는 &lt;code&gt;minimizable=yes&lt;/code&gt; 를 대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="15ee8d812737b39143c7fb57d7614507069983a4" translate="yes" xml:space="preserve">
          <source>When setting &lt;code&gt;responseType&lt;/code&gt; to a particular value, the author should make sure that the server is actually sending a response compatible with that format. If the server returns data that is not compatible with the &lt;code&gt;responseType&lt;/code&gt; that was set, the value of &lt;a href=&quot;response&quot;&gt;&lt;code&gt;response&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;responseType&lt;/code&gt; 을 특정 값으로 설정할 때 작성자는 서버가 실제로 해당 형식과 호환되는 응답을 보내는 지 확인해야합니다. 와 호환되지 않습니다 서버 데이터를 반환하는 경우 &lt;code&gt;responseType&lt;/code&gt; 설정의 값 &lt;a href=&quot;response&quot;&gt; &lt;code&gt;response&lt;/code&gt; &lt;/a&gt; 할 것이다 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a590456297f1f8daa1809fc0ea3649d7f02dce02" translate="yes" xml:space="preserve">
          <source>When setting our coefficients, the &lt;code&gt;feedforward&lt;/code&gt; values can't all be set to zero, otherwise nothing would be sent to the filter. Something like this is acceptable:</source>
          <target state="translated">계수를 설정할 때 &lt;code&gt;feedforward&lt;/code&gt; 값을 모두 0으로 설정할 수 없으며, 그렇지 않으면 필터로 전송되지 않습니다. 이와 같은 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2319f30338438d879bc2e193b33159ccd9fe8936" translate="yes" xml:space="preserve">
          <source>When setting the value of &lt;code&gt;direction&lt;/code&gt;, the following exceptions can occur:</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; 값을 설정할 때 다음 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98988dc7aa1cb1eb0462f1becd5ffb24aa01eb7d" translate="yes" xml:space="preserve">
          <source>When starting the signaling process, an &lt;strong&gt;offer&lt;/strong&gt; is created by the user initiating the call. This offer includes a session description, in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SDP&quot;&gt;SDP&lt;/a&gt; format, and needs to be delivered to the receiving user, which we'll call the &lt;strong&gt;callee&lt;/strong&gt;. The callee responds to the offer with an &lt;strong&gt;answer&lt;/strong&gt; message, also containing an SDP description. Our signaling server will use WebSocket to transmit offer messages with the type &lt;code&gt;&quot;video-offer&quot;&lt;/code&gt;, and answer messages with the type &lt;code&gt;&quot;video-answer&quot;&lt;/code&gt;. These messages have the following fields:</source>
          <target state="translated">신호 처리 프로세스를 시작할 때 사용자가 통화를 시작하면 &lt;strong&gt;오퍼&lt;/strong&gt; 가 작성됩니다. 이 오퍼에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SDP&quot;&gt;SDP&lt;/a&gt; 형식 의 세션 설명이 포함 되며 수신 사용자에게 전달해야하며이를 &lt;strong&gt;수신자에게&lt;/strong&gt; 전화합니다 . 수신자 는 SDP 설명이 포함 된 &lt;strong&gt;응답&lt;/strong&gt; 메시지 와 함께 오퍼에 &lt;strong&gt;응답&lt;/strong&gt; 합니다. Google 시그널링 서버는 WebSocket을 사용하여 &lt;code&gt;&quot;video-offer&quot;&lt;/code&gt; 유형의 오퍼 메시지를 전송하고 &lt;code&gt;&quot;video-answer&quot;&lt;/code&gt; 유형의 메시지에 응답합니다 . 이 메시지에는 다음과 같은 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="81bc27e6843e09c3f87f20bab3f68914edebd437" translate="yes" xml:space="preserve">
          <source>When testing you can get around the HTTPS restriction by checking the &quot;Enable Service Workers over HTTP (when toolbox is open)&quot; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Settings&quot;&gt;Firefox Developer Tools settings&lt;/a&gt;.</source>
          <target state="translated">테스트 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Settings&quot;&gt;Firefox 개발자 도구 설정&lt;/a&gt; 에서 &quot;HTTP를 통해 서비스 워커 사용 (도구 상자가 열려있을 때)&quot;옵션을 선택하여 HTTPS 제한을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3dce835c28213f3bb867cdb69f7c2acf000e9f3c" translate="yes" xml:space="preserve">
          <source>When that happens, we know the video has started playing, so we call our &lt;code&gt;getCurrentSettings()&lt;/code&gt; function (described above) to display the actual settings that the browser decided upon after considering our constraints and the capabilities of the hardware.</source>
          <target state="translated">이러한 상황이 발생하면 비디오 재생이 시작된 것이므로 &lt;code&gt;getCurrentSettings()&lt;/code&gt; 함수 (위 설명 참조)를 호출 하여 제약 조건과 하드웨어 기능을 고려한 후 브라우저가 결정한 실제 설정을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="170458374de8d9d34b21effc3f5cd7cf1d8ede7e" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../datatransfer&quot;&gt;&lt;code&gt;DataTransfer&lt;/code&gt;&lt;/a&gt; object is created, &lt;code&gt;dropEffect&lt;/code&gt; is set to a string value. On getting, it returns its current value. On setting, if the new value is one of the values listed below, then the property's current value will be set to the new value and other values will be ignored.</source>
          <target state="translated">때 &lt;a href=&quot;../datatransfer&quot;&gt; &lt;code&gt;DataTransfer&lt;/code&gt; &lt;/a&gt; 객체가 생성, &lt;code&gt;dropEffect&lt;/code&gt; 를이 문자열 값으로 설정됩니다. 가져 오면 현재 값을 반환합니다. 설정시 새 값이 아래 나열된 값 중 하나 인 경우 속성의 현재 값이 새 값으로 설정되고 다른 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4a897014deee64b512b044886966ea42c42661" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; object's ICE connection state changes to &lt;code&gt;&quot;failed&quot;&lt;/code&gt;, you should try to trigger an &lt;a href=&quot;../webrtc_api/session_lifetime#ICE_restart&quot;&gt;ICE restart&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; 의&lt;/a&gt; 객체의 ICE 연결 상태가 변경 &lt;code&gt;&quot;failed&quot;&lt;/code&gt; , 당신은 트리거하도록해야 &lt;a href=&quot;../webrtc_api/session_lifetime#ICE_restart&quot;&gt;ICE 다시 시작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2e55a38c36655d933210552203f47251809730" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../windoworworkerglobalscope/fetch&quot;&gt;fetch request&lt;/a&gt; is initiated, we pass in the &lt;code&gt;AbortSignal&lt;/code&gt; as an option inside the request's options object (see &lt;code&gt;{signal}&lt;/code&gt;, below). This associates the signal and controller with the fetch request and allows us to abort it by calling &lt;a href=&quot;abort&quot;&gt;&lt;code&gt;AbortController.abort()&lt;/code&gt;&lt;/a&gt;, as seen below in the second event listener.</source>
          <target state="translated">때 &lt;a href=&quot;../windoworworkerglobalscope/fetch&quot;&gt;가져 오기 요청을&lt;/a&gt; 시작, 우리가 전달 &lt;code&gt;AbortSignal&lt;/code&gt; 요청의 옵션 객체의 내부 옵션으로 (참조 &lt;code&gt;{signal}&lt;/code&gt; 아래). 이것은 시그널과 컨트롤러를 페치 요청과 연관 시키며 아래 두 번째 이벤트 리스너에서 볼 수 있듯이 &lt;a href=&quot;abort&quot;&gt; &lt;code&gt;AbortController.abort()&lt;/code&gt; &lt;/a&gt; 를 호출하여 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb74bd244de5d5466e811370eee97f905789dcf" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt;fetch request&lt;/a&gt; is initiated, we pass in the &lt;code&gt;AbortSignal&lt;/code&gt; as an option inside the request's options object (see &lt;code&gt;{signal}&lt;/code&gt;, below). This associates the signal and controller with the fetch request and allows us to abort it by calling &lt;a href=&quot;abortcontroller/abort&quot;&gt;&lt;code&gt;AbortController.abort()&lt;/code&gt;&lt;/a&gt;, as seen below in the second event listener.</source>
          <target state="translated">때 &lt;a href=&quot;windoworworkerglobalscope/fetch&quot;&gt;가져 오기 요청을&lt;/a&gt; 시작, 우리가 전달 &lt;code&gt;AbortSignal&lt;/code&gt; 요청의 옵션 객체의 내부 옵션으로 (참조 &lt;code&gt;{signal}&lt;/code&gt; 아래). 이것은 시그널과 컨트롤러를 페치 요청과 연관 시키며 아래 두 번째 이벤트 리스너에서 볼 수 있듯이 &lt;a href=&quot;abortcontroller/abort&quot;&gt; &lt;code&gt;AbortController.abort()&lt;/code&gt; &lt;/a&gt; 를 호출하여 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4be292eea0d62bed233f932a55f02cfb7dc31c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&quot;sendrecv&quot;&lt;/code&gt; offer is received by the remote peer, it calls its &lt;code&gt;holdEnded()&lt;/code&gt; method:</source>
          <target state="translated">때 &lt;code&gt;&quot;sendrecv&quot;&lt;/code&gt; 제공이 원격 피어에 의해 수신되고, 그것의 호출 &lt;code&gt;holdEnded()&lt;/code&gt; 메소드를 :</target>
        </trans-unit>
        <trans-unit id="6e0833b39914236c0c18fdf6c35e8d2ad6272fdb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; event handler terminated, that is when the load event is completed. If this event has not yet been sent, or is not yet completed, it returns &lt;code&gt;0.&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 이벤트 핸들러가 종료 load 이벤트가 완료되면, 즉. 이 이벤트가 아직 전송되지 않았거나 아직 완료되지 않은 경우 &lt;code&gt;0.&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="155be4bdc0e49aedda66d74b36e03f99a0570c78" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; event was sent for the current document. If this event has not yet been sent, it returns &lt;code&gt;0.&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 이벤트는 현재 문서를 보냈습니다. 이 이벤트가 아직 전송되지 않은 경우 &lt;code&gt;0.&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6cd684a1da502ba55e06034dbbe608b4c135ecec" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/mousedown&quot;&gt;mousedown&lt;/a&gt;&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Mouseover&quot;&gt;&lt;code&gt;mouseover&lt;/code&gt;&lt;/a&gt; event occurs on a key, we want to start playing the corresponding note. The &lt;code&gt;notePressed()&lt;/code&gt; function is used as the event handler for these events.</source>
          <target state="translated">키 에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/mousedown&quot;&gt;mousedown&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Mouseover&quot;&gt; &lt;code&gt;mouseover&lt;/code&gt; &lt;/a&gt; 이벤트가 발생하면 해당 음표 연주를 시작하려고합니다. &lt;code&gt;notePressed()&lt;/code&gt; 함수는 이러한 이벤트에 대한 이벤트 핸들러로 사용된다.</target>
        </trans-unit>
        <trans-unit id="42ebd58fc29230c0a260ba3031de970a3c61db76" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; event handler finishes. If there is no previous document, or if the previous document, or one of the needed redirects, is not of the same origin, the value returned is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; 이벤트 처리기가 완료됩니다. 이전 문서가 없거나 이전 문서 또는 필요한 리디렉션 중 하나의 출처가 동일하지 않은 경우 반환되는 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc03a551d332d5cd1fa1a4ddf2018e191917b767" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; event has been thrown, indicating the time at which the previous document in the window began to unload. If there is no previous document, or if the previous document or one of the needed redirects is not of the same origin, the value returned is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/unload&quot;&gt;unload&lt;/a&gt;&lt;/code&gt; 이벤트가 발생 된 시간을 표시하는 창에서 이전 문서는 언로드하기 시작했다. 이전 문서가 없거나 이전 문서 또는 필요한 리디렉션 중 하나가 동일한 출처가 아닌 경우 반환되는 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a47d8b540256fcfc3d14f8c14a13539b4826781" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;dfn&gt;close&lt;/dfn&gt;()&lt;/code&gt; method is called on a &lt;a href=&quot;../presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; begins the process of closing the connection by sending an empty &lt;code&gt;closeMessage&lt;/code&gt; with the &lt;code&gt;closeReason&lt;/code&gt; set to &lt;code&gt;closed&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;dfn&gt;close&lt;/dfn&gt;()&lt;/code&gt; 메소드가 호출되어 &lt;a href=&quot;../presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 상기 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트는&lt;/a&gt; 빈 전송하여 연결 닫는 과정 시작 &lt;code&gt;closeMessage&lt;/code&gt; 와 &lt;code&gt;closeReason&lt;/code&gt; 용 으로 설정 &lt;code&gt;closed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42ffa15d469d09132a6b45fcbd902817e8aa2270" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;dfn&gt;getAvailability&lt;/dfn&gt;()&lt;/code&gt; method is called, the user agent &lt;em&gt;MUST&lt;/em&gt; run the following steps:</source>
          <target state="translated">때 &lt;code&gt;&lt;dfn&gt;getAvailability&lt;/dfn&gt;()&lt;/code&gt; 메소드가 호출 될 때, 사용자 에이전트는 &lt;em&gt;반드시&lt;/em&gt; 다음 단계를 실행합니다 :</target>
        </trans-unit>
        <trans-unit id="4391a06c9d0f2338a7c223835dc8fc4b32ce1dd6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;dfn&gt;getAvailability&lt;/dfn&gt;()&lt;/code&gt; method is called, the user agent &lt;em&gt;MUST&lt;/em&gt; run the steps as the link.</source>
          <target state="translated">때 &lt;code&gt;&lt;dfn&gt;getAvailability&lt;/dfn&gt;()&lt;/code&gt; 메소드가 호출 될 때, 사용자 에이전트는 &lt;em&gt;반드시&lt;/em&gt; 링크로 단계를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="15baee29e476d71d5e423c6e177f7644e49dc536" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;dfn&gt;reconnect&lt;/dfn&gt;(presentationId)&lt;/code&gt; method is called on a &lt;code&gt;PresentationRequest&lt;/code&gt;&lt;var&gt;presentationRequest&lt;/var&gt;, the &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-user-agents&quot;&gt;user agent&lt;/a&gt;&lt;em&gt;MUST&lt;/em&gt; run the following steps to</source>
          <target state="translated">&lt;code&gt;PresentationRequest&lt;/code&gt; &lt;var&gt;presentationRequest&lt;/var&gt; 에서 &lt;code&gt;&lt;dfn&gt;reconnect&lt;/dfn&gt;(presentationId)&lt;/code&gt; 메소드가 호출 되면 &lt;a href=&quot;https://www.w3.org/TR/presentation-api/#dfn-user-agents&quot;&gt;사용자 에이전트&lt;/a&gt; 는 다음 단계를 수행 &lt;em&gt;해야&lt;/em&gt; 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fea13ca177f96f2cce88b05d8eb364696e1f353" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;dfn&gt;terminate&lt;/dfn&gt;()&lt;/code&gt; method is called on a &lt;a href=&quot;../presentationconnection&quot;&gt;&lt;code&gt;PresentationConnection&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; begins the process of terminating the presentation. The exact process differs depending on whether &lt;code&gt;terminate()&lt;/code&gt; is called in the controlling or the presenting context.</source>
          <target state="translated">&lt;a href=&quot;../presentationconnection&quot;&gt; &lt;code&gt;PresentationConnection&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;&lt;dfn&gt;terminate&lt;/dfn&gt;()&lt;/code&gt; 메소드가 호출 되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 는 프리젠 테이션 종료 프로세스를 시작합니다. 정확한 프로세스는 제어 컨텍스트 또는 프리젠 테이션 컨텍스트에서 &lt;code&gt;terminate()&lt;/code&gt; 가 호출 되는지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="afab87a55a2cbb60584dec7012dd16c616599150" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;VRDisplay&lt;/code&gt; is not presenting a scene, this is functionally equivalent to &lt;a href=&quot;../window/requestanimationframe&quot;&gt;&lt;code&gt;Window.requestAnimationFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;VRDisplay&lt;/code&gt; 이 장면을 제시하지 않는,이 기능적으로 동일 &lt;a href=&quot;../window/requestanimationframe&quot;&gt; &lt;code&gt;Window.requestAnimationFrame&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bacba41f7f222545591f6432c766b199d19e287" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;VRDisplay&lt;/code&gt; is presenting, the callback is called at its native refresh rate.</source>
          <target state="translated">때 &lt;code&gt;VRDisplay&lt;/code&gt; 가 제시 콜백은 네이티브 새로 고침 속도라고합니다.</target>
        </trans-unit>
        <trans-unit id="ce9c61230318f6b91dfe6f655b2ab29cd51199b8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;mode&lt;/code&gt; of a shadow root is &quot;&lt;code&gt;closed&lt;/code&gt;&quot;, the shadow root&amp;rsquo;s implementation internals are inaccessible and unchangeable from JavaScript&amp;mdash;in the same way the implementation internals of, for example, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element are inaccessible and unchangeable from JavaScript.</source>
          <target state="translated">섀도우 루트 의 &lt;code&gt;mode&lt;/code&gt; 가 &quot; &lt;code&gt;closed&lt;/code&gt; &quot;경우 섀도우 루트의 구현 내부는 JavaScript에서 액세스 할 수없고 변경할 수 없습니다. 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 구현 내부는 JavaScript에서 액세스 할 수없고 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc4934e8bd3a8da0e29e9d7f7b1ef67047ec5e45" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;oninstall&lt;/code&gt; handler completes, the service worker is considered installed.</source>
          <target state="translated">때 &lt;code&gt;oninstall&lt;/code&gt; 핸들러 완료가 서비스 노동자 고려 설치.</target>
        </trans-unit>
        <trans-unit id="cf22449b85a37cdd14b29a36f972942979bbe90b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;onunmute&lt;/code&gt; event handler is called, the track's &lt;a href=&quot;muted&quot;&gt;&lt;code&gt;muted&lt;/code&gt;&lt;/a&gt; flag is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;onunmute&lt;/code&gt; 이벤트 핸들러가 호출 될 때, 트랙의 &lt;a href=&quot;muted&quot;&gt; &lt;code&gt;muted&lt;/code&gt; &lt;/a&gt; 플래그가 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60dc0f2a025f4d10adf32869bc65b2b714c66281" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;requestData()&lt;/code&gt; method is invoked, the browser queues a task that runs the following steps:</source>
          <target state="translated">때 &lt;code&gt;requestData()&lt;/code&gt; 메소드가 호출되고, 브라우저는 다음 단계를 실행하는 작업을 큐 :</target>
        </trans-unit>
        <trans-unit id="90885fc32dbfbad8b23af1666efeb791aeccac8b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;resume()&lt;/code&gt; method is invoked, the browser queues a task that runs the following steps:</source>
          <target state="translated">때 &lt;code&gt;resume()&lt;/code&gt; 메소드가 호출되고, 브라우저는 다음 단계를 실행하는 작업을 큐 :</target>
        </trans-unit>
        <trans-unit id="d86262e8364e3cf4d9684f7eb30500de8684042d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;startRendering()&lt;/code&gt; promise resolves, rendering has completed and the output &lt;code&gt;AudioBuffer&lt;/code&gt; is returned out of the promise.</source>
          <target state="translated">때 &lt;code&gt;startRendering()&lt;/code&gt; 약속의 결의는, 렌더링이 완료 한 출력 &lt;code&gt;AudioBuffer&lt;/code&gt; 약속 밖으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c37cbd465b80e0d4ec473469eefaf3ae4e0eb9c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;stop()&lt;/code&gt; method is invoked, the UA queues a task that runs the following steps:</source>
          <target state="translated">때 &lt;code&gt;stop()&lt;/code&gt; 메소드가 호출되면, UA는 다음 단계를 실행하는 작업을 큐 :</target>
        </trans-unit>
        <trans-unit id="e63c9a36b0456d2f72f7188fa624ad4d35c38d6a" translate="yes" xml:space="preserve">
          <source>When the IFrame has loaded, we register an &lt;code&gt;onclick&lt;/code&gt; handler for our button and an &lt;code&gt;onmessage&lt;/code&gt; handler for &lt;a href=&quot;../messagechannel/port1&quot;&gt;&lt;code&gt;MessageChannel.port1&lt;/code&gt;&lt;/a&gt;. Finally we transfer &lt;a href=&quot;../messagechannel/port2&quot;&gt;&lt;code&gt;MessageChannel.port2&lt;/code&gt;&lt;/a&gt; to the IFrame using the &lt;a href=&quot;../window/postmessage&quot;&gt;&lt;code&gt;window.postMessage&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">IFrame이로드되면 버튼 의 &lt;code&gt;onclick&lt;/code&gt; 핸들러와 &lt;a href=&quot;../messagechannel/port1&quot;&gt; &lt;code&gt;MessageChannel.port1&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;onmessage&lt;/code&gt; 핸들러를 등록합니다 . 마지막으로 &lt;a href=&quot;../window/postmessage&quot;&gt; &lt;code&gt;window.postMessage&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;a href=&quot;../messagechannel/port2&quot;&gt; &lt;code&gt;MessageChannel.port2&lt;/code&gt; &lt;/a&gt; 를 IFrame 으로 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="dc1fb33c3cdd6daf218a397fb6256d6ed43ebfc8" translate="yes" xml:space="preserve">
          <source>When the IFrame has loaded, we register an &lt;code&gt;onmessage&lt;/code&gt; handler for &lt;a href=&quot;messagechannel/port1&quot;&gt;&lt;code&gt;MessageChannel.port1&lt;/code&gt;&lt;/a&gt; and transfer &lt;a href=&quot;messagechannel/port2&quot;&gt;&lt;code&gt;MessageChannel.port2&lt;/code&gt;&lt;/a&gt; to the IFrame using the &lt;a href=&quot;window/postmessage&quot;&gt;&lt;code&gt;window.postMessage&lt;/code&gt;&lt;/a&gt; method along with a message.</source>
          <target state="translated">IFrame이로드되면 &lt;a href=&quot;messagechannel/port1&quot;&gt; &lt;code&gt;MessageChannel.port1&lt;/code&gt; 에&lt;/a&gt; 대한 &lt;code&gt;onmessage&lt;/code&gt; 핸들러를 등록 하고 메시지와 함께 &lt;a href=&quot;window/postmessage&quot;&gt; &lt;code&gt;window.postMessage&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;a href=&quot;messagechannel/port2&quot;&gt; &lt;code&gt;MessageChannel.port2&lt;/code&gt; &lt;/a&gt; 를 IFrame으로 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="a7e4ad3a03781aabf88e28bcd4efb42210025bdc" translate="yes" xml:space="preserve">
          <source>When the MediaRecorder is recording, the &lt;a href=&quot;../mediarecorder/state&quot;&gt;&lt;code&gt;MediaRecorder.state&lt;/code&gt;&lt;/a&gt; property will return a value of &quot;recording&quot;.</source>
          <target state="translated">MediaRecorder가 기록 중일 때 &lt;a href=&quot;../mediarecorder/state&quot;&gt; &lt;code&gt;MediaRecorder.state&lt;/code&gt; &lt;/a&gt; 속성은 &quot;recording&quot;값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2bf78d4d77467531848593da2c12d66578716e7f" translate="yes" xml:space="preserve">
          <source>When the Pointer lock state changes&amp;mdash;for example, when calling &lt;a href=&quot;element/requestpointerlock&quot;&gt;&lt;code&gt;requestPointerLock()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;document/exitpointerlock&quot;&gt;&lt;code&gt;exitPointerLock()&lt;/code&gt;&lt;/a&gt;, the user pressing the ESC key, etc.&amp;mdash;the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerlockchange&quot;&gt;pointerlockchange&lt;/a&gt;&lt;/code&gt; event is dispatched to the &lt;code&gt;document&lt;/code&gt;. This is a simple event and contains no extra data.</source>
          <target state="translated">포인터 잠금 상태가 변경되면 (예 : &lt;a href=&quot;element/requestpointerlock&quot;&gt; &lt;code&gt;requestPointerLock()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;document/exitpointerlock&quot;&gt; &lt;code&gt;exitPointerLock()&lt;/code&gt; &lt;/a&gt; 호출 , 사용자가 ESC 키 누르기 등) &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerlockchange&quot;&gt;pointerlockchange&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;code&gt;document&lt;/code&gt; 로 전달됩니다 . 이것은 간단한 이벤트이며 추가 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ea347fd70c4fb3150ede93f0a7797537c904ffe" translate="yes" xml:space="preserve">
          <source>When the Promise returned by &lt;code&gt;getUserMedia()&lt;/code&gt; is resolved, the preview &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-srcobject&quot;&gt;srcobject&lt;/a&gt;&lt;/code&gt; attribute is set to be the input stream, which causes the video being captured by the user's camera to be displayed in the preview box. Since the &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; element is muted, the audio won't play. The &quot;Download&quot; button's link is then set to refer to the stream as well. Then, in line 8, we arrange for &lt;code&gt;preview.captureStream()&lt;/code&gt; to call &lt;code&gt;preview.mozCaptureStream()&lt;/code&gt; so that our code will work on Firefox, on which the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/captureStream&quot;&gt;&lt;code&gt;MediaRecorder.captureStream()&lt;/code&gt;&lt;/a&gt; method is prefixed. Then a new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; which resolves when the preview video starts to play is created and returned.</source>
          <target state="translated">&lt;code&gt;getUserMedia()&lt;/code&gt; 의해 반환 된 Promise 가 해결되면 preview &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-srcobject&quot;&gt;srcobject&lt;/a&gt;&lt;/code&gt; 속성이 입력 스트림으로 설정되어 사용자 카메라가 캡처 한 비디오가 미리보기 상자에 표시됩니다. 이후 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 요소가 음소거되고 오디오가 재생되지 않습니다. 그런 다음 &quot;다운로드&quot;버튼의 링크가 스트림을 참조하도록 설정됩니다. 그런 다음, 8 번, 우리가 준비 &lt;code&gt;preview.captureStream()&lt;/code&gt; 호출 &lt;code&gt;preview.mozCaptureStream()&lt;/code&gt; 우리의 코드가있는 파이어 폭스에서 작동 할 수 있도록 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/captureStream&quot;&gt; &lt;code&gt;MediaRecorder.captureStream()&lt;/code&gt; &lt;/a&gt; 메소드가 앞에 붙습니다. 그런 다음 새로운 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 미리보기 비디오가 재생되기 시작하면 해결되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a615e8d216a008e09a0aaa6303aef7ad3335f0ba" translate="yes" xml:space="preserve">
          <source>When the amount of a target element which is visible within the root element crosses one of the visibility thresholds,</source>
          <target state="translated">루트 요소 내에서 볼 수있는 대상 요소의 양이 가시성 임계 값 중 하나를 초과하면</target>
        </trans-unit>
        <trans-unit id="32d7fed74aa3c9bf9e7b2463d00efc4b82768b3f" translate="yes" xml:space="preserve">
          <source>When the audio is played to the end, it loops, but you can control how long the loops last by altering &lt;code&gt;loopStart&lt;/code&gt; and &lt;code&gt;loopEnd&lt;/code&gt;. For example, if you set their values to 20 and 25, respectively, the audio will start to loop between 20 and 25 seconds in to the track.</source>
          <target state="translated">오디오가 끝까지 재생되면 루프가 반복되지만 &lt;code&gt;loopStart&lt;/code&gt; 및 &lt;code&gt;loopEnd&lt;/code&gt; 를 변경하여 루프 지속 시간을 제어 할 수 있습니다 . 예를 들어, 값을 각각 20과 25로 설정하면 오디오가 트랙에서 20 초와 25 초 사이에서 반복되기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e24b0cc32d22e2488193cf1bd94e74f452949ea5" translate="yes" xml:space="preserve">
          <source>When the audio is played to the end, it loops, but you can control how long the loops last by altering &lt;code&gt;loopStart&lt;/code&gt; and &lt;code&gt;loopEnd&lt;/code&gt;. For example, if you set their values to 20 and 25, respectively, then begin playback, the sound will play normally until it reaches the 25 second mark. Then the current play position will loop back to the 20 second mark and continue playing until the 25 second mark, ad infinitum (or at least until &lt;a href=&quot;../audioscheduledsourcenode/stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; is called).</source>
          <target state="translated">오디오가 끝까지 재생되면 루프가 반복되지만 &lt;code&gt;loopStart&lt;/code&gt; 및 &lt;code&gt;loopEnd&lt;/code&gt; 를 변경하여 루프 지속 시간을 제어 할 수 있습니다 . 예를 들어, 값을 각각 20과 25로 설정 한 다음 재생을 시작하면 25 초 표시에 도달 할 때까지 사운드가 정상적으로 재생됩니다. 그런 다음 현재 재생 위치가 20 초 마크로 되돌아 가고 25 초 마크까지 무한대로 (또는 적어도 &lt;a href=&quot;../audioscheduledsourcenode/stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 이 호출 될 때까지 ) 계속 재생 됩니다.</target>
        </trans-unit>
        <trans-unit id="39d3f50da9c0d82ba411371bee723b13d4be77b5" translate="yes" xml:space="preserve">
          <source>When the available disk space is filled up, the quota manager will start clearing out data based on an LRU policy &amp;mdash; the least recently used origin will be deleted first, then the next one, until the browser is no longer over the limit.</source>
          <target state="translated">사용 가능한 디스크 공간이 가득 차면 할당량 관리자가 LRU 정책에 따라 데이터 지우기를 시작합니다. 브라우저가 더 이상 제한을 초과하지 않을 때까지 가장 최근에 사용한 원본이 먼저 삭제 된 다음 다음 원본이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b279040d65102fcafc743e176713b9b8be7341" translate="yes" xml:space="preserve">
          <source>When the browser adds a new &quot;&lt;code&gt;frame&lt;/code&gt;&quot; entry to the performance timeline, both of the observer callbacks will be invoked.</source>
          <target state="translated">브라우저가 성능 타임 라인에 새 &quot; &lt;code&gt;frame&lt;/code&gt; &quot;항목을 추가하면 두 옵저버 콜백이 모두 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c4cbb2e1cb16505ffea56fb85c6e49a6dda278ae" translate="yes" xml:space="preserve">
          <source>When the browser detects that the target element (in our case, the one with the ID &lt;code&gt;&quot;box&quot;&lt;/code&gt;) has been unveiled or obscured such that its visibility ratio crosses one of the thresholds in our list, it calls our handler function, &lt;code&gt;handleIntersect()&lt;/code&gt;:</source>
          <target state="translated">브라우저가 대상 요소 (이 경우 ID가 &lt;code&gt;&quot;box&quot;&lt;/code&gt; 인 요소 )가 공개되거나 가려져서 가시성 비율이 목록의 임계 값 중 하나를 초과하는 것을 &lt;code&gt;handleIntersect()&lt;/code&gt; 핸들러 함수 handleIntersect ()를 호출합니다. :</target>
        </trans-unit>
        <trans-unit id="8496a9863ad494d02d25096932d5f3577a3b859f" translate="yes" xml:space="preserve">
          <source>When the browser is ready to fetch the document using an HTTP request. This moment is &lt;em&gt;before&lt;/em&gt; the check to any application cache.</source>
          <target state="translated">브라우저가 HTTP 요청을 사용하여 문서를 페치 할 준비가 된 경우 이 순간은 응용 프로그램 캐시를 확인 &lt;em&gt;하기 전&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="350a1fd062dc804995b1031003ef6f2de0f91e04" translate="yes" xml:space="preserve">
          <source>When the browser received the first byte of the response, from the server from a cache, or from a local resource.</source>
          <target state="translated">브라우저가 캐시 또는 로컬 리소스에서 서버로부터 응답의 첫 번째 바이트를 수신 한 경우</target>
        </trans-unit>
        <trans-unit id="105409482e116bc47983c4229d28d9dda32f73db" translate="yes" xml:space="preserve">
          <source>When the browser received the last byte of the response, or when the connection is closed if this happened first, from the server, the cache, or from a local resource.</source>
          <target state="translated">브라우저가 응답의 마지막 바이트를 수신했을 때 또는 서버, 캐시 또는 로컬 자원에서 처음 발생한 경우 연결이 닫힐 때.</target>
        </trans-unit>
        <trans-unit id="50ba4ed179b7791a1be1374a91e79aeb1d381644" translate="yes" xml:space="preserve">
          <source>When the browser sent the request to obtain the actual document, from the server or from a cache. If the transport layer fails after the start of the request and the connection is reopened, this property will be set to the time corresponding to the new request.</source>
          <target state="translated">브라우저가 실제 문서를 얻기위한 요청을 서버 또는 캐시에서 보냈을 때. 요청 시작 후 전송 계층이 실패하고 연결이 다시 열리면이 특성은 새 요청에 해당하는 시간으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="beb363aa3681e984cec0e93d51cec6346c056a16" translate="yes" xml:space="preserve">
          <source>When the browser shuts down (because the user chose the Quit or Exit option), the disk containing the database is removed unexpectedly, or permissions are lost to the database store, the following things happen:</source>
          <target state="translated">사용자가 Quit (종료) 또는 Exit (종료) 옵션을 선택했기 때문에 브라우저가 종료되면 데이터베이스가 포함 된 디스크가 예기치 않게 제거되거나 데이터베이스 저장소에 대한 권한이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="61efc49afc4e840226c8362204bfe6b25d174615" translate="yes" xml:space="preserve">
          <source>When the button is clicked, the oscillator starts, and the &lt;code&gt;MediaRecorder&lt;/code&gt; is started. When the button is stopped, the oscillator and&lt;code&gt; MediaRecorder&lt;/code&gt; both stop. Stopping the &lt;code&gt;MediaRecorder&lt;/code&gt; causes the &lt;code&gt;dataavailable&lt;/code&gt; event to fire, and the event data is pushed into the &lt;code&gt;chunks&lt;/code&gt; array. After that, the &lt;code&gt;stop&lt;/code&gt; event fires, a new &lt;code&gt;blob&lt;/code&gt; is made of type opus &amp;mdash; which contains the data in the &lt;code&gt;chunks&lt;/code&gt; array, and a new window (tab) is then opened that points to a URL created from the blob.</source>
          <target state="translated">버튼을 클릭하면 발진기가 시작되고 &lt;code&gt;MediaRecorder&lt;/code&gt; 가 시작됩니다. 버튼이 중지되면 오실레이터와 &lt;code&gt; MediaRecorder&lt;/code&gt; 가 모두 중지됩니다. 정지 &lt;code&gt;MediaRecorder&lt;/code&gt; 하는 원인 &lt;code&gt;dataavailable&lt;/code&gt; 화재 이벤트, 이벤트 데이터는로 밀려 &lt;code&gt;chunks&lt;/code&gt; 배열. 그런 다음 &lt;code&gt;stop&lt;/code&gt; 이벤트가 발생 하고 &lt;code&gt;chunks&lt;/code&gt; 배열 의 데이터가 포함 된 opus 유형 의 새 &lt;code&gt;blob&lt;/code&gt; 이 만들어 지고 Blob에서 생성 된 URL을 가리키는 새 창 (탭)이 열립니다.</target>
        </trans-unit>
        <trans-unit id="533788242fd866bfaf98a429979be6b6c17e1071" translate="yes" xml:space="preserve">
          <source>When the button is pressed, the current position, orientation, etc. of the sensor/head mounted display is set to be 0 &amp;mdash; this makes the method useful for calibration when an app is first loaded.</source>
          <target state="translated">버튼을 누르면 센서 / 헤드 마운트 디스플레이의 현재 위치, 방향 등이 0으로 설정됩니다. 따라서 앱을 처음로드 할 때이 방법이 보정에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aa3d1042776a40be3f647ebe46e6279e0edfe9dc" translate="yes" xml:space="preserve">
          <source>When the caller's &lt;code&gt;RTCPeerConnection&lt;/code&gt; ICE layer comes up with a new candidate to propose, it issues an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; event to &lt;code&gt;callerPC&lt;/code&gt;. The &lt;code&gt;icecandidate&lt;/code&gt; event handler's job is to transmit the candidate to the receiver. In our example, we are directly controlling both the caller and the receiver, so we can just directly add the candidate to the receiver by calling its &lt;a href=&quot;../rtcpeerconnection/addicecandidate&quot;&gt;&lt;code&gt;addIceCandidate()&lt;/code&gt;&lt;/a&gt; method. That's handled by &lt;code&gt;handleCallerIceEvent()&lt;/code&gt;:</source>
          <target state="translated">발신자의 &lt;code&gt;RTCPeerConnection&lt;/code&gt; ICE 레이어가 제안 할 새로운 후보를 제시하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; 이벤트를 &lt;code&gt;callerPC&lt;/code&gt; 에 발행 합니다. &lt;code&gt;icecandidate&lt;/code&gt; 의 이벤트 핸들러의 역할은 전송에 수신기에 후보입니다. 이 예에서는 호출자와 수신자를 모두 직접 제어하므로 &lt;a href=&quot;../rtcpeerconnection/addicecandidate&quot;&gt; &lt;code&gt;addIceCandidate()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 후보를 수신자에 직접 추가 할 수 있습니다 . &lt;code&gt;handleCallerIceEvent()&lt;/code&gt; 가 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="18d29ea866555b83f31f522311de83636997435a" translate="yes" xml:space="preserve">
          <source>When the calling &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; begins to receive media (after the microphone's stream is added to it), a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; event is delivered to the caller, letting it know that it's time to start negotiating the connection with the receiver. As previously mentioned, our example is simplified somewhat because we control both the caller and the receiver, so &lt;code&gt;handleCallerNegotiationNeeded()&lt;/code&gt; is able to quickly construct the connection by chaining the required calls together for both the caller and receiver, as shown below.</source>
          <target state="translated">호출 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 이 미디어 수신을 시작하면 (마이크 스트림이 추가 된 후) &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/negotiationneeded&quot;&gt;negotiationneeded&lt;/a&gt;&lt;/code&gt; 이벤트가 호출자에게 전달되어 수신자와의 연결 협상을 시작할 시간임을 알려줍니다. 앞에서 언급 한 것처럼 호출자와 수신자를 모두 제어하기 때문에 예제가 다소 단순화되었으므로 &lt;code&gt;handleCallerNegotiationNeeded()&lt;/code&gt; 는 아래 표시된 것처럼 호출자와 수신자 모두에 대해 필요한 호출을 연결하여 신속하게 연결을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8cca7d1c8177e7f4f8aa1998030d5e56bd42c09" translate="yes" xml:space="preserve">
          <source>When the canvas is initialized or &lt;code&gt;beginPath()&lt;/code&gt; is called, you typically will want to use the &lt;code&gt;moveTo()&lt;/code&gt; function to place the starting point somewhere else. We could also use &lt;code&gt;moveTo()&lt;/code&gt; to draw unconnected paths. Take a look at the smiley face below.</source>
          <target state="translated">캔버스가 초기화되거나 &lt;code&gt;beginPath()&lt;/code&gt; 가 호출되면 일반적으로 &lt;code&gt;moveTo()&lt;/code&gt; 함수를 사용하여 시작 지점을 다른 곳에 배치하려고합니다. &lt;code&gt;moveTo()&lt;/code&gt; 를 사용 하여 연결되지 않은 경로를 그릴 수도 있습니다 . 아래의 웃는 얼굴을보십시오.</target>
        </trans-unit>
        <trans-unit id="53eb8eba2a3daab13bf34be7e700aa658187cd56" translate="yes" xml:space="preserve">
          <source>When the connection is opened network. If the transport layer reports an error and the connection establishment is started again, the last connection establishment end time is given. If a persistent connection is used, the value will be the same as &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt;. A connection is considered as opened when all secure connection handshake, or SOCKS authentication, is terminated.</source>
          <target state="translated">연결이 열려있을 때 네트워크. 전송 계층이 오류를보고하고 연결 설정이 다시 시작되면 마지막 연결 설정 종료 시간이 제공됩니다. 지속적 연결이 사용되는 경우 값은 &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt; 와 동일합니다 . 모든 보안 연결 핸드 셰이크 또는 SOCKS 인증이 종료되면 연결이 열린 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="76c9c3d99b351f029d70d5db9fd9568e6eb3a785" translate="yes" xml:space="preserve">
          <source>When the container does not scroll, but has overflowing children, these checks determine if the container can scroll:</source>
          <target state="translated">컨테이너가 스크롤되지 않지만 넘친 자식이있는 경우 이러한 검사는 컨테이너가 스크롤 가능한지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f999374b8edb4032b0a23c52bc5ae64b0f926872" translate="yes" xml:space="preserve">
          <source>When the current port receives a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MIDIMessage&quot;&gt;&lt;code&gt;MIDIMessage&lt;/code&gt;&lt;/a&gt; it triggers a call to this event handler.</source>
          <target state="translated">현재 포트가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MIDIMessage&quot;&gt; &lt;code&gt;MIDIMessage&lt;/code&gt; 를&lt;/a&gt; 수신하면 이 이벤트 핸들러에 대한 호출을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="612eb0282a020d53d02c4e2675af913b08ae504d" translate="yes" xml:space="preserve">
          <source>When the device proximity sensor detects a change between the device and an object, it notifies the browser of that change. When the browser gets such a notification, it fires a &lt;a href=&quot;deviceproximityevent&quot;&gt;&lt;code&gt;DeviceProximityEvent&lt;/code&gt;&lt;/a&gt; for any change, and a &lt;a href=&quot;userproximityevent&quot;&gt;&lt;code&gt;UserProximityEvent&lt;/code&gt;&lt;/a&gt; event in the case of a more rough change.</source>
          <target state="translated">장치 근접 센서는 장치와 물체 사이의 변화를 감지하면 해당 변화를 브라우저에 알립니다. 브라우저가 이러한 알림을 받으면 변경 사항 이있을 때 &lt;a href=&quot;deviceproximityevent&quot;&gt; &lt;code&gt;DeviceProximityEvent&lt;/code&gt; &lt;/a&gt; 가 발생하고 변경 이 더 &lt;a href=&quot;userproximityevent&quot;&gt; &lt;code&gt;UserProximityEvent&lt;/code&gt; &lt;/a&gt; 경우 UserProximityEvent 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6307cceb0ab0826ee9ad7c09c446be851e147976" translate="yes" xml:space="preserve">
          <source>When the dial button is clicked, &lt;code&gt;connectAndDial()&lt;/code&gt; is called. This starts building the WebRTC connection in preparation for sending the DTMF codes.</source>
          <target state="translated">다이얼 버튼을 클릭하면 &lt;code&gt;connectAndDial()&lt;/code&gt; 이 호출됩니다. DTMF 코드 전송 준비에 WebRTC 연결 구축이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f73abc508f8682c32e1f3e323ea5afcdb1d543" translate="yes" xml:space="preserve">
          <source>When the domain lookup is finished. If a persistent connection is used, or the information is stored in a cache or a local resource, the value will be the same as &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt;.</source>
          <target state="translated">도메인 조회가 완료된 경우 지속적 연결이 사용되거나 정보가 캐시 또는 로컬 자원에 저장된 경우 값은 &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6ad592848fdf8928a7eb321d91c7c9a32dae5882" translate="yes" xml:space="preserve">
          <source>When the domain lookup starts. If a persistent connection is used, or the information is stored in a cache or a local resource, the value will be the same as &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt;.</source>
          <target state="translated">도메인 조회가 시작될 때 지속적 연결이 사용되거나 정보가 캐시 또는 로컬 자원에 저장된 경우 값은 &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9ce1a04e3c286d36884562c0642e05dc2a986176" translate="yes" xml:space="preserve">
          <source>When the element does not have a first child, then &lt;code&gt;firstChild&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. The element is still appended to the parent, after the last child. Since the parent element did not have a first child, it did not have a last child either. Consequently, the new element is the only element, after insertion.</source>
          <target state="translated">요소에 첫 번째 자식이 &lt;code&gt;firstChild&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다. 요소는 마지막 자식 이후에도 여전히 부모에 추가됩니다. 부모 요소에는 첫 번째 자식이 없으므로 마지막 자식도 없었습니다. 결과적으로 새로운 요소는 삽입 후 유일한 요소입니다.</target>
        </trans-unit>
        <trans-unit id="8eff7324c9524a5ccfee088b6bad52429f10f081" translate="yes" xml:space="preserve">
          <source>When the first HTTP redirect starts. If there is no redirect, or if one of the redirects is not of the same origin, the value returned is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">첫 번째 HTTP 리디렉션이 시작될 때 리디렉션이 없거나 리디렉션 중 하나의 원점이 동일하지 않은 경우 반환되는 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffba0997651e82706a57373f5ce453c0458a27a8" translate="yes" xml:space="preserve">
          <source>When the following code is used inside a service worker to respond to a push messages by sending the data received via &lt;a href=&quot;../pushmessagedata&quot;&gt;&lt;code&gt;PushMessageData&lt;/code&gt;&lt;/a&gt; to the main context via a &lt;a href=&quot;../channel_messaging_api&quot;&gt;channel message&lt;/a&gt;, the event object of &lt;code&gt;onmessage&lt;/code&gt; will be a &lt;code&gt;ExtendableMessageEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../pushmessagedata&quot;&gt; &lt;code&gt;PushMessageData&lt;/code&gt; &lt;/a&gt; 를 통해 수신 된 데이터를 &lt;a href=&quot;../channel_messaging_api&quot;&gt;채널 메시지&lt;/a&gt; 를 통해 기본 컨텍스트 로 전송하여 푸시 메시지에 응답하기 위해 서비스 워커 내부에서 다음 코드를 사용 하는 경우 &lt;code&gt;onmessage&lt;/code&gt; 의 이벤트 객체 는 &lt;code&gt;ExtendableMessageEvent&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="a84bb2c2165f75feccb7fb59ab1acd531f76be6e" translate="yes" xml:space="preserve">
          <source>When the following code is used inside a service worker to respond to a push messages by sending the data received via &lt;a href=&quot;pushmessagedata&quot;&gt;&lt;code&gt;PushMessageData&lt;/code&gt;&lt;/a&gt; to the main context via a &lt;a href=&quot;channel_messaging_api&quot;&gt;channel message&lt;/a&gt;, the event object of &lt;code&gt;onmessage&lt;/code&gt; will be a &lt;code&gt;ExtendableMessageEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;pushmessagedata&quot;&gt; &lt;code&gt;PushMessageData&lt;/code&gt; &lt;/a&gt; 를 통해 수신 된 데이터를 &lt;a href=&quot;channel_messaging_api&quot;&gt;채널 메시지&lt;/a&gt; 를 통해 기본 컨텍스트 로 전송하여 푸시 메시지에 응답하기 위해 서비스 워커 내부에서 다음 코드를 사용 하는 경우 &lt;code&gt;onmessage&lt;/code&gt; 의 이벤트 객체 는 &lt;code&gt;ExtendableMessageEvent&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f311172178989f9d4dc13b5188cf4041e8ebf5b" translate="yes" xml:space="preserve">
          <source>When the following code is used inside the main thread to set up a message channel between it and a service worker for sending messages between the two, the event object of &lt;code&gt;onmessage&lt;/code&gt; will be a &lt;code&gt;ServiceWorkerMessageEvent&lt;/code&gt;.</source>
          <target state="translated">메인 스레드 내에서 다음 코드를 사용하여 두 코드 사이에 메시지를 보내기 &lt;code&gt;onmessage&lt;/code&gt; 코드와 서비스 워커 사이에 메시지 채널을 설정하면 onmessage 의 이벤트 객체 는 &lt;code&gt;ServiceWorkerMessageEvent&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3bac4700ec5c761184b42bc84aedc27117745e7b" translate="yes" xml:space="preserve">
          <source>When the form is submitted, an event handler is run that puts the entered values into a ScrollToOptions dictionary, and then invokes the &lt;a href=&quot;../window/scrollto&quot;&gt;&lt;code&gt;Window.ScrollTo()&lt;/code&gt;&lt;/a&gt; method, passing the dictionary as a parameter:</source>
          <target state="translated">양식이 제출되면 입력 된 값을 ScrollToOptions 사전에 넣은 다음 이벤트 핸들러가 실행 되어 사전을 매개 변수로 전달하여 &lt;a href=&quot;../window/scrollto&quot;&gt; &lt;code&gt;Window.ScrollTo()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="699cc75134158d3a793326f96977d944bea59451" translate="yes" xml:space="preserve">
          <source>When the form is submitted, an event handler is run that puts the entered values into a ScrollToOptions dictionary, and then invokes the &lt;a href=&quot;window/scrollto&quot;&gt;&lt;code&gt;Window.ScrollTo()&lt;/code&gt;&lt;/a&gt; method, passing the dictionary as a parameter:</source>
          <target state="translated">양식이 제출되면 입력 된 값을 ScrollToOptions 사전에 넣은 다음 이벤트 핸들러가 실행 되어 사전을 매개 변수로 전달하여 &lt;a href=&quot;window/scrollto&quot;&gt; &lt;code&gt;Window.ScrollTo()&lt;/code&gt; &lt;/a&gt; 메소드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="902216d2ce5fc2ca7a98151ccb8cbfac79f84472" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;true&lt;/code&gt;, this prevents the firing of the default event handler.</source>
          <target state="translated">함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 기본 이벤트 처리기가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba06b9cdd699f177726e7f57bcdcd3cd88b9d315" translate="yes" xml:space="preserve">
          <source>When the intial message is received from the main page via the &lt;a href=&quot;../window/postmessage&quot;&gt;&lt;code&gt;window.postMessage&lt;/code&gt;&lt;/a&gt; method, we run the &lt;code&gt;initPort&lt;/code&gt; function. This saves the transfered port and register an onmessage handler that will be called each time a message is passed through our &lt;a href=&quot;../messagechannel&quot;&gt;&lt;code&gt;MessageChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 메시지가 &lt;a href=&quot;../window/postmessage&quot;&gt; &lt;code&gt;window.postMessage&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 초기 메시지를 수신 하면 &lt;code&gt;initPort&lt;/code&gt; 함수를 실행합니다 . 전송 된 포트를 저장하고 메시지가 &lt;a href=&quot;../messagechannel&quot;&gt; &lt;code&gt;MessageChannel&lt;/code&gt; 을&lt;/a&gt; 통과 할 때마다 호출 될 onmessage 핸들러를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="dfa418df41a8e2c804b46c47c170e8d2746bbbba" translate="yes" xml:space="preserve">
          <source>When the key is first depressed, the &lt;code&gt;keydown&lt;/code&gt; event is sent.</source>
          <target state="translated">키가 처음 우울 될 때 &lt;code&gt;keydown&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf05f6fc0519d8976526ddb13344e76d19faee8" translate="yes" xml:space="preserve">
          <source>When the last HTTP redirect is completed, that is when the last byte of the HTTP response has been received. If there is no redirect, or if one of the redirects is not of the same origin, the value returned is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">마지막 HTTP 리디렉션이 완료되면, 즉 HTTP 응답의 마지막 바이트가 수신 된 시점입니다. 리디렉션이 없거나 리디렉션 중 하나의 원점이 동일하지 않은 경우 반환되는 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b57ce896dfd5cd7a4903a914d77303cd695f765" translate="yes" xml:space="preserve">
          <source>When the light sensor of a device detects a change in the light level, it notifies the browser of that change. When the browser gets such a notification, it fires a &lt;a href=&quot;devicelightevent&quot;&gt;&lt;code&gt;DeviceLightEvent&lt;/code&gt;&lt;/a&gt; event that provides information about the exact light intensity (in lux units).</source>
          <target state="translated">장치의 광 센서가 광 레벨의 변화를 감지하면 해당 변경 사항을 브라우저에 알립니다. 브라우저가 이러한 알림을 받으면 정확한 조명 강도 (럭스 단위)에 대한 정보를 제공 하는 &lt;a href=&quot;devicelightevent&quot;&gt; &lt;code&gt;DeviceLightEvent&lt;/code&gt; &lt;/a&gt; 이벤트를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="560082e7dcd947cb29a93eede56e926881ba8fc5" translate="yes" xml:space="preserve">
          <source>When the local peer experiences an open or close event, the &lt;code&gt;handleSendChannelStatusChange()&lt;/code&gt; method is called:</source>
          <target state="translated">로컬 피어에서 열기 또는 닫기 이벤트가 발생하면 &lt;code&gt;handleSendChannelStatusChange()&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="27a889f8a007c01abcb4faf6d63d40c5a15a91a5" translate="yes" xml:space="preserve">
          <source>When the local user clicks the interface widget to disable hold mode, the &lt;code&gt;disableHold()&lt;/code&gt; method is called to begin the process of restoring normal functionality.</source>
          <target state="translated">로컬 사용자가 인터페이스 위젯을 클릭하여 보류 모드를 사용 안함으로 설정하면 &lt;code&gt;disableHold()&lt;/code&gt; 메소드가 호출되어 일반 기능 복원 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ebac40f6a72793796b91bcfc5c8b72b1f2b17b70" translate="yes" xml:space="preserve">
          <source>When the local user decides to enable hold mode, the &lt;code&gt;enableHold()&lt;/code&gt; method below is called. It accepts as input a &lt;a href=&quot;../mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt; containing the audio to play while the call is on hold.</source>
          <target state="translated">로컬 사용자가 보류 모드를 사용하기로 결정하면 아래 의 &lt;code&gt;enableHold()&lt;/code&gt; 메소드가 호출됩니다. 통화 대기 중 재생할 오디오가 포함 된 &lt;a href=&quot;../mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 을 입력으로 받아들 입니다.</target>
        </trans-unit>
        <trans-unit id="d7f09e809f3f680076d45cee843a01c1fe3f673e" translate="yes" xml:space="preserve">
          <source>When the media stream ends, any media data not already delivered to your &lt;code&gt;ondataavailable&lt;/code&gt; handler is passed in a single &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">미디어 스트림이 끝나면 &lt;code&gt;ondataavailable&lt;/code&gt; 핸들러로 아직 전달되지 않은 미디어 데이터 는 단일 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; 에&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="200a112377c2d0da736664ec1a452098ea2f0425" translate="yes" xml:space="preserve">
          <source>When the mode is &lt;code&gt;&quot;showing&quot;&lt;/code&gt;, text tracks are performed differently depending on their &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;. In general:</source>
          <target state="translated">모드가 &lt;code&gt;&quot;showing&quot;&lt;/code&gt; 경우 텍스트 트랙은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; 에 따라 다르게 수행 됩니다. 일반적으로 :</target>
        </trans-unit>
        <trans-unit id="9b66bfe8f53f6ad854aabf7ab0116c143bf98838" translate="yes" xml:space="preserve">
          <source>When the mouse is unlocked, the system cursor can exit and re-enter the browser window. If that happens, &lt;a href=&quot;mouseevent/movementx&quot;&gt;&lt;code&gt;movementX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;mouseevent/movementy&quot;&gt;&lt;code&gt;movementY&lt;/code&gt;&lt;/a&gt; could be set to zero.</source>
          <target state="translated">마우스 잠금이 해제되면 시스템 커서가 브라우저 창을 종료했다가 다시 입력 할 수 있습니다. 이 경우 &lt;a href=&quot;mouseevent/movementx&quot;&gt; &lt;code&gt;movementX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mouseevent/movementy&quot;&gt; &lt;code&gt;movementY&lt;/code&gt; &lt;/a&gt; 를 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f915c69d3f7277d60c1e7e7d9711fc6729338a13" translate="yes" xml:space="preserve">
          <source>When the number of channels doesn't match between an input and an output, up- or down-mixing happens according the following rules. This can be somewhat controlled by setting the &lt;a href=&quot;../audionode/channelinterpretation&quot;&gt;&lt;code&gt;AudioNode.channelInterpretation&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;speakers&lt;/code&gt; or &lt;code&gt;discrete&lt;/code&gt;:</source>
          <target state="translated">채널 수가 입력과 출력간에 일치하지 않으면 다음 규칙에 따라 업 믹스 또는 다운 믹스가 발생합니다. &lt;a href=&quot;../audionode/channelinterpretation&quot;&gt; &lt;code&gt;AudioNode.channelInterpretation&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;speakers&lt;/code&gt; 또는 &lt;code&gt;discrete&lt;/code&gt; 으로 설정하여 다소 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91cf2afc707473bc973d50d6ca2efd4285a74d39" translate="yes" xml:space="preserve">
          <source>When the number of channels doesn't match between an input and an output, up- or down-mixing happens according the following rules. This can be somewhat controlled by setting the &lt;a href=&quot;channelinterpretation&quot;&gt;&lt;code&gt;AudioNode.channelInterpretation&lt;/code&gt;&lt;/a&gt; property to &lt;code&gt;speakers&lt;/code&gt; or &lt;code&gt;discrete&lt;/code&gt;:</source>
          <target state="translated">채널 수가 입력과 출력간에 일치하지 않으면 다음 규칙에 따라 업 믹스 또는 다운 믹스가 발생합니다. &lt;a href=&quot;channelinterpretation&quot;&gt; &lt;code&gt;AudioNode.channelInterpretation&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;speakers&lt;/code&gt; 또는 &lt;code&gt;discrete&lt;/code&gt; 으로 설정하여 다소 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad483e8bf409e425b58e8efd619abdc5050a0c3" translate="yes" xml:space="preserve">
          <source>When the observer (callback) is invoked, the callback's parameters include a &lt;em&gt;&lt;a href=&quot;performanceobserverentrylist&quot;&gt;&lt;code&gt;performance observer entry list&lt;/code&gt;&lt;/a&gt;&lt;/em&gt; that contains only &lt;em&gt;observed&lt;/em&gt;&lt;a href=&quot;performanceentry&quot;&gt;&lt;code&gt;performance entries&lt;/code&gt;&lt;/a&gt;. That is, the list contains entries only for the event types that were specified when the observer's &lt;a href=&quot;performanceobserver/observe&quot;&gt;&lt;code&gt;observe()&lt;/code&gt;&lt;/a&gt; method was invoked. The &lt;a href=&quot;performanceobserverentrylist&quot;&gt;&lt;code&gt;performance observer entry list&lt;/code&gt;&lt;/a&gt; interface has the same three &lt;code&gt;getEntries*()&lt;/code&gt; methods as the &lt;a href=&quot;performance&quot;&gt;&lt;code&gt;Performance&lt;/code&gt;&lt;/a&gt; interface. However, note there is one key difference with these methods; the &lt;a href=&quot;performanceobserverentrylist&quot;&gt;&lt;code&gt;performance observer entry list&lt;/code&gt;&lt;/a&gt; versions are used to retrieve &lt;em&gt;observed&lt;/em&gt; performance entries within the observer callback.</source>
          <target state="translated">관찰자 (콜백)가 호출되면 콜백의 매개 변수에는 &lt;em&gt;관찰 된 &lt;/em&gt;&lt;a href=&quot;performanceentry&quot;&gt; &lt;code&gt;performance entries&lt;/code&gt; &lt;/a&gt; 만 포함하는 &lt;em&gt;&lt;a href=&quot;performanceobserverentrylist&quot;&gt; &lt;code&gt;performance observer entry list&lt;/code&gt; &lt;/a&gt;&lt;/em&gt; 이 포함됩니다 . 즉, 목록에는 관찰자의 &lt;a href=&quot;performanceobserver/observe&quot;&gt; &lt;code&gt;observe()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때 지정된 이벤트 유형에 대한 항목 만 포함 됩니다. &lt;a href=&quot;performanceobserverentrylist&quot;&gt; &lt;code&gt;performance observer entry list&lt;/code&gt; &lt;/a&gt; 인터페이스는 같은 세 가지가 &lt;code&gt;getEntries*()&lt;/code&gt; 는 AS 방법 &lt;a href=&quot;performance&quot;&gt; &lt;code&gt;Performance&lt;/code&gt; &lt;/a&gt; 인터페이스를. 그러나 이러한 방법에는 한 가지 중요한 차이점이 있습니다. &lt;a href=&quot;performanceobserverentrylist&quot;&gt; &lt;code&gt;performance observer entry list&lt;/code&gt; &lt;/a&gt; 버전은 검색하는 데 사용되는 &lt;em&gt;관찰&lt;/em&gt; 관찰자 콜백 내에서 성능 항목을.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7175f21e5a2e17845e87b2f7b83e601c87827619" translate="yes" xml:space="preserve">
          <source>When the offer arrives, the callee's &lt;code&gt;handleVideoOfferMsg()&lt;/code&gt; function is called with the &lt;code&gt;&quot;video-offer&quot;&lt;/code&gt; message that was received. This function needs to do two things. First, it needs to create its own &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; and add the tracks containing the audio and video from its microphone and webcam to that. Second, it needs to process the received offer, constructing and sending its answer.</source>
          <target state="translated">오퍼가 도착하면 수신자의 &lt;code&gt;handleVideoOfferMsg()&lt;/code&gt; 함수가 수신 된 &lt;code&gt;&quot;video-offer&quot;&lt;/code&gt; 메시지 와 함께 호출됩니다 . 이 기능은 두 가지 작업을 수행해야합니다. 먼저 자체 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 을 만들고 마이크와 웹캠의 오디오 및 비디오가 포함 된 트랙을 여기에 추가해야합니다. 둘째, 수신 한 제안을 처리하고 답변을 구성하고 발송해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0bec275fd0f6273c0d0acf797afd767ae95035d" translate="yes" xml:space="preserve">
          <source>When the opened database doesn't exist yet, the value of &lt;code&gt;oldVersion&lt;/code&gt; is 0.</source>
          <target state="translated">열린 데이터베이스가 아직 없으면 &lt;code&gt;oldVersion&lt;/code&gt; 값 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ee5c225e0694b3df91bd7af04aec1826c22c80d2" translate="yes" xml:space="preserve">
          <source>When the page content finishes loading (e.g. on &lt;code&gt;DOMContentLoaded&lt;/code&gt;).</source>
          <target state="translated">페이지 컨텐츠로드가 완료되면 (예 : &lt;code&gt;DOMContentLoaded&lt;/code&gt; 에서 ).</target>
        </trans-unit>
        <trans-unit id="8e922759a0f9be599e7731ead610cb8c60760586" translate="yes" xml:space="preserve">
          <source>When the page is loaded, this code is run to set up an event listener to watch for the</source>
          <target state="translated">페이지가로드되면이 코드가 실행되어 이벤트 리스너를 설정하여</target>
        </trans-unit>
        <trans-unit id="14f06ff227348a175a5ecda369bb2dfb11462ebf" translate="yes" xml:space="preserve">
          <source>When the page loads, the &lt;code&gt;startup()&lt;/code&gt; function shown below should be called by our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/a&gt; element's &lt;code&gt;onload&lt;/code&gt; attribute (but in the example we use a button to trigger it, due to limitations of the MDN live example system).</source>
          <target state="translated">페이지가로드 될 때 아래에 표시된 &lt;code&gt;startup()&lt;/code&gt; 함수는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt; &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 &lt;code&gt;onload&lt;/code&gt; 속성에 의해 호출되어야 합니다 (하지만이 예에서는 MDN 라이브 예제 시스템의 제한으로 인해 버튼을 사용하여 페이지를 트리거 함).</target>
        </trans-unit>
        <trans-unit id="f8d059be663cdcd4a12850cd2f6a0c99689b6fdf" translate="yes" xml:space="preserve">
          <source>When the page loads, this code runs to set up and run the example:</source>
          <target state="translated">페이지가로드되면이 코드가 실행되어 예제를 설정하고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8986747220e0569aa52b83a6cd262503f62f9870" translate="yes" xml:space="preserve">
          <source>When the page loads, we do some basic setup: we fetch references to the dial button and the log output box elements, and we use &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt;&lt;code&gt;addEventListener()&lt;/code&gt;&lt;/a&gt; to add an event listener to the dial button so that clicking it calls the &lt;code&gt;connectAndDial()&lt;/code&gt; function to begin the connection process.</source>
          <target state="translated">페이지가로드되면 몇 가지 기본 설정을 수행합니다. 다이얼 버튼과 로그 출력 상자 요소에 대한 참조를 가져오고 &lt;a href=&quot;../eventtarget/addeventlistener&quot;&gt; &lt;code&gt;addEventListener()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이벤트 리스너를 다이얼 버튼에 추가하여 클릭하면 &lt;code&gt;connectAndDial()&lt;/code&gt; 함수를 호출합니다. 연결 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="839549cedee1215fb2d0d740f0fd133bdc03411a" translate="yes" xml:space="preserve">
          <source>When the parameter's value finishes following the curve, its value is guaranteed to match the last value in the set of values specified in the &lt;code&gt;values&lt;/code&gt; parameter.</source>
          <target state="translated">매개 변수 값이 곡선을 따라 완료되면 해당 값은 &lt;code&gt;values&lt;/code&gt; 매개 변수에 지정된 값 세트의 마지막 값과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3134eb9034ba0688c09d8933a0459e0314d97425" translate="yes" xml:space="preserve">
          <source>When the parser finished its work on the main document, that is when its &lt;a href=&quot;document/readystate&quot;&gt;&lt;code&gt;Document.readyState&lt;/code&gt;&lt;/a&gt; changes to &lt;code&gt;'complete'&lt;/code&gt; and the corresponding &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; event is thrown.</source>
          <target state="translated">파서가 주 문서에 대한 작업을 마치면, 즉 &lt;a href=&quot;document/readystate&quot;&gt; &lt;code&gt;Document.readyState&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'complete'&lt;/code&gt; 로 변경되고 해당 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f808803da015941c4bf2374be53dabc0ea78103f" translate="yes" xml:space="preserve">
          <source>When the parser finished its work on the main document, that is when its &lt;a href=&quot;document/readystate&quot;&gt;&lt;code&gt;Document.readyState&lt;/code&gt;&lt;/a&gt; changes to &lt;code&gt;'interactive'&lt;/code&gt; and the corresponding &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; event is thrown.</source>
          <target state="translated">파서가 주 문서에 대한 작업을 마치면, 즉 &lt;a href=&quot;document/readystate&quot;&gt; &lt;code&gt;Document.readyState&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'interactive'&lt;/code&gt; 로 변경되고 해당 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dbb3c5d76fb79c825556e2cee9e32a2b42390e41" translate="yes" xml:space="preserve">
          <source>When the parser started its work, that is when its &lt;a href=&quot;document/readystate&quot;&gt;&lt;code&gt;Document.readyState&lt;/code&gt;&lt;/a&gt; changes to &lt;code&gt;'loading'&lt;/code&gt; and the corresponding &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; event is thrown.</source>
          <target state="translated">파서가 작업을 시작했을 때, 즉 &lt;a href=&quot;document/readystate&quot;&gt; &lt;code&gt;Document.readyState&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'loading'&lt;/code&gt; 으로 변경되고 해당 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생 하는 시점 입니다.</target>
        </trans-unit>
        <trans-unit id="21ee0794ad950a44e9f58b2c0a55f4df23b09dd1" translate="yes" xml:space="preserve">
          <source>When the port is started, both scripts post messages to the worker and handle messages sent from it using &lt;code&gt;port.postMessage()&lt;/code&gt; and &lt;code&gt;port.onmessage&lt;/code&gt;, respectively:</source>
          <target state="translated">포트가 시작되면 두 스크립트는 모두 작업자에게 메시지를 게시 하고 각각 &lt;code&gt;port.postMessage()&lt;/code&gt; 및 &lt;code&gt;port.onmessage&lt;/code&gt; 를 사용하여 보낸 메시지를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="88d47ec674ecb886615c0be510f12c1e0ec92e38" translate="yes" xml:space="preserve">
          <source>When the preview video begins to play, we know there's media to record, so we respond by calling the &lt;code&gt;&lt;a href=&quot;#Starting_media_recording&quot;&gt;startRecording()&lt;/a&gt;&lt;/code&gt; function we created earlier, passing in the preview video stream (as the source media to be recorded) and &lt;code&gt;recordingTimeMS&lt;/code&gt; as the number of milliseconds of media to record. As mentioned before, &lt;code&gt;startRecording()&lt;/code&gt; returns a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; whose resolution handler is called (receiving as input an array of &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; objects containing the chunks of recorded media data) once recording has completed.</source>
          <target state="translated">미리보기 비디오가 재생되기 시작하면 기록 할 미디어가 있다는 것을 알기 때문에 앞에서 만든 &lt;code&gt;&lt;a href=&quot;#Starting_media_recording&quot;&gt;startRecording()&lt;/a&gt;&lt;/code&gt; 함수 를 호출 하여 미리보기 비디오 스트림 (기록 할 소스 미디어로)과 &lt;code&gt;recordingTimeMS&lt;/code&gt; 를 기록 할 미디어 (밀리 초)입니다. 앞에서 언급했듯이 &lt;code&gt;startRecording()&lt;/code&gt; 은 일단 기록이 완료되면 해상도 핸들러가 호출 된 ( 기록 된 미디어 데이터 청크를 포함하는 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 객체 의 배열을 입력으로 수신) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d28c7be1ba200f05c9f79e1058a1e236de27ea78" translate="yes" xml:space="preserve">
          <source>When the problem is reported, the user agent may focus the element and change the scrolling position of the document or perform some other action that brings the element to the user's attention. User agents may report more than one constraint violation if this element suffers from multiple problems at once. If the element is not rendered, then the user agent may report the error for the running script instead of notifying the user.</source>
          <target state="translated">문제가보고되면 사용자 에이전트는 요소의 초점을 맞추고 문서의 스크롤 위치를 변경하거나 요소를 사용자의주의를 끌 수있는 다른 작업을 수행 할 수 있습니다. 이 요소에 여러 문제가 동시에 발생하면 사용자 에이전트는 둘 이상의 제약 조건 위반을보고 할 수 있습니다. 요소가 렌더링되지 않으면 사용자 에이전트는 사용자에게 알리지 않고 실행중인 스크립트에 대한 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd399f4e43d1fbff3051d2f3cc9db341694f374e" translate="yes" xml:space="preserve">
          <source>When the promise is fulfilled, the fulfillment handler receives a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">약속이 이행되면 이행 핸들러는 &lt;code&gt;undefined&lt;/code&gt; 값을받습니다 .</target>
        </trans-unit>
        <trans-unit id="1a97df6b10a130f07c83f20a008316d901cdbda8" translate="yes" xml:space="preserve">
          <source>When the prompt for unload terminates on the previous document in the same browsing context. If there is no previous document, this value will be the same as &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt;.</source>
          <target state="translated">언로드 프롬프트가 동일한 찾아보기 컨텍스트에서 이전 문서에서 종료되는 경우 이전 문서가없는 경우이 값은 &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="adad6cb70dcae1a052aa53cd9c1eeeba06043a37" translate="yes" xml:space="preserve">
          <source>When the receiver begins to receive media, an event is delivered to the receiver's &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;receiverPC&lt;/code&gt;. As explained in &lt;a href=&quot;#Starting_the_connection_process&quot;&gt;Starting the connection process&lt;/a&gt;, the current WebRTC specification uses the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/track&quot;&gt;track&lt;/a&gt;&lt;/code&gt; event for this, but some browsers haven't been updated to support this yet, so we also need to handle the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addstream&quot;&gt;addstream&lt;/a&gt;&lt;/code&gt; event. The &lt;code&gt;handleReceiverTrackEvent()&lt;/code&gt; and &lt;code&gt;handleReceiverAddStreamEvent()&lt;/code&gt; methods, shown below, handle these.</source>
          <target state="translated">수신자가 매체를 수신하기 시작하면 이벤트가 수신자의 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;receiverPC&lt;/code&gt; 로 전달됩니다 . &lt;a href=&quot;#Starting_the_connection_process&quot;&gt;연결 프로세스 시작에&lt;/a&gt; 설명 된대로 현재 WebRTC 스펙은이를 위해 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/track&quot;&gt;track&lt;/a&gt;&lt;/code&gt; 이벤트를 사용 하지만 일부 브라우저는 아직이를 지원하도록 업데이트되지 않았으므로 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/addstream&quot;&gt;addstream&lt;/a&gt;&lt;/code&gt; 이벤트도 처리해야합니다 . 아래에 표시된 &lt;code&gt;handleReceiverTrackEvent()&lt;/code&gt; 및 &lt;code&gt;handleReceiverAddStreamEvent()&lt;/code&gt; 메소드가 이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="537c5b67511ced3deaf928994ad8df896145f723" translate="yes" xml:space="preserve">
          <source>When the receiver's &lt;code&gt;RTCPeerConnection&lt;/code&gt; ICE layer comes up with a new candidate to propose, it issues an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; event to &lt;code&gt;receiverPC&lt;/code&gt;. The &lt;code&gt;icecandidate&lt;/code&gt; event handler's job is to transmit the candidate to the caller. In our example, we are directly controlling both the caller and the receiver, so we can just directly add the candidate to the caller by calling its &lt;a href=&quot;../rtcpeerconnection/addicecandidate&quot;&gt;&lt;code&gt;addIceCandidate()&lt;/code&gt;&lt;/a&gt; method. That's handled by &lt;code&gt;handleReceiverIceEvent()&lt;/code&gt;.</source>
          <target state="translated">수신기의 경우 &lt;code&gt;RTCPeerConnection&lt;/code&gt; 의 얼음 층이 제안하는 새로운 후보와 함께 제공, 그것은 문제 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/icecandidate&quot;&gt;icecandidate&lt;/a&gt;&lt;/code&gt; 의 에 이벤트 &lt;code&gt;receiverPC&lt;/code&gt; 을 . &lt;code&gt;icecandidate&lt;/code&gt; 의 이벤트 핸들러의 역할은 전송에 호출자에게 후보입니다. 이 예에서는 호출자와 수신자를 모두 직접 제어하므로 &lt;a href=&quot;../rtcpeerconnection/addicecandidate&quot;&gt; &lt;code&gt;addIceCandidate()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 후보를 호출자에 직접 추가 할 수 있습니다 . 이것은 &lt;code&gt;handleReceiverIceEvent()&lt;/code&gt; 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e08a7dedbb40b64e048a6926edb37c0ec6a93f0" translate="yes" xml:space="preserve">
          <source>When the request to open a connection is sent to the network. If the transport layer reports an error and the connection establishment is started again, the last connection establishment start time is given. If a persistent connection is used, the value will be the same as &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt;.</source>
          <target state="translated">연결 열기 요청이 네트워크로 전송 될 때 전송 계층이 오류를보고하고 연결 설정이 다시 시작되면 마지막 연결 설정 시작 시간이 제공됩니다. 지속적 연결이 사용되는 경우 값은 &lt;code&gt;PerformanceTiming.fetchStart&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6330942dde22ea4f2ab3c7b78ab71f7dcc0e416d" translate="yes" xml:space="preserve">
          <source>When the sample is ready to play, the program sets up the UI so it is ready to go.</source>
          <target state="translated">샘플을 재생할 준비가되면 프로그램은 UI를 설정하여 바로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd95af1279863fef4276b2646716dcbc0614ae30" translate="yes" xml:space="preserve">
          <source>When the scissor test is enabled, only pixels within the scissor box can be modified by drawing commands.</source>
          <target state="translated">가위 테스트가 활성화되면 가위 상자 내의 픽셀 만 드로잉 명령으로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03fc356dce5942faad0d83681aaba03d171f758a" translate="yes" xml:space="preserve">
          <source>When the script is run, we set up an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; event listener, so that once the page is fully loaded, our &lt;code&gt;startup()&lt;/code&gt; function is called.</source>
          <target state="translated">스크립트가 실행될 때 페이지가 완전히로드되면 &lt;code&gt;startup()&lt;/code&gt; 함수가 호출 되도록 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/load&quot;&gt;load&lt;/a&gt;&lt;/code&gt; 이벤트 리스너를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b0a37825790ba0caa1e8e247362ba97814c0ef39" translate="yes" xml:space="preserve">
          <source>When the second &lt;code&gt;restore()&lt;/code&gt; statement is called, the original state (the one we set up before the first call to &lt;code&gt;save&lt;/code&gt;) is restored and the last rectangle is once again drawn in black.</source>
          <target state="translated">두 번째 &lt;code&gt;restore()&lt;/code&gt; 문이 호출되면 원래 상태 ( &lt;code&gt;save&lt;/code&gt; 하기 위해 첫 번째 호출 전에 설정 한 상태 )가 복원되고 마지막 사각형이 다시 한 번 검은 색으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="fc7bf41b6462d43688e17f92d02accf760e77236" translate="yes" xml:space="preserve">
          <source>When the secure connection handshake starts. If no such connection is requested, it returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">보안 연결 핸드 셰이크가 시작될 때 이러한 연결이 요청되지 않으면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="33155266d0c1586320b9d2840caac0f2b71eeadf" translate="yes" xml:space="preserve">
          <source>When the shift key is pressed, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event is first fired, and the &lt;code&gt;key&lt;/code&gt; property value is set to be the string &lt;code&gt;&quot;Shift&quot;&lt;/code&gt;. As we keep holding this key, the keydown event does not continue to fire repeatedly because it produced no character key.</source>
          <target state="translated">Shift 키를 누르면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트가 먼저 시작되고 &lt;code&gt;key&lt;/code&gt; 속성 값이 문자열 &lt;code&gt;&quot;Shift&quot;&lt;/code&gt; 로 설정 됩니다. 이 키를 계속 누르고 있으면 키 다운 이벤트는 문자 키가 생성되지 않아 계속 반복적으로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c33925f313b9963274b88c6fe522b5dbd1c593f0" translate="yes" xml:space="preserve">
          <source>When the shift key is pressed, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event is first fired, and the &lt;code&gt;key&lt;/code&gt; property value is set to the string &lt;code&gt;&quot;Shift&quot;&lt;/code&gt;. As we keep holding this key, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; event does not continue to fire repeatedly because it does not produce a character key.</source>
          <target state="translated">Shift 키를 누르면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트가 먼저 시작되고 &lt;code&gt;key&lt;/code&gt; 속성 값이 &lt;code&gt;&quot;Shift&quot;&lt;/code&gt; 문자열로 설정됩니다 . 우리가이 키를 계속 누르고으로, &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/keydown&quot;&gt;keydown&lt;/a&gt;&lt;/code&gt; 이벤트는 문자 키를 생성하지 않기 때문에 반복적으로 불을 계속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edb11773ee8c2aacfc99893b3087a6f719b5dae2" translate="yes" xml:space="preserve">
          <source>When the source stream ends, &lt;code&gt;state&lt;/code&gt; is set to &lt;code&gt;&quot;inactive&quot;&lt;/code&gt; and data gathering stops. A final &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dataavailable&quot;&gt;dataavailable&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;code&gt;MediaRecorder&lt;/code&gt;, followed by a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; event.</source>
          <target state="translated">소스 스트림이 종료되면 &lt;code&gt;state&lt;/code&gt; 가 &lt;code&gt;&quot;inactive&quot;&lt;/code&gt; 설정 되고 데이터 수집이 중지됩니다. 최종 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dataavailable&quot;&gt;dataavailable&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;code&gt;MediaRecorder&lt;/code&gt; 로 전송 된 후 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/stop&quot;&gt;stop&lt;/a&gt;&lt;/code&gt; 이벤트가 이어집니다 .</target>
        </trans-unit>
        <trans-unit id="6feee11ede65732d796f8f44eec1bdd622f546c7" translate="yes" xml:space="preserve">
          <source>When the stream is done (&lt;code&gt;if (done)&lt;/code&gt;), we run &lt;code&gt;reader.cancel()&lt;/code&gt; to cancel the stream, signalling that we don't need to use it any more.</source>
          <target state="translated">스트림이 완료되면 ( &lt;code&gt;if (done)&lt;/code&gt; ), &lt;code&gt;reader.cancel()&lt;/code&gt; 을 실행 하여 스트림을 취소하고 더 ​​이상 사용할 필요가 없다는 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c9605836e46f30a630e4532dbbfb1b2329dc5df4" translate="yes" xml:space="preserve">
          <source>When the stream is obtained, it's attached to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element so that it's visible on screen, and we grab the audio track and video track into the variables &lt;code&gt;audioTrack&lt;/code&gt; and &lt;code&gt;videoTrack&lt;/code&gt;.</source>
          <target state="translated">스트림을 가져 오면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 연결되어 화면에 표시되며 오디오 트랙 및 비디오 트랙을 &lt;code&gt;audioTrack&lt;/code&gt; 및 &lt;code&gt;videoTrack&lt;/code&gt; 변수로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="44380c5f983cc0aa64cc8e5f12f59ade351d3e24" translate="yes" xml:space="preserve">
          <source>When the user begins a drag by clicking and dragging from the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/vbox&quot;&gt;vbox&lt;/a&gt;&lt;/code&gt; above, the &lt;code&gt;startDrag()&lt;/code&gt; function below is called.</source>
          <target state="translated">사용자가 위 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/vbox&quot;&gt;vbox&lt;/a&gt;&lt;/code&gt; 에서 클릭하고 드래그하여 드래그를 시작하면 아래 의 &lt;code&gt;startDrag()&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a727dd034a906afe61a84778788e2557337f530d" translate="yes" xml:space="preserve">
          <source>When the user clicks on a username they want to call, the &lt;code&gt;invite()&lt;/code&gt; function is invoked as the event handler for that &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; event:</source>
          <target state="translated">사용자가 호출하려는 사용자 이름을 클릭하면 &lt;code&gt;invite()&lt;/code&gt; 함수가 해당 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; 이벤트 의 이벤트 핸들러로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a9cb607dc7ab7c1e6a20774f9edcd5040f0b611" translate="yes" xml:space="preserve">
          <source>When the user clicks the &quot;Connect&quot; button, the &lt;code&gt;connectPeers()&lt;/code&gt; method is called. We're going to break this up and look at it a bit at a time, for clarity.</source>
          <target state="translated">사용자가 &quot;연결&quot;버튼을 클릭하면 &lt;code&gt;connectPeers()&lt;/code&gt; 메소드가 호출됩니다. 명확성을 위해이 부분을 나누고 한 번에 조금 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6cf9ab1ead49e14d7101b88104637155345dba0b" translate="yes" xml:space="preserve">
          <source>When the user clicks the &quot;Disconnect&quot; button, the &lt;code&gt;disconnectPeers()&lt;/code&gt; method previously set as that button's handler is called.</source>
          <target state="translated">사용자가 &quot;연결 끊기&quot;단추를 클릭하면 이전에 해당 단추의 처리기로 설정된 &lt;code&gt;disconnectPeers()&lt;/code&gt; 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="38f71e84f14303251b25fa9bc7c263c60c6e12ea" translate="yes" xml:space="preserve">
          <source>When the user clicks the &quot;Hang Up&quot; button to end the call, the &lt;code&gt;hangUpCall()&lt;/code&gt; function is called:</source>
          <target state="translated">사용자가 &quot;전화 끊기&quot;버튼을 클릭하여 호출을 종료하면 &lt;code&gt;hangUpCall()&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a0560da4e829067e55910d706beed3eb7c32acaf" translate="yes" xml:space="preserve">
          <source>When the user clicks the OK button, text entered in the input field is returned. If the user clicks OK without entering any text, an empty string is returned. If the user clicks the Cancel button, this function returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">사용자가 확인 버튼을 클릭하면 입력 필드에 입력 한 텍스트가 반환됩니다. 사용자가 텍스트를 입력하지 않고 확인을 클릭하면 빈 문자열이 반환됩니다. 사용자가 취소 버튼을 클릭하면이 함수는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0da7af71e9afccd4774acf1db4d7f301071f054e" translate="yes" xml:space="preserve">
          <source>When the user clicks the play/pause toggle button while the oscillators aren't playing, the &lt;code&gt;startOscillators()&lt;/code&gt; function gets called.</source>
          <target state="translated">오실레이터가 재생되지 않는 동안 사용자가 재생 / 일시 정지 토글 버튼을 클릭하면 &lt;code&gt;startOscillators()&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="85a5b4ec0d907d93592cb3b8ce597a8b5f7e9392" translate="yes" xml:space="preserve">
          <source>When the user lifts a finger off the surface, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerup&quot;&gt;pointerup&lt;/a&gt;&lt;/code&gt; event is sent. We handle this event by calling the &lt;code&gt;handleEnd()&lt;/code&gt; function below. Its job is to draw the last line segment for the touch that ended and remove the touch point from the ongoing touch list.</source>
          <target state="translated">사용자가 표면에서 손가락을 떼면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerup&quot;&gt;pointerup&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다. 아래 &lt;code&gt;handleEnd()&lt;/code&gt; 함수 를 호출하여이 이벤트를 처리 합니다. 그 작업은 종료 된 터치에 대한 마지막 선분을 그리고 진행중인 터치리스트에서 터치 포인트를 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6dbd3f962c7dae65fbc32df1e5d887467a22b95e" translate="yes" xml:space="preserve">
          <source>When the user lifts a finger off the surface, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchend&quot;&gt;touchend&lt;/a&gt;&lt;/code&gt; event is sent. We handle this by calling the &lt;code&gt;handleEnd()&lt;/code&gt; function below. Its job is to draw the last line segment for each touch that ended and remove the touch point from the ongoing touch list.</source>
          <target state="translated">사용자가 손가락을 표면에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/touchend&quot;&gt;touchend&lt;/a&gt;&lt;/code&gt; 이벤트가 전송됩니다. 아래 &lt;code&gt;handleEnd()&lt;/code&gt; 함수 를 호출하여 이를 처리 합니다. 그 작업은 종료 된 각 터치마다 마지막 선 세그먼트를 그리고 진행중인 터치리스트에서 터치 포인트를 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71d928d3e6a835e3c077144d6aedf206b3dd2962" translate="yes" xml:space="preserve">
          <source>When the user minimizes the window or switches to another tab, the API sends a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange&quot;&gt;visibilitychange&lt;/a&gt;&lt;/code&gt; event to let listeners know the state of the page has changed. You can detect the event and perform some actions or behave differently. For example, if your web app is playing a video, it can pause the video when the user puts the tab into the background, and resume playback when the user returns to the tab. The user doesn't lose their place in the video, the video's soundtrack doesn't interfere with audio in the new foreground tab, and the user doesn't miss any of the video in the meantime.</source>
          <target state="translated">사용자가 창을 최소화하거나 다른 탭으로 전환하면 API는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange&quot;&gt;visibilitychange&lt;/a&gt;&lt;/code&gt; 이벤트를 보내 청취자에게 페이지 상태가 변경되었음을 알립니다. 이벤트를 감지하고 일부 조치를 수행하거나 다르게 작동 할 수 있습니다. 예를 들어, 웹 앱에서 비디오를 재생하는 경우 사용자가 탭을 배경에 놓으면 비디오가 일시 중지되고 사용자가 탭으로 돌아 오면 재생을 다시 시작할 수 있습니다. 사용자가 비디오에서 자리를 잃지 않고 비디오의 사운드 트랙이 새로운 전경 탭의 오디오를 방해하지 않으며 그 동안 사용자는 비디오를 놓치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9767aacd80e0e11093c6182eb78d14ae45fcb58" translate="yes" xml:space="preserve">
          <source>When the user presses the &quot;Send&quot; button, the sendMessage() method we've established as the handler for the button's &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; event is called. That method is simple enough:</source>
          <target state="translated">사용자가 &quot;Send&quot;버튼을 누르면 버튼의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; 이벤트 처리기로 설정 한 sendMessage () 메서드 가 호출됩니다. 그 방법은 충분히 간단합니다.</target>
        </trans-unit>
        <trans-unit id="691a84eb7e0015fcfba268cd3a31b2d0b4a6aad7" translate="yes" xml:space="preserve">
          <source>When the user releases the key, the &lt;code&gt;keyup&lt;/code&gt; event is sent.</source>
          <target state="translated">사용자가 키를 &lt;code&gt;keyup&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="046dc1872cb2544b6c632950577d726593ff414e" translate="yes" xml:space="preserve">
          <source>When the user releases the mouse, the drag and drop operation ends. If the mouse was released over an element that is a valid drop target, that is, one that cancelled the last &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragenter&quot;&gt;dragenter&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; or &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragover&quot;&gt;dragover&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; event, and then the drop will be successful, and a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; event will fire at the target. Otherwise, the drag operation is cancelled, and no &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; event is fired.</source>
          <target state="translated">사용자가 마우스를 놓으면 드래그 앤 드롭 작업이 종료됩니다. 마우스가 유효한 놓기 대상인 요소, 즉 마지막 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragenter&quot;&gt;dragenter&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragover&quot;&gt;dragover&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이벤트 를 취소 한 요소 위에 놓인 경우 놓기가 성공하고 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이벤트가 대상에서 시작됩니다. 그렇지 않으면 드래그 작업이 취소되고 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이벤트가 발생 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="90cd70947355aae5353dbe81d9dacd074974261d" translate="yes" xml:space="preserve">
          <source>When the user selects a file, the &lt;code&gt;handleFiles()&lt;/code&gt; function gets called with a &lt;a href=&quot;../filelist&quot;&gt;&lt;code&gt;FileList&lt;/code&gt;&lt;/a&gt; object containing &lt;a href=&quot;../file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; objects representing the files selected by the user.</source>
          <target state="translated">사용자가 파일을 선택하면 &lt;code&gt;handleFiles()&lt;/code&gt; 함수가 사용자가 선택한 파일을 나타내는 &lt;a href=&quot;../file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 객체를 포함 하는 &lt;a href=&quot;../filelist&quot;&gt; &lt;code&gt;FileList&lt;/code&gt; &lt;/a&gt; 객체 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8204c07806596cca627eedd95b13c66cb1a8f3e1" translate="yes" xml:space="preserve">
          <source>When the value of this property changes a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; event fires on the &lt;a href=&quot;../document&quot;&gt;&lt;code&gt;document&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이 속성 값이 변경되면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange&quot;&gt;readystatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;a href=&quot;../document&quot;&gt; &lt;code&gt;document&lt;/code&gt; &lt;/a&gt; 객체 에서 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="23287c04cee6187c8575338ae4ce1445f08cebdf" translate="yes" xml:space="preserve">
          <source>When the value of this property changes, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange&quot;&gt;visibilitychange&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;a href=&quot;../document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성의 값이 변경되면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange&quot;&gt;visibilitychange&lt;/a&gt;&lt;/code&gt; 변경 이벤트가 &lt;a href=&quot;../document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="4aabbed96dc4375bad394b2d3431585bafa5eb9e" translate="yes" xml:space="preserve">
          <source>When the visibility of the specified element crosses over one of the observer's visibility thresholds (as listed in &lt;a href=&quot;thresholds&quot;&gt;&lt;code&gt;IntersectionObserver.thresholds&lt;/code&gt;&lt;/a&gt;, the observer's callback is executed with an &lt;a href=&quot;../intersectionobserverentry&quot;&gt;&lt;code&gt;IntersectionObserverEntry&lt;/code&gt;&lt;/a&gt; representing the intersection change which occurred. Note that this design allows multiple elements' intersection changes to be processed by a single call to the callback using an array of &lt;code&gt;IntersectionObserverEntry&lt;/code&gt; objects.</source>
          <target state="translated">나열된 바와 같이 관찰자의 시야 임계 값 중 하나 (이상 지정된 요소 십자가의 공개시 &lt;a href=&quot;thresholds&quot;&gt; &lt;code&gt;IntersectionObserver.thresholds&lt;/code&gt; 은&lt;/a&gt; , 관찰자의 콜백가 함께 실행 &lt;a href=&quot;../intersectionobserverentry&quot;&gt; &lt;code&gt;IntersectionObserverEntry&lt;/code&gt; 이&lt;/a&gt; 교차 변화를 나타내는 발생한다. 이러한 설계는 여러 요소의 교점으로 변경 허용 참고 &lt;code&gt;IntersectionObserverEntry&lt;/code&gt; 객체 의 배열을 사용하여 콜백에 대한 단일 호출로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="d2941bdb6d2957bace5c69002a5658260596873c" translate="yes" xml:space="preserve">
          <source>When there is an error caused by calling &lt;a href=&quot;element/requestpointerlock&quot;&gt;&lt;code&gt;requestPointerLock()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;document/exitpointerlock&quot;&gt;&lt;code&gt;exitPointerLock()&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerlockerror&quot;&gt;pointerlockerror&lt;/a&gt;&lt;/code&gt; event is dispatched to the &lt;code&gt;document&lt;/code&gt;. This is a simple event and contains no extra data.</source>
          <target state="translated">전화에 의한 오류가있는 경우 &lt;a href=&quot;element/requestpointerlock&quot;&gt; &lt;code&gt;requestPointerLock()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;document/exitpointerlock&quot;&gt; &lt;code&gt;exitPointerLock()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/pointerlockerror&quot;&gt;pointerlockerror&lt;/a&gt;&lt;/code&gt; 의 이벤트가 파견되는 &lt;code&gt;document&lt;/code&gt; . 이것은 간단한 이벤트이며 추가 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="33c0c76361bf9f839d684610f50b7454c7d59ae1" translate="yes" xml:space="preserve">
          <source>When there is no selection, the active element is the page's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">선택이 없으면 활성 요소는 페이지의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body&quot;&gt; &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="939ca88904b6a1bf7a85b5630413d3f6b194d620" translate="yes" xml:space="preserve">
          <source>When these transferable objects are transferred, they are 'neutered' on the previous context &amp;mdash; the one they previously belonged to. For instance a port, when is sent, cannot be used anymore by the original context. Note that the only two objects that can currently be transferred are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer&quot;&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 전송 가능한 객체가 전송되면 이전 컨텍스트 (이전에 속한 객체)에서 '중립'됩니다. 예를 들어, 포트가 전송되면 더 이상 원래 컨텍스트에서 사용할 수 없습니다. 현재 전송할 수있는 두 개의 오브젝트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer&quot;&gt; &lt;code&gt;ArrayBuffer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04293ceb4c72045381c1033f9d03a53a9fc46188" translate="yes" xml:space="preserve">
          <source>When this event is processed, the target's border is set to &lt;code&gt;dashed&lt;/code&gt; to provide a clear visual indication the element has received a move event.</source>
          <target state="translated">이 이벤트가 처리되면 대상의 경계가 &lt;code&gt;dashed&lt;/code&gt; 로 설정되어 요소가 이동 이벤트를 수신했음을 명확하게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="55306c9e63cf68f3a0947c7106d9b313abd34896" translate="yes" xml:space="preserve">
          <source>When this event returns (or sets the &lt;code&gt;returnValue&lt;/code&gt; property to) a value other than &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, the user is prompted to confirm the page unload. In some browsers, the return value of the event is displayed in this dialog. Starting with Firefox 44, Chrome 51, Opera 38 and Safari 9.1, a generic string not under the control of the webpage will be shown instead of the returned string. For example, Firefox displays the string &quot;This page is asking you to confirm that you want to leave - data you have entered may not be saved.&quot; (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588292&quot;&gt;bug 588292&lt;/a&gt;), and Chrome displays the string &quot;Do you want to leave this site? Changes you made may not be saved&quot; (see &lt;a href=&quot;https://www.chromestatus.com/feature/5349061406228480&quot;&gt;Chrome Platform Status&lt;/a&gt;).</source>
          <target state="translated">이 이벤트가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 이외의 값을 반환하거나 &lt;code&gt;returnValue&lt;/code&gt; 속성을 설정 하면 페이지 언로드를 확인하라는 메시지가 표시됩니다. 일부 브라우저에서는이 대화 상자에 이벤트 반환 값이 표시됩니다. Firefox 44, Chrome 51, Opera 38 및 Safari 9.1부터는 웹 페이지에서 제어하지 않는 일반 문자열이 반환 된 문자열 대신 표시됩니다. 예를 들어, Firefox는 &quot;이 페이지에서 나가고 싶다는 메시지를 표시합니다. 입력 한 데이터가 저장되지 않았을 수 있습니다.&quot;라는 문자열이 표시됩니다. ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588292&quot;&gt;버그 588292&lt;/a&gt; 참조 ) Chrome에 '이 사이트를 떠나시겠습니까? 변경 사항이 저장되지 않았을 수 있습니다'라는 문자열이 표시됩니다 ( &lt;a href=&quot;https://www.chromestatus.com/feature/5349061406228480&quot;&gt;Chrome 플랫폼 상태&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b675ce375b683ebfefb729b81a7eb5944f8b8e72" translate="yes" xml:space="preserve">
          <source>When this example is executed, it begins by collecting references to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element as well as the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt;&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;&lt;/a&gt; used to toggle playback on and off. It then sets up an event handler for the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; event on the play toggle button and attempts to automatically begin playback by calling &lt;code&gt;playVideo()&lt;/code&gt;.</source>
          <target state="translated">이 예제가 실행되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 대한 참조 와 재생을 켜고 끄는 데 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 에&lt;/a&gt; 대한 참조를 수집하여 시작 합니다. 그런 다음 재생 전환 버튼 에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/click&quot;&gt;click&lt;/a&gt;&lt;/code&gt; 이벤트에 대한 이벤트 핸들러를 설정하고 &lt;code&gt;playVideo()&lt;/code&gt; 를 호출하여 자동으로 재생을 시작하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d6963259b1639a97714b25bf71859ceda2efe355" translate="yes" xml:space="preserve">
          <source>When this is a new document created dynamically.</source>
          <target state="translated">이 문서가 동적으로 작성된 새 문서 인 경우</target>
        </trans-unit>
        <trans-unit id="a7cc7af49aee2c249093e11831d780c2917df107" translate="yes" xml:space="preserve">
          <source>When this property is used, font loading has a timeline with three periods. The lengths of the first two periods depend on the value of the property and the user agent. (See below.)</source>
          <target state="translated">이 속성을 사용하면 글꼴로드에 3 개의 마침표가있는 타임 라인이 있습니다. 처음 두 기간의 길이는 속성 값과 사용자 에이전트에 따라 다릅니다. (아래 참조)</target>
        </trans-unit>
        <trans-unit id="d3b8d4c5e0bbbf65d205f57082e9e093bfa6a136" translate="yes" xml:space="preserve">
          <source>When this property's value changes, a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/connectionstatechange&quot;&gt;connectionstatechange&lt;/a&gt;&lt;/code&gt; event is sent to the &lt;a href=&quot;../rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">이 속성 값이 변경되면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/connectionstatechange&quot;&gt;connectionstatechange&lt;/a&gt;&lt;/code&gt; 이벤트가 &lt;a href=&quot;../rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 인스턴스로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="72fcf2f3217fcc81de10c510d68d0a69d72945d4" translate="yes" xml:space="preserve">
          <source>When this routine is called, the video element is displaying the most recent frame of video data, which looks like this:</source>
          <target state="translated">이 루틴이 호출되면 video 요소는 가장 최근의 비디오 데이터 프레임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="12da763f4582496e5d8fcc3f5219d4d93ab09a37" translate="yes" xml:space="preserve">
          <source>When this script gets executed, the image starts loading.</source>
          <target state="translated">이 스크립트가 실행되면 이미지가로드되기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="79065f4bd450dbbee8cbd4937d33d44eccde0b47" translate="yes" xml:space="preserve">
          <source>When time runs out, if there are still tasks left in the list, we call &lt;a href=&quot;window/requestidlecallback&quot;&gt;&lt;code&gt;requestIdleCallback()&lt;/code&gt;&lt;/a&gt; again so that we can continue to process the tasks the next time there's idle time available. If the queue is empty, we set taskHandle to 0 to indicate that we don't have a callback scheduled. That way, we'll know to request a callback next time &lt;code&gt;enqueueTask()&lt;/code&gt; is called.</source>
          <target state="translated">시간이 &lt;a href=&quot;window/requestidlecallback&quot;&gt; &lt;code&gt;requestIdleCallback()&lt;/code&gt; &lt;/a&gt; 때 목록에 여전히 작업이 남아 있으면 다음에 유휴 시간이있을 때 작업을 계속 처리 할 수 ​​있도록 requestIdleCallback ()을 다시 호출 합니다. 대기열이 비어 있으면 우리는 callHand이 예약되지 않았 음을 나타 내기 위해 taskHandle을 0으로 설정합니다. 그렇게하면 다음에 &lt;code&gt;enqueueTask()&lt;/code&gt; 가 호출 될 때 콜백을 요청해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0aac95d000954a3d204a1d1969ae467ca96ea7d4" translate="yes" xml:space="preserve">
          <source>When two or more pointer device types are being used concurrently, multiple pointers (one for each pointerType) are considered primary. For example, a touch contact and a mouse cursor moved simultaneously will produce pointers that are both considered primary. If there are multiple primary pointers, these pointers will all produce &lt;em&gt;compatibility mouse events&lt;/em&gt; (see &lt;a href=&quot;../pointer_events&quot;&gt;&lt;code&gt;Pointer_events&lt;/code&gt;&lt;/a&gt; for more information about pointer, mouse and touch interaction).</source>
          <target state="translated">둘 이상의 포인터 장치 유형을 동시에 사용하는 경우 여러 포인터 (각 pointerType에 하나씩)가 기본으로 간주됩니다. 예를 들어, 터치 접점과 마우스 커서가 동시에 이동하면 기본으로 간주되는 포인터가 생성됩니다. 기본 포인터가 여러 개인 경우 이러한 포인터는 모두 &lt;em&gt;호환 마우스 이벤트를&lt;/em&gt; 생성 &lt;em&gt;합니다&lt;/em&gt; ( 포인터, 마우스 및 터치 상호 작용에 대한 자세한 내용 은 &lt;a href=&quot;../pointer_events&quot;&gt; &lt;code&gt;Pointer_events&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="79146cc2fed45810d8933ee53b7f0d75b48acaa3" translate="yes" xml:space="preserve">
          <source>When two users running Firefox are communicating on a data channel, the message size limit is much larger than when Firefox and Chrome are communicating because Firefox implements a now deprecated technique for sending large messages in multiple SCTP messages, which Chrome does not. Chrome will instead see a series of messages that it believes are complete, and will deliver them to the receiving &lt;code&gt;RTCDataChannel&lt;/code&gt; as multiple messages.</source>
          <target state="translated">Firefox를 실행하는 두 명의 사용자가 데이터 채널을 통해 통신하는 경우 Firefox는 현재는 더 이상 사용되지 않는 여러 기술을 사용하여 Chrome에서 지원하지 않는 여러 SCTP 메시지로 여러 SCTP 메시지를 전송하기 때문에 Firefox와 Chrome이 통신 할 때보 다 메시지 크기 제한이 훨씬 큽니다. 대신 Chrome은 완료된 것으로 판단되는 일련의 메시지를보고 수신 한 &lt;code&gt;RTCDataChannel&lt;/code&gt; 에 여러 메시지로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="03ab3dc0897982abbf51b2d2f98ed4e141beaa2d" translate="yes" xml:space="preserve">
          <source>When user privacy is a concern, It is important that any web app implementation will invalidate cookie data after a certain timeout and won't rely on the browser clearing session cookies</source>
          <target state="translated">사용자 개인 정보 보호가 중요한 경우, 웹 앱 구현은 특정 시간 초과 후 쿠키 데이터를 무효화하고 브라우저 지우기 세션 쿠키에 의존하지 않는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="d2e5e3cd9b9145fc3fafcf8fa78521b8237792c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;attributeOldValue&lt;/code&gt;, setting the &lt;a href=&quot;attributes&quot;&gt;&lt;code&gt;attributes&lt;/code&gt;&lt;/a&gt; option to &lt;code&gt;true&lt;/code&gt; is optional.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;attributeOldValue&lt;/code&gt; 을 , 설정, &lt;a href=&quot;attributes&quot;&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;/a&gt; 옵션을 ' &lt;code&gt;true&lt;/code&gt; 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3c2c8af7b21e55d22c72205444d7779f95b876bc" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fill&lt;/code&gt; (or &lt;a href=&quot;../../canvasrenderingcontext2d/clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../canvasrenderingcontext2d/ispointinpath&quot;&gt;&lt;code&gt;isPointinPath&lt;/code&gt;&lt;/a&gt;) you can optionally provide a fill rule algorithm by which to determine if a point is inside or outside a path and thus if it gets filled or not. This is useful when a path intersects itself or is nested.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;fill&lt;/code&gt; (또는 &lt;a href=&quot;../../canvasrenderingcontext2d/clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../canvasrenderingcontext2d/ispointinpath&quot;&gt; &lt;code&gt;isPointinPath&lt;/code&gt; 을&lt;/a&gt; ) 선택적이 작성되지 않았거나 들어간 경우 포인트가 내부 또는 경로 외부에 따라서인지 확인하여 채우기 규칙 알고리즘을 제공 할 수 있습니다. 경로가 서로 교차하거나 중첩 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5525b44cb435301e9e2d96a565462e3b7e7bd0de" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt; and the &lt;a href=&quot;../ext_color_buffer_float&quot;&gt;&lt;code&gt;EXT_color_buffer_float&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">때 사용 &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL을이 컨텍스트&lt;/a&gt; 와 &lt;a href=&quot;../ext_color_buffer_float&quot;&gt; &lt;code&gt;EXT_color_buffer_float&lt;/code&gt; 의&lt;/a&gt; 확장 :</target>
        </trans-unit>
        <trans-unit id="c3a9d9ab629bb1bafb9d6af3f01a8328b78f7c95" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt;, a &lt;code&gt;gl.INVALID_OPERATION&lt;/code&gt; error is thrown if this vertex attribute is defined as a integer in the vertex shader (e.g. &lt;code&gt;uvec4&lt;/code&gt; or &lt;code&gt;ivec4&lt;/code&gt;, instead of &lt;code&gt;vec4&lt;/code&gt;).</source>
          <target state="translated">사용시 &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL을 2 컨텍스트&lt;/a&gt; 하는 &lt;code&gt;gl.INVALID_OPERATION&lt;/code&gt; 의 버텍스 속성 정점 셰이더의 정수로서 정의되는 경우 에러 (예 슬로우 &lt;code&gt;uvec4&lt;/code&gt; 또는 &lt;code&gt;ivec4&lt;/code&gt; 대신, &lt;code&gt;vec4&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef8a8674d827d3157a103d101c1065fd8d184038" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt;, the following value is available additionally:</source>
          <target state="translated">사용시 &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL을 2 콘텍스트를&lt;/a&gt; 다음 값을 별도로 사용할 :</target>
        </trans-unit>
        <trans-unit id="7fec16d0a877f1230719ce7d2e45502118b7fcce" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt;, the following values are available additionally:</source>
          <target state="translated">사용시 &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL을 2 콘텍스트를&lt;/a&gt; 다음 값을 별도로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cffddfb39d31b7f924328b8a24c9e1e7b124cdb2" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt;, the following values are possible additionally:</source>
          <target state="translated">&lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 컨텍스트를&lt;/a&gt; 사용하는 경우 다음 값이 추가로 가능합니다.</target>
        </trans-unit>
        <trans-unit id="901bd858af36cd2f860d3cc5cf18b06261148069" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 context&lt;/a&gt;, the following values can be returned additionally:</source>
          <target state="translated">&lt;a href=&quot;../webgl2renderingcontext&quot;&gt;WebGL 2 컨텍스트를&lt;/a&gt; 사용하는 경우 다음 값이 추가로 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc5a807a16d8763a6af26723eb7f8de518d16c2" translate="yes" xml:space="preserve">
          <source>When using a user agent where no constructor has been implemented yet, it is possible to access such an object using the &lt;a href=&quot;url&quot;&gt;&lt;code&gt;Window.URL&lt;/code&gt;&lt;/a&gt; properties (prefixed with Webkit-based browser as &lt;code&gt;Window.webkitURL&lt;/code&gt;).</source>
          <target state="translated">생성자는 아직 실행되지 않은 사용자 에이전트를 사용하는 경우, 상기 사용하여 이러한 개체 액세스 가능 &lt;a href=&quot;url&quot;&gt; &lt;code&gt;Window.URL&lt;/code&gt; 의&lt;/a&gt; (AS 웹킷 기반 브라우저 접두사 특성 &lt;code&gt;Window.webkitURL&lt;/code&gt; 는 ).</target>
        </trans-unit>
        <trans-unit id="6059ede8763193571c8298041ada7ceb08b9b717" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../angle_instanced_arrays&quot;&gt;&lt;code&gt;ANGLE_instanced_arrays&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../angle_instanced_arrays&quot;&gt; &lt;code&gt;ANGLE_instanced_arrays&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e240042b8c5547c103948c7d0738bdd865ac9dc0" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../ext_blend_minmax&quot;&gt;&lt;code&gt;EXT_blend_minmax&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../ext_blend_minmax&quot;&gt; &lt;code&gt;EXT_blend_minmax&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="71829a009bdbb443a69713bbf6ee5fb36b746c77" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../ext_srgb&quot;&gt;&lt;code&gt;EXT_sRGB&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../ext_srgb&quot;&gt; &lt;code&gt;EXT_sRGB&lt;/code&gt; &lt;/a&gt; 확장자를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7e7f33789e2adf6a8f07c9c64b3d7ff1a06208b7" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../oes_element_index_uint&quot;&gt;&lt;code&gt;OES_element_index_uint&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../oes_element_index_uint&quot;&gt; &lt;code&gt;OES_element_index_uint&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="098c02e50b889a98a266cefa28187523880306a1" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../oes_standard_derivatives&quot;&gt;&lt;code&gt;OES_standard_derivatives&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../oes_standard_derivatives&quot;&gt; &lt;code&gt;OES_standard_derivatives&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5878b2b9f9491e09388f470dce3148619add20d1" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../oes_texture_half_float&quot;&gt;&lt;code&gt;OES_texture_half_float&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../oes_texture_half_float&quot;&gt; &lt;code&gt;OES_texture_half_float&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="076f5831e432985cd0dab8de24bd154c44f98b1a" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../rtcpeerconnection/rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection()&lt;/code&gt;&lt;/a&gt; constructor, we will specify an &lt;a href=&quot;../rtcconfiguration&quot;&gt;&lt;code&gt;RTCConfiguration&lt;/code&gt;&lt;/a&gt;-compliant object providing configuration parameters for the connection. We use only one of these in this example: &lt;code&gt;iceServers&lt;/code&gt;. This is an array of objects describing STUN and/or TURN servers for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; layer to use when attempting to establish a route between the caller and the callee. These servers are used to determine the best route and protocols to use when communicating between the peers, even if they're behind a firewall or using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/NAT&quot;&gt;NAT&lt;/a&gt;.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../rtcpeerconnection/rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection()&lt;/code&gt; &lt;/a&gt; 생성자를, 우리는 지정됩니다 &lt;a href=&quot;../rtcconfiguration&quot;&gt; &lt;code&gt;RTCConfiguration&lt;/code&gt; &lt;/a&gt; 연결에 대한 구성 매개 변수를 제공하는 호환 개체를. 이 예제에서는 &lt;code&gt;iceServers&lt;/code&gt; 중 하나만 사용합니다 . 이것은 발신자와 수신자 사이의 경로를 설정하려고 시도 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ICE&quot;&gt;ICE&lt;/a&gt; 계층에 사용할 STUN 및 / 또는 TURN 서버를 설명하는 객체의 배열입니다 . 이 서버는 방화벽 뒤에 있거나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/NAT&quot;&gt;NAT를&lt;/a&gt; 사용하는 경우에도 피어간에 통신 할 때 사용할 최상의 경로와 프로토콜을 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="151e0be03dfc6be359a3a921b91810424de829bd" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_color_buffer_float&quot;&gt;&lt;code&gt;WEBGL_color_buffer_float&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_color_buffer_float&quot;&gt; &lt;code&gt;WEBGL_color_buffer_float&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f49ea6b64d516fee7209a8df82fcb44a2847417a" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_astc&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_astc&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_astc&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_astc&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="19823bedcb0c759e981165e869c32a435dc8cf88" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_atc&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_atc&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_atc&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_atc&lt;/code&gt; &lt;/a&gt; 확장자를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="fa6ec0efb0979f86b9941a490dfa61c365c83a90" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_etc&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_etc&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_etc&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_etc&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="13ceb5fa832db0a0aae7e9ef04d05aa0613e5dad" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_etc1&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_etc1&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_etc1&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_etc1&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="58f4f58fcbe5f1fe8252165cb77b50c134490559" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_pvrtc&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_pvrtc&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_pvrtc&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_pvrtc&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="38a9d850924d40adf91cade1e57a5f780ea720d5" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_s3tc&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_s3tc&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_s3tc&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_s3tc&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7c6eca164002431deb6ae22b534fe06cd95bec1a" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_compressed_texture_s3tc_srgb&quot;&gt;&lt;code&gt;WEBGL_compressed_texture_s3tc_srgb&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_compressed_texture_s3tc_srgb&quot;&gt; &lt;code&gt;WEBGL_compressed_texture_s3tc_srgb&lt;/code&gt; &lt;/a&gt; 확장자를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e36293671aea26271a85137a0ba2bd84259355ed" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_depth_texture&quot;&gt;&lt;code&gt;WEBGL_depth_texture&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_depth_texture&quot;&gt; &lt;code&gt;WEBGL_depth_texture&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1f392a7166e8e2ca483c3f6e047ee57b892fc9a3" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../webgl_draw_buffers&quot;&gt;&lt;code&gt;WEBGL_draw_buffers&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;../webgl_draw_buffers&quot;&gt; &lt;code&gt;WEBGL_draw_buffers&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0552f1ae794471fbf65586e2e2f7c6e7ef59bda7" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method it is possible to use the third optional parameter to pass a filename inside the &lt;code&gt;Content-Disposition&lt;/code&gt; header that is sent to the server. When no filename is specified (or the parameter isn't supported), the name &quot;blob&quot; is used.</source>
          <target state="translated">사용시 &lt;a href=&quot;append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메소드는이를 내부의 파일 이름을 통과하는 세 번째 옵션 매개 변수를 사용할 수있다 &lt;code&gt;Content-Disposition&lt;/code&gt; 서버에 전송되는 헤더. 파일 이름이 지정되지 않았거나 매개 변수가 지원되지 않으면 &quot;blob&quot;라는 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8698e9a59e52f4976079a9d3a23753b4f05b604a" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float&quot;&gt;&lt;code&gt;OES_texture_float&lt;/code&gt;&lt;/a&gt; extension:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float&quot;&gt; &lt;code&gt;OES_texture_float&lt;/code&gt; &lt;/a&gt; 확장을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="488c629de7c8b1461d0e2a3edf0b7719602ab347" translate="yes" xml:space="preserve">
          <source>When using the deprecated callback-based version of &lt;code&gt;setLocalDescription()&lt;/code&gt;, the following exceptions may occur:</source>
          <target state="translated">더 이상 사용되지 않는 콜백 기반 버전의 &lt;code&gt;setLocalDescription()&lt;/code&gt; 을 사용하는 경우 다음 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c11852cf7f6d35f27feb76f547f683d816548a6" translate="yes" xml:space="preserve">
          <source>When using the deprecated callback-based version of &lt;code&gt;setRemoteDescription()&lt;/code&gt;, the following exceptions may occur:</source>
          <target state="translated">더 이상 사용되지 않는 콜백 기반 버전의 &lt;code&gt;setRemoteDescription()&lt;/code&gt; 을 사용하는 경우 다음 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f7a2d9bc03cf525798c002ab65cb112b9a6cf49" translate="yes" xml:space="preserve">
          <source>When using the inline HTML markup (&lt;code&gt;&amp;lt;body onerror=&quot;alert('an error occurred')&quot;&amp;gt;&lt;/code&gt;), the HTML specification requires arguments passed to &lt;code&gt;onerror&lt;/code&gt; to be named &lt;code&gt;event&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;lineno&lt;/code&gt;, &lt;code&gt;colno&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;. In browsers that have not implemented this requirement, they can still be obtained via &lt;code&gt;arguments[0]&lt;/code&gt; through &lt;code&gt;arguments[2]&lt;/code&gt;.</source>
          <target state="translated">인라인 HTML 마크 업 ( &lt;code&gt;&amp;lt;body onerror=&quot;alert('an error occurred')&quot;&amp;gt;&lt;/code&gt; )을 사용하는 경우 HTML 사양에서는 &lt;code&gt;onerror&lt;/code&gt; 에 전달 된 인수의 이름을 &lt;code&gt;event&lt;/code&gt; , &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;lineno&lt;/code&gt; , &lt;code&gt;colno&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 로 지정해야 합니다. 이 요구 사항을 구현하지 않은 브라우저에서는 &lt;code&gt;arguments[0]&lt;/code&gt; ~ &lt;code&gt;arguments[2]&lt;/code&gt; 를 통해 여전히 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28da46c0755b3ffe2198514ad0b3aa40f4e11454" translate="yes" xml:space="preserve">
          <source>When viewing a document, an element with focus is always the &lt;a href=&quot;../documentorshadowroot/activeelement&quot;&gt;active element&lt;/a&gt; in the document, but an active element does not necessarily have focus. For example, an active element within a popup window that is not the foreground does not have focus.</source>
          <target state="translated">문서를 볼 때 초점 요소는 항상있다 &lt;a href=&quot;../documentorshadowroot/activeelement&quot;&gt;활성 요소&lt;/a&gt; 문서,하지만 활성 요소는 반드시 초점이 없습니다. 예를 들어, 전경이 아닌 팝업 창 내의 활성 요소에는 초점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4ef80d4e5aef04ff5ba6df1ae55c5427bace4b5" translate="yes" xml:space="preserve">
          <source>When we come to call the &lt;code&gt;imgLoad()&lt;/code&gt; function, we call it with the url to the image we want to load, as we might expect, but the rest of the code is a little different:</source>
          <target state="translated">&lt;code&gt;imgLoad()&lt;/code&gt; 함수 를 호출 할 때로드 할 이미지의 url을 호출합니다. 예상대로 코드의 나머지 부분은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="daa8612a0c9c45f58a41457196952f1438a32ef4" translate="yes" xml:space="preserve">
          <source>When we come to run the function, we do the following. This is because Firefox doesn't support &lt;a href=&quot;../speechsynthesis/onvoiceschanged&quot;&gt;&lt;code&gt;SpeechSynthesis.onvoiceschanged&lt;/code&gt;&lt;/a&gt;, and will just return a list of voices when &lt;a href=&quot;../speechsynthesis/getvoices&quot;&gt;&lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt;&lt;/a&gt; is fired. With Chrome however, you have to wait for the event to fire before populating the list, hence the if statement seen below.</source>
          <target state="translated">함수를 실행하면 다음을 수행합니다. Firefox는 &lt;a href=&quot;../speechsynthesis/onvoiceschanged&quot;&gt; &lt;code&gt;SpeechSynthesis.onvoiceschanged&lt;/code&gt; 를&lt;/a&gt; 지원하지 않기 때문에 &lt;a href=&quot;../speechsynthesis/getvoices&quot;&gt; &lt;code&gt;SpeechSynthesis.getVoices()&lt;/code&gt; &lt;/a&gt; 가 시작될 때 음성 목록 만 반환합니다 . 그러나 Chrome을 사용하면 목록을 채우기 전에 이벤트가 시작될 때까지 기다려야하므로 아래 if 문이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c95a9e8c24eeb31488c12c1c3406c5ae1c457e9" translate="yes" xml:space="preserve">
          <source>When we want to explicitly set a key&amp;rsquo;s offset from the other keys, we can specify an offset directly in the object, separated from the declaration with a comma. In the above example, to make sure that Alice&amp;rsquo;s color changes at 30% (not 50%) for the color change, we are giving it &lt;code&gt;offset: 0.3&lt;/code&gt;.</source>
          <target state="translated">다른 키와 키 오프셋을 명시 적으로 설정하려면 선언에서 쉼표로 구분하여 객체에 직접 오프셋을 지정할 수 있습니다. 위의 예에서 Alice의 색상이 색상 변경에 대해 30 % (50 % 아님)로 변경되도록하려면 &lt;code&gt;offset: 0.3&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4bee466b9b61109435ee1146df9ef9dd231d861e" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;WebGLQuery&lt;/code&gt; objects, the following methods of the &lt;a href=&quot;webgl2renderingcontext&quot;&gt;&lt;code&gt;WebGL2RenderingContext&lt;/code&gt;&lt;/a&gt; are useful:</source>
          <target state="translated">&lt;code&gt;WebGLQuery&lt;/code&gt; 오브젝트로 작업 할 때 다음 &lt;a href=&quot;webgl2renderingcontext&quot;&gt; &lt;code&gt;WebGL2RenderingContext&lt;/code&gt; &lt;/a&gt; 메소드 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="43143ffc89e172f649dfaa01f74554ab08b5d302" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;WebGLSampler&lt;/code&gt; objects, the following methods of the &lt;a href=&quot;webgl2renderingcontext&quot;&gt;&lt;code&gt;WebGL2RenderingContext&lt;/code&gt;&lt;/a&gt; are useful:</source>
          <target state="translated">&lt;code&gt;WebGLSampler&lt;/code&gt; 오브젝트로 작업 할 때 다음 &lt;a href=&quot;webgl2renderingcontext&quot;&gt; &lt;code&gt;WebGL2RenderingContext&lt;/code&gt; &lt;/a&gt; 메소드 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a204f461438b2bffcbacd97612b7d7dd04f3dc41" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;WebGLSync&lt;/code&gt; objects, the following methods of the &lt;a href=&quot;webgl2renderingcontext&quot;&gt;&lt;code&gt;WebGL2RenderingContext&lt;/code&gt;&lt;/a&gt; are useful:</source>
          <target state="translated">&lt;code&gt;WebGLSync&lt;/code&gt; 오브젝트로 작업 할 때 다음 &lt;a href=&quot;webgl2renderingcontext&quot;&gt; &lt;code&gt;WebGL2RenderingContext&lt;/code&gt; &lt;/a&gt; 메소드 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="999fea53b32cb0175886ac200d5445d5cc584f4f" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;WebGLTransformFeedback&lt;/code&gt; objects, the following methods of the &lt;a href=&quot;webgl2renderingcontext&quot;&gt;&lt;code&gt;WebGL2RenderingContext&lt;/code&gt;&lt;/a&gt; are useful:</source>
          <target state="translated">&lt;code&gt;WebGLTransformFeedback&lt;/code&gt; 오브젝트로 작업 할 때 다음 &lt;a href=&quot;webgl2renderingcontext&quot;&gt; &lt;code&gt;WebGL2RenderingContext&lt;/code&gt; &lt;/a&gt; 메소드 가 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3909ef72341ca4702e501c73befc333a25b9763d" translate="yes" xml:space="preserve">
          <source>When working with &lt;code&gt;WebGLVertexArrayObject&lt;/code&gt; objects, the following methods are useful:</source>
          <target state="translated">&lt;code&gt;WebGLVertexArrayObject&lt;/code&gt; 객체로 작업 할 때 다음 방법이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c678ee9895b7dbff3144d5dd35ada232c348f208" translate="yes" xml:space="preserve">
          <source>When working with MSE, the following tools are a must have:</source>
          <target state="translated">MSE로 작업 할 때는 다음 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16bafe2426e5dc4186e26ad59cd9d6c052eec641" translate="yes" xml:space="preserve">
          <source>When working with an &lt;a href=&quot;../audiocontext&quot;&gt;&lt;code&gt;AudioContext&lt;/code&gt;&lt;/a&gt;, if you create the audio context from inside a &lt;code&gt;click&lt;/code&gt; event the state should automatically be set to &lt;code&gt;running&lt;/code&gt;. Here is a simple example of creating the context from inside a &lt;code&gt;click&lt;/code&gt; event:</source>
          <target state="translated">&lt;a href=&quot;../audiocontext&quot;&gt; &lt;code&gt;AudioContext&lt;/code&gt; 로&lt;/a&gt; 작업 할 때 &lt;code&gt;click&lt;/code&gt; 이벤트 내부에서 오디오 컨텍스트를 생성 하면 상태가 자동으로 &lt;code&gt;running&lt;/code&gt; 으로 설정되어야 합니다 . 다음은 &lt;code&gt;click&lt;/code&gt; 이벤트 내부에서 컨텍스트를 작성하는 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="ef480760ef4502ba63b9c5946d9bbb6f124b2d6e" translate="yes" xml:space="preserve">
          <source>When working with files, you are looking at either the grabbing the file from an &lt;a href=&quot;../htmlmediaelement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; (i.e. an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; element), or you're looking to fetch the file and decode it into a buffer. Both are legitimate ways of working, however, it's more common to use the former when you are working will full-length tracks, and the latter when working with shorter, more sample-like tracks.</source>
          <target state="translated">파일로 작업 할 때 &lt;a href=&quot;../htmlmediaelement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소)에서 파일을 가져 오거나 파일을 가져 와서 버퍼로 디코딩하려고합니다. 둘 다 합법적 인 작업 방식이지만, 전장 트랙을 작업 할 때는 전자를 사용하고, 더 짧고 샘플 같은 트랙을 작업 할 때는 전자를 사용하는 것이 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="93563d9724827d60d0fc12b8c68aa5c0bbc5c2f9" translate="yes" xml:space="preserve">
          <source>When working with media source extensions, it is likely that you need to condition your assets before you can stream them. This article takes you through the requirements and shows you a toolchain you can use to encode your assets appropriately.</source>
          <target state="translated">미디어 소스 확장으로 작업 할 때 자산을 스트리밍하기 전에 자산을 조정해야 할 수 있습니다. 이 기사에서는 요구 사항을 살펴보고 자산을 적절히 인코딩하는 데 사용할 수있는 툴체인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b33f2b99a3d01e4dd9689a6763cfbebecd22daf0" translate="yes" xml:space="preserve">
          <source>When working with the keyboard, focus rings are a handy indicator to help navigating on a page. To draw focus rings on a canvas drawing, the &lt;code&gt;drawFocusIfNeeded&lt;/code&gt; property can be used.</source>
          <target state="translated">키보드로 작업 할 때 포커스 링은 페이지를 탐색하는 데 도움이되는 편리한 표시기입니다. 캔버스 도면에 초점 링을 그리려면 &lt;code&gt;drawFocusIfNeeded&lt;/code&gt; 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212d058f76197537c8637cc3abc9611b30b850f5" translate="yes" xml:space="preserve">
          <source>When writing code for the Web with JavaScript, there are a great many APIs available. Below is a list of all the interfaces (that is, types of objects) that you may be able to use while developing your Web app or site.</source>
          <target state="translated">JavaScript를 사용하여 웹용 코드를 작성할 때 사용할 수있는 많은 API가 있습니다. 다음은 웹앱 또는 사이트를 개발하는 동안 사용할 수있는 모든 인터페이스 (즉, 객체 유형) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="eb67b1e9a2a9d6fd72938c0bf3d17c62284c482d" translate="yes" xml:space="preserve">
          <source>When you are using an &lt;a href=&quot;../iirfilternode&quot;&gt;&lt;code&gt;IIRFilterNode&lt;/code&gt;&lt;/a&gt; instead of a &lt;a href=&quot;../biquadfilternode&quot;&gt;&lt;code&gt;BiquadFilterNode&lt;/code&gt;&lt;/a&gt; you are creating the filter yourself, rather than just choosing a pre-programmed type. So you can create a highpass filter, or a lowpass filter, or a more bespoke one. And this is where the IIR filter node is useful &amp;mdash; you can create your own if none of the alaready available settings is right for what you want. As well as this, if your audio graph needed a highpass and a bandpass filter within it, you could just use one IIR filter node in place of the two biquad filter nodes you would otherwise need for this.</source>
          <target state="translated">당신은 사용하는 경우 &lt;a href=&quot;../iirfilternode&quot;&gt; &lt;code&gt;IIRFilterNode&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../biquadfilternode&quot;&gt; &lt;code&gt;BiquadFilterNode&lt;/code&gt; 을&lt;/a&gt; 오히려 단지 미리 프로그램 유형을 선택하는 것보다, 필터를 직접 만들 수 있습니다. 따라서 고역 통과 필터 또는 저역 통과 필터 또는보다 맞춤형 필터를 만들 수 있습니다. 그리고 이것이 IIR 필터 노드가 유용한 곳입니다. 사용 가능한 설정 중 어느 것도 원하는 것에 맞지 않으면 직접 만들 수 있습니다. 뿐만 아니라 오디오 그래프에 고역 통과 및 대역 통과 필터가 필요한 경우, 필요에 따라 두 개의 바이 쿼드 필터 노드 대신 하나의 IIR 필터 노드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6f3bdf5b3e9728f4dfa61f824b1bd8ddad1687" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;stop()&lt;/code&gt; on a transceiver, the sender immediately stops sending media and each of its RTP streams are closed using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/RTCP&quot;&gt;RTCP&lt;/a&gt;&lt;code&gt;&quot;BYE&quot;&lt;/code&gt; message. The receiver then stops receiving media; the receiver's &lt;a href=&quot;../rtcrtpreceiver/track&quot;&gt;&lt;code&gt;track&lt;/code&gt;&lt;/a&gt; is stopped, and the transceiver's &lt;a href=&quot;stopped&quot;&gt;&lt;code&gt;stopped&lt;/code&gt;&lt;/a&gt; property is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">송수신기에서 &lt;code&gt;stop()&lt;/code&gt; 을 호출 하면 발신자가 즉시 미디어 전송을 중지하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/RTCP&quot;&gt;RTCP &lt;/a&gt; &lt;code&gt;&quot;BYE&quot;&lt;/code&gt; 메시지를 사용하여 각 RTP 스트림이 닫힙니다 . 그러면 수신기가 미디어 수신을 중지합니다. 수신자의 &lt;a href=&quot;../rtcrtpreceiver/track&quot;&gt; &lt;code&gt;track&lt;/code&gt; &lt;/a&gt; 이 중지되고 트랜시버의 &lt;a href=&quot;stopped&quot;&gt; &lt;code&gt;stopped&lt;/code&gt; &lt;/a&gt; 특성이 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="752816c410a167aa92af868f97203689aa5abf87" translate="yes" xml:space="preserve">
          <source>When you change the value of &lt;code&gt;direction&lt;/code&gt;, an &lt;code&gt;InvalidStateError&lt;/code&gt; exception will occur if the connection is closed or the receiver is stopped.</source>
          <target state="translated">만약 값 변경하면 &lt;code&gt;direction&lt;/code&gt; , &lt;code&gt;InvalidStateError&lt;/code&gt; 의 접속이 폐쇄되거나 수신기가 중지 된 경우 예외가 발생할 것이다.</target>
        </trans-unit>
        <trans-unit id="575ee9c5def7c7753488ae6c2dfe0e6d80c78123" translate="yes" xml:space="preserve">
          <source>When you choose different options, the page is instantly updated; in addition, your choices are stored in &lt;code&gt;localStorage&lt;/code&gt;, so that when you leave the page and load it again, later on, your choices are remembered.</source>
          <target state="translated">다른 옵션을 선택하면 페이지가 즉시 업데이트됩니다. 또한 선택 사항은 &lt;code&gt;localStorage&lt;/code&gt; 에 저장 되므로 페이지를 떠나 다시로드하면 나중에 선택 사항이 기억됩니다.</target>
        </trans-unit>
        <trans-unit id="d9140f42d6088c690941df0d4bd0d84684481de6" translate="yes" xml:space="preserve">
          <source>When you click on the &lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; element and then the &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt; element, you'll notice two things. First, the &lt;code&gt;composed&lt;/code&gt; property returns &lt;code&gt;true&lt;/code&gt; beause the &lt;code&gt;click&lt;/code&gt; event is always able to propagate across shadow boundaries. Second, you'll notice a difference in the value of &lt;code&gt;composedPath&lt;/code&gt; for the two elements. The &lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; element's composed path is this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; 요소 를 클릭 한 다음 &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt; 요소를 클릭하면 두 가지가 있습니다. 첫째, &lt;code&gt;composed&lt;/code&gt; 속성 반환 &lt;code&gt;true&lt;/code&gt; beause &lt;code&gt;click&lt;/code&gt; 이벤트는 항상 그림자의 경계를 넘어 전파 할 수 있습니다. 둘째, 두 요소에 대해 &lt;code&gt;composedPath&lt;/code&gt; 의 값이 다릅니다 . &lt;code&gt;&amp;lt;open-shadow&amp;gt;&lt;/code&gt; 요소의 합성 경로는이있다 :</target>
        </trans-unit>
        <trans-unit id="e50e7cd11e676bc9b9a31e2c689dc5beb22f1344" translate="yes" xml:space="preserve">
          <source>When you create a new database or increase the version number of an existing database (by specifying a higher version number than you did previously, when &lt;a href=&quot;#Opening_a_database&quot;&gt;Opening a database&lt;/a&gt;), the &lt;code&gt;onupgradeneeded&lt;/code&gt; event will be triggered and an &lt;a href=&quot;../idbversionchangeevent&quot;&gt;IDBVersionChangeEvent&lt;/a&gt; object will be passed to any &lt;code&gt;onversionchange&lt;/code&gt; event handler set up on &lt;code&gt;request.result&lt;/code&gt; (i.e., &lt;code&gt;db&lt;/code&gt; in the example). In the handler for the &lt;code&gt;upgradeneeded&lt;/code&gt; event, you should create the object stores needed for this version of the database:</source>
          <target state="translated">새 데이터베이스를 만들거나 기존 데이터베이스의 버전 번호를 증가 할 때 (이전보다 더 높은 버전 번호를 지정하는 경우, &lt;a href=&quot;#Opening_a_database&quot;&gt;데이터베이스를 열기&lt;/a&gt; )에 &lt;code&gt;onupgradeneeded&lt;/code&gt; 이벤트가 트리거됩니다 및 &lt;a href=&quot;../idbversionchangeevent&quot;&gt;IDBVersionChangeEvent의&lt;/a&gt; 객체 하나에 전달됩니다 &lt;code&gt;onversionchange&lt;/code&gt; 의 이벤트 &lt;code&gt;request.result&lt;/code&gt; 에 핸들러 설정 (예 : &lt;code&gt;db&lt;/code&gt; ) 의 핸들러에서 &lt;code&gt;upgradeneeded&lt;/code&gt; 이벤트, 데이터베이스의이 버전에 필요한 객체 저장소를 만들어야합니다 :</target>
        </trans-unit>
        <trans-unit id="374af22673faa85cdb234cce75182580d5b5ba0a" translate="yes" xml:space="preserve">
          <source>When you create a script&amp;ndash;whether it's inline in a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element or included in the web page by means of a script loading instruction&amp;ndash;you can immediately begin using the API for the &lt;a href=&quot;../document&quot;&gt;&lt;code&gt;document&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; elements to manipulate the document itself or to get at the children of that document, which are the various elements in the web page. Your DOM programming may be something as simple as the following, which displays an alert message by using the &lt;a href=&quot;../window/alert&quot;&gt;&lt;code&gt;alert()&lt;/code&gt;&lt;/a&gt; function from the &lt;a href=&quot;../window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; object, or it may use more sophisticated DOM methods to actually create new content, as in the longer example below.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소에 인라인이든 스크립트로드 명령을 통해 웹 페이지에 포함 된 스크립트를 만들 때 즉시 &lt;a href=&quot;../document&quot;&gt; &lt;code&gt;document&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; 요소에 API를 사용 하여 문서 자체를 조작하거나 얻을 수 있습니다. 웹 페이지의 다양한 요소 인 해당 문서의 하위에서 DOM 프로그래밍은 다음과 같이 간단 할 수 있습니다.이 방법 은 &lt;a href=&quot;../window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;../window/alert&quot;&gt; &lt;code&gt;alert()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 경고 메시지를 표시 하거나 아래의 더 긴 예에서와 같이보다 정교한 DOM 메서드를 사용하여 실제로 새 내용을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a26d422cfe918fc94972b2cddcce0d19cc79225" translate="yes" xml:space="preserve">
          <source>When you create an audio context (either offline or online) it is created with a &lt;code&gt;state&lt;/code&gt;, which can be &lt;code&gt;suspended&lt;/code&gt;, &lt;code&gt;running&lt;/code&gt;, or &lt;code&gt;closed&lt;/code&gt;.</source>
          <target state="translated">오디오 컨텍스트 (오프라인 또는 온라인)를 만들면 &lt;code&gt;suspended&lt;/code&gt; , &lt;code&gt;running&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 수 있는 &lt;code&gt;state&lt;/code&gt; 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="dedc19355c2c70e85291c33a0546eb73b75e7849" translate="yes" xml:space="preserve">
          <source>When you first create a WebGL context, the size of the viewport will match the size of the canvas. However, if you resize the canvas, you will need to tell the WebGL context a new viewport setting. In this situation, you can use &lt;code&gt;gl.viewport&lt;/code&gt;.</source>
          <target state="translated">WebGL 컨텍스트를 처음 작성할 때 뷰포트의 크기는 캔버스의 크기와 일치합니다. 그러나 캔버스 크기를 조정하는 경우 WebGL 컨텍스트에 새로운 뷰포트 설정을 알려야합니다. 이 상황에서는 &lt;code&gt;gl.viewport&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8bb6baedfd0b37f85b2cbecbee095bfc96babdd" translate="yes" xml:space="preserve">
          <source>When you get a reference to a &lt;code&gt;table&lt;/code&gt; object, as in the following example, you routinely use all three of these interfaces interchangeably on the object, perhaps without knowing it.</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;table&lt;/code&gt; 개체에 대한 참조를 얻으면 이러한 세 가지 인터페이스를 모두 개체에 대해 서로 모르게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e487e4cdcfcfbcb00f9d7533125332467f8420" translate="yes" xml:space="preserve">
          <source>When you have a &lt;a href=&quot;../file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; object you'd like to reference by URL from HTML, you can create an object URL for it like this:</source>
          <target state="translated">HTML에서 URL로 참조 하려는 &lt;a href=&quot;../file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 객체가 있으면 다음과 같이 객체 URL을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced5e892d53e45c9af4b4e5f88747350156148d5" translate="yes" xml:space="preserve">
          <source>When you instantiate the ServerSocket class, it is bound to the port number you specified by the &lt;em&gt;port&lt;/em&gt; argument.</source>
          <target state="translated">ServerSocket 클래스를 인스턴스화하면 &lt;em&gt;port&lt;/em&gt; 인수로 지정한 포트 번호에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="62d0f0d62628b8ed9a95636e6c00dc90b7bef672" translate="yes" xml:space="preserve">
          <source>When you look through the source code of &lt;a href=&quot;https://github.com/mdn/webvr-tests/blob/master/raw-webgl-example/webgl-demo.js&quot;&gt;our demo's main JavaScript file&lt;/a&gt;, you can easily find the WebVR-specific parts by searching for the string &quot;WebVR&quot; in preceding comments.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mdn/webvr-tests/blob/master/raw-webgl-example/webgl-demo.js&quot;&gt;데모 메인 JavaScript 파일의&lt;/a&gt; 소스 코드를 살펴보면 앞의 주석에서 &quot;WebVR&quot;문자열을 검색하여 WebVR 관련 부분을 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6370283fec311ae4dd8ef646dac7e106c7c5f36" translate="yes" xml:space="preserve">
          <source>When you pass a method to &lt;code&gt;setInterval()&lt;/code&gt; or any other function, it is invoked with the wrong &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; value. This problem is explained in detail in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#As_an_object_method&quot;&gt;JavaScript reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;setInterval()&lt;/code&gt; 또는 다른 함수에 메소드를 전달하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; 값 이 잘못 호출됩니다 . 이 문제는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#As_an_object_method&quot;&gt;JavaScript 참조&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e1a9153308bb8ee47af5cb3755e6a1d9bb81c5" translate="yes" xml:space="preserve">
          <source>When you pass a method to &lt;code&gt;setTimeout()&lt;/code&gt; (or any other function, for that matter), it will be invoked with a &lt;code&gt;this&lt;/code&gt; value that may differ from your expectation. This issue is explained in detail in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#As_an_object_method&quot;&gt;JavaScript reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;setTimeout()&lt;/code&gt; (또는 그 문제에 대한 다른 함수 )에 메소드를 전달하면 예상과 다를 수 있는 &lt;code&gt;this&lt;/code&gt; 값 으로 호출됩니다 . 이 문제는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#As_an_object_method&quot;&gt;JavaScript 참조&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1225f7125b5ee57e4758124d1b46580cf6102326" translate="yes" xml:space="preserve">
          <source>When you trap events on the window, document, or other roomy elements, you can get the coordinates of that event (e.g., a click) and route it properly, as the following example demonstrates:</source>
          <target state="translated">창, 문서 또는 기타 넓은 요소에서 이벤트를 잡을 때 다음 예제와 같이 해당 이벤트의 좌표 (예 : 클릭)를 가져 와서 올바르게 라우팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="993d68d0d2cf41ae1b379f9d8014b2e37154b27b" translate="yes" xml:space="preserve">
          <source>When you want to remove an attribute, you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete operator&lt;/a&gt;.</source>
          <target state="translated">속성을 제거하려는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete&quot;&gt;delete 연산자를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a23a487ac9773df26d204b78f917023c484472cb" translate="yes" xml:space="preserve">
          <source>When you want to stop sending messages down the channel, you can invoke &lt;a href=&quot;messageport/close&quot;&gt;&lt;code&gt;MessagePort.close&lt;/code&gt;&lt;/a&gt; to close the ports.</source>
          <target state="translated">채널을 통한 메시지 전송을 중지하려면 &lt;a href=&quot;messageport/close&quot;&gt; &lt;code&gt;MessagePort.close&lt;/code&gt; &lt;/a&gt; 를 호출 하여 포트를 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e41e085dc476e29380f021d890bfa6b70a87d89" translate="yes" xml:space="preserve">
          <source>When you wish to provide your own certificates for use by an &lt;a href=&quot;rtcpeerconnection&quot;&gt;&lt;code&gt;RTCPeerConnection&lt;/code&gt;&lt;/a&gt; instead of having the &lt;code&gt;RTCPeerConnection&lt;/code&gt; generate them automatically, you do so through calls to &lt;a href=&quot;rtcpeerconnection/generatecertificate&quot;&gt;&lt;code&gt;RTCPeerConnection.generateCertificate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RTCPeerConnection&lt;/code&gt; 이 자동으로 생성하는 대신 &lt;a href=&quot;rtcpeerconnection&quot;&gt; &lt;code&gt;RTCPeerConnection&lt;/code&gt; &lt;/a&gt; 에서 사용할 자체 인증서를 제공 하려면 &lt;a href=&quot;rtcpeerconnection/generatecertificate&quot;&gt; &lt;code&gt;RTCPeerConnection.generateCertificate()&lt;/code&gt; &lt;/a&gt; 호출을 통해 인증서를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d70a0a55d60c98f66c2029191d41371c303563d" translate="yes" xml:space="preserve">
          <source>When you've finished using the WebSocket connection, call the WebSocket method &lt;a href=&quot;https://developer.mozilla.org/en/WebSockets/WebSockets_reference/WebSocket#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">WebSocket 연결 사용을 마치면 WebSocket 메소드 &lt;a href=&quot;https://developer.mozilla.org/en/WebSockets/WebSockets_reference/WebSocket#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8f8ffeed03dc8f2d0cf7dbe3d3e9cdb7dc8637e" translate="yes" xml:space="preserve">
          <source>When your page loads, it might have a non-null state object. This can happen, for example, if the page sets a state object (using &lt;code&gt;pushState()&lt;/code&gt; or &lt;code&gt;replaceState()&lt;/code&gt;) and then the user restarts their browser. When your page reloads, the page will receive an onload event, but no popstate event. However, if you read the history.state property, you'll get back the state object you would have gotten if a popstate had fired.</source>
          <target state="translated">페이지가로드되면 널이 아닌 상태 오브젝트가있을 수 있습니다. 예를 들어 페이지가 &lt;code&gt;pushState()&lt;/code&gt; 또는 &lt;code&gt;replaceState()&lt;/code&gt; 사용하여 상태 객체를 설정 한 다음 사용자가 브라우저를 다시 시작 하면 이런 일이 발생할 수 있습니다 . 페이지가 다시로드되면 페이지에 onload 이벤트가 수신되지만 popstate 이벤트는 수신되지 않습니다. 그러나 history.state 속성을 읽으면 popstate가 시작된 경우 얻을 수있는 상태 객체를 다시 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="062c9a4f9d449b003b7ca18c5f85fdfa9d1c09ed" translate="yes" xml:space="preserve">
          <source>When your web app changes in such a way that a version change is required for your database, you need to consider what happens if the user has the old version of your app open in one tab and then loads the new version of your app in another. When you call &lt;code&gt;open()&lt;/code&gt; with a greater version than the actual version of the database, all other open databases must explicitly acknowledge the request before you can start making changes to the database (an &lt;code&gt;onblocked&lt;/code&gt; event is fired until they are closed or reloaded). Here's how it works:</source>
          <target state="translated">데이터베이스에 버전 변경이 필요한 방식으로 웹 앱이 변경되면 사용자가 한 탭에서 이전 버전의 앱을 연 다음 다른 버전에 새 버전의 앱을로드하면 어떻게되는지 고려해야합니다. . 실제 버전의 데이터베이스보다 큰 버전으로 &lt;code&gt;open()&lt;/code&gt; 을 호출 하면 데이터베이스를 변경하기 시작하기 전에 열려있는 다른 모든 데이터베이스가 요청을 명시 적으로 승인해야합니다 ( 차단되거나 다시로드 될 때까지 &lt;code&gt;onblocked&lt;/code&gt; 이벤트가 발생 함). 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f1519c231b2cc34c8d8a9d88c74b6cebf629c8e" translate="yes" xml:space="preserve">
          <source>Whenever a new value is assigned to the location object, a document will be loaded using the URL as if &lt;code&gt;location.assign()&lt;/code&gt; had been called with the modified URL. Note that security settings, like CORS, may prevent this to effectively happen.</source>
          <target state="translated">새 값이 위치 객체에 할당 될 때마다 수정 된 URL로 &lt;code&gt;location.assign()&lt;/code&gt; 이 호출 된 것처럼 URL을 사용하여 문서가로드됩니다 . CORS와 같은 보안 설정으로 인해 이러한 상황이 효과적으로 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13d80bc77477a352d26e0b670a11509478d97d2e" translate="yes" xml:space="preserve">
          <source>Whenever the target meets a threshold specified for the &lt;code&gt;IntersectionObserver&lt;/code&gt;, the callback is invoked. The callback receives a list of &lt;a href=&quot;intersectionobserverentry&quot;&gt;&lt;code&gt;IntersectionObserverEntry&lt;/code&gt;&lt;/a&gt; objects and the observer:</source>
          <target state="translated">대상이 &lt;code&gt;IntersectionObserver&lt;/code&gt; 에 지정된 임계 값을 충족 할 때마다 콜백이 호출됩니다. 콜백은 &lt;a href=&quot;intersectionobserverentry&quot;&gt; &lt;code&gt;IntersectionObserverEntry&lt;/code&gt; &lt;/a&gt; 객체 및 관찰자 의 목록을받습니다 .</target>
        </trans-unit>
        <trans-unit id="12ec40acd39b349647f72e20d888bc02e7e928fa" translate="yes" xml:space="preserve">
          <source>Whenever this value decreases to fall to or below the value specified in the &lt;a href=&quot;bufferedamountlowthreshold&quot;&gt;&lt;code&gt;bufferedAmountLowThreshold&lt;/code&gt;&lt;/a&gt; property, the user agent fires the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/bufferedamountlow&quot;&gt;bufferedamountlow&lt;/a&gt;&lt;/code&gt; event. This event may be used, for example, to implement code which queues more messages to be sent whenever there's room to buffer them.</source>
          <target state="translated">이 값이 &lt;a href=&quot;bufferedamountlowthreshold&quot;&gt; &lt;code&gt;bufferedAmountLowThreshold&lt;/code&gt; &lt;/a&gt; 특성에 지정된 값 이하로 떨어지면 사용자 에이전트는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/bufferedamountlow&quot;&gt;bufferedamountlow&lt;/a&gt;&lt;/code&gt; 이벤트를 발생시킵니다 . 예를 들어,이 이벤트는 버퍼링 할 공간이있을 때마다 더 많은 메시지를 보내도록 대기하는 코드를 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ebe48a3c94951af91835ac4308b7fb4af93ccb" translate="yes" xml:space="preserve">
          <source>Whenever you move the mouse, this example checks whether the cursor is in a circular &lt;code&gt;Path2D&lt;/code&gt; path. If yes, the circle becomes green, otherwise it is red.</source>
          <target state="translated">마우스를 움직일 때마다이 예제는 커서가 원형 &lt;code&gt;Path2D&lt;/code&gt; 경로 에 있는지 확인합니다 . 그렇다면 원이 녹색이되고, 그렇지 않으면 빨간색이됩니다.</target>
        </trans-unit>
        <trans-unit id="6929b561cca04bbe53d80605e1ebc2768bfd7f3e" translate="yes" xml:space="preserve">
          <source>Whenever you move the mouse, this example checks whether the cursor is in the stroke of an elliptical &lt;code&gt;Path2D&lt;/code&gt; path. If yes, the ellipse's stroke becomes green, otherwise it is red.</source>
          <target state="translated">마우스를 움직일 때마다이 예제는 커서가 타원형 &lt;code&gt;Path2D&lt;/code&gt; 경로 의 획에 있는지 확인합니다 . 그렇다면 타원의 획이 녹색이되고 그렇지 않으면 빨간색이됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0d6636dc2bf750351fbd92bd9e1b711132900a" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; is a &lt;a href=&quot;../batterymanager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; object, and &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/chargingchange&quot;&gt;chargingchange&lt;/a&gt;&lt;/code&gt; event occurs.</source>
          <target state="translated">어디 &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; A는 &lt;a href=&quot;../batterymanager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; 의&lt;/a&gt; 객체 및 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 때 호출하는 기능입니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/chargingchange&quot;&gt;chargingchange&lt;/a&gt;&lt;/code&gt; 의 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d36f0ff60574ff33b5a7a3e045701e8a6594f836" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; is a &lt;a href=&quot;../batterymanager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; object, and &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/chargingtimechange&quot;&gt;chargingtimechange&lt;/a&gt;&lt;/code&gt; event occurs.</source>
          <target state="translated">여기서 &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; 는 &lt;a href=&quot;../batterymanager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt; 객체이고 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/chargingtimechange&quot;&gt;chargingtimechange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생할 때 호출되는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="9041a88cefdc3d77196d7812a51677ca7177b77b" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; is a &lt;a href=&quot;../batterymanager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; object, and &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dischargingtimechange&quot;&gt;dischargingtimechange&lt;/a&gt;&lt;/code&gt; event occurs.</source>
          <target state="translated">여기서 &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; 는 &lt;a href=&quot;../batterymanager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt; 객체이고 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dischargingtimechange&quot;&gt;dischargingtimechange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생할 때 호출되는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="78e2d2de85cc3ccfef3a5b8e8a619265bd75004d" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; is a &lt;a href=&quot;../batterymanager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; object, and &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/levelchange&quot;&gt;levelchange&lt;/a&gt;&lt;/code&gt; event occurs.</source>
          <target state="translated">여기서 &lt;code&gt;&lt;em&gt;battery&lt;/em&gt;&lt;/code&gt; 는 &lt;a href=&quot;../batterymanager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt; 객체이고 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/levelchange&quot;&gt;levelchange&lt;/a&gt;&lt;/code&gt; 이벤트가 발생할 때 호출되는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="5a4eee02f3f097ff38a344dee19eb455de207db0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicelight&quot;&gt;devicelight&lt;/a&gt;&lt;/code&gt; event occurs. These events are of type &lt;a href=&quot;../devicelightevent&quot;&gt;&lt;code&gt;DeviceLightEvent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어디 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 때 호출하는 기능입니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicelight&quot;&gt;devicelight&lt;/a&gt;&lt;/code&gt; 의 이벤트가 발생이. 이러한 이벤트는 &lt;a href=&quot;../devicelightevent&quot;&gt; &lt;code&gt;DeviceLightEvent&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="855d6e97dd06c760bfc54cd0834a5b596826c2ff" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; is a function to be called when the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/deviceproximity&quot;&gt;deviceproximity&lt;/a&gt;&lt;/code&gt; event occurs. These events are of type &lt;a href=&quot;../deviceproximityevent&quot;&gt;&lt;code&gt;DeviceProximityEvent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어디 &lt;code&gt;&lt;em&gt;funcRef&lt;/em&gt;&lt;/code&gt; 는 때 호출하는 기능입니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/deviceproximity&quot;&gt;deviceproximity&lt;/a&gt;&lt;/code&gt; 의 이벤트가 발생이. 이러한 이벤트는 &lt;a href=&quot;../deviceproximityevent&quot;&gt; &lt;code&gt;DeviceProximityEvent&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="35ac77582d7c567f16c6980afcf32505c256f5d2" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;funcRef&lt;/code&gt; is a reference to a function.</source>
          <target state="translated">여기서 &lt;code&gt;funcRef&lt;/code&gt; 는 함수에 대한 참조이다.</target>
        </trans-unit>
        <trans-unit id="1761a310ddf608c0f04bd115e2a97e1741cb1a59" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;funcRef&lt;/code&gt; is a reference to a function. This function receives a &lt;a href=&quot;../devicemotionevent&quot;&gt;&lt;code&gt;DeviceMotionEvent&lt;/code&gt;&lt;/a&gt; object describing the motion that occurred.</source>
          <target state="translated">여기서 &lt;code&gt;funcRef&lt;/code&gt; 는 함수에 대한 참조이다. 이 함수는 발생한 모션을 설명 하는 &lt;a href=&quot;../devicemotionevent&quot;&gt; &lt;code&gt;DeviceMotionEvent&lt;/code&gt; &lt;/a&gt; 객체를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="9b95aebddef29decaeb051575dfedfcbd4106ac8" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;width&lt;/code&gt; is a string representing the width in number of pixels or as a percentage value.</source>
          <target state="translated">여기서 &lt;code&gt;width&lt;/code&gt; 는 너비를 픽셀 수 또는 백분율 값으로 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3285d96d1174e09478c085d5c0d23acce0ac2ef4" translate="yes" xml:space="preserve">
          <source>Where is the data stored?</source>
          <target state="translated">데이터는 어디에 저장됩니까?</target>
        </trans-unit>
        <trans-unit id="7467fe8dfca0de5a7e53e1ad793bbdec24383169" translate="yes" xml:space="preserve">
          <source>Where it matters for WebRTC purposes, these are dealt with in a variety of places within the WebRTC infrastructure. For example, RTCP handles QoS monitoring.</source>
          <target state="translated">WebRTC 목적에 중요한 경우, WebRTC 인프라 내의 다양한 위치에서 처리됩니다. 예를 들어 RTCP는 QoS 모니터링을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="91a87fb79d960cece8f96056c2af6befa24f1c98" translate="yes" xml:space="preserve">
          <source>Where p and a are the tags which are used in HTML for paragraph and link, respectively and they can be replaced by identifiers which are used for Cues in WebVTT file.</source>
          <target state="translated">여기서 p와 a는 각각 단락과 링크에 HTML로 사용되는 태그이며 WebVTT 파일의 큐에 사용되는 식별자로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fddbe0cb10eaa8b4994516f5b590fa1ffe7d04b6" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;parent&quot;&gt;&lt;code&gt;window.parent&lt;/code&gt;&lt;/a&gt; property returns the immediate parent of the current window, &lt;code&gt;window.top&lt;/code&gt; returns the topmost window in the hierarchy of window objects.</source>
          <target state="translated">&lt;a href=&quot;parent&quot;&gt; &lt;code&gt;window.parent&lt;/code&gt; 의&lt;/a&gt; 속성은 현재 윈도우의 바로 위 부모를 반환 &lt;code&gt;window.top&lt;/code&gt; 의 창 개체의 계층 구조에서 반환 최상위 창을여십시오.</target>
        </trans-unit>
        <trans-unit id="9033ce8d21ed06b1408ca216cffa39cc3f095102" translate="yes" xml:space="preserve">
          <source>Where the components are defined as follows:</source>
          <target state="translated">구성 요소가 다음과 같이 정의 된 위치 :</target>
        </trans-unit>
        <trans-unit id="574e95b6d8efa0022fbdde2c832cda5a47026661" translate="yes" xml:space="preserve">
          <source>Whereas the &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt; element's composed path is a follows:</source>
          <target state="translated">반면 &lt;code&gt;&amp;lt;closed-shadow&amp;gt;&lt;/code&gt; 요소의 합성 경로는 다음이다 :</target>
        </trans-unit>
        <trans-unit id="4711f67e3cc0bb19d232e4c530869b9832f09b6a" translate="yes" xml:space="preserve">
          <source>Whether a device uses hardware or software decoding impacts how smooth and power efficient the video decoding is and how efficient the playback will be. The Media Capabilities API enables determining which codecs are supported and how performant a media file will be both in terms of smoothness and power efficiency.</source>
          <target state="translated">장치가 하드웨어 또는 소프트웨어 디코딩을 사용하는지 여부는 비디오 디코딩이 얼마나 매끄럽고 전력 효율적이며 재생 효율성에 영향을줍니다. 미디어 기능 API를 사용하면 지원되는 코덱과 미디어 파일의 성능 및 부드러움 및 전력 효율성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0210f3057e96b2243ad943c8728ce49f3f1ec69" translate="yes" xml:space="preserve">
          <source>Whether an event can be canceled or not is something that's determined when that event is initialized.</source>
          <target state="translated">이벤트를 취소 할 수 있는지 여부는 해당 이벤트가 초기화 될 때 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="22a49a142295885bf2698e17d4e6b3207f89d2a5" translate="yes" xml:space="preserve">
          <source>Whether the animation runs forwards (&lt;code&gt;normal&lt;/code&gt;), backwards (&lt;code&gt;reverse&lt;/code&gt;), switches direction after each iteration (&lt;code&gt;alternate&lt;/code&gt;), or runs backwards and switches direction after each iteration (&lt;code&gt;alternate-reverse&lt;/code&gt;). Defaults to &lt;code&gt;&quot;normal&quot;&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 앞으로 실행되는지 ( &lt;code&gt;normal&lt;/code&gt; ) 뒤로 이동 하는지 ( &lt;code&gt;reverse&lt;/code&gt; ), 반복 할 때마다 방향을 전환 하거나 ( &lt;code&gt;alternate&lt;/code&gt; ), 반복 할 때마다 뒤로 이동하고 방향을 전환 할 것인지 ( &lt;code&gt;alternate-reverse&lt;/code&gt; ) 기본값은 &lt;code&gt;&quot;normal&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1395955c5a2548d4a30efb6327390af52ac0ea32" translate="yes" xml:space="preserve">
          <source>Whether the mouse coordinates are within a particular area on the canvas, is a common problem to solve. The hit region API allows you to define an area of your canvas and provides another possibility to expose interactive content on a canvas to accessibility tools. It allows you to make hit detection easier and lets you route events to DOM elements. The API has the following three methods (which are still experimental in current web browsers; check the browser compatibility tables).</source>
          <target state="translated">마우스 좌표가 캔버스의 특정 영역 내에 있는지 여부는 일반적인 문제입니다. 적중 영역 API를 사용하면 캔버스 영역을 정의하고 캔버스의 대화 형 컨텐츠를 내게 필요한 옵션 도구에 노출 할 수 있습니다. 적중 감지를보다 쉽게하고 이벤트를 DOM 요소로 라우트 할 수 있습니다. API에는 다음 세 가지 방법이 있습니다 (현재 웹 브라우저에서 아직 실험 중이며 브라우저 호환성 표를 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="a750597dbe2dc313c41aabb70b3b34b1d1884551" translate="yes" xml:space="preserve">
          <source>Which array &lt;code&gt;forEach()&lt;/code&gt; is being applied to.</source>
          <target state="translated">적용 할 &lt;code&gt;forEach()&lt;/code&gt; 배열 .</target>
        </trans-unit>
        <trans-unit id="2fa608cfd082a248a72feb1d19024301841e78f2" translate="yes" xml:space="preserve">
          <source>Which is exactly the same as the &lt;code&gt;(z + 1) * scaleFactor&lt;/code&gt; that we used in the previous example.</source>
          <target state="translated">이전 예제에서 사용한 &lt;code&gt;(z + 1) * scaleFactor&lt;/code&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9c325461434f28b91467db739ce54f53cecbbcde" translate="yes" xml:space="preserve">
          <source>Which must be greater than the start time</source>
          <target state="translated">시작 시간보다 커야합니다</target>
        </trans-unit>
        <trans-unit id="22aa7b656b3bc7c7d0b959e574f102d7aab0f495" translate="yes" xml:space="preserve">
          <source>Which of the two functions, &lt;code&gt;onsuccess()&lt;/code&gt; or &lt;code&gt;onerror()&lt;/code&gt;, gets called? If everything succeeds, a success event (that is, a DOM event whose &lt;code&gt;type&lt;/code&gt; property is set to &lt;code&gt;&quot;success&quot;&lt;/code&gt;) is fired with &lt;code&gt;request&lt;/code&gt; as its &lt;code&gt;target&lt;/code&gt;. Once it is fired, the &lt;code&gt;onsuccess()&lt;/code&gt; function on &lt;code&gt;request&lt;/code&gt; is triggered with the success event as its argument. Otherwise, if there was any problem, an error event (that is, a DOM event whose &lt;code&gt;type&lt;/code&gt; property is set to &lt;code&gt;&quot;error&quot;&lt;/code&gt;) is fired at &lt;code&gt;request&lt;/code&gt;. This triggers the &lt;code&gt;&lt;code&gt;onerror()&lt;/code&gt;&lt;/code&gt; function with the error event as its argument.</source>
          <target state="translated">&lt;code&gt;onsuccess()&lt;/code&gt; 또는 &lt;code&gt;onerror()&lt;/code&gt; 중 어떤 함수 가 호출됩니까? 모든 성공하면, (이다, 누구는 DOM 이벤트 성공 이벤트 &lt;code&gt;type&lt;/code&gt; 속성에 설정되어있는 &lt;code&gt;&quot;success&quot;&lt;/code&gt; )와 해고 &lt;code&gt;request&lt;/code&gt; 는 같은 &lt;code&gt;target&lt;/code&gt; . 일단 실행되면 &lt;code&gt;request&lt;/code&gt; &lt;code&gt;onsuccess()&lt;/code&gt; 함수 가 성공 이벤트를 인수로 사용하여 트리거됩니다. 어떤 문제가 발생했을 경우 그렇지 않으면, (이다, 누구는 DOM 이벤트 오류 이벤트 &lt;code&gt;type&lt;/code&gt; 속성에 설정되어있는 &lt;code&gt;&quot;error&quot;&lt;/code&gt; )에서 발사되는 &lt;code&gt;request&lt;/code&gt; . 오류 이벤트를 인수로 하여 &lt;code&gt;&lt;code&gt;onerror()&lt;/code&gt;&lt;/code&gt; 함수를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="c6e6f3689e2ba49330864598266c50c96132a904" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;addEventListener()&lt;/code&gt; will let you add the same listener more than once for the same type if the options are different, the only option &lt;code&gt;removeEventListener()&lt;/code&gt; checks is the &lt;code&gt;capture&lt;/code&gt;/&lt;code&gt;useCapture&lt;/code&gt; flag. Its value must match for &lt;code&gt;removeEventListener()&lt;/code&gt; to match, but the other values don't.</source>
          <target state="translated">옵션이 다른 경우 &lt;code&gt;addEventListener()&lt;/code&gt; 를 사용하면 동일한 유형에 대해 동일한 리스너를 두 번 이상 추가 할 수 있지만 &lt;code&gt;removeEventListener()&lt;/code&gt; 검사 옵션 만 &lt;code&gt;capture&lt;/code&gt; / &lt;code&gt;useCapture&lt;/code&gt; 플래그입니다. &lt;code&gt;removeEventListener()&lt;/code&gt; 가 일치 하도록 값이 일치해야 하지만 다른 값은 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1ad5174754f314bfbceffd519c9479861a974d5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;self.skipWaiting()&lt;/code&gt; can be called at any point during the service worker's execution, it will only have an effect if there's a newly installed service worker that might otherwise remain in the &lt;code&gt;waiting&lt;/code&gt; state. Therefore, it's common to call &lt;code&gt;self.skipWaiting()&lt;/code&gt; from inside of an &lt;a href=&quot;../installevent&quot;&gt;&lt;code&gt;InstallEvent&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">하지만 &lt;code&gt;self.skipWaiting()&lt;/code&gt; 서비스 노동자의 실행 중에 언제든지 호출 할 수 있습니다 그렇지 않으면 남아있을 수 있습니다 새로 설치 서비스 작업자가 있다면, 그것은 단지 영향을 미칠 것이다 &lt;code&gt;waiting&lt;/code&gt; 상태입니다. 따라서 &lt;a href=&quot;../installevent&quot;&gt; &lt;code&gt;InstallEvent&lt;/code&gt; &lt;/a&gt; 핸들러 내부에서 &lt;code&gt;self.skipWaiting()&lt;/code&gt; 을 호출하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="58b29086e504954a8dc55b56aaafed1688c8d4a5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;textContent&lt;/code&gt; gets the content of all elements, including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, &lt;code&gt;innerText&lt;/code&gt; does not, only showing &amp;ldquo;human-readable&amp;rdquo; elements.</source>
          <target state="translated">&lt;code&gt;textContent&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 포함한 모든 요소의 내용을 가져 오는 반면 &lt;code&gt;innerText&lt;/code&gt; 는 &quot;사람이 읽을 수있는&quot;요소 만 표시하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1677d5cb2e08363d28b42f87c2956814a4aa4b6c" translate="yes" xml:space="preserve">
          <source>While RTP is intended for use in latency-critical scenarios, it doesn't inherently offer any features that ensure QoS. Instead, it only offers the information necessary to allow QoS to be implemented elsewhere in the stack.</source>
          <target state="translated">RTP는 대기 시간이 긴 시나리오에서 사용하기위한 것이지만 본질적으로 QoS를 보장하는 기능을 제공하지는 않습니다. 대신 스택의 다른 곳에서 QoS를 구현하는 데 필요한 정보 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="01b5afbf41773c3c75e65b325870d18afd092ed1" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;../vrdisplay&quot;&gt;&lt;code&gt;VRDisplay&lt;/code&gt;&lt;/a&gt; is blurred it does not lose it&amp;rsquo;s presenting status (&lt;a href=&quot;../vrdisplay/ispresenting&quot;&gt;&lt;code&gt;VRDisplay.isPresenting&lt;/code&gt;&lt;/a&gt; continues to report &lt;code&gt;true&lt;/code&gt;) but &lt;a href=&quot;../vrdisplay/getframedata&quot;&gt;&lt;code&gt;VRDisplay.getFrameData()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; without updating the provided &lt;a href=&quot;../vrframedata&quot;&gt;&lt;code&gt;VRFrameData&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/getPose&quot;&gt;&lt;code&gt;VRDisplay.getPose()&lt;/code&gt;&lt;/a&gt; returns a &lt;a href=&quot;../vrpose&quot;&gt;&lt;code&gt;VRPose&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;null&lt;/code&gt; members.</source>
          <target state="translated">&lt;a href=&quot;../vrdisplay&quot;&gt; &lt;code&gt;VRDisplay&lt;/code&gt; &lt;/a&gt; 가 흐려지는 동안 현재 상태 ( &lt;a href=&quot;../vrdisplay/ispresenting&quot;&gt; &lt;code&gt;VRDisplay.isPresenting&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 계속보고 함 )를 &lt;a href=&quot;../vrdisplay/getframedata&quot;&gt; &lt;code&gt;VRDisplay.getFrameData()&lt;/code&gt; &lt;/a&gt; 않지만 VRDisplay.getFrameData () 는 제공된 &lt;a href=&quot;../vrframedata&quot;&gt; &lt;code&gt;VRFrameData&lt;/code&gt; &lt;/a&gt; 를 업데이트하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/getPose&quot;&gt; &lt;code&gt;VRDisplay.getPose()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;null&lt;/code&gt; 멤버 와 함께 &lt;a href=&quot;../vrpose&quot;&gt; &lt;code&gt;VRPose&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aed3e1ed6ba05d0bd2deb652db96e58b8fbc306e" translate="yes" xml:space="preserve">
          <source>While creating a CustomEvent object, you must create the object from the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XUL/window&quot;&gt;window&lt;/a&gt;. The &lt;code&gt;detail&lt;/code&gt; attribute of your CustomEvent will be subjected to the same restrictions. String and Array values will be readable by the content without restrictions, but custom Objects will not. While using a custom Object, you will need to define the attributes of that object that are readable from the content script using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/&quot;&gt;Components.utils.cloneInto()&lt;/a&gt;.</source>
          <target state="translated">CustomEvent 객체를 만드는 동안 동일한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/XUL/window&quot;&gt;창&lt;/a&gt; 에서 객체를 만들어야합니다 . CustomEvent 의 &lt;code&gt;detail&lt;/code&gt; 속성에도 동일한 제한이 적용됩니다. 문자열 및 배열 값은 제한없이 컨텐츠에서 읽을 수 있지만 사용자 정의 오브젝트는 읽을 수 없습니다. 사용자 정의 객체를 사용하는 동안 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/&quot;&gt;Components.utils.cloneInto ()를&lt;/a&gt; 사용하여 컨텐츠 스크립트에서 읽을 수있는 해당 객체의 속성을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b78b9ed44c178f4579608dc427ab472e6c6b06b" translate="yes" xml:space="preserve">
          <source>While handling an asynchronous request, the value of &lt;code&gt;responseText&lt;/code&gt; always has the current content received from the server, even if it's incomplete because the data has not been completely received yet.</source>
          <target state="translated">비동기 요청을 처리하는 동안 &lt;code&gt;responseText&lt;/code&gt; 값은 데이터가 아직 완전히 수신되지 않아서 불완전하더라도 서버에서 수신 한 현재 컨텐츠를 항상 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a90e109a6a6f027b28c605504e9754ef85c08a1d" translate="yes" xml:space="preserve">
          <source>While iframes work by default, &quot;sandboxed&quot; iframes block Pointer lock. The ability to avoid this limitation, in the form of the attribute/value combination &lt;code&gt;&amp;lt;iframe sandbox=&quot;allow-pointer-lock&quot;&amp;gt;&lt;/code&gt;, is expected to appear in Chrome soon.</source>
          <target state="translated">iframe은 기본적으로 작동하지만 &quot;샌드 박스&quot;iframe은 포인터 잠금을 차단합니다. 속성 / 값 조합 &lt;code&gt;&amp;lt;iframe sandbox=&quot;allow-pointer-lock&quot;&amp;gt;&lt;/code&gt; 의 형식으로이 제한을 피하는 기능 은 곧 Chrome에 나타날 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ee9cf3cfba692860032328902f2f45d9229ca6" translate="yes" xml:space="preserve">
          <source>While information about a user's cameras and microphones are inaccessible for privacy reasons, an application can request the camera and microphone capabilities it needs and wants, using additional constraints. The following expresses a preference for 1280x720 camera resolution:</source>
          <target state="translated">개인 정보 보호를 위해 사용자의 카메라 및 마이크에 대한 정보에 액세스 할 수 없지만 응용 프로그램은 추가 제약 조건을 사용하여 필요한 카메라 및 마이크 기능을 요청할 수 있습니다. 다음은 1280x720 카메라 해상도에 대한 기본 설정을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bf401a186baf2c5f165729ade6c02a73c539e5c" translate="yes" xml:space="preserve">
          <source>While slightly painful when initially working with scalable 2D graphics, paying attention to the pixel grid and the position of paths ensures that your drawings will look correct regardless of scaling or any other transformations involved. A 1.0-width vertical line drawn at the correct position will become a crisp 2-pixel line when scaled up by 2, and will appear at the correct position.</source>
          <target state="translated">처음에 확장 가능한 2D 그래픽으로 작업 할 때 약간 고통 스럽지만 픽셀 격자와 경로 위치에주의를 기울이면 스케일링이나 기타 변형에 관계없이 도면이 올바르게 보일 수 있습니다. 올바른 위치에 그려진 1.0 너비 세로선은 2 씩 확대되면 선명한 2 픽셀 선이되고 올바른 위치에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8e42a26e3e14767ec938e2efc79ed1a212618720" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/browsing-the-web.html#abort-a-document&quot;&gt;standard for aborting a document load&lt;/a&gt; is defined, &lt;a href=&quot;https://github.com/whatwg/html/issues/3525&quot;&gt;HTML issue #3525&lt;/a&gt; suggests that browsers do not currently fire the &quot;abort&quot; event on &lt;code&gt;window&lt;/code&gt; that would trigger &lt;code&gt;onabort&lt;/code&gt; to be called.</source>
          <target state="translated">그동안 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/browsing-the-web.html#abort-a-document&quot;&gt;문서 부하를 중단 표준을&lt;/a&gt; 정의, &lt;a href=&quot;https://github.com/whatwg/html/issues/3525&quot;&gt;HTML 문제 # 3525는&lt;/a&gt; 브라우저가 현재 &quot;취소&quot;에 이벤트가 발생하지 않는 것을 제안 &lt;code&gt;window&lt;/code&gt; 발생하게됩니다 &lt;code&gt;onabort&lt;/code&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35cf1e475b7bded5eb2a8c85006f09a919173abe" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;label&quot;&gt;&lt;code&gt;label&lt;/code&gt;&lt;/a&gt; property doesn't have to be unique, this ID number is guaranteed to be unique among all data channels. Additionally, known implementations of WebRTC use the same ID on both peers. A unique ID makes it easier for your code to do its own out-of-band data channel-related signaling.</source>
          <target state="translated">&lt;a href=&quot;label&quot;&gt; &lt;code&gt;label&lt;/code&gt; &lt;/a&gt; 속성은 고유하지 않아도 되지만 이 ID 번호는 모든 데이터 채널에서 고유해야합니다. 또한 알려진 WebRTC 구현은 두 피어에서 동일한 ID를 사용합니다. 고유 한 ID를 사용하면 코드에서 자체 대역 외 데이터 채널 관련 신호를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e31addbffe614238773279550765fdb4361122e" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;ArrayBuffer&lt;/code&gt; can be filled with both integers and floats, the attributes will always be converted to a float when they are sent to the vertex shader. If you need to use integers in your vertex shader code, you can either cast the float back to an integer in the vertex shader (e.g. &lt;code&gt;(int) floatNumber&lt;/code&gt;), or use &lt;a href=&quot;../webgl2renderingcontext/vertexattribipointer&quot;&gt;&lt;code&gt;gl.vertexAttribIPointer()&lt;/code&gt;&lt;/a&gt; from WebGL2.</source>
          <target state="translated">&lt;code&gt;ArrayBuffer&lt;/code&gt; 는 정수와 부동 소수점으로 채워질 수 있지만 속성은 꼭 정점 셰이더로 보내질 때 항상 부동 소수점으로 변환됩니다. 정점 셰이더 코드에서 정수를 사용해야하는 경우, 부동 소수점을 정점 셰이더의 정수 (예 : &lt;code&gt;(int) floatNumber&lt;/code&gt; )로 다시 캐스팅 하거나 &lt;a href=&quot;../webgl2renderingcontext/vertexattribipointer&quot;&gt; &lt;code&gt;gl.vertexAttribIPointer()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a20f42a68e5aecf135d2ea686e7f9f1237921a3" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;AudioParam&lt;/code&gt; named &lt;code&gt;offset&lt;/code&gt; is read-only, the &lt;code&gt;value&lt;/code&gt; property within is not. So you can change the value of &lt;code&gt;offset&lt;/code&gt; by setting the value of &lt;code&gt;ConstantSourceNode.offset.value&lt;/code&gt;:</source>
          <target state="translated">이름 이 &lt;code&gt;AudioParam&lt;/code&gt; 인 &lt;code&gt;offset&lt;/code&gt; 은 읽기 전용이지만 &lt;code&gt;value&lt;/code&gt; 속성은 아닙니다. 따라서 &lt;code&gt;ConstantSourceNode.offset.value&lt;/code&gt; 값을 설정하여 &lt;code&gt;offset&lt;/code&gt; 값을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97a5fb8cfae9e9a388d84f10512d99ad5f83304b" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;createWriter()&lt;/code&gt; method existed, it immediately called &lt;code&gt;errorCallback&lt;/code&gt; with the &lt;code&gt;NS_ERROR_DOM_SECURITY_ERR&lt;/code&gt; error.</source>
          <target state="translated">&lt;code&gt;createWriter()&lt;/code&gt; 메소드가 존재 하는 동안 &lt;code&gt;NS_ERROR_DOM_SECURITY_ERR&lt;/code&gt; 오류 와 함께 &lt;code&gt;errorCallback&lt;/code&gt; 을 즉시 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="d37f7320e358b7e65dbf5f9cd612fb8b1f3dc4fc" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;removeRecursively()&lt;/code&gt; method existed, it immediately called the error callback with &lt;code&gt;NS_ERROR_DOM_SECURITY_ERR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;removeRecursively()&lt;/code&gt; 메소드가 존재 하는 동안 &lt;code&gt;NS_ERROR_DOM_SECURITY_ERR&lt;/code&gt; 을 사용 하여 오류 콜백을 즉시 호출했습니다 .</target>
        </trans-unit>
        <trans-unit id="bdebc4b3b3ef8b054b9215aa56ac45c65438bd54" translate="yes" xml:space="preserve">
          <source>While the WebRTC &lt;a href=&quot;http://www.w3.org/TR/webrtc/&quot;&gt;specification&lt;/a&gt; is relatively stable, not all browsers have fully implemented all of its features. In addition, some browsers still have prefixes on some or all WebRTC APIs. While you can manually code around these issues, there is an easier way. The WebRTC organization &lt;a href=&quot;https://github.com/webrtc/adapter/&quot;&gt;provides on GitHub the WebRTC adapter&lt;/a&gt; to work around compatibility issues in different browsers' WebRTC implementations. The adapter is a JavaScript shim which lets your code to be written to the specification so that it will &quot;just work&quot; in all browsers with WebRTC support. There's no need to conditionally use prefixed APIs or implement other workarounds.</source>
          <target state="translated">WebRTC &lt;a href=&quot;http://www.w3.org/TR/webrtc/&quot;&gt;사양&lt;/a&gt; 은 비교적 안정적이지만 모든 브라우저가 모든 기능을 완전히 구현 한 것은 아닙니다. 또한 일부 브라우저에는 여전히 일부 또는 모든 WebRTC API에 접두사가 있습니다. 이러한 문제를 수동으로 코딩 할 수는 있지만 더 쉬운 방법이 있습니다. WebRTC 조직 &lt;a href=&quot;https://github.com/webrtc/adapter/&quot;&gt;은 GitHub에서 WebRTC 어댑터&lt;/a&gt; 를 제공하여 다른 브라우저의 WebRTC 구현에서 호환성 문제를 해결할 수 있습니다. 어댑터는 JavaScript shim으로 WebRTC를 지원하는 모든 브라우저에서 &quot;작동&quot;할 수 있도록 사양에 코드를 작성할 수 있습니다. 조건부 접두사 API를 사용하거나 다른 해결 방법을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6787ba606a042d3b7fd034b3cf383efa8cb8b89c" translate="yes" xml:space="preserve">
          <source>While the WebRTC &lt;a href=&quot;https://www.w3.org/TR/webrtc/&quot;&gt;specification&lt;/a&gt; is relatively stable, not all browsers have fully implemented all of its features. In addition, some browsers still have prefixes on some or all WebRTC APIs. While you can manually code around these issues, there is an easier way. The WebRTC organization &lt;a href=&quot;https://github.com/webrtc/adapter/&quot;&gt;provides on GitHub the WebRTC adapter&lt;/a&gt; to work around compatibility issues in different browsers' WebRTC implementations. The adapter is a JavaScript shim which lets your code to be written to the specification so that it will &quot;just work&quot; in all browsers with WebRTC support. There's no need to conditionally use prefixed APIs or implement other workarounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cad4644fa34e0054b44bf1d4207b28ebb5ac7d" translate="yes" xml:space="preserve">
          <source>While the article Using the MediaStream Recording API demonstrates using the &lt;a href=&quot;../mediarecorder&quot;&gt;&lt;code&gt;MediaRecorder&lt;/code&gt;&lt;/a&gt; interface to capture a &lt;a href=&quot;../mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt; generated by a hardware device, as returned by &lt;a href=&quot;../mediadevices/getusermedia&quot;&gt;&lt;code&gt;navigator.mediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt;, you can also use an HTML media element (namely &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt;) as the source of the &lt;code&gt;MediaStream&lt;/code&gt; to be recorded. In this article, we'll look at an example that does just that.</source>
          <target state="translated">&lt;a href=&quot;../mediadevices/getusermedia&quot;&gt; &lt;code&gt;navigator.mediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 에서 리턴 한대로 MediaStream 레코딩 API 사용 기사는 &lt;a href=&quot;../mediarecorder&quot;&gt; &lt;code&gt;MediaRecorder&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 하드웨어 디바이스에 의해 생성 된 &lt;a href=&quot;../mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 을 캡처하는 방법을 설명하지만 HTML 매체 요소 (예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; )를 기록 할 &lt;code&gt;MediaStream&lt;/code&gt; 의 소스로 지정하십시오 . 이 기사에서는이를 수행하는 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="797b382246f26d1255a1cfed6292ce9f609e0c65" translate="yes" xml:space="preserve">
          <source>While the published specification describes this as an interface, it has since been changed to a dictionary in follow-up drafts.</source>
          <target state="translated">게시 된 사양은이를 인터페이스로 설명하지만 그 이후 후속 초안에서 사전으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="feb6f214a2ac495b564c14534cad54174d2e6d80" translate="yes" xml:space="preserve">
          <source>While there's other CSS involved in this example, tparh that really matters for our purposes is the CSS that styles the &lt;code&gt;&quot;box&quot;&lt;/code&gt; element that we'll be animating. That CSS looks like this:</source>
          <target state="translated">이 예제에는 다른 CSS가 포함되어 있지만 실제로 목적에 중요한 tparh는 애니메이션을 적용 할 &lt;code&gt;&quot;box&quot;&lt;/code&gt; 요소의 스타일을 지정하는 CSS입니다 . 해당 CSS는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f983776633f57cc6691d5d3fb869bba846d4d8b" translate="yes" xml:space="preserve">
          <source>While this article uses CSS3 for the ease of explanations, matrices are a core concept used by many different technologies including WebGL and shaders. This article is also available as an &lt;a href=&quot;https://github.com/TatumCreative/mdn-matrix-math&quot;&gt;MDN content kit&lt;/a&gt;. The live examples use a collection of &lt;a href=&quot;https://github.com/TatumCreative/mdn-webgl&quot;&gt;utility functions&lt;/a&gt; availabile under a global object named &quot;MDN&quot;.</source>
          <target state="translated">이 기사에서는 설명을 쉽게하기 위해 CSS3을 사용하지만 매트릭스는 WebGL 및 셰이더를 포함한 많은 다른 기술에서 사용되는 핵심 개념입니다. 이 기사는 &lt;a href=&quot;https://github.com/TatumCreative/mdn-matrix-math&quot;&gt;MDN 컨텐츠 키트&lt;/a&gt; 로도 제공됩니다 . 라이브 예제 는 &quot;MDN&quot;이라는 전역 객체에서 사용 가능한 &lt;a href=&quot;https://github.com/TatumCreative/mdn-webgl&quot;&gt;유틸리티 함수&lt;/a&gt; 모음을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="de434f88a34e3c3a64dc0c79d1ce2d9a8963ab73" translate="yes" xml:space="preserve">
          <source>While this example is trivial, you can replace the simple output of &quot;Supported&quot; vs. &quot;Not supported&quot; with code to provide alternative methods for presenting the audiovisual information you want to share with the user or otherwise work with.</source>
          <target state="translated">이 예제는 사소한 것이지만 &quot;지원됨&quot;과 &quot;지원되지 않음&quot;의 간단한 출력을 코드로 대체하여 사용자와 공유하거나 다른 방법으로 작업하려는 시청각 정보를 제시하는 대체 방법을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73391f9feabc77b6f8f917fb779ffda3f8fa05b7" translate="yes" xml:space="preserve">
          <source>While this happens, the previous version is still responsible for fetches. The new version is installing in the background. We are calling the new cache &lt;code&gt;v2&lt;/code&gt;, so the previous &lt;code&gt;v1&lt;/code&gt; cache isn't disturbed.</source>
          <target state="translated">이 경우에도 이전 버전은 여전히 ​​페치를 담당합니다. 새 버전이 백그라운드에서 설치 중입니다. 새 캐시 &lt;code&gt;v2&lt;/code&gt; 를 호출 하므로 이전 &lt;code&gt;v1&lt;/code&gt; 캐시가 방해받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bfa65f684f8b28bb7488c726fd58c21e5193aa7" translate="yes" xml:space="preserve">
          <source>While this is an extremely simple example, imagine having a 32 oscillator synthesizer with multiple linked parameters in play across a number of patched nodes. Being able to shorten the number of operations to adjust them all will prove invaluable for code size and performance both.</source>
          <target state="translated">이것은 매우 간단한 예이지만 여러 패치 된 노드에서 여러 개의 연결된 파라미터가있는 32 개의 오실레이터 신시사이저가 있다고 상상해보십시오. 모든 작업을 조정하기 위해 작업 수를 단축 할 수 있으면 코드 크기와 성능 모두에서 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="15445e729aa96a028be12f8eeb34097c920be46d" translate="yes" xml:space="preserve">
          <source>While using document.evaluate() works in FF2, in FF3 one must use someXMLDoc.evaluate() if evaluating against something other than the current document.</source>
          <target state="translated">FF2에서 document.evaluate ()가 작동하는 동안 FF3에서는 현재 문서 이외의 다른 것에 대해 평가하는 경우 someXMLDoc.evaluate ()를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f232a5ab3a83a44a1e973dbaef1ca3af873e08e9" translate="yes" xml:space="preserve">
          <source>While vertex attributes are usually used to specify values which are different for each vertex (using &lt;a href=&quot;vertexattribpointer&quot;&gt;&lt;code&gt;vertexAttribPointer&lt;/code&gt;&lt;/a&gt;), it can be useful to specify a constant value. For example, if you have a shader which has a &lt;code&gt;color&lt;/code&gt; vertex attribute, but you want to draw everything in a single color, you can use &lt;code&gt;vertexAttrib&lt;/code&gt; to achieve that without creating a buffer filled with only one value or having to create a separate shader which uses a uniform for the color.</source>
          <target state="translated">정점 속성은 일반적으로 각 정점마다 다른 값을 지정하는 데 사용 &lt;a href=&quot;vertexattribpointer&quot;&gt; &lt;code&gt;vertexAttribPointer&lt;/code&gt; &lt;/a&gt; ( vertexAttribPointer 사용 ) 상수 값을 지정하는 것이 유용 할 수 있습니다. 예를 들어, &lt;code&gt;color&lt;/code&gt; 정점 속성 이있는 셰이더가 있지만 모든 것을 단일 색상으로 그리려면 &lt;code&gt;vertexAttrib&lt;/code&gt; 을 사용 하여 하나의 값으로 채워진 버퍼를 만들거나 별도의 셰이더를 만들지 않고도이를 달성 할 수 있습니다. 색상에 유니폼을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9735502472fb8645f3f3ce406fb7680c8d1a15b4" translate="yes" xml:space="preserve">
          <source>While we can write CSS Animations with the Web Animations API, where the API really comes in handy is manipulating the animation&amp;rsquo;s playback. The Web Animations API provides several useful methods for controlling playback. Let&amp;rsquo;s take a look at pausing and playing animations in the Growing/Shrinking Alice game (check out the &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ&quot;&gt;full code on Codepen&lt;/a&gt;):</source>
          <target state="translated">Web Animations API로 CSS 애니메이션을 작성할 수 있지만 API가 실제로 유용한 곳은 애니메이션의 재생을 조작하는 것입니다. Web Animations API는 재생을 제어하는 ​​몇 가지 유용한 방법을 제공합니다. Alice의 Growing / Shrinking Alice 게임에서 애니메이션 일시 정지 및 재생을 살펴 보겠습니다 ( &lt;a href=&quot;http://codepen.io/rachelnabors/pen/PNYGZQ&quot;&gt;Codepen&lt;/a&gt; 의 전체 코드 확인 ).</target>
        </trans-unit>
        <trans-unit id="cae912e54b7746f546892f38cc1a0efc0b468087" translate="yes" xml:space="preserve">
          <source>While we can write CSS Animations with the Web Animations API, where the API really comes in handy is manipulating the animation&amp;rsquo;s playback. The Web Animations API provides several useful methods for controlling playback. Let&amp;rsquo;s take a look at pausing and playing animations in the Growing/Shrinking Alice game (check out the &lt;a href=&quot;https://codepen.io/rachelnabors/pen/PNYGZQ&quot;&gt;full code on Codepen&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad808409f9233584eacb6f81aba6de2f8b0666c2" translate="yes" xml:space="preserve">
          <source>While working on your Web Audio API code, you may find that you need tools to analyze the graph of nodes you create or to otherwise debug your work. This article discusses tools available to help you do that.</source>
          <target state="translated">Web Audio API 코드에서 작업하는 동안 생성 한 노드의 그래프를 분석하거나 작업을 디버깅하는 도구가 필요할 수 있습니다. 이 기사에서는이를 수행하는 데 도움이되는 도구에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1affea20cdd4173ba4ba9192dd973a33d5530c24" translate="yes" xml:space="preserve">
          <source>While you can just &lt;a href=&quot;https://github.com/mdn/samples-server/tree/master/s/webrtc-simple-datachannel/main.js&quot;&gt;look at the code itself on GitHub&lt;/a&gt;, below we'll review the parts of the code that do the heavy lifting.</source>
          <target state="translated">방금 수 있지만 &lt;a href=&quot;https://github.com/mdn/samples-server/tree/master/s/webrtc-simple-datachannel/main.js&quot;&gt;GitHub의에 코드 자체를 보면&lt;/a&gt; , 아래 우리는 무거운 할 코드의 부분을 검토합니다.</target>
        </trans-unit>
        <trans-unit id="9d622eb69a5875a65853870e99381ca1c9e10477" translate="yes" xml:space="preserve">
          <source>While you should instead use the CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/border-spacing&quot;&gt;&lt;code&gt;border-spacing&lt;/code&gt;&lt;/a&gt; property, the obsolete &lt;a href=&quot;../htmltableelement&quot;&gt;&lt;code&gt;HTMLTableElement&lt;/code&gt;&lt;/a&gt; interface's &lt;code&gt;&lt;strong&gt;cellSpacing&lt;/strong&gt;&lt;/code&gt; property represents the spacing around the individual &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th&quot;&gt;&lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td&quot;&gt;&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/a&gt; elements representing a table's cells. Any two cells are separated by the sum of the &lt;code&gt;cellSpacing&lt;/code&gt; of each of the two cells.</source>
          <target state="translated">대신 CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/border-spacing&quot;&gt; &lt;code&gt;border-spacing&lt;/code&gt; &lt;/a&gt; 속성 을 사용해야하지만 사용 되지 않는 &lt;a href=&quot;../htmltableelement&quot;&gt; &lt;code&gt;HTMLTableElement&lt;/code&gt; &lt;/a&gt; 인터페이스의 &lt;code&gt;&lt;strong&gt;cellSpacing&lt;/strong&gt;&lt;/code&gt; 속성은 테이블의 셀을 나타내는 개별 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th&quot;&gt; &lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td&quot;&gt; &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 주위의 간격을 나타냅니다. 두 세포의 합으로 분리 &lt;code&gt;cellSpacing&lt;/code&gt; 두 셀의 각.</target>
        </trans-unit>
        <trans-unit id="f110937a31794d7af371747f9b664d4615df8d41" translate="yes" xml:space="preserve">
          <source>Why does WebVR have its own requestAnimationFrame()?</source>
          <target state="translated">WebVR에 자체 requestAnimationFrame ()이있는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c6ddafdf36167a3465e231aba3ea6cd469e4d8dd" translate="yes" xml:space="preserve">
          <source>Why is my service worker failing to register?</source>
          <target state="translated">서비스 담당자가 등록하지 못하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d7208f97a187e41a0f79c932e9258d95ba937eab" translate="yes" xml:space="preserve">
          <source>Why matrices are important</source>
          <target state="translated">행렬이 중요한 이유</target>
        </trans-unit>
        <trans-unit id="930bf7e073fccab7f3f3f6f189b150f8ac14c0fb" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;addEventListener&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;addEventListener&lt;/code&gt; 를 사용하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="9ffeed44a345e5f320b12d679f8b1d74979925fe" translate="yes" xml:space="preserve">
          <source>Why use Beacon?</source>
          <target state="translated">왜 비콘을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="fbe7cc3ca81e30d0c2df2fb6ddd130b17a5108d1" translate="yes" xml:space="preserve">
          <source>Why, you may wonder, is something fundamental to the process of establishing a WebRTC connection left out of the specification? The answer is simple: since the two devices have no way to directly contact each other, and the specification can&amp;rsquo;t predict every possible use case for WebRTC, it makes more sense to let the developer select an appropriate networking technology and messaging protocol.</source>
          <target state="translated">왜 사양에서 벗어난 WebRTC 연결을 설정하는 과정에서 근본적인 것이 궁금할까요? 대답은 간단합니다. 두 장치가 서로 직접 연락 할 방법이없고 사양이 WebRTC의 가능한 모든 사용 사례를 예측할 수 없기 때문에 개발자가 적절한 네트워킹 기술 및 메시징 프로토콜을 선택하도록하는 것이 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="812eda1ec8a8550c1241c997b5510e45c2853039" translate="yes" xml:space="preserve">
          <source>WiFi Information API</source>
          <target state="translated">WiFi 정보 API</target>
        </trans-unit>
        <trans-unit id="82718d060967c684aa0c9faae3fa0070ecd6bea3" translate="yes" xml:space="preserve">
          <source>WiFi P2P API</source>
          <target state="translated">WiFi P2P API</target>
        </trans-unit>
        <trans-unit id="783c82091a962d6967bbaf9053f242f2256a974f" translate="yes" xml:space="preserve">
          <source>WiFi Tethering API</source>
          <target state="translated">WiFi 테 더링 API</target>
        </trans-unit>
        <trans-unit id="1642f118c8b0528714d276f4650abfce53ee0d45" translate="yes" xml:space="preserve">
          <source>Width (in pixels) of the browser window viewport including, if rendered, the vertical scrollbar.</source>
          <target state="translated">렌더링 된 경우 세로 스크롤 막대를 포함하여 브라우저 창 뷰포트의 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="6ed6746e16e9da7f183eb810cc239f5eb028a623" translate="yes" xml:space="preserve">
          <source>Width and height</source>
          <target state="translated">폭과 높이</target>
        </trans-unit>
        <trans-unit id="04517969e4e88b6ac77e48991dd3507a4b32fdc6" translate="yes" xml:space="preserve">
          <source>Width and height must be multiples of 4.</source>
          <target state="translated">너비와 높이는 4의 배수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c32471fdfcc936eaef45f672707805517f43a478" translate="yes" xml:space="preserve">
          <source>Width and height must be powers of 2.</source>
          <target state="translated">너비와 높이는 2의 거듭 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="adf48bc5d5aad8c317971b9e2c49d1baf4b4d0a7" translate="yes" xml:space="preserve">
          <source>Width of lines. Default &lt;code&gt;1.0&lt;/code&gt;</source>
          <target state="translated">선의 너비. 기본 &lt;code&gt;1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e6911ae8c2c39729fed25810c0c64aed59e4b53" translate="yes" xml:space="preserve">
          <source>Width of the rectangle to be painted. Defaults to the width of the image data.</source>
          <target state="translated">칠할 사각형의 너비입니다. 이미지 데이터의 너비가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f0b2f802b10ce4db36dd6d0609fc630e8c7ea5cb" translate="yes" xml:space="preserve">
          <source>Wikipedia article on B&amp;eacute;zier curves</source>
          <target state="translated">베 지어 곡선에 관한 Wikipedia 기사</target>
        </trans-unit>
        <trans-unit id="cacc40419d0e71d22493f603adeb315123597bdc" translate="yes" xml:space="preserve">
          <source>Will always be &lt;code&gt;'SensorErrorEvent'&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;'SensorErrorEvent'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c457525ac41d909f890bde5a63d11f13205d57cf" translate="yes" xml:space="preserve">
          <source>Will be stored in the array buffer as follows:</source>
          <target state="translated">다음과 같이 배열 버퍼에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="bb375493900031c658af955fbed577798f48ba2f" translate="yes" xml:space="preserve">
          <source>Will describe the color gamut, or the range of color, the screen can display (not currently supported anywhere).</source>
          <target state="translated">화면이 표시 할 수있는 색 영역 또는 색 범위를 설명합니다 (현재는 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="9932ab684ce0f7e2f7cf8d93016e7f5a37562a2d" translate="yes" xml:space="preserve">
          <source>Will describe the known luminance characteristics of the screen (not currently supported anywhere).</source>
          <target state="translated">화면의 알려진 휘도 특성을 설명합니다 (현재는 지원되지 않음).</target>
        </trans-unit>
        <trans-unit id="97b82711e660baa7cf3a85a7a46e0f3884daca1e" translate="yes" xml:space="preserve">
          <source>Will hold our &lt;a href=&quot;../intersectionobserver&quot;&gt;&lt;code&gt;IntersectionObserver&lt;/code&gt;&lt;/a&gt; used to track the intersection between the ads and the &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; element's bounds.</source>
          <target state="translated">광고와 &lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt; 요소의 경계 사이의 교차점을 추적하는 데 사용되는 &lt;a href=&quot;../intersectionobserver&quot;&gt; &lt;code&gt;IntersectionObserver&lt;/code&gt; 를&lt;/a&gt; 보유 합니다.</target>
        </trans-unit>
        <trans-unit id="410a70e773546db24768ac427861e4b752ec5155" translate="yes" xml:space="preserve">
          <source>Will hold the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; element which contains the time the ad has been visible so far.</source>
          <target state="translated">광고가 지금까지 표시된 시간을 포함 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a6580c3c1187e5dc9fdc06a7338a94d6e4571c" translate="yes" xml:space="preserve">
          <source>Will hold the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2&quot;&gt;&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;&lt;/a&gt; element representing the ad's title.</source>
          <target state="translated">광고 제목을 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2&quot;&gt; &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="e9bad46ef5286cdd60bef087b89ca4af12b8d41a" translate="yes" xml:space="preserve">
          <source>Will hold the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;/a&gt; representing the ad's body text.</source>
          <target state="translated">광고 본문을 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p&quot;&gt; &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="720f0131c6416ed9e457c366b630cd9b19bb0eae" translate="yes" xml:space="preserve">
          <source>Will log the time needed by the user to dismiss the alert box, log the time to the console, wait for the user to dismiss the second alert, and then log the ending time to the console:</source>
          <target state="translated">사용자가 경고 상자를 해제하고 콘솔에 시간을 기록한 다음 사용자가 두 번째 경고를 해제 할 때까지 기다린 다음 종료 시간을 콘솔에 기록하는 데 필요한 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="cb306168f02adeddcbd30194a965ee718444d3e3" translate="yes" xml:space="preserve">
          <source>Will throw a &lt;code&gt;NS_ERROR_DOM_INVALID_CHARACTER_ERR&lt;/code&gt; exception if one tries to submit the closing CDATA sequence (&quot;]]&amp;gt;&quot;) as part of the data, so unescaped user-provided data cannot be safely used without with this method getting this exception (&lt;code&gt;&lt;a href=&quot;createtextnode&quot;&gt;createTextNode()&lt;/a&gt;&lt;/code&gt; can often be used in its place).</source>
          <target state="translated">던져 것 &lt;code&gt;NS_ERROR_DOM_INVALID_CHARACTER_ERR&lt;/code&gt; 의 하나 개의 시도가 닫는 CDATA 순서를 제출하는 경우 데이터의 일부로서 ( &quot;]]&amp;gt;&quot;) 예외를, 그래서 이스케이프 사용자가 제공 한 데이터가 안전하게이 예외 (점점이 방법없이 사용할 수 없습니다 &lt;code&gt;&lt;a href=&quot;createtextnode&quot;&gt;createTextNode()&lt;/a&gt;&lt;/code&gt; 종종 있습니다 그 자리에 사용).</target>
        </trans-unit>
        <trans-unit id="5ac302cd37f782694646e0f66f5e065da2aaaeff" translate="yes" xml:space="preserve">
          <source>Will write to the console:</source>
          <target state="translated">콘솔에 쓸 것이다 :</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="6c058d9178cae138c823f18de3e8cd52c6d85cfd" translate="yes" xml:space="preserve">
          <source>Window events</source>
          <target state="translated">창 이벤트</target>
        </trans-unit>
        <trans-unit id="47044b57cd8f08779dff853e0bbb5e3e1f639acf" translate="yes" xml:space="preserve">
          <source>Window features</source>
          <target state="translated">창 특징</target>
        </trans-unit>
        <trans-unit id="d7834573ce9a2f9c71d41b38388fd8af273a3626" translate="yes" xml:space="preserve">
          <source>Window functionality features</source>
          <target state="translated">창 기능 기능</target>
        </trans-unit>
        <trans-unit id="847fd5b0e7d19b54f0ebf121df83ee37523e321d" translate="yes" xml:space="preserve">
          <source>Window.localStorage</source>
          <target state="translated">Window.localStorage</target>
        </trans-unit>
        <trans-unit id="e06553da442fe83bb81f9d16d444ebaf29427291" translate="yes" xml:space="preserve">
          <source>Window.postMessage</source>
          <target state="translated">Window.postMessage</target>
        </trans-unit>
        <trans-unit id="730be718e137a1c210a0ee0fe5c0e5f9c2de5cc0" translate="yes" xml:space="preserve">
          <source>WindowBase64.Base64 encoding and decoding</source>
          <target state="translated">WindowBase64.Base64 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="ad1e0b4c85449d1543b482c415e6853a319bc6be" translate="yes" xml:space="preserve">
          <source>WindowClient</source>
          <target state="translated">WindowClient</target>
        </trans-unit>
        <trans-unit id="9d6627e726b5cd54a1cdade14ee86172c35a6398" translate="yes" xml:space="preserve">
          <source>WindowClient.focus</source>
          <target state="translated">WindowClient.focus</target>
        </trans-unit>
        <trans-unit id="ec8da8acf8bd50ef4044dfab3009d325a98d632a" translate="yes" xml:space="preserve">
          <source>WindowClient.focused</source>
          <target state="translated">WindowClient.focused</target>
        </trans-unit>
        <trans-unit id="1718e9d8b2b7bfa5a3830b3afea61429c64a9927" translate="yes" xml:space="preserve">
          <source>WindowClient.navigate</source>
          <target state="translated">WindowClient.navigate</target>
        </trans-unit>
        <trans-unit id="414bb71b657edc2dbb3e1b5db8e46d07f3c53362" translate="yes" xml:space="preserve">
          <source>WindowClient.visibilityState</source>
          <target state="translated">WindowClient.visibilityState</target>
        </trans-unit>
        <trans-unit id="1a6e732a37845c36fcda3afa6f1ba0d920b0ebca" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers</source>
          <target state="translated">WindowEventHandlers</target>
        </trans-unit>
        <trans-unit id="e0d5cb550a45faff2b9506f4b1765ed96267e3d0" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onafterprint</source>
          <target state="translated">WindowEventHandlers.onafterprint</target>
        </trans-unit>
        <trans-unit id="db85a0101308193e4bd8f57371bfe0436c9b17e9" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onbeforeprint</source>
          <target state="translated">WindowEventHandlers.onbeforeprint</target>
        </trans-unit>
        <trans-unit id="e444d73e40f34442ebc5f8ee36601c99cefeed62" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onbeforeunload</source>
          <target state="translated">WindowEventHandlers.onbeforeunload</target>
        </trans-unit>
        <trans-unit id="f5a28eaed2e9a3c4e1935f2031b3f4db7f6edac5" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onhashchange</source>
          <target state="translated">WindowEventHandlers.onhashchange</target>
        </trans-unit>
        <trans-unit id="ca66e4b89923d5faa447ef489205809bbe8c39f8" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onlanguagechange</source>
          <target state="translated">WindowEventHandlers.onlanguagechange</target>
        </trans-unit>
        <trans-unit id="2b858c20f019e6dc8a0ccff83249f8d8755a39ec" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onmessage</source>
          <target state="translated">WindowEventHandlers.onmessage</target>
        </trans-unit>
        <trans-unit id="80407d07cac41a8f7d9ca0dbc6a431d605e997d2" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onmessageerror</source>
          <target state="translated">WindowEventHandlers.onmessageerror</target>
        </trans-unit>
        <trans-unit id="1e6db104f8269652f6af517cad59bddb8ab54bd8" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onpopstate</source>
          <target state="translated">WindowEventHandlers.onpopstate</target>
        </trans-unit>
        <trans-unit id="b5295ee0cadfbc9f05a94859c94f84fd25dc8090" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onrejectionhandled</source>
          <target state="translated">WindowEventHandlers.onrejectionhandled</target>
        </trans-unit>
        <trans-unit id="29b824c41f886a5eaa4aa169891d4c0c368c473c" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onstorage</source>
          <target state="translated">WindowEventHandlers.onstorage</target>
        </trans-unit>
        <trans-unit id="1cc5da3986b0d97b681eb258ee732cdbaa51cf68" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onunhandledrejection</source>
          <target state="translated">WindowEventHandlers.onunhandledrejection</target>
        </trans-unit>
        <trans-unit id="4ee3a8b6d5951c23c66f22e4e25378ec88fcc7af" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers.onunload</source>
          <target state="translated">WindowEventHandlers.onunload</target>
        </trans-unit>
        <trans-unit id="4695cae95157eec4a2f36b8710914191b7160a60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope</source>
          <target state="translated">WindowOrWorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="d763098d050b46b02a523444b14d83e6f520d9d4" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope mixin</source>
          <target state="translated">WindowOrWorkerGlobalScope 믹스 인</target>
        </trans-unit>
        <trans-unit id="097752d5e348c24d5a189c3ca9fab78d55edd767" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.atob</source>
          <target state="translated">WindowOrWorkerGlobalScope.atob</target>
        </trans-unit>
        <trans-unit id="efc90a4cc92535fec2b748e4d0c3139ab6e37dc1" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.btoa</source>
          <target state="translated">WindowOrWorkerGlobalScope.btoa</target>
        </trans-unit>
        <trans-unit id="3d20e90dd0a29c76ced115f916d7a14a46329a5e" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.caches</source>
          <target state="translated">WindowOrWorkerGlobalScope.caches</target>
        </trans-unit>
        <trans-unit id="7dd146554d30a2996c66fae533a3e3c64a8c7159" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.clearInterval</source>
          <target state="translated">WindowOrWorkerGlobalScope.clearInterval</target>
        </trans-unit>
        <trans-unit id="62bdc2ee357307721b13e63db237f52f659efe11" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.clearTimeout</source>
          <target state="translated">WindowOrWorkerGlobalScope.clearTimeout</target>
        </trans-unit>
        <trans-unit id="b5be5c80eb9dcc1f179f98df9281505a83260eac" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.createImageBitmap</source>
          <target state="translated">WindowOrWorkerGlobalScope.createImageBitmap</target>
        </trans-unit>
        <trans-unit id="2ca6e3e1ac96b6d84d852f89047da28707a24b60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.fetch</source>
          <target state="translated">WindowOrWorkerGlobalScope.fetch</target>
        </trans-unit>
        <trans-unit id="7cc7c43efcbd55a98bbced2e7dbf78253d2fa4e5" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.indexedDB</source>
          <target state="translated">WindowOrWorkerGlobalScope.indexedDB</target>
        </trans-unit>
        <trans-unit id="56962c266078a8dfca6eb0d27c27f1b8f74ec9a6" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.isSecureContext</source>
          <target state="translated">WindowOrWorkerGlobalScope.isSecureContext</target>
        </trans-unit>
        <trans-unit id="412904ea302f96e7e920b5afdf1e9c0dc1137495" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.origin</source>
          <target state="translated">WindowOrWorkerGlobalScope.origin</target>
        </trans-unit>
        <trans-unit id="7b2908b81e1bd458f36a12196a0149d1180c5c2c" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.setInterval</source>
          <target state="translated">WindowOrWorkerGlobalScope.setInterval</target>
        </trans-unit>
        <trans-unit id="20aa5c5c874ca192a5c0e6e9063131a2c6249f6e" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope.setTimeout</source>
          <target state="translated">WindowOrWorkerGlobalScope.setTimeout</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="deebb7cd337d6895afb7ebc103c7f94f9207cd40" translate="yes" xml:space="preserve">
          <source>Windows 32-bit</source>
          <target state="translated">Windows 32 비트</target>
        </trans-unit>
        <trans-unit id="9cdfc54cc3b508486d3c59faddc9ea935b42584b" translate="yes" xml:space="preserve">
          <source>Windows 64-bit (32-bit build)</source>
          <target state="translated">Windows 64 비트 (32 비트 빌드)</target>
        </trans-unit>
        <trans-unit id="2840441da35f1084b02fc6bd50f15074d123f5f4" translate="yes" xml:space="preserve">
          <source>Windows 64-bit (64-bit build)</source>
          <target state="translated">Windows 64 비트 (64 비트 빌드)</target>
        </trans-unit>
        <trans-unit id="ed4932a7d32c6b1177526419c99a7cb3119925da" translate="yes" xml:space="preserve">
          <source>Windows CE</source>
          <target state="translated">윈도우 CE</target>
        </trans-unit>
        <trans-unit id="336c28309e5afeb0c32155db22da77f63062ac51" translate="yes" xml:space="preserve">
          <source>Windows NT x.y</source>
          <target state="translated">Windows NT xy</target>
        </trans-unit>
        <trans-unit id="39f688fd5cdc12e1f9cfb5fdb1b6ddc424d6165f" translate="yes" xml:space="preserve">
          <source>Windows NT x.y; WOW64</source>
          <target state="translated">Windows NT xy; 와우 64</target>
        </trans-unit>
        <trans-unit id="84b88ff322a19609192efbdd1b51aaee788f69d8" translate="yes" xml:space="preserve">
          <source>Windows NT x.y; Win64; x64</source>
          <target state="translated">Windows NT xy; Win64; x64</target>
        </trans-unit>
        <trans-unit id="794350602423fad8a09162b1af95c325f2cea71b" translate="yes" xml:space="preserve">
          <source>Windows are subjected to throttling after 30 seconds, with the same throttling delay rules as specified for window timers (again, see &lt;a href=&quot;windoworworkerglobalscope/settimeout#Reasons_for_delays_longer_than_specified&quot;&gt;Reasons for delays longer than specified&lt;/a&gt;). In Chrome, this value is 10 seconds.</source>
          <target state="translated">Windows는 창 타이머에 대해 지정된 것과 동일한 제한 지연 규칙을 사용하여 30 초 후에 제한을받습니다 (다시 말하면 &lt;a href=&quot;windoworworkerglobalscope/settimeout#Reasons_for_delays_longer_than_specified&quot;&gt;지정된 지연 시간보다 긴 지연 이유&lt;/a&gt; 참조 ). Chrome에서이 값은 10 초입니다.</target>
        </trans-unit>
        <trans-unit id="947f52a223f8d1c40cbde62959f38d0c2399e825" translate="yes" xml:space="preserve">
          <source>Windows support was enabled in Firefox 55.</source>
          <target state="translated">Firefox 55에서 Windows 지원이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce5ccaad45e0b5f1fdae7ce25be2d15c9913d784" translate="yes" xml:space="preserve">
          <source>WindowsCE x.y&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">WindowsCE xy &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="b08b8379a55e1493f146e03b1df5f8c29cf0dad7" translate="yes" xml:space="preserve">
          <source>Wiring this up is the same as we've seen before. We create the &lt;a href=&quot;../biquadfilternode&quot;&gt;&lt;code&gt;BiquadFilterNode&lt;/code&gt;&lt;/a&gt;, configure the properties we want for it and connect it through our graph. Different types of biquad filters have different properties &amp;mdash; for instance setting the frequency on a bandpass type adjusts the middle frequency, however on a lowpass it would set the top frequency.</source>
          <target state="translated">이 배선은 이전에 본 것과 동일합니다. &lt;a href=&quot;../biquadfilternode&quot;&gt; &lt;code&gt;BiquadFilterNode&lt;/code&gt; 를&lt;/a&gt; 생성하고 원하는 속성을 구성한 후 그래프를 통해 연결합니다. 예를 들어 대역 통과 유형에서 주파수를 설정하면 중간 주파수가 조정되지만 저역 통과에서는 최고 주파수가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e59274a3f1b62379fb3b23d357e01ab5b9203b2f" translate="yes" xml:space="preserve">
          <source>Wiring up our controls</source>
          <target state="translated">컨트롤 배선</target>
        </trans-unit>
        <trans-unit id="11912a273673cc3dbd7f8d8470a2f28603227b0a" translate="yes" xml:space="preserve">
          <source>Wiring up out control buttons is comparatively simple &amp;mdash; now we can listen for a mouse event on our controls and run this function, as well as stop it when the mouse is released:</source>
          <target state="translated">컨트롤 버튼의 배선은 비교적 간단합니다. 이제 컨트롤에서 마우스 이벤트를 수신하고이 기능을 실행하고 마우스를 놓을 때 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="587941514c3c716b9903ba75d1411936906c3587" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;webglrenderingcontext/scissor&quot;&gt;&lt;code&gt;scissor()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;webglrenderingcontext/clear&quot;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/a&gt; we can demonstrate how the WebGL drawing buffer is affected by the size of the canvas.</source>
          <target state="translated">함께 &lt;a href=&quot;webglrenderingcontext/scissor&quot;&gt; &lt;code&gt;scissor()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;webglrenderingcontext/clear&quot;&gt; &lt;code&gt;clear()&lt;/code&gt; &lt;/a&gt; 우리는 WebGL을 그리기 버퍼가 캔버스의 크기에 의해 영향을받는 방법을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4034675f295cb5f3e8e6fdc87d027df0afb718b" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;globalAlpha&lt;/code&gt; applied this sets how shapes and images are drawn onto the existing bitmap.</source>
          <target state="translated">함께 &lt;code&gt;globalAlpha&lt;/code&gt; 도형 및 이미지 기존 비트 맵에 그리는 방식이 세트를 적용 하였다.</target>
        </trans-unit>
        <trans-unit id="33042f6c0abb01a45c937d2e32999ac38c5e3e93" translate="yes" xml:space="preserve">
          <source>With Media Source Extensions (MSE), this is changing. MSE allows us to replace the usual single track &lt;code&gt;src&lt;/code&gt; value fed to media elements with a reference to a &lt;code&gt;MediaSource&lt;/code&gt; object, which is a container for information like the ready state of the media for being played, and references to multiple &lt;code&gt;SourceBuffer&lt;/code&gt; objects that represent the different chunks of media that make up the entire stream. MSE gives us finer grained control over how much and how often content is fetched, and some control over memory usage details, such as when buffers are evicted. It lays the groundwork for adaptive bitrate streaming clients (such as those using DASH or HLS) to be built on its extensible API.</source>
          <target state="translated">MSE (Media Source Extensions)에서는 이와 같이 변화하고 있습니다. MSE는 우리가 평소 단선 대체 할 수 &lt;code&gt;src&lt;/code&gt; (A)에 대한 참조 미디어 요소에 공급되는 값 &lt;code&gt;MediaSource&lt;/code&gt; 의 배수로 재생중인 대한 매체의 준비 상태와 같은 정보를위한 컨테이너 객체 및 참조 &lt;code&gt;SourceBuffer&lt;/code&gt; 의 다른을 나타내는 개체 전체 스트림을 구성하는 미디어 덩어리. MSE는 컨텐츠를 얼마나 많이 그리고 얼마나 자주 가져 오는지를보다 세밀하게 제어하고 버퍼가 제거 될 때와 같은 메모리 사용 세부 사항을 제어합니다. 확장 가능한 API를 기반으로하는 적응 형 비트 전송률 스트리밍 클라이언트 (예 : DASH 또는 HLS를 사용하는 클라이언트)를위한 토대를 마련합니다.</target>
        </trans-unit>
        <trans-unit id="123c426ce26786c920eff725894b3adae3c6b111" translate="yes" xml:space="preserve">
          <source>With Streams being available to JavaScript, this all changes &amp;mdash; you can now start processing raw data with JavaScript bit by bit as soon as it is available on the client-side, without needing to generate a buffer, string, or blob.</source>
          <target state="translated">Streams를 JavaScript로 사용할 수있게되면이 모든 것이 변경됩니다. 이제 버퍼, 문자열 또는 블로 브를 생성 할 필요없이 클라이언트 측에서 JavaScript로 원시 데이터를 비트 단위로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="622e96cbd1a045b478716e13976a9a20bdac74dd" translate="yes" xml:space="preserve">
          <source>With animations, use &lt;a href=&quot;../../window/requestanimationframe&quot;&gt;&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;../../windoworworkerglobalscope/setinterval&quot;&gt;&lt;code&gt;window.setInterval()&lt;/code&gt;&lt;/a&gt; .</source>
          <target state="translated">애니메이션에서는 &lt;a href=&quot;../../windoworworkerglobalscope/setinterval&quot;&gt; &lt;code&gt;window.setInterval()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../window/requestanimationframe&quot;&gt; &lt;code&gt;window.requestAnimationFrame()&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0585d73f5f04985cc96e7e4fc8ca2277bcc28ca2" translate="yes" xml:space="preserve">
          <source>With chrome privileges, the property is read-write, otherwise it is read-only. Bear in mind that if you try to set this property without chrome privileges, it will not throw an exception and instead just silently fail. This is to prevent scripts designed to set this property in Internet Explorer from breaking.</source>
          <target state="translated">크롬 권한을 사용하면 속성이 읽기 / 쓰기이고 그렇지 않은 경우 읽기 전용입니다. 크롬 권한없이이 속성을 설정하려고하면 예외가 발생하지 않고 대신 자동으로 실패합니다. 이는 Internet Explorer에서이 속성을 설정하도록 설계된 스크립트가 손상되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="75db5ee23b5a65f08162a3cce882d3bcd3e6d83d" translate="yes" xml:space="preserve">
          <source>With each new circle, the opacity of the previous circles underneath is effectively increased. If we were to increase the step count (and thus draw more circles), the background would eventually disappear completely from the center of the image.</source>
          <target state="translated">각각의 새로운 원으로, 이전 원의 불투명도가 효과적으로 증가합니다. 걸음 수를 늘려서 더 많은 원을 그리면 배경이 이미지 중앙에서 완전히 사라집니다.</target>
        </trans-unit>
        <trans-unit id="58d6fd5a66be936878dc30d2be42354e8d08fffb" translate="yes" xml:space="preserve">
          <source>With our presentation request successful, we now want to start setting up to render content to present to the VRDisplay. First of all we set the canvas to the same size as the VR display area. We do this by getting the &lt;a href=&quot;../vreyeparameters&quot;&gt;&lt;code&gt;VREyeParameters&lt;/code&gt;&lt;/a&gt; for both eyes using &lt;a href=&quot;../vrdisplay/geteyeparameters&quot;&gt;&lt;code&gt;VRDisplay.getEyeParameters()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프레젠테이션 요청이 성공적으로 완료되면 이제 콘텐츠를 렌더링하여 VRDisplay에 표시하도록 설정을 시작하려고합니다. 우선 캔버스를 VR 표시 영역과 동일한 크기로 설정했습니다. &lt;a href=&quot;../vrdisplay/geteyeparameters&quot;&gt; &lt;code&gt;VRDisplay.getEyeParameters()&lt;/code&gt; &lt;/a&gt; 사용하여 두 눈에 대한 &lt;a href=&quot;../vreyeparameters&quot;&gt; &lt;code&gt;VREyeParameters&lt;/code&gt; &lt;/a&gt; 를 가져 와서이 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="475c638ecca2e0aa5deab71cece409d7616d19c9" translate="yes" xml:space="preserve">
          <source>With service workers, the following steps are generally observed for basic set up:</source>
          <target state="translated">서비스 작업자의 경우 일반적으로 기본 설정을 위해 다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef018c89bac5a1f15c8d985b4c3db2ebf523806" translate="yes" xml:space="preserve">
          <source>With some payment handlers (e.g., Apple Pay), dispatched whenever the user changes payment instrument, like switching from a credit card to a debit card.</source>
          <target state="translated">일부 결제 처리기 (예 : Apple Pay)를 사용하면 신용 카드에서 직불 카드로 전환하는 등 사용자가 결제 수단을 변경할 때마다 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b2cee01555913708425f8b4d2d83591aa39ba9" translate="yes" xml:space="preserve">
          <source>With some payment handlers (e.g., Apple Pay), this event handler is called to handle the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/merchantvalidation&quot;&gt;merchantvalidation&lt;/a&gt;&lt;/code&gt; event, which is dispatched when the user agent requires that the merchant validate that the merchant or vendor requesting payment is legitimate.</source>
          <target state="translated">일부 지불 처리기 (예를 들어, 애플 유료)로,이 이벤트 핸들러는 처리하기 위해 호출됩니다 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/merchantvalidation&quot;&gt;merchantvalidation&lt;/a&gt;&lt;/code&gt; 의 사용자 에이전트가 상인 또는 공급 업체가 지불을 요구하는 상인의 validate가 합법적해야 할 때 전달되는 이벤트.</target>
        </trans-unit>
        <trans-unit id="283c8f301ff63a2a1b520c116d14517c3c3e3aab" translate="yes" xml:space="preserve">
          <source>With tabbed browsing, there is a reasonable chance that any given webpage is in the background and thus not visible to the user. The Page Visibility API provides events you can watch for to know when a document becomes visible or hidden, as well as features to look at the current visibility state of the page.</source>
          <target state="translated">탭 브라우징을 사용하면 지정된 웹 페이지가 백그라운드에있어 사용자에게 보이지 않을 가능성이 있습니다. 페이지 가시성 API는 문서의 현재 가시성 상태를 볼 수있는 기능뿐만 아니라 문서가 표시되거나 숨겨지는시기를 알 수있는 이벤트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f88bdd2d45f0f48ea15e71d299b791576eb1ed4" translate="yes" xml:space="preserve">
          <source>With that all in mind, let's take a look at the code to create an IIR filter with the Web Audio API.</source>
          <target state="translated">이를 염두에두고 Web Audio API를 사용하여 IIR 필터를 작성하는 코드를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="824f585c959f8f70672e6232e46d690305fb4be1" translate="yes" xml:space="preserve">
          <source>With that in hand, we set the &lt;a href=&quot;font&quot;&gt;&lt;code&gt;font&lt;/code&gt;&lt;/a&gt; to 50-pixel-tall &quot;serif&quot; (the user's default &lt;a href=&quot;https://en.wikipedia.org/wiki/serif&quot;&gt;serif&lt;/a&gt; font), then call &lt;code&gt;fillText()&lt;/code&gt; to draw the text &quot;Hello world,&quot; starting at the coordinates (50, 90).</source>
          <target state="translated">이를 사용하여 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;font&lt;/code&gt; &lt;/a&gt; 을 50 픽셀 높이의 &quot;serif&quot;(사용자의 기본 &lt;a href=&quot;https://en.wikipedia.org/wiki/serif&quot;&gt;serif&lt;/a&gt; 글꼴)로 설정 한 다음 &lt;code&gt;fillText()&lt;/code&gt; 를 호출 하여 좌표 (50, 90)에서 시작하여 &quot;Hello world&quot;라는 텍스트를 그립니다.</target>
        </trans-unit>
        <trans-unit id="04ea948dd70fbbf6b77fcd91951fefee88e0fd3f" translate="yes" xml:space="preserve">
          <source>With that in hand, we set the &lt;a href=&quot;font&quot;&gt;&lt;code&gt;font&lt;/code&gt;&lt;/a&gt; to 50-pixel-tall &quot;serif&quot; (the user's default &lt;a href=&quot;https://en.wikipedia.org/wiki/serif&quot;&gt;serif&lt;/a&gt; font), then call &lt;code&gt;strokeText()&lt;/code&gt; to draw the text &quot;Hello world,&quot; starting at the coordinates (50, 90).</source>
          <target state="translated">이를 사용하여 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;font&lt;/code&gt; &lt;/a&gt; 을 50 픽셀 높이의 &quot;serif&quot;(사용자의 기본 &lt;a href=&quot;https://en.wikipedia.org/wiki/serif&quot;&gt;serif&lt;/a&gt; 글꼴)로 설정 한 다음 &lt;code&gt;strokeText()&lt;/code&gt; 를 호출 하여 좌표 (50, 90)에서 시작하여 &quot;Hello world&quot;라는 텍스트를 그립니다.</target>
        </trans-unit>
        <trans-unit id="524dce0be1ce55ccc6b932d6f3166cabf9853e0c" translate="yes" xml:space="preserve">
          <source>With that key, we will be able to compute the &lt;em&gt;mac&lt;/em&gt; of the data.</source>
          <target state="translated">이 키를 사용 하여 데이터 의 &lt;em&gt;맥&lt;/em&gt; 을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81e3cc29ef214d7f001756261741ed56bf894b75" translate="yes" xml:space="preserve">
          <source>With the &quot;Include local directory pass when uploading files to a server&quot; option enabled, IE will change the filename inside the &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; on the fly. To have direct control of the sent filename, the developer should send the filename as the third parameter value, i.e. &lt;code&gt;formData.append(name, value, filename)&lt;/code&gt;.</source>
          <target state="translated">&quot;서버에 파일을 업로드 할 때 로컬 디렉토리 패스 포함&quot;옵션을 활성화하면 IE가 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 내부의 파일 이름을 즉시 변경합니다 . 전송 된 파일 이름을 직접 제어하려면 개발자는 파일 이름을 세 번째 매개 변수 값 (예 : &lt;code&gt;formData.append(name, value, filename)&lt;/code&gt; 으로 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b2bd2ea3acafa99b467b627258375ddc9ca19c7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragenter&quot;&gt;dragenter&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragover&quot;&gt;dragover&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; event, the &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt;&lt;code&gt;dropEffect&lt;/code&gt;&lt;/a&gt; property is initialized to the effect that the user is requesting. The user can modify the desired effect by pressing modifier keys. Although the exact keys used vary by platform, typically the Shift and Control keys would be used to switch between copying, moving, and linking. The mouse pointer will change to indicate which operation is desired; for instance, for a copy, the cursor might appear with a plus sign next to it.</source>
          <target state="translated">으로 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragenter&quot;&gt;dragenter&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragover&quot;&gt;dragover&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 행사, &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt; &lt;code&gt;dropEffect&lt;/code&gt; 를의&lt;/a&gt; 특성은 사용자가 요청하고 있다는 효과가 초기화된다. 사용자는 수정 자 키를 눌러 원하는 효과를 수정할 수 있습니다. 사용되는 정확한 키는 플랫폼마다 다르지만 일반적으로 Shift 및 Control 키는 복사, 이동 및 링크를 전환하는 데 사용됩니다. 마우스 포인터가 변경되어 원하는 작업을 나타냅니다. 예를 들어, 사본의 경우 커서 옆에 더하기 부호가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90dd4ea9efa94f11d39366b3dc421afbcde1b22b" translate="yes" xml:space="preserve">
          <source>With the IIRFIlter node it's up to you to set what &lt;code&gt;feedforward&lt;/code&gt; and &lt;code&gt;feedback&lt;/code&gt; values the filter needs &amp;mdash; this determines the characteristics of the filter. The downside is that this involves some complex maths.</source>
          <target state="translated">IIRFIlter 노드를 사용하면 필터에 필요한 &lt;code&gt;feedforward&lt;/code&gt; 및 &lt;code&gt;feedback&lt;/code&gt; 값 을 설정할 수 있습니다 . 이는 필터의 특성을 결정합니다. 단점은 복잡한 수학과 관련이 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c0e5e110d6fecbc0aa44994529f76d105b26872" translate="yes" xml:space="preserve">
          <source>With the Web Animations API, all you need to change is just one little property!</source>
          <target state="translated">Web Animations API를 사용하면 하나의 작은 속성 만 변경하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a85d0b6832368867becfacd793181be50c35ca7b" translate="yes" xml:space="preserve">
          <source>With the Web Animations API, we can move interactive animations from stylesheets to JavaScript, separating presentation from behavior. We no longer need to rely on DOM-heavy techniques such as writing CSS properties and scoping classes onto elements to control playback direction. And unlike pure, declarative CSS, JavaScript also lets us dynamically set values from properties to durations. For building custom animation libraries and creating interactive animations, the Web Animations API might be the perfect tool for the job. Let's see what it can do!</source>
          <target state="translated">Web Animations API를 사용하면 대화식 애니메이션을 스타일 시트에서 JavaScript로 이동하여 프리젠 테이션을 동작과 분리 할 수 ​​있습니다. 더 이상 재생 방향을 제어하기 위해 CSS 속성 작성 및 요소에 클래스 범위 지정과 같은 DOM이 많은 기술에 의존 할 필요가 없습니다. 순수하고 선언적인 CSS와 달리 JavaScript를 사용하면 속성에서 기간까지 값을 동적으로 설정할 수 있습니다. 사용자 정의 애니메이션 라이브러리를 작성하고 대화식 애니메이션을 작성하는 경우 Web Animations API가 작업에 완벽한 도구 일 수 있습니다. 그것이 무엇을 할 수 있는지 보자!</target>
        </trans-unit>
        <trans-unit id="a54e82323c0ae7c79ee68042b2e1bb2d7ca8fd44" translate="yes" xml:space="preserve">
          <source>With the association in place between the vertex buffer for our shape and the &lt;code&gt;aVertexPosition&lt;/code&gt; attribute used to deliver vertexes one by one into the vertex shader, we're ready to draw the shape by calling &lt;a href=&quot;../webglrenderingcontext/drawarrays&quot;&gt;&lt;code&gt;drawArrays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정점에 대한 정점 버퍼와 정점 셰이더에 정점을 하나씩 전달하는 데 사용되는 &lt;code&gt;aVertexPosition&lt;/code&gt; 속성 사이의 연결을 사용하면 &lt;a href=&quot;../webglrenderingcontext/drawarrays&quot;&gt; &lt;code&gt;drawArrays()&lt;/code&gt; &lt;/a&gt; 를 호출하여 모양을 그릴 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="55351da2e8fbca9c3979a774ef437b511c178f6e" translate="yes" xml:space="preserve">
          <source>With the association in place between the vertex buffer for our shape and the &lt;code&gt;aVertexPosition&lt;/code&gt; attribute used to deliver vertexes one by one into the vertex shader, we're ready to draw the shape by calling &lt;a href=&quot;drawarrays&quot;&gt;&lt;code&gt;drawArrays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정점에 대한 정점 버퍼와 정점 셰이더에 정점을 하나씩 전달하는 데 사용되는 &lt;code&gt;aVertexPosition&lt;/code&gt; 속성 사이의 연결을 사용하면 &lt;a href=&quot;drawarrays&quot;&gt; &lt;code&gt;drawArrays()&lt;/code&gt; &lt;/a&gt; 를 호출하여 모양을 그릴 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="372fac645750cd24a713bdd67eb92870c39ea0b9" translate="yes" xml:space="preserve">
          <source>With the built-in popup blockers of Mozilla/Firefox and Internet Explorer 6 SP2, you have to check the return value of &lt;code&gt;window.open()&lt;/code&gt;: it will be &lt;var&gt;null&lt;/var&gt; if the window wasn't allowed to open. However, for most other popup blockers, there is no reliable way.</source>
          <target state="translated">함께 내장 된 모질라 / 파이어 폭스와 인터넷 익스플로러 6 SP2의 팝업 차단, 당신의 반환 값을 확인해야 &lt;code&gt;window.open()&lt;/code&gt; :이 될 것 &lt;var&gt;null&lt;/var&gt; 창을 열도록 허용되지 않은 경우. 그러나 대부분의 다른 팝업 차단기에는 신뢰할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="16e542e1cdcc282a5a2d4bd8bc7d1a8cf7f93967" translate="yes" xml:space="preserve">
          <source>With the chunks encoded, we then call &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array/forEach&lt;/code&gt;&lt;/a&gt; on the resulting array. Inside this block we use &lt;a href=&quot;../writablestreamdefaultwriter/ready&quot;&gt;&lt;code&gt;WritableStreamDefaultWriter.ready&lt;/code&gt;&lt;/a&gt; to check whether the writer is ready to have another chunk written to it. &lt;code&gt;ready&lt;/code&gt; returns a promise that fulfills when this is the case, inside of which we call &lt;a href=&quot;../writablestreamdefaultwriter/write&quot;&gt;&lt;code&gt;WritableStreamDefaultWriter.write()&lt;/code&gt;&lt;/a&gt; to actually write the chunk to the stream. This also triggers the &lt;code&gt;write()&lt;/code&gt; method specified inside the &lt;code&gt;WritableStream()&lt;/code&gt; constructor, as discussed above.</source>
          <target state="translated">청크가 인코딩되면 결과 배열에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array/forEach&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 블록 내에서 &lt;a href=&quot;../writablestreamdefaultwriter/ready&quot;&gt; &lt;code&gt;WritableStreamDefaultWriter.ready&lt;/code&gt; &lt;/a&gt; 를 사용 하여 기록기에 다른 청크를 쓸 준비가되었는지 확인합니다. &lt;code&gt;ready&lt;/code&gt; 는이 경우에 이행하는 약속을 반환합니다. 내부에서 &lt;a href=&quot;../writablestreamdefaultwriter/write&quot;&gt; &lt;code&gt;WritableStreamDefaultWriter.write()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 실제로 청크를 스트림에 씁니다. 또한 위에서 설명한 것처럼 &lt;code&gt;WritableStream()&lt;/code&gt; 생성자 내에 지정된 &lt;code&gt;write()&lt;/code&gt; 메서드를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="5bb67e872994a46782754507025c87dd7ad6061a" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;../../canvasrenderingcontext2d/drawimage&quot;&gt;&lt;code&gt;drawImage()&lt;/code&gt;&lt;/a&gt; method, a second canvas and the &lt;a href=&quot;../../canvasrenderingcontext2d/imagesmoothingenabled&quot;&gt;&lt;code&gt;imageSmoothingEnabled&lt;/code&gt;&lt;/a&gt; property, we are able to zoom into our picture and see the details.</source>
          <target state="translated">의 도움으로 &lt;a href=&quot;../../canvasrenderingcontext2d/drawimage&quot;&gt; &lt;code&gt;drawImage()&lt;/code&gt; &lt;/a&gt; 방법, 두 번째 캔버스와 &lt;a href=&quot;../../canvasrenderingcontext2d/imagesmoothingenabled&quot;&gt; &lt;code&gt;imageSmoothingEnabled&lt;/code&gt; &lt;/a&gt; 재산, 우리는 우리의 사진을 확대하고 세부 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bef082f7c4f61bc5cbafc769bef716c244ef51d" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;../fontface&quot;&gt;&lt;code&gt;FontFace&lt;/code&gt;&lt;/a&gt; API, you can explicitly load fonts before using it in canvas.</source>
          <target state="translated">의 도움으로 &lt;a href=&quot;../fontface&quot;&gt; &lt;code&gt;FontFace&lt;/code&gt; 의&lt;/a&gt; API 명시 적으로 캔버스를 사용하기 전에 글꼴을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af46fc9bd78e3c73ec4e832eac2cbd0e2ebf0c9" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;webgl_lose_context&quot;&gt;&lt;code&gt;WEBGL_lose_context&lt;/code&gt;&lt;/a&gt; extension, you can simulate the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; events:</source>
          <target state="translated">&lt;a href=&quot;webgl_lose_context&quot;&gt; &lt;code&gt;WEBGL_lose_context&lt;/code&gt; &lt;/a&gt; 확장 의 도움으로 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; 이벤트를 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6326322bfbb8795b35ede077b61f6922dccb4109" translate="yes" xml:space="preserve">
          <source>With the help of this extension, privileged contexts are able to retrieve debugging information about about the user's graphic driver:</source>
          <target state="translated">이 확장의 도움으로 권한있는 컨텍스트는 사용자의 그래픽 드라이버에 대한 디버깅 정보를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c0612a2e28d43a1a66b95588c3d7754981bf08" translate="yes" xml:space="preserve">
          <source>With the help of this extension, you can now set the magnification or minification filter in the &lt;a href=&quot;webglrenderingcontext/texparameter&quot;&gt;&lt;code&gt;WebGLRenderingContext.texParameter()&lt;/code&gt;&lt;/a&gt; method to one of &lt;code&gt;gl.LINEAR&lt;/code&gt;, &lt;code&gt;gl.LINEAR_MIPMAP_NEAREST&lt;/code&gt;, &lt;code&gt;gl.NEAREST_MIPMAP_LINEAR&lt;/code&gt;, or &lt;code&gt;gl.LINEAR_MIPMAP_LINEAR&lt;/code&gt;, and use floating-point textures.</source>
          <target state="translated">이 확장을 사용하여 &lt;a href=&quot;webglrenderingcontext/texparameter&quot;&gt; &lt;code&gt;WebGLRenderingContext.texParameter()&lt;/code&gt; &lt;/a&gt; 메서드 의 확대 또는 축소 필터 를 &lt;code&gt;gl.LINEAR&lt;/code&gt; , &lt;code&gt;gl.LINEAR_MIPMAP_NEAREST&lt;/code&gt; , &lt;code&gt;gl.NEAREST_MIPMAP_LINEAR&lt;/code&gt; 또는 &lt;code&gt;gl.LINEAR_MIPMAP_LINEAR&lt;/code&gt; 중 하나로 설정 하고 부동 소수점 텍스처를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a933ce180c6fad4edba3fab29ef2f91d8cad459f" translate="yes" xml:space="preserve">
          <source>With the help of this extension, you can now set the magnification or minification filter in the &lt;a href=&quot;webglrenderingcontext/texparameter&quot;&gt;&lt;code&gt;WebGLRenderingContext.texParameter()&lt;/code&gt;&lt;/a&gt; method to one of &lt;code&gt;gl.LINEAR&lt;/code&gt;, &lt;code&gt;gl.LINEAR_MIPMAP_NEAREST&lt;/code&gt;, &lt;code&gt;gl.NEAREST_MIPMAP_LINEAR&lt;/code&gt;, or &lt;code&gt;gl.LINEAR_MIPMAP_LINEAR&lt;/code&gt;, and use half floating-point textures.</source>
          <target state="translated">이 확장을 사용하여 &lt;a href=&quot;webglrenderingcontext/texparameter&quot;&gt; &lt;code&gt;WebGLRenderingContext.texParameter()&lt;/code&gt; &lt;/a&gt; 메소드 의 확대 또는 축소 필터 를 &lt;code&gt;gl.LINEAR&lt;/code&gt; , &lt;code&gt;gl.LINEAR_MIPMAP_NEAREST&lt;/code&gt; , &lt;code&gt;gl.NEAREST_MIPMAP_LINEAR&lt;/code&gt; 또는 &lt;code&gt;gl.LINEAR_MIPMAP_LINEAR&lt;/code&gt; 중 하나로 설정 하고 반 부동 소수점을 사용할 수 있습니다 텍스처.</target>
        </trans-unit>
        <trans-unit id="2cc00bbddfb710fc0691818558c6fbcb71a5aa34" translate="yes" xml:space="preserve">
          <source>With the index of the vertex position attribute now available in &lt;code&gt;aVertexPosition&lt;/code&gt;, we call &lt;code&gt;enableVertexAttribArray()&lt;/code&gt; to enable the position attribute so it can be used by the shader program (in particular, by the vertex shader).</source>
          <target state="translated">이제 &lt;code&gt;aVertexPosition&lt;/code&gt; 에서 사용 가능한 정점 위치 속성의 색인을 사용하여 &lt;code&gt;enableVertexAttribArray()&lt;/code&gt; 를 호출 하여 위치 속성을 활성화하여 셰이더 프로그램 (특히 정점 셰이더)에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf64d3949733da974c20eedab6fd34b775c6a3e" translate="yes" xml:space="preserve">
          <source>With the key generator, the key would be generated automatically as you add the value to the object store. The current number of a key generator is always set to 1 when the object store for that key generator is first created. Basically the newly auto-generated key is increased by 1 based on the previous key. The current number for a key generator never decreases, other than as a result of database operations being reverted, for example, the database transaction is aborted. Therefore deleting a record or even clearing all records from an object store never affects the object store's key generator.</source>
          <target state="translated">키 생성기를 사용하면 값을 객체 저장소에 추가 할 때 키가 자동으로 생성됩니다. 해당 키 생성기의 오브젝트 저장소가 처음 작성 될 때 키 생성기의 현재 수는 항상 1로 설정됩니다. 기본적으로 새로 생성 된 키는 이전 키를 기준으로 1 씩 증가합니다. 키 생성기의 현재 수는 데이터베이스 작업이 복귀 된 결과 (예 : 데이터베이스 트랜잭션이 중단 된 결과)를 제외하고는 절대 감소하지 않습니다. 따라서 객체 저장소에서 레코드를 삭제하거나 모든 레코드를 지우더라도 객체 저장소의 키 생성기에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9456e13ad3bc20d9d10f3fdc696c591711a62371" translate="yes" xml:space="preserve">
          <source>With the structure of the site defined, we turn to the styling for the site. Let's look at the style for each component of the page individually.</source>
          <target state="translated">사이트의 구조가 정의되면 사이트의 스타일을 설정합니다. 페이지의 각 구성 요소에 대한 스타일을 개별적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c4766a07076583dc04214965503b8753a31349a4" translate="yes" xml:space="preserve">
          <source>With the target element in hand, we set the &lt;a href=&quot;../element/scrolltop&quot;&gt;&lt;code&gt;scrollTop&lt;/code&gt;&lt;/a&gt; of the frame's &lt;a href=&quot;../document/scrollingelement&quot;&gt;&lt;code&gt;scrollingElement&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/element/offsetTop&quot;&gt;&lt;code&gt;offsetTop&lt;/code&gt;&lt;/a&gt; of the target element. By doing so, we set the vertical scrolling position of the frame's document so that it's the same as the top edge of the target element.</source>
          <target state="translated">대상 요소를 손 으로 사용하여 프레임 &lt;a href=&quot;../document/scrollingelement&quot;&gt; &lt;code&gt;scrollingElement&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../element/scrolltop&quot;&gt; &lt;code&gt;scrollTop&lt;/code&gt; &lt;/a&gt; 을 대상 요소 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/element/offsetTop&quot;&gt; &lt;code&gt;offsetTop&lt;/code&gt; &lt;/a&gt; 으로 설정합니다. 이를 통해 대상 문서의 상단 가장자리와 동일하도록 프레임 문서의 세로 스크롤 위치를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e88e8622e274f1ebeb983438f7b26a2f87e8c5e7" translate="yes" xml:space="preserve">
          <source>With the user's permission through a prompt, turns on a camera or screensharing and/or a microphone on the system and provides a &lt;a href=&quot;mediastream&quot;&gt;&lt;code&gt;MediaStream&lt;/code&gt;&lt;/a&gt; containing a video track and/or an audio track with the input.</source>
          <target state="translated">프롬프트를 통한 사용자의 권한으로 시스템에서 카메라 또는 화면 공유 및 / 또는 마이크를 켜고 비디오 트랙 및 / 또는 오디오 트랙이 포함 된 &lt;a href=&quot;mediastream&quot;&gt; &lt;code&gt;MediaStream&lt;/code&gt; &lt;/a&gt; 을 입력과 함께 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1b468afcfdf19875b48968ca43a3849d0d8c0094" translate="yes" xml:space="preserve">
          <source>With the vertex data now provided to WebGL, we set &lt;code&gt;vertexNumComponents&lt;/code&gt; to the number of components in each vertex (2, since they're 2D vertexes) and &lt;code&gt;vertexCount&lt;/code&gt; to the number of vertexes in the vertex list.</source>
          <target state="translated">이제 정점 데이터가 WebGL에 제공되면 &lt;code&gt;vertexNumComponents&lt;/code&gt; 를 각 정점의 구성 요소 수 (2D 정점이므로 2)로 설정하고 &lt;code&gt;vertexCount&lt;/code&gt; 를 정점 목록의 정점 수로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e585e1993bc271947d97639b9e2d7bd6073ffa57" translate="yes" xml:space="preserve">
          <source>With these big concepts under our belts, we can get to more concrete stuff.</source>
          <target state="translated">벨트 아래에 이러한 큰 개념을 사용하면보다 구체적인 내용을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39f05fb2284f0bc47f94036cb08c4e0ffa2afcae" translate="yes" xml:space="preserve">
          <source>With these big concepts under our belts, we can get to more concrete stuff. For a tutorial on how to use the API, see &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/Using_IndexedDB&quot;&gt;Using IndexedDB&lt;/a&gt;.</source>
          <target state="translated">벨트 아래에 이러한 큰 개념을 사용하면보다 구체적인 내용을 얻을 수 있습니다. API 사용 방법에 대한 학습서는 &lt;a href=&quot;https://developer.mozilla.org/en/IndexedDB/Using_IndexedDB&quot;&gt;IndexedDB 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bd411077698f97ffa81e2a28c9b9e7871ccf888" translate="yes" xml:space="preserve">
          <source>With this code in place, each time the user plugs in a camera, microphone, or other media device, or turns one on or off, we call &lt;code&gt;updateDeviceList()&lt;/code&gt; to redraw the list of connected devices.</source>
          <target state="translated">이 코드를 사용하면 사용자가 카메라, 마이크 또는 기타 미디어 장치를 꽂거나 켜거나 끌 때마다 &lt;code&gt;updateDeviceList()&lt;/code&gt; 를 호출 하여 연결된 장치 목록을 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="5d0732cf9cfe5b4099e1505216e0992ca0bde3ae" translate="yes" xml:space="preserve">
          <source>With this code in place, the result looks like this:</source>
          <target state="translated">이 코드를 사용하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec0404607a980fd5b9cd16a3e85645b9a750988d" translate="yes" xml:space="preserve">
          <source>With this extension, you can simulate the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; events:</source>
          <target state="translated">이 확장을 사용하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; 이벤트를 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ea8709d1511ba3b03fccc2295c99744fe633cb" translate="yes" xml:space="preserve">
          <source>With this method, you can simulate the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; event:</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextlost&quot;&gt;webglcontextlost&lt;/a&gt;&lt;/code&gt; 이벤트를 시뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88f3f7c0e22ab6115c9f43ac1615342d428a4b14" translate="yes" xml:space="preserve">
          <source>With this method, you can simulate the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; event:</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/webglcontextrestored&quot;&gt;webglcontextrestored&lt;/a&gt;&lt;/code&gt; 이벤트를 시뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a884c64cfc571fd48023eb4273cf6f26af1099e" translate="yes" xml:space="preserve">
          <source>With this table in place, we can find out the frequency for a given note in a particular octave quite easily. If we want the frequency for the note G# in octave 1, we simply use &lt;code&gt;noteFreq[1][&quot;G#&quot;]&lt;/code&gt; and get the value 51.9 as a result.</source>
          <target state="translated">이 표를 사용하면 특정 옥타브에서 주어진 음표의 주파수를 매우 쉽게 찾을 수 있습니다. 옥타브 1에서 음표 G #의 주파수를 원한다면, 간단히 &lt;code&gt;noteFreq[1][&quot;G#&quot;]&lt;/code&gt; 를 사용하고 그 결과 값 51.9를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="892207f2edf7542576ac45a227a9c260fda91319" translate="yes" xml:space="preserve">
          <source>With those settings included it's time to directly draw to the screen using clip space coordinates.</source>
          <target state="translated">이러한 설정이 포함되면 클립 공간 좌표를 사용하여 화면에 직접 그릴 때입니다.</target>
        </trans-unit>
        <trans-unit id="aa4b5acb4cc342c42949520deb37509c671e5bee" translate="yes" xml:space="preserve">
          <source>With your video properly encoded and adaptive bitrate media generated, you're now ready to begin adaptive bitrate streaming on the web using DASH and MSE.</source>
          <target state="translated">비디오가 올바르게 인코딩되고 적응 형 비트 전송률 미디어가 생성되면 이제 DASH 및 MSE를 사용하여 웹에서 적응 형 비트 전송률 스트리밍을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc479cbff77863350a14cd5e5acd16377352285" translate="yes" xml:space="preserve">
          <source>Within a web page, there are certain cases where a default drag behavior is used. These include text selections, images, and links. When an image or link is dragged, the URL of the image or link is set as the drag data, and a drag begins. For other elements, they must be part of a selection for a default drag to occur. To see this in effect, select an area of a webpage, and then click and hold the mouse and drag the selection. An OS-specific rendering of the selection will appear and follow the mouse pointer as the drag occurs. However, this behavior is only the default drag behavior, if no listeners adjust the data to be dragged.</source>
          <target state="translated">웹 페이지에는 기본 끌기 동작이 사용되는 경우가 있습니다. 여기에는 텍스트 선택, 이미지 및 링크가 포함됩니다. 이미지 또는 링크를 드래그하면 이미지 또는 링크의 URL이 드래그 데이터로 설정되고 드래그가 시작됩니다. 다른 요소의 경우 기본 드래그가 발생하도록 선택의 일부 여야합니다. 이 기능을 보려면 웹 페이지 영역을 선택한 다음 마우스를 클릭 한 채로 선택 영역을 드래그하십시오. 선택 항목의 OS 별 렌더링이 나타나고 드래그가 발생할 때 마우스 포인터를 따라갑니다. 그러나 리스너가 드래그 할 데이터를 조정하지 않으면이 동작은 기본 드래그 동작입니다.</target>
        </trans-unit>
        <trans-unit id="fc43be0e00e924dacd3bb06a355176e423ada085" translate="yes" xml:space="preserve">
          <source>Within site CSS</source>
          <target state="translated">사이트 CSS 내</target>
        </trans-unit>
        <trans-unit id="f493720c0b682bbd7dc9d44627e0f89f05f4be75" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; events, you can check the &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt;&lt;code&gt;dropEffect&lt;/code&gt;&lt;/a&gt; property to determine which effect was ultimately chosen. If the chosen effect were &quot;move&quot;, then the original data should be removed from the source of the drag within the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; event.</source>
          <target state="translated">&lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이벤트 내에서 &lt;a href=&quot;../datatransfer/dropeffect&quot;&gt; &lt;code&gt;dropEffect&lt;/code&gt; &lt;/a&gt; 속성을 확인하여 궁극적으로 선택된 효과를 확인할 수 있습니다 . 선택한 효과가 &quot;이동&quot;이면 &lt;code&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/dragend&quot;&gt;dragend&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; 이벤트 내에서 드래그 소스에서 원본 데이터를 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1db54bc51e85b2de5417757bf5d36d3b98af01f1" translate="yes" xml:space="preserve">
          <source>Within the SVG DOM, a &amp;lt;coordinate&amp;gt; is represented as an &lt;a href=&quot;../svglength&quot;&gt;&lt;code&gt;SVGLength&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../svganimatedlength&quot;&gt;&lt;code&gt;SVGAnimatedLength&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SVG DOM 내에서 &amp;lt;coordinate&amp;gt;는 &lt;a href=&quot;../svglength&quot;&gt; &lt;code&gt;SVGLength&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../svganimatedlength&quot;&gt; &lt;code&gt;SVGAnimatedLength&lt;/code&gt; &lt;/a&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d1a551c3e917b6a767f7fe289128cc7bc7c6772" translate="yes" xml:space="preserve">
          <source>Within the WebVTT file itself</source>
          <target state="translated">WebVTT 파일 자체 내</target>
        </trans-unit>
        <trans-unit id="e22f62d4eb22532f66fdef12a14f0847c636b79a" translate="yes" xml:space="preserve">
          <source>Without any boundary collision testing our ball runs out of the canvas quickly. We need to check if the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; position of the ball is out of the canvas dimensions and invert the direction of the velocity vectors. To do so, we add the following checks to the &lt;code&gt;draw&lt;/code&gt; method:</source>
          <target state="translated">경계 충돌 테스트가 없으면 공이 캔버스 밖으로 빠르게 빠져 나옵니다. 볼 의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 위치가 캔버스 치수를 벗어나 있는지 확인 하고 속도 벡터의 방향을 반전 시켜야합니다 . 그렇게하기 위해 &lt;code&gt;draw&lt;/code&gt; 메소드에 다음 검사를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3e48fc16a05b9e5ec9cc58f341586b7b35b9759b" translate="yes" xml:space="preserve">
          <source>Workaround for event.newURL and event.oldURL</source>
          <target state="translated">event.newURL 및 event.oldURL에 대한 해결 방법</target>
        </trans-unit>
        <trans-unit id="97de39ae118b23bf5c7480efba0263d4b3523884" translate="yes" xml:space="preserve">
          <source>Workarounds</source>
          <target state="translated">Workarounds</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="557ecc750b78133ef46c941190d2035f31c8e3ef" translate="yes" xml:space="preserve">
          <source>Worker Interface</source>
          <target state="translated">작업자 인터페이스</target>
        </trans-unit>
        <trans-unit id="45f351551597f42a738de45d92186592bc96c2cb" translate="yes" xml:space="preserve">
          <source>Worker code</source>
          <target state="translated">작업자 코드</target>
        </trans-unit>
        <trans-unit id="444702735f0fed9f8b96bd9c9c1a013dd2c0cf03" translate="yes" xml:space="preserve">
          <source>Worker context</source>
          <target state="translated">작업자 컨텍스트</target>
        </trans-unit>
        <trans-unit id="27e5d7b86605ca1f916eb4c434ac66638402dfec" translate="yes" xml:space="preserve">
          <source>Worker feature detection</source>
          <target state="translated">작업자 기능 감지</target>
        </trans-unit>
        <trans-unit id="2817f9e4b4c7c7d617bb714ffa668284ae432a2b" translate="yes" xml:space="preserve">
          <source>Worker threads have access to a global function, &lt;code&gt;importScripts()&lt;/code&gt;, which lets them import scripts. It accepts zero or more URIs as parameters to resources to import; all of the following examples are valid:</source>
          <target state="translated">작업자 스레드는 전역 함수 &lt;code&gt;importScripts()&lt;/code&gt; 액세스하여 스크립트를 가져올 수 있습니다. 가져올 자원에 대한 매개 변수로 0 개 이상의 URI를 허용합니다. 다음 예제는 모두 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7fcbf383d375a68e192d36f72dd2a7d644226b70" translate="yes" xml:space="preserve">
          <source>Worker.constructor</source>
          <target state="translated">Worker.constructor</target>
        </trans-unit>
        <trans-unit id="4cb08f8fcfe7ed6a88e084a618784110212fa831" translate="yes" xml:space="preserve">
          <source>Worker.onmessage</source>
          <target state="translated">Worker.onmessage</target>
        </trans-unit>
        <trans-unit id="bdca11fd9765dd33362e4e00434a69f88eefba00" translate="yes" xml:space="preserve">
          <source>Worker.onmessageerror</source>
          <target state="translated">Worker.onmessageerror</target>
        </trans-unit>
        <trans-unit id="c683d0df6a04846df93f030586bbc6677b85a85b" translate="yes" xml:space="preserve">
          <source>Worker.postMessage</source>
          <target state="translated">Worker.postMessage</target>
        </trans-unit>
        <trans-unit id="8d6799029efbbf3fd6883f5e6028ef4f7fb3c461" translate="yes" xml:space="preserve">
          <source>Worker.terminate</source>
          <target state="translated">Worker.terminate</target>
        </trans-unit>
        <trans-unit id="958d8e26e3b98c62cdd72e1f83e755dbf3211860" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope</source>
          <target state="translated">WorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="db121ff82e01165cc9576f7795aa88da975f66d1" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.importScripts</source>
          <target state="translated">WorkerGlobalScope.importScripts</target>
        </trans-unit>
        <trans-unit id="f6831b001a4cf6b39302eb0fcf3acea67134ff9a" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.location</source>
          <target state="translated">WorkerGlobalScope.location</target>
        </trans-unit>
        <trans-unit id="b1db2dc6f0b0033fceee51aa503e72d4920f6fa2" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.navigator</source>
          <target state="translated">WorkerGlobalScope.navigator</target>
        </trans-unit>
        <trans-unit id="e1a576f4e0b3ba4e6a55bfb7ff67483fc54ed716" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.onclose</source>
          <target state="translated">WorkerGlobalScope.onclose</target>
        </trans-unit>
        <trans-unit id="95d483e3ff45af7d10447ed80ad2ba199c13f06d" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.onerror</source>
          <target state="translated">WorkerGlobalScope.onerror</target>
        </trans-unit>
        <trans-unit id="5515d9288bba6547d8d55d05cf323a85411e5a85" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.onlanguagechange</source>
          <target state="translated">WorkerGlobalScope.onlanguagechange</target>
        </trans-unit>
        <trans-unit id="4483f2487bbc8bb7f126184a5652ac4f8058eb7c" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.onoffline</source>
          <target state="translated">WorkerGlobalScope.onoffline</target>
        </trans-unit>
        <trans-unit id="170c26198a9da8fca9fda3571dc105dc352da134" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.ononline</source>
          <target state="translated">WorkerGlobalScope.ononline</target>
        </trans-unit>
        <trans-unit id="2a557663b947a7e390e61d6222fe7a95a5383d6e" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.performance</source>
          <target state="translated">WorkerGlobalScope.performance</target>
        </trans-unit>
        <trans-unit id="0306d4b19bdff06aa9f87c973cfd2a1e15facbcd" translate="yes" xml:space="preserve">
          <source>WorkerGlobalScope.self</source>
          <target state="translated">WorkerGlobalScope.self</target>
        </trans-unit>
        <trans-unit id="74a0d635bad8cb921832f022e80f37a47e5b135d" translate="yes" xml:space="preserve">
          <source>WorkerLocation</source>
          <target state="translated">WorkerLocation</target>
        </trans-unit>
        <trans-unit id="315e6d0000af41369aa07e54a100988d3fd17dee" translate="yes" xml:space="preserve">
          <source>WorkerNavigator</source>
          <target state="translated">WorkerNavigator</target>
        </trans-unit>
        <trans-unit id="e5fe3477ef2e6d808558d970bc78565c8048db91" translate="yes" xml:space="preserve">
          <source>WorkerNavigator.connection</source>
          <target state="translated">WorkerNavigator.connection</target>
        </trans-unit>
        <trans-unit id="16145348d388cbf26ca66f7579a2ec82840071f0" translate="yes" xml:space="preserve">
          <source>WorkerNavigator.locks</source>
          <target state="translated">WorkerNavigator.locks</target>
        </trans-unit>
        <trans-unit id="ee5a9e6beb452533d5f36a9d23c50fb23b5809da" translate="yes" xml:space="preserve">
          <source>WorkerNavigator.permissions</source>
          <target state="translated">WorkerNavigator.permissions</target>
        </trans-unit>
        <trans-unit id="74dcc4d991545e8d02f0deeddbddf70e41880ee6" translate="yes" xml:space="preserve">
          <source>WorkerNavigator.sendBeacon()</source>
          <target state="translated">WorkerNavigator.sendBeacon()</target>
        </trans-unit>
        <trans-unit id="b6ef3acd0f91c0c6e2a6bad2692c8aa84dfc4c73" translate="yes" xml:space="preserve">
          <source>Workers</source>
          <target state="translated">Workers</target>
        </trans-unit>
        <trans-unit id="92e96706f9c71190a5f854fa3bb63763988bbf36" translate="yes" xml:space="preserve">
          <source>Workers are considered to have their own execution context, distinct from the document that created them. For this reason they are, in general, not governed by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_Security_Policy&quot;&gt;content security policy&lt;/a&gt; of the document (or parent worker) that created them. So for example, suppose a document is served with the following header:</source>
          <target state="translated">작업자는 자신을 만든 문서와는 달리 고유 한 실행 컨텍스트를 갖는 것으로 간주됩니다. 이러한 이유로 인해 일반적으로 문서를 만든 문서 (또는 상위 작업자) 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_Security_Policy&quot;&gt;콘텐츠 보안 정책&lt;/a&gt; 이 적용되지 않습니다 . 예를 들어, 문서가 다음 헤더와 함께 제공된다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e0faa61746d2dc83992776547c3a106ba44e5fd4" translate="yes" xml:space="preserve">
          <source>Workers are mainly useful for allowing your code to perform processor-intensive calculations without blocking the user interface thread. In this example, a worker is used to calculate Fibonacci numbers.</source>
          <target state="translated">작업자는 주로 코드가 사용자 인터페이스 스레드를 차단하지 않고 프로세서 집약적 인 계산을 수행 할 수 있도록하는 데 유용합니다. 이 예에서 작업자는 피보나치 수를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6de8a4ef2fd42f731bc7d4aba330b604b8dbf94e" translate="yes" xml:space="preserve">
          <source>Workers can also create a new URL using the &lt;a href=&quot;../url/url&quot;&gt;&lt;code&gt;URL()&lt;/code&gt;&lt;/a&gt; constructor and call any normal method on the returned object.</source>
          <target state="translated">작업자는 &lt;a href=&quot;../url/url&quot;&gt; &lt;code&gt;URL()&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 새 URL을 만들고 반환 된 객체에서 일반 메서드를 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbc0cd62c963e533e26d418859faf51d471ed093" translate="yes" xml:space="preserve">
          <source>Workers can use the static methods &lt;a href=&quot;../url/createobjecturl&quot;&gt;URL.createObjectURL&lt;/a&gt; and &lt;a href=&quot;../url/revokeobjecturl&quot;&gt;URL.revokeObjectURL&lt;/a&gt; with &lt;a href=&quot;../blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt; objects accesible to the worker.</source>
          <target state="translated">작업자는 작업자가 액세스 할 수있는 &lt;a href=&quot;../blob&quot;&gt; &lt;code&gt;Blob&lt;/code&gt; &lt;/a&gt; 객체 와 함께 정적 메서드 &lt;a href=&quot;../url/createobjecturl&quot;&gt;URL.createObjectURL&lt;/a&gt; 및 &lt;a href=&quot;../url/revokeobjecturl&quot;&gt;URL.revokeObjectURL&lt;/a&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ee8e17f609e5a3529e298faa3430175587745eb" translate="yes" xml:space="preserve">
          <source>Workers may in turn spawn new workers as long as those workers are hosted within the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;origin&lt;/a&gt; as the parent page (Note: nested workers are &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=22723&quot;&gt;currently not implemented in WebKit&lt;/a&gt;). In addition workers may use &lt;a href=&quot;xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; for network I/O, with the stipulation that the &lt;code&gt;responseXML&lt;/code&gt; and &lt;code&gt;channel&lt;/code&gt; attributes on &lt;code&gt;XMLHttpRequest&lt;/code&gt; always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">작업자는 부모 페이지 와 동일한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;출처&lt;/a&gt; 내에 호스트되는 한 새로운 작업자를 생성 할 수 있습니다 (참고 : 중첩 된 작업자는 &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=22723&quot;&gt;현재 WebKit에서 구현되지 않습니다&lt;/a&gt; ). 또한 근로자가 사용할 수 있습니다 &lt;a href=&quot;xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; 하는 규정으로, 네트워크 I / O에 대한 &lt;code&gt;responseXML&lt;/code&gt; 및 &lt;code&gt;channel&lt;/code&gt; 의 특성 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 항상 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74cee3adf91cebc05c18c7b9063880a5b0b27ca0" translate="yes" xml:space="preserve">
          <source>Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page. In addition, workers may use &lt;a href=&quot;xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; for network I/O, with the exception that the &lt;code&gt;responseXML&lt;/code&gt; and &lt;code&gt;channel&lt;/code&gt; attributes on &lt;code&gt;XMLHttpRequest&lt;/code&gt; always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">근로자가 부모 페이지와 동일한 출처 내에서 호스트되는 한 근로자는 새로운 근로자를 생성 할 수 있습니다. 또한, 근로자가 사용할 수 있습니다 &lt;a href=&quot;xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; 것을 제외하고, 네트워크 I / O에 대한 &lt;code&gt;responseXML&lt;/code&gt; 및 &lt;code&gt;channel&lt;/code&gt; 의 특성 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 항상 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e654449b2757a4fb08da980d01570baa564b70c" translate="yes" xml:space="preserve">
          <source>Workers may spawn more workers if they wish. So-called sub-workers must be hosted within the same origin as the parent page. Also, the URIs for subworkers are resolved relative to the parent worker's location rather than that of the owning page. This makes it easier for workers to keep track of where their dependencies are.</source>
          <target state="translated">원한다면 더 많은 근로자를 스폰 할 수 있습니다. 소위 하위 근로자는 상위 페이지와 동일한 출처 내에서 호스팅되어야합니다. 또한 하위 작업자의 URI는 소유 페이지의 위치가 아닌 상위 작업자의 위치를 ​​기준으로 확인됩니다. 따라서 작업자가 종속성의 위치를 ​​쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5c4ce1a26a6e586b1bdb77deaef520b5287f1fd" translate="yes" xml:space="preserve">
          <source>Workers may, in turn, spawn new workers, as long as those workers are hosted within the same origin as the parent page. In addition, workers may use &lt;a href=&quot;../xmlhttprequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; for network I/O, with the exception that the &lt;code&gt;responseXML&lt;/code&gt; and &lt;code&gt;channel&lt;/code&gt; attributes on &lt;code&gt;XMLHttpRequest&lt;/code&gt; always return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">근로자는 해당 근로자가 상위 페이지와 동일한 원산지 내에서 호스팅되는 한 새로운 근로자를 생성 할 수 있습니다. 또한, 근로자가 사용할 수 있습니다 &lt;a href=&quot;../xmlhttprequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; 것을 제외하고, 네트워크 I / O에 대한 &lt;code&gt;responseXML&lt;/code&gt; 및 &lt;code&gt;channel&lt;/code&gt; 의 특성 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 항상 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd81953275e4c603fc6e296163f16395c6ee5da7" translate="yes" xml:space="preserve">
          <source>Working Draft</source>
          <target state="translated">작업 초안</target>
        </trans-unit>
        <trans-unit id="d5d5132306a8d60e8bca8cc47a924e629d79ce94" translate="yes" xml:space="preserve">
          <source>Working with extensions</source>
          <target state="translated">확장 작업</target>
        </trans-unit>
        <trans-unit id="3f431c547b0c92488c93507145ba5204b4cd4f9a" translate="yes" xml:space="preserve">
          <source>Working with windows in chrome code</source>
          <target state="translated">크롬 코드에서 윈도우 작업</target>
        </trans-unit>
        <trans-unit id="9a228d880b9910b61ce9bd91c7b7b322839414e9" translate="yes" xml:space="preserve">
          <source>Worklet</source>
          <target state="translated">Worklet</target>
        </trans-unit>
        <trans-unit id="3b5f27aab06de1e65689543feb5bb98725bd1b5d" translate="yes" xml:space="preserve">
          <source>Worklet types</source>
          <target state="translated">워크 릿 유형</target>
        </trans-unit>
        <trans-unit id="bea772fca721f599a72e792fcae363af6b27f58a" translate="yes" xml:space="preserve">
          <source>Worklet.addModule</source>
          <target state="translated">Worklet.addModule</target>
        </trans-unit>
        <trans-unit id="a04589c9de7934ee0efbd0faf239f57f555e123d" translate="yes" xml:space="preserve">
          <source>Worklets Level 1&lt;br/&gt;&lt;small&gt;The definition of 'Worklet' in that specification.&lt;/small&gt;</source>
          <target state="translated">Worklets Level 1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'Worklet'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d8e39a843fe2d3c37723b93c44e39e568b5f3fee" translate="yes" xml:space="preserve">
          <source>Worklets Level 1&lt;br/&gt;&lt;small&gt;The definition of 'addModule()' in that specification.&lt;/small&gt;</source>
          <target state="translated">Worklets Level 1 &lt;br/&gt;&lt;small&gt;해당 사양에서 'addModule ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1bdb94b6fa73b2bf71f07b2f00f3356bf3d0cd13" translate="yes" xml:space="preserve">
          <source>Worklets are restricted to specific use cases; they cannot be used for arbitrary computations like Web Workers. The &lt;code&gt;Worklet&lt;/code&gt; interface abstracts properties and methods common to all kind of worklets, and cannot be created directly. Instead, you can use one of the following classes:</source>
          <target state="translated">워크 릿은 특정 사용 사례로 제한됩니다. 웹 워커와 같은 임의의 계산에는 사용할 수 없습니다. &lt;code&gt;Worklet&lt;/code&gt; 의 인터페이스는 worklets의 모든 종류의 속성과 메소드 일반을 추상화, 직접 만들 수 없습니다. 대신 다음 클래스 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f57fa8de020173285d4a3296513c8975f36ae41" translate="yes" xml:space="preserve">
          <source>Wrapping function for texture coordinate &lt;code&gt;r&lt;/code&gt;</source>
          <target state="translated">텍스처 좌표 &lt;code&gt;r&lt;/code&gt; 의 랩핑 기능</target>
        </trans-unit>
        <trans-unit id="b85e9fbd902ae93fc7384ea883cf75e2df7fd24e" translate="yes" xml:space="preserve">
          <source>Wrapping function for texture coordinate &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">텍스처 좌표에 대한 포장 기능 &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6511461a8f068e6307d98b1791e151f29af62ed9" translate="yes" xml:space="preserve">
          <source>Wrapping function for texture coordinate &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">텍스처 좌표 &lt;code&gt;t&lt;/code&gt; 에 대한 랩핑 기능</target>
        </trans-unit>
        <trans-unit id="4d77822dc5b91ca9ef4c744ff10647ed567f0c23" translate="yes" xml:space="preserve">
          <source>Wrapping up the startup() method</source>
          <target state="translated">startup () 메소드 마무리</target>
        </trans-unit>
        <trans-unit id="86793abc57b7f140d05eafeb0e1a06f397559249" translate="yes" xml:space="preserve">
          <source>Writable streams</source>
          <target state="translated">쓰기 가능한 스트림</target>
        </trans-unit>
        <trans-unit id="cb1b8b7b4f6fe87b5560f6db7162aa9f8346d70f" translate="yes" xml:space="preserve">
          <source>WritableStream</source>
          <target state="translated">WritableStream</target>
        </trans-unit>
        <trans-unit id="d3da910dd66c5fbf6bc164bbb7e033ca3b00264d" translate="yes" xml:space="preserve">
          <source>WritableStream.abort</source>
          <target state="translated">WritableStream.abort</target>
        </trans-unit>
        <trans-unit id="5da357be5a24fb338c3c3656fc0d9e834e00cddf" translate="yes" xml:space="preserve">
          <source>WritableStream.constructor</source>
          <target state="translated">WritableStream.constructor</target>
        </trans-unit>
        <trans-unit id="257cc5b9714e97c085901c1434a3eb460f507fc2" translate="yes" xml:space="preserve">
          <source>WritableStream.getWriter</source>
          <target state="translated">WritableStream.getWriter</target>
        </trans-unit>
        <trans-unit id="f028b8f923b52c93fb6b368ce8826ad1c383f7b5" translate="yes" xml:space="preserve">
          <source>WritableStream.locked</source>
          <target state="translated">WritableStream.locked</target>
        </trans-unit>
        <trans-unit id="db95ad84de234c815c23a48ef5f26dbbb569c6e6" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultController</source>
          <target state="translated">WritableStreamDefaultController</target>
        </trans-unit>
        <trans-unit id="ab0bc77d85967d53533c5d405c67eaa9da0762f9" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultController.constructor</source>
          <target state="translated">WritableStreamDefaultController.constructor</target>
        </trans-unit>
        <trans-unit id="1481613ed0eb266f7b0325e8db8cce5e36c19680" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultController.error</source>
          <target state="translated">WritableStreamDefaultController.error</target>
        </trans-unit>
        <trans-unit id="adb31476b8ab736ad37b323dc9b1bbba778122ca" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter</source>
          <target state="translated">WritableStreamDefaultWriter</target>
        </trans-unit>
        <trans-unit id="2baea71edd8514732824138dc1ba8c850eabae62" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.abort</source>
          <target state="translated">WritableStreamDefaultWriter.abort</target>
        </trans-unit>
        <trans-unit id="3195b8588306a7d1edf2e3573482c99902105917" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.close</source>
          <target state="translated">WritableStreamDefaultWriter.close</target>
        </trans-unit>
        <trans-unit id="373e63f5b29bdecdd6fa0d85622dba3930738807" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.closed</source>
          <target state="translated">WritableStreamDefaultWriter.closed</target>
        </trans-unit>
        <trans-unit id="49eca0322e57a91dcf7dc4612ac48cb31bb59265" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.constructor</source>
          <target state="translated">WritableStreamDefaultWriter.constructor</target>
        </trans-unit>
        <trans-unit id="8d5ec6fc733e411c6c35c8805d317d62d645fffb" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.desiredSize</source>
          <target state="translated">WritableStreamDefaultWriter.desiredSize</target>
        </trans-unit>
        <trans-unit id="bf49714da5a0ec81048719f0cd0bb9ad9ddc10bc" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.ready</source>
          <target state="translated">WritableStreamDefaultWriter.ready</target>
        </trans-unit>
        <trans-unit id="6792498dd73efaea90088575539b26425017a2c7" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.releaseLock</source>
          <target state="translated">WritableStreamDefaultWriter.releaseLock</target>
        </trans-unit>
        <trans-unit id="7da63f57b4561f0763d871ef19418a85b416780c" translate="yes" xml:space="preserve">
          <source>WritableStreamDefaultWriter.write</source>
          <target state="translated">WritableStreamDefaultWriter.write</target>
        </trans-unit>
        <trans-unit id="e04761e13f10b5a90ad2cb289d4340d058b4756e" translate="yes" xml:space="preserve">
          <source>Write a new cookie</source>
          <target state="translated">새로운 쿠키를 작성</target>
        </trans-unit>
        <trans-unit id="55543e48cc6534225c5388e5104b3f8151d092bb" translate="yes" xml:space="preserve">
          <source>Write it back as value of &lt;em&gt;Sec-WebSocket-Accept&lt;/em&gt; response header as part of a HTTP response.</source>
          <target state="translated">HTTP 응답의 일부로 &lt;em&gt;Sec-WebSocket-Accept&lt;/em&gt; 응답 헤더의 값으로 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="57369ff3e4f8ea463d1b55fdfacdc12457bb0376" translate="yes" xml:space="preserve">
          <source>Write the hash back as the value of &quot;Sec-WebSocket-Accept&quot; response header in an HTTP response</source>
          <target state="translated">HTTP 응답에서 &quot;Sec-WebSocket-Accept&quot;응답 헤더 값으로 해시를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3931405017ef076792278ee97d7bcbdce21ddc10" translate="yes" xml:space="preserve">
          <source>Write your code, using WebRTC APIs per the specification, knowing that your code should work on all browsers.</source>
          <target state="translated">사양에 따라 WebRTC API를 사용하여 코드가 모든 브라우저에서 작동해야한다는 것을 알고 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c49376792985d1b88974dcb9ae087990ee557acf" translate="yes" xml:space="preserve">
          <source>Write your own code to negotiate the data transport and write your own code to signal to the other peer that it needs to connect to the new channel.</source>
          <target state="translated">데이터 전송을 협상하기 위해 자신의 코드를 작성하고 새로운 채널에 연결해야한다는 다른 피어에게 신호를 보내기 위해 자신의 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e18520123476873237d468e57f57ef6713062042" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; bytes from the specified byte array starting at offset &lt;em&gt;&lt;code&gt;off&lt;/code&gt;&lt;/em&gt; to this output stream.</source>
          <target state="translated">오프셋 &lt;em&gt; &lt;code&gt;off&lt;/code&gt; &lt;/em&gt; 에서 시작하여 지정된 바이트 배열에서 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 바이트 를이 출력 스트림에 씁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e199aae15f0ab86109c1df2c22b120e8d8b4c7cb" translate="yes" xml:space="preserve">
          <source>Writes a line of text in a document.</source>
          <target state="translated">문서에 한 줄의 텍스트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="21e4b0d93e1e251813913ab939b119fed73858af" translate="yes" xml:space="preserve">
          <source>Writes a message to the console.</source>
          <target state="translated">콘솔에 메시지를 씁니다.</target>
        </trans-unit>
        <trans-unit id="947e9228b06c46f157db71cd1d04fc4bbfc5867f" translate="yes" xml:space="preserve">
          <source>Writes a passed chunk of data to a &lt;a href=&quot;writablestream&quot;&gt;&lt;code&gt;WritableStream&lt;/code&gt;&lt;/a&gt; and its underlying sink, then returns a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; that resolves to indicate the success or failure of the write operation.</source>
          <target state="translated">전달 된 데이터 청크를 &lt;a href=&quot;writablestream&quot;&gt; &lt;code&gt;WritableStream&lt;/code&gt; &lt;/a&gt; 및 해당 기본 싱크 에 쓴 다음 쓰기 작업의 성공 또는 실패를 나타내도록 해결 되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="00253bf1b5322cad1ae84c2c63a59b81232f9bde" translate="yes" xml:space="preserve">
          <source>Writes a string of text followed by a newline character to a document.</source>
          <target state="translated">문서에 줄 바꿈 문자와 함께 문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="4cbc4a9a3fc44dfe4b8664ba2f2e541da673c3eb" translate="yes" xml:space="preserve">
          <source>Writes an error message to the console if the assertion is false. If the assertion is true, nothing happens.</source>
          <target state="translated">어설 션이 false 인 경우 콘솔에 오류 메시지를 씁니다. 어설 션이 true이면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9d47ac2bdaa06766816480f2210af557454a7c" translate="yes" xml:space="preserve">
          <source>Writes arbitrary data to the system clipboard. This asynchronous operation signals that it's finished by resolving the returned &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">시스템 클립 보드에 임의의 데이터를 씁니다. 이 비동기 작업은 반환 된 &lt;code&gt;Promise&lt;/code&gt; 를 해결하여 작업이 완료되었음을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="9b8960f32b77e4309090e69ebd8bcf8716bfcb95" translate="yes" xml:space="preserve">
          <source>Writes audio into the stream at the current offset. Returns the number of bytes actually written to the stream.</source>
          <target state="translated">현재 오프셋에서 스트림에 오디오를 씁니다. 실제로 스트림에 쓴 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af189bf4e8f78eeda4d7eb768cffb60dedbf06fc" translate="yes" xml:space="preserve">
          <source>Writes bytes from buffer, offset and size determine length of message.</source>
          <target state="translated">버퍼에서 바이트를 쓰고, 오프셋 및 크기에 따라 메시지 길이가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="894fd94d264b246782aeb91490b3f4931370f6ec" translate="yes" xml:space="preserve">
          <source>Writes text in a document.</source>
          <target state="translated">문서에 텍스트를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e63dfb4f590be37465a41f92795c3a28f4596df0" translate="yes" xml:space="preserve">
          <source>Writes text to the system clipboard, returning a &lt;code&gt;Promise&lt;/code&gt; which is resolved once the text is fully copied into the clipboard.</source>
          <target state="translated">텍스트를 시스템 클립 보드에 기록 하고 텍스트가 클립 보드에 완전히 복사되면 해결 되는 &lt;code&gt;Promise&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2dabb8334b6cbbc19635a160f00032f11eeb9962" translate="yes" xml:space="preserve">
          <source>Writing</source>
          <target state="translated">Writing</target>
        </trans-unit>
        <trans-unit id="75cb81f5d9005409ce4dbeb3d073ae62b20017a8" translate="yes" xml:space="preserve">
          <source>Writing CSS Animations with the Web Animations API</source>
          <target state="translated">웹 애니메이션 API를 사용하여 CSS 애니메이션 작성</target>
        </trans-unit>
        <trans-unit id="7bd31533c664cad6c1d5c8b4117b72230f799269" translate="yes" xml:space="preserve">
          <source>Writing Web Audio API code that works in every browser</source>
          <target state="translated">모든 브라우저에서 작동하는 Web Audio API 코드 작성</target>
        </trans-unit>
        <trans-unit id="06265c3a1b120d66a122daab42a58ce9893ce343" translate="yes" xml:space="preserve">
          <source>Writing WebSocket client applications</source>
          <target state="translated">WebSocket 클라이언트 애플리케이션 작성</target>
        </trans-unit>
        <trans-unit id="ec42012e65f141dfe4b612d0198c10447264de4e" translate="yes" xml:space="preserve">
          <source>Writing WebSocket servers</source>
          <target state="translated">WebSocket 서버 작성</target>
        </trans-unit>
        <trans-unit id="c53f56645448ed404ea76f0eb89de92b15cce24b" translate="yes" xml:space="preserve">
          <source>Writing to a document that has already loaded without calling &lt;a href=&quot;open&quot;&gt;&lt;code&gt;document.open()&lt;/code&gt;&lt;/a&gt; will automatically call &lt;code&gt;document.open&lt;/code&gt;. Once you have finished writing, it is recommended to call &lt;a href=&quot;close&quot;&gt;&lt;code&gt;document.close()&lt;/code&gt;&lt;/a&gt; to tell the browser to finish loading the page. The text you write is parsed into the document's structure model. In the example above, the &lt;code&gt;h1&lt;/code&gt; element becomes a node in the document.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt; &lt;code&gt;document.open()&lt;/code&gt; &lt;/a&gt; 을 호출하지 않고 이미로드 된 문서에 쓰면 자동으로 &lt;code&gt;document.open&lt;/code&gt; 이 호출됩니다 . 쓰기가 끝나면 &lt;a href=&quot;close&quot;&gt; &lt;code&gt;document.close()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 브라우저에 페이지로드를 완료 하도록 지시하는 것이 좋습니다 . 작성한 텍스트가 문서의 구조 모델로 구문 분석됩니다. 위의 예에서 &lt;code&gt;h1&lt;/code&gt; 요소는 문서의 노드가됩니다.</target>
        </trans-unit>
        <trans-unit id="45786e1c7f1ba36f6f3fa162ec9adc900dd40a60" translate="yes" xml:space="preserve">
          <source>Writing to the clipboard is available without permission in secure contexts and browser extensions, but only from user-initiated event callbacks. Browser extensions with the &lt;code&gt;&quot;clipboardWrite&quot;&lt;/code&gt; permission can write to the clipboard at any time.</source>
          <target state="translated">안전한 컨텍스트 및 브라우저 확장 프로그램에서 권한없이 클립 보드에 쓸 수 있지만 사용자가 시작한 이벤트 콜백에서만 가능합니다. &lt;code&gt;&quot;clipboardWrite&quot;&lt;/code&gt; 권한 이있는 브라우저 확장 프로그램 은 언제든지 클립 보드에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="c484f501ad8135e8cfa50666eb037c60fb38009d" translate="yes" xml:space="preserve">
          <source>X = Vx * sin(&amp;theta;/2)</source>
          <target state="translated">X = Vx * sin (&amp;theta; / 2)</target>
        </trans-unit>
        <trans-unit id="1e01cba2f6638d438d27938366658f92af3051eb" translate="yes" xml:space="preserve">
          <source>X1 (back) Mouse</source>
          <target state="translated">X1 (뒤) 마우스</target>
        </trans-unit>
        <trans-unit id="237d1efafbc3e2759b36d1a298cdc97f81476996" translate="yes" xml:space="preserve">
          <source>X2 (forward) Mouse</source>
          <target state="translated">X2 (앞으로) 마우스</target>
        </trans-unit>
        <trans-unit id="97e0a00fd8dc25a78eb8ea7c949d7d4e9c3f8c40" translate="yes" xml:space="preserve">
          <source>XDomain</source>
          <target state="translated">XDomain</target>
        </trans-unit>
        <trans-unit id="855e3d169b349a14867ed875f329653292225aef" translate="yes" xml:space="preserve">
          <source>XHR</source>
          <target state="translated">XHR</target>
        </trans-unit>
        <trans-unit id="14df91620c76417e3eabf9c3fc67337392f4a971" translate="yes" xml:space="preserve">
          <source>XHR in Android 4.0 sends empty content for &lt;code&gt;FormData&lt;/code&gt; with &lt;code&gt;blob&lt;/code&gt;.</source>
          <target state="translated">Android 4.0의 XHR은 &lt;code&gt;blob&lt;/code&gt; 과 함께 &lt;code&gt;FormData&lt;/code&gt; 에 빈 내용을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="f48015ce22da2cb62dc55092e9e541944096e051" translate="yes" xml:space="preserve">
          <source>XML content may use the &lt;code&gt;text/xml&lt;/code&gt; type, but you should ensure that the data value is well-formed XML.</source>
          <target state="translated">XML 컨텐츠는 &lt;code&gt;text/xml&lt;/code&gt; 유형을 사용할 수 있지만 데이터 값이 올바른 형식인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbfb5e9da4d4e953346b880559ac2756d402c79d" translate="yes" xml:space="preserve">
          <source>XMLHTTPRequest</source>
          <target state="translated">XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="1a1dc754a10525066d7d47c74e38c2ea14cb7e3f" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest</source>
          <target state="translated">XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="9c7ac98c5678de235355b246629689d55756876e" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest - REST and the Rich User Experience</source>
          <target state="translated">XMLHttpRequest-REST 및 풍부한 사용자 경험</target>
        </trans-unit>
        <trans-unit id="d48537600e415d0b70f2c0c7986f879ac4ce3d8f" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.HTML in XMLHttpRequest</source>
          <target state="translated">XMLHttpRequest의 XMLHttpRequest.HTML</target>
        </trans-unit>
        <trans-unit id="184713aba0b06a3ef26cdf2cb1845a34d124e9c4" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.Synchronous and Asynchronous Requests</source>
          <target state="translated">XMLHttpRequest. 동기 및 비동기 요청</target>
        </trans-unit>
        <trans-unit id="58c9e1ac412a8a9fd10ae2678a48305d78262c19" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.Using XMLHttpRequest</source>
          <target state="translated">XMLHttpRequest. XMLHttpRequest 사용</target>
        </trans-unit>
        <trans-unit id="1e13e5f7185280de648b1bba241ab7dd98343fd9" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.abort</source>
          <target state="translated">XMLHttpRequest.abort</target>
        </trans-unit>
        <trans-unit id="8ade0ba8152baaa16000d1e18549499ac95853c1" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.channel</source>
          <target state="translated">XMLHttpRequest.channel</target>
        </trans-unit>
        <trans-unit id="955808f3ce72fee7425e29ce5ea98a4893fb1439" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.channel is an &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIChannel&quot;&gt;nsIChannel&lt;/a&gt;&lt;/code&gt; that used by the object when performing the request. This is &lt;code&gt;null&lt;/code&gt; if the channel hasn't been created yet. In the case of a multi-part request, this is the initial channel, not the different parts in the multi-part request. &lt;strong&gt;Requires elevated privileges to access.&lt;/strong&gt;</source>
          <target state="translated">XMLHttpRequest.channel은 요청을 수행 할 때 개체가 사용 하는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIChannel&quot;&gt;nsIChannel&lt;/a&gt;&lt;/code&gt; 입니다. 이다 &lt;code&gt;null&lt;/code&gt; 채널이 아직 생성되지 않은 경우. 멀티 파트 요청의 경우 멀티 파트 요청의 다른 파트가 아닌 초기 채널입니다. &lt;strong&gt;액세스하려면 높은 권한이 필요합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4de8f0cc699497a6e084c092f6a12589ab5e0ab1" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.getAllResponseHeaders</source>
          <target state="translated">XMLHttpRequest.getAllResponseHeaders</target>
        </trans-unit>
        <trans-unit id="ec6d6ea9ea7be9bb9fb3e2e596160ae59226845b" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.getResponseHeader</source>
          <target state="translated">XMLHttpRequest.getResponseHeader</target>
        </trans-unit>
        <trans-unit id="6a5ac3629b02948e0cbd31a9d356489be0d62208" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.init()</source>
          <target state="translated">XMLHttpRequest.init()</target>
        </trans-unit>
        <trans-unit id="e11ff8fe84349a0536b8ebea8e77eac02b3005f9" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.onreadystatechange</source>
          <target state="translated">XMLHttpRequest.onreadystatechange</target>
        </trans-unit>
        <trans-unit id="e885975abc209b2f1ced9f1478719dfdb114b4ac" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.open</source>
          <target state="translated">XMLHttpRequest.open</target>
        </trans-unit>
        <trans-unit id="9d89f2fe7c8fdaed4a1559a738c82167bcb1baf7" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.openRequest()</source>
          <target state="translated">XMLHttpRequest.openRequest()</target>
        </trans-unit>
        <trans-unit id="403e8e5fd1686f5ac44560f3d25a44ad18d1b426" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.overrideMimeType</source>
          <target state="translated">XMLHttpRequest.overrideMimeType</target>
        </trans-unit>
        <trans-unit id="94e03029629a1a9f2efe6846d4342a49ea5447f7" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.readyState</source>
          <target state="translated">XMLHttpRequest.readyState</target>
        </trans-unit>
        <trans-unit id="44aaffbcc2d83cf89c6d27cc6dc61baa7ea0760e" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.response</source>
          <target state="translated">XMLHttpRequest.response</target>
        </trans-unit>
        <trans-unit id="e0d968fc57686669b874e373617f99a5a935bef5" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.responseText</source>
          <target state="translated">XMLHttpRequest.responseText</target>
        </trans-unit>
        <trans-unit id="6a076eabfc4893fca4a5829fff2a9a3ffcb690f5" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.responseType</source>
          <target state="translated">XMLHttpRequest.responseType</target>
        </trans-unit>
        <trans-unit id="57ceb2818770474b8c62e768fe7f9db2828f2b56" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.responseURL</source>
          <target state="translated">XMLHttpRequest.responseURL</target>
        </trans-unit>
        <trans-unit id="8a1fae050423115e14607649d39e0caf9994a103" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.responseXML</source>
          <target state="translated">XMLHttpRequest.responseXML</target>
        </trans-unit>
        <trans-unit id="dd18743e28f021ed90fe5737b195efda13dc49ee" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.send</source>
          <target state="translated">XMLHttpRequest.send</target>
        </trans-unit>
        <trans-unit id="786937ed1c59de4db64b2a8f1a989c907ba3f1e6" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.sendAsBinary</source>
          <target state="translated">XMLHttpRequest.sendAsBinary</target>
        </trans-unit>
        <trans-unit id="24cf61a93bec456d364b4b240abe412fdea1243f" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.setRequestHeader</source>
          <target state="translated">XMLHttpRequest.setRequestHeader</target>
        </trans-unit>
        <trans-unit id="4e6e73c0f575d9568da304e1e26216f373c2661d" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.status</source>
          <target state="translated">XMLHttpRequest.status</target>
        </trans-unit>
        <trans-unit id="b5e4dd6c7e3d308c66492ffaa4033d54e5888852" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.statusText</source>
          <target state="translated">XMLHttpRequest.statusText</target>
        </trans-unit>
        <trans-unit id="f74cae9e57479e3b5b01d1766334502a7000f9b4" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.timeout</source>
          <target state="translated">XMLHttpRequest.timeout</target>
        </trans-unit>
        <trans-unit id="49a6b171f9a873d7d116fe84d4fbbe8e5c47060d" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.upload</source>
          <target state="translated">XMLHttpRequest.upload</target>
        </trans-unit>
        <trans-unit id="214c23a08b508fd38d9a8fc0b37887dddf4af9a2" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest.withCredentials</source>
          <target state="translated">XMLHttpRequest.withCredentials</target>
        </trans-unit>
        <trans-unit id="ccf8e117681d1c793356c31e43954acaa6ce763c" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'FormData' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'FormData'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="06bed2935ea9c83774e80c0c4d963f4510deb2aa" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'FormData()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'FormData ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="04915acea4987c520a855ad2669ad1e35685549a" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'ProgressEvent' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'ProgressEvent'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="51823600eabe9d6b97e3b2b44f3c1e72b5d54310" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'ProgressEvent()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'ProgressEvent ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8009260d7b46da5f9bd22c4640eb0811d6eea516" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'ProgressEvent.lengthComputable' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'ProgressEvent.lengthComputable'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="96dc0453da94420f5252f412f1bb7289ce263d1e" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'ProgressEvent.loaded' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'ProgressEvent.loaded'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="066eb04c6dc5060c5872b13c1bb106cc4ec3c30e" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'append()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'append ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="62024f985656319fc5fa5c6b4a90e2e6f4f1add7" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'delete()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'delete ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a48b46505ed029c2e8e8e599ccfc79da33a7b63d" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'entries() (as iterator&amp;lt;&amp;gt;)' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 스펙에서 'entries () (iterator &amp;lt;&amp;gt;)'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a3168bb2ef5c76fdb186ec2740ebc8d050d28f56" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'get()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'get ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0ca5a5bcb9567c368c17013d7709c3380e4fdb56" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'getAll()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'getAll ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c18e2f3e7590238f353d1b0ecc696f14aec417a7" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'getAllResponseHeaders()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'getAllResponseHeaders ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="73e3c1f62d7a54c9d8311a5cfc5fd3c39b922d79" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'getResponseHeader()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'getResponseHeader ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2c4423ae14ed9c228fd680312ae0b3cfe9236db4" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'has()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'has ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5eb37963c2b4753cb22b727155bf47faaf35b9fd" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'keys() (as iterator&amp;lt;&amp;gt;)' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'keys () (iterator &amp;lt;&amp;gt;)'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6869b7325a237345873ef1b84f078ca584309108" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'open()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'open ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="76f703ee004aa1470cabe4046e7ef59976e9b664" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'overrideMimeType()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'overrideMimeType ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c7f70bab78a0e2d17a0dd645e11c66a2343486db" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'responseXML' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'responseXML'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3189816b7f8d0b211f75059468951dcf7ab94de8" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'send()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'send ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b2ba2f9c1f6a6b797b8de44721d36a9368ecef7e" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'set()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'set ()'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d54d9851eead5fe435a1bd3bff4f9a4419d0356c" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'setRequestHeader()' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 사양에서 'setRequestHeader ()'의 정의입니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="dfb8a510c93e45a85ad3387602a07e471c36377d" translate="yes" xml:space="preserve">
          <source>XMLHttpRequest&lt;br/&gt;&lt;small&gt;The definition of 'values() (as iterator&amp;lt;&amp;gt;)' in that specification.&lt;/small&gt;</source>
          <target state="translated">XMLHttpRequest &lt;br/&gt;&lt;small&gt;해당 스펙에서 'values ​​() (iterator &amp;lt;&amp;gt;)'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9b68e15e4875c1705acf2dcd068ce37e8fbd2212" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestEventTarget</source>
          <target state="translated">XMLHttpRequestEventTarget</target>
        </trans-unit>
        <trans-unit id="ef5784b83727e814badf283144796dcf41a3b5d2" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestEventTarget.onabort</source>
          <target state="translated">XMLHttpRequestEventTarget.onabort</target>
        </trans-unit>
        <trans-unit id="92a8e777a4ed2873052a3c63cffb8fb82dd07a56" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestEventTarget.onerror</source>
          <target state="translated">XMLHttpRequestEventTarget.onerror</target>
        </trans-unit>
        <trans-unit id="1f12987f2230f3f6d0a4a519754bdb20baa514ed" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestEventTarget.onload</source>
          <target state="translated">XMLHttpRequestEventTarget.onload</target>
        </trans-unit>
        <trans-unit id="b81824430492121422a2a45bc7e0c4b5cfd04ad6" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestEventTarget.onloadstart</source>
          <target state="translated">XMLHttpRequestEventTarget.onloadstart</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
