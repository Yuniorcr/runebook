<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="javascript">
    <body>
      <group id="javascript">
        <trans-unit id="dc71f7514eedbed3ceb94ad5c83afcda03734c72" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;arrow function expression&lt;/strong&gt; is a compact alternative to a traditional &lt;a href=&quot;../operators/function&quot;&gt;function expression&lt;/a&gt;, but is limited and can't be used in all situations.</source>
          <target state="translated">&lt;strong&gt;화살표 함수 표현식은&lt;/strong&gt; 기존에 소형 대안 &lt;a href=&quot;../operators/function&quot;&gt;함수 표현식&lt;/a&gt; 만 제한되며 모든 상황에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="607e4dc315b484ba61d20fbbf5614a0760b2cdba" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;assignment operator&lt;/strong&gt; assigns a value to its left operand based on the value of its right operand.</source>
          <target state="translated">&lt;strong&gt;할당 연산자&lt;/strong&gt; 양수인 오른쪽 피연산자의 값에 따라 그것의 왼쪽 피연산자 값.</target>
        </trans-unit>
        <trans-unit id="0ef32178f844cc002042d95f78a7b5278d86a590" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;asynchronously resolved&lt;/strong&gt;&lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; if the &lt;var&gt;iterable&lt;/var&gt; passed contains no promises.</source>
          <target state="translated">&lt;strong&gt;비동기 적으로 해결 &lt;/strong&gt;&lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 은 if &lt;var&gt;iterable&lt;/var&gt; 전달은 어떤 약속을 포함하지 않는다.</target>
        </trans-unit>
        <trans-unit id="904d5976b308e2cf370f1501613cd8846c61e3a2" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;asynchronously resolved&lt;/strong&gt;&lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; if the &lt;var&gt;iterable&lt;/var&gt; passed contains no promises. Note, Google Chrome 58 returns an &lt;strong&gt;already resolved&lt;/strong&gt; promise in this case.</source>
          <target state="translated">&lt;strong&gt;비동기 적으로 해결 &lt;/strong&gt;&lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 은 if &lt;var&gt;iterable&lt;/var&gt; 전달은 어떤 약속을 포함하지 않는다. 이 경우 Chrome 58은 &lt;strong&gt;이미 해결 된&lt;/strong&gt; 약속을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a767f92ce194f1873bd322c68f31bfd6943db581" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;empty statement&lt;/strong&gt; is used to provide no statement, although the JavaScript syntax would expect one.</source>
          <target state="translated">&lt;strong&gt;빈 문은&lt;/strong&gt; 자바 스크립트 구문을 기대할 수 있지만, 아무런 설명을 제공하지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c41d3a52802b697a3a0ec9387f2f4b7e944f5a03" translate="yes" xml:space="preserve">
          <source>An API that returns a &lt;a href=&quot;../global_objects/promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; will result in a promise chain, and it splits the function into many parts. Consider the following code:</source>
          <target state="translated">&lt;a href=&quot;../global_objects/promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 를 반환하는 API 는 약속 체인을 생성하고 함수를 여러 부분으로 나눕니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d6e1fb977cb0563ff8d5c19996560538d0a19f3d" translate="yes" xml:space="preserve">
          <source>An accessor descriptor also has the following optional keys:</source>
          <target state="translated">접근 자 설명자에는 다음과 같은 선택적 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ba2736be15ee34c7ec5d427128a154ec58e802" translate="yes" xml:space="preserve">
          <source>An accessor property that returns the buffer contained in the memory.</source>
          <target state="translated">메모리에 포함 된 버퍼를 반환하는 접근 자 속성입니다.</target>
        </trans-unit>
        <trans-unit id="aa3a67a4c0526a53a8eea043d8576001f4b1c120" translate="yes" xml:space="preserve">
          <source>An action can be assigned to an already &quot;settled&quot; promise. In that case, the action (if appropriate) will be performed at the first asynchronous opportunity. Note that promises are guaranteed to be asynchronous. Therefore, an action for an already &quot;settled&quot; promise will occur only after the stack has cleared and a clock-tick has passed. The effect is much like that of &lt;code&gt;setTimeout(action,10)&lt;/code&gt;.</source>
          <target state="translated">이미 &quot;확정 된&quot;promise에 작업을 할당 할 수 있습니다. 이 경우 작업 (해당하는 경우)은 첫 번째 비동기 기회에서 수행됩니다. 약속은 비동기식으로 보장됩니다. 따라서 이미 &quot;안정된&quot;promise에 대한 작업은 스택이 지워지고 시계 눈금이 지난 후에 만 ​​발생합니다. 효과는 &lt;code&gt;setTimeout(action,10)&lt;/code&gt; 과 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="cb4daa3d3786043af0c5a93f620d2482f66c1bdc" translate="yes" xml:space="preserve">
          <source>An additional optimization technique to lazify or delay the calculation of a property value and cache it for later access are &lt;strong&gt;smart (or &quot;&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt;&quot;) getters&lt;/strong&gt;. The value is calculated the first time the getter is called, and is then cached so subsequent accesses return the cached value without recalculating it. This is useful in the following situations:</source>
          <target state="translated">속성 값의 계산을 지연하거나 지연시키고 나중에 액세스 할 수 있도록 캐시하는 추가 최적화 기술은 &lt;strong&gt;스마트 (또는 &quot; &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;메모 화 된&lt;/a&gt; &quot;) 게터&lt;/strong&gt; 입니다. 값은 getter가 처음 호출 될 때 계산 된 다음 캐시되어 후속 액세스에서 다시 계산하지 않고 캐시 된 값을 반환합니다. 이는 다음 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a03499d49258efd7b96ce9fc262e5c83ec924074" translate="yes" xml:space="preserve">
          <source>An additional optimization technique to lazify or delay the calculation of a property value and cache it for later access are&lt;strong&gt; smart or &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; getters&lt;/strong&gt;. The value is calculated the first time the getter is called, and is then cached so subsequent accesses return the cached value without recalculating it. This is useful in the following situations:</source>
          <target state="translated">속성 값의 계산을 지연 시키거나 지연시키고 나중에 액세스 할 수 있도록 캐시하는 추가 최적화 기술은 &lt;strong&gt;스마트하거나&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;&lt;/a&gt;&lt;/strong&gt; 메모리 화 &lt;strong&gt;된&lt;/strong&gt;&lt;strong&gt; 게터&lt;/strong&gt; 입니다. 값은 게터가 처음 호출 될 때 계산 된 다음 캐시되므로 후속 액세스는 캐시 된 값을 다시 계산하지 않고 반환합니다. 다음 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="93110263f3a02ef2acddc832bccbe4d1ee2d6b6c" translate="yes" xml:space="preserve">
          <source>An alias for the variable that holds the value attempted to be assigned to &lt;code&gt;&lt;var&gt;prop&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;prop&lt;/var&gt;&lt;/code&gt; 에 할당하려고 시도한 값을 보유하는 변수의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="5c0089cf4fd6d504691e8dd3f3f6007a79efc218" translate="yes" xml:space="preserve">
          <source>An alias for the variable that holds the value attempted to be assigned to &lt;code&gt;prop.&lt;/code&gt;</source>
          <target state="translated">값을 보유한 변수의 별명을 &lt;code&gt;prop.&lt;/code&gt; 지정하려고했습니다 .</target>
        </trans-unit>
        <trans-unit id="d6016719702c59ad00b3edb04713bfcc42f7a2e2" translate="yes" xml:space="preserve">
          <source>An alias for the variable that holds the value attempted to be assigned to &lt;code&gt;prop&lt;/code&gt;.</source>
          <target state="translated">값을 보유한 변수의 별명이 &lt;code&gt;prop&lt;/code&gt; 에 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f756a12b0c4869514c34f124ff122238e13e61af" translate="yes" xml:space="preserve">
          <source>An anonymous function is created and called:</source>
          <target state="translated">익명 함수가 생성되고 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="400e6951bed505cfb4c59c0c2736981c28198b92" translate="yes" xml:space="preserve">
          <source>An array containing objects representing the exported functions of the given module.</source>
          <target state="translated">지정된 모듈의 내 보낸 함수를 나타내는 객체를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6c7fc74f35e37d771379bedc3096bf6ec8a27b18" translate="yes" xml:space="preserve">
          <source>An array containing objects representing the imported functions of the given module.</source>
          <target state="translated">주어진 모듈의 가져온 함수를 나타내는 객체를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3ee0359ece94b819bf8999821d7a29e0c97c39e9" translate="yes" xml:space="preserve">
          <source>An array containing the canonical locale names.</source>
          <target state="translated">표준 로케일 이름을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="294c063efbd9732c4ca28f74c4def4da64e7a34e" translate="yes" xml:space="preserve">
          <source>An array containing the deleted elements.</source>
          <target state="translated">삭제 된 요소를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b8c6ddda445db591cd5ad81d4db8de771f6936fb" translate="yes" xml:space="preserve">
          <source>An array containing the deleted elements. If only one element is removed, an array of one element is returned. If no elements are removed, an empty array is returned.</source>
          <target state="translated">삭제 된 요소를 포함하는 배열입니다. 하나의 요소 만 제거하면 하나의 요소 배열이 반환됩니다. 요소가 제거되지 않으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83a6b9d1167655fd7e1912a34148467ca61399c7" translate="yes" xml:space="preserve">
          <source>An array containing the given object's own enumerable property values.</source>
          <target state="translated">지정된 객체의 열거 가능한 속성 값을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="cf644f932140ad032f297a3500f2f5be55f1e595" translate="yes" xml:space="preserve">
          <source>An array corresponding to the arguments passed to a function.</source>
          <target state="translated">함수에 전달 된 인수에 해당하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="0ef0fc75dc31886b468c867697291158b56e92dd" translate="yes" xml:space="preserve">
          <source>An array corresponding to the arguments passed to a function. This is deprecated as property of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt;. Use the &lt;a href=&quot;../../functions/arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; object available within the function instead.</source>
          <target state="translated">함수에 전달 된 인수에 해당하는 배열입니다. 이것은 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; 의&lt;/a&gt; 속성으로 사용되지 않습니다 . 대신 함수 내에서 사용 가능한 &lt;a href=&quot;../../functions/arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 객체를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2392b3a79dbcf85997c3e946ba81b7bb00504726" translate="yes" xml:space="preserve">
          <source>An array corresponding to the arguments passed to a function. This is deprecated as property of &lt;a href=&quot;function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt;. Use the &lt;a href=&quot;../functions/arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; object available within the function instead.</source>
          <target state="translated">함수에 전달 된 인수에 해당하는 배열입니다. 이것은 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; 의&lt;/a&gt; 속성으로 사용되지 않습니다 . 대신 함수 내에서 사용 가능한 &lt;a href=&quot;../functions/arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 객체를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="17f84c99cc1e709b7e2e7cc25e68a800f6787203" translate="yes" xml:space="preserve">
          <source>An array of all symbol properties found directly upon the given object.</source>
          <target state="translated">지정된 객체에서 직접 찾은 모든 심볼 속성의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="939875be84425baa86f4e27e35e5c37a64400d8e" translate="yes" xml:space="preserve">
          <source>An array of objects. An &lt;code&gt;'x'&lt;/code&gt; denotes an &lt;code&gt;'on'&lt;/code&gt; state, a &lt;code&gt;'-'&lt;/code&gt; (hyphen) denotes an &lt;code&gt;'off'&lt;/code&gt; state and an &lt;code&gt;'_'&lt;/code&gt; (underscore) denotes the length of an &lt;code&gt;'on'&lt;/code&gt; state.</source>
          <target state="translated">객체의 배열. &lt;code&gt;'x'&lt;/code&gt; 를 나타내고 &lt;code&gt;'on'&lt;/code&gt; 상태는 &lt;code&gt;'-'&lt;/code&gt; (하이픈)는을 나타내고 &lt;code&gt;'off'&lt;/code&gt; 상태 및 &lt;code&gt;'_'&lt;/code&gt; 의 길이이다 (밑줄) &lt;code&gt;'on'&lt;/code&gt; 상태.</target>
        </trans-unit>
        <trans-unit id="5f1aa483a622265e16e21ae55475c37ff5942623" translate="yes" xml:space="preserve">
          <source>An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.</source>
          <target state="translated">런타임의 기본 로케일로 폴백하지 않고 데이터 정렬에서 지원되는 지정된 로케일 태그의 서브 세트를 나타내는 문자열 배열.</target>
        </trans-unit>
        <trans-unit id="8c38f432bd1ddfdeee6fa4d76387b78d4ffffeb8" translate="yes" xml:space="preserve">
          <source>An array of strings representing a subset of the given locale tags that are supported in date and time formatting without having to fall back to the runtime's default locale.</source>
          <target state="translated">런타임의 기본 로케일로 돌아 가지 않고 날짜 및 시간 형식으로 지원되는 지정된 로케일 태그의 서브 세트를 나타내는 문자열 배열.</target>
        </trans-unit>
        <trans-unit id="dff512279d3e3d7747a9029073cc81b1abeb136c" translate="yes" xml:space="preserve">
          <source>An array of strings representing a subset of the given locale tags that are supported in number formatting without having to fall back to the runtime's default locale.</source>
          <target state="translated">런타임의 기본 로케일로 돌아 가지 않고 숫자 형식으로 지원되는 지정된 로케일 태그의 서브 세트를 나타내는 문자열 배열.</target>
        </trans-unit>
        <trans-unit id="d3525b867e17bc9965be4e0986238be5396a0ea2" translate="yes" xml:space="preserve">
          <source>An array of strings representing a subset of the given locale tags that are supported in plural formatting without having to fall back to the runtime's default locale.</source>
          <target state="translated">런타임의 기본 로케일로 돌아 가지 않고 복수 형식으로 지원되는 지정된 로케일 태그의 서브 세트를 나타내는 문자열 배열.</target>
        </trans-unit>
        <trans-unit id="9ecd22a069ff40a7adba2fb22eb682e921f7fa56" translate="yes" xml:space="preserve">
          <source>An array of strings that correspond to the properties found directly upon the given object.</source>
          <target state="translated">지정된 객체에서 직접 찾은 속성에 해당하는 문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="82c7ff8ecc238b0a2ed408eaf35a1b64aff96df1" translate="yes" xml:space="preserve">
          <source>An array of strings that corresponds to the properties found directly in the given object.</source>
          <target state="translated">주어진 객체에서 직접 찾은 속성에 해당하는 문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6fcf73071464349321076ab6e25b38ccba0fc11a" translate="yes" xml:space="preserve">
          <source>An array of strings that represent all the enumerable properties of the given object.</source>
          <target state="translated">지정된 객체의 열거 가능한 모든 속성을 나타내는 문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="95dc172965791e059f6fdf61cfca3b8552eb577f" translate="yes" xml:space="preserve">
          <source>An array of the given object's own enumerable property &lt;code&gt;[key, value]&lt;/code&gt; pairs.</source>
          <target state="translated">지정된 객체 자체의 열거 가능한 속성 &lt;code&gt;[key, value]&lt;/code&gt; 쌍 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="552d66072a8804f7950ce81da141922f241ea639" translate="yes" xml:space="preserve">
          <source>An array of the given object's own enumerable string-keyed property &lt;code&gt;[&lt;var&gt;key&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;]&lt;/code&gt; pairs.</source>
          <target state="translated">주어진 객체의 고유 한 열거 가능한 문자열 키 속성 &lt;code&gt;[&lt;var&gt;key&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;]&lt;/code&gt; 쌍 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="c6a8b51bfc275b75e67018d696417d3e4f98e4d2" translate="yes" xml:space="preserve">
          <source>An array-like object specifying the arguments with which &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; should be called.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 을 호출해야하는 인수를 지정하는 배열 류 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="96149a7cfd499334d51399dbd236c11d242d951e" translate="yes" xml:space="preserve">
          <source>An array-like object specifying the arguments with which &lt;code&gt;target&lt;/code&gt; should be called.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 을 호출 할 인수를 지정하는 배열과 유사한 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="0a91c45330077c858d10f57c59493882d5804c68" translate="yes" xml:space="preserve">
          <source>An array-like object specifying the arguments with which &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; should be called.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 을 호출 할 인수를 지정하는 배열과 유사한 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="10e533ce8e823a791dbf3c43de2c8bc55b3892b0" translate="yes" xml:space="preserve">
          <source>An array-like object, specifying the arguments with which &lt;code&gt;&lt;var&gt;func&lt;/var&gt;&lt;/code&gt; should be called, or &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; if no arguments should be provided to the function.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;func&lt;/var&gt;&lt;/code&gt; 를 호출해야하는 인수를 지정하는 배열 류 객체 . 함수에 인수를 제공하지 않으면 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ea85a520a76e8b6050148f34da2b543b6c31c03" translate="yes" xml:space="preserve">
          <source>An array-like or iterable object to convert to a typed array.</source>
          <target state="translated">유형이 지정된 배열로 변환 할 배열과 유사하거나 반복 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fa9c92f2822babf9db63226c903eadbff9d44c70" translate="yes" xml:space="preserve">
          <source>An array-like or iterable object to convert to an array.</source>
          <target state="translated">배열로 변환 할 배열과 유사하거나 반복 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="14e7a38fb60f213081bdec62d8f9c549f8cb262a" translate="yes" xml:space="preserve">
          <source>An array-like structure representing a WebAssembly Table, which stores function references.</source>
          <target state="translated">함수 참조를 저장하는 WebAssembly 테이블을 나타내는 배열과 유사한 구조입니다.</target>
        </trans-unit>
        <trans-unit id="420291fda6a2df1379755dfd0f020d225443c84b" translate="yes" xml:space="preserve">
          <source>An arrow function cannot contain a line break between its parameters and its arrow.</source>
          <target state="translated">화살표 함수는 매개 변수와 화살표 사이에 줄 바꿈을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30f3b9d9b9373d50159a57406f2ffef27133479a" translate="yes" xml:space="preserve">
          <source>An arrow function does not have its own &lt;code&gt;this;&lt;/code&gt; the &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical context is used i.e. Arrow functions follow the normal variable lookup rules. So while searching for &lt;code&gt;this&lt;/code&gt; which is not present in current scope they end up finding &lt;code&gt;this&lt;/code&gt; from its enclosing scope . Thus, in the following code, the &lt;code&gt;this&lt;/code&gt; within the function that is passed to &lt;code&gt;setInterval&lt;/code&gt; has the same value as &lt;code&gt;this&lt;/code&gt; in the lexically enclosing function:</source>
          <target state="translated">화살표 함수에는 고유 한 기능이 없습니다 &lt;code&gt;this;&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 화살표 기능이 정상 가변 룩업 규칙을 따르는, 즉 둘러싸 콘텍스트 어휘의 값이 사용된다. 그래서 검색하는 동안 &lt;code&gt;this&lt;/code&gt; 그들이 찾는 결국 현재 범위에 존재하지 않는 &lt;code&gt;this&lt;/code&gt; 자사의 바깥 쪽 범위. 따라서, 다음의 코드에서는, &lt;code&gt;this&lt;/code&gt; 전달 된 함수 내 &lt;code&gt;setInterval&lt;/code&gt; 같은 값 갖는다 &lt;code&gt;this&lt;/code&gt; 어휘를 둘러싸 함수 :</target>
        </trans-unit>
        <trans-unit id="2903f4c76b6a87245b422e2b51c264e5b423df7a" translate="yes" xml:space="preserve">
          <source>An arrow function expression has a shorter syntax and lexically binds its &lt;code&gt;this&lt;/code&gt; value (see &lt;a href=&quot;functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt; for details):</source>
          <target state="translated">화살표 함수 표현식은 구문 &lt;code&gt;this&lt;/code&gt; 짧고이 값을 어휘 적으로 바인딩 합니다 (자세한 내용은 &lt;a href=&quot;functions/arrow_functions&quot;&gt;화살표 함수&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="71f86c59a91631ee3cae0ebff0097fde924961e4" translate="yes" xml:space="preserve">
          <source>An assignment operator assigns a value to its left operand based on the value of its right operand.</source>
          <target state="translated">대입 연산자는 오른쪽 피연산자 값에 따라 왼쪽 피연산자에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ba4e1651e560d06f9979af37172776e0f825aec6" translate="yes" xml:space="preserve">
          <source>An async function is a function declared with the &lt;code&gt;async&lt;/code&gt;keyword&lt;strong&gt;. &lt;/strong&gt;Async functions are instances of the &lt;a href=&quot;../global_objects/asyncfunction&quot;&gt;&lt;code&gt;AsyncFunction&lt;/code&gt;&lt;/a&gt; constructor, and the &lt;code&gt;await&lt;/code&gt; keyword is permitted within them. The &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.</source>
          <target state="translated">비동기 함수는 &lt;code&gt;async&lt;/code&gt; 키워드로 선언 된 함수 &lt;strong&gt;입니다. &lt;/strong&gt;비동기 함수는 &lt;a href=&quot;../global_objects/asyncfunction&quot;&gt; &lt;code&gt;AsyncFunction&lt;/code&gt; &lt;/a&gt; 생성자의 인스턴스이며 그 안에서 &lt;code&gt;await&lt;/code&gt; 키워드가 허용됩니다. &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 를 키워드는 비동기, 약속 기반의 행동이 명시 적으로 구성 약속 체인의 필요성을 피하고, 깨끗한 스타일로 작성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="037a62a87dd303931bc8001559f23982efa44685" translate="yes" xml:space="preserve">
          <source>An easier way would be the &lt;a href=&quot;from&quot;&gt;&lt;code&gt;Array.from()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">더 쉬운 방법은 &lt;a href=&quot;from&quot;&gt; &lt;code&gt;Array.from()&lt;/code&gt; &lt;/a&gt; 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="a07a0b90f394a5ae03e3e7fc5cb3ba0b9b17e65f" translate="yes" xml:space="preserve">
          <source>An easy way to understand array comprehension syntax, is to compare it with the Array &lt;a href=&quot;../global_objects/array/map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../global_objects/array/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; methods:</source>
          <target state="translated">배열 이해 구문을 이해하는 쉬운 방법은 배열 &lt;a href=&quot;../global_objects/array/map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../global_objects/array/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 메소드 와 비교하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6c6be03bf697ecd2fdffc6c8a431e2305886c862" translate="yes" xml:space="preserve">
          <source>An empty handler will create a proxy that behaves, in almost all respects, exactly like the target. By defining any of a set group of functions on the &lt;code&gt;handler&lt;/code&gt; object, you can customise specific aspects of the proxy's behavior. For example, by defining &lt;code&gt;get()&lt;/code&gt; you can provide a customised version of the target's &lt;a href=&quot;../../operators/property_accessors&quot;&gt;property accessor&lt;/a&gt;.</source>
          <target state="translated">빈 핸들러는 거의 모든 측면에서 대상과 똑같이 작동하는 프록시를 생성합니다. &lt;code&gt;handler&lt;/code&gt; 객체에서 함수 집합을 정의 하여 프록시 동작의 특정 측면을 사용자 정의 할 수 있습니다. 예를 들어 &lt;code&gt;get()&lt;/code&gt; 을 정의하여 대상 &lt;a href=&quot;../../operators/property_accessors&quot;&gt;속성 접근&lt;/a&gt; 자의 사용자 정의 된 버전을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe7a92abe9d32ff8c428c25cb1f273210959e120" translate="yes" xml:space="preserve">
          <source>An empty iterable causes the returned promise to be forever pending:</source>
          <target state="translated">빈 iterable은 리턴 된 약속이 영원히 보류되도록합니다.</target>
        </trans-unit>
        <trans-unit id="a5bebd2c7d7a5684a19483fa34674022fb01ee9d" translate="yes" xml:space="preserve">
          <source>An empty object with no properties can be created like this:</source>
          <target state="translated">속성이없는 빈 객체는 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b06616016d285a37f2dcd931812ca40b58e483f7" translate="yes" xml:space="preserve">
          <source>An empty statement is used to provide no statement, although the JavaScript syntax would expect one.</source>
          <target state="translated">JavaScript 구문이 예상하지만 빈 명령문은 명령문을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c5a07aa537b0c3a1f53a56833d025dadd80c880" translate="yes" xml:space="preserve">
          <source>An empty string &lt;code&gt;&lt;var&gt;searchValue&lt;/var&gt;&lt;/code&gt; produces strange results. With no &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; value, or any &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; value lower than the string's &lt;code&gt;length&lt;/code&gt;, the returned value is the same as the &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; value:</source>
          <target state="translated">빈 문자열 &lt;code&gt;&lt;var&gt;searchValue&lt;/var&gt;&lt;/code&gt; 는 이상한 결과를 생성합니다. 아니오 &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; 값, 또는 &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; 의의 값 문자열의보다 &lt;code&gt;length&lt;/code&gt; , 반환 값은 동일하다 &lt;code&gt;&lt;var&gt;fromIndex&lt;/var&gt;&lt;/code&gt; 의의 값 :</target>
        </trans-unit>
        <trans-unit id="5ca461869e539ecb37f26c5baeae262972b6ec88" translate="yes" xml:space="preserve">
          <source>An empty string &lt;var&gt;searchValue&lt;/var&gt; will match at any index between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;str.length&lt;/code&gt;</source>
          <target state="translated">빈 문자열 &lt;var&gt;searchValue&lt;/var&gt; 는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;str.length&lt;/code&gt; 사이의 모든 색인에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="71431f94615d62f369cba3d7202b3350d88fcd31" translate="yes" xml:space="preserve">
          <source>An encoded component of a Uniform Resource Identifier.</source>
          <target state="translated">Uniform Resource Identifier의 인코딩 된 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d4a3f0492dc0b390e0f5420e8372f08bc5000ff9" translate="yes" xml:space="preserve">
          <source>An example helpers library (&lt;code&gt;helpers.js&lt;/code&gt;)</source>
          <target state="translated">예제 도우미 라이브러리 ( &lt;code&gt;helpers.js&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="08645bca7b03be10dc588e7ca5f5224b8977c4da" translate="yes" xml:space="preserve">
          <source>An existing &lt;a href=&quot;../arraybuffer&quot;&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../sharedarraybuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; to use as the storage backing the new &lt;code&gt;DataView&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;DataView&lt;/code&gt; 개체를 지원하는 저장소로 사용할 기존 &lt;a href=&quot;../arraybuffer&quot;&gt; &lt;code&gt;ArrayBuffer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../sharedarraybuffer&quot;&gt; &lt;code&gt;SharedArrayBuffer&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a1706e59c3de8fdea8b2a592f30d78f262a80bc" translate="yes" xml:space="preserve">
          <source>An existing &lt;a href=&quot;arraybuffer&quot;&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sharedarraybuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt;  to use as the storage backing the new &lt;code&gt;DataView&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;DataView&lt;/code&gt; 객체를 지원하는 스토리지로 사용할 기존 &lt;a href=&quot;arraybuffer&quot;&gt; &lt;code&gt;ArrayBuffer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sharedarraybuffer&quot;&gt; &lt;code&gt;SharedArrayBuffer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ef7aef358560ebdb0055bca9a1bae446c97504f" translate="yes" xml:space="preserve">
          <source>An existing symbol with the given key if found; otherwise, a new symbol is created and returned.</source>
          <target state="translated">주어진 키가있는 기존 심볼. 그렇지 않으면 새 심볼이 만들어져 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7dac3affe4df2a3ef9b4685334a7f50105251705" translate="yes" xml:space="preserve">
          <source>An explanation of why the name &quot;&lt;strong&gt;let&lt;/strong&gt;&quot; was chosen can be found &lt;a href=&quot;https://stackoverflow.com/questions/37916940/why-was-the-name-let-chosen-for-block-scoped-variable-declarations-in-javascri&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&quot; &lt;strong&gt;let&lt;/strong&gt; &quot; 이라는 이름 이 선택된 이유에 대한 설명은 &lt;a href=&quot;https://stackoverflow.com/questions/37916940/why-was-the-name-let-chosen-for-block-scoped-variable-declarations-in-javascri&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6aa298faee5ff12e2f3e180256594d43024e29a5" translate="yes" xml:space="preserve">
          <source>An expression (including assignment expressions) or variable declaration evaluated once before the loop begins. Typically used to initialize a counter variable. This expression may optionally declare new variables with &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; keywords. Variables declared with &lt;code&gt;var&lt;/code&gt; are not local to the loop, i.e. they are in the same scope the &lt;code&gt;for&lt;/code&gt; loop is in. Variables declared with &lt;code&gt;let&lt;/code&gt; are local to the statement.</source>
          <target state="translated">루프가 시작되기 전에 한 번 평가 된 표현식 (할당 표현식 포함) 또는 변수 선언. 일반적으로 카운터 변수를 초기화하는 데 사용됩니다. 이 표현식은 선택적으로 &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 키워드로 새 변수를 선언 할 수 있습니다. &lt;code&gt;var&lt;/code&gt; 로 선언 된 변수는 루프에 국한되지 않습니다. 즉, &lt;code&gt;for&lt;/code&gt; 루프가 있는 동일한 범위 에 있습니다. &lt;code&gt;let&lt;/code&gt; 으로 선언 된 변수는 명령문에 국한됩니다.</target>
        </trans-unit>
        <trans-unit id="563b165e57203ba22b381e63a88f80ffaf862cb4" translate="yes" xml:space="preserve">
          <source>An expression (including assignment expressions) or variable declaration. Typically used to initialize a counter variable. This expression may optionally declare new variables with &lt;code&gt;var&lt;/code&gt; or let keywords. Variables declared with &lt;code&gt;var&lt;/code&gt; are not local to the loop, i.e. they are in the same scope the &lt;code&gt;for&lt;/code&gt; loop is in. Variables declared with let are local to the statement.</source>
          <target state="translated">표현식 (할당 표현식 포함) 또는 변수 선언 일반적으로 카운터 변수를 초기화하는 데 사용됩니다. 이 표현식은 &lt;code&gt;var&lt;/code&gt; 또는 let 키워드를 사용 하여 새 변수를 선택적으로 선언 할 수 있습니다. &lt;code&gt;var&lt;/code&gt; 로 선언 된 변수는 루프에 국한되지 않습니다. 즉, &lt;code&gt;for&lt;/code&gt; 루프 와 동일한 범위 에 있습니다. let으로 선언 된 변수는 명령문에 국지됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbd88784f3cf214b9daf916b8f03307c6f230f6" translate="yes" xml:space="preserve">
          <source>An expression comparing Objects is only true if the operands reference the same Object.</source>
          <target state="translated">피연산자가 동일한 객체를 참조하는 경우에만 객체를 비교하는 표현식이 참입니다.</target>
        </trans-unit>
        <trans-unit id="d96fbf68c0b8026b43dbb2becb94876cf06f5c77" translate="yes" xml:space="preserve">
          <source>An expression evaluated after each pass through the loop. If &lt;code&gt;condition&lt;/code&gt; evaluates to true, the &lt;code&gt;statement&lt;/code&gt; is re-executed. When &lt;code&gt;condition&lt;/code&gt; evaluates to false, control passes to the statement following the &lt;code&gt;do...while&lt;/code&gt;.</source>
          <target state="translated">루프를 통과 한 후에 평가 된 표현식입니다. 경우 &lt;code&gt;condition&lt;/code&gt; true로 평가의 &lt;code&gt;statement&lt;/code&gt; 다시 실행됩니다. &lt;code&gt;condition&lt;/code&gt; 이 거짓으로 평가 되면 제어는 &lt;code&gt;do...while&lt;/code&gt; 다음에 나오는 명령문으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="65648dd53962c19787343d60effc1f5cb5a1a68c" translate="yes" xml:space="preserve">
          <source>An expression evaluated before each pass through the loop. If this condition evaluates to true, &lt;code&gt;&lt;var&gt;statement&lt;/var&gt;&lt;/code&gt; is executed. When condition evaluates to false, execution continues with the statement after the &lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">루프를 통과 할 때마다 평가되는 표현식입니다. 이 조건이 참으로 평가되면 &lt;code&gt;&lt;var&gt;statement&lt;/var&gt;&lt;/code&gt; 이 실행됩니다. 조건이 거짓으로 평가되면 &lt;code&gt;while&lt;/code&gt; 루프 이후의 명령문으로 실행이 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4694def79a9e78b30c8c4a5a47247c0399309b4" translate="yes" xml:space="preserve">
          <source>An expression evaluated before each pass through the loop. If this condition evaluates to true, &lt;code&gt;statement&lt;/code&gt; is executed. When condition evaluates to false, execution continues with the statement after the &lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">루프를 통과하기 전에 평가 된 표현식입니다. 이 조건이 true로 평가되면 &lt;code&gt;statement&lt;/code&gt; 이 실행됩니다. 조건이 false로 평가되면 &lt;code&gt;while&lt;/code&gt; 루프 후 명령문으로 실행이 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="def975c74255559c1f7477823bd32eb09004bc31" translate="yes" xml:space="preserve">
          <source>An expression representing the object or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;primitive&lt;/a&gt; whose type is to be returned.</source>
          <target state="translated">유형이 리턴 될 오브젝트 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;기본 요소&lt;/a&gt; 를 나타내는 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="a660b1a15463458ef45fe32fec4465966c30369c" translate="yes" xml:space="preserve">
          <source>An expression to be evaluated at the end of each loop iteration. This occurs before the next evaluation of &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt;. Generally used to update or increment the counter variable.</source>
          <target state="translated">각 루프 반복이 끝날 때 평가할 표현식입니다. 이는 다음 &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; 평가 전에 발생합니다 . 일반적으로 카운터 변수를 업데이트하거나 증가시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d77c0bc243558a100ea011b2ee0d834472948bf" translate="yes" xml:space="preserve">
          <source>An expression to be evaluated at the end of each loop iteration. This occurs before the next evaluation of &lt;code&gt;condition&lt;/code&gt;. Generally used to update or increment the counter variable.</source>
          <target state="translated">각 루프 반복이 끝날 때 평가할 표현식입니다. 이것은 다음 &lt;code&gt;condition&lt;/code&gt; 평가 전에 발생합니다 . 카운터 변수를 업데이트하거나 증가시키는 데 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b02a03e1661f4d2b7f2c20763540987093de4367" translate="yes" xml:space="preserve">
          <source>An expression to be evaluated before each loop iteration. If this expression evaluates to true, &lt;code&gt;&lt;var&gt;statement&lt;/var&gt;&lt;/code&gt; is executed. This conditional test is optional. If omitted, the condition always evaluates to true. If the expression evaluates to false, execution skips to the first expression following the &lt;code&gt;for&lt;/code&gt; construct.</source>
          <target state="translated">각 루프 반복 전에 평가할 표현식입니다. 이식이 true로 평가되면 &lt;code&gt;&lt;var&gt;statement&lt;/var&gt;&lt;/code&gt; 이 실행됩니다. 이 조건부 테스트는 선택 사항입니다. 생략하면 조건은 항상 참으로 평가됩니다. 식이 false로 평가되면 &lt;code&gt;for&lt;/code&gt; 구문 다음의 첫 번째 식으로 실행이 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="f6c6980cf583ad644d4313f43c90fa74393d4f55" translate="yes" xml:space="preserve">
          <source>An expression to be evaluated before each loop iteration. If this expression evaluates to true, &lt;code&gt;statement&lt;/code&gt; is executed. This conditional test is optional. If omitted, the condition always evaluates to true. If the expression evaluates to false, execution skips to the first expression following the &lt;code&gt;for&lt;/code&gt; construct.</source>
          <target state="translated">각 루프 반복 전에 평가할 표현식입니다. 이 표현식이 true로 평가되면 &lt;code&gt;statement&lt;/code&gt; 이 실행됩니다. 이 조건부 테스트는 선택 사항입니다. 생략하면 조건이 항상 true로 평가됩니다. 표현식이 false로 평가되면 실행은 &lt;code&gt;for&lt;/code&gt; 구문 다음에 오는 첫 번째 표현식으로 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="35ba1c7d434c3faa3b57f94ed7a6d9c3f43bdbf0" translate="yes" xml:space="preserve">
          <source>An expression which is evaluated if the &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; evaluates to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/truthy&quot;&gt;truthy&lt;/a&gt; value (one which equals or can be converted to &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; 이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/truthy&quot;&gt;참&lt;/a&gt; 값으로 평가되면 평가되는 표현식입니다 ( &lt;code&gt;true&lt;/code&gt; 와 같거나 true 로 변환 될 수있는 값 ).</target>
        </trans-unit>
        <trans-unit id="441a9804aa307a8ae123fd4ee45c3052920b8afb" translate="yes" xml:space="preserve">
          <source>An expression which is executed if the &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;falsy&lt;/a&gt; (that is, has a value which can be converted to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; 이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;거짓&lt;/a&gt; (즉, &lt;code&gt;false&lt;/code&gt; 로 변환 될 수있는 값이 있음) 인 경우 실행되는 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="bbf04a8ac56a18b3c5ca4ecba6b36bf41f3502fa" translate="yes" xml:space="preserve">
          <source>An expression whose result is matched against each &lt;code&gt;case&lt;/code&gt; clause.</source>
          <target state="translated">결과가 각 &lt;code&gt;case&lt;/code&gt; 절 과 일치하는 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="096f81052c204301bb39461a515e3a197f8ba0a9" translate="yes" xml:space="preserve">
          <source>An expression whose result is matched against each case clause.</source>
          <target state="translated">결과가 각 case 절과 일치하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="a5cf0224face5193db610e7ed4df9111dbb244de" translate="yes" xml:space="preserve">
          <source>An expression whose value is used as a condition.</source>
          <target state="translated">값이 조건으로 사용되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ce72caeca8acacc91dc374028b95f508257f68d6" translate="yes" xml:space="preserve">
          <source>An identifier to hold an exception object for the associated &lt;code&gt;catch&lt;/code&gt; clause.</source>
          <target state="translated">연관된 &lt;code&gt;catch&lt;/code&gt; 절에 대한 예외 오브젝트를 보유하는 식별자 입니다.</target>
        </trans-unit>
        <trans-unit id="49041670d07ea7557ebf2d3541054989a1d8c947" translate="yes" xml:space="preserve">
          <source>An implementation dependent string representation of the timezone, which might be an abbreviation or full name (there is no standard for names or abbreviations of timezones), e.g. &quot;Line Islands Time&quot; or &quot;LINT&quot;</source>
          <target state="translated">시간대의 구현 종속 문자열 표현 (약어 또는 전체 이름 일 수 있음) (예 : &quot;라인 아일랜드 시간&quot;또는 &quot;LINT&quot;)</target>
        </trans-unit>
        <trans-unit id="bddcb716532f5813789510c630398489b6f527aa" translate="yes" xml:space="preserve">
          <source>An important difference between &lt;strong&gt;function declarations&lt;/strong&gt; and &lt;strong&gt;class declarations&lt;/strong&gt; is that function declarations are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;hoisted&lt;/a&gt; and class declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw a &lt;a href=&quot;global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;함수 선언&lt;/strong&gt; 과 &lt;strong&gt;클래스 선언&lt;/strong&gt; 의 중요한 차이점은 &lt;strong&gt;함수&lt;/strong&gt; 선언이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;들어&lt;/a&gt; 있고 클래스 선언이 없다는 것입니다. 먼저 클래스를 선언 한 다음 액세스해야합니다. 그렇지 않으면 다음과 같은 코드에서 &lt;a href=&quot;global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2118abfd81bf472d819615a6ea6e791a3d7c3f0" translate="yes" xml:space="preserve">
          <source>An important difference between &lt;strong&gt;function declarations&lt;/strong&gt; and &lt;strong&gt;class declarations&lt;/strong&gt; is that function declarations are &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;hoisted&lt;/a&gt; and class declarations are not. You first need to declare your class and then access it, otherwise code like the following will throw a &lt;a href=&quot;global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;함수 선언&lt;/strong&gt; 과 &lt;strong&gt;클래스 선언&lt;/strong&gt; 의 중요한 차이점은 &lt;strong&gt;함수&lt;/strong&gt; 선언은 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;호이스트&lt;/a&gt; 되고 클래스 선언은 그렇지 않다는 것입니다. 먼저 클래스를 선언 한 다음 액세스해야합니다. 그렇지 않으면 다음과 같은 코드에서 &lt;a href=&quot;global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03cf9802975b2140faf4b1e02522092a10522a90" translate="yes" xml:space="preserve">
          <source>An index in the array if an element passes the test; otherwise, &lt;strong&gt;-1&lt;/strong&gt;.</source>
          <target state="translated">요소가 테스트를 통과 한 경우 배열의 인덱스입니다. 그렇지 않으면 &lt;strong&gt;-1&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="45068698e9e35e33334c7424a76962254dd1cef2" translate="yes" xml:space="preserve">
          <source>An infinite iterator</source>
          <target state="translated">무한 반복자</target>
        </trans-unit>
        <trans-unit id="8f7da3fcdbd9e76635a6c3870e9c23199a2cb3cc" translate="yes" xml:space="preserve">
          <source>An initializer for a constant is required. You must specify its value in the same statement in which it's declared. (This makes sense, given that it can't be changed later.)</source>
          <target state="translated">상수에 대한 이니셜 라이저가 필요합니다. 선언 된 동일한 명령문에서 값을 지정해야합니다. (나중에 변경할 수 없다는 점을 감안하면 의미가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a6549ca8166686b21d0cc0acb269a9dee4d5211f" translate="yes" xml:space="preserve">
          <source>An integer between 0 and +&amp;infin;: [0, +&amp;infin;), indicating the number of times to repeat the string in the newly-created string that is to be returned.</source>
          <target state="translated">0에서 + &amp;infin; 사이의 정수 : [0, + &amp;infin;) : 새로 생성 된 문자열에서 반환 될 문자열을 반복 할 횟수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c371a876965041f9229c3513e6ca693cd937b671" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 1-less-than the length of the string. If no index is provided, the default is 0, so the first character in the string is returned.</source>
          <target state="translated">문자열 길이보다 0에서 1 사이의 정수입니다. 색인이 제공되지 않으면 기본값은 0이므로 문자열의 첫 번째 문자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="106b9efaffaff775ad822a58e16c5ef2bf962e75" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 11 representing the month.</source>
          <target state="translated">월을 나타내는 0에서 11 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="0340f4b68be3264af2a2b8b4b46f968a655877fa" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 11, representing the months January through December.</source>
          <target state="translated">1 월에서 12 월까지의 달을 나타내는 0에서 11 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c307e319633b22dc9f4154c242880723be84dfbf" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 23, representing the hour.</source>
          <target state="translated">시간을 나타내는 0에서 23 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="1d8603477473538026a144a65d91cf5cfbe173c1" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 59, representing the minutes.</source>
          <target state="translated">분을 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="8cd81723e643cac2becb26e41b4e0d2ec22b36f6" translate="yes" xml:space="preserve">
          <source>An integer between 0 and 59, representing the seconds.</source>
          <target state="translated">초를 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="3877ba4370f4d8fc75db580b793f879f937eef5f" translate="yes" xml:space="preserve">
          <source>An integer between 1 and 7, a string representing a signed integer between 1 and 7.</source>
          <target state="translated">1과 7 사이의 정수이며 1과 7 사이의 부호있는 정수를 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="08822b1556747f82a5e4057749ea2d5932291a56" translate="yes" xml:space="preserve">
          <source>An integer between 2 and 36 that represents the &lt;var&gt;radix&lt;/var&gt; (the base in mathematical numeral systems) of the above mentioned string.</source>
          <target state="translated">위에서 언급 한 문자열 의 &lt;var&gt;radix&lt;/var&gt; (수치 체계의 밑) 를 나타내는 2와 36 사이의 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="2c73b13d5099afde06b1c29ec287db4d342cb15f" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; (January) and &lt;code&gt;11&lt;/code&gt; (December) representing the month. &lt;em&gt;(Up through ECMAScript 2016, &lt;code&gt;&lt;var&gt;month&lt;/var&gt;&lt;/code&gt; was a required parameter. As of ES2017, it no longer is.)&lt;/em&gt;</source>
          <target state="translated">월을 나타내는 &lt;code&gt;0&lt;/code&gt; (1 월)에서 &lt;code&gt;11&lt;/code&gt; (12 월) 사이의 정수 입니다. &lt;em&gt;(ECMAScript 2016까지 &lt;code&gt;&lt;var&gt;month&lt;/var&gt;&lt;/code&gt; 은 필수 매개 변수였습니다. ES2017부터는 더 이상 그렇지 않습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dd835e1ba108b3c5843cccda3330a950fe36b09" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;a href=&quot;../number/positive_infinity&quot;&gt;&lt;code&gt;+Infinity&lt;/code&gt;&lt;/a&gt;, indicating the number of times to repeat the string.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 에서 &lt;a href=&quot;../number/positive_infinity&quot;&gt; &lt;code&gt;+Infinity&lt;/code&gt; &lt;/a&gt; 사이의 정수로 , 문자열을 반복 할 횟수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c8d8b197e5c5620f77acf23c8f0787a484dc9bef" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;23&lt;/code&gt; representing the hours. If omitted, defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">시간을 나타내는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;23&lt;/code&gt; 사이의 정수 입니다. 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9207d72cfc3b6cd49e9edd908ee6e6a8d3904c9d" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;59&lt;/code&gt; representing the minutes. If omitted, defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">분을 나타내는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;59&lt;/code&gt; 사이의 정수 입니다. 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a697324efdab03d0d2c66a847302af1d4c25b285" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;59&lt;/code&gt; representing the seconds. If omitted, defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">초를 나타내는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;59&lt;/code&gt; 사이의 정수 입니다. 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26478d9a3f8d53efcaf0c9e44df7b28e48cf1325" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;999&lt;/code&gt; representing the milliseconds. If omitted, defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">밀리 초를 나타내는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;999&lt;/code&gt; 사이의 정수 입니다. 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c257002ebd243d8ab43aa0408fa65716a7d1f464" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length - 1&lt;/code&gt;. If the &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; cannot be converted to the integer or no &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; is provided, the default is &lt;code&gt;0&lt;/code&gt;, so the first character of &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length - 1&lt;/code&gt; 사이의 정수 . 경우 &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; 정수로 변환 할 수 없거나 &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; 제공되지 않으며, 기본값은 &lt;code&gt;0&lt;/code&gt; 의 첫 번째 문자 있도록, &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d35f1e124435ebc992ea4a691d77a18c6956a1a" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;31&lt;/code&gt; representing the day of the month. If omitted, defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">날짜를 나타내는 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;31&lt;/code&gt; 사이의 정수 입니다. 생략하면 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="574d03b5326d390cae6bca671dce60c618242818" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;36&lt;/code&gt; that represents the &lt;em&gt;radix&lt;/em&gt; (the base in mathematical numeral systems) of the &lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt;. Be careful&amp;mdash;this does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; default to &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt; 의 &lt;em&gt;기수&lt;/em&gt; (수학적 숫자 체계의 밑) 를 나타내는 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;36&lt;/code&gt; 사이의 정수 입니다. 주의하십시오. 기본값은 &lt;code&gt;10&lt;/code&gt; 이 &lt;strong&gt;&lt;em&gt;아닙니다&lt;/em&gt;&lt;/strong&gt; !&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e0430deadf1418adbf98f4175e7f4b66e2194b8" translate="yes" xml:space="preserve">
          <source>An integer between &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;36&lt;/code&gt; that represents the &lt;em&gt;radix&lt;/em&gt; (the base in mathematical numeral systems) of the &lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt;. Be careful&amp;mdash;this does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; default to &lt;code&gt;10&lt;/code&gt;! If the radix value is not of the &lt;code&gt;Number&lt;/code&gt; type it will be coerced to a &lt;code&gt;Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt; 의 &lt;em&gt;기수&lt;/em&gt; (수학적 숫자 체계의 밑) 를 나타내는 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;36&lt;/code&gt; 사이의 정수 입니다. 주의하십시오. 기본값은 &lt;code&gt;10&lt;/code&gt; 이 &lt;strong&gt;&lt;em&gt;아닙니다&lt;/em&gt;&lt;/strong&gt; ! 기수 값이 아닌 경우 &lt;code&gt;Number&lt;/code&gt; 유형 그것은 강제 변환 될 &lt;code&gt;Number&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="052febdc911896d49cc022792c614d939102b8be" translate="yes" xml:space="preserve">
          <source>An integer from 1 to 31, representing the day of the month.</source>
          <target state="translated">월을 나타내는 1에서 31 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="da1ff9a222f12671689bb808ba1d5a230e68ce18" translate="yes" xml:space="preserve">
          <source>An integer greater than or equal to 0 and less than the length of the string; if it is not a number, it defaults to 0.</source>
          <target state="translated">0보다 크고 문자열 길이보다 작은 정수입니다. 숫자가 아닌 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="32dcc771f58aac0e49bb1d347d0542a9b3129077" translate="yes" xml:space="preserve">
          <source>An integer greater than or equal to &lt;code&gt;0&lt;/code&gt; and less than the &lt;code&gt;length&lt;/code&gt; of the string. If &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; is not a number, it defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 보다 크거나 같고 문자열 의 &lt;code&gt;length&lt;/code&gt; 보다 작은 정수 . &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; 가 숫자가 아닌 경우 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="23b96f0fe9c9ae7c1c08269b2edbd7ca0b69489b" translate="yes" xml:space="preserve">
          <source>An integer in the range &lt;code&gt;2&lt;/code&gt; through &lt;code&gt;36&lt;/code&gt; specifying the base to use for representing numeric values.</source>
          <target state="translated">범위의 정수 &lt;code&gt;2&lt;/code&gt; 내지 &lt;code&gt;36&lt;/code&gt; 염기를 특정 숫자 값을 나타 내기 위해 사용한다.</target>
        </trans-unit>
        <trans-unit id="cfbee8fb07a8deec24b19c6ae7c40817f11bce1a" translate="yes" xml:space="preserve">
          <source>An integer indicating the number of elements in the array to remove from &lt;code&gt;&lt;var&gt;start&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;start&lt;/var&gt;&lt;/code&gt; 에서 제거 할 배열의 요소 수를 나타내는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="23933916916af0d0a3a44b6ae90cbc769c6eedc8" translate="yes" xml:space="preserve">
          <source>An integer indicating the number of old array elements to remove.</source>
          <target state="translated">제거 할 이전 배열 요소 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="0b33fad11117904307c5cbf907a0aa9d62fff1be" translate="yes" xml:space="preserve">
          <source>An integer number corresponding to the day of the week for the given date, according to local time: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 요일에 해당하는 정수 : 0은 일요일, 1은 월요일, 2는 화요일 등입니다.</target>
        </trans-unit>
        <trans-unit id="35fba568ed1f420669a64b07f09439a349e74cb8" translate="yes" xml:space="preserve">
          <source>An integer number corresponding to the day of the week for the given date, according to universal time: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.</source>
          <target state="translated">지정된 날짜의 요일에 해당하는 정수로 표준시 : 0은 일요일, 1은 월요일, 2는 화요일 등입니다.</target>
        </trans-unit>
        <trans-unit id="36496561c417a8ee96420e2a90e6e6dca58c7829" translate="yes" xml:space="preserve">
          <source>An integer number parsed from the given string. If the first character cannot be converted to a number, &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">주어진 문자열에서 파싱 된 정수 첫 문자를 숫자로 변환 할 수 없으면 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="754f84fe6eda6fbcfd66a5c2dd8aaf4e612c3728" translate="yes" xml:space="preserve">
          <source>An integer number parsed from the given string. If the first character cannot be converted to a number, &lt;a href=&quot;nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">주어진 문자열에서 파싱 된 정수 첫 문자를 숫자로 변환 할 수 없으면 &lt;a href=&quot;nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8c56e50c7700a4eb35860fbd58da65a55be76f" translate="yes" xml:space="preserve">
          <source>An integer number ranging from 1 to 31 representing day of month for the given date, according to universal time.</source>
          <target state="translated">표준시에 따라 주어진 날짜의 날짜를 나타내는 1에서 31 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f7b92fee5e3d728be9bd92c3fb91adbf123124fa" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 11, corresponding to the month of the given date according to universal time. 0 for January, 1 for February, 2 for March, and so on.</source>
          <target state="translated">지정된 시간의 표준시에 따라 해당 날짜의 월에 해당하는 0에서 11 사이의 정수입니다. 1 월의 경우 0, 2 월의 경우 1, 3 월의 경우 2 등입니다.</target>
        </trans-unit>
        <trans-unit id="bdf2d721e24be76b4cd146e44c2452bba742c120" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 11, representing the month in the given date according to local time. 0 corresponds to January, 1 to February, and so on.</source>
          <target state="translated">현지 시간에 따라 주어진 날짜의 월을 나타내는 0에서 11 사이의 정수입니다. 0은 1 월, 1 ~ 2 월 등에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a983a5c51a13d3fd93ae6a301548ecf77e2a434d" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 23, representing the hour for the given date according to local time.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 시간을 나타내는 0에서 23 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b1325856017b7684f529e31d370b53200f228761" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 23, representing the hours in the given date according to universal time.</source>
          <target state="translated">지정된 날짜의 표준시를 기준으로 0에서 23 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c70225ce44d32316849eb9b0a8f260dc07b6d33f" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 59, representing the minutes in the given date according to local time.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 분을 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="1de535437e5b03a40105100e65959b20cf5746c1" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 59, representing the minutes in the given date according to universal time.</source>
          <target state="translated">지정된 날짜의 표준시를 기준으로 분을 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e8f4e1a7a43f1bbe013ac8cf5bf6a20bd20529e1" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 59, representing the seconds in the given date according to local time.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 초를 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="04050712c56a2a403dfbf471a090ea88b43e9813" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 59, representing the seconds in the given date according to universal time.</source>
          <target state="translated">지정된 날짜의 초를 표준시로 나타내는 0에서 59 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="938cd26196813e1d928d61a97441625f390776c8" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 6, corresponding to the day of the week for the given date, according to local time: 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 요일에 해당하는 0에서 6 사이의 정수입니다. 일요일은 0, 월요일은 1, 화요일은 2 등입니다.</target>
        </trans-unit>
        <trans-unit id="6a5d3e71c52e9c6c55bf879a8f3240b43592ef22" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 999, representing the milliseconds in the given date according to universal time.</source>
          <target state="translated">지정된 날짜의 표준시를 기준으로 밀리 초를 나타내는 0에서 999 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c4231138e078d6640fb02c9c25d9896be84a001a" translate="yes" xml:space="preserve">
          <source>An integer number, between 0 and 999, representing the milliseconds portion of the given date object. This method is a companion to the other UTC based methods that give hour portion, minute portion, etc.; this method gives milliseconds portion.</source>
          <target state="translated">주어진 날짜 개체의 밀리 초 부분을 나타내는 0에서 999 사이의 정수입니다. 이 방법은 시간 부분, 분 부분 등을 제공하는 다른 UTC 기반 방법의 동반자입니다. 이 방법은 밀리 초 부분을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b365bdcc543e89595531fa9a1b8aa86a13679615" translate="yes" xml:space="preserve">
          <source>An integer number, between 1 and 31, representing the day of the month for the given date according to local time.</source>
          <target state="translated">현지 시간에 따라 지정된 날짜의 날짜를 나타내는 1에서 31 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="2f08d00e1b173f560b35429c221a4caaf7baac5f" translate="yes" xml:space="preserve">
          <source>An integer number, between 1 and 31, representing the day of the month in the given date according to universal time.</source>
          <target state="translated">1에서 31 사이의 정수로, 표준시에 따라 주어진 날짜의 날짜를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e5ee2460e6d16d876ed9e6ade87f029dabab2d3" translate="yes" xml:space="preserve">
          <source>An integer parsed from the given &lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;var&gt;string&lt;/var&gt;&lt;/code&gt; 에서 파싱 된 정수 .</target>
        </trans-unit>
        <trans-unit id="17ddd4175df2c1bb6050443d893c9febc839b102" translate="yes" xml:space="preserve">
          <source>An integer representing the day of the month.</source>
          <target state="translated">월의 일을 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="647f4f4862274d7e0970767ba9be02ae17cd4bbf" translate="yes" xml:space="preserve">
          <source>An integer representing the index at which to start the search. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">검색을 시작할 인덱스를 나타내는 정수입니다. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f35f4daf059f1c306117b1bfaa6ea2c0b629f0f3" translate="yes" xml:space="preserve">
          <source>An integer representing the index at which to start the search; the default value is &lt;code&gt;0&lt;/code&gt;. For &lt;code&gt;fromIndex&lt;/code&gt; values lower than &lt;code&gt;0&lt;/code&gt; or greater than &lt;code&gt;str.length&lt;/code&gt;, the search starts at index &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;str.length&lt;/code&gt; respectively.</source>
          <target state="translated">검색을 시작할 색인을 나타내는 정수. 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다. 들면 &lt;code&gt;fromIndex&lt;/code&gt; 와의 값이보다 낮은 &lt;code&gt;0&lt;/code&gt; 또는 이상 &lt;code&gt;str.length&lt;/code&gt; 검색 인덱스에서 시작하여 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;str.length&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="209a9c0e9cc009c55d6958232eb29f3e5a9d99d7" translate="yes" xml:space="preserve">
          <source>An integer representing the number of milliseconds since 1 January 1970, 00:00:00 UTC.</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC 이후의 밀리 초 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="6e21f096c448ce606f47e63face34d6309b8df22" translate="yes" xml:space="preserve">
          <source>An integer specifying the number of significant digits.</source>
          <target state="translated">유효 자릿수를 지정하는 정수.</target>
        </trans-unit>
        <trans-unit id="dcd6dd9cd13569033c0915a39e4d5a0f9941080f" translate="yes" xml:space="preserve">
          <source>An integer specifying the numeric value of the year, for example, 1995.</source>
          <target state="translated">연도의 숫자 값을 지정하는 정수입니다 (예 : 1995).</target>
        </trans-unit>
        <trans-unit id="5aea6935c1bbb2f34ac703e6e0140659572669f1" translate="yes" xml:space="preserve">
          <source>An integer typed array. One of &lt;a href=&quot;../int8array&quot;&gt;&lt;code&gt;Int8Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../uint8array&quot;&gt;&lt;code&gt;Uint8Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../int16array&quot;&gt;&lt;code&gt;Int16Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../uint16array&quot;&gt;&lt;code&gt;Uint16Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../int32array&quot;&gt;&lt;code&gt;Int32Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../uint32array&quot;&gt;&lt;code&gt;Uint32Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../bigint64array&quot;&gt;&lt;code&gt;BigInt64Array&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../biguint64array&quot;&gt;&lt;code&gt;BigUint64Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 유형 배열. 하나 &lt;a href=&quot;../int8array&quot;&gt; &lt;code&gt;Int8Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../uint8array&quot;&gt; &lt;code&gt;Uint8Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../int16array&quot;&gt; &lt;code&gt;Int16Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../uint16array&quot;&gt; &lt;code&gt;Uint16Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../int32array&quot;&gt; &lt;code&gt;Int32Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../uint32array&quot;&gt; &lt;code&gt;Uint32Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../bigint64array&quot;&gt; &lt;code&gt;BigInt64Array&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../biguint64array&quot;&gt; &lt;code&gt;BigUint64Array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a9589e9e9d4504cb0febd0da375260b1780d22" translate="yes" xml:space="preserve">
          <source>An integer value representing the number of milliseconds since January 1, 1970, 00:00:00 UTC (the ECMAScript epoch, equivalent to the UNIX epoch), with leap seconds ignored. Keep in mind that most &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16&quot;&gt;UNIX Timestamp&lt;/a&gt; functions are only accurate to the nearest second.</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC (UNIX epoch에 해당하는 ECMAScript epoch) 이후의 밀리 초 수를 나타내는 정수 값이며 윤초는 무시됩니다. 대부분의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16&quot;&gt;UNIX 타임 스탬프&lt;/a&gt; 함수는 가장 가까운 초까지만 정확합니다.</target>
        </trans-unit>
        <trans-unit id="32c31af829f43ba0e3522318e8262aea10dc4d63" translate="yes" xml:space="preserve">
          <source>An integer.</source>
          <target state="translated">정수.</target>
        </trans-unit>
        <trans-unit id="dc997dad4494439606eb480415acf8f1c0c6b05c" translate="yes" xml:space="preserve">
          <source>An invalid array length might appear in these situations:</source>
          <target state="translated">다음과 같은 경우 잘못된 배열 길이가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="506ee6e30644d516e304fc8dfc1b1805e6799886" translate="yes" xml:space="preserve">
          <source>An iterable object, such as an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;../../iteration_protocols#The_iterable_protocol&quot;&gt;iterable&lt;/a&gt;.</source>
          <target state="translated">반복 가능한 객체 (예 : &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; )&lt;/a&gt; . &lt;a href=&quot;../../iteration_protocols#The_iterable_protocol&quot;&gt;iterable을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="072ebc4cb51d3e0446dbaaf95877eb99fb472cf5" translate="yes" xml:space="preserve">
          <source>An iterable object, such as an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable&quot;&gt;iterable&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 와 같은 반복 가능한 객체 입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable&quot;&gt;iterable&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="337a36e4669bd324b675d78d08466b5bd302477d" translate="yes" xml:space="preserve">
          <source>An iterable object, such as an Array</source>
          <target state="translated">반복 가능한 객체 (예 : Array)</target>
        </trans-unit>
        <trans-unit id="589a4d7fca7d60d5b7dc9a637c909dece6af7c81" translate="yes" xml:space="preserve">
          <source>An iterable of errors, may not actually be &lt;a href=&quot;../error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">반복 가능한 오류는 실제로 &lt;a href=&quot;../error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 인스턴스 가 아닐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f149abfff83b66c7ebbfb81fbb14f51ec0ef4ce9" translate="yes" xml:space="preserve">
          <source>An iterable such as &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; or other objects implementing the &lt;a href=&quot;../../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 과 같은 iterable 또는 &lt;a href=&quot;../../iteration_protocols#The_iterable_protocol&quot;&gt;iterable 프로토콜을&lt;/a&gt; 구현하는 다른 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="5f2ede100cbd0f6ec44df1183f037c33e90c448d" translate="yes" xml:space="preserve">
          <source>An object containing all own property descriptors of an object. Might be an empty object, if there are no properties.</source>
          <target state="translated">객체의 모든 고유 속성 설명자를 포함하는 객체입니다. 속성이없는 경우 빈 개체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8a04d3b83e76e1d31794bcb1d321337a1454b6" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;../memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of &lt;code&gt;module&lt;/code&gt; or else a &lt;a href=&quot;../linkerror&quot;&gt;&lt;code&gt;WebAssembly.LinkError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;../memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 객체 와 같이 새로 생성 된 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값을 포함하는 객체입니다. 선언 된 각 &lt;code&gt;module&lt;/code&gt; 가져 오기에 대해 하나의 일치 속성이 있어야합니다 . 그렇지 않으면 &lt;a href=&quot;../linkerror&quot;&gt; &lt;code&gt;WebAssembly.LinkError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46ea25370eaef0407e8dc3262ed647ebe09efdb1" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of &lt;code&gt;module&lt;/code&gt; or else a &lt;a href=&quot;linkerror&quot;&gt;&lt;code&gt;WebAssembly.LinkError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 객체 와 같이 새로 생성 된 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값을 포함하는 객체입니다. 선언 된 &lt;code&gt;module&lt;/code&gt; 가져 오기마다 하나의 일치하는 속성이 있어야합니다. . 그렇지 않으면 &lt;a href=&quot;linkerror&quot;&gt; &lt;code&gt;WebAssembly.LinkError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3bec7bd7024bb97b0837a10deb648b4045bc8dac" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of &lt;code&gt;module&lt;/code&gt; or else a &lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 객체 와 같이 새로 만든 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값이 포함 된 객체입니다. 선언 된 각 &lt;code&gt;module&lt;/code&gt; 가져 오기에 대해 일치하는 특성이 하나 있어야합니다 . 그렇지 않으면 &lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e19b4618b39c0485290c2d5d07e27010bca56f33" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of the compiled module or else a &lt;a href=&quot;linkerror&quot;&gt;&lt;code&gt;WebAssembly.LinkError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 와 같이 새로 생성 된 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값을 포함하는 객체입니다. 객체 객체입니다. 컴파일 된 모듈의 선언 된 가져 오기마다 하나의 일치 속성이 있어야합니다 . 그렇지 않으면 &lt;a href=&quot;linkerror&quot;&gt; &lt;code&gt;WebAssembly.LinkError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b1d73c63f41dfe35f11e6718cabf1dcc6a7ea7" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of the compiled module or else a &lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 객체 와 같이 새로 만든 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값이 포함 된 객체입니다. 컴파일 된 모듈의 선언 된 각 가져 오기에 대해 일치하는 특성이 하나씩 있어야합니다 . 그렇지 않으면 &lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9dabc0f328f544b71e23a30a35dc738a1b13d4e" translate="yes" xml:space="preserve">
          <source>An object containing the values to be imported into the newly-created &lt;code&gt;Instance&lt;/code&gt;, such as functions or &lt;a href=&quot;memory&quot;&gt;&lt;code&gt;WebAssembly.Memory&lt;/code&gt;&lt;/a&gt; objects. There must be one matching property for each declared import of the compiled module or else a &lt;code&gt;&lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">함수 또는 &lt;a href=&quot;memory&quot;&gt; &lt;code&gt;WebAssembly.Memory&lt;/code&gt; &lt;/a&gt; 객체 와 같이 새로 생성 된 &lt;code&gt;Instance&lt;/code&gt; 로 가져올 값을 포함하는 객체입니다. 컴파일 된 모듈의 선언 된 가져 오기마다 하나의 일치 속성이 있어야합니다 . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;linkerror&quot;&gt;WebAssembly.LinkError&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed4554d3a9bfe10fc9274f6580e3a99041e44b73" translate="yes" xml:space="preserve">
          <source>An object copy function</source>
          <target state="translated">객체 복사 기능</target>
        </trans-unit>
        <trans-unit id="f2bb3dbcab4a3947fe5e075642972a91b8ef5b99" translate="yes" xml:space="preserve">
          <source>An object initializer is an expression that describes the initialization of an &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;. Objects consist of &lt;em&gt;properties&lt;/em&gt;, which are used to describe an object. The values of object properties can either contain &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/primitive&quot;&gt;primitive&lt;/a&gt; data types or other objects.</source>
          <target state="translated">개체 이니셜 라이저의 초기화를 설명하는 표현이다 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; . 객체 는 객체를 설명하는 데 사용되는 &lt;em&gt;속성&lt;/em&gt; 으로 구성됩니다 . 객체 속성의 값은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/primitive&quot;&gt;기본&lt;/a&gt; 데이터 유형 또는 기타 객체를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69c8c102247f74c4759a203869bb7774da7adb9b" translate="yes" xml:space="preserve">
          <source>An object initializer is an expression that describes the initialization of an &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;. Objects consist of &lt;em&gt;properties&lt;/em&gt;, which are used to describe an object. Values of object properties can either contain &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/primitive&quot;&gt;primitive&lt;/a&gt; data types or other objects.</source>
          <target state="translated">객체 이니셜 라이저는 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 의 초기화를 설명하는 표현식입니다 . 객체 는 객체를 설명하는 데 사용되는 &lt;em&gt;properties&lt;/em&gt; 로 구성됩니다 . 객체 속성 값은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/primitive&quot;&gt;기본&lt;/a&gt; 데이터 유형 또는 다른 객체를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99a621d988e485ace47a397128dc8e8d287136fd" translate="yes" xml:space="preserve">
          <source>An object is an iterator when it implements a &lt;code&gt;&lt;strong&gt;next()&lt;/strong&gt;&lt;/code&gt; method with the following semantics:</source>
          <target state="translated">객체는 다음 시맨틱 으로 &lt;code&gt;&lt;strong&gt;next()&lt;/strong&gt;&lt;/code&gt; 메소드를 구현할 때 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="f11c3f8e12b5acf0a8a11cbec820f5fa06996f30" translate="yes" xml:space="preserve">
          <source>An object is expected somewhere and wasn't provided. &lt;a href=&quot;../global_objects/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; is not an object and won't work. You must provide a proper object in the given situation.</source>
          <target state="translated">어딘가에 개체가 있어야하고 제공되지 않았습니다. &lt;a href=&quot;../global_objects/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 은 객체가 아니며 작동하지 않습니다. 주어진 상황에서 적절한 대상을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4dbcd9a5cf0ba1654890be421a68b53eed3db69" translate="yes" xml:space="preserve">
          <source>An object is extensible if new properties can be added to it. &lt;code&gt;Object.preventExtensions()&lt;/code&gt; marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be &lt;em&gt;deleted&lt;/em&gt;. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; (most commonly, but not exclusively, when in &lt;a href=&quot;../../strict_mode&quot;&gt;strict mode&lt;/a&gt;).</source>
          <target state="translated">새 속성을 추가 할 수있는 경우 개체를 확장 할 수 있습니다. &lt;code&gt;Object.preventExtensions()&lt;/code&gt; 는 객체를 더 이상 확장 할 수없는 것으로 표시하므로 확장 불가능으로 표시되었을 당시의 속성을 넘어서는 속성을 가질 수 없습니다. 일반적으로 확장 불가능한 객체의 속성은 여전히 &lt;em&gt;삭제&lt;/em&gt; 될 수 있습니다 . 확장 불가능한 객체에 새 속성을 추가하려는 시도는 자동으로 또는 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시켜 실패합니다. (가장 일반적으로 &lt;a href=&quot;../../strict_mode&quot;&gt;엄격 모드에&lt;/a&gt; 있을 때 배타적이지는 않음 ).</target>
        </trans-unit>
        <trans-unit id="4436066d53f46a0d1753452787cf7af4d3ecb195" translate="yes" xml:space="preserve">
          <source>An object is extensible if new properties can be added to it. &lt;code&gt;Object.preventExtensions()&lt;/code&gt; marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be &lt;em&gt;deleted&lt;/em&gt;. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; (most commonly, but not exclusively, when in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;strict mode&lt;/a&gt;).</source>
          <target state="translated">새 속성을 추가 할 수 있으면 개체를 확장 할 수 있습니다. &lt;code&gt;Object.preventExtensions()&lt;/code&gt; 는 객체를 더 이상 확장 할 수없는 것으로 표시하므로 확장 할 수없는 것으로 표시된 시점보다 더 이상 속성을 갖지 않습니다. 확장 할 수없는 객체의 속성은 일반적으로 여전히 &lt;em&gt;삭제&lt;/em&gt; 될 수 있습니다 . 확장 불가능한 객체에 새 속성을 추가하려고 시도하면 자동으로 또는 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; (가장 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;엄격&lt;/a&gt; 하지만 엄격하게 모드 가 아닌 경우)가 발생하여 실패 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf3070f43e03d203dcef8fb9469bdfb447fa49f1" translate="yes" xml:space="preserve">
          <source>An object is frozen if and only if it is not &lt;a href=&quot;isextensible&quot;&gt;extensible&lt;/a&gt;, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.</source>
          <target state="translated">&lt;a href=&quot;isextensible&quot;&gt;확장&lt;/a&gt; 할 수없는 경우에만 객체가 고정 되고 모든 속성을 구성 할 수없고 모든 데이터 속성 (즉, getter 또는 setter 구성 요소가있는 접근 자 속성이 아닌 속성)이 쓰기 불가능한 경우에만 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="712ffe697d71b130ef3239945df80e1a6a9491bb" translate="yes" xml:space="preserve">
          <source>An object of named capturing groups whose keys are the names and values are the capturing groups or &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; if no named capturing groups were defined. See &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges&quot;&gt;Groups and Ranges&lt;/a&gt; for more information.</source>
          <target state="translated">키가 이름이고 값이 캡처 그룹이거나 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 명명 된 캡처 그룹의 개체 명명 된 캡처 링 그룹이 정의 경우 . 자세한 내용은 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges&quot;&gt;그룹 및 범위&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6df81df7baba66915feda74646cf84534079038b" translate="yes" xml:space="preserve">
          <source>An object that can contain the following members:</source>
          <target state="translated">다음 멤버를 포함 할 수있는 객체 :</target>
        </trans-unit>
        <trans-unit id="c6cf93c7c289ecebcd9f2ece530dd346913a95fe" translate="yes" xml:space="preserve">
          <source>An object that contains configuration for the Locale. Keys are Unicode locale tags, values are valid Unicode tag values.</source>
          <target state="translated">Locale에 대한 구성을 포함하는 개체입니다. 키는 유니 코드 로케일 태그이고 값은 유효한 유니 코드 태그 값입니다.</target>
        </trans-unit>
        <trans-unit id="f02100f32e5bcd97721742e5813decce92bc3c34" translate="yes" xml:space="preserve">
          <source>An object value of whose own and inherited property names are excluded from the &lt;code&gt;&lt;a href=&quot;../statements/with&quot;&gt;with&lt;/a&gt;&lt;/code&gt; environment bindings of the associated object.</source>
          <target state="translated">고유하고 상속 된 특성 이름의 오브젝트 값이 연관된 오브젝트 의 &lt;code&gt;&lt;a href=&quot;../statements/with&quot;&gt;with&lt;/a&gt;&lt;/code&gt; 환경 바인딩 에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="85a731bb400404166a455c869da7701f54ab8f37" translate="yes" xml:space="preserve">
          <source>An object whose &lt;a href=&quot;webassembly/memory/buffer&quot;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt; property is a resizable &lt;a href=&quot;arraybuffer&quot;&gt;ArrayBuffer&lt;/a&gt; that holds the raw bytes of memory accessed by a WebAssembly &lt;code&gt;Instance&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;webassembly/memory/buffer&quot;&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;/a&gt; 속성이 크기 조정 가능한 객체&lt;a href=&quot;arraybuffer&quot;&gt;&lt;/a&gt; WebAssembly &lt;code&gt;Instance&lt;/code&gt; 액세스 한 메모리의 원시 바이트를 보유 ArrayBuffer .</target>
        </trans-unit>
        <trans-unit id="2817a49d74f07b9fbbb93dc2e97b4df5f01eb5f0" translate="yes" xml:space="preserve">
          <source>An object whose keys represent the names of properties to be defined or modified and whose values are objects describing those properties. Each value in &lt;code&gt;props&lt;/code&gt; must be either a data descriptor or an accessor descriptor; it cannot be both (see &lt;a href=&quot;defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; for more details).</source>
          <target state="translated">키가 정의 또는 수정할 속성의 이름을 나타내고 값이 해당 속성을 설명하는 개체 인 개체입니다. &lt;code&gt;props&lt;/code&gt; 의 각 값은 데이터 설명자 또는 접근 자 설명자 여야합니다. 둘 다일 수는 없습니다 (자세한 내용은 &lt;a href=&quot;defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="820a8026ea9b80267138c0a0b12726227ac4c231" translate="yes" xml:space="preserve">
          <source>An object whose own enumerable properties constitute descriptors for the properties to be defined or modified. Property descriptors present in objects come in two main flavors: data descriptors and accessor descriptors (see &lt;a href=&quot;defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; for more details). Descriptors have the following keys:</source>
          <target state="translated">자체 열거 가능한 속성을 가진 객체는 정의되거나 수정 될 속성의 설명자를 구성합니다. 객체에 존재하는 속성 디스크립터는 데이터 디스크립터와 접근 자 디스크립터의 두 가지 주요 특징이 있습니다 (자세한 내용은 &lt;a href=&quot;defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 참조). 설명자에는 다음 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff96a012649da26d6ad3f16cf10c95ceaed68e32" translate="yes" xml:space="preserve">
          <source>An object whose properties are functions define the behavior of proxy &lt;code&gt;&lt;var&gt;p&lt;/var&gt;&lt;/code&gt; when an operation is performed on it.</source>
          <target state="translated">속성이 함수 인 객체 는 작업이 수행 될 때 프록시 &lt;code&gt;&lt;var&gt;p&lt;/var&gt;&lt;/code&gt; 의 동작을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="18167a9b504993f9580b0cd5dc93aab1b8a20097" translate="yes" xml:space="preserve">
          <source>An object whose properties are functions that define the behavior of the proxy when an operation is performed on it.</source>
          <target state="translated">작업이 수행 될 때 프록시의 동작을 정의하는 함수가 속성 인 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9a03bc5e160e766a9ed1913bb0e172b19eaac291" translate="yes" xml:space="preserve">
          <source>An object whose properties are functions which define the behavior of the proxy when an operation is performed on it.</source>
          <target state="translated">작업이 수행 될 때 프록시의 동작을 정의하는 속성이 속성 인 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9ef63f5b81d4a82352600a7b952ee57872f7bdd2" translate="yes" xml:space="preserve">
          <source>An object with configuration properties, for numbers see &lt;a href=&quot;../number/tolocalestring&quot;&gt;&lt;code&gt;Number.prototype.toLocaleString()&lt;/code&gt;&lt;/a&gt;, and for dates see &lt;a href=&quot;../date/tolocalestring&quot;&gt;&lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 속성이있는 객체는 숫자에 대해서는 &lt;a href=&quot;../number/tolocalestring&quot;&gt; &lt;code&gt;Number.prototype.toLocaleString()&lt;/code&gt; &lt;/a&gt; 참조하고 날짜에 대해서는 &lt;a href=&quot;../date/tolocalestring&quot;&gt; &lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="407f8e249c84df72579c5561e84cc72e4fa34177" translate="yes" xml:space="preserve">
          <source>An object with properties reflecting the locale and formatting options computed during the construction of the given &lt;a href=&quot;../displaynames&quot;&gt;&lt;code&gt;DisplayNames&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">지정된 &lt;a href=&quot;../displaynames&quot;&gt; &lt;code&gt;DisplayNames&lt;/code&gt; &lt;/a&gt; 개체를 생성하는 동안 계산 된 로캘 및 서식 옵션을 반영하는 속성이있는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="e522425d30a2e6f0a5d94f4411a40d9ca0a98307" translate="yes" xml:space="preserve">
          <source>An object with properties reflecting the locale and formatting options computed during the construction of the given &lt;a href=&quot;../listformat&quot;&gt;&lt;code&gt;ListFormat&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">지정된 &lt;a href=&quot;../listformat&quot;&gt; &lt;code&gt;ListFormat&lt;/code&gt; &lt;/a&gt; 객체를 생성하는 동안 계산 된 로케일 및 서식 옵션을 반영하는 속성이있는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="12cce90e8314992290092e3423e0c6e851c132e8" translate="yes" xml:space="preserve">
          <source>An object with some or all of the following properties:</source>
          <target state="translated">다음 속성의 일부 또는 전부를 가진 개체 :</target>
        </trans-unit>
        <trans-unit id="8c49c8fdfe03520a4f22227a3dace23aa8bffea7" translate="yes" xml:space="preserve">
          <source>An object's &lt;code&gt;valueOf&lt;/code&gt; method is usually invoked by JavaScript, but you can invoke it yourself as follows:</source>
          <target state="translated">객체의 &lt;code&gt;valueOf&lt;/code&gt; 메소드는 일반적으로 JavaScript에 의해 호출되지만 다음과 같이 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d68ed57fb9597ee463b003e668302df80df3c76" translate="yes" xml:space="preserve">
          <source>An operation with a fractional result will be truncated when used with a &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">소수 결과가있는 연산은 &lt;code&gt;BigInt&lt;/code&gt; 와 함께 사용할 때 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="f5bff02f5b42f7bb4a8dfe66ea44ca7d8395fddc" translate="yes" xml:space="preserve">
          <source>An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns &lt;code&gt;true&lt;/code&gt; if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.</source>
          <target state="translated">잠금 또는 원자 적 작업을 사용할지 여부를 결정하는 데 사용할 수있는 최적화 기본 요소입니다. 주어진 요소 크기의 배열에 대한 원자 연산이 하드웨어 원자 연산 (잠금과 반대)을 사용하여 구현 될 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 전문가 전용입니다.</target>
        </trans-unit>
        <trans-unit id="d3a29c22a80dd52034e9d0a6bb8b02f51cbeb8da" translate="yes" xml:space="preserve">
          <source>An optimization primitive that can be used to determine whether to use locks or atomic operations. Returns &lt;code&gt;true&lt;/code&gt;, if an atomic operation on arrays of the given element size will be implemented using a hardware atomic operation (as opposed to a lock). Experts only.</source>
          <target state="translated">잠금 또는 원자 연산 사용 여부를 판별하는 데 사용할 수있는 최적화 기본 요소입니다. 주어진 요소 크기의 배열에서 원자 연산이 하드웨어 원자 연산을 사용하여 구현되는 경우 (잠금이 아닌) &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 전문가 만.</target>
        </trans-unit>
        <trans-unit id="d99abf3c44aeed951d4777d64be8fdd61de202ff" translate="yes" xml:space="preserve">
          <source>An optional &lt;a href=&quot;label&quot;&gt;&lt;code&gt;label&lt;/code&gt;&lt;/a&gt; for visual identification or as a target for &lt;a href=&quot;break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시각적 식별 또는 &lt;a href=&quot;break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; 대상으로 사용 되는 선택적 &lt;a href=&quot;label&quot;&gt; &lt;code&gt;label&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f476a0b44d763ae55a8605a52e48c6f66b3cef7" translate="yes" xml:space="preserve">
          <source>An optional &lt;a href=&quot;label&quot;&gt;label&lt;/a&gt; for visual identification or as a target for &lt;a href=&quot;break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시각적 식별을위한 선택적 &lt;a href=&quot;label&quot;&gt;레이블&lt;/a&gt; 또는 &lt;a href=&quot;break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; 대상으로 사용 있습니다.</target>
        </trans-unit>
        <trans-unit id="8183e1d29407b43ac5287e0b76c3f9b4d7c219c8" translate="yes" xml:space="preserve">
          <source>An optional human-readable description of the aggregate error.</source>
          <target state="translated">집계 오류에 대한 사람이 읽을 수있는 선택적 설명입니다.</target>
        </trans-unit>
        <trans-unit id="d74c34f0ecf7dc3de3b2a7be41d3c4d58b0914c6" translate="yes" xml:space="preserve">
          <source>An optional identifier to hold an exception object for the associated &lt;code&gt;catch&lt;/code&gt;-block.</source>
          <target state="translated">관련 항목에 대한 예외 개체를 저장할 선택적 식별자 &lt;code&gt;catch&lt;/code&gt; 블록에 입니다.</target>
        </trans-unit>
        <trans-unit id="3f70d39f14cbc68c1cd5c4b7aa65ac0f905c0522" translate="yes" xml:space="preserve">
          <source>An optional statement that is executed as long as the condition evaluates to true. To execute multiple statements within the loop, use a &lt;a href=&quot;block&quot;&gt;block&lt;/a&gt; statement (&lt;code&gt;{ ... }&lt;/code&gt;) to group those statements.</source>
          <target state="translated">조건이 true로 평가되는 동안 실행되는 선택적 명령문입니다. 루프 내에서 여러 명령문을 실행하려면 &lt;a href=&quot;block&quot;&gt;블록&lt;/a&gt; 명령문 ( &lt;code&gt;{ ... }&lt;/code&gt; )을 사용하여 해당 명령문을 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="24819c5ddedcfe55fcfd455595e135fef10eea7f" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit integer number.</source>
          <target state="translated">부호없는 16 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ce504bc3d402213305047f30718c8aa5119f3d78" translate="yes" xml:space="preserve">
          <source>An unsigned 32-bit integer number.</source>
          <target state="translated">부호없는 32 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c4c36bd8b8247e9a2a43a0269db5cfa41e5b9762" translate="yes" xml:space="preserve">
          <source>An unsigned 8-bit integer number.</source>
          <target state="translated">부호없는 8 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="8e31e6e045f0d9d021bd59af5b2b59d92a760712" translate="yes" xml:space="preserve">
          <source>Anchored sticky flag</source>
          <target state="translated">고정 된 스티커 플래그</target>
        </trans-unit>
        <trans-unit id="f9078d8fbf9d47370364306bfc30567e70f7b2f5" translate="yes" xml:space="preserve">
          <source>Anchored sticky flag behavior per ES2015</source>
          <target state="translated">ES2015에 따라 고정 된 스티커 동작</target>
        </trans-unit>
        <trans-unit id="b108963d124df70a2f67339c2de1882421596e6a" translate="yes" xml:space="preserve">
          <source>Anchors created with the &lt;code&gt;anchor()&lt;/code&gt; method become elements in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/anchors&quot;&gt;&lt;code&gt;document.anchors&lt;/code&gt;&lt;/a&gt; array.</source>
          <target state="translated">&lt;code&gt;anchor()&lt;/code&gt; 메서드로 만든 앵커 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/anchors&quot;&gt; &lt;code&gt;document.anchors&lt;/code&gt; &lt;/a&gt; 배열의 요소가 됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3fb086b2e3af2c93b596641bb4aca8ea03a74e" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;formatToParts&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;formatToParts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2adfedf85e6eb6b155c99d184553081314d22ff9" translate="yes" xml:space="preserve">
          <source>And also:</source>
          <target state="translated">그리고 또한:</target>
        </trans-unit>
        <trans-unit id="a9158d219a6ae1568e116122989b29c295fb483b" translate="yes" xml:space="preserve">
          <source>And finally, for &lt;strong&gt;named functions&lt;/strong&gt; we treat arrow expressions like variables</source>
          <target state="translated">그리고 마지막으로 &lt;strong&gt; 명명 된 함수의 경우&lt;/strong&gt; 화살표 표현식을 변수처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="d29c3e2888737fa5cb456b54f6811f8aa4029364" translate="yes" xml:space="preserve">
          <source>And if you were to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">그리고 만약 당신이 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 를 제공한다면 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7480d2aeec56676be28d36508a4c39dd4fe7bdb" translate="yes" xml:space="preserve">
          <source>And if you were to provide an &lt;code&gt;initialValue&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">그리고 &lt;code&gt;initialValue&lt;/code&gt; 를 제공 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="672a025cb43c547f7536ec579a66e6ce99bf4379" translate="yes" xml:space="preserve">
          <source>And not equivalent to the following which would always perform an assignment:</source>
          <target state="translated">그리고 항상 할당을 수행하는 다음과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cf4b1ce40c89b2855c5fbfaf193e6fc17095989" translate="yes" xml:space="preserve">
          <source>And now, let's re-throw the error.</source>
          <target state="translated">이제 오류를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a2a432eee98ed07f9acd2295f1515c76ea6f6efb" translate="yes" xml:space="preserve">
          <source>And now, let's rethrow the error.</source>
          <target state="translated">이제 오류를 다시 던져 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e133533c62c20c49e00f259c00bce75deb9562ab" translate="yes" xml:space="preserve">
          <source>And then instantiate two new &lt;code&gt;Person&lt;/code&gt; objects as follows:</source>
          <target state="translated">그런 다음 두 개의 새 &lt;code&gt;Person&lt;/code&gt; 을 인스턴스화합니다. 과 같이 객체 합니다.</target>
        </trans-unit>
        <trans-unit id="9e40ca491b5dc7bb4160c2cc168b1951a8bcd2fb" translate="yes" xml:space="preserve">
          <source>And then instantiate two new &lt;code&gt;person&lt;/code&gt; objects as follows:</source>
          <target state="translated">그런 다음 다음과 같이 두 개의 새로운 &lt;code&gt;person&lt;/code&gt; 객체 를 인스턴스화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5b93109d2910f83b46a8f8b84565a2b90f04e8f" translate="yes" xml:space="preserve">
          <source>Android webview</source>
          <target state="translated">안드로이드 웹뷰</target>
        </trans-unit>
        <trans-unit id="a41a56fc235abdf7386b1d8797eb97d0da88f3a0" translate="yes" xml:space="preserve">
          <source>Anonymous function expression</source>
          <target state="translated">익명 함수 표현</target>
        </trans-unit>
        <trans-unit id="2fa2afa4021d3c7afb706a67d2f9a41524ab1bba" translate="yes" xml:space="preserve">
          <source>Anonymous function expressions that were created using the keyword &lt;code&gt;function&lt;/code&gt; or arrow functions would have &lt;code&gt;&quot;&quot;&lt;/code&gt; (an empty string) as their name.</source>
          <target state="translated">키워드 &lt;code&gt;function&lt;/code&gt; 또는 화살표 함수를 사용하여 만든 익명 함수 식 에는 이름으로 &lt;code&gt;&quot;&quot;&lt;/code&gt; (빈 문자열)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9e238257091e7b815453db1e7f955856aac944" translate="yes" xml:space="preserve">
          <source>Another Example: An &lt;a href=&quot;if...else&quot;&gt;&lt;code&gt;if...else&lt;/code&gt;&lt;/a&gt; statement without curly braces (&lt;code&gt;{}&lt;/code&gt;). If &lt;code&gt;three&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, nothing will happen, &lt;code&gt;four&lt;/code&gt; does not matter, and also the &lt;code&gt;launchRocket()&lt;/code&gt; function in the &lt;code&gt;else&lt;/code&gt; case will not be executed.</source>
          <target state="translated">다른 예 : 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )가 없는 &lt;a href=&quot;if...else&quot;&gt; &lt;code&gt;if...else&lt;/code&gt; &lt;/a&gt; 문 경우 &lt;code&gt;three&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 아무것도 일어날 것 &lt;code&gt;four&lt;/code&gt; 중요하지 않습니다, 또한 &lt;code&gt;launchRocket()&lt;/code&gt; 의 기능이 &lt;code&gt;else&lt;/code&gt; 경우는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d54af0c4eed0044ff19131aa0adfda5b38426da" translate="yes" xml:space="preserve">
          <source>Another compelling reason for &lt;code&gt;matchAll&lt;/code&gt; is the improved access to capture groups.</source>
          <target state="translated">&lt;code&gt;matchAll&lt;/code&gt; 의 또 다른 강력한 이유 는 캡처 그룹에 대한 향상된 액세스입니다.</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">다른 예시</target>
        </trans-unit>
        <trans-unit id="38aefb666b7ab2db7e6b6eb0f628cc7c37e33e6e" translate="yes" xml:space="preserve">
          <source>Another example of temporal dead zone combined with lexical scoping</source>
          <target state="translated">어휘 범위와 결합 된 임시 데드 존의 또 다른 예</target>
        </trans-unit>
        <trans-unit id="5ab1c822e9b3b96cbfa2bd5e2a0b2913a89156c6" translate="yes" xml:space="preserve">
          <source>Another example of throwing an object</source>
          <target state="translated">객체를 던지는 또 다른 예</target>
        </trans-unit>
        <trans-unit id="db2f210ea05881fd5ef1b241094fcad01c62cbe2" translate="yes" xml:space="preserve">
          <source>Another example that one could make with comma operator is processing before returning. As stated, only the last element will be returned but all others are going to be evaluated as well. So, one could do:</source>
          <target state="translated">쉼표 연산자로 만들 수있는 또 다른 예는 반환하기 전에 처리하는 것입니다. 언급 한 바와 같이 마지막 요소 만 반환되지만 다른 요소도 모두 평가됩니다. 따라서 할 수있는 일 :</target>
        </trans-unit>
        <trans-unit id="29729dc342f0f212d34bf555bf46a096e78104b3" translate="yes" xml:space="preserve">
          <source>Another feature that was deprecated was &lt;code&gt;arguments.callee.caller&lt;/code&gt;, or more specifically &lt;code&gt;Function.caller&lt;/code&gt;. Why is this? Well, at any point in time you can find the deepest caller of any function on the stack, and as I said above looking at the call stack has one single major effect: it makes a large number of optimizations impossible, or much much more difficult. For example, if you cannot guarantee that a function &lt;code&gt;f&lt;/code&gt; will not call an unknown function, it is not possible to inline &lt;code&gt;f&lt;/code&gt;. Basically it means that any call site that may have been trivially inlinable accumulates a large number of guards:</source>
          <target state="translated">더 이상 사용되지 않는 또 다른 기능은 &lt;code&gt;arguments.callee.caller&lt;/code&gt; 또는보다 구체적으로 &lt;code&gt;Function.caller&lt;/code&gt; 입니다. 왜 이런거야? 글쎄, 어느 시점에서든 스택에서 함수의 가장 깊은 호출자를 찾을 수 있으며 위에서 언급했듯이 콜 스택을 보면 하나의 주요 효과가 있습니다. 많은 최적화가 불가능하거나 훨씬 어렵습니다. . 당신이 함수 보장 할 수 없습니다 예를 들어, &lt;code&gt;f&lt;/code&gt; 는 알 수없는 함수를 호출하지 않습니다, 그것은 인라인 할 수 없습니다 &lt;code&gt;f&lt;/code&gt; . 기본적으로 그것은 사소하게 불쾌했을 수있는 모든 호출 사이트에 많은 수의 경비원이 축적됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="76fc00cfc08f8f3c2a4610681b74ef7a539ad447" translate="yes" xml:space="preserve">
          <source>Another option for this use case might be to use a &lt;a href=&quot;../global_objects/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 사용 사례의 또 다른 옵션은 &lt;a href=&quot;../global_objects/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="659dd4787a10ee95228f3a766583c861c4376858" translate="yes" xml:space="preserve">
          <source>Another possibility is to use &lt;a href=&quot;../template_literals&quot;&gt;template literals&lt;/a&gt;, which are supported in ECMAScript 2015 environments:</source>
          <target state="translated">또 다른 가능성은 ECMAScript 2015 환경에서 지원되는 &lt;a href=&quot;../template_literals&quot;&gt;템플릿 리터럴&lt;/a&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="678fdef9c1a3fde8a191396e515b2108c7749a62" translate="yes" xml:space="preserve">
          <source>Another simple example using &lt;code&gt;Promise&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to load an image is available at the MDN GitHub &lt;a href=&quot;https://github.com/mdn/js-examples/tree/master/promises-test&quot;&gt;js-examples&lt;/a&gt; repository. You can also &lt;a href=&quot;https://mdn.github.io/js-examples/promises-test/&quot;&gt;see it in action&lt;/a&gt;. Each step is commented and allows you to follow the Promise and XHR architecture closely.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 사용하여 이미지를로드하는 또 다른 간단한 예 는 MDN GitHub &lt;a href=&quot;https://github.com/mdn/js-examples/tree/master/promises-test&quot;&gt;js-examples&lt;/a&gt; 리포지토리에서 확인할 수 있습니다. 당신은 또한 &lt;a href=&quot;https://mdn.github.io/js-examples/promises-test/&quot;&gt;그것을 실제로 볼&lt;/a&gt; 수 있습니다 . 각 단계는 주석 처리되어 있으며 Promise 및 XHR 아키텍처를 면밀히 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8c04e1867e064b47ad4b2221b9c4a319b967c39" translate="yes" xml:space="preserve">
          <source>Another simple example using &lt;code&gt;Promise&lt;/code&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to load an image is available at the MDN GitHub &lt;a href=&quot;https://github.com/mdn/js-examples/tree/master/promises-test&quot;&gt;js-examples&lt;/a&gt; repository. You can also &lt;a href=&quot;https://mdn.github.io/js-examples/promises-test/&quot;&gt;see it in action&lt;/a&gt;. Each step is commented on and allows you to follow the Promise and XHR architecture closely.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 사용하여 이미지를로드하는 또 다른 간단한 예 는 MDN GitHub &lt;a href=&quot;https://github.com/mdn/js-examples/tree/master/promises-test&quot;&gt;js-examples&lt;/a&gt; 저장소 에서 사용할 수 있습니다 . 당신은 또한 &lt;a href=&quot;https://mdn.github.io/js-examples/promises-test/&quot;&gt;그것을 실제로 볼&lt;/a&gt; 수 있습니다 . 각 단계에 주석이 달려 있으며 Promise 및 XHR 아키텍처를 면밀히 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a181e40979db43208338191d57acf6b1b4ca1ece" translate="yes" xml:space="preserve">
          <source>Another way would be two to handle the empty case, either before calling &lt;code&gt;reduce&lt;/code&gt;, or in the callback after adding an unexpected dummy initial value.</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;reduce&lt;/code&gt; 를 호출하기 전에 또는 예기치 않은 더미 초기 값을 추가 한 후 콜백에서 빈 케이스를 처리하는 두 가지 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="65dbba8190c1c78cee3f235dda797321e96cf16c" translate="yes" xml:space="preserve">
          <source>Anurag Majumdar - Super &amp;amp; Extends in JavaScript</source>
          <target state="translated">Anurag Majumdar-JavaScript에서 수퍼 및 확장</target>
        </trans-unit>
        <trans-unit id="8fe5105a977c4769f1bd28eaa84cc7507432091d" translate="yes" xml:space="preserve">
          <source>Any JavaScript identifier that is not a reserved word.</source>
          <target state="translated">예약어가 아닌 JavaScript 식별자</target>
        </trans-unit>
        <trans-unit id="d37f0c77a82b0dc9c48652775d8c0df86c964a7e" translate="yes" xml:space="preserve">
          <source>Any JavaScript value returned by the iterator. Can be omitted when &lt;code&gt;done&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">반복자가 반환 한 모든 JavaScript 값입니다. &lt;code&gt;done&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 생략 가능 .</target>
        </trans-unit>
        <trans-unit id="120ebc47eb19aed84fe0fa9335c2121c4d28cc38" translate="yes" xml:space="preserve">
          <source>Any argument in the argument list can use spread syntax and it can be used multiple times.</source>
          <target state="translated">인수 목록의 모든 인수는 스프레드 구문을 사용할 수 있으며 여러 번 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8b562bb735f4067dc9da1e62b0ed53a2464a7a" translate="yes" xml:space="preserve">
          <source>Any argument in the argument list can use spread syntax, and the spread syntax can be used multiple times.</source>
          <target state="translated">인수 목록의 모든 인수는 스프레드 구문을 사용할 수 있으며 스프레드 구문은 여러 번 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d297acf05987414a38f19277e26e954c347bdc8c" translate="yes" xml:space="preserve">
          <source>Any argument value that is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; is treated as if it were &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 인&lt;/a&gt; 인수 값 은 &lt;code&gt;0&lt;/code&gt; 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d8022bc7c6ecc3f95235e0126a70f61a8dc946a" translate="yes" xml:space="preserve">
          <source>Any argument value that is less than 0 or greater than &lt;code&gt;stringName.length&lt;/code&gt; is treated as if it were 0 and &lt;code&gt;stringName.length&lt;/code&gt; respectively. Any argument value that is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; is treated as if it were 0.</source>
          <target state="translated">0보다 작거나 &lt;code&gt;stringName.length&lt;/code&gt; 보다 큰 인수 값은 각각 0과 &lt;code&gt;stringName.length&lt;/code&gt; 인 것처럼 처리됩니다 . &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 인&lt;/a&gt; 인수 값은 마치 0 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f1703017d123e905663da479f61f12f8aa24fc77" translate="yes" xml:space="preserve">
          <source>Any argument value that is less than &lt;code&gt;0&lt;/code&gt; or greater than &lt;code&gt;stringName.length&lt;/code&gt; is treated as if it were &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;stringName.length&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 보다 작거나 &lt;code&gt;stringName.length&lt;/code&gt; 보다 큰 인수 값은 각각 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;stringName.length&lt;/code&gt; 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="462f06d1e073cd86185bb9aaf55b870129c25321" translate="yes" xml:space="preserve">
          <source>Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.</source>
          <target state="translated">모든 코드 포인트는 이스케이프 시퀀스 형태로 나타날 수 있습니다. 문자열 리터럴은 ECMAScript 문자열 값으로 평가됩니다. 이러한 문자열 값을 생성 할 때 유니 코드 코드 포인트는 UTF-16으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e0172cb97961cdda062ca7ce8fac8d0a39efa7ea" translate="yes" xml:space="preserve">
          <source>Any expressions.</source>
          <target state="translated">모든 표현.</target>
        </trans-unit>
        <trans-unit id="c94601c41a96ba46ae20815dea8dbb4c8727e4c6" translate="yes" xml:space="preserve">
          <source>Any function.</source>
          <target state="translated">모든 기능.</target>
        </trans-unit>
        <trans-unit id="88f4c0bee8a7ff7d3a4343d95829f783a371620f" translate="yes" xml:space="preserve">
          <source>Any given exception will be caught only once by the nearest enclosing &lt;code&gt;catch&lt;/code&gt;-block unless it is rethrown. Of course, any new exceptions raised in the &quot;inner&quot; block (because the code in &lt;code&gt;catch&lt;/code&gt;-block may do something that throws), will be caught by the &quot;outer&quot; block.</source>
          <target state="translated">주어진 예외 는 다시 발생하지 않는 한 가장 가까운 둘러싸는 &lt;code&gt;catch&lt;/code&gt; 블록에 의해 한 번만 포착됩니다 . 물론, &quot;내부&quot;블록에서 발생한 모든 새로운 예외는 ( &lt;code&gt;catch&lt;/code&gt; -block 의 코드 가 던지는 일을 할 수 있기 때문에 ) &quot;외부&quot;블록에 의해 잡힐 것입니다.</target>
        </trans-unit>
        <trans-unit id="1df0363b66ad832b2d5de41b91505b4cfbc96ff0" translate="yes" xml:space="preserve">
          <source>Any given exception will be caught only once by the nearest enclosing catch-block unless it is re-thrown. Of course, any new exceptions raised in the &quot;inner&quot; block (because the code in catch-block may do something that throws), will be caught by the &quot;outer&quot; block.</source>
          <target state="translated">주어진 예외는 다시 발생하지 않는 한 가장 가까운 엔 클로징 캐치 블록에 의해 한 번만 포착됩니다. 물론, &quot;내부&quot;블록에서 발생한 새로운 예외 (캐치 블록의 코드가 던질 수 있기 때문에)는 &quot;외부&quot;블록에 의해 포착됩니다.</target>
        </trans-unit>
        <trans-unit id="c57c6045ba537d4f4071760d6b3efdb563da7e55" translate="yes" xml:space="preserve">
          <source>Any literal strings or whitespace in the formatted number.</source>
          <target state="translated">서식이 지정된 숫자의 리터럴 문자열 또는 공백.</target>
        </trans-unit>
        <trans-unit id="dd90c15ad5e32e40f3250e0b9c1cf1a64b4485f1" translate="yes" xml:space="preserve">
          <source>Any negative number divided by &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; is negative Zero.</source>
          <target state="translated">&lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 로 나눈 음수 는 음수 0입니다.</target>
        </trans-unit>
        <trans-unit id="f4f9a99f13863877ce756b248ebeab1f32f415e6" translate="yes" xml:space="preserve">
          <source>Any negative value divided by &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; is positive zero.</source>
          <target state="translated">음수 값을 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 로 나눈 값 은 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="69d70aab2b2c68be24f0e61566d853801ee81d21" translate="yes" xml:space="preserve">
          <source>Any negative value, including &lt;a href=&quot;negative_infinity&quot;&gt;&lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt;&lt;/a&gt;, multiplied by &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; is &lt;a href=&quot;negative_infinity&quot;&gt;&lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;negative_infinity&quot;&gt; &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 를&lt;/a&gt; 포함 하여 &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 를 곱한 음수 값 은 &lt;a href=&quot;negative_infinity&quot;&gt; &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93ed4a42f1477dc2202345409410952854ed731b" translate="yes" xml:space="preserve">
          <source>Any negative value, including &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt;, multiplied by &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; is &lt;a href=&quot;positive_infinity&quot;&gt;&lt;code&gt;POSITIVE_INFINITY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포함 부정적인 값 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 곱 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 가 있다 &lt;a href=&quot;positive_infinity&quot;&gt; &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="549464df94eb314d9570aedac15d470cd515adce" translate="yes" xml:space="preserve">
          <source>Any newline characters inserted in the source are part of the template literal.</source>
          <target state="translated">소스에 삽입 된 모든 개행 문자는 템플릿 리터럴의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="02c4a209de2c2fadc72815c6a463bb88e0037e90" translate="yes" xml:space="preserve">
          <source>Any newline characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:</source>
          <target state="translated">소스에 삽입 된 개행 문자는 템플릿 리터럴의 일부입니다. 일반 문자열을 사용하면 여러 줄 문자열을 가져 오려면 다음 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e783679a6e6d3b22ceca2b95d8f69e073f1687ca" translate="yes" xml:space="preserve">
          <source>Any object of which the value is not &lt;a href=&quot;undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, including a &lt;code&gt;Boolean&lt;/code&gt; object whose value is &lt;code&gt;false&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt; when passed to a conditional statement. For example, the condition in the following &lt;a href=&quot;../statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; statement evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">값이 &lt;code&gt;false&lt;/code&gt; 인 &lt;code&gt;Boolean&lt;/code&gt; 객체를 포함 하여 값이 &lt;a href=&quot;undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 되지 않았 거나 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 이 아닌 객체 는 조건문에 전달 될 때 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다 . 예를 들어, 다음 &lt;a href=&quot;../statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 문의 조건은 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="738a0c7a56a0cdf7441e37fe93cb49a261cc5c7d" translate="yes" xml:space="preserve">
          <source>Any operation that involves a string and is not an addition operation (e.g. &lt;code&gt;&quot;foo&quot; / 3&lt;/code&gt;)</source>
          <target state="translated">문자열을 포함하고 더하기 연산이 아닌 모든 연산 (예 : &lt;code&gt;&quot;foo&quot; / 3&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="baae159e1bc05db0ccfaa73f09024f70815a9c63" translate="yes" xml:space="preserve">
          <source>Any other object</source>
          <target state="translated">다른 물체</target>
        </trans-unit>
        <trans-unit id="3d870d35221986484377d8371800209cb672221c" translate="yes" xml:space="preserve">
          <source>Any positive number divided by &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; is positive Zero.</source>
          <target state="translated">&lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 로 나눈 양수 는 양의 0입니다.</target>
        </trans-unit>
        <trans-unit id="8f2ef7716332780d4cbeb4b02ca293197d780a28" translate="yes" xml:space="preserve">
          <source>Any positive value divided by &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; is negativezero.</source>
          <target state="translated">양수 값을 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 로 나눈 값 은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="71c63b188472aeb3bb2c19b931773ffeb14e9541" translate="yes" xml:space="preserve">
          <source>Any positive value, including &lt;a href=&quot;positive_infinity&quot;&gt;&lt;code&gt;POSITIVE_INFINITY&lt;/code&gt;&lt;/a&gt;, multiplied by &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; is &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt;.</source>
          <target state="translated">을 포함하는 임의의 양수, &lt;a href=&quot;positive_infinity&quot;&gt; &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; &lt;/a&gt; 곱 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 가 있다 &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40663bd051e9eb26e11a76943aa7901805b6a7f7" translate="yes" xml:space="preserve">
          <source>Any positive value, including &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt;, multiplied by &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; is &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt;.</source>
          <target state="translated">을 포함하는 임의의 양수, &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 곱 &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 가 있다 &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f36b58843a66d33558d0519080bc582d8b84843" translate="yes" xml:space="preserve">
          <source>Any property declared with &lt;a href=&quot;../statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../statements/const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; cannot be deleted from the scope within which they were defined.</source>
          <target state="translated">&lt;a href=&quot;../statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../statements/const&quot;&gt; &lt;code&gt;const&lt;/code&gt; 로&lt;/a&gt; 선언 된 속성 은 정의 된 범위에서 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d250a3d163c089daaf861c1b6281450a1214fbee" translate="yes" xml:space="preserve">
          <source>Any property declared with &lt;a href=&quot;../statements/var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; cannot be deleted from the global scope or from a function's scope.</source>
          <target state="translated">&lt;a href=&quot;../statements/var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 로&lt;/a&gt; 선언 된 속성 은 전역 범위 나 함수 범위에서 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe1b3703f73f75fe58f81e1ed59799544c6a1b63" translate="yes" xml:space="preserve">
          <source>Any statement. To execute multiple statements, use a &lt;a href=&quot;block&quot;&gt;block&lt;/a&gt; statement ({ ... }) to group those statements.</source>
          <target state="translated">모든 진술. 여러 명령문을 실행하려면 &lt;a href=&quot;block&quot;&gt;블록&lt;/a&gt; 명령문 ({...})을 사용하여 해당 명령문을 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="1ce2652c4b040238e06008189496237a246ca32b" translate="yes" xml:space="preserve">
          <source>Any string that specifies the &lt;code&gt;href&lt;/code&gt; attribute of the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag; it should be a valid URL (relative or absolute), with any &lt;code&gt;&amp;amp;&lt;/code&gt; characters escaped as &lt;code&gt;&amp;amp;amp;&lt;/code&gt;, and any &lt;code&gt;&quot;&lt;/code&gt; characters escaped as &lt;code&gt;&amp;amp;quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그 의 &lt;code&gt;href&lt;/code&gt; 속성 을 지정하는 문자열 . 어떤으로는 (절대 또는 상대) 유효한 URL이어야 &lt;code&gt;&amp;amp;&lt;/code&gt; 문자로 이스케이프 &lt;code&gt;&amp;amp;amp;&lt;/code&gt; , 및 모든 &lt;code&gt;&quot;&lt;/code&gt; 문자가 &lt;code&gt;&amp;amp;quot;&lt;/code&gt; 이스케이프되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0731bcf6e4efb427019a6c5d202f52547a23214e" translate="yes" xml:space="preserve">
          <source>Any valid expression.</source>
          <target state="translated">유효한 표현식.</target>
        </trans-unit>
        <trans-unit id="f8a80c1d8b906a18596a29b844aca28794484214" translate="yes" xml:space="preserve">
          <source>Any value.</source>
          <target state="translated">모든 값.</target>
        </trans-unit>
        <trans-unit id="79e875b09fd179b1df32cb6b33825331f219f1bd" translate="yes" xml:space="preserve">
          <source>Any variable defined with &lt;code&gt;var&lt;/code&gt; is marked as non-configurable. In the following example, &lt;code&gt;salary&lt;/code&gt; is non-configurable and cannot be deleted. In non-strict mode, the &lt;code&gt;delete&lt;/code&gt; operation will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 로 정의 된 모든 변수 는 구성 할 수없는 것으로 표시됩니다. 다음 예에서 &lt;code&gt;salary&lt;/code&gt; 는 구성 할 수 없으며 삭제할 수 없습니다. 엄격하지 않은 모드에서는 &lt;code&gt;delete&lt;/code&gt; 작업이 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7a84a609481880e442128a873df9896371e4a486" translate="yes" xml:space="preserve">
          <source>Anything to be converted to a string.</source>
          <target state="translated">문자열로 변환 할 항목</target>
        </trans-unit>
        <trans-unit id="d3e109750a4efd5f9de22e23d078725de8858fd9" translate="yes" xml:space="preserve">
          <source>Anyway, it can be simplified using &lt;a href=&quot;../function/bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어쨌든 &lt;a href=&quot;../function/bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; 를&lt;/a&gt; 사용하여 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="236c6d96d1396da47fb718c1c70cbd3dd681a57d" translate="yes" xml:space="preserve">
          <source>Appending Prototype Chains</source>
          <target state="translated">프로토 타입 체인 추가</target>
        </trans-unit>
        <trans-unit id="806aee0e4633c8e7750f3f2812362738aa8d8af0" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to the &lt;code&gt;Set&lt;/code&gt; object. Returns the &lt;code&gt;Set&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 개체에 &lt;code&gt;&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 을 추가 합니다. &lt;code&gt;Set&lt;/code&gt; 개체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3e1c96547e09ee6d604882e24ff555a931b56bd4" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; to the &lt;code&gt;WeakSet&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;WeakSet&lt;/code&gt; 개체에 &lt;code&gt;&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="433e9e96e0b07f8c286dea4d11f453f49714ebe6" translate="yes" xml:space="preserve">
          <source>Appends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.</source>
          <target state="translated">프라 미스에 핸들러를 추가하고 원래 프라 미스가 해결 될 때 해결되는 새 프라 미스를 반환합니다. 처리기는 이행 또는 거부 여부에 관계없이 약속이 해결 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e665300e918d74332b2742b941327096ebc4e41d" translate="yes" xml:space="preserve">
          <source>Appends a handler to the promise, and returns a new promise which is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.</source>
          <target state="translated">약속에 처리기를 추가하고 원래 약속이 해결 될 때 해결되는 새 약속을 반환합니다. 처리기는 약속이 이행되거나 이행되거나 거부 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a1410ae34999bd4955a8e78f8882063187d204fd" translate="yes" xml:space="preserve">
          <source>Appends a new element with the given value to the &lt;code&gt;Set&lt;/code&gt; object. Returns the &lt;code&gt;Set&lt;/code&gt; object.</source>
          <target state="translated">주어진 값을 가진 새로운 요소를 &lt;code&gt;Set&lt;/code&gt; 객체에 추가합니다. 수익 &lt;code&gt;Set&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="a38b2c6702934be92b08ef81b626db7ffc599942" translate="yes" xml:space="preserve">
          <source>Appends a new object with the given value to the &lt;code&gt;WeakSet&lt;/code&gt; object.</source>
          <target state="translated">주어진 값을 가진 새로운 객체를 &lt;code&gt;WeakSet&lt;/code&gt; 객체 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="1766991edca7f510f676e6a40b7fe16f16608e46" translate="yes" xml:space="preserve">
          <source>Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.</source>
          <target state="translated">거부 핸들러 콜백을 약속에 추가하고, 콜백이 호출되면 콜백의 리턴 값 또는 약속이 대신 이행되면 원래 이행 값으로 해결되는 새 약속을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="70a96367ea67f94fc6b60925b6c44c0cdf87e534" translate="yes" xml:space="preserve">
          <source>Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e. if the relevant handler &lt;code&gt;onFulfilled&lt;/code&gt; or &lt;code&gt;onRejected&lt;/code&gt; is not a function).</source>
          <target state="translated">이행 및 거부 핸들러를 약속에 추가하고, 호출 된 핸들러의 리턴 값 또는 약속이 처리되지 않은 경우 (예 : &lt;code&gt;onFulfilled&lt;/code&gt; 또는 &lt;code&gt;onRejected&lt;/code&gt; 의 관련 핸들러 가 함수가 아닌 경우) 원래의 확정 된 값으로 해석되는 새 약속을 리턴합니다. .</target>
        </trans-unit>
        <trans-unit id="383d122890de4ae662a8c62319e7d2f5e0630526" translate="yes" xml:space="preserve">
          <source>Applies a function against an accumulator and each value of the array (from left-to-right) so as to reduce it to a single value. See also &lt;a href=&quot;array/reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기 및 배열의 ​​각 값 (왼쪽에서 오른쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;array/reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="355d38f951494308ad5d8f48a0aae537bdf464be" translate="yes" xml:space="preserve">
          <source>Applies a function against an accumulator and each value of the array (from right-to-left) so as to reduce it to a single value. See also &lt;a href=&quot;array/reduceright&quot;&gt;&lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기 및 배열의 ​​각 값 (오른쪽에서 왼쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;array/reduceright&quot;&gt; &lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eeacb1c816d22849b1be1fe7f2e84686087551d" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.</source>
          <target state="translated">누산기와 배열의 각 값 (왼쪽에서 오른쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="2154cdb14e22c7ce545ad07a11a7b90e5dc570c0" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also &lt;a href=&quot;../array/reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기와 배열의 각 값 (왼쪽에서 오른쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;../array/reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="099b64b5de77495c7e47f56cd30d2f07ec8b4595" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also &lt;a href=&quot;array/reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기와 배열의 각 값 (왼쪽에서 오른쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;array/reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24d67ead42ea329225535c7e0f0ce9b721033789" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from left-to-right) so as to reduce it to a single value. See also &lt;a href=&quot;array/reduce&quot;&gt;&lt;code&gt;Array.prototype.reduce()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기 및 배열의 ​​각 값 (왼쪽에서 오른쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;array/reduce&quot;&gt; &lt;code&gt;Array.prototype.reduce()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27387529f0930425db4f86da78ab484c122b8fc4" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.</source>
          <target state="translated">누산기와 배열의 각 값 (오른쪽에서 왼쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="298c3527001d4e1d738cbe7b386014991537faad" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also &lt;a href=&quot;../array/reduceright&quot;&gt;&lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기와 배열의 각 값 (오른쪽에서 왼쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;../array/reduceright&quot;&gt; &lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14db5180710bd1da842052aa2f9ebdacf810244c" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also &lt;a href=&quot;array/reduceright&quot;&gt;&lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기와 배열의 각 값 (오른쪽에서 왼쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다. &lt;a href=&quot;array/reduceright&quot;&gt; &lt;code&gt;Array.prototype.reduceRight()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c393806e45fa4e9152ad8610af2469c3143412f" translate="yes" xml:space="preserve">
          <source>Apply a function against an accumulator&amp;gt; and each value of the array (from right-to-left) as to reduce it to a single value.</source>
          <target state="translated">accumulator&amp;gt; 및 배열의 ​​각 값 (오른쪽에서 왼쪽으로)에 대해 함수를 적용하여 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="adfb2ef8d1613f689214f2f3c938cdd74c395d2b" translate="yes" xml:space="preserve">
          <source>Apply for new</source>
          <target state="translated">새로운 신청</target>
        </trans-unit>
        <trans-unit id="9a2dcc4f62af67bd61a78054ffb7861d7fe5e35a" translate="yes" xml:space="preserve">
          <source>Apply for new operator</source>
          <target state="translated">신규 사업자 신청</target>
        </trans-unit>
        <trans-unit id="5f9e5b24ba358dca83a601a0f4caf2118c6bd660" translate="yes" xml:space="preserve">
          <source>Approach 1: Returning false</source>
          <target state="translated">접근 방식 1 : 거짓 반환</target>
        </trans-unit>
        <trans-unit id="a32b89cf8e8b10ade8fbe1f7db52d96750492ee8" translate="yes" xml:space="preserve">
          <source>Approach 2: Throwing an Exception</source>
          <target state="translated">접근법 2 : 예외 던지기</target>
        </trans-unit>
        <trans-unit id="53a54822c18ac7656c43da9b8e21c6b857d7887b" translate="yes" xml:space="preserve">
          <source>Arabic-Indic digits</source>
          <target state="translated">아랍어-인도 숫자</target>
        </trans-unit>
        <trans-unit id="7570af5b2814be60d3225f429a5da3b60a955a03" translate="yes" xml:space="preserve">
          <source>Argument length</source>
          <target state="translated">인수 길이</target>
        </trans-unit>
        <trans-unit id="219458337756538964c610a180311ef64788987f" translate="yes" xml:space="preserve">
          <source>Argument to be resolved by this &lt;code&gt;Promise&lt;/code&gt;. Can also be a &lt;code&gt;Promise&lt;/code&gt; or a thenable to resolve.</source>
          <target state="translated">이 &lt;code&gt;Promise&lt;/code&gt; 의해 해결 될 주장 . 또한 일 수 있습니다 &lt;code&gt;Promise&lt;/code&gt; 이나 해결에 thenable.</target>
        </trans-unit>
        <trans-unit id="de8b14636021ee8ac55612174a0e052d70a4d91c" translate="yes" xml:space="preserve">
          <source>Arguments for the function.</source>
          <target state="translated">함수에 대한 인수.</target>
        </trans-unit>
        <trans-unit id="8372bf4b683d80ce379677415160200a3acb0226" translate="yes" xml:space="preserve">
          <source>Arguments object</source>
          <target state="translated">인수 객체</target>
        </trans-unit>
        <trans-unit id="75f3906ff5866811055573d5f65f94577a39b679" translate="yes" xml:space="preserve">
          <source>Arguments to prepend to arguments provided to the bound function when invoking &lt;code&gt;&lt;var&gt;func&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;func&lt;/var&gt;&lt;/code&gt; 를 호출 할 때 바인딩 된 함수에 제공된 인수 앞에 추가 할 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="a9c170746708bafd69661d37a9e52f81b9c365da" translate="yes" xml:space="preserve">
          <source>Arguments to prepend to arguments provided to the bound function when invoking the target function.</source>
          <target state="translated">대상 함수를 호출 할 때 바운드 함수에 제공된 인수 앞에 추가 할 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="ad2101986bf079834f5e97462d8a86b84df9d757" translate="yes" xml:space="preserve">
          <source>Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.</source>
          <target state="translated">산술 연산자는 숫자 값 (리터럴 또는 변수)을 피연산자로 사용하고 단일 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7495d65ea64153e29e757a46e71a985b6c309b41" translate="yes" xml:space="preserve">
          <source>Armenian lower case numerals &amp;mdash; algorithmic</source>
          <target state="translated">아르메니아 소문자 숫자 &amp;mdash; 알고리즘</target>
        </trans-unit>
        <trans-unit id="7fdaaf9b67c3b1d0c68d34be06cba5e4c7ef627c" translate="yes" xml:space="preserve">
          <source>Armenian upper case numerals &amp;mdash; algorithmic</source>
          <target state="translated">아르메니아 대문자 숫자 &amp;mdash; 알고리즘</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="407b3375ba305104bfa3347f5f11fda2fe33bf93" translate="yes" xml:space="preserve">
          <source>Array and Object destructuring can be combined. Say you want the third element in the array &lt;code&gt;props&lt;/code&gt; below, and then you want the &lt;code&gt;name&lt;/code&gt; property in the object, you can do the following:</source>
          <target state="translated">배열과 객체 분해를 결합 할 수 있습니다. 아래 배열 &lt;code&gt;props&lt;/code&gt; 의 세 번째 요소 를 원 하고 객체 의 &lt;code&gt;name&lt;/code&gt; 속성 을 원한다고 가정 하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e24458d846b2cac571b6dad13f86f103be1e9ea" translate="yes" xml:space="preserve">
          <source>Array comprehension was previously proposed to be standardized in ECMAScript 2016, it provide a useful shortcut for constructing a new array based on the contents of another. Comprehensions can often be used in place of calls to &lt;a href=&quot;../global_objects/array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../global_objects/array/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;, or as a way of combining the two.</source>
          <target state="translated">배열 이해는 이전에 ECMAScript 2016에서 표준화되도록 제안되었으며 다른 배열의 내용을 기반으로 새 배열을 구성하는 데 유용한 바로 가기를 제공합니다. 이해는 종종 &lt;a href=&quot;../global_objects/array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../global_objects/array/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 호출 대신 또는이 둘을 결합하는 방법 으로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56e943b579120bf89542182a985318248ca1cdc7" translate="yes" xml:space="preserve">
          <source>Array comprehensions</source>
          <target state="translated">배열 이해</target>
        </trans-unit>
        <trans-unit id="ec92be30c7075d7cbaf977412d5f7c60c6ba5ab0" translate="yes" xml:space="preserve">
          <source>Array comprehensions compared to &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;filter&lt;/code&gt; 와 비교 한 배열 이해</target>
        </trans-unit>
        <trans-unit id="f9bd19cb1530ba2b98635d89f6578c4e48630f1d" translate="yes" xml:space="preserve">
          <source>Array comprehensions with if statement</source>
          <target state="translated">if 문으로 배열 이해</target>
        </trans-unit>
        <trans-unit id="842b581677d7bbf424ba11a565664f3dd7ca2c6f" translate="yes" xml:space="preserve">
          <source>Array comprehensions with two arrays</source>
          <target state="translated">두 개의 배열로 배열 이해</target>
        </trans-unit>
        <trans-unit id="c165216e453ed98c3aef7f84dc7c701408f4b8e8" translate="yes" xml:space="preserve">
          <source>Array comprehensions.</source>
          <target state="translated">배열 이해.</target>
        </trans-unit>
        <trans-unit id="5e1907d208c70ed71ca1b5d14ad8025d0cadae6b" translate="yes" xml:space="preserve">
          <source>Array constructor with a single parameter</source>
          <target state="translated">단일 매개 변수가있는 배열 생성자</target>
        </trans-unit>
        <trans-unit id="46fc87402a10dcf7fac0ceb66c972d4086b1ef6c" translate="yes" xml:space="preserve">
          <source>Array constructor with multiple parameters</source>
          <target state="translated">여러 매개 변수가있는 배열 생성자</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">배열 파괴</target>
        </trans-unit>
        <trans-unit id="ca912dfb8ab25b6c79495135bc628a32c75efd38" translate="yes" xml:space="preserve">
          <source>Array elements are object properties in the same way that &lt;code&gt;toString&lt;/code&gt; is a property (to be specific, however, &lt;code&gt;toString()&lt;/code&gt; is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:</source>
          <target state="translated">배열 요소는 &lt;code&gt;toString&lt;/code&gt; 이 속성 인 것과 같은 방식으로 객체 속성입니다 (구체적으로 는 &lt;code&gt;toString()&lt;/code&gt; 이 메서드 임). 그럼에도 불구하고 다음과 같이 배열의 요소에 액세스하려고하면 속성 이름이 유효하지 않기 때문에 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33944814a24fadb9f412474be11953dc9ae05219" translate="yes" xml:space="preserve">
          <source>Array elements are object properties in the same way that &lt;code&gt;toString&lt;/code&gt; is a property, but trying to access an element of an array as follows throws a syntax error because the property name is not valid:</source>
          <target state="translated">배열 요소는 &lt;code&gt;toString&lt;/code&gt; 이 속성 과 같은 방식으로 객체 속성 이지만 다음과 같이 배열의 요소에 액세스하려고하면 속성 이름이 유효하지 않기 때문에 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a40bd58f6e852afaa3de5912db101f1c7a6e3647" translate="yes" xml:space="preserve">
          <source>Array from a &lt;code&gt;Map&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 에서 배열</target>
        </trans-unit>
        <trans-unit id="f8931b112e9cecb36b14b2c391707b7847aec858" translate="yes" xml:space="preserve">
          <source>Array from a &lt;code&gt;NodeList&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NodeList&lt;/code&gt; 의 배열</target>
        </trans-unit>
        <trans-unit id="3b311cad8218d80babeada604a6cfc0dceac040a" translate="yes" xml:space="preserve">
          <source>Array from a &lt;code&gt;Set&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 에서 배열</target>
        </trans-unit>
        <trans-unit id="c37271e2e7ebbd1be8f375e1ccbe1037bef4e172" translate="yes" xml:space="preserve">
          <source>Array from a &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 에서 배열</target>
        </trans-unit>
        <trans-unit id="b8e55e94bdd15b33dc5e89e076dda9c9a54dbdcf" translate="yes" xml:space="preserve">
          <source>Array from an Array-like object (arguments)</source>
          <target state="translated">배열과 같은 객체의 배열 (인수)</target>
        </trans-unit>
        <trans-unit id="3dcb2d95c8fe2c2782c9cecd792d3969e8a95c47" translate="yes" xml:space="preserve">
          <source>Array indexes are just enumerable properties with integer names and are otherwise identical to general object properties. There is no guarantee that &lt;code&gt;for...in&lt;/code&gt; will return the indexes in any particular order. The &lt;code&gt;for...in&lt;/code&gt; loop statement will return all enumerable properties, including those with non&amp;ndash;integer names and those that are inherited.</source>
          <target state="translated">배열 인덱스는 정수 이름을 가진 열거 가능한 속성이며 일반적인 객체 속성과 동일합니다. &lt;code&gt;for...in&lt;/code&gt; 이 특정 순서로 인덱스를 반환 한다는 보장은 없습니다 . 는 &lt;code&gt;for...in&lt;/code&gt; 루프 문 정수가 아닌 이름을 가진 사람들과 상속 된 것을 포함하여, 모든 열거 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8dce53e0a0975947c956658914379abbbb9bb300" translate="yes" xml:space="preserve">
          <source>Array initializer/literal syntax.</source>
          <target state="translated">배열 이니셜 라이저 / 리터럴 구문.</target>
        </trans-unit>
        <trans-unit id="54ce2e26a977d43e1bdce79807203f89339ed787" translate="yes" xml:space="preserve">
          <source>Array item access with optional chaining</source>
          <target state="translated">선택적 체인으로 배열 항목 액세스</target>
        </trans-unit>
        <trans-unit id="0ff3d11bd339374764a52e87cc9cd404db976cee" translate="yes" xml:space="preserve">
          <source>Array iteration</source>
          <target state="translated">배열 반복</target>
        </trans-unit>
        <trans-unit id="70b6af200f3cd9da5e8eedc08862c1d1e9e582ad" translate="yes" xml:space="preserve">
          <source>Array iteration and for...in</source>
          <target state="translated">배열 반복 및 for ... in</target>
        </trans-unit>
        <trans-unit id="538c2e6e845280c47b7b8f3c9694da22f3440d9b" translate="yes" xml:space="preserve">
          <source>Array literal notation</source>
          <target state="translated">배열 리터럴 표기법</target>
        </trans-unit>
        <trans-unit id="051f0d6bd098df06454138ddf1bfe22d07625d2a" translate="yes" xml:space="preserve">
          <source>Array literals</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="d400b46a131622426486cc164c53df3470099bd7" translate="yes" xml:space="preserve">
          <source>Array literals (&lt;code&gt;[1, 2, 3]&lt;/code&gt;)</source>
          <target state="translated">배열 리터럴 ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41e00548a25f87e7867d99260498c2ed70f7a7b2" translate="yes" xml:space="preserve">
          <source>Array methods: &lt;a href=&quot;every&quot;&gt;&lt;code&gt;every()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;some&quot;&gt;&lt;code&gt;some()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;findindex&quot;&gt;&lt;code&gt;findIndex()&lt;/code&gt;&lt;/a&gt; test the array elements with a predicate returning a truthy value to determine if further iteration is required.</source>
          <target state="translated">배열 메서드 : &lt;a href=&quot;every&quot;&gt; &lt;code&gt;every()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;some&quot;&gt; &lt;code&gt;some()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;findindex&quot;&gt; &lt;code&gt;findIndex()&lt;/code&gt; &lt;/a&gt; 는 추가 반복이 필요한지 확인하기 위해 진실 값을 반환하는 조건 자로 배열 요소를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="3a6c98dce72395c00ba5120f10385bf1cdf1c586" translate="yes" xml:space="preserve">
          <source>Array sort argument</source>
          <target state="translated">배열 정렬 인수</target>
        </trans-unit>
        <trans-unit id="048806b25e664d5f25b564c6d8dadfa08d426f7c" translate="yes" xml:space="preserve">
          <source>Array subclassing</source>
          <target state="translated">배열 서브 클래 싱</target>
        </trans-unit>
        <trans-unit id="b3ba691d70f6a4d851bed750b01467ee0aa6bfc3" translate="yes" xml:space="preserve">
          <source>Array toLocaleString() override</source>
          <target state="translated">Array toLocaleString () 재정의</target>
        </trans-unit>
        <trans-unit id="eb626b6aa22fe542a1defb09c31049c352ca0566" translate="yes" xml:space="preserve">
          <source>Array-like objects</source>
          <target state="translated">배열과 유사한 객체</target>
        </trans-unit>
        <trans-unit id="f11c41c31481af345045cf968702b9aaeedbdbe4" translate="yes" xml:space="preserve">
          <source>Array.@@species</source>
          <target state="translated">Array.@@species</target>
        </trans-unit>
        <trans-unit id="04ce8a3dbafd5912029cb5c7dbba5320e12c7074" translate="yes" xml:space="preserve">
          <source>Array.array</source>
          <target state="translated">Array.array</target>
        </trans-unit>
        <trans-unit id="679ef0f69b71ffcfffd14154349f3a662a2bf231" translate="yes" xml:space="preserve">
          <source>Array.from</source>
          <target state="translated">Array.from</target>
        </trans-unit>
        <trans-unit id="e441a7e4503c40df54307ae7673c8302a82898f2" translate="yes" xml:space="preserve">
          <source>Array.isArray</source>
          <target state="translated">Array.isArray</target>
        </trans-unit>
        <trans-unit id="fb5ce6e940582647f2fa3ae56246c93e000d7601" translate="yes" xml:space="preserve">
          <source>Array.length</source>
          <target state="translated">Array.length</target>
        </trans-unit>
        <trans-unit id="7c95f9796809d5949a3a953877aa14c969a75aa9" translate="yes" xml:space="preserve">
          <source>Array.of</source>
          <target state="translated">Array.of</target>
        </trans-unit>
        <trans-unit id="9db637ab084a17ac81478a045a51d8242d7e6da5" translate="yes" xml:space="preserve">
          <source>Array.prototype</source>
          <target state="translated">Array.prototype</target>
        </trans-unit>
        <trans-unit id="95971ea269213b08d09c9553e6421bde178a5ca7" translate="yes" xml:space="preserve">
          <source>ArrayBuffer</source>
          <target state="translated">ArrayBuffer</target>
        </trans-unit>
        <trans-unit id="0759b3dac7ff4e7674f2a2c8f44a224ff636d7ea" translate="yes" xml:space="preserve">
          <source>ArrayBuffer.@@species</source>
          <target state="translated">ArrayBuffer.@@species</target>
        </trans-unit>
        <trans-unit id="56b930c29730300623f908954575308320af29f3" translate="yes" xml:space="preserve">
          <source>ArrayBuffer.arrayBuffer</source>
          <target state="translated">ArrayBuffer.arrayBuffer</target>
        </trans-unit>
        <trans-unit id="ae7d638de1e11b639e68239572ac648b21255da8" translate="yes" xml:space="preserve">
          <source>ArrayBuffer.isView</source>
          <target state="translated">ArrayBuffer.isView</target>
        </trans-unit>
        <trans-unit id="f9865f3e07c8d91cb9ff94628a52a2470b489e09" translate="yes" xml:space="preserve">
          <source>ArrayBuffer.prototype</source>
          <target state="translated">ArrayBuffer.prototype</target>
        </trans-unit>
        <trans-unit id="95303c90ba12f2bf9d4a1daadf6aa1ea9000c060" translate="yes" xml:space="preserve">
          <source>ArrayBuffer.prototype.constructor</source>
          <target state="translated">ArrayBuffer.prototype.constructor</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5b5440253bf0400a58ae4dba7c2ffaea43b107b9" translate="yes" xml:space="preserve">
          <source>Arrays and/or values to concatenate into a new array. If &lt;code&gt;value&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt; returns a shallow copy of the existing array on which it is called. See the description below for more details.</source>
          <target state="translated">새 배열로 연결할 배열 및 / 또는 값 경우 &lt;code&gt;value&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 된다 &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;concat&lt;/code&gt; 복귀 얕은가 호출되는 기존의 어레이로 복사한다. 자세한 내용은 아래 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6950bc50cd1ba244d3d3571a66ff67ee31553234" translate="yes" xml:space="preserve">
          <source>Arrays and/or values to concatenate into a new array. If all &lt;code&gt;value&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; parameters are omitted, &lt;code&gt;concat&lt;/code&gt; returns a shallow copy of the existing array on which it is called. See the description below for more details.</source>
          <target state="translated">새 배열로 연결할 배열 및 / 또는 값입니다. 모든 &lt;code&gt;value&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; 매개 변수가 생략되면 &lt;code&gt;concat&lt;/code&gt; 은 호출되는 기존 배열의 단순 사본을 리턴합니다. 자세한 내용은 아래 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d451c76312f844d3627616e3e376a66e8aeea81d" translate="yes" xml:space="preserve">
          <source>Arrays are list-like objects whose prototype has methods to perform traversal and mutation operations. Neither the length of a JavaScript array nor the types of its elements are fixed. Since an array's length can change at any time, and data can be stored at non-contiguous locations in the array, JavaScript arrays are not guaranteed to be dense; this depends on how the programmer chooses to use them. In general, these are convenient characteristics; but if these features are not desirable for your particular use, you might consider using typed arrays.</source>
          <target state="translated">배열은 프로토 타입에 순회 및 변이 연산을 수행하는 메소드가있는 목록과 유사한 객체입니다. JavaScript 배열의 길이와 해당 요소의 유형은 고정되어 있지 않습니다. 배열의 길이는 언제든지 변경 될 수 있고 배열의 연속되지 않은 위치에 데이터를 저장할 수 있으므로 JavaScript 배열은 밀도가 보장되지 않습니다. 이것은 프로그래머가 사용하는 방법에 따라 다릅니다. 일반적으로 이들은 편리한 특성입니다. 그러나 이러한 기능이 특정 용도에 적합하지 않은 경우 유형이 지정된 배열 사용을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8e66a835cdc10db3415f5d74425c17eb4895a50" translate="yes" xml:space="preserve">
          <source>Arrays can be created using a constructor with a single number parameter. An array with its &lt;code&gt;length&lt;/code&gt; property set to that number and the array elements are empty slots.</source>
          <target state="translated">단일 숫자 매개 변수가있는 생성자를 사용하여 배열을 만들 수 있습니다. &lt;code&gt;length&lt;/code&gt; 속성이 해당 숫자로 설정된 배열과 배열 요소는 빈 슬롯입니다.</target>
        </trans-unit>
        <trans-unit id="9edc42e336cb3f47019b2e753f91fc12ba2d99fb" translate="yes" xml:space="preserve">
          <source>Arrays can be created using the &lt;a href=&quot;../../lexical_grammar#Array_literals&quot;&gt;literal&lt;/a&gt; notation:</source>
          <target state="translated">&lt;a href=&quot;../../lexical_grammar#Array_literals&quot;&gt;리터럴&lt;/a&gt; 표기법을 사용하여 배열을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6012be3ed9adcc6640c51a8dcfc660bb766ea888" translate="yes" xml:space="preserve">
          <source>Arrays cannot use strings as element indexes (as in an &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_array&quot;&gt;associative array&lt;/a&gt;) but must use integers. Setting or accessing via non-integers using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties&quot;&gt;bracket notation&lt;/a&gt; (or &lt;a href=&quot;../operators/property_accessors&quot;&gt;dot notation&lt;/a&gt;) will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;object property collection&lt;/a&gt;. The array's object properties and list of array elements are separate, and the array's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Array_methods&quot;&gt;traversal and mutation operations&lt;/a&gt; cannot be applied to these named properties.</source>
          <target state="translated">배열은 문자열을 요소 인덱스로 사용할 수 없지만 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_array&quot;&gt;연관 배열&lt;/a&gt; 에서처럼 ) 정수를 사용해야합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties&quot;&gt;대괄호 표기법&lt;/a&gt; (또는 &lt;a href=&quot;../operators/property_accessors&quot;&gt;점 표기법&lt;/a&gt; )을 사용하여 비정 수를 통해 설정하거나 액세스 하면 배열 목록 자체에서 요소를 설정하거나 검색하지 않지만 해당 배열의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;객체 속성 컬렉션&lt;/a&gt; 과 관련된 변수를 설정하거나 액세스합니다 . 배열의 객체 속성과 배열 요소 목록은 분리되어 있으며 배열의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Array_methods&quot;&gt;순회 및 변이 연산&lt;/a&gt; 은 이러한 명명 된 속성에 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e8a3c32c7e9b4c8f886e1bbebcdc7df95965d0d" translate="yes" xml:space="preserve">
          <source>Arrow function</source>
          <target state="translated">화살표 기능</target>
        </trans-unit>
        <trans-unit id="fc6d0b4a3431a2895e9d69a29dd7c9026e676f98" translate="yes" xml:space="preserve">
          <source>Arrow functions</source>
          <target state="translated">화살표 기능</target>
        </trans-unit>
        <trans-unit id="d503a4473544d47a97ef7776556a3f29e4c47c0a" translate="yes" xml:space="preserve">
          <source>Arrow functions can have either a &quot;concise body&quot; or the usual &quot;block body&quot;.</source>
          <target state="translated">화살표 기능은 &quot;간결한 바디&quot;또는 일반적인 &quot;블록 바디&quot;를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b9a8dee12aacd502cecf7ed7a0ba5a0b89bc89" translate="yes" xml:space="preserve">
          <source>Arrow functions cannot be used as constructors and will throw an error when used with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">화살표 함수는 생성자로 사용할 수 없으며 &lt;code&gt;new&lt;/code&gt; 와 함께 사용하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="8a7e7eee4b710ae724e5cf53d2cb03fcc499ec71" translate="yes" xml:space="preserve">
          <source>Arrow functions do not have a &lt;code&gt;prototype&lt;/code&gt; property.</source>
          <target state="translated">화살표 함수에는 &lt;code&gt;prototype&lt;/code&gt; 속성 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="88efb2e48554f7f22c48e051b67d6b53b28be6a6" translate="yes" xml:space="preserve">
          <source>Arrow functions do not have their own &lt;a href=&quot;arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt; object&lt;/a&gt;. Thus, in this example, &lt;code&gt;arguments&lt;/code&gt; is simply a reference to the arguments of the enclosing scope:</source>
          <target state="translated">화살표 함수에는 자체 &lt;a href=&quot;arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; 객체&lt;/a&gt; 가 없습니다 . 따라서이 예에서 &lt;code&gt;arguments&lt;/code&gt; 는 단순히 포함 범위의 인수에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c57dbaecef381f062a942d4d6e763bd851543042" translate="yes" xml:space="preserve">
          <source>Arrow functions do not have their own &lt;code&gt;this&lt;/code&gt;. Another example involving &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">함수는 자신이 소유하지 않아도 화살표 &lt;code&gt;this&lt;/code&gt; . &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 와 관련된 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="df85bc5997113f0441758b4fdcf56fbbd456a41a" translate="yes" xml:space="preserve">
          <source>Arrow functions introduce a short-hand braceless syntax that returns an expression. This can cause unintended side effects by returning the result of a function call that previously returned nothing. To be safe, when the return value of a function is not intended to be used, it can be passed to the void operator to ensure that (for example) changing APIs do not cause arrow functions' behaviors to change.</source>
          <target state="translated">화살표 함수는 표현식을 반환하는 짧은 괄호없는 구문을 소개합니다. 이전에 아무것도 반환하지 않은 함수 호출의 결과를 반환하여 의도하지 않은 부작용이 발생할 수 있습니다. 안전을 위해 함수의 반환 값을 사용하지 않을 경우 void 연산자로 전달하여 (예를 들어) API 변경으로 화살표 함수의 동작이 변경되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9375a1b9855e61c8027f0cf7732afbaa29837a39" translate="yes" xml:space="preserve">
          <source>Arrow functions used as methods</source>
          <target state="translated">방법으로 사용되는 화살표 기능</target>
        </trans-unit>
        <trans-unit id="d45babcae94938a3c75f01f70e934447e795901a" translate="yes" xml:space="preserve">
          <source>As a DOM event handler</source>
          <target state="translated">DOM 이벤트 핸들러로서</target>
        </trans-unit>
        <trans-unit id="9ce6ae1feb45237fc6e076f221452d760fed2724" translate="yes" xml:space="preserve">
          <source>As a baseline requirement, documents will need to be in a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;secure context&lt;/a&gt;.</source>
          <target state="translated">기본 요구 사항으로 문서는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;안전한 컨텍스트&lt;/a&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b61459c1af9aa2cd532db4d8e210ca778fe21f1" translate="yes" xml:space="preserve">
          <source>As a baseline requirement, your document needs to be in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;secure context&lt;/a&gt;.</source>
          <target state="translated">기본 요구 사항으로 문서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts&quot;&gt;안전한 컨텍스트&lt;/a&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="429a16b965fd947d5a1e23ea21fc9c7acb81cf44" translate="yes" xml:space="preserve">
          <source>As a constructor</source>
          <target state="translated">생성자로서</target>
        </trans-unit>
        <trans-unit id="d1153130f3a3654ab903ab7e17dab6458c4a7799" translate="yes" xml:space="preserve">
          <source>As a couple of additions to ECMAScript 2015, &lt;strong&gt;Iteration protocols&lt;/strong&gt; aren't new built-ins or syntax, but &lt;em&gt;protocols&lt;/em&gt;. These protocols can be implemented by any object by simply following some conventions.</source>
          <target state="translated">ECMAScript 2015에 대한 몇 가지 추가 사항으로 &lt;strong&gt;반복 프로토콜&lt;/strong&gt; 은 새로운 내장 또는 구문이 아니라 &lt;em&gt;프로토콜&lt;/em&gt; 입니다. 이러한 프로토콜은 몇 가지 규칙을 따르는 것만으로 모든 개체에서 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7cda1e552cc8fbbcb34407a14ed1f6d2513b06" translate="yes" xml:space="preserve">
          <source>As a quick and dirty hack the expression</source>
          <target state="translated">빠르고 더러운 표현으로 해킹</target>
        </trans-unit>
        <trans-unit id="9335f0766738d701fea38f74f9d8d3b4b69e1c25" translate="yes" xml:space="preserve">
          <source>As a result of this newly required environment, there are a couple API implications:</source>
          <target state="translated">이 새로 필요한 환경의 결과로 다음과 같은 몇 가지 API 관련 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85317fe7f561e137bf6a3057ad71f87e70b5f0e5" translate="yes" xml:space="preserve">
          <source>As all objects have no own symbol properties initially, &lt;code&gt;Object.getOwnPropertySymbols()&lt;/code&gt; returns an empty array unless you have set symbol properties on your object.</source>
          <target state="translated">모든 객체에는 처음에 고유 한 심볼 속성이 없으므로 &lt;code&gt;Object.getOwnPropertySymbols()&lt;/code&gt; 는 객체에 심볼 속성을 설정하지 않은 경우 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aef2ce6a60ba776240379210716384a2e73586e4" translate="yes" xml:space="preserve">
          <source>As all other objects, &lt;a href=&quot;global_objects/function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; objects can be created using the &lt;code&gt;new&lt;/code&gt; operator:</source>
          <target state="translated">다른 모든 객체와 마찬가지로 &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;global_objects/function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; 객체를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a16ab5a2287e3f880e1444c946f5f1cf3c609f54" translate="yes" xml:space="preserve">
          <source>As all other objects, &lt;a href=&quot;global_objects/generatorfunction&quot;&gt;&lt;code&gt;GeneratorFunction&lt;/code&gt;&lt;/a&gt; objects can be created using the &lt;code&gt;new&lt;/code&gt; operator:</source>
          <target state="translated">다른 모든 객체와 마찬가지로 &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;global_objects/generatorfunction&quot;&gt; &lt;code&gt;GeneratorFunction&lt;/code&gt; &lt;/a&gt; 객체를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="743aa5d6255f8f38463d29b47164e632032c5cd3" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.slice(2, -1)&lt;/code&gt; extracts the third character through the second to last character in the string.</source>
          <target state="translated">예를 들어, &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.slice(2, -1)&lt;/code&gt; 은 문자열의 두 번째에서 마지막 문자까지 세 번째 문자를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="316d4ebbc7f55319e26f659bc6183c143a6e7095" translate="yes" xml:space="preserve">
          <source>As an example, &lt;code&gt;str.slice(2, -1)&lt;/code&gt; extracts the third character through the second to last character in the string.</source>
          <target state="translated">예를 들어 &lt;code&gt;str.slice(2, -1)&lt;/code&gt; 은 문자열의 두 번째 문자부터 마지막 ​​문자까지 세 번째 문자를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="69d1b408492ed5838e44e10bb431c5daad89f9e2" translate="yes" xml:space="preserve">
          <source>As an example, here are &lt;code&gt;Math.max&lt;/code&gt;/&lt;code&gt;Math.min&lt;/code&gt;, used to find out the maximum/minimum value in an array.</source>
          <target state="translated">예를 들어 배열의 최대 / 최소 값을 찾는 데 사용되는 &lt;code&gt;Math.max&lt;/code&gt; / &lt;code&gt;Math.min&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3604afbf4a4aac3adb46d11b657fd186dbeaec0" translate="yes" xml:space="preserve">
          <source>As an object method</source>
          <target state="translated">객체 방법으로</target>
        </trans-unit>
        <trans-unit id="6aafeba3a118374a3c2e543ef5c4b61e80001046" translate="yes" xml:space="preserve">
          <source>As another example, the unique exponentiation operator has right-associativity, whereas other arithmetic operators have left-associativity. It is interesting to note that, the order of evaluation is always left-to-right irregardless of associativity and precedence.</source>
          <target state="translated">또 다른 예로, 고유 지수 연산자는 오른쪽 연관성을 갖는 반면, 다른 산술 연산자는 왼쪽 연관성을 갖습니다. 평가 순서는 연관성 및 우선 순위에 관계없이 항상 왼쪽에서 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="9a3f20c0b7149e2a5b69aca6a85dbd88e7bfa06c" translate="yes" xml:space="preserve">
          <source>As defined by the ECMAScript 5 specification, &lt;code&gt;Infinity&lt;/code&gt; is read-only (implemented in JavaScript 1.8.5 / Firefox 4).</source>
          <target state="translated">ECMAScript 5 사양에 정의 된대로 &lt;code&gt;Infinity&lt;/code&gt; 는 읽기 전용입니다 (JavaScript 1.8.5 / Firefox 4에서 구현 됨).</target>
        </trans-unit>
        <trans-unit id="2f2e163714feed8b14c3ab9777cefaa758e9a170" translate="yes" xml:space="preserve">
          <source>As explained above, some results contain additional properties as described below.</source>
          <target state="translated">위에서 설명한 것처럼 일부 결과에는 아래 설명 된 추가 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="27266e7938b0cc73a7255c19c6a79a6c2e4e030b" translate="yes" xml:space="preserve">
          <source>As logical expressions are evaluated left to right, it is always possible to remove parentheses from a complex expression following some rules.</source>
          <target state="translated">논리식은 왼쪽에서 오른쪽으로 평가되므로 일부 규칙에 따라 복잡한 식에서 괄호를 항상 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de89faab92512d4843c7e08807f95f16cb8c3a6c" translate="yes" xml:space="preserve">
          <source>As logical expressions are evaluated left to right, they are tested for possible &quot;short-circuit&quot; evaluation using the following rules:</source>
          <target state="translated">논리식이 왼쪽에서 오른쪽으로 평가 될 때 다음 규칙을 사용하여 가능한 &quot;단락&quot;평가를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="2e5845a76203089fc9b6ffd2ba3e1d1f05c9b349" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;\W&lt;/code&gt; only matches ASCII based characters; for example, &quot;a&quot; to &quot;z&quot;, &quot;A&quot; to &quot;Z&quot;, &quot;0&quot; to &quot;9&quot; and &quot;_&quot;. To match characters from other languages such as Cyrillic or Hebrew, use &lt;code&gt;\uhhhh&lt;/code&gt;, where &quot;hhhh&quot; is the character's Unicode value in hexadecimal. This example demonstrates how one can separate out Unicode characters from a word.</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;\W&lt;/code&gt; 는 ASCII 기반 문자 만 일치합니다. 예를 들어 &quot;a&quot;~ &quot;z&quot;, &quot;A&quot;~ &quot;Z&quot;, &quot;0&quot;~ ​​&quot;9&quot;및 &quot;_&quot;입니다. 키릴 자모 또는 히브리어와 같은 다른 언어의 문자를 일치 시키려면 &lt;code&gt;\uhhhh&lt;/code&gt; uhhhh를 사용하십시오 . 여기서 &quot;hhhh&quot;는 문자의 유니 코드 값 (16 진수)입니다. 이 예제는 유니 코드 문자를 단어와 분리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d340023a46ddca802c957e47e8ac822fa3908132" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;code&gt;push&lt;/code&gt; is intentionally generic, and we can use that to our advantage. &lt;code&gt;Array.prototype.push&lt;/code&gt; can work on an object just fine, as this example shows.</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;push&lt;/code&gt; 는 의도적으로 일반적이며이를 이점으로 사용할 수 있습니다. &lt;code&gt;Array.prototype.push&lt;/code&gt; 는이 예제에서 볼 수 있듯이 객체에서 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b89ad20db407fbc1dbcf949ff2ea73d3e7739cc" translate="yes" xml:space="preserve">
          <source>As mentioned above, &lt;code&gt;push&lt;/code&gt; is intentionally generic, and we can use that to our advantage. &lt;code&gt;Array.prototype.push&lt;/code&gt; can work on an object just fine, as this example shows. Note that we don't create an array to store a collection of objects. Instead, we store the collection on the object itself and use &lt;code&gt;call&lt;/code&gt; on &lt;code&gt;Array.prototype.push&lt;/code&gt; to trick the method into thinking we are dealing with an array, and it just works, thanks to the way JavaScript allows us to establish the execution context however we please.</source>
          <target state="translated">위에서 언급 한 바와 같이 &lt;code&gt;push&lt;/code&gt; 는 의도적으로 일반적이므로이를 활용할 수 있습니다. 이 예제에서 볼 수 있듯이 &lt;code&gt;Array.prototype.push&lt;/code&gt; 는 객체에서 잘 작동 할 수 있습니다. 객체 컬렉션을 저장하기 위해 배열을 만들지 않습니다. 대신 컬렉션 자체를 객체 자체에 저장하고 &lt;code&gt;Array.prototype.push&lt;/code&gt; 에 대한 &lt;code&gt;call&lt;/code&gt; 을 사용 하여 메소드를 배열을 처리한다고 생각하도록 속이고 JavaScript가 실행 컨텍스트를 설정할 수있는 방식 덕분에 작동합니다. 우리는 제발.</target>
        </trans-unit>
        <trans-unit id="bdaa8b62f43dc63e0ad47d864f7b58399b69902c" translate="yes" xml:space="preserve">
          <source>As of ECMAScript 2016, tagged templates conform to the rules of the following escape sequences:</source>
          <target state="translated">ECMAScript 2016부터 태그 된 템플릿은 다음 이스케이프 시퀀스 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="86e7074b192dda8a1ea062acc4b52554bbdf7bf1" translate="yes" xml:space="preserve">
          <source>As of ES2015, you can also use &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt;.</source>
          <target state="translated">ES2015부터 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c97692bab7176d39864ec6d495e695308455ffd3" translate="yes" xml:space="preserve">
          <source>As of ES5, this can also be another &lt;code&gt;RegExp&lt;/code&gt; object or literal (for the two RegExp constructor notations only). Patterns may include &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters&lt;/a&gt; to match a wider range of values than would a literal string.</source>
          <target state="translated">ES5부터는 다른 &lt;code&gt;RegExp&lt;/code&gt; 객체 또는 리터럴 일 수도 있습니다 (두 개의 RegExp 생성자 표기법에만 해당). 패턴에는 리터럴 문자열보다 더 넓은 범위의 값과 일치하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;특수 문자&lt;/a&gt; 가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c921421fe81703c8f087d8c7268acc1471abd2a8" translate="yes" xml:space="preserve">
          <source>As said, these differences can make debugging even simple-seeming problems quickly go astray. For example:</source>
          <target state="translated">앞에서 언급 한 바와 같이 이러한 차이점으로 인해 디버깅조차 단순 해 보이는 문제가 빨리 사라질 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7968e2796cc6687a5f4953a8ad7fa7b732d73941" translate="yes" xml:space="preserve">
          <source>As seen above, the fields can be declared with or without a default value.</source>
          <target state="translated">위에서 볼 수 있듯이 필드는 기본값을 사용하거나 사용하지 않고 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46c6c7f8bfb6ac149c26748e945c00f905895f02" translate="yes" xml:space="preserve">
          <source>As seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.</source>
          <target state="translated">예제에서 볼 수 있듯이 쓰기 불가능한 속성에 쓰려고 시도해도 속성이 변경되지 않지만 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21d2a264c9fde6e01cdf2ed05d84f01da72050fc" translate="yes" xml:space="preserve">
          <source>As shown above, all seems normal so far. However, when attempting to actually use these objects, their differences quickly become apparent:</source>
          <target state="translated">위에서 볼 수 있듯이 지금까지 모든 것이 정상인 것 같습니다. 그러나 실제로 이러한 객체를 사용하려고 할 때 차이점이 빠르게 드러납니다.</target>
        </trans-unit>
        <trans-unit id="982bf3ceaec868376092718e6ddc9c0ea2778ee8" translate="yes" xml:space="preserve">
          <source>As shown above, the { brackets } and ( parentheses ) and &quot;return&quot; are optional, but may be required.</source>
          <target state="translated">위에 표시된대로 {대괄호} 및 (괄호) 및 &quot;반환&quot;은 선택 사항이지만 필수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73c0dbacbcb3a76bc1ffa8c313fdd8b9265aed3c" translate="yes" xml:space="preserve">
          <source>As shown, objects modified this way now look very much like ordinary objects.</source>
          <target state="translated">표시된 것처럼이 방법으로 수정 된 객체는 이제 일반 객체와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1aa22bacbb90ee485c142e8d6f87aa78c9b48fd9" translate="yes" xml:space="preserve">
          <source>As stated previously, arrow function expressions are best suited for non-method functions. Let's see what happens when we try to use them as methods:</source>
          <target state="translated">앞에서 언급했듯이 화살표 함수 표현식은 비 메소드 함수에 가장 적합합니다. 그것들을 메소드로 사용하려고 할 때 어떤 일이 발생하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="7cbfbd88cd6fe7b112788dcbd77c64a11bc25a9d" translate="yes" xml:space="preserve">
          <source>As stated, if you do not specify a constructor method a default constructor is used. For base classes the default constructor is:</source>
          <target state="translated">언급 한대로 생성자 메서드를 지정하지 않으면 기본 생성자가 사용됩니다. 기본 클래스의 경우 기본 생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01141694d25e0ba11fdfedb99ad78dedf9123324" translate="yes" xml:space="preserve">
          <source>As such, &lt;code&gt;delete&lt;/code&gt; cannot delete any functions in the global scope (whether this is part from a function definition or a function expression).</source>
          <target state="translated">따라서 &lt;code&gt;delete&lt;/code&gt; 는 전역 범위에서 함수를 삭제할 수 없습니다 (이것이 함수 정의 또는 함수 표현식의 일부인지 여부).</target>
        </trans-unit>
        <trans-unit id="43de276e02fb5cae067a91bb1ffdd5afad4051d8" translate="yes" xml:space="preserve">
          <source>As the 4th example shows, the function name can be different from the variable the function is assigned to. They have no relation to each other. A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in:</source>
          <target state="translated">네 번째 예에서 볼 수 있듯이 함수 이름은 함수가 할당 된 변수와 다를 수 있습니다. 그들은 서로 관계가 없습니다. 함수 선언은 함수 이름과 이름이 같은 변수를 만듭니다. 따라서 함수 표현식으로 정의 된 함수와 달리 함수 선언으로 정의 된 함수는 해당 범위에서 이름으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf55a33661f108fbde9b2bb54f72e0af2bb68fd8" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;&lt;a href=&quot;promise/then&quot;&gt;&lt;code&gt;Promise.prototype.then()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;promise/catch&quot;&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; methods return promises, they can be chained.</source>
          <target state="translated">는 AS &lt;code&gt;&lt;a href=&quot;promise/then&quot;&gt;&lt;code&gt;Promise.prototype.then()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;promise/catch&quot;&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드 약속을 반환, 그들은 체인 될 수있다.</target>
        </trans-unit>
        <trans-unit id="27a98fb309af44abe38dbcc1a4d5cecf1cbd0796" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;then&lt;/code&gt; and &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt;&lt;/a&gt; methods return promises, they &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining&quot;&gt;can be chained&lt;/a&gt; &amp;mdash; an operation called &lt;em&gt;composition&lt;/em&gt;.</source>
          <target state="translated">는 AS &lt;code&gt;then&lt;/code&gt; 과 &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;Promise.prototype.catch()&lt;/code&gt; &lt;/a&gt; 메소드 반환 약속, 그들은 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#Chaining&quot;&gt;체인 될 수있다&lt;/a&gt; -라는 동작을 &lt;em&gt;조성&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="04b9cb9920dc356539a8a67ecac564d8697a4b53" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;then&lt;/code&gt; and &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;Promise.prototype.catch()&lt;/code&gt;&lt;/a&gt; methods return promises, they can be chained &amp;mdash; an operation called &lt;em&gt;composition&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 및 &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;Promise.prototype.catch()&lt;/code&gt; &lt;/a&gt; 메소드가 약속을 리턴 함에 따라 이들을 체인화 할 수 있습니다 ( &lt;em&gt;컴포지션)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d0c996ec54542a5fd7737f7598dd89a498b87b8" translate="yes" xml:space="preserve">
          <source>As the name implies, public instance methods are methods available on class instances.</source>
          <target state="translated">이름에서 알 수 있듯이 공용 인스턴스 메서드는 클래스 인스턴스에서 사용할 수있는 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="04c18933c5032f4ca8d5f4ea92b287dae00fb65e" translate="yes" xml:space="preserve">
          <source>As we can see, both examples do not start with the &lt;code&gt;function&lt;/code&gt; keyword. Statements involving functions which do not start with &lt;code&gt;function&lt;/code&gt; are function expressions.</source>
          <target state="translated">보시다시피, 두 예제는 모두 &lt;code&gt;function&lt;/code&gt; 키워드로 시작하지 않습니다 . 로 시작하지 않는 기능을 포함하는 문 &lt;code&gt;function&lt;/code&gt; 함수 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ed44fde2babb09e3ed5b178484a8683808645050" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;exec()&lt;/code&gt; (or in combination with it), &lt;code&gt;test()&lt;/code&gt; called multiple times on the same global regular expression instance will advance past the previous match.</source>
          <target state="translated">&lt;code&gt;exec()&lt;/code&gt; (또는 그와 함께 ) 와 마찬가지로 &lt;code&gt;test()&lt;/code&gt; 마찬가지로 동일한 전역 정규식 인스턴스에서 여러 번 호출 된 는 이전 일치 항목을 지나서 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d5ad447d3a0144bf7de3d53bf1cbaa189de9bf26" translate="yes" xml:space="preserve">
          <source>As with canonical normalization, you can ask for decomposed or composed compatible forms by passing &lt;code&gt;&quot;NFKD&quot;&lt;/code&gt; or &lt;code&gt;&quot;NFKC&quot;&lt;/code&gt;, respectively.</source>
          <target state="translated">표준 정규화와 마찬가지로 &lt;code&gt;&quot;NFKD&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;NFKC&quot;&lt;/code&gt; 를 전달하여 분해되거나 구성된 호환 형식을 요청할 수 있습니다. 각각 .</target>
        </trans-unit>
        <trans-unit id="dfea5df33fceeb3e5a45b870d696433556ac14ce" translate="yes" xml:space="preserve">
          <source>As with most of the built-in objects in JavaScript, the &lt;code&gt;Math&lt;/code&gt; object can be extended with custom properties and methods. To extend the &lt;code&gt;Math&lt;/code&gt; object, you do not use &lt;code&gt;prototype&lt;/code&gt;. Instead, you directly extend &lt;code&gt;Math&lt;/code&gt;:</source>
          <target state="translated">JavaScript에 내장 된 대부분의 객체와 마찬가지로 &lt;code&gt;Math&lt;/code&gt; 객체는 사용자 정의 속성 및 메소드로 확장 할 수 있습니다. &lt;code&gt;Math&lt;/code&gt; 객체 를 확장하기 위해 &lt;code&gt;prototype&lt;/code&gt; 을 사용하지 않습니다 . 대신 직접 &lt;code&gt;Math&lt;/code&gt; 확장하십시오 .</target>
        </trans-unit>
        <trans-unit id="94774134762debfbbc3a38c381068610d4609520" translate="yes" xml:space="preserve">
          <source>As you can do with any Array-like object, you can use ES2015's &lt;a href=&quot;../global_objects/array/from&quot;&gt;&lt;code&gt;Array.from()&lt;/code&gt;&lt;/a&gt; method or &lt;a href=&quot;../operators/spread_syntax&quot;&gt;spread operator&lt;/a&gt; to convert &lt;code&gt;arguments&lt;/code&gt; to a real Array:</source>
          <target state="translated">Array와 같은 객체로 할 수 있듯이 ES2015의 &lt;a href=&quot;../global_objects/array/from&quot;&gt; &lt;code&gt;Array.from()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../operators/spread_syntax&quot;&gt;spread 연산자&lt;/a&gt; 를 사용하여 &lt;code&gt;arguments&lt;/code&gt; 를 실제 Array 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="157261e12ec94162e8c2641c02afcfc4e1a05bb4" translate="yes" xml:space="preserve">
          <source>As you can do with any Array-like object, you can use ES2015's &lt;a href=&quot;../global_objects/array/from&quot;&gt;&lt;code&gt;Array.from()&lt;/code&gt;&lt;/a&gt; method or &lt;a href=&quot;../operators/spread_syntax&quot;&gt;spread syntax&lt;/a&gt; to convert &lt;code&gt;arguments&lt;/code&gt; to a real Array:</source>
          <target state="translated">Array와 유사한 객체로 할 수 있듯이 ES2015의 &lt;a href=&quot;../global_objects/array/from&quot;&gt; &lt;code&gt;Array.from()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../operators/spread_syntax&quot;&gt;스프레드 구문&lt;/a&gt; 을 사용하여 &lt;code&gt;arguments&lt;/code&gt; 를 실제 Array 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14a803907be712fb3db4c6a6f7769d34cb77477b" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;length&lt;/code&gt; property does not necessarily indicate the number of defined values in the array. See also &lt;a href=&quot;../array#Relationship_between_length_and_numerical_properties&quot;&gt;Relationship between &lt;code&gt;length&lt;/code&gt; and numerical properties&lt;/a&gt;.</source>
          <target state="translated">보시다시피 &lt;code&gt;length&lt;/code&gt; 속성이 반드시 배열에 정의 된 값의 수를 나타내는 것은 아닙니다. &lt;a href=&quot;../array#Relationship_between_length_and_numerical_properties&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 와 수치 속성 간의 관계를 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="28924a0707293aafe7600f1f8f95ea48d506e615" translate="yes" xml:space="preserve">
          <source>Assigned a default value in case the unpacked value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">압축 해제 된 값이 &lt;code&gt;undefined&lt;/code&gt; 경우 기본값을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="de1152642d5538dc1bd7bd94613541716f02863f" translate="yes" xml:space="preserve">
          <source>Assigning a default value to a variable</source>
          <target state="translated">변수에 기본값 할당</target>
        </trans-unit>
        <trans-unit id="19ee3ef8fecaf357009c4e42e1758b79bd67b243" translate="yes" xml:space="preserve">
          <source>Assigning a value to an undeclared variable implicitly creates it as a global variable (it becomes a property of the global object) when the assignment is executed. The differences between declared and undeclared variables are:</source>
          <target state="translated">선언되지 않은 변수에 값을 할당하면 할당이 실행될 때 암시 적으로 전역 변수 (글로벌 객체의 속성이 됨)로 생성됩니다. 선언 된 변수와 선언되지 않은 변수의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a328cf23950a4c2dd7cf0d84df9d0f0b55887b06" translate="yes" xml:space="preserve">
          <source>Assigning a value to the same constant name in the same block-scope will throw.</source>
          <target state="translated">동일한 블록 범위에서 동일한 상수 이름에 값을 할당하면 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="77d7cec53736acd03c12949621fbb4f0fef2b3f8" translate="yes" xml:space="preserve">
          <source>Assigning the rest of an array to a variable</source>
          <target state="translated">나머지 배열을 변수에 할당</target>
        </trans-unit>
        <trans-unit id="fc89d73de1e7985333c94758dd3f77af4489b824" translate="yes" xml:space="preserve">
          <source>Assigning to length</source>
          <target state="translated">길이에 할당</target>
        </trans-unit>
        <trans-unit id="dab86c2f68dc9210ef0bdb54850781f15563ef0c" translate="yes" xml:space="preserve">
          <source>Assigning to new variable names</source>
          <target state="translated">새로운 변수 이름에 할당</target>
        </trans-unit>
        <trans-unit id="b3a2f1aa05c3769666a3869dfe2488d80afcf977" translate="yes" xml:space="preserve">
          <source>Assigning to new variables names and providing default values</source>
          <target state="translated">새 변수 이름에 지정하고 기본값을 제공</target>
        </trans-unit>
        <trans-unit id="dd1bfc09c8e5fbdfec303db25c21f0f19458bebf" translate="yes" xml:space="preserve">
          <source>Assigning two variables with single string value</source>
          <target state="translated">단일 문자열 값으로 두 개의 변수 할당</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="5f1106667a3ffe6b7d174acec14d782a9c3ea70e" translate="yes" xml:space="preserve">
          <source>Assignment (&lt;code&gt;x = y&lt;/code&gt;)</source>
          <target state="translated">대입 ( &lt;code&gt;x = y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="87c55c9d7cf3600d0c45a8fa56b1b4cc7c337e78" translate="yes" xml:space="preserve">
          <source>Assignment operator.</source>
          <target state="translated">할당 연산자.</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="7aefb89dcf3d54439e0e29239ec910aab07b5ebf" translate="yes" xml:space="preserve">
          <source>Assignment operators in the JS guide</source>
          <target state="translated">JS 가이드의 할당 연산자</target>
        </trans-unit>
        <trans-unit id="831e549cdc8903a28dcd904d46eb9b62d0711db3" translate="yes" xml:space="preserve">
          <source>Assignment separate from declaration</source>
          <target state="translated">선언과 별도로 할당</target>
        </trans-unit>
        <trans-unit id="99708553016c28b2ad5d67c421a22ae856a7943d" translate="yes" xml:space="preserve">
          <source>Assignment within conditional expressions</source>
          <target state="translated">조건식 내 할당</target>
        </trans-unit>
        <trans-unit id="159e1ce04e2cd5322d4cb306182e2709c3b28d64" translate="yes" xml:space="preserve">
          <source>Assignment within the conditional expression</source>
          <target state="translated">조건식 내 할당</target>
        </trans-unit>
        <trans-unit id="9a37acb2e24f30a5a26e984dd635a4ee536e546f" translate="yes" xml:space="preserve">
          <source>Assignment without declaration</source>
          <target state="translated">선언하지 않은 과제</target>
        </trans-unit>
        <trans-unit id="18c67934740cd2dda50cc308a7af44a2cbc3ff0b" translate="yes" xml:space="preserve">
          <source>Associates a function with a property that, when accessed, executes that function and returns its return value.</source>
          <target state="translated">액세스 할 때 해당 함수를 실행하고 리턴 값을 리턴하는 특성과 함수를 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fb3991ea7907d72606d3a58259eeab463111ab2" translate="yes" xml:space="preserve">
          <source>Associates a function with a property that, when set, executes that function which modifies the property.</source>
          <target state="translated">설정된 경우 특성을 수정하는 해당 기능을 실행하는 특성과 함수를 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="7e8c8e8756c3e2a099abe557013eea7ecf8ac4e8" translate="yes" xml:space="preserve">
          <source>Associativity determines the way in which operators of the same precedence are parsed. For example, consider an expression:</source>
          <target state="translated">연관성은 동일한 우선 순위의 연산자가 구문 분석되는 방식을 결정합니다. 예를 들어, 표현식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="40a30fc881d26c18d47a972f2de5340d0bddd541" translate="yes" xml:space="preserve">
          <source>Assuming a pristine execution environment with all names and properties referring to their initial values, &lt;code&gt;Object.defineProperties&lt;/code&gt; is almost completely equivalent (note the comment in &lt;code&gt;isCallable&lt;/code&gt;) to the following reimplementation in JavaScript:</source>
          <target state="translated">모든 이름과 속성이 초기 값을 참조하는 원시 실행 환경을 가정하면 &lt;code&gt;Object.defineProperties&lt;/code&gt; 는 JavaScript에서 다음과 같이 다시 구현 하는 것과 거의 동일합니다 ( &lt;code&gt;isCallable&lt;/code&gt; 의 주석 참고 ).</target>
        </trans-unit>
        <trans-unit id="e6287d405a76408031a1b4e4ab2ff51598b84909" translate="yes" xml:space="preserve">
          <source>Assuming a runtime that supports Indonesian and German but not Balinese in collation, &lt;code&gt;supportedLocalesOf&lt;/code&gt; returns the Indonesian and German language tags unchanged, even though pinyin collation is not used with Indonesian and a specialized German for Indonesia is unlikely to be supported. Note the specification of the &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; algorithm here &amp;mdash; a &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.</source>
          <target state="translated">collation에서 인도네시아어와 독일어를 지원하지만 발리 언어는 &lt;code&gt;supportedLocalesOf&lt;/code&gt; 하지 않는 런타임을 가정하면, supportedLocalesOf 는 병음 조합이 인도네시아어와 함께 사용되지 않고 인도네시아의 특수 독일어가 지원되지 않더라도 인도네시아어와 독일어 태그를 변경하지 않고 리턴합니다. 여기 에서 &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; 알고리즘 의 사양에 주목 하십시오. &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 매처는 대부분의 발리어 사용자도 인도네시아어를 이해하므로 발리 언어 태그도 반환하므로 인도네시아어가 발리어에 적합한 것으로 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20cfbcee80b679f703032bf9fd2069c9ca834319" translate="yes" xml:space="preserve">
          <source>Assuming a runtime that supports Indonesian and German but not Balinese in date and time formatting, &lt;code&gt;supportedLocalesOf&lt;/code&gt; returns the Indonesian and German language tags unchanged, even though pinyin collation is neither relevant to date and time formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; algorithm here &amp;mdash; a &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.</source>
          <target state="translated">날짜 및 시간 형식에서는 인도네시아어 및 독일어는 지원하지만 발리어는 지원하지 않는 런타임을 가정 할 때 &lt;code&gt;supportedLocalesOf&lt;/code&gt; 는 병음 데이터 정렬이 날짜 및 시간 형식과 관련이없고 인도네시아어와 인도네시아어 및 인도네시아어와 함께 사용되는 경우에도 인도네시아어와 독일어 태그를 변경하지 않고 반환합니다. 지원되지 않을 것입니다. 여기 에서 &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; 알고리즘 의 사양에 유의 하십시오. &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 매처는 대부분의 발리어 사용자도 인도네시아어를 이해하므로 발리 언어 태그도 반환하므로 인도네시아어가 발리어에 적합하다고 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b74a342ee44ef6af7964c6966d0846ba4b275b6" translate="yes" xml:space="preserve">
          <source>Assuming a runtime that supports Indonesian and German but not Balinese in number formatting, &lt;code&gt;supportedLocalesOf&lt;/code&gt; returns the Indonesian and German language tags unchanged, even though &lt;code&gt;pinyin&lt;/code&gt; collation is neither relevant to number formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; algorithm here &amp;mdash; a &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.</source>
          <target state="translated">인도네시아어와 독일어는 지원하지만 숫자 형식으로는 발리는 &lt;code&gt;supportedLocalesOf&lt;/code&gt; 하지 않는 런타임을 가정하면 supportedLocalesOf 는 &lt;code&gt;pinyin&lt;/code&gt; 데이터 정렬이 숫자 형식화와 관련이 없으며 인도네시아어와도 사용되지 않더라도 인도네시아어와 독일어 태그를 변경하지 않고 반환합니다 . 지원됩니다. 여기 에서 &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; 알고리즘 의 사양에 유의 하십시오. &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 매처는 대부분의 발리어 사용자도 인도네시아어를 이해하므로 발리 언어 태그도 반환하므로 인도네시아어가 발리어에 적합하다고 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="139cd6b0d8a3c6ef09755401116cf1edc4fd2f7b" translate="yes" xml:space="preserve">
          <source>Assuming a runtime that supports Indonesian and German but not Balinese in plural formatting, &lt;code&gt;supportedLocalesOf&lt;/code&gt; returns the Indonesian and German language tags unchanged, even though &lt;code&gt;pinyin&lt;/code&gt; collation is neither relevant to plural formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; algorithm here &amp;mdash; a &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.</source>
          <target state="translated">인도네시아어와 독일어를 지원하지만 복수 형식의 발리어를 &lt;code&gt;supportedLocalesOf&lt;/code&gt; 하지 않는 런타임을 가정하면 supportedLocalesOf 는 &lt;code&gt;pinyin&lt;/code&gt; 데이터 정렬이 복수 형식과 관련이 없거나 인도네시아어와 함께 사용되지 않더라도 인도네시아어와 독일어 태그를 변경하지 않고 반환합니다 . 지원됩니다. 여기 에서 &lt;code&gt;&quot;lookup&quot;&lt;/code&gt; 알고리즘 의 사양에 유의 하십시오. &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 매처는 대부분의 발리어 사용자도 인도네시아어를 이해하므로 발리 언어 태그도 반환하므로 인도네시아어가 발리어에 적합하다고 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06d7bb5363c3603dab0d5523d48da44db6fa916" translate="yes" xml:space="preserve">
          <source>Assuming a runtime that supports Indonesian and German but not Balinese in plural formatting, &lt;code&gt;supportedLocalesOf&lt;/code&gt; returns the Indonesian and German language tags unchanged, even though &lt;code&gt;pinyin&lt;/code&gt; collation is neither relevant to plural formatting nor used with Indonesian, and a specialized German for Indonesia is unlikely to be supported. Note the specification of the &lt;code&gt;lookup&lt;/code&gt; algorithm here &amp;mdash; a &lt;code&gt;best fit&lt;/code&gt; matcher might decide that Indonesian is an adequate match for Balinese since most Balinese speakers also understand Indonesian, and therefore return the Balinese language tag as well.</source>
          <target state="translated">인도네시아어와 독일어를 지원하지만 복수 형식화에서 발리어를 &lt;code&gt;supportedLocalesOf&lt;/code&gt; 하지 않는 런타임을 가정하면, supportedLocalesOf 는 &lt;code&gt;pinyin&lt;/code&gt; 데이터 정렬이 복수 형식화와 관련이없고 인도네시아어와 함께 사용되지 않더라도 인도네시아어 및 독일어 태그를 변경하지 않고 반환하며 인도네시아 용 특수 독일어는 그럴 가능성이 낮습니다. 지원됩니다. 의 사양 참고 &lt;code&gt;lookup&lt;/code&gt; 여기 알고리즘을 - &lt;code&gt;best fit&lt;/code&gt; 정규 대부분의 발리 스피커는 인도네시아어 이해하기 때문에 인도네시아어 발리에 대한 적절한 일치하는 것을 결정, 따라서 발리 언어 태그를 반환 할뿐만 아니라 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="445aedd2e680d1bbdbabb034f3ca19f76188528b" translate="yes" xml:space="preserve">
          <source>Async functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.</source>
          <target state="translated">비동기 함수는 항상 약속을 반환합니다. 비동기 함수의 반환 값이 명시 적으로 약속이 아닌 경우 암시 적으로 약속에 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="783f2a2df615b75e6dce64939ba51bad05f6b44f" translate="yes" xml:space="preserve">
          <source>Async functions and execution order</source>
          <target state="translated">비동기 함수 및 실행 순서</target>
        </trans-unit>
        <trans-unit id="c90ad4f9f702414e2b5dbfa5221c549d5854c7db" translate="yes" xml:space="preserve">
          <source>Async functions can contain zero or more &lt;a href=&quot;../operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expressions. Await expressions suspend progress through an async function, yielding control and subsequently resuming progress only when an awaited promise-based asynchronous operation is either fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; enables the use of ordinary &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; blocks around asynchronous code.</source>
          <target state="translated">비동기 함수에는 0 개 이상의 &lt;a href=&quot;../operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 식이 포함될 수 있습니다 . Await 식은 비동기 함수를 통해 진행을 일시 중단하여 제어를 양보 한 다음 대기 된 약속 기반 비동기 작업이 충족되거나 거부 될 때만 진행을 다시 시작합니다. 약속의 확인 된 값은 await 식의 반환 값으로 처리됩니다. 의 사용 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 를가 일반의 사용을 가능하게 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 비동기 코드 주위에 블록을.</target>
        </trans-unit>
        <trans-unit id="a54306afe1186b35f39454949b654df02eaf5921" translate="yes" xml:space="preserve">
          <source>Async functions may also be defined &lt;a href=&quot;../operators/async_function&quot;&gt;as expressions&lt;/a&gt;.</source>
          <target state="translated">비동기 함수는 &lt;a href=&quot;../operators/async_function&quot;&gt;표현식&lt;/a&gt; 으로 정의 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1de478364d359d80003f50ac6c23dfbb8ec17b9" translate="yes" xml:space="preserve">
          <source>Async generator methods</source>
          <target state="translated">비동기 생성기 방법</target>
        </trans-unit>
        <trans-unit id="eff9960bccab37df30db91c6d36347885aa7dad8" translate="yes" xml:space="preserve">
          <source>Async methods</source>
          <target state="translated">비동기 방법</target>
        </trans-unit>
        <trans-unit id="72461dccf2067d5111358217c4577db8984d2f42" translate="yes" xml:space="preserve">
          <source>AsyncFunction</source>
          <target state="translated">AsyncFunction</target>
        </trans-unit>
        <trans-unit id="675d9dafc3dde5f6f1f3e1b07267f9831dd78bc7" translate="yes" xml:space="preserve">
          <source>AsyncFunction.prototype</source>
          <target state="translated">AsyncFunction.prototype</target>
        </trans-unit>
        <trans-unit id="84383a8f0f36526e51c1d4e8d7d5425bfd96b2ca" translate="yes" xml:space="preserve">
          <source>Asynchronicity of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.race&lt;/code&gt; 의 비동기 성</target>
        </trans-unit>
        <trans-unit id="a04460fc77d5b7420cece76e636d242c9930e141" translate="yes" xml:space="preserve">
          <source>Asynchronicity of Promise.race</source>
          <target state="translated">Promise.race의 비동기 성</target>
        </trans-unit>
        <trans-unit id="02d60b958686cb1f594032ede8ba5c532cc8eb38" translate="yes" xml:space="preserve">
          <source>Asynchronicity or synchronicity of &lt;code&gt;Promise.all&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.all&lt;/code&gt; 의 비동기 성 또는 동기 성</target>
        </trans-unit>
        <trans-unit id="d5a91f86684c9f470a0a84071109409a3300ea3d" translate="yes" xml:space="preserve">
          <source>At its very simplest, the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Intl.Locale&lt;/code&gt;&lt;/a&gt; constructor takes a locale identifier string as its argument:</source>
          <target state="translated">가장 간단하게 &lt;a href=&quot;locale&quot;&gt; &lt;code&gt;Intl.Locale&lt;/code&gt; &lt;/a&gt; 생성자는 로케일 식별자 문자열을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93ae8bd3d99d9a83820dc22e938c18cd6caad01c" translate="yes" xml:space="preserve">
          <source>At its very simplest, the &lt;a href=&quot;locale/locale&quot;&gt;&lt;code&gt;Intl.Locale&lt;/code&gt;&lt;/a&gt; constructor takes a locale identifier string as its argument:</source>
          <target state="translated">가장 간단하게 &lt;a href=&quot;locale/locale&quot;&gt; &lt;code&gt;Intl.Locale&lt;/code&gt; &lt;/a&gt; 생성자는 로캘 식별자 문자열을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d8915ffb7180e68b4e8c7b56ae94c96836bae276" translate="yes" xml:space="preserve">
          <source>At present, there is no &lt;code&gt;Math.clon&lt;/code&gt; for &quot;Count Leading Ones&quot; (named &quot;clon&quot;, not &quot;clo&quot;, because &quot;clo&quot; and &quot;clz&quot; are too similar especially for non-English-speaking people). However, a &lt;code&gt;clon&lt;/code&gt; function can easily be created by inversing the bits of a number and passing the result to &lt;code&gt;Math.clz32&lt;/code&gt;. Doing this will work because the inverse of 1 is 0 and vice-versa. Thus, inversing the bits will inverse the measured quantity of 0's (from &lt;code&gt;Math.clz32&lt;/code&gt;), thereby making &lt;code&gt;Math.clz32&lt;/code&gt; count the number of ones instead of counting the number of zeros.</source>
          <target state="translated">현재 &quot;Count Leading Ones&quot;에 대한 &lt;code&gt;Math.clon&lt;/code&gt; 은 없습니다 ( &quot;clo&quot;와 &quot;clz&quot;는 특히 영어를 사용하지 않는 사람들에게는 너무 유사하기 때문에 &quot;clo&quot;가 아니라 &quot;clon&quot;으로 명명 됨). 그러나 숫자의 비트를 &lt;code&gt;Math.clz32&lt;/code&gt; 하고 그 결과를 Math.clz32에 전달하면 &lt;code&gt;clon&lt;/code&gt; 함수를 쉽게 만들 수 있습니다 . 이렇게하면 1의 역이 0이고 그 반대의 경우도 마찬가지이기 때문에 작동합니다. 따라서 비트를 반전하면 측정 된 0의 양 ( &lt;code&gt;Math.clz32&lt;/code&gt; 에서 ) 이 반전 되어 &lt;code&gt;Math.clz32&lt;/code&gt; 가 0의 수를 계산하는 대신 1의 수를 계산하게됩니다.</target>
        </trans-unit>
        <trans-unit id="caf455145317822f90dd7493431b1576d0e6536d" translate="yes" xml:space="preserve">
          <source>At present, there is no &lt;code&gt;Math.clon&lt;/code&gt; for &quot;Count Leading Ones&quot; (named &quot;clon&quot;, not &quot;clo&quot;, because &quot;clo&quot; and &quot;clz&quot; are too similar especially for non-english-speaking people). However, a CLON function can easily be created by inversing the bits of a number and passing the result to `Math.clz` which will work because the inverse of 1 is 0 and vice-versa. Thus, inversing the bits will inverse the measured quanity 0 (of Math.clz), thereby making Math.clz count the number of ones instead of the number of zeros.</source>
          <target state="translated">현재 &quot;Count Leading Ones&quot;에 대한 &lt;code&gt;Math.clon&lt;/code&gt; 은 없습니다 ( &quot;clo&quot;와 &quot;clz&quot;는 영어를 구사하지 않는 사람들에게는 너무 유사하기 때문에 &quot;clo&quot;가 아니라 &quot;clon&quot;으로 명명 됨). 그러나 CLON 함수는 숫자의 비트를 뒤집고 그 결과를`Math.clz '에 전달하여 쉽게 만들 수 있는데, 이는 1의 역수가 0이므로 반대의 경우도 마찬가지입니다. 따라서, 비트를 반전 시키면 (Math.clz의) 측정 된 quanity 0이 반전되어 Math.clz는 0의 수 대신 1의 수를 카운트하게됩니다.</target>
        </trans-unit>
        <trans-unit id="e123dd9e59650fe88b327d4d0f525d401259f392" translate="yes" xml:space="preserve">
          <source>At the moment &lt;code&gt;stop()&lt;/code&gt; is called the call stack will be:</source>
          <target state="translated">&lt;code&gt;stop()&lt;/code&gt; 이 호출 되는 순간 호출 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d1cc4f39fed99301ce94078cc2a5219ea84aca7" translate="yes" xml:space="preserve">
          <source>At the time when the constructor generates the new &lt;code&gt;promiseObj&lt;/code&gt;, it also generates a corresponding pair of functions for &lt;code&gt;resolutionFunc&lt;/code&gt; and &lt;code&gt;rejectionFunc;&lt;/code&gt; these are &quot;tethered&quot; to the &lt;code&gt;promiseObj&lt;/code&gt;. Therefore, the code within the &lt;code&gt;executor&lt;/code&gt; has the opportunity to perform some operation and then reflect the operation's outcome(If the value is not another Promise object) as either &quot;fulfilled&quot; or &quot;rejected&quot; by terminating with an invocation of either the &lt;code&gt;resolutionFunc&lt;/code&gt; or the &lt;code&gt;rejectionFunc&lt;/code&gt;, respectively.</source>
          <target state="translated">생성자가 새 &lt;code&gt;promiseObj&lt;/code&gt; 를 생성 할 때 &lt;code&gt;resolutionFunc&lt;/code&gt; 및 &lt;code&gt;rejectionFunc;&lt;/code&gt; 해당하는 함수 쌍도 생성합니다 . 이들은 &lt;code&gt;promiseObj&lt;/code&gt; 에 &quot;테 더링&quot;됩니다 . 따라서 &lt;code&gt;executor&lt;/code&gt; 프로그램 내의 코드 는 일부 작업을 수행 한 다음 &lt;code&gt;resolutionFunc&lt;/code&gt; 또는 the &lt;code&gt;rejectionFunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21647d40658d5c2bb791c8dd38ca360a2deedaab" translate="yes" xml:space="preserve">
          <source>At the top level of programs and functions, &lt;code&gt;let&lt;/code&gt;, unlike &lt;code&gt;var&lt;/code&gt;, does not create a property on the global object. For example:</source>
          <target state="translated">프로그램 및 기능의 최상위 레벨에서 &lt;code&gt;let&lt;/code&gt; 는 달리, &lt;code&gt;var&lt;/code&gt; , 전역 객체의 속성을 만들지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="3f836adca87be251d502a94ed73c994043ad8e3e" translate="yes" xml:space="preserve">
          <source>Atomic operations on non-shared &lt;code&gt;ArrayBuffer&lt;/code&gt; objects</source>
          <target state="translated">비공유 &lt;code&gt;ArrayBuffer&lt;/code&gt; 에 대한 원자 적 작업 객체</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="f85f7410ec8be229ef5b91b1cd3f92c61f353f5a" translate="yes" xml:space="preserve">
          <source>Atomics.add</source>
          <target state="translated">Atomics.add</target>
        </trans-unit>
        <trans-unit id="e00a0386c1e6b2b0638039f05bc4001df4969ab8" translate="yes" xml:space="preserve">
          <source>Atomics.and</source>
          <target state="translated">Atomics.and</target>
        </trans-unit>
        <trans-unit id="ad2717348dd0b78b3ee3b1d52eedf3294cae060a" translate="yes" xml:space="preserve">
          <source>Atomics.compareExchange</source>
          <target state="translated">Atomics.compareExchange</target>
        </trans-unit>
        <trans-unit id="badd0d0872059c86c2354b2522695f9e9b64e841" translate="yes" xml:space="preserve">
          <source>Atomics.exchange</source>
          <target state="translated">Atomics.exchange</target>
        </trans-unit>
        <trans-unit id="9a2ef3ec645728e3192050492ca789f56bd331ef" translate="yes" xml:space="preserve">
          <source>Atomics.isLockFree</source>
          <target state="translated">Atomics.isLockFree</target>
        </trans-unit>
        <trans-unit id="1fb98a238867f9795a0ca47509ccc73a1f3804e1" translate="yes" xml:space="preserve">
          <source>Atomics.load</source>
          <target state="translated">Atomics.load</target>
        </trans-unit>
        <trans-unit id="8f33001e9afb9970703f3e069d77cd387440522c" translate="yes" xml:space="preserve">
          <source>Atomics.notify</source>
          <target state="translated">Atomics.notify</target>
        </trans-unit>
        <trans-unit id="4b59069ef282276419e62366e7890757fc613351" translate="yes" xml:space="preserve">
          <source>Atomics.or</source>
          <target state="translated">Atomics.or</target>
        </trans-unit>
        <trans-unit id="7a3aec76fe1cacc70b5c6d279f1176edd778085b" translate="yes" xml:space="preserve">
          <source>Atomics.store</source>
          <target state="translated">Atomics.store</target>
        </trans-unit>
        <trans-unit id="b2be5619f1b779bdbcc894c4b051895bb2cf5398" translate="yes" xml:space="preserve">
          <source>Atomics.sub</source>
          <target state="translated">Atomics.sub</target>
        </trans-unit>
        <trans-unit id="6b37ac0d3d457722e8601f3c8e946f5f5bf02162" translate="yes" xml:space="preserve">
          <source>Atomics.wait</source>
          <target state="translated">Atomics.wait</target>
        </trans-unit>
        <trans-unit id="a82e5513b087ae217336da68fa152fea0c82446d" translate="yes" xml:space="preserve">
          <source>Atomics.xor</source>
          <target state="translated">Atomics.xor</target>
        </trans-unit>
        <trans-unit id="2b33afd0e78ae876c55d72cc152397ba1385a00e" translate="yes" xml:space="preserve">
          <source>Attempting to declare a class twice</source>
          <target state="translated">클래스를 두 번 선언하려고 시도</target>
        </trans-unit>
        <trans-unit id="72d46d7d3d242c212209a1fadee72567b294d7d2" translate="yes" xml:space="preserve">
          <source>Attempting to delete a plain variable, doesn't work in JavaScript and it throws an error in strict mode:</source>
          <target state="translated">일반 변수를 삭제하려고 시도하면 JavaScript에서 작동하지 않으며 엄격 모드에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ddd176d7dc7b62615a492c4fdf896a00beffcfde" translate="yes" xml:space="preserve">
          <source>Attempting to delete non-configurable properties</source>
          <target state="translated">구성 할 수없는 속성 삭제 시도</target>
        </trans-unit>
        <trans-unit id="db5152f6fbed10d8441cb928a545cd73f0aaed25" translate="yes" xml:space="preserve">
          <source>Attention: If an empty string (&quot;&quot;) is used as the separator, the string is &lt;strong&gt;not&lt;/strong&gt; split between each &lt;em&gt;user-perceived character&lt;/em&gt; (&lt;a href=&quot;https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries&quot;&gt;grapheme cluster&lt;/a&gt;) or between each unicode character (codepoint) but between each UTF-16 codeunit. This destroys &lt;a href=&quot;http://unicode.org/faq/utf_bom.html#utf16-2&quot;&gt;surrogate pairs&lt;/a&gt;. See also &lt;a href=&quot;https://stackoverflow.com/a/34717402&quot;&gt;How do you get a string to a character array in JavaScript?&lt;/a&gt; on stackoverflow.</source>
          <target state="translated">주의 : 빈 문자열 ( &quot;&quot;), 세퍼레이터로서 사용되는 경우, 캐릭터가되어 &lt;strong&gt;있지&lt;/strong&gt; 각각 나뉘어 &lt;em&gt;사용자 인식 문자&lt;/em&gt; ( &lt;a href=&quot;https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries&quot;&gt;자모 클러스터&lt;/a&gt; ) 또는 각각의 유니 코드 문자 사이 (코드 포인트)하지만 각 UTF-16 codeunit 사이. 이것은 &lt;a href=&quot;http://unicode.org/faq/utf_bom.html#utf16-2&quot;&gt;대리 쌍을&lt;/a&gt; 파괴 합니다 . &lt;a href=&quot;https://stackoverflow.com/a/34717402&quot;&gt;JavaScript에서 문자열을 문자형 배열로 가져 오는 방법&lt;/a&gt; 도 참조하십시오 . 스택 오버 플로우.</target>
        </trans-unit>
        <trans-unit id="b9198038145c380df9f218dd05386e8b57cbcae3" translate="yes" xml:space="preserve">
          <source>Autoboxing will not happen in strict mode, the &lt;em&gt;this&lt;/em&gt; value remains as passed.</source>
          <target state="translated">오토 박싱은 엄격 모드에서 발생하지 않습니다 &lt;em&gt;이&lt;/em&gt; 전달로 값 유적.</target>
        </trans-unit>
        <trans-unit id="2f1bd0e4bb77a22b6b44b6989aabd07d1ca2d4a8" translate="yes" xml:space="preserve">
          <source>Automate Mask Creation</source>
          <target state="translated">마스크 생성 자동화</target>
        </trans-unit>
        <trans-unit id="ef03d415de3b288ce45c39fae71498f3e9051f49" translate="yes" xml:space="preserve">
          <source>Automatic Semicolon Insertion</source>
          <target state="translated">자동 세미콜론 삽입</target>
        </trans-unit>
        <trans-unit id="872127103480de5d4b855a7eef875473dc644f22" translate="yes" xml:space="preserve">
          <source>Automatic semicolon insertion</source>
          <target state="translated">자동 세미콜론 삽입</target>
        </trans-unit>
        <trans-unit id="ea2f6197435b14aebe5f46e481ed29407de6b116" translate="yes" xml:space="preserve">
          <source>Automatic semicolon insertion (ASI)</source>
          <target state="translated">자동 세미콜론 삽입 (ASI)</target>
        </trans-unit>
        <trans-unit id="0dbde6894a574267e8a91c3cb9bcd71799f17575" translate="yes" xml:space="preserve">
          <source>Available in Firefox Nightly.</source>
          <target state="translated">Firefox Nightly에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1d28ddbdb25cf79cfa52355eac8bf17a5cbf93a8" translate="yes" xml:space="preserve">
          <source>Available in workers</source>
          <target state="translated">노동자에서 유효한</target>
        </trans-unit>
        <trans-unit id="b318f9f25ac95a943d98d2de8173c1823b4dea0e" translate="yes" xml:space="preserve">
          <source>Avoid comparing formatted date values to static values</source>
          <target state="translated">형식이 지정된 날짜 값을 정적 값과 비교하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="665404082df60aa12c1c1d0ba08877ba86b20a9c" translate="yes" xml:space="preserve">
          <source>Avoid where possible</source>
          <target state="translated">가능한 한 피하십시오</target>
        </trans-unit>
        <trans-unit id="3de44dc233fdc574da2ac9dba3876a893c9af95f" translate="yes" xml:space="preserve">
          <source>Avoiding &lt;code&gt;eval()&lt;/code&gt; here could be done by splitting the property path and looping through the different properties:</source>
          <target state="translated">여기에서 &lt;code&gt;eval()&lt;/code&gt; 피하기 는 속성 경로를 분할하고 다른 속성을 반복하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310d1e06f91217d130d6eb9ad2231dbd27fd8bfd" translate="yes" xml:space="preserve">
          <source>Awaiting a promise to be fulfilled</source>
          <target state="translated">성취 될 약속을 기다리며</target>
        </trans-unit>
        <trans-unit id="5f18a12ebb8823e606a287182279c3b7bf13c914" translate="yes" xml:space="preserve">
          <source>Axel Rauschmayer's book: &quot;Exploring JS: Modules&quot;</source>
          <target state="translated">Axel Rauschmayer의 책 : &quot;JS : 모듈 탐구&quot;</target>
        </trans-unit>
        <trans-unit id="cfad1589094fb6bb5ab258c1bab5dad61852e4a2" translate="yes" xml:space="preserve">
          <source>Axel Rauschmayer's book: &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;&quot;Exploring JS: Modules&quot;&lt;/a&gt;</source>
          <target state="translated">Axel Rauschmayer의 저서 : &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;&quot;Exploring JS : Modules&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6909aee501b628ab957c138b9e729d59fbb7b1f0" translate="yes" xml:space="preserve">
          <source>BCP 47 also allows for extensions, each consisting of a single digit or letter (other than &lt;code&gt;&quot;x&quot;&lt;/code&gt;) and one or more two- to eight-letter or digit tags, all separated by hyphens. JavaScript internationalization functions use the &lt;code&gt;&quot;u&quot;&lt;/code&gt; (Unicode) extension, which can be used to request additional customization of &lt;a href=&quot;intl/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;intl/numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;intl/datetimeformat&quot;&gt;&lt;code&gt;DateTimeFormat&lt;/code&gt;&lt;/a&gt; objects. Examples:</source>
          <target state="translated">BCP 47은 또한 하나의 숫자 또는 문자 ( &lt;code&gt;&quot;x&quot;&lt;/code&gt; 제외)와 하나 이상의 2-8 자 또는 숫자 태그로 구성되며 모두 하이픈으로 구분 된 확장을 허용합니다. JavaScript 국제화 함수 는 &lt;a href=&quot;intl/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;intl/numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;intl/datetimeformat&quot;&gt; &lt;code&gt;DateTimeFormat&lt;/code&gt; &lt;/a&gt; 객체 의 추가 사용자 정의를 요청하는 데 사용할 수있는 &lt;code&gt;&quot;u&quot;&lt;/code&gt; (유니 코드) 확장을 사용 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e6a4665f91bc71a6040ede9f0b9a35ce77ce0584" translate="yes" xml:space="preserve">
          <source>BCP 47 also allows for extensions. JavaScript internationalization functions use the &lt;code&gt;&quot;u&quot;&lt;/code&gt; (Unicode) extension, which can be used to request additional customization of &lt;a href=&quot;collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numberformat&quot;&gt;&lt;code&gt;NumberFormat&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;datetimeformat&quot;&gt;&lt;code&gt;DateTimeFormat&lt;/code&gt;&lt;/a&gt; objects. Examples:</source>
          <target state="translated">BCP 47은 또한 확장을 허용합니다. JavaScript 국제화 함수는 &lt;code&gt;&quot;u&quot;&lt;/code&gt; (유니 코드) 확장자를 사용하여 &lt;a href=&quot;collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numberformat&quot;&gt; &lt;code&gt;NumberFormat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;datetimeformat&quot;&gt; &lt;code&gt;DateTimeFormat&lt;/code&gt; &lt;/a&gt; 오브젝트 의 추가 사용자 정의를 요청하는 데 사용할 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="ce1d3d04df88b03c0902b03fc277abd7509b89f7" translate="yes" xml:space="preserve">
          <source>BMP characters, in UTF-16, use a single code unit:</source>
          <target state="translated">UTF-16의 BMP 문자는 단일 코드 단위를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="14f79f39f0a63aa933f5da5de18563f76130fdb0" translate="yes" xml:space="preserve">
          <source>Babel can handle Custom Error Class methods, but only when they are declared with &lt;a href=&quot;object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;. Otherwise, Babel and other transpilers will not correctly handle the following code without &lt;a href=&quot;https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend&quot;&gt;additional configuration&lt;/a&gt;.</source>
          <target state="translated">Babel은 Custom Error Class 메서드를 처리 할 수 ​​있지만 &lt;a href=&quot;object/defineproperty&quot;&gt;Object.defineProperty ()&lt;/a&gt; 로 선언 된 경우에만 가능 합니다. 그렇지 않으면 Babel 및 기타 변환기가 &lt;a href=&quot;https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend&quot;&gt;추가 구성&lt;/a&gt; 없이 다음 코드를 올바르게 처리하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="34a0c4a7da2073aae9dc11efe23ad6817bc43ca9" translate="yes" xml:space="preserve">
          <source>Backward compatibility can be ensured using attribute &lt;code&gt;nomodule&lt;/code&gt; on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; tag.</source>
          <target state="translated">이전 버전과의 호환성은 속성의 사용을 보장 할 수 &lt;code&gt;nomodule&lt;/code&gt; 을 온 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그입니다.</target>
        </trans-unit>
        <trans-unit id="8c1d2b7474b3062f0921e1c8062aee5ea36a9a24" translate="yes" xml:space="preserve">
          <source>Backward compatibility: In historic versions (like JavaScript 1.2) the &lt;code&gt;charCodeAt()&lt;/code&gt; method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct match of the ASCII character set.</source>
          <target state="translated">이전 버전과의 호환성 : JavaScript 1.2와 같은 기록 버전에서 &lt;code&gt;charCodeAt()&lt;/code&gt; 메서드는 지정된 인덱스에있는 문자의 ISO-Latin-1 코드 세트 값을 나타내는 숫자를 반환합니다. ISO-Latin-1 코드 세트의 범위는 0-255입니다. 첫 번째 0-127은 ASCII 문자 세트와 직접 일치합니다.</target>
        </trans-unit>
        <trans-unit id="acf9d65267d783baf67f1e532c25a3c9280dc0e0" translate="yes" xml:space="preserve">
          <source>Backward compatibility: In historic versions (like JavaScript 1.2) the &lt;code&gt;charCodeAt()&lt;/code&gt; method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. The first &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;127&lt;/code&gt; are a direct match of the ASCII character set.</source>
          <target state="translated">역 호환성 : 이전 버전 (예 : JavaScript 1.2)에서 &lt;code&gt;charCodeAt()&lt;/code&gt; 메서드는 지정된 색인에있는 문자의 ISO-Latin-1 코드 세트 값을 나타내는 숫자를 반환합니다. ISO-Latin-1 코드 세트의 범위는 &lt;code&gt;0&lt;/code&gt; ~ &lt;code&gt;255&lt;/code&gt; 입니다. 처음 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;127&lt;/code&gt; 은 ASCII 문자 집합과 직접 일치합니다.</target>
        </trans-unit>
        <trans-unit id="21d14d590046bace542231b735e58a3935f07bd1" translate="yes" xml:space="preserve">
          <source>Bad code with &lt;code&gt;eval()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 사용한 잘못된 코드 :</target>
        </trans-unit>
        <trans-unit id="4503df1131ba4201009636d74c2ac16a6cb58b3a" translate="yes" xml:space="preserve">
          <source>Bad code with eval:</source>
          <target state="translated">평가가 잘못된 코드 :</target>
        </trans-unit>
        <trans-unit id="1ddbaaa28a35cb31e8f654cd17ff8f5babeaec2b" translate="yes" xml:space="preserve">
          <source>Bad keywords</source>
          <target state="translated">잘못된 키워드</target>
        </trans-unit>
        <trans-unit id="cb778240eb1a8d5a5b8d65d21154595b3c8f0201" translate="yes" xml:space="preserve">
          <source>Bad octal</source>
          <target state="translated">나쁜 8 진</target>
        </trans-unit>
        <trans-unit id="c3938ec2fcbf136263fe632f93c19fa52f055a88" translate="yes" xml:space="preserve">
          <source>Bad radix</source>
          <target state="translated">기수</target>
        </trans-unit>
        <trans-unit id="52ef861c5150691f8f54cf9fda204d94d1f25438" translate="yes" xml:space="preserve">
          <source>Bad regexp flag</source>
          <target state="translated">잘못된 정규식 플래그</target>
        </trans-unit>
        <trans-unit id="56c45ab05316e25c53faf5dfe1d3443f60ccab8a" translate="yes" xml:space="preserve">
          <source>Bad return or yield</source>
          <target state="translated">불량 수익률</target>
        </trans-unit>
        <trans-unit id="82e8713139343b8a44e6ce88afab446733d2cfa7" translate="yes" xml:space="preserve">
          <source>Balinese digits</source>
          <target state="translated">발리 숫자</target>
        </trans-unit>
        <trans-unit id="a598b79d487db8f6e5350ab4e06367a72ce91665" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm of E, approximately 0.434.</source>
          <target state="translated">E의 밑이 10 인 로그는 약 0.434입니다.</target>
        </trans-unit>
        <trans-unit id="90d513cda2433f2c16588aab1e2d0e868d46a7e3" translate="yes" xml:space="preserve">
          <source>Base 2 logarithm of E, approximately 1.443.</source>
          <target state="translated">E의 밑이 2 인 로그는 약 1.443입니다.</target>
        </trans-unit>
        <trans-unit id="7e65305b3de5a607a44d39b5b89d6bcecf695442" translate="yes" xml:space="preserve">
          <source>Base-10 logarithm of &lt;code&gt;E&lt;/code&gt;; approximately &lt;code&gt;0.434&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 의 밑이 10 인 로그 ; 약 &lt;code&gt;0.434&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54ef76ef210fba93e149b9c0d3d3ea9bd7a633e5" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;E&lt;/code&gt;; approximately &lt;code&gt;1.443&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 의 밑이 2 인 로그 ; 약 &lt;code&gt;1.443&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec7bef0e28378298bb0f60a8456b619c42be767e" translate="yes" xml:space="preserve">
          <source>Base62x</source>
          <target state="translated">Base62x</target>
        </trans-unit>
        <trans-unit id="93a7282c9864a1028a984aa6cbbb2ec6b5aa16d3" translate="yes" xml:space="preserve">
          <source>Based on &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;rfc7231&lt;/a&gt; and modified according to &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-date.prototype.toutcstring&quot;&gt;ecma-262 toUTCString&lt;/a&gt;, it can have negative values in the &lt;a href=&quot;https://tc39.es/ecma262/#sec-date.prototype.toutcstring&quot;&gt;2021 version&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;rfc7231을&lt;/a&gt; 기반으로 하고 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-date.prototype.toutcstring&quot;&gt;ecma-262 toUTCString&lt;/a&gt; 에 따라 수정 되었으며 &lt;a href=&quot;https://tc39.es/ecma262/#sec-date.prototype.toutcstring&quot;&gt;2021 버전&lt;/a&gt; 에서 음수 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a51dd96170b4f481d245702db0b852840eda8492" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;format&lt;/code&gt; usage</source>
          <target state="translated">기본 &lt;code&gt;format&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="e08cb7a1d697c774ab698effaea99dfd6d5aa779" translate="yes" xml:space="preserve">
          <source>Basic &lt;code&gt;formatRange&lt;/code&gt; usage</source>
          <target state="translated">기본 &lt;code&gt;formatRange&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="d3171daff0fd5c1a55e8e273e630be925b5dab7f" translate="yes" xml:space="preserve">
          <source>Basic assignment</source>
          <target state="translated">기본 과제</target>
        </trans-unit>
        <trans-unit id="385f92dd7e327ad7e274a02d06c99636307445f5" translate="yes" xml:space="preserve">
          <source>Basic const usage</source>
          <target state="translated">기본적인 const 사용법</target>
        </trans-unit>
        <trans-unit id="b7d02d0cdbdcee22f1fb765dca10884b0e541413" translate="yes" xml:space="preserve">
          <source>Basic division</source>
          <target state="translated">기본 구분</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="b05ce46110143bfc1a17af9e6d27306b788aa56d" translate="yes" xml:space="preserve">
          <source>Basic exponentiation</source>
          <target state="translated">기본 지수</target>
        </trans-unit>
        <trans-unit id="2c9cf6c707f48de1d6715dc4325c637cf880df09" translate="yes" xml:space="preserve">
          <source>Basic formatRangeToParts usage</source>
          <target state="translated">기본 formatRangeToParts 사용법</target>
        </trans-unit>
        <trans-unit id="603a17103ca6f4689a7f39d7753cccdc316ac985" translate="yes" xml:space="preserve">
          <source>Basic keywords and general expressions in JavaScript.</source>
          <target state="translated">JavaScript의 기본 키워드 및 일반 표현식</target>
        </trans-unit>
        <trans-unit id="48e2b3aff207a2929af920ad2047a4854ec8d687" translate="yes" xml:space="preserve">
          <source>Basic support</source>
          <target state="translated">기본 지원</target>
        </trans-unit>
        <trans-unit id="953657b3d60232a538f74887fa8b6a3c3c1d63ab" translate="yes" xml:space="preserve">
          <source>Basic syntax</source>
          <target state="translated">기본 문법</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="d0cb1bfda35a10398f80e9a6a90f2d5ba29df508" translate="yes" xml:space="preserve">
          <source>Basic variable assignment</source>
          <target state="translated">기본 변수 할당</target>
        </trans-unit>
        <trans-unit id="f0190e01f6433ac19adccb460422e2fa412fec44" translate="yes" xml:space="preserve">
          <source>Be aware of, also, that using Object.entries() on an object created via Object.create() will result in an empty array being returned.</source>
          <target state="translated">또한 Object.create ()를 통해 생성 된 객체에 Object.entries ()를 사용하면 빈 배열이 반환된다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="97c266c8bd468b1c3cd55d582d8503a21e064806" translate="yes" xml:space="preserve">
          <source>Be aware that a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; will be thrown if a trailing comma is used on the left-hand side with a rest element:</source>
          <target state="translated">&amp;bull; 그래도주의 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 뒤에 쉼표가 나머지 요소와 왼쪽에 사용하는 경우 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="e02c3864b4961d4d706a2d9dc784c97800627ab4" translate="yes" xml:space="preserve">
          <source>Be aware that a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; will be thrown if a trailing comma is used on the right-hand side of a rest element:</source>
          <target state="translated">&amp;bull; 그래도주의 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 뒤에 쉼표가 나머지 요소의 오른쪽에 사용하는 경우 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="dc9bbd3411cedcf90a22d35246e2dd08020ba70c" translate="yes" xml:space="preserve">
          <source>Be careful when using the &lt;code&gt;in&lt;/code&gt; operator to search in &lt;a href=&quot;../global_objects/array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; objects. The &lt;code&gt;in&lt;/code&gt; operator checks the index number, not the value at that index.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 연산자를 사용하여 &lt;a href=&quot;../global_objects/array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 객체 를 검색 할 때주의하십시오 . &lt;code&gt;in&lt;/code&gt; 오퍼레이터 검사 인덱스 번호, 그 인덱스 값이 아닌.</target>
        </trans-unit>
        <trans-unit id="04bf3c3bb0512624aeb7e2950aaef79621519c1b" translate="yes" xml:space="preserve">
          <source>Be mindful of the order:</source>
          <target state="translated">순서를 명심하십시오 :</target>
        </trans-unit>
        <trans-unit id="17b155441a7c080cfc06afe199d93e49f39490b1" translate="yes" xml:space="preserve">
          <source>Bear in mind that these attributes are not necessarily the descriptor's own properties. Inherited properties will be considered as well. In order to ensure these defaults are preserved, you might freeze the &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/a&gt; upfront, specify all options explicitly, or point to &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;create&quot;&gt;&lt;code&gt;Object.create(null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 속성이 반드시 설명자 고유의 속성은 아닙니다. 상속 된 속성도 고려됩니다. 이러한 기본값이 유지되도록하려면 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object.prototype&lt;/code&gt; 을&lt;/a&gt; 미리 고정 하거나 모든 옵션을 명시 적으로 지정하거나 &lt;a href=&quot;create&quot;&gt; &lt;code&gt;Object.create(null)&lt;/code&gt; &lt;/a&gt; 하여 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 가리킬 수 있습니다. 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d4529f5c08d6e05c06f2a846ce44f96dd10e1b" translate="yes" xml:space="preserve">
          <source>Bear in mind that these attributes are not necessarily the descriptor's own properties. Inherited properties will be considered as well. In order to ensure these defaults are preserved, you might freeze the &lt;a href=&quot;prototype&quot;&gt;&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/a&gt; upfront, specify all options explicitly, or point to &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;create&quot;&gt;&lt;code&gt;Object.create(null)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 속성은 반드시 설명자 자신의 속성 일 필요는 없습니다. 상속 된 속성도 고려됩니다. 이러한 기본값을 유지하기 위해 &lt;a href=&quot;prototype&quot;&gt; &lt;code&gt;Object.prototype&lt;/code&gt; 을&lt;/a&gt; 미리 고정 시키 거나 모든 옵션을 명시 적으로 지정하거나 &lt;a href=&quot;create&quot;&gt; &lt;code&gt;Object.create(null)&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c00375e350157c8ada33eaad97c26905f63efc" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;E&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.E&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.E&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="0b82237b8ca287548c8c9d966231902587413854" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;LN10&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.LN10&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;LN10&lt;/code&gt; 은 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.LN10&lt;/code&gt; 으로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="74c299425352e96db9b847db61898b8bd8a3bbb7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;LN2&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.LN2&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;LN2&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.LN2&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="b21307b05117fad93dfb591d1dc7fbf9248e5e7d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;LOG10E&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.LOG10E&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;LOG10E&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.LOG10E&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="35a8bdd1c3ebf5931310584099a45bdb95dc7a00" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;LOG2E&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.LOG2E&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;LOG2E&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.LOG2E&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="28da257f917dc14a7461c78d28327d34af66855c" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MAX_SAFE_INTEGER&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;MAX_SAFE_INTEGER&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="077f4de5c3ea80491f5d9c680f34de3613201936" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MAX_VALUE&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.MAX_VALUE&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;MAX_VALUE&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아닌 항상 &lt;code&gt;Number.MAX_VALUE&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d0bd2fe13bef8111056df1f25f32475d70d3dd46" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MAX_VALUE&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.MAX_VALUE&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created. Calling it on the object you created(rather than &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; itself), will result in &lt;strong&gt;undefined&lt;/strong&gt; value.</source>
          <target state="translated">&lt;code&gt;MAX_VALUE&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Number.MAX_VALUE&lt;/code&gt; 로 사용합니다 . &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 자체가 아니라 만든 객체에서 호출하면 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 값 이 발생 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7668233da44d6b3d40245d7d5498724e4e43aab" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MIN_SAFE_INTEGER&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;MIN_SAFE_INTEGER&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ddc83264c5614617d7120921ebe62621ba077b15" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MIN_VALUE&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.MIN_VALUE&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;MIN_VALUE&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Number.MIN_VALUE&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="59e28bee002f1e71a28d51e2c1d9ebf64a4e0b72" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Math&lt;/code&gt; is not a constructor, &lt;code&gt;max()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt; (You always use it as &lt;code&gt;Math.max()&lt;/code&gt;, rather than as a method of an instanced &lt;code&gt;Math&lt;/code&gt; object).</source>
          <target state="translated">&lt;code&gt;Math&lt;/code&gt; 는 생성자가 아니기 때문에 &lt;code&gt;max()&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 메서드입니다 . 인스턴스화 된 &lt;code&gt;Math&lt;/code&gt; 객체 의 메서드가 아니라 항상 &lt;code&gt;Math.max()&lt;/code&gt; 로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d446b3d7d27b21910d3a0b232b222b99cad1cf7" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.NEGATIVE_INFINITY&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;NEGATIVE_INFINITY&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아닌 항상 &lt;code&gt;Number.NEGATIVE_INFINITY&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dc6003a808eb6b1e37755f0a59d5c4579d5512c5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PI&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.PI&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;PI&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.PI&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="170df98252c4d129f7ddcfc182b168b1f8e3d185" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; is a static property of &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;, rather than as a property of a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">&lt;code&gt;POSITIVE_INFINITY&lt;/code&gt; 는 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 의 정적 속성 이므로 생성 한 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt; 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c20ad6b99ef4e0c6cd5c7258b7e31dabeb8fb09b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Reflect.defineProperty&lt;/code&gt; returns a Boolean success status, you can just use an &lt;code&gt;&lt;a href=&quot;../../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt; block here:</source>
          <target state="translated">&lt;code&gt;Reflect.defineProperty&lt;/code&gt; 가 부울 성공 상태를 반환 하기 때문에 여기서 &lt;code&gt;&lt;a href=&quot;../../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt; 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3db7decf4d8bb989733ad671d3d4a23d7d324f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;SQRT1_2&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.SQRT1_2&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;SQRT1_2&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.SQRT1_2&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="8eadbe8117d2da8fddf518944fb3798a13a205fc" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;SQRT2&lt;/code&gt; is a static property of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.SQRT2&lt;/code&gt;, rather than as a property of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">&lt;code&gt;SQRT2&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 속성 이므로 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 속성이 아니라 항상 &lt;code&gt;Math.SQRT2&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 는 생성자가 아님).</target>
        </trans-unit>
        <trans-unit id="da0573ddff08ba142b239d6699ca38a32055fb53" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;abs()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.abs()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;abs()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.abs()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="37e61cbad7672ad9ad2a476a1d4818ce03c60692" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;acos()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.acos()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;acos()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.acos()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="e20ec90111527afee6c1b5758ff6c8166867c76d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;acosh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.acosh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is no constructor).</source>
          <target state="translated">때문에 &lt;code&gt;acosh()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.acosh()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 없음).</target>
        </trans-unit>
        <trans-unit id="c42515ecc3b7607915622996be58b945e58008c5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;asin()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.asin()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;asin()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.asin()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="1ad7904f3ecae86089f72ff0a3814609d377719a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;asinh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.asinh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;asinh()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.asinh()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="9e875c549d11bc970b0f1afdcf76ded5ef1eac90" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;atan()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.atan()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;atan()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.atan()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="9b8b9b1909763a487ac98201cce52fefdc1934b5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;atan2()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.atan2()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;atan2()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.atan2()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="4edbcd2c6fdb404e5be6e4271ec17592b8ea3453" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;atanh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.atanh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;atanh()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.atanh()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="c39bc6d4aaea62511e5e16c760ed8a7cd2057282" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;cbrt()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.cbrt()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;cbrt()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.cbrt()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="7536b1cc9a985c4bb5f8409e31dcaf4731519d46" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;ceil()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.ceil()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;ceil()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.ceil()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="b5199a2af06df91de5b4bcfdf9fbd3a86fe3452f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;cos()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.cos()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;cos()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용할 &lt;code&gt;Math.cos()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="ae64a33697739a9c10e13dcd75bd1d4c6f28d9d9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;cosh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.cosh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;cosh()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.cosh()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="60fe84081b0a915785751f48959e6fc0527d23da" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;exp()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.exp()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;exp()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.exp()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="492133ebabf3cb8131ecd1375ae5a01bc20e3ba9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;expm1()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.expm1()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;expm1()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.expm1()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="e762507e1c13ded9a98083683b7484be5bb493e4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;floor()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.floor()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;floor()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.floor()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="d44790cd68c5a20a416530969112fe05b3fed5a0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fromCharCode()&lt;/code&gt; is a static method of &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;String.fromCharCode()&lt;/code&gt;, rather than as a method of a &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">때문에 &lt;code&gt;fromCharCode()&lt;/code&gt; 의 정적 방법 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , 당신은 항상로 사용 &lt;code&gt;String.fromCharCode()&lt;/code&gt; 보다는의 방법으로 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 오브젝트 당신이 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="cbf818ffb66ea3de63f350cd39e18544f1de4b2a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fromCharCode()&lt;/code&gt; only works with 16-bit values (same as the &lt;code&gt;\u&lt;/code&gt; escape sequence), a surrogate pair is required in order to return a supplementary character. For example, both &lt;code&gt;String.fromCharCode(0xD83C, 0xDF03)&lt;/code&gt; and &lt;code&gt;\uD83C\uDF03&lt;/code&gt; return code point &lt;code&gt;U+1F303&lt;/code&gt; &quot;Night with Stars&quot;.</source>
          <target state="translated">왜냐하면 &lt;code&gt;fromCharCode()&lt;/code&gt; 단 (16와 동일 비트 값 작동 &lt;code&gt;\u&lt;/code&gt; 대리 쌍이 부가 문자를 리턴하기 위해 필요한, 이스케이프 시퀀스). 예를 들어, &lt;code&gt;String.fromCharCode(0xD83C, 0xDF03)&lt;/code&gt; 및 &lt;code&gt;\uD83C\uDF03&lt;/code&gt; 코드 포인트 &lt;code&gt;U+1F303&lt;/code&gt; &quot;별이있는 밤&quot;을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d013ee9d50f6892ef3976a970b60a910ebe9b4c4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fromCodePoint()&lt;/code&gt; is a static method of &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;String.fromCodePoint()&lt;/code&gt;, rather than as a method of a &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">때문에 &lt;code&gt;fromCodePoint()&lt;/code&gt; 의 정적 방법 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , 당신은 항상로 사용 &lt;code&gt;String.fromCodePoint()&lt;/code&gt; 보다는의 방법으로 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 오브젝트 당신이 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="aad7bfed48215b0f742476bab0b572a56f15eaf5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fromCodePoint()&lt;/code&gt; is a static method of &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, you must call it as &lt;code&gt;String.fromCodePoint()&lt;/code&gt;, rather than as a method of a &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; object you created.</source>
          <target state="translated">때문에 &lt;code&gt;fromCodePoint()&lt;/code&gt; 의 정적 방법 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , 당신이로 호출해야 &lt;code&gt;String.fromCodePoint()&lt;/code&gt; 보다는의 방법으로 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 오브젝트 당신이 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="ad160d0aa4d77d60deec7ba899aff53d3317dbc8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;fround()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.fround()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;fround()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.fround()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="53268151587d2de8c8d329793e7fa99990cf27ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;hypot()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.hypot()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;hypot()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.hypot()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="ee560aad8583510bf57e46a82e9d61aa9eaef074" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;imul()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.imul()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;imul()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.imul()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="ca090e636d85d8126929e1be48b1bedb97a25f21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;log()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.log()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;log()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.log()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="06ff84d1cfb60efb814067d964a1badf08b59ca8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;log10()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.log10()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;log10()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.log10()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="d4504da10c3b187be135cf0b93ebfb704290c6dd" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;log1p()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.log1p()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;log1p()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.log1p()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="f1c683e74b27b4bb60facc44c92d320f9cacd257" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;log2()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.log2()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;log2()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.log2()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="11fbf5fcd5f937dc77c18cf2f7ab47a9611d3751" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;max()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.max()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;max()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.max()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="5a8071e18e448e739f60e98d44548d36040ed2f9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;min()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.min()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;min()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.min()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="4e9a349771578ae630f5b9ceca8e29d7d1f4ca26" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;now()&lt;/code&gt; is a static method of &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, you always use it as &lt;code&gt;Date.now()&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;now()&lt;/code&gt; 의 정적 방법 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , 당신은 항상로 사용 &lt;code&gt;Date.now()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b49ed67cd88286bc6e1698ad754539ba1a1a87c" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;parse()&lt;/code&gt; is a static method of &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, it is called as &lt;code&gt;Date.parse()&lt;/code&gt; rather than as a method of a &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">때문에 &lt;code&gt;parse()&lt;/code&gt; 정적 방법 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; ,이 호출되는 &lt;code&gt;Date.parse()&lt;/code&gt; 대신하는 방법으로서 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 예.</target>
        </trans-unit>
        <trans-unit id="8a80d77f1956af42d7d1e58a2096c01b4786f98a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;pow()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.pow()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; has no constructor).</source>
          <target state="translated">때문에 &lt;code&gt;pow()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.pow()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자가 없습니다).</target>
        </trans-unit>
        <trans-unit id="173e452c64721d1ef540c6145ebf7e4c90e4c6e4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;pow()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.pow()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; has no constructor). If the base is negative and the exponent is not an integer, the result is NaN.</source>
          <target state="translated">&lt;code&gt;pow()&lt;/code&gt; 는 &lt;code&gt;Math&lt;/code&gt; 의 정적 메서드 이기 때문에 생성 한 &lt;code&gt;Math&lt;/code&gt; 객체 의 메서드가 아닌 항상 &lt;code&gt;Math.pow()&lt;/code&gt; 로 사용합니다 ( &lt;code&gt;Math&lt;/code&gt; 에는 생성자가 없음). 밑이 음수이고 지수가 정수가 아닌 경우 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="de9f67058c4fe9ab68863945bdf1f1f9fd637f13" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;round()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.round()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; has no constructor).</source>
          <target state="translated">때문에 &lt;code&gt;round()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.round()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자가 없습니다).</target>
        </trans-unit>
        <trans-unit id="17c60362cae5bfd6dcbd5b5c30746edb43c3f633" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;sign()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.sign()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;sign()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.sign()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="a98e1606f6da2fede2d7644872da386e2f311bbb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;sin()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.sin()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;sin()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.sin()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="d397c84b8315649a9cf478375d3f01829dad94d0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;sinh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.sinh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;sinh()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.sinh()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="372e97a5361f71355eab20c306344aad5abea7fb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;sqrt()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.sqrt()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;sqrt()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.sqrt()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="b2bffdc67853a6649c3a6b0f0e3fba320e583173" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;tan()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.tan()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;tan()&lt;/code&gt; 의 정적 방법이다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.tan()&lt;/code&gt; 보다는의 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="30244635651b5dba22a6f60b570c933ced1b0c92" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;tanh()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.tanh()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;tanh()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.tanh()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="d3eef51281b9d3788e8242b114a41ca29e195be9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;trunc()&lt;/code&gt; is a static method of &lt;code&gt;Math&lt;/code&gt;, you always use it as &lt;code&gt;Math.trunc()&lt;/code&gt;, rather than as a method of a &lt;code&gt;Math&lt;/code&gt; object you created (&lt;code&gt;Math&lt;/code&gt; is not a constructor).</source>
          <target state="translated">때문에 &lt;code&gt;trunc()&lt;/code&gt; 의 정적 방법입니다 &lt;code&gt;Math&lt;/code&gt; , 당신은 항상로 사용 &lt;code&gt;Math.trunc()&lt;/code&gt; ,가 아닌 방법으로 &lt;code&gt;Math&lt;/code&gt; 만든 객체 ( &lt;code&gt;Math&lt;/code&gt; 생성자 아니다).</target>
        </trans-unit>
        <trans-unit id="53aa7796acbc86b1404a9e2d8c7392875eb591a9" translate="yes" xml:space="preserve">
          <source>Because JavaScript does not currently include standard support for 64-bit integer values, &lt;code&gt;DataView&lt;/code&gt; does not offer native 64-bit operations. As a workaround, you could implement your own &lt;code&gt;getUint64()&lt;/code&gt; function to obtain a value with precision up to &lt;a href=&quot;number/max_safe_integer&quot;&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;&lt;/a&gt;, which could suffice for certain cases.</source>
          <target state="translated">JavaScript는 현재 64 비트 정수 값에 대한 표준 지원을 포함하지 않기 때문에 &lt;code&gt;DataView&lt;/code&gt; 는 기본 64 비트 작업을 제공하지 않습니다. 해결 방법으로 고유 한 &lt;code&gt;getUint64()&lt;/code&gt; 함수를 구현하여 특정 경우에 충분할 수있는 &lt;a href=&quot;number/max_safe_integer&quot;&gt; &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; &lt;/a&gt; 까지의 정밀도로 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5ce40564816fc1649df79ceab1927c7ff224088" translate="yes" xml:space="preserve">
          <source>Because JavaScript does not currently include standard support for 64-bit integer values, &lt;code&gt;DataView&lt;/code&gt; does not offer native 64-bit operations. As a workaround, you could implement your own getUint64() method to obtain a value with precision up to &lt;a href=&quot;number/max_safe_integer&quot;&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;&lt;/a&gt;, which could suffice for certain cases.</source>
          <target state="translated">JavaScript에는 현재 64 비트 정수 값에 대한 표준 지원이 포함되어 있지 않으므로 &lt;code&gt;DataView&lt;/code&gt; 는 기본 64 비트 작업을 제공하지 않습니다. 이 문제를 해결하려면 고유 한 getUint64 () 메소드를 구현하여 &lt;a href=&quot;number/max_safe_integer&quot;&gt; &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; &lt;/a&gt; 까지의 정밀도 로 특정 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dcff0e7da27e1a1a10c94b6367a79326f02b8b9" translate="yes" xml:space="preserve">
          <source>Because coercing between &lt;a href=&quot;number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;BigInt&lt;/code&gt; can lead to loss of precision, it is recommended to only use &lt;code&gt;BigInt&lt;/code&gt; when values greater than 2&lt;sup&gt;53&lt;/sup&gt; are reasonably expected and not to coerce between the two types.</source>
          <target state="translated">&lt;a href=&quot;number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;BigInt&lt;/code&gt; 간의 강제 변환 은 정밀도 손실로 이어질 수 있으므로 2 &lt;sup&gt;53&lt;/sup&gt; 보다 큰 값 이 합리적으로 예상되고 두 유형간에 강제 변환되지 않는 경우 에만 &lt;code&gt;BigInt&lt;/code&gt; 를 사용하는 것이 좋습니다 .&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="69c444e974b0711efc78517b5a1232f2bfd599d1" translate="yes" xml:space="preserve">
          <source>Because each value in the &lt;code&gt;Set&lt;/code&gt; has to be unique, the value equality will be checked. In an earlier version of ECMAScript specification, this was not based on the same algorithm as the one used in the &lt;code&gt;===&lt;/code&gt; operator. Specifically, for &lt;code&gt;Set&lt;/code&gt;s, &lt;code&gt;+0&lt;/code&gt; (which is strictly equal to &lt;code&gt;-0&lt;/code&gt;) and &lt;code&gt;-0&lt;/code&gt; were different values. However, this was changed in the ECMAScript 2015 specification. See &lt;em&gt;&quot;Key equality for -0 and 0&quot;&lt;/em&gt; in the &lt;a href=&quot;#Browser_compatibility&quot;&gt;browser compatibility&lt;/a&gt; table for details.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 각 값은 고유해야하므로 값이 같은지 확인합니다. 이전 버전의 ECMAScript 사양에서는 &lt;code&gt;===&lt;/code&gt; 연산자에 사용 된 것과 동일한 알고리즘을 기반으로하지 않았습니다 . 특히 &lt;code&gt;Set&lt;/code&gt; 의 경우 &lt;code&gt;+0&lt;/code&gt; ( &lt;code&gt;-0&lt;/code&gt; 과 동일 함 )과 &lt;code&gt;-0&lt;/code&gt; 은 서로 다른 값이었습니다. 그러나 이것은 ECMAScript 2015 사양에서 변경되었습니다. 자세한 내용 은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 표 에서 &lt;em&gt;&quot;-0 및 0의 키 동일성&quot;&lt;/em&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c20a9cfdd69df242b88e730600c7db46b22fe86f" translate="yes" xml:space="preserve">
          <source>Because each value in the Set has to be unique, the value equality will be checked. In an earlier version of ECMAScript specification, this was not based on the same algorithm as the one used in the === operator. Specifically, for &lt;code&gt;Set&lt;/code&gt;s, &lt;code&gt;+0&lt;/code&gt; (which is strictly equal to &lt;code&gt;-0&lt;/code&gt;) and &lt;code&gt;-0&lt;/code&gt; were different values. However, this was changed in the ECMAScript 2015 specification. See &quot;Value equality for -0 and 0&quot; in the &lt;a href=&quot;#Browser_compatibility&quot;&gt;browser compatibility&lt;/a&gt; table for details.</source>
          <target state="translated">세트의 각 값은 고유해야하므로 값이 같은지 확인합니다. ECMAScript 사양의 이전 버전에서는 === 연산자에 사용 된 것과 동일한 알고리즘을 기반으로하지 않았습니다. 특히 &lt;code&gt;Set&lt;/code&gt; 의 경우 &lt;code&gt;+0&lt;/code&gt; (엄격히 &lt;code&gt;-0&lt;/code&gt; )과 &lt;code&gt;-0&lt;/code&gt; 은 다른 값이었습니다. 그러나 이것은 ECMAScript 2015 사양에서 변경되었습니다. 자세한 내용은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 표 에서 &quot;-0과 0의 값 평등&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1fded9ba75595ca39290a957e0bae450c1108c6" translate="yes" xml:space="preserve">
          <source>Because of references being weak, &lt;code&gt;WeakMap&lt;/code&gt; keys are not enumerable (i.e. there is no method giving you a list of the keys). If they were, the list would depend on the state of garbage collection, introducing non-determinism. If you want to have a list of keys, you should use a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참조가 약하기 때문에 &lt;code&gt;WeakMap&lt;/code&gt; 키는 열거 할 수 없습니다 (즉, 키 목록을 제공하는 방법이 없습니다). 만약 그렇다면, 목록은 비결정론을 도입하여 가비지 콜렉션의 상태에 따라 결정됩니다. 키 목록을 원하면 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb652a847f513489449cba9cb7f59972b1464b30" translate="yes" xml:space="preserve">
          <source>Because of the variances in parsing of date strings, it is recommended to always manually parse strings as results are inconsistent, especially across different ECMAScript implementations where strings like &lt;code&gt;&quot;2015-10-12 12:00:00&quot;&lt;/code&gt; may be parsed to as &lt;code&gt;NaN&lt;/code&gt;, UTC or local timezone.</source>
          <target state="translated">날짜 문자열 구문 분석의 차이로 인해 결과가 일치하지 않을 때, 특히 &lt;code&gt;&quot;2015-10-12 12:00:00&quot;&lt;/code&gt; 과 같은 문자열 을 &lt;code&gt;NaN&lt;/code&gt; 으로 구문 분석 할 수있는 다른 ECMAScript 구현에서 문자열을 항상 수동으로 구문 분석하는 것이 좋습니다 . UTC 또는 현지 시간대.</target>
        </trans-unit>
        <trans-unit id="db1f1a95df83f9cfc159023a1630ca2b35b2c638" translate="yes" xml:space="preserve">
          <source>Because of these three differences, failure to declare variables will very likely lead to unexpected results. Thus &lt;strong&gt;it is recommended to always declare variables, regardless of whether they are in a function or global scope.&lt;/strong&gt; And in ECMAScript 5 &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, assigning to an undeclared variable throws an error.</source>
          <target state="translated">이 세 가지 차이점 때문에 변수를 선언하지 않으면 예기치 않은 결과가 발생할 가능성이 큽니다. 따라서 &lt;strong&gt;변수가 함수 또는 전역 범위인지 여부에 관계없이 항상 변수를 선언하는 것이 좋습니다. &lt;/strong&gt;ECMAScript 5 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 선언되지 않은 변수에 할당하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0e35cb376ac0f59af1af4e600f13bf7c337eb9e" translate="yes" xml:space="preserve">
          <source>Because of this, in order to examine (or reproduce) the full character for individual character values of &lt;code&gt;65536&lt;/code&gt; or greater, for such characters, it is necessary to retrieve not only &lt;code&gt;charCodeAt(&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt;, but also &lt;code&gt;charCodeAt(&lt;var&gt;i&lt;/var&gt;+1)&lt;/code&gt; (as if manipulating a string with two letters), or to use &lt;code&gt;codePointAt(&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt; instead. See examples 2 and 3 (below).</source>
          <target state="translated">이 때문에 순서대로 검사 (또는 재현)의 개별 문자 값의 전체 문자 &lt;code&gt;65536&lt;/code&gt; 이상은, 같은 문자,뿐만 아니라 검색 할 필요가 &lt;code&gt;charCodeAt(&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt; 뿐만 아니라, &lt;code&gt;charCodeAt(&lt;var&gt;i&lt;/var&gt;+1)&lt;/code&gt; 로 ( 두 글자로 문자열을 조작하는 경우) 또는 대신 &lt;code&gt;codePointAt(&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt; 사용합니다. 예 2 및 3 (아래)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4dc9e30827c38b33a9bd89036ccdc332bcc2662" translate="yes" xml:space="preserve">
          <source>Because older browsers are generally also slower browsers, it is far more critical than most people recognize to create performance polyfills to make the browsing experience in outdated browsers slightly less horrible.</source>
          <target state="translated">구형 브라우저는 일반적으로 느린 브라우저이기 때문에, 구형 브라우저에서 브라우징 경험을 약간 덜 끔찍하게 만들기 위해 성능 폴리 필을 만드는 것이 대부분의 사람들이 인식하는 것보다 훨씬 더 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4bb7ef7b8fd64ccc09bf1a82f2ef249678defa0d" translate="yes" xml:space="preserve">
          <source>Because some numbers include the &lt;code&gt;e&lt;/code&gt; character in their string representation (e.g. &lt;code&gt;6.022e23&lt;/code&gt;), using &lt;code&gt;parseInt&lt;/code&gt; to truncate numeric values will produce unexpected results when used on very large or very small numbers. &lt;code&gt;parseInt&lt;/code&gt; should not be used as a substitute for &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 숫자는 문자열 표현에 &lt;code&gt;e&lt;/code&gt; 문자를 포함하므로 (예 : &lt;code&gt;6.022e23&lt;/code&gt; ) &lt;code&gt;parseInt&lt;/code&gt; 를 사용하여 숫자 값을 자르면 매우 크거나 작은 숫자에 사용할 때 예기치 않은 결과가 발생합니다. &lt;code&gt;parseInt&lt;/code&gt; 를 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="19a4700dffa9ea6423afda27d38271425bf4ded4" translate="yes" xml:space="preserve">
          <source>Because some numbers use the &lt;code&gt;e&lt;/code&gt; character in their string representation (e.g. &lt;code&gt;6.022e23&lt;/code&gt; for 6.022 &amp;times; 10&lt;sup&gt;23&lt;/sup&gt;), using &lt;code&gt;parseInt&lt;/code&gt; to truncate numbers will produce unexpected results when used on very large or very small numbers. &lt;code&gt;parseInt&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be used as a substitute for &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 숫자 는 문자열 표현에 &lt;code&gt;e&lt;/code&gt; 문자를 사용하기 때문에 (예 : 6.022 &amp;times; 10 &lt;sup&gt;23의 경우 &lt;/sup&gt; &lt;code&gt;6.022e23&lt;/code&gt; ) &lt;code&gt;parseInt&lt;/code&gt; 를 사용하여 숫자를 자르면 매우 크거나 아주 작은 숫자에 사용될 때 예기치 않은 결과가 생성됩니다. &lt;code&gt;parseInt&lt;/code&gt; 는 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; .&lt;sup&gt;&lt;/sup&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d20de304942bae9b22b7814302f926fb3ecafa2" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;Math.tan()&lt;/code&gt; function accepts radians, but it is often easier to work with degrees, the following function accepts a value in degrees, converts it to radians and returns the tangent.</source>
          <target state="translated">때문에 &lt;code&gt;Math.tan()&lt;/code&gt; 함수는 라디안을 허용하지만 학위를 가진 일에 종종 쉽게, 다음 함수는 라디안 변환을, 각도 값을 받아 탄젠트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b8dc76b38cfe7796676c8492b5362ea45614e08" translate="yes" xml:space="preserve">
          <source>Because the handler is empty, this proxy behaves just like the original target:</source>
          <target state="translated">핸들러가 비어 있기 때문에이 프록시는 원래 대상처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1d2baf8a9799699735ddc9e7f897328da1c9244e" translate="yes" xml:space="preserve">
          <source>Because the order of iteration is implementation-dependent, iterating over an array may not visit elements in a consistent order. Therefore, it is better to use a &lt;a href=&quot;for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop with a numeric index (or &lt;a href=&quot;../global_objects/array/foreach&quot;&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; loop) when iterating over arrays where the order of access is important.</source>
          <target state="translated">반복 순서는 구현에 따라 다르므로 배열을 반복하면 요소를 일관된 순서로 방문하지 않을 수 있습니다. 따라서 액세스 순서가 중요한 배열을 반복 할 때는 숫자 인덱스 (또는 &lt;a href=&quot;../global_objects/array/foreach&quot;&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; 루프) 와 함께 &lt;a href=&quot;for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4281d9845fae6b6d0dce14f1297972fc4b1d4319" translate="yes" xml:space="preserve">
          <source>Because there is no &quot;+&quot; operator to concatenate the string, JavaScript expects the argument for the &lt;code&gt;log&lt;/code&gt; function to be just &lt;code&gt;&quot;PI: &quot;&lt;/code&gt;. In that case, it should be terminated by a closing parenthesis.</source>
          <target state="translated">문자열을 연결하는 &quot;+&quot;연산자가 없기 때문에 JavaScript는 &lt;code&gt;log&lt;/code&gt; 함수 의 인수가 &lt;code&gt;&quot;PI: &quot;&lt;/code&gt; 일 것으로 예상합니다 . 이 경우 닫는 괄호로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="4fa36743099fb41e622047846221819607dcb74a" translate="yes" xml:space="preserve">
          <source>Because this feature is a part of the language, it is still the burden on engine developers to implement that feature performantly (ideally). Until engine developers address this issue, if you are concerned about performance, you should avoid setting the &lt;code&gt;[[Prototype]]&lt;/code&gt; of an object. Instead, create a new object with the desired &lt;code&gt;[[Prototype]]&lt;/code&gt; using &lt;a href=&quot;create&quot;&gt;&lt;code&gt;Object.create()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 언어의 일부이기 때문에 해당 기능을 (이상적으로) 성능있게 구현하는 것은 여전히 ​​엔진 개발자의 부담입니다. 엔진 개발자가이 문제를 해결할 때까지 성능이 염려된다면 개체 의 &lt;code&gt;[[Prototype]]&lt;/code&gt; 설정을 피해야 합니다. 대신 &lt;a href=&quot;create&quot;&gt; &lt;code&gt;Object.create()&lt;/code&gt; &lt;/a&gt; 사용하여 원하는 &lt;code&gt;[[Prototype]]&lt;/code&gt; 으로 새 개체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="603f4e4965885c0d0b4786f6777af45a20fc2100" translate="yes" xml:space="preserve">
          <source>Because variable declarations (and declarations in general) are processed before any code is executed, declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called &quot;</source>
          <target state="translated">변수 선언 (및 일반적으로 선언)은 코드가 실행되기 전에 처리되기 때문에 코드에서 변수를 선언하는 것은 맨 위에서 선언하는 것과 같습니다. 이것은 또한 변수가 선언되기 전에 사용 된 것처럼 보일 수 있음을 의미합니다. 이 동작을 &quot;</target>
        </trans-unit>
        <trans-unit id="dc95003644b4ff30716b50875dcd9e7875b16289" translate="yes" xml:space="preserve">
          <source>Because variable declarations (and declarations in general) are processed before any code is executed, declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called &quot;hoisting&quot;, as it appears that the variable declaration is moved to the top of the function or global code.</source>
          <target state="translated">변수 선언 (및 일반적 선언)은 코드가 실행되기 전에 처리되므로 코드의 어느 곳에서나 변수를 선언하는 것은 맨 위에 선언하는 것과 같습니다. 이것은 또한 변수가 선언되기 전에 사용되는 것처럼 보일 수 있음을 의미합니다. 변수 선언이 함수 또는 전역 코드의 맨 위로 이동 한 것으로 보이므로이 동작을 &quot;게양&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="2abcf792e9e27d8dafb82479f92f8a86c66adb6f" translate="yes" xml:space="preserve">
          <source>Because we want to further transform the &lt;em&gt;result&lt;/em&gt; of the match before the final substitution is made, we must use a function. This forces the evaluation of the match prior to the &lt;a href=&quot;tolowercase&quot;&gt;&lt;code&gt;toLowerCase()&lt;/code&gt;&lt;/a&gt; method. If we had tried to do this using the match without a function, the &lt;a href=&quot;tolowercase&quot;&gt;&lt;code&gt;toLowerCase()&lt;/code&gt;&lt;/a&gt; would have no effect.</source>
          <target state="translated">최종 대체가 이루어지기 전에 일치 하는 &lt;em&gt;결과&lt;/em&gt; 를 추가로 변환하려면 함수를 사용해야합니다. 그러면 &lt;a href=&quot;tolowercase&quot;&gt; &lt;code&gt;toLowerCase()&lt;/code&gt; &lt;/a&gt; 메소드 이전에 일치 평가가 수행 됩니다. 함수없이 일치를 사용하여이 작업을 시도한 경우 &lt;a href=&quot;tolowercase&quot;&gt; &lt;code&gt;toLowerCase()&lt;/code&gt; &lt;/a&gt; 는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6ae924cc0de1fac266b0475d2bc8a29c06258cf" translate="yes" xml:space="preserve">
          <source>Been formally correct it suffers from a number of issues related to floating point computations. Accurate result requires special handling of positive/negative, small/large arguments as it done e.g. in &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/ieee754/dbl-64/s_asinh.c&quot;&gt;glibc&lt;/a&gt; or &lt;a href=&quot;http://git.savannah.gnu.org/cgit/gsl.git/tree/sys/invhyp.c&quot;&gt;GNU Scientific Library&lt;/a&gt;.</source>
          <target state="translated">공식적으로 수정되었으므로 부동 소수점 계산과 관련된 많은 문제가 발생합니다. 정확한 결과를 위해서는 예를 들어 &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/ieee754/dbl-64/s_asinh.c&quot;&gt;glibc&lt;/a&gt; 또는 &lt;a href=&quot;http://git.savannah.gnu.org/cgit/gsl.git/tree/sys/invhyp.c&quot;&gt;GNU Scientific Library&lt;/a&gt; 와 같이 긍정적 / 부정적 / 작거나 큰 인수를 특수하게 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="159644552db2acc7dd9b689cc5dc2eaa6ac55f74" translate="yes" xml:space="preserve">
          <source>Before ECMAScript 2015, &lt;code&gt;typeof&lt;/code&gt; was always guaranteed to return a string for any operand it was supplied with. Even with undeclared identifiers, &lt;code&gt;typeof&lt;/code&gt; will return &lt;code&gt;'undefined'&lt;/code&gt;. Using &lt;code&gt;typeof&lt;/code&gt; could never generate an error.</source>
          <target state="translated">ECMAScript 2015 이전에는 &lt;code&gt;typeof&lt;/code&gt; 는 항상 제공된 피연산자에 대한 문자열을 반환하도록 보장되었습니다. 선언되지 않은 식별자를 사용하더라도 &lt;code&gt;typeof&lt;/code&gt; 는 &lt;code&gt;'undefined'&lt;/code&gt; 를 반환 합니다. &lt;code&gt;typeof&lt;/code&gt; 를 사용 하면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55091dd1c45efd77c4be5bc4d41fc309633f94a4" translate="yes" xml:space="preserve">
          <source>Before Edge 18, numbers are rounded to 15 decimal digits. For example, &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; returns &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt;.</source>
          <target state="translated">Edge 18 이전에는 숫자가 십진수 15 자리로 반올림됩니다. 예를 들어 &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; 는 &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="44bb71e3409e753a6606887905ef5a4c30abff4e" translate="yes" xml:space="preserve">
          <source>Before Edge 18, numbers are rounded to 15 decimal digits. For example, &lt;code&gt;new Intl.NumberFormat('en-US').format(1000000000000005)&lt;/code&gt; returns &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt;.</source>
          <target state="translated">Edge 18 이전에는 숫자가 십진수 15 자리로 반올림됩니다. 예를 들어 &lt;code&gt;new Intl.NumberFormat('en-US').format(1000000000000005)&lt;/code&gt; 은 &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="454d1992dff79b418d7f489ef534bb31be6404ea" translate="yes" xml:space="preserve">
          <source>Before version 12.0.0, &lt;code&gt;formatToParts()&lt;/code&gt; returned an object with an incorrectly cased type key of &lt;code&gt;dayperiod&lt;/code&gt;. Version 12.0.0 and later use the specification defined &lt;code&gt;dayPeriod&lt;/code&gt;. See &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium bug 865351&lt;/a&gt;.</source>
          <target state="translated">버전 12.0.0 이전에는 &lt;code&gt;formatToParts()&lt;/code&gt; 대소 문자 가 잘못 &lt;code&gt;dayperiod&lt;/code&gt; 유형 키가 dayperiod 인 객체를 반환했습니다 . 버전 12.0.0 이상에서는 정의 된 &lt;code&gt;dayPeriod&lt;/code&gt; 사양을 사용합니다 . &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium 버그 865351을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8256a9242be184b84e484474da214718a6118e5a" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator/Collator&quot;&gt;the &lt;code&gt;Collator()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator/Collator&quot;&gt;은 &lt;code&gt;Collator()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="962a2ad2b18607490c51c4d5b622a533c2c94ec9" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat&quot;&gt;the &lt;code&gt;DateTimeFormat()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat&quot;&gt;은 &lt;code&gt;DateTimeFormat()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2db5edee86ad1fa7add680ac3ed5c30cc5ad7de3" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat&quot;&gt;the &lt;code&gt;ListFormat()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/ListFormat&quot;&gt;은 &lt;code&gt;ListFormat()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3bb5b68af13f14fe777adc7b2edbfd32ea0cac7" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/Locale&quot;&gt;the &lt;code&gt;Locale()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale/Locale&quot;&gt;은 &lt;code&gt;Locale()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d196043c4a8c8fdc06465fb5c3e4d6b429765af3" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat&quot;&gt;the &lt;code&gt;NumberFormat()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat&quot;&gt;은 &lt;code&gt;NumberFormat()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e77eae32ad4859d20aeefd5755ecfea676e18fc9" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules/PluralRules&quot;&gt;the &lt;code&gt;PluralRules()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/PluralRules/PluralRules&quot;&gt;은 &lt;code&gt;PluralRules()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3d420e773551fa06a48acaa68ddd45ad37625769" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. See &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat&quot;&gt;the &lt;code&gt;RelativeTimeFormat()&lt;/code&gt; constructor&lt;/a&gt; for more details.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Intl/RelativeTimeFormat/RelativeTimeFormat&quot;&gt;은 &lt;code&gt;RelativeTimeFormat()&lt;/code&gt; 생성자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ed73dbd0153424ac30eadd3079e884fa0594805" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abe865f49c9942b1e6cb6a7f54fdde7784d327bb" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;Collator&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;Collator&lt;/code&gt; 인스턴스가 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 폴백 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="274cc86ec69f538670925df17205c4da54fbf895" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;DateTimeFormat&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;DateTimeFormat&lt;/code&gt; 인스턴스가 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4847f861c63545ad43e69129f441b955f04ce81b" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;Intl&lt;/code&gt; APIs silently fall back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;Intl&lt;/code&gt; API가 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="615867ceacb9975d71b882ea137ec7b2470db5c8" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;ListFormat&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;ListFormat&lt;/code&gt; 인스턴스는 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34487a5a0c1c9d87a4331f009ac61ec2cce4923a" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;Locale&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;Locale&lt;/code&gt; 인스턴스는 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df988861a9b2a99393fe63487d544af7ae95adf" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;NumberFormat&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;NumberFormat&lt;/code&gt; 인스턴스는 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="673f255febdf8da85817d7c318f5f62dc45c152c" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;PluralRules&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;PluralRules&lt;/code&gt; 인스턴스가 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="181a2ebe804d44c148d6530e917652c19361eccc" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the &lt;code&gt;RelativeTimeFormat&lt;/code&gt; instance silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 의 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면 &lt;code&gt;RelativeTimeFormat&lt;/code&gt; 인스턴스가 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3993bc53a1d1460ac1d88aa64eb530fe29dee19" translate="yes" xml:space="preserve">
          <source>Before version 13.0.0, only the locale data for &lt;code&gt;en-US&lt;/code&gt; is available by default. When other locales are specified, the function silently falls back to &lt;code&gt;en-US&lt;/code&gt;. To make full ICU (locale) data available for versions prior to 13, see &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;Node.js documentation on the &lt;code&gt;--with-intl&lt;/code&gt; option&lt;/a&gt; and how to provide the data.</source>
          <target state="translated">버전 13.0.0 이전 에는 기본적으로 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터 만 사용할 수 있습니다. 다른 로케일이 지정되면이 함수는 자동으로 &lt;code&gt;en-US&lt;/code&gt; 로 대체 됩니다. 13 이전 버전에서 전체 ICU (로케일) 데이터를 사용할 수 있도록 &lt;a href=&quot;https://nodejs.org/docs/latest/api/intl.html#intl_options_for_building_node_js&quot;&gt;하려면 &lt;code&gt;--with-intl&lt;/code&gt; 옵션&lt;/a&gt; 및 데이터 제공 방법에 대한 Node.js 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="338c199868d5bf041754fcf6aec6c63ec759fc67" translate="yes" xml:space="preserve">
          <source>Before version 50, &lt;code&gt;formatToParts()&lt;/code&gt; returned an object with an incorrectly cased type key of &lt;code&gt;dayperiod&lt;/code&gt;. Version 50 and later use the specification defined &lt;code&gt;dayPeriod&lt;/code&gt;. See &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium bug 865351&lt;/a&gt;.</source>
          <target state="translated">버전 50 이전에는 &lt;code&gt;formatToParts()&lt;/code&gt; 에서 &lt;code&gt;dayperiod&lt;/code&gt; 가 잘못 지정된 유형 키 dayperiod가 있는 객체를 반환했습니다 . 버전 50 이상은 &lt;code&gt;dayPeriod&lt;/code&gt; 정의 된 사양을 사용합니다 . &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium 버그 865351을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="818d878908922152ebba17bb2253e441c6960cf9" translate="yes" xml:space="preserve">
          <source>Before version 58, &lt;code&gt;formatToParts()&lt;/code&gt; returned an object with an incorrectly cased type key of &lt;code&gt;dayperiod&lt;/code&gt;. Version 58 and later use the specification defined &lt;code&gt;dayPeriod&lt;/code&gt;. See &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium bug 865351&lt;/a&gt;.</source>
          <target state="translated">버전 58 이전에는 &lt;code&gt;formatToParts()&lt;/code&gt; 에서 &lt;code&gt;dayperiod&lt;/code&gt; 가 잘못 지정된 유형 키 dayperiod가 있는 객체를 반환했습니다 . 버전 58 이상은 &lt;code&gt;dayPeriod&lt;/code&gt; 정의 된 사양을 사용합니다 . &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium 버그 865351을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="075f9144781d3e998c01764134b1204b37d21724" translate="yes" xml:space="preserve">
          <source>Before version 71, &lt;code&gt;formatToParts()&lt;/code&gt; returned an object with an incorrectly cased type key of &lt;code&gt;dayperiod&lt;/code&gt;. Version 71 and later use the specification defined &lt;code&gt;dayPeriod&lt;/code&gt;. See &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium bug 865351&lt;/a&gt;.</source>
          <target state="translated">버전 71 이전에는 &lt;code&gt;formatToParts()&lt;/code&gt; 에서 &lt;code&gt;dayperiod&lt;/code&gt; 가 잘못 지정된 유형 키 dayperiod가 있는 객체를 반환했습니다 . 버전 71 이상에서는 &lt;code&gt;dayPeriod&lt;/code&gt; 정의 된 사양을 사용합니다 . &lt;a href=&quot;https://crbug.com/865351&quot;&gt;Chromium 버그 865351을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7b060e5d9198be1ddfe36f7dfa9b43b5da1e057" translate="yes" xml:space="preserve">
          <source>Behavior in JavaScript 1.2 and earlier</source>
          <target state="translated">JavaScript 1.2 및 이전 버전의 동작</target>
        </trans-unit>
        <trans-unit id="d75a7b56c05bb5521d3f28fbe0024c97cf4e0458" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;Math.abs()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Math.abs()&lt;/code&gt; 동작</target>
        </trans-unit>
        <trans-unit id="030746620683a06e6082bbc1c67e2963a3b93e9c" translate="yes" xml:space="preserve">
          <source>Behavior of Math.abs()</source>
          <target state="translated">Math.abs ()의 동작</target>
        </trans-unit>
        <trans-unit id="0f0f67845acd5aa1522ca81da8b0ea866ee05f97" translate="yes" xml:space="preserve">
          <source>Below is a table with the available collation types, taken from the &lt;a href=&quot;https://github.com/unicode-org/cldr/blob/2dd06669d833823e26872f249aa304bc9d9d2a90/common/bcp47/collation.xml&quot;&gt;Unicode collation specification&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;https://github.com/unicode-org/cldr/blob/2dd06669d833823e26872f249aa304bc9d9d2a90/common/bcp47/collation.xml&quot;&gt;유니 코드 데이터 정렬 사양&lt;/a&gt; 에서 가져온 사용 가능한 데이터 정렬 유형이있는 표입니다 .</target>
        </trans-unit>
        <trans-unit id="baa70661bdbd1c409645a470f04d8aa9be63099c" translate="yes" xml:space="preserve">
          <source>Below is an example of how to use &lt;code&gt;Object.create()&lt;/code&gt; to achieve classical inheritance. This is for a single inheritance, which is all that JavaScript supports.</source>
          <target state="translated">다음은 &lt;code&gt;Object.create()&lt;/code&gt; 를 사용 하여 고전적인 상속을 달성 하는 방법의 예입니다 . 이것은 JavaScript가 지원하는 모든 단일 상속을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="51f92d6f7fd65c8ad04ba8889f67557332d328c6" translate="yes" xml:space="preserve">
          <source>Below is an example of how to use &lt;code&gt;Object.create()&lt;/code&gt; to achieve classical inheritance. This is for single inheritance, which is all that JavaScript supports.</source>
          <target state="translated">아래는 &lt;code&gt;Object.create()&lt;/code&gt; 를 사용 하여 클래식 상속을 얻는 방법의 예입니다 . 이것은 단일 상속을위한 것으로 JavaScript가 지원하는 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cb1774d9020d13243cb4c0ad8b262714aec3bbb" translate="yes" xml:space="preserve">
          <source>Below, the third argument isn't provided, but &lt;code&gt;manyMoreArgs&lt;/code&gt; is still an array (albeit an empty one).</source>
          <target state="translated">아래에서 세 번째 인수는 제공되지 않지만 &lt;code&gt;manyMoreArgs&lt;/code&gt; 는 여전히 배열입니다 (비어 있더라도).</target>
        </trans-unit>
        <trans-unit id="c41b032a35727b00a30611f89e3948a0493d74fe" translate="yes" xml:space="preserve">
          <source>Below, you'll find a list of errors which are thrown by JavaScript. These errors can be a helpful debugging aid, but the reported problem isn't always immediately clear. The pages below will provide additional details about these errors. Each error is an object based upon the &lt;a href=&quot;global_objects/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, and has a &lt;code&gt;name&lt;/code&gt; and a &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">아래에는 JavaScript에서 발생하는 오류 목록이 있습니다. 이러한 오류는 디버깅에 도움이 될 수 있지만보고 된 문제가 항상 명확하지는 않습니다. 아래 페이지는 이러한 오류에 대한 추가 정보를 제공합니다. 각 오류는 &lt;a href=&quot;global_objects/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체를 기반으로하는 개체이며 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;message&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8202e0fab4410750ecb314be24a983994b26bd" translate="yes" xml:space="preserve">
          <source>Below... even though there is just one value, the last argument still gets put into an array.</source>
          <target state="translated">아래 ... 값이 하나만 있지만 마지막 인수는 여전히 배열에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="261185687d86dcc2558ac603bc22ba3f33059610" translate="yes" xml:space="preserve">
          <source>Below... the third argument wasn't provided, yet &quot;manyMoreArgs&quot; is still an array (although empty).</source>
          <target state="translated">아래 ... 세 번째 인수는 제공되지 않았지만 &quot;manyMoreArgs&quot;는 여전히 배열입니다 (비어 있지만).</target>
        </trans-unit>
        <trans-unit id="9d32fc114f5792d08dfd878d4c61b9978fcd1ab0" translate="yes" xml:space="preserve">
          <source>Bengali digits</source>
          <target state="translated">벵골 숫자</target>
        </trans-unit>
        <trans-unit id="20cd995d35d428b0741c03ebed037a0ac338a5c0" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;false&lt;/code&gt;, possible falsy expressions are: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/code&gt;, &lt;code&gt;&lt;code&gt;&lt;code&gt;0&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;, the empty string (&lt;code&gt;&lt;code&gt;&lt;code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;), and &lt;code&gt;&lt;code&gt;&lt;code&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is any of these, the result of the conditional expression will be &lt;code&gt;exprF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 외에도 가능한 허위 표현식은 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/code&gt; , &lt;code&gt;&lt;code&gt;&lt;code&gt;0&lt;/code&gt;&lt;/code&gt;&lt;/code&gt; , 빈 문자열 ( &lt;code&gt;&lt;code&gt;&lt;code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;code&gt;&lt;code&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/code&gt;&lt;/code&gt;&lt;/code&gt; 입니다. &lt;code&gt;condition&lt;/code&gt; 이 이들 중 하나 인 경우 조건식 의 결과는 &lt;code&gt;exprF&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b309977549c7b35f0463b03147736866c045ba81" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;false&lt;/code&gt;, possible falsy expressions are: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;), and &lt;code&gt;undefined&lt;/code&gt;. If &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; is any of these, the result of the conditional expression will be the result of executing the expression &lt;code&gt;exprIfFalse&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 외에 가능한 허위 표현식은 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ) 및 &lt;code&gt;undefined&lt;/code&gt; 입니다. &lt;code&gt;&lt;var&gt;condition&lt;/var&gt;&lt;/code&gt; 이 이들 중 하나 이면 조건식 의 결과는 &lt;code&gt;exprIfFalse&lt;/code&gt; 표현식을 실행 한 결과가 됩니다.</target>
        </trans-unit>
        <trans-unit id="8523ec8a82ebe573bcf2ecdd81f9704e7581a58f" translate="yes" xml:space="preserve">
          <source>Besides generator objects, &lt;code&gt;yield*&lt;/code&gt; can also &lt;code&gt;yield&lt;/code&gt; other kinds of iterables (e.g., arrays, strings, or &lt;a href=&quot;../functions/arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">생성기 객체 외에도 &lt;code&gt;yield*&lt;/code&gt; 는 다른 종류의 이터 러블 (예 : 배열, 문자열 또는 &lt;a href=&quot;../functions/arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 객체)을 &lt;code&gt;yield&lt;/code&gt; 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dd9d33fbffbae845ccc0b4876c531ee46de4cdc" translate="yes" xml:space="preserve">
          <source>Besides generator objects, &lt;code&gt;yield*&lt;/code&gt; can also &lt;code&gt;yield&lt;/code&gt; other kinds of iterables, e.g. arrays, strings or arguments objects.</source>
          <target state="translated">발전기 오브젝트 외에, &lt;code&gt;yield*&lt;/code&gt; 도 수 &lt;code&gt;yield&lt;/code&gt; 예를 들어 배열의 반복 가능 객체, 문자열이나 인수 객체의 다른 종류.</target>
        </trans-unit>
        <trans-unit id="9e6eafdf023657a3fd3a8b11636254d4fad58147" translate="yes" xml:space="preserve">
          <source>Besides regular, printable characters, special characters can be encoded using escape notation:</source>
          <target state="translated">인쇄 가능한 일반 문자 외에도 특수 문자는 이스케이프 표기법을 사용하여 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8fb1122f77fe0ba01680d6e22b4baf1b576598" translate="yes" xml:space="preserve">
          <source>Besides the generic &lt;code&gt;Error&lt;/code&gt; constructor, there are other core error constructors in JavaScript. For client-side exceptions, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Statements#Exception_handling_statements&quot;&gt;Exception handling statements&lt;/a&gt;.</source>
          <target state="translated">일반 &lt;code&gt;Error&lt;/code&gt; 생성자 외에도 JavaScript에는 다른 핵심 오류 생성자가 있습니다. 클라이언트 측 예외에 대해서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Statements#Exception_handling_statements&quot;&gt;예외 처리 문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c2e151a3cc5d7777c01be8bc72c029402798cc" translate="yes" xml:space="preserve">
          <source>Besides the generic &lt;code&gt;Error&lt;/code&gt; constructor, there are seven other core error constructors in JavaScript. For client-side exceptions, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Statements#Exception_handling_statements&quot;&gt;Exception handling statements&lt;/a&gt;.</source>
          <target state="translated">일반적인 &lt;code&gt;Error&lt;/code&gt; 생성자 외에도 JavaScript에는 7 개의 다른 핵심 오류 생성자가 있습니다. 클라이언트 측 예외에 대해서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Statements#Exception_handling_statements&quot;&gt;예외 처리 명령문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="102f89978123850cb86b07c3efbc74877da7360e" translate="yes" xml:space="preserve">
          <source>Better access to capturing groups (than String.prototype.match())</source>
          <target state="translated">캡처 그룹에 대한 더 나은 액세스 (String.prototype.match ()보다)</target>
        </trans-unit>
        <trans-unit id="9771605fc0f821b322531f36410ed7ccf7f3b31a" translate="yes" xml:space="preserve">
          <source>Better code without &lt;code&gt;eval()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 없는 더 나은 코드 :</target>
        </trans-unit>
        <trans-unit id="77d11c5ac571ff07519a187888bdf11074258b69" translate="yes" xml:space="preserve">
          <source>Better code without eval:</source>
          <target state="translated">평가없이 더 나은 코드 :</target>
        </trans-unit>
        <trans-unit id="d9d539cd76ae701f0f3708222006d5c1b01546b8" translate="yes" xml:space="preserve">
          <source>Between the generator's code path, its &lt;code&gt;yield&lt;/code&gt; operators, and the ability to specify a new starting value by passing it to &lt;a href=&quot;../global_objects/generator/next&quot;&gt;&lt;code&gt;Generator.prototype.next()&lt;/code&gt;&lt;/a&gt;, generators offer enormous power and control.</source>
          <target state="translated">생성기의 코드 경로, &lt;code&gt;yield&lt;/code&gt; 연산자 및 &lt;a href=&quot;../global_objects/generator/next&quot;&gt; &lt;code&gt;Generator.prototype.next()&lt;/code&gt; &lt;/a&gt; 로 전달하여 새 시작 값을 지정하는 기능 사이 에서 생성기는 엄청난 힘과 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="145b964bad46a6b2a54ed42cfb4031205fa33575" translate="yes" xml:space="preserve">
          <source>Bhaiksuki digits</source>
          <target state="translated">Bhaiksuki 자리</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="9ec8edd65739efa3eaea12b2df2dafcba3bba456" translate="yes" xml:space="preserve">
          <source>BigInt literal</source>
          <target state="translated">BigInt 리터럴</target>
        </trans-unit>
        <trans-unit id="4856b08f1395bd7f7d60a226d59828b8fdd79069" translate="yes" xml:space="preserve">
          <source>BigInt.asIntN</source>
          <target state="translated">BigInt.asIntN</target>
        </trans-unit>
        <trans-unit id="a47bf8e1d5dd849d1b173fdc188c58baef781a36" translate="yes" xml:space="preserve">
          <source>BigInt.asUintN</source>
          <target state="translated">BigInt.asUintN</target>
        </trans-unit>
        <trans-unit id="62fb25d340a03121c6c0582c307214b7988b4c0d" translate="yes" xml:space="preserve">
          <source>BigInt.bigInt</source>
          <target state="translated">BigInt.bigInt</target>
        </trans-unit>
        <trans-unit id="d29e0a647197a8263e16300caaca898599312972" translate="yes" xml:space="preserve">
          <source>BigInt64Array</source>
          <target state="translated">BigInt64Array</target>
        </trans-unit>
        <trans-unit id="25807b53be7a683893c71c4fcf9ccd1ab2bd9504" translate="yes" xml:space="preserve">
          <source>BigInt64Array.bigInt64Array</source>
          <target state="translated">BigInt64Array.bigInt64Array</target>
        </trans-unit>
        <trans-unit id="ab3356a07e37aa82c9221734366ee9314805334d" translate="yes" xml:space="preserve">
          <source>BigUint64Array</source>
          <target state="translated">BigUint64Array</target>
        </trans-unit>
        <trans-unit id="db018a086b1c2e4d40892f6070f86848b2553c41" translate="yes" xml:space="preserve">
          <source>BigUint64Array.bigUint64Array</source>
          <target state="translated">BigUint64Array.bigUint64Array</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="a6ae5e739bb51d1efcd9ab02e0c4453257e53d13" translate="yes" xml:space="preserve">
          <source>Binary bitwise operators</source>
          <target state="translated">이진 비트 연산자</target>
        </trans-unit>
        <trans-unit id="83215e885168a982dedfb5f1ebc95225e2bf7474" translate="yes" xml:space="preserve">
          <source>Binary code point order (used in Hindi)</source>
          <target state="translated">바이너리 코드 포인트 순서 (힌디어로 사용됨)</target>
        </trans-unit>
        <trans-unit id="8756d89e35f765492208b16956608e9c330132ec" translate="yes" xml:space="preserve">
          <source>Binary logical operators</source>
          <target state="translated">이진 논리 연산자</target>
        </trans-unit>
        <trans-unit id="a7be905883f7d051cd0a22fef7a668ee621d2079" translate="yes" xml:space="preserve">
          <source>Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter &quot;B&quot; (&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;). Because this syntax is new in ECMAScript 2015, see the browser compatibility table, below. If the digits after the &lt;code&gt;0b&lt;/code&gt; are not 0 or 1, the following &lt;a href=&quot;global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; is thrown: &quot;Missing binary digits after 0b&quot;.</source>
          <target state="translated">이진 숫자 구문은 앞에 오는 0과 소문자 또는 대문자 라틴 문자 &quot;B&quot;( &lt;code&gt;0b&lt;/code&gt; 또는 &lt;code&gt;0B&lt;/code&gt; )를 사용합니다. 이 구문은 ECMAScript 2015의 새로운 기능이므로 아래의 브라우저 호환성 표를 참조하십시오. &lt;code&gt;0b&lt;/code&gt; 뒤의 숫자 가 0 또는 1이 아니면 다음 &lt;a href=&quot;global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &quot;0b 뒤에 2 진수 누락&quot;.</target>
        </trans-unit>
        <trans-unit id="2874efcc76cef8287eda56aabf4377e410abf486" translate="yes" xml:space="preserve">
          <source>Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter &quot;B&quot; (&lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;). Because this syntax is new in ECMAScript 2015, see the browser compatibility table, below. If the digits after the &lt;code&gt;0b&lt;/code&gt; are not 0 or 1, the following &lt;code&gt;&lt;a href=&quot;global_objects/syntaxerror&quot;&gt;SyntaxError&lt;/a&gt;&lt;/code&gt; is thrown: &quot;Missing binary digits after 0b&quot;.</source>
          <target state="translated">이진 숫자 구문은 선행 0과 소문자 또는 대문자 라틴 문자 &quot;B&quot;( &lt;code&gt;0b&lt;/code&gt; 또는 &lt;code&gt;0B&lt;/code&gt; )를 사용합니다. 이 구문은 ECMAScript 2015의 새로운 기능이므로 아래의 브라우저 호환성 표를 참조하십시오. &lt;code&gt;0b&lt;/code&gt; 뒤의 숫자 가 0 또는 1이 아닌 경우 다음 &lt;code&gt;&lt;a href=&quot;global_objects/syntaxerror&quot;&gt;SyntaxError&lt;/a&gt;&lt;/code&gt; 가 발생합니다. &quot;0b 뒤에 이진수가 누락되었습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="4a017cd979dca481c1cc4d0dba522bb792b6ec74" translate="yes" xml:space="preserve">
          <source>Binary numeric literals (&lt;code&gt;0b&lt;/code&gt;)</source>
          <target state="translated">이진 숫자 리터럴 ( &lt;code&gt;0b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4bdf2505c1f9ea6cd90d41762fb41d00a51b1117" translate="yes" xml:space="preserve">
          <source>Binary strings</source>
          <target state="translated">이진 문자열</target>
        </trans-unit>
        <trans-unit id="9f01c29a338dbfbd4129972247f2c426c77f6ed9" translate="yes" xml:space="preserve">
          <source>Binding &lt;code&gt;this&lt;/code&gt; with prototype and static methods</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 프로토 타입 및 정적 메서드와 바인딩</target>
        </trans-unit>
        <trans-unit id="76de4944f8b748c8a0e7daa5916ebaebf0eb3452" translate="yes" xml:space="preserve">
          <source>Binding can be done with the .&lt;code&gt;call&lt;/code&gt; function of &lt;a href=&quot;../function/prototype&quot;&gt;&lt;code&gt;Function.prototype&lt;/code&gt;&lt;/a&gt; and it can also be reduced using &lt;code&gt;[].slice.call(arguments)&lt;/code&gt; instead of &lt;code&gt;Array.prototype.slice.call&lt;/code&gt;. Anyway, it can be simplified using &lt;a href=&quot;../function/bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로 바인딩을 수행 할 수 있습니다. &lt;a href=&quot;../function/prototype&quot;&gt; &lt;code&gt;Function.prototype&lt;/code&gt; &lt;/a&gt; 의 함수를 &lt;code&gt;call&lt;/code&gt; 하고 &lt;code&gt;Array.prototype.slice.call&lt;/code&gt; 대신 &lt;code&gt;[].slice.call(arguments)&lt;/code&gt; 를 사용하여 줄일 수도 있습니다 . 어쨌든 &lt;a href=&quot;../function/bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; 를&lt;/a&gt; 사용하여 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33685dd0afcc1232eb1cd1adcb82fc4c2cfb09eb" translate="yes" xml:space="preserve">
          <source>Binding can be done with the &lt;a href=&quot;../function/call&quot;&gt;&lt;code&gt;call()&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function.prototype&lt;/code&gt;&lt;/a&gt; and it can also be reduced using &lt;code&gt;[].slice.call(arguments)&lt;/code&gt; instead of &lt;code&gt;Array.prototype.slice.call&lt;/code&gt;.</source>
          <target state="translated">바인딩은 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function.prototype&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../function/call&quot;&gt; &lt;code&gt;call()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 수행 할 수 있으며 &lt;code&gt;Array.prototype.slice.call&lt;/code&gt; 대신 &lt;code&gt;[].slice.call(arguments)&lt;/code&gt; 를 사용하여 줄일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="286ca3119c2dddb2961e31f60e4a3e163da17eae" translate="yes" xml:space="preserve">
          <source>Binds an object property to a function that will be called when that property is looked up.</source>
          <target state="translated">객체 속성을 해당 속성을 찾을 때 호출 될 함수에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="5e3a56716d36edae26cdf7ba11e2b0a7f1f03c0e" translate="yes" xml:space="preserve">
          <source>Binds an object property to a function to be called when there is an attempt to set that property.</source>
          <target state="translated">해당 속성을 설정하려고 할 때 호출 할 함수에 개체 속성을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="904b0e8a139eb9ff00c6255a632105837af7ed24" translate="yes" xml:space="preserve">
          <source>Bitwise AND (&lt;code&gt;a &amp;amp; b&lt;/code&gt;)</source>
          <target state="translated">비트 AND ( &lt;code&gt;a &amp;amp; b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="19157360058c50bbf65aa36c06fcf24282a48b35" translate="yes" xml:space="preserve">
          <source>Bitwise AND assignment</source>
          <target state="translated">비트 AND 대입</target>
        </trans-unit>
        <trans-unit id="db18850b4fbdf18ce2743308d732881bff20e370" translate="yes" xml:space="preserve">
          <source>Bitwise AND assignment (&lt;code&gt;&amp;amp;=&lt;/code&gt;)</source>
          <target state="translated">비트 AND 대입 ( &lt;code&gt;&amp;amp;=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="207c0ede4c9f854f279319be8d54c1851a4c68e6" translate="yes" xml:space="preserve">
          <source>Bitwise AND assignment (&lt;code&gt;x &amp;amp;= y&lt;/code&gt;)</source>
          <target state="translated">비트 AND 대입 ( &lt;code&gt;x &amp;amp;= y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e7709ea6d5ed548c9ce41069efce2a3064d76764" translate="yes" xml:space="preserve">
          <source>Bitwise AND assignment operator</source>
          <target state="translated">비트 AND 할당 연산자</target>
        </trans-unit>
        <trans-unit id="b83b40bc737146a9d8ff05e395bc13b4f754647f" translate="yes" xml:space="preserve">
          <source>Bitwise AND assignment.</source>
          <target state="translated">비트 AND 대입.</target>
        </trans-unit>
        <trans-unit id="0df7c0bd6736eaaf3a752d36fa8db9d8e9d6e8b8" translate="yes" xml:space="preserve">
          <source>Bitwise AND operator</source>
          <target state="translated">비트 AND 연산자</target>
        </trans-unit>
        <trans-unit id="ffba6db82603dad8914301fabc35b8806c66bd9d" translate="yes" xml:space="preserve">
          <source>Bitwise AND.</source>
          <target state="translated">비트 AND.</target>
        </trans-unit>
        <trans-unit id="2737aa3f8657f46926b272468cdaaf97d4ae4bca" translate="yes" xml:space="preserve">
          <source>Bitwise ANDing any number &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 와 &lt;code&gt;0&lt;/code&gt; 을 비트 단위로 AND 하면 &lt;code&gt;0&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="228f1254537780a1665d7d6053bc84359b75bc83" translate="yes" xml:space="preserve">
          <source>Bitwise ANDing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields &lt;code&gt;0&lt;/code&gt;. Bitwise ANDing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;-1&lt;/code&gt; yields &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 비트 AND 하면 &lt;code&gt;0&lt;/code&gt; 이 됩니다. 숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;-1&lt;/code&gt; 로 비트 AND 하면 &lt;code&gt;x&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="1106c19e63f1ecb8c7e66bf9006a1aeb1bfdb0e8" translate="yes" xml:space="preserve">
          <source>Bitwise Left Shift</source>
          <target state="translated">비트 왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">비트 단위 NOT</target>
        </trans-unit>
        <trans-unit id="b85f0285386bcc121aa981e9285153a238ab302c" translate="yes" xml:space="preserve">
          <source>Bitwise NOT (&lt;code&gt;~a&lt;/code&gt;)</source>
          <target state="translated">비트 NOT ( &lt;code&gt;~a&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ea10ea62f6783893a49bcccf186e0af033c9f677" translate="yes" xml:space="preserve">
          <source>Bitwise NOT operator.</source>
          <target state="translated">비트 NOT 연산자</target>
        </trans-unit>
        <trans-unit id="b9eca6b3f86ef4b57c63a63799bfc18d87f7ade5" translate="yes" xml:space="preserve">
          <source>Bitwise NOTing any number &lt;code&gt;x&lt;/code&gt; yields &lt;code&gt;-(x + 1)&lt;/code&gt;. For example, &lt;code&gt;~-5&lt;/code&gt; yields &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt; 를 비트로 표시 하면 &lt;code&gt;-(x + 1)&lt;/code&gt; 됩니다. 예를 들어 &lt;code&gt;~-5&lt;/code&gt; &lt;code&gt;4&lt;/code&gt; 를 산출 합니다.</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="78a461b3681192de29c2632b67cf5c033faafe18" translate="yes" xml:space="preserve">
          <source>Bitwise OR (&lt;code&gt;a | b&lt;/code&gt;)</source>
          <target state="translated">비트 단위 OR ( &lt;code&gt;a | b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a7d8fd299d5c1bafd6ababe24987384c94c58173" translate="yes" xml:space="preserve">
          <source>Bitwise OR assignment</source>
          <target state="translated">비트 OR 할당</target>
        </trans-unit>
        <trans-unit id="cf6f335e17a5850b36eca82a39c1fb3b9497c5cf" translate="yes" xml:space="preserve">
          <source>Bitwise OR assignment (&lt;code&gt;x |= y&lt;/code&gt;)</source>
          <target state="translated">비트 OR 대입 ( &lt;code&gt;x |= y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0055669203c5d801c537b7c1231033a51fdff2e7" translate="yes" xml:space="preserve">
          <source>Bitwise OR assignment (&lt;code&gt;|=&lt;/code&gt;)</source>
          <target state="translated">비트 OR 할당 ( &lt;code&gt;|=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c00418dad140cd5db782a8810cf33d100779a732" translate="yes" xml:space="preserve">
          <source>Bitwise OR assignment operator</source>
          <target state="translated">비트 OR 할당 연산자</target>
        </trans-unit>
        <trans-unit id="02d812fc3cec8b81c5535cd3018fc4f06ade94e9" translate="yes" xml:space="preserve">
          <source>Bitwise OR assignment.</source>
          <target state="translated">비트 단위 OR 할당.</target>
        </trans-unit>
        <trans-unit id="c7c79b59fde4e0bcec0d187739484d6548579930" translate="yes" xml:space="preserve">
          <source>Bitwise OR operator</source>
          <target state="translated">비트 OR 연산자</target>
        </trans-unit>
        <trans-unit id="f6cce76615b422f50d91d4d2e6ab10761c70e02d" translate="yes" xml:space="preserve">
          <source>Bitwise OR.</source>
          <target state="translated">비트 OR.</target>
        </trans-unit>
        <trans-unit id="437690ced7acdfb3db70e825b1a978514935c359" translate="yes" xml:space="preserve">
          <source>Bitwise ORing any number &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">비트 단위 OR 작업 임의 번호 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 와 &lt;code&gt;0&lt;/code&gt; 수율의 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76ed4e1870847d788b5165f69f2a25c0d1bdf96f" translate="yes" xml:space="preserve">
          <source>Bitwise ORing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields &lt;code&gt;x&lt;/code&gt;. Bitwise ORing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;-1&lt;/code&gt; yields &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 비트 OR 하면 &lt;code&gt;x&lt;/code&gt; 가 됩니다. 숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;-1&lt;/code&gt; 로 비트 OR 하면 &lt;code&gt;-1&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="13d1bf85f6108733cd5763f383227ae586d1706d" translate="yes" xml:space="preserve">
          <source>Bitwise Right Shift</source>
          <target state="translated">비트 오른쪽 시프트</target>
        </trans-unit>
        <trans-unit id="d105663d9d701d23ae726ff9dc6d8ecf8192aa61" translate="yes" xml:space="preserve">
          <source>Bitwise Unsigned Right Shift</source>
          <target state="translated">비트 부호없는 오른쪽 시프트</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="51306fe75b76bd49cbe3e00e768e9b55bf4ae5f7" translate="yes" xml:space="preserve">
          <source>Bitwise XOR (&lt;code&gt;a ^ b&lt;/code&gt;)</source>
          <target state="translated">비트 XOR ( &lt;code&gt;a ^ b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e3e1709ce290a67ec5f21e03a6b6317c9f304436" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment</source>
          <target state="translated">비트 XOR 할당</target>
        </trans-unit>
        <trans-unit id="5528a7a5704835b370988fe2d816030aee967dc6" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment (&lt;code&gt;x ^= y&lt;/code&gt;)</source>
          <target state="translated">비트 XOR 대입 ( &lt;code&gt;x ^= y&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="726a42aef2d386243def2c984efd4e709d97d58a" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment operator</source>
          <target state="translated">비트 XOR 할당 연산자</target>
        </trans-unit>
        <trans-unit id="a2e6f0879c56242b4b6e0dfcdd52258af33ed61f" translate="yes" xml:space="preserve">
          <source>Bitwise XOR assignment.</source>
          <target state="translated">비트 XOR 할당.</target>
        </trans-unit>
        <trans-unit id="3113dc4268d62d0b5a670a3be75adeb0efd5616d" translate="yes" xml:space="preserve">
          <source>Bitwise XOR operator</source>
          <target state="translated">비트 XOR 연산자</target>
        </trans-unit>
        <trans-unit id="208853b1399b38924467bde1a53c6b31b3f0d077" translate="yes" xml:space="preserve">
          <source>Bitwise XOR.</source>
          <target state="translated">비트 XOR.</target>
        </trans-unit>
        <trans-unit id="f293cbfb8237e5c7cfaae6bb93ba3378d50e2a7d" translate="yes" xml:space="preserve">
          <source>Bitwise XORing any number &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">비트 단위 XOR 연산 어떤 번호 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 와 &lt;code&gt;0&lt;/code&gt; 수율의 &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8496e18e62495844702902d344bb9aee1d53dca8" translate="yes" xml:space="preserve">
          <source>Bitwise XORing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;0&lt;/code&gt; yields x. Bitwise XORing any number &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;-1&lt;/code&gt; yields &lt;code&gt;~x&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 비트 XOR 하면 x가됩니다. 숫자 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;-1&lt;/code&gt; 로 XOR 하면 &lt;code&gt;~x&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="49799e0ede49c819113d20d6cebe854b9eb4b468" translate="yes" xml:space="preserve">
          <source>Bitwise left shift (&lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt;)</source>
          <target state="translated">비트 단위 왼쪽 시프트 ( &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e6cd89765f9f07982713f6158dd811fb58407b4c" translate="yes" xml:space="preserve">
          <source>Bitwise left shift operator.</source>
          <target state="translated">비트 왼쪽 시프트 연산자.</target>
        </trans-unit>
        <trans-unit id="b43dfc8d2e6ac1a2f9d917e7bf1ee01506c3ea48" translate="yes" xml:space="preserve">
          <source>Bitwise logical operators</source>
          <target state="translated">비트 논리 연산자</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="d0b085fabde0c44cb6500453963ef371f1f5a371" translate="yes" xml:space="preserve">
          <source>Bitwise operators in the JS guide</source>
          <target state="translated">JS 가이드의 비트 연산자</target>
        </trans-unit>
        <trans-unit id="cf36d30aed7538bcf7a534272f9f63ef2c05b3d7" translate="yes" xml:space="preserve">
          <source>Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.</source>
          <target state="translated">비트 연산자는 피연산자를 32 비트 (0과 1) 집합으로 취급하고 표준 JavaScript 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21e3d2983421ad31e10303ddd77128c1f7ec8861" translate="yes" xml:space="preserve">
          <source>Bitwise right shift (&lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt;)</source>
          <target state="translated">비트 오른쪽 시프트 ( &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ed5a09a9d7f5e8fb884bd222a4d9226d68817eec" translate="yes" xml:space="preserve">
          <source>Bitwise right shift operator.</source>
          <target state="translated">비트 오른쪽 시프트 연산자.</target>
        </trans-unit>
        <trans-unit id="d49fb1543c1cf037be882f516f8283e8411c03af" translate="yes" xml:space="preserve">
          <source>Bitwise shift operators</source>
          <target state="translated">비트 시프트 연산자</target>
        </trans-unit>
        <trans-unit id="b55b921b4ab4b2a4aa94c854dd6f474fd101c31b" translate="yes" xml:space="preserve">
          <source>Bitwise shifting any number &lt;code&gt;x&lt;/code&gt; to the left by &lt;code&gt;y&lt;/code&gt; bits yields &lt;code&gt;x * 2&amp;nbsp;** y&lt;/code&gt;.</source>
          <target state="translated">숫자 &lt;code&gt;x&lt;/code&gt; 를 왼쪽으로 &lt;code&gt;y&lt;/code&gt; 비트 씩 비트 이동하면 &lt;code&gt;x * 2&amp;nbsp;** y&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4cfc404dc07a4c79c7f13da23a3d2f9325c509" translate="yes" xml:space="preserve">
          <source>Bitwise unsigned right shift (&lt;code&gt;a &amp;gt;&amp;gt;&amp;gt; b&lt;/code&gt;)</source>
          <target state="translated">비트 부호없는 오른쪽 시프트 ( &lt;code&gt;a &amp;gt;&amp;gt;&amp;gt; b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="295c9191efffb3bb34f27f69cfe56325dce052a0" translate="yes" xml:space="preserve">
          <source>Bitwise unsigned right shift operator.</source>
          <target state="translated">비트 부호없는 오른쪽 시프트 연산자.</target>
        </trans-unit>
        <trans-unit id="4bbca20f48097a12932f951b2540fe1cef457e75" translate="yes" xml:space="preserve">
          <source>Block Scoping Rules</source>
          <target state="translated">범위 지정 규칙 차단</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">블록 진술</target>
        </trans-unit>
        <trans-unit id="1a8f0843bcf082b23c210f56bc6a9711e29db02a" translate="yes" xml:space="preserve">
          <source>Block scoping</source>
          <target state="translated">블록 범위 지정</target>
        </trans-unit>
        <trans-unit id="bc371f6dae1e3e909b4c05d159ced5d5bf380148" translate="yes" xml:space="preserve">
          <source>Block scoping rules with let, const or function declaration in strict mode</source>
          <target state="translated">엄격 모드에서 let, const 또는 함수 선언을 사용하여 범위 지정 규칙 차단</target>
        </trans-unit>
        <trans-unit id="5c452d77debbc7a83908ba2c8511d154548f5ab6" translate="yes" xml:space="preserve">
          <source>Block scoping rules with var or function declaration in non-strict mode</source>
          <target state="translated">엄격하지 않은 모드에서 var 또는 함수 선언이있는 블록 범위 규칙</target>
        </trans-unit>
        <trans-unit id="969ef7f93e174f019c94a1a2b4d8cb9962752777" translate="yes" xml:space="preserve">
          <source>Block-level functions</source>
          <target state="translated">블록 레벨 기능</target>
        </trans-unit>
        <trans-unit id="3a4dc39931e8b4f58b52224be0ab5913ab714b6f" translate="yes" xml:space="preserve">
          <source>Block-level functions in non-strict code</source>
          <target state="translated">엄격하지 않은 코드의 블록 수준 함수</target>
        </trans-unit>
        <trans-unit id="223690972993f09a3e260b9055786a3bcfde4eea" translate="yes" xml:space="preserve">
          <source>Block-scope variables within &lt;code&gt;switch&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문 내의 블록 범위 변수</target>
        </trans-unit>
        <trans-unit id="4b378921152c8fce52a9f4a8108f22a325030ee4" translate="yes" xml:space="preserve">
          <source>Blocks are commonly used in association with &lt;a href=&quot;if...else&quot;&gt;&lt;code&gt;if...else&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; statements.</source>
          <target state="translated">블록은 일반적으로 &lt;a href=&quot;if...else&quot;&gt; &lt;code&gt;if...else&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 문과 관련하여 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="90000c3ff777303da5ba95029671caaecb1a0646" translate="yes" xml:space="preserve">
          <source>Blog post: &quot;ES6 In Depth: Classes&quot;</source>
          <target state="translated">블로그 게시물 : &quot;ES6 심도 : 수업&quot;</target>
        </trans-unit>
        <trans-unit id="0b4be1c4511e65eb0f5a72d1caf15f5b4c50d45d" translate="yes" xml:space="preserve">
          <source>Bonding arrays contained in an array of objects using the spread operator and initialValue</source>
          <target state="translated">spread 연산자와 initialValue를 사용하여 객체 배열에 포함 된 배열 결합</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="e7bd2781af4b67186aeca61c0314545e3d8f6ee2" translate="yes" xml:space="preserve">
          <source>Boolean data type (Wikipedia)</source>
          <target state="translated">부울 데이터 형식 (Wikipedia)</target>
        </trans-unit>
        <trans-unit id="8eaf8a6b9a4be72c9ec43f36ab75dc481def2fef" translate="yes" xml:space="preserve">
          <source>Boolean literal</source>
          <target state="translated">부울 리터럴</target>
        </trans-unit>
        <trans-unit id="ebd49e494985f6506a4c46505a8445efd7b5d37e" translate="yes" xml:space="preserve">
          <source>Boolean literals (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">부울 리터럴 ( &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e806555369690f003bb66da55fa7f106f81b42e8" translate="yes" xml:space="preserve">
          <source>Boolean primitives</source>
          <target state="translated">부울 프리미티브</target>
        </trans-unit>
        <trans-unit id="9f712644f3d2fd5d30b1dc50f020babfd535a2e1" translate="yes" xml:space="preserve">
          <source>Boolean values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are converted to 1 and 0 respectively.</source>
          <target state="translated">부울 값 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 는 각각 1과 0으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="bafb42bd8a7b23d58942b4d964812d501578ecb4" translate="yes" xml:space="preserve">
          <source>Boolean.boolean</source>
          <target state="translated">Boolean.boolean</target>
        </trans-unit>
        <trans-unit id="1f102602ed247c6b12a26812e81bca2ba1dd4627" translate="yes" xml:space="preserve">
          <source>Boolean.prototype</source>
          <target state="translated">Boolean.prototype</target>
        </trans-unit>
        <trans-unit id="654f22e57098e5b43fcee49bfb4be08667c6f56b" translate="yes" xml:space="preserve">
          <source>Booleans must be both &lt;code&gt;true&lt;/code&gt; or both &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부울은 모두 &lt;code&gt;true&lt;/code&gt; 이거나 &lt;code&gt;false&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8330bbb5ea1b3cd628f51340a64838a6c79182c8" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; properties are copied.</source>
          <target state="translated">두 &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 속성이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="16d710b26d846dc5dfd857489d4c042180867059" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for...in&lt;/code&gt; and &lt;code&gt;for...of&lt;/code&gt; statements iterate over something. The main difference between them is in what they iterate over.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 및 &lt;code&gt;for...of&lt;/code&gt; 문 모두 무언가를 반복합니다. 그들 사이의 주요 차이점은 그들이 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="077843fe2573eda90e5f4c69e8d4b8a0c3cc25f1" translate="yes" xml:space="preserve">
          <source>Both Public and private field declarations are an &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;experimental feature (stage 3)&lt;/a&gt; proposed at &lt;a href=&quot;https://tc39.github.io/beta/&quot;&gt;TC39&lt;/a&gt;, the JavaScript standards committee.</source>
          <target state="translated">공개 및 비공개 필드 선언은 모두 JavaScript 표준위원회 인 &lt;a href=&quot;https://tc39.github.io/beta/&quot;&gt;TC39&lt;/a&gt; 에서 제안한 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;실험적 기능 (3 단계)&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d99c247e5d195ef53c983662a3f089c50ba31b78" translate="yes" xml:space="preserve">
          <source>Both data and accessor descriptors are objects. They share the following optional keys (please note: the &lt;strong&gt;defaults&lt;/strong&gt; mentioned here are in the case of defining properties using &lt;code&gt;Object.defineProperty()&lt;/code&gt;):</source>
          <target state="translated">데이터 및 접근 자 설명자는 모두 개체입니다. 이들은 다음과 같은 선택적 키를 공유합니다 (참고 : 여기에 언급 된 &lt;strong&gt;기본값&lt;/strong&gt; 은 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 사용하여 속성을 정의하는 경우 임 ).</target>
        </trans-unit>
        <trans-unit id="1b4e9beeb224225cc3fb98b04f8fe30d72ea557d" translate="yes" xml:space="preserve">
          <source>Both data and accessor descriptors are objects. They share the following optional keys:</source>
          <target state="translated">데이터 및 접근 자 설명자 모두 개체입니다. 다음과 같은 선택적 키를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="85aa6ceba666be7d2128d19642bc15c59b499adc" translate="yes" xml:space="preserve">
          <source>Both lines will throw a &lt;code&gt;SyntaxError&lt;/code&gt;:</source>
          <target state="translated">두 줄 모두 &lt;code&gt;SyntaxError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6c75fb4d493afe560bfc951ac11a9f2a488aa359" translate="yes" xml:space="preserve">
          <source>Both lines will throw a SyntaxError:</source>
          <target state="translated">두 줄 모두 SyntaxError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d92eca167111ea2c3e464fb0ae5da04ea28fd55" translate="yes" xml:space="preserve">
          <source>Both of the above methods result in identical strings.</source>
          <target state="translated">위의 두 방법 모두 동일한 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2a336ea754922474e5193fc394f3b779e9feeda5" translate="yes" xml:space="preserve">
          <source>Both of these result in identical strings being created.</source>
          <target state="translated">이 두 가지 모두 동일한 문자열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="45a50e0682b1be2af5144e5ada02ea28b4d38253" translate="yes" xml:space="preserve">
          <source>Both static and instance public fields are writable, enumerable, and configurable properties. As such, unlike their private counterparts, they participate in prototype inheritance.</source>
          <target state="translated">정적 및 인스턴스 공용 필드는 모두 쓰기 가능하고 열거 가능하며 구성 가능한 속성입니다. 따라서 개인과 달리 프로토 타입 상속에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="f5a7d65234a859b8fc71598d624cf812f967748d" translate="yes" xml:space="preserve">
          <source>Both, &lt;a href=&quot;../global_objects/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, have no properties you could access.</source>
          <target state="translated">&lt;a href=&quot;../global_objects/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 모두 액세스 할 수있는 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="33b3636f5258d6a496a704ec54c29db5b253a832" translate="yes" xml:space="preserve">
          <source>Bound function names</source>
          <target state="translated">바운드 함수 이름</target>
        </trans-unit>
        <trans-unit id="d7159e794664ac62bfac2747b789576dbdcf1c60" translate="yes" xml:space="preserve">
          <source>Bound functions are automatically suitable for use with the &lt;a href=&quot;../../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided &lt;code&gt;this&lt;/code&gt; is ignored.</source>
          <target state="translated">바인딩 된 함수는 대상 함수에 의해 생성 된 새 인스턴스를 생성하기 위해 &lt;a href=&quot;../../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자 와 함께 사용하기에 자동으로 적합 합니다. 바인딩 된 함수가 값을 생성하는 데 사용되는 경우 제공된 &lt;code&gt;this&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bae8c99681fcb5bed93319c3a8e784ff8f36832c" translate="yes" xml:space="preserve">
          <source>Bound functions are automatically suitable for use with the &lt;a href=&quot;../../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided &lt;code&gt;this&lt;/code&gt; is ignored. However, provided arguments are still prepended to the constructor call:</source>
          <target state="translated">바운드 함수는 대상 함수로 작성된 새 인스턴스를 구성 하기 위해 &lt;a href=&quot;../../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자 와 함께 사용하기에 자동으로 적합 합니다. 바인드 함수를 사용하여 값을 구성하는 &lt;code&gt;this&lt;/code&gt; 값 은 무시됩니다. 그러나 제공된 인수는 여전히 생성자 호출 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b16480759bbc4d89ce784dfdc68a435b33834d1e" translate="yes" xml:space="preserve">
          <source>Bound functions used as constructors</source>
          <target state="translated">생성자로 사용되는 바운드 함수</target>
        </trans-unit>
        <trans-unit id="676167cbb2c97275c4be4d6c7fc8fcffc08b6517" translate="yes" xml:space="preserve">
          <source>Boundaries</source>
          <target state="translated">Boundaries</target>
        </trans-unit>
        <trans-unit id="a4b116a0b5493666bad04b28569b9c9f04d07eed" translate="yes" xml:space="preserve">
          <source>Boxing with prototype and static methods</source>
          <target state="translated">프로토 타입과 정적 방법으로 복싱</target>
        </trans-unit>
        <trans-unit id="00a4a57c91f2fdc5c903c80c715cfd51d25d159c" translate="yes" xml:space="preserve">
          <source>Bracket notation</source>
          <target state="translated">대괄호 표기법</target>
        </trans-unit>
        <trans-unit id="7e3a2e6e2e6ecc584b6eac09ac9297599bd044a1" translate="yes" xml:space="preserve">
          <source>Bracket notation vs. &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">대괄호 표기법 대 &lt;code&gt;eval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782a6c9031e2024679b210f762c9530e2def80d" translate="yes" xml:space="preserve">
          <source>Brahmi digits</source>
          <target state="translated">브라 흐미 숫자</target>
        </trans-unit>
        <trans-unit id="6c437544a2fdc41e6c287d1fca5e9492cc91a589" translate="yes" xml:space="preserve">
          <source>Breaking changes in &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in Firefox 44</source>
          <target state="translated">Firefox 44 에서 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 의 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="b99b91e559917941bb0e259fb1c7151b747a651d" translate="yes" xml:space="preserve">
          <source>Browser compatibility</source>
          <target state="translated">브라우저 호환성</target>
        </trans-unit>
        <trans-unit id="b9596fac5cc2ce26e02f68794e8302c229989e32" translate="yes" xml:space="preserve">
          <source>Browser compatibility&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;Update compatibility data on GitHub&lt;/a&gt;</source>
          <target state="translated">브라우저 호환성 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;GitHub의 호환성 데이터 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad735f3a90b4762d4bc98ff90a8d1ea0c7f3598c" translate="yes" xml:space="preserve">
          <source>Built-in APIs accepting iterables</source>
          <target state="translated">이터 러블을 허용하는 내장 API</target>
        </trans-unit>
        <trans-unit id="2cc171ab81fa4452ee0c19ad52e0e7f0d9b6ef29" translate="yes" xml:space="preserve">
          <source>Built-in Async Iterables</source>
          <target state="translated">기본 제공 비동기 반복 가능</target>
        </trans-unit>
        <trans-unit id="581abb698c99c4b1120288f3de3a9b64c9286720" translate="yes" xml:space="preserve">
          <source>Built-in iterables</source>
          <target state="translated">내장 이터 러블</target>
        </trans-unit>
        <trans-unit id="884ab2c39a0a22ef21580b757472274ae839547e" translate="yes" xml:space="preserve">
          <source>Built-in toStringTag symbols</source>
          <target state="translated">내장 toStringTag 기호</target>
        </trans-unit>
        <trans-unit id="448aea1f663f911f7037eb448b904b903acbc888" translate="yes" xml:space="preserve">
          <source>Built-ins</source>
          <target state="translated">Built-ins</target>
        </trans-unit>
        <trans-unit id="92721da1822273850afdb94edb4d22e3303367c0" translate="yes" xml:space="preserve">
          <source>But a default export can be imported with any name for example:</source>
          <target state="translated">그러나 기본 내보내기는 다음과 같은 이름으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9555f50cca8312e6f450839db586b008b4b6efe4" translate="yes" xml:space="preserve">
          <source>But beware: by using &lt;code&gt;apply&lt;/code&gt; this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (that is, more than tens of thousands of arguments) varies across engines. (The JavaScriptCore engine has hard-coded &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=80797&quot;&gt;argument limit of 65536&lt;/a&gt;.</source>
          <target state="translated">그러나주의하십시오. 이 방법으로 &lt;code&gt;apply&lt;/code&gt; 를 사용 하면 JavaScript 엔진의 인수 길이 제한을 초과 할 위험이 있습니다. 너무 많은 인수 (즉, 수만 개 이상의 인수)가있는 함수를 적용한 결과는 엔진마다 다릅니다. (JavaScriptCore 엔진의 하드 코딩 된 &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=80797&quot;&gt;인수 제한은 65536&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f2a03247dac989b4bafc6987ec5a3c8d8668c6a" translate="yes" xml:space="preserve">
          <source>But beware: in using &lt;code&gt;apply&lt;/code&gt; this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=80797&quot;&gt;argument limit of 65536&lt;/a&gt;), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. To illustrate this latter case: if such an engine had a limit of four arguments (actual limits are of course significantly higher), it would be as if the arguments &lt;code&gt;5, 6, 2, 3&lt;/code&gt; had been passed to &lt;code&gt;apply&lt;/code&gt; in the examples above, rather than the full array.</source>
          <target state="translated">그러나 이런 식으로 &lt;code&gt;apply&lt;/code&gt; 하면 JavaScript 엔진의 인수 길이 제한을 초과 할 위험이 있습니다. 너무 많은 인수가있는 함수를 적용 한 결과 (수만 개의 인수 이상으로 생각)는 엔진마다 다릅니다 (JavaScriptCore는 하드 코딩 된 &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=80797&quot;&gt;인수 제한 65536&lt;/a&gt; ). 동작)이 지정되지 않았습니다. 일부 엔진은 예외가 발생합니다. 더 악의적으로, 다른 사람들은 실제로 적용된 함수에 전달되는 인수의 수를 임의로 제한합니다. 후자의 경우를 설명하기 위해 : 만약 그러한 엔진이 4 개의 인수의 한계를 가지고 있다면 (실제 한계는 물론 상당히 높음), 인수 &lt;code&gt;5, 6, 2, 3&lt;/code&gt; 이 &lt;code&gt;apply&lt;/code&gt; 되도록 통과 된 것과 같습니다. 위의 예에서는 전체 배열이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c5b583455c2fbecd20a5fd6c20328e66a1b3fe39" translate="yes" xml:space="preserve">
          <source>But that way of setting a property does not interact with the Map data structure. It uses the feature of the generic object. The value of 'bla' is not stored in the Map for queries. Other operations on the data fail:</source>
          <target state="translated">그러나 속성을 설정하는 이러한 방법은 Map 데이터 구조와 상호 작용하지 않습니다. 일반 개체의 기능을 사용합니다. 'bla'의 값은 쿼리를 위해 맵에 저장되지 않습니다. 데이터에 대한 다른 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="acab0ffeb0e96c00b7547d458b0d5582e549bad5" translate="yes" xml:space="preserve">
          <source>But when do we need to perform last line here? Unfortunately the answer is - it depends.</source>
          <target state="translated">하지만 언제 마지막 줄을 수행해야합니까? 불행히도 그 대답은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6028000d5a15ce56f4d39ed3e2cbf1dd3f527ec0" translate="yes" xml:space="preserve">
          <source>But when do we need to perform the last line here? Unfortunately, the answer is: &lt;em&gt;it depends&lt;/em&gt;.</source>
          <target state="translated">하지만 여기서 마지막 줄을 언제 수행해야합니까? 불행히도 대답은 : &lt;em&gt;그것은 의존한다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="977e4a9357ea1f101d39dbc97f777df1a9f0b2b0" translate="yes" xml:space="preserve">
          <source>But where &lt;code&gt;function1&lt;/code&gt; and &lt;code&gt;function2&lt;/code&gt; do not become available inside the current module.</source>
          <target state="translated">그러나 &lt;code&gt;function1&lt;/code&gt; 및 &lt;code&gt;function2&lt;/code&gt; 는 현재 모듈 내에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e962dcf9bf0e8855188d7c4bfc8bb71e56d5031b" translate="yes" xml:space="preserve">
          <source>But with the addition of block-scoped &lt;a href=&quot;../statements/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../statements/const&quot;&gt;&lt;code&gt;Statements/const&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;typeof&lt;/code&gt; on &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; variables (or using &lt;code&gt;typeof&lt;/code&gt; on a &lt;code&gt;class&lt;/code&gt;) in a block before they are declared will throw a &lt;a href=&quot;../global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt;. Block scoped variables are in a &quot;&lt;a href=&quot;../statements/let#The_temporal_dead_zone_and_typeof&quot;&gt;temporal dead zone&lt;/a&gt;&quot; from the start of the block until the initialization is processed, during which, it will throw an error if accessed.</source>
          <target state="translated">그러나의 추가와 함께 블록 범위의 &lt;a href=&quot;../statements/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../statements/const&quot;&gt; &lt;code&gt;Statements/const&lt;/code&gt; &lt;/a&gt; 사용 &lt;code&gt;typeof&lt;/code&gt; 에 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 변수 (또는 사용 &lt;code&gt;typeof&lt;/code&gt; A의 &lt;code&gt;class&lt;/code&gt; ) 그들이 발생합니다 선언되기 전에 블록에 &lt;a href=&quot;../global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; &lt;/a&gt; . 블록 범위 변수는 블록 시작부터 초기화가 처리 될 때까지 &quot; &lt;a href=&quot;../statements/let#The_temporal_dead_zone_and_typeof&quot;&gt;임시 데드 존&lt;/a&gt; &quot;에 있으며, 그 동안 액세스하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2386b0cb8bc197488708768792aa4518bd775961" translate="yes" xml:space="preserve">
          <source>But with the addition of non-hoisted, block-scoped &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../statements/const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;typeof&lt;/code&gt; on &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; variables (or using &lt;code&gt;typeof&lt;/code&gt; on a &lt;code&gt;class)&lt;/code&gt; in a block before they are declared will throw a &lt;code&gt;&lt;a href=&quot;../global_objects/referenceerror&quot;&gt;ReferenceError&lt;/a&gt;&lt;/code&gt;. Block scoped variables are in a &quot;&lt;a href=&quot;../statements/let#Temporal_Dead_Zone_and_errors_with_let&quot;&gt;temporal dead zone&lt;/a&gt;&quot; from the start of the block until the initialization is processed, during which, it will throw an error if accessed.</source>
          <target state="translated">그러나 비 호이스트, 블록 범위 &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../statements/const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 를 추가하면 선언하기 전에 블록에서 &lt;code&gt;typeof&lt;/code&gt; on &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 변수를 사용하거나 &lt;code&gt;class)&lt;/code&gt; 에서 &lt;code&gt;typeof&lt;/code&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../global_objects/referenceerror&quot;&gt;ReferenceError&lt;/a&gt;&lt;/code&gt; 가 발생 합니다. 블록 범위 변수는 블록 의 시작부터 초기화가 처리 될 때까지 &quot; &lt;a href=&quot;../statements/let#Temporal_Dead_Zone_and_errors_with_let&quot;&gt;임시 데드 존&lt;/a&gt; &quot;에 있으며, 그 동안 액세스하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="acab9b5ebf6d33af79db5b88d974ec8ff3aade38" translate="yes" xml:space="preserve">
          <source>But with this change &lt;code&gt;JSON.stringify&lt;/code&gt; represents lone surrogates using JSON escape sequences that &lt;em&gt;can&lt;/em&gt; be encoded in valid UTF-8 or UTF-16:</source>
          <target state="translated">그러나이 변경으로 &lt;code&gt;JSON.stringify&lt;/code&gt; 는 유효한 UTF-8 또는 UTF-16으로 인코딩 &lt;em&gt;할 수&lt;/em&gt; 있는 JSON 이스케이프 시퀀스를 사용하는 고독한 대리자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4a7cc2b2cbe895d93ecd7208ead5d9a31b5ce6a7" translate="yes" xml:space="preserve">
          <source>But you can mutate the properties in a variable:</source>
          <target state="translated">그러나 변수의 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae4e6b4934b4082b0607861655201c9bddd4928c" translate="yes" xml:space="preserve">
          <source>But you wanted to append to the existing array... So what now? Write a loop? Surely not?</source>
          <target state="translated">하지만 기존 어레이에 추가하고 싶었습니다. 이제 어떻게해야합니까? 루프를 작성 하시겠습니까? 분명히 아니다?</target>
        </trans-unit>
        <trans-unit id="df4f3610603e26f63d0b839316556ad1b13bcdf1" translate="yes" xml:space="preserve">
          <source>But, &lt;code&gt;Promise.all&lt;/code&gt; resolves synchronously &lt;strong&gt;if and only if&lt;/strong&gt; the &lt;var&gt;iterable&lt;/var&gt; passed is empty:</source>
          <target state="translated">그러나 &lt;code&gt;Promise.all&lt;/code&gt; 은 전달 된 &lt;var&gt;iterable&lt;/var&gt; 이 비어있는 &lt;strong&gt;경우에만&lt;/strong&gt; 동 기적으로 해결 &lt;strong&gt;됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="56c3a9c1f13d2c03f486c47c2ef4f97cbc875fc9" translate="yes" xml:space="preserve">
          <source>But, if you pass an array to &lt;code&gt;push&lt;/code&gt;, it will actually add that array as a single element, instead of adding the elements individually. So you end up with an array inside an array.</source>
          <target state="translated">그러나 &lt;code&gt;push&lt;/code&gt; 에 배열을 전달 하면 요소를 개별적으로 추가하는 대신 실제로 해당 배열을 단일 요소로 추가합니다. 따라서 배열 내부의 배열로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="e395f352635c44cff809d07317daf64f2921e510" translate="yes" xml:space="preserve">
          <source>But, the &lt;code&gt;length&lt;/code&gt; property does not necessarily indicate the number of defined values in the array. See also &lt;a href=&quot;../array#Relationship_between_length_and_numerical_properties&quot;&gt;Relationship between &lt;code&gt;length&lt;/code&gt; and numerical properties&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;length&lt;/code&gt; 속성이 반드시 배열에 정의 된 값의 수를 나타내는 것은 아닙니다. &lt;a href=&quot;../array#Relationship_between_length_and_numerical_properties&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성과 숫자 속성의 관계를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bbae1cbadd6294457f6e790fc07e56efdedeb9c" translate="yes" xml:space="preserve">
          <source>By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.</source>
          <target state="translated">짧은 시간에 버튼을 여러 번 클릭하면 다른 약속이 차례로 이행되는 것을 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33195d68474668ca9b4fbeb87084df1cb01c7086" translate="yes" xml:space="preserve">
          <source>By contrast, identifiers declared with &lt;a href=&quot;let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;const&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;do have &lt;/strong&gt;block scope:</source>
          <target state="translated">반대로 &lt;a href=&quot;let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;const&quot;&gt; &lt;code&gt;const&lt;/code&gt; 로&lt;/a&gt; 선언 된 식별자 &lt;strong&gt;는&lt;/strong&gt; 블록 범위를 &lt;strong&gt;갖습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="692c4388cf797b740802098c3e95fb8fcd78c138" translate="yes" xml:space="preserve">
          <source>By contrast, native &lt;code&gt;WeakMap&lt;/code&gt;s hold &quot;weak&quot; references to key objects, which means that they do not prevent garbage collection in case there would be no other reference to the key object. This also avoids preventing garbage collection of values in the map. Native WeakMaps can be particularly useful constructs when mapping keys to information about the key that is valuable only if the key has not been garbage collected.</source>
          <target state="translated">대조적으로, 네이티브 &lt;code&gt;WeakMap&lt;/code&gt; 은 키 객체에 대한 &quot;약한&quot;참조를 보유합니다. 즉, 키 객체에 대한 다른 참조가 없을 경우 가비지 수집을 방지하지 않습니다. 이것은 또한 맵에서 값의 가비지 수집을 방지합니다. 네이티브 WeakMaps는 키가 가비지 수집되지 않은 경우에만 중요한 키에 대한 정보에 키를 매핑 할 때 특히 유용한 구성 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d7055e7599fed5e77ac1117d25535cd8b0ebb9" translate="yes" xml:space="preserve">
          <source>By contrast, native WeakMaps hold &quot;weak&quot; references to key objects, which means that they do not prevent garbage collection in case there would be no other reference to the key object. This also avoids preventing garbage collection of values in the map. Native WeakMaps can be particularly useful constructs when mapping keys to information about the key that is valuable only if the key has not been garbage collected.</source>
          <target state="translated">대조적으로, 네이티브 WeakMap은 키 객체에 대한 &quot;약한&quot;참조를 보유합니다. 즉, 키 객체에 대한 다른 참조가없는 경우 가비지 콜렉션을 막지 않습니다. 또한 맵에서 값의 가비지 수집을 방지합니다. 네이티브 WeakMaps는 키를 가비지 수집하지 않은 경우에만 유용한 키에 대한 정보에 키를 매핑 할 때 특히 유용한 구성입니다.</target>
        </trans-unit>
        <trans-unit id="19a482c4520a9ba92e09ec0677ce2851220b93a6" translate="yes" xml:space="preserve">
          <source>By declaring fields up-front, class definitions become more self-documenting, and the fields are always present.</source>
          <target state="translated">필드를 미리 선언함으로써 클래스 정의는보다 자체 문서화되며 필드는 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c7c5a64edfd385ed53a10245ea0f514af1e6d3b0" translate="yes" xml:space="preserve">
          <source>By default within &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout&quot;&gt;&lt;code&gt;window.setTimeout()&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;this&lt;/code&gt; keyword will be set to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;global&lt;/code&gt;) object. When working with class methods that require &lt;code&gt;this&lt;/code&gt; to refer to class instances, you may explicitly bind &lt;code&gt;this&lt;/code&gt; to the callback function, in order to maintain the instance.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout&quot;&gt; &lt;code&gt;window.setTimeout()&lt;/code&gt; &lt;/a&gt; 내 에서 &lt;code&gt;this&lt;/code&gt; 키워드는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;global&lt;/code&gt; ) 객체 로 설정됩니다 . 클래스 인스턴스를 참조하기 위해 &lt;code&gt;this&lt;/code&gt; 필요로하는 클래스 메소드로 작업 할 때 인스턴스 를 유지하기 위해 &lt;code&gt;this&lt;/code&gt; 명시 적으로 콜백 함수에 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="659359b5cf4c8436196c0eca9ad42a5da58e11ff" translate="yes" xml:space="preserve">
          <source>By default within &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout&quot;&gt;&lt;code&gt;window.setTimeout()&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;this&lt;/code&gt; keyword will be set to the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;global&lt;/code&gt;) object. When working with class methods that require &lt;code&gt;this&lt;/code&gt; to refer to class instances, you may explicitly bind &lt;code&gt;this&lt;/code&gt; to the callback function, in order to maintain the instance.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout&quot;&gt; &lt;code&gt;window.setTimeout()&lt;/code&gt; &lt;/a&gt; 내 에서 &lt;code&gt;this&lt;/code&gt; 키워드는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;global&lt;/code&gt; ) 객체 로 설정됩니다 . 클래스 인스턴스를 참조하기 위해 &lt;code&gt;this&lt;/code&gt; 필요한 클래스 메소드로 작업 할 때 , 인스턴스를 유지하기 위해 &lt;code&gt;this&lt;/code&gt; 콜백 함수에 명시 적으로 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10e28890ee038393999a1380b4faf5a01bb1578a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../array/concat&quot;&gt;&lt;code&gt;Array.prototype.concat()&lt;/code&gt;&lt;/a&gt; spreads (flattens) arrays into its result:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../array/concat&quot;&gt; &lt;code&gt;Array.prototype.concat()&lt;/code&gt; &lt;/a&gt; )은 배열을 결과로 확장 (평평하게)합니다.</target>
        </trans-unit>
        <trans-unit id="62d6641e0d6b851c30bd6b7fd4c1a2ddbb3d2e80" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; instances are given the name &quot;Error&quot;. The &lt;code&gt;name&lt;/code&gt; property, in addition to the &lt;a href=&quot;message&quot;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/a&gt; property, is used by the &lt;a href=&quot;tostring&quot;&gt;&lt;code&gt;Error.prototype.toString()&lt;/code&gt;&lt;/a&gt; method to create a string representation of the error.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 인스턴스에는 &quot;오류&quot;라는 이름이 지정됩니다. &lt;code&gt;name&lt;/code&gt; 속성은 이외에 &lt;a href=&quot;message&quot;&gt; &lt;code&gt;message&lt;/code&gt; &lt;/a&gt; 속성에 의해 사용 &lt;a href=&quot;tostring&quot;&gt; &lt;code&gt;Error.prototype.toString()&lt;/code&gt; &lt;/a&gt; 에러의 스트링 표현을 생성하는 방법.</target>
        </trans-unit>
        <trans-unit id="272853013a210f467b913bed382af8c88e6adc38" translate="yes" xml:space="preserve">
          <source>By default, WebAssembly memories are unshared. You can create a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#Shared_memories&quot;&gt;shared memory&lt;/a&gt; by passing &lt;code&gt;shared: true&lt;/code&gt; in the constructor's initialization object:</source>
          <target state="translated">기본적으로 WebAssembly 메모리는 공유되지 않습니다. 생성자의 초기화 객체에 &lt;code&gt;shared: true&lt;/code&gt; 를 전달 하여 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format#Shared_memories&quot;&gt;공유 메모리&lt;/a&gt; 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8f721be42732dfaaa8dc900a44483d0c45cf0fd" translate="yes" xml:space="preserve">
          <source>By default, functions return &lt;code&gt;undefined&lt;/code&gt;. To return any other value, the function must have a &lt;a href=&quot;return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; statement that specifies the value to return.</source>
          <target state="translated">기본적으로 함수는 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다. 다른 값을 반환하려면 함수에 &lt;a href=&quot;return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 할 값을 지정 하는 return 문이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3121504be0e2cb862120db5715233b6181f79215" translate="yes" xml:space="preserve">
          <source>By default, objects are &lt;a href=&quot;isextensible&quot;&gt;extensible&lt;/a&gt; (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; (most commonly, although not exclusively, when in &lt;a href=&quot;../../strict_mode&quot;&gt;strict mode&lt;/a&gt; code).</source>
          <target state="translated">기본적으로 개체는 &lt;a href=&quot;isextensible&quot;&gt;확장 가능합니다&lt;/a&gt; (새 속성을 추가 할 수 있음). 객체를 봉인하면 새로운 속성이 추가되는 것을 방지하고 기존의 모든 속성을 구성 할 수없는 것으로 표시합니다. 이는 객체의 속성 집합을 고정 및 변경 불가능하게 만드는 효과가 있습니다. 모든 속성을 구성 할 수 없도록 설정하면 데이터 속성에서 접근 자 속성으로 또는 그 반대로 변환되는 것을 방지 할 수 있지만 데이터 속성의 값이 변경되는 것을 막지는 않습니다. 봉인 된 객체에서 속성을 삭제하거나 추가하거나 데이터 속성을 접근 자로 또는 그 반대로 변환하려고 시도하면 자동으로 또는 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; (가장 &lt;a href=&quot;../../strict_mode&quot;&gt;엄격&lt;/a&gt; 하지는 않지만 엄격하게 모드 코드 인 경우)가 발생하여 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="28e6d0fc51ec1ee314b5c461991b5894747dd62c" translate="yes" xml:space="preserve">
          <source>By default, objects are &lt;a href=&quot;isextensible&quot;&gt;extensible&lt;/a&gt; (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; (most commonly, although not exclusively, when in &lt;a href=&quot;../../strict_mode&quot;&gt;strict mode&lt;/a&gt; code).</source>
          <target state="translated">기본적으로 개체는 &lt;a href=&quot;isextensible&quot;&gt;확장 가능합니다&lt;/a&gt; (새 속성을 추가 할 수 있음). 개체를 봉인하면 새 속성이 추가되지 않고 모든 기존 속성이 구성 불가능으로 표시됩니다. 이것은 객체의 속성 집합을 고정시키는 효과가 있습니다. 모든 속성을 구성 할 수 없도록 설정하면 데이터 속성에서 접근 자 속성으로 또는 그 반대로 변환되는 것을 방지 할 수 있지만 데이터 속성의 값이 변경되는 것을 막지는 않습니다. 봉인 된 개체에 속성을 삭제 또는 추가하거나 데이터 속성을 접근 자로 또는 그 반대로 변환하려고하면 자동으로 또는 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 를 throw하여 실패합니다 (가장 일반적으로 &lt;a href=&quot;../../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 코드 에서 배타적이지는 않지만 ).</target>
        </trans-unit>
        <trans-unit id="22bf756fbb55c71ec9b2b9351542a91bee798090" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;message&lt;/code&gt; property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the &lt;a href=&quot;../error&quot;&gt;&lt;code&gt;Error constructor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;message&lt;/code&gt; 특성은 빈 문자열이지만 메시지를 &lt;a href=&quot;../error&quot;&gt; &lt;code&gt;Error constructor&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수로 지정하여 인스턴스에 대해이 동작을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="132de52e398cb45787f34b3ef44936d5e7d944f2" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;message&lt;/code&gt; property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the &lt;a href=&quot;error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">기본적으로 &lt;code&gt;message&lt;/code&gt; 속성은 빈 문자열이지만 &lt;a href=&quot;error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 생성자 의 첫 번째 인수로 메시지를 지정하여 인스턴스에 대해이 동작을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8785fd69786fee35f445f4dccf23f2fe0e41ac32" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;valueOf&lt;/code&gt; method is inherited by every object descended from &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, &lt;code&gt;valueOf&lt;/code&gt; returns the object itself.</source>
          <target state="translated">기본적으로 &lt;code&gt;valueOf&lt;/code&gt; 메소드는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; 의&lt;/a&gt; 하위 오브젝트로 상속됩니다 . 모든 내장 코어 객체는이 메서드를 재정 의하여 적절한 값을 반환합니다. 객체에 프리미티브 값이 없으면 &lt;code&gt;valueOf&lt;/code&gt; 는 객체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7873be2b91374dc17c7f6a426afcf13220ec712f" translate="yes" xml:space="preserve">
          <source>By default, this method is inherited by every object descended from &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로이 메소드는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; 의&lt;/a&gt; 하위 오브젝트로 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="046fbef544b28cf30f608e4ced019d95a74980a3" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;radix&lt;/code&gt; you can also convert base 10 numbers (like 1,2,3,4,5,.........) to another base numbers, in example below we are converting base 10 number to a base 2 (binary) number.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 를 사용하여 기본 10 숫자 (예 : 1,2,3,4,5, .........)를 다른 기본 숫자로 변환 할 수도 있습니다. 아래 예에서는 기본 10 숫자를 기본 2로 변환합니다. (이진) 숫자.</target>
        </trans-unit>
        <trans-unit id="a7aa977a0190559c39e91a6132694b1e17763080" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;?.&lt;/code&gt; operator instead of just &lt;code&gt;.&lt;/code&gt;, JavaScript knows to implicitly check to be sure &lt;code&gt;obj.first&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; before attempting to access &lt;code&gt;obj.first.second&lt;/code&gt;. If &lt;code&gt;obj.first&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, the expression automatically short-circuits, returning &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 를 사용하여 . 연산자 대신 &lt;code&gt;.&lt;/code&gt; 자바 스크립트가 암시 적으로 확실하게 확인을 알고 &lt;code&gt;obj.first&lt;/code&gt; 것은 아니다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 액세스를 시도하기 전에 &lt;code&gt;obj.first.second&lt;/code&gt; . 경우 &lt;code&gt;obj.first&lt;/code&gt; 가 인 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; , 식 자동 단락 돌려 보내는 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374179f942f22d09db25dc99065a0cc232ed77dc" translate="yes" xml:space="preserve">
          <source>Byte index before which to end slicing. If end is unspecified, the new &lt;code&gt;ArrayBuffer&lt;/code&gt; contains all bytes from begin to the end of this &lt;code&gt;ArrayBuffer&lt;/code&gt;. If negative, it will make the Byte index begin from the last Byte.</source>
          <target state="translated">슬라이싱을 종료하기 전의 바이트 인덱스입니다. end가 지정되지 않은 경우 새 &lt;code&gt;ArrayBuffer&lt;/code&gt; 는이 &lt;code&gt;ArrayBuffer&lt;/code&gt; 의 시작부터 끝까지 모든 바이트를 포함합니다 . 음수이면 Byte 인덱스가 마지막 Byte에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5969a259516b46e9263305388faf90ad0f94edb5" translate="yes" xml:space="preserve">
          <source>Byte index before which to end slicing. If end is unspecified, the new &lt;code&gt;ArrayBuffer&lt;/code&gt; contains all bytes from begin to the end of this &lt;code&gt;ArrayBuffer&lt;/code&gt;. The range specified by the begin and end values is clamped to the valid index range for the current array. If the computed length of the new &lt;code&gt;ArrayBuffer&lt;/code&gt; would be negative, it is clamped to zero.</source>
          <target state="translated">슬라이싱을 종료하기 전의 바이트 인덱스. end를 지정하지 않으면 새로운 &lt;code&gt;ArrayBuffer&lt;/code&gt; 는이 &lt;code&gt;ArrayBuffer&lt;/code&gt; 의 시작부터 끝까지 모든 바이트를 포함합니다 . 시작 및 종료 값으로 지정된 범위는 현재 배열의 유효한 인덱스 범위로 고정됩니다. 새 &lt;code&gt;ArrayBuffer&lt;/code&gt; 의 계산 된 길이 가 음수이면 0으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="65c69de6b60d275943eb0b345c38a4da863d03c4" translate="yes" xml:space="preserve">
          <source>Byte order mark</source>
          <target state="translated">바이트 순서 표시</target>
        </trans-unit>
        <trans-unit id="421b23d45757122556d21f325621aca603974ed8" translate="yes" xml:space="preserve">
          <source>C developers have the &lt;code&gt;strcmp()&lt;/code&gt; function for comparing strings. In JavaScript, you just use the &lt;a href=&quot;../operators/comparison_operators&quot;&gt;less-than and greater-than operators&lt;/a&gt;:</source>
          <target state="translated">C 개발자는 문자열을 비교하기위한 &lt;code&gt;strcmp()&lt;/code&gt; 함수를 가지고 있습니다. JavaScript에서는 &lt;a href=&quot;../operators/comparison_operators&quot;&gt;작거나 큰 연산자&lt;/a&gt; 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd0af9a1d0d1eecdeb1b8b648f9c213b74409baf" translate="yes" xml:space="preserve">
          <source>Calculating Primes</source>
          <target state="translated">소수 계산</target>
        </trans-unit>
        <trans-unit id="1c8b28082cf2210fb50e12c5b438c7c48e487269" translate="yes" xml:space="preserve">
          <source>Calculating elapsed time</source>
          <target state="translated">경과 시간 계산</target>
        </trans-unit>
        <trans-unit id="3deb97bb6737095095f7e93d8c67cbbe7f00b636" translate="yes" xml:space="preserve">
          <source>Calculating the height of an equalateral triangle</source>
          <target state="translated">등각 삼각형의 높이 계산</target>
        </trans-unit>
        <trans-unit id="2cd3c40d7e3c9323d20f88c3334e1f59d6a5bd56" translate="yes" xml:space="preserve">
          <source>Calculating the hypotenuse of a right triangle, or the magnitude of a complex number, uses the formula &lt;code&gt;Math.sqrt(v1*v1 + v2*v2)&lt;/code&gt; where v1 and v2 are either the sides of the triangle, or the real and complex values. For calculating distance in 2 or more dimensions, simply add in more squares inside the square root sign, like &lt;code&gt;Math.sqrt(v1*v1 + v2*v2 + v3*v3&amp;nbsp;+ v4*v4)&lt;/code&gt;.</source>
          <target state="translated">직각 삼각형의 빗변 또는 복소수의 크기를 계산할 때는 수식 &lt;code&gt;Math.sqrt(v1*v1 + v2*v2)&lt;/code&gt; 여기서 v1과 v2는 삼각형의 변이거나 실수와 복소수 값입니다. 2 차원 이상의 거리를 계산하려면 &lt;code&gt;Math.sqrt(v1*v1 + v2*v2 + v3*v3&amp;nbsp;+ v4*v4)&lt;/code&gt; 와 같이 제곱근 기호 안에 더 많은 제곱을 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="35c3b580c4c9bd656b61a8a81be780a8a57bd1e7" translate="yes" xml:space="preserve">
          <source>Calculating the hypotenuse of a right triangle, or the magnitude of a complex number, uses the formula &lt;code&gt;Math.sqrt(v1*v1 + v2*v2)&lt;/code&gt;, where v1 and v2 are the lengths of the triangle's legs, or the complex number's real and complex components. The corresponding distance in 2 or more dimensions can be calculated by adding more squares under the square root: &lt;code&gt;Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)&lt;/code&gt;.</source>
          <target state="translated">직각 삼각형의 빗변 또는 복소수의 크기를 계산할 때는 공식 &lt;code&gt;Math.sqrt(v1*v1 + v2*v2)&lt;/code&gt; . 여기서 v1 및 v2는 삼각형 다리의 길이 또는 복소수의 실수 및 복잡한 구성 요소. 2 차원 이상의 해당 거리는 제곱근 아래에 더 많은 제곱을 추가하여 계산할 수 있습니다. &lt;code&gt;Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75076fa81417b77190b525ebb4267bd890ca6f2b" translate="yes" xml:space="preserve">
          <source>Calendar eras fall under the category of locale key &quot;extension keys&quot;. These keys add additional data about the locale, and are added to locale identifiers by using the &lt;code&gt;-u&lt;/code&gt; extension. Thus, the calendar era type can be added to the inital locale identifier string that is passed into the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Intl.Locale&lt;/code&gt;&lt;/a&gt; constructor. To add the calendar type, first add the &lt;code&gt;-u&lt;/code&gt; extension to the string. Next, add the &lt;code&gt;-ca&lt;/code&gt; extension to indicate that you are adding a calendar type. Finally, add the calendar era to the string.</source>
          <target state="translated">달력 연대는 로케일 키 &quot;확장 키&quot;범주에 속합니다. 이러한 키는 로캘에 대한 추가 데이터를 추가하고 &lt;code&gt;-u&lt;/code&gt; 확장 을 사용하여 로캘 식별자에 추가됩니다 . 따라서 달력 연대 유형은 &lt;a href=&quot;locale&quot;&gt; &lt;code&gt;Intl.Locale&lt;/code&gt; &lt;/a&gt; 생성자에 전달되는 초기 로캘 식별자 문자열에 추가 될 수 있습니다 . 달력 유형을 추가하려면 먼저 문자열에 &lt;code&gt;-u&lt;/code&gt; 확장자를 추가하십시오 . 다음 으로 달력 유형을 추가하고 있음을 나타 내기 위해 &lt;code&gt;-ca&lt;/code&gt; 확장자를 추가합니다. 마지막으로 달력 시대를 문자열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="164d5c54993254a0eebc24327e95935cc50f0011" translate="yes" xml:space="preserve">
          <source>Calendar key (name)</source>
          <target state="translated">캘린더 키 (이름)</target>
        </trans-unit>
        <trans-unit id="00cf770565d7149653e11b20f78127e8ec5a6f73" translate="yes" xml:space="preserve">
          <source>Calendar. Possible values include: &quot;&lt;code&gt;buddhist&lt;/code&gt;&quot;, &quot;&lt;code&gt;chinese&lt;/code&gt;&quot;, &quot; &lt;code&gt;coptic&lt;/code&gt;&quot;, &quot;&lt;code&gt;ethiopia&lt;/code&gt;&quot;, &quot;&lt;code&gt;ethiopic&lt;/code&gt;&quot;, &quot;&lt;code&gt;gregory&lt;/code&gt;&quot;, &quot; &lt;code&gt;hebrew&lt;/code&gt;&quot;, &quot;&lt;code&gt;indian&lt;/code&gt;&quot;, &quot;&lt;code&gt;islamic&lt;/code&gt;&quot;, &quot;&lt;code&gt;iso8601&lt;/code&gt;&quot;, &quot; &lt;code&gt;japanese&lt;/code&gt;&quot;, &quot;&lt;code&gt;persian&lt;/code&gt;&quot;, &quot;&lt;code&gt;roc&lt;/code&gt;&quot;.</source>
          <target state="translated">달력. 가능한 값은 다음과 같습니다 : &quot; &lt;code&gt;buddhist&lt;/code&gt; &quot;, &quot; &lt;code&gt;chinese&lt;/code&gt; &quot;, &quot; &lt;code&gt;coptic&lt;/code&gt; &quot;, &quot; &lt;code&gt;ethiopia&lt;/code&gt; &quot;, &quot; &lt;code&gt;ethiopic&lt;/code&gt; &quot;, &quot; &lt;code&gt;gregory&lt;/code&gt; &quot;, &quot; &lt;code&gt;hebrew&lt;/code&gt; &quot;, &quot; &lt;code&gt;indian&lt;/code&gt; &quot;, &quot; &lt;code&gt;islamic&lt;/code&gt; &quot;, &quot; &lt;code&gt;iso8601&lt;/code&gt; &quot;, &quot; &lt;code&gt;japanese&lt;/code&gt; &quot;, &quot; &lt;code&gt;persian&lt;/code&gt; &quot;,&quot; &lt;code&gt;roc&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="c68c6d5893482d0eb10110f5fe7c2224eb1880f5" translate="yes" xml:space="preserve">
          <source>Calendar. Possible values include: &quot;&lt;code&gt;buddhist&lt;/code&gt;&quot;, &quot;&lt;code&gt;chinese&lt;/code&gt;&quot;, &quot;&lt;code&gt;coptic&lt;/code&gt;&quot;, &quot;&lt;code&gt;ethiopia&lt;/code&gt;&quot;, &quot;&lt;code&gt;ethiopic&lt;/code&gt;&quot;, &quot;&lt;code&gt;gregory&lt;/code&gt;&quot;, &quot;&lt;code&gt;hebrew&lt;/code&gt;&quot;, &quot;&lt;code&gt;indian&lt;/code&gt;&quot;, &quot;&lt;code&gt;islamic&lt;/code&gt;&quot;, &quot;&lt;code&gt;iso8601&lt;/code&gt;&quot;, &quot;&lt;code&gt;japanese&lt;/code&gt;&quot;, &quot;&lt;code&gt;persian&lt;/code&gt;&quot;, &quot;&lt;code&gt;roc&lt;/code&gt;&quot;.</source>
          <target state="translated">달력. 가능한 값은 다음과 같습니다 : &quot; &lt;code&gt;buddhist&lt;/code&gt; &quot;, &quot; &lt;code&gt;chinese&lt;/code&gt; &quot;, &quot; &lt;code&gt;coptic&lt;/code&gt; &quot;, &quot; &lt;code&gt;ethiopia&lt;/code&gt; &quot;, &quot; &lt;code&gt;ethiopic&lt;/code&gt; &quot;, &quot; &lt;code&gt;gregory&lt;/code&gt; &quot;, &quot; &lt;code&gt;hebrew&lt;/code&gt; &quot;, &quot; &lt;code&gt;indian&lt;/code&gt; &quot;, &quot; &lt;code&gt;islamic&lt;/code&gt; &quot;, &quot; &lt;code&gt;iso8601&lt;/code&gt; &quot;, &quot; &lt;code&gt;japanese&lt;/code&gt; &quot;, &quot; &lt;code&gt;persian&lt;/code&gt; &quot;,&quot; &lt;code&gt;roc&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="2b5c53c059f496e27e1159f1dc69b90da7746174" translate="yes" xml:space="preserve">
          <source>Calendar. Possible values include: &lt;code&gt;&quot;buddhist&quot;&lt;/code&gt;, &lt;code&gt;&quot;chinese&quot;&lt;/code&gt;, &lt;code&gt;&quot;coptic&quot;&lt;/code&gt;, &lt;code&gt;&quot;ethioaa&quot;&lt;/code&gt;, &lt;code&gt;&quot;ethiopic&quot;&lt;/code&gt;, &lt;code&gt;&quot;gregory&quot;&lt;/code&gt;, &lt;code&gt;&quot;hebrew&quot;&lt;/code&gt;, &lt;code&gt;&quot;indian&quot;&lt;/code&gt;, &lt;code&gt;&quot;islamic&quot;&lt;/code&gt;, &lt;code&gt;&quot;islamicc&quot;&lt;/code&gt;, &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt;, &lt;code&gt;&quot;japanese&quot;&lt;/code&gt;, &lt;code&gt;&quot;persian&quot;&lt;/code&gt;, &lt;code&gt;&quot;roc&quot;&lt;/code&gt;.</source>
          <target state="translated">달력. 가능한 값은 다음과 같습니다. &lt;code&gt;&quot;buddhist&quot;&lt;/code&gt; , &lt;code&gt;&quot;chinese&quot;&lt;/code&gt; , &lt;code&gt;&quot;coptic&quot;&lt;/code&gt; , &lt;code&gt;&quot;ethioaa&quot;&lt;/code&gt; , &lt;code&gt;&quot;ethiopic&quot;&lt;/code&gt; , &lt;code&gt;&quot;gregory&quot;&lt;/code&gt; , &lt;code&gt;&quot;hebrew&quot;&lt;/code&gt; , &lt;code&gt;&quot;indian&quot;&lt;/code&gt; , &lt;code&gt;&quot;islamic&quot;&lt;/code&gt; , &lt;code&gt;&quot;islamicc&quot;&lt;/code&gt; , &lt;code&gt;&quot;iso8601&quot;&lt;/code&gt; , &lt;code&gt;&quot;japanese&quot;&lt;/code&gt; , &lt;code&gt;&quot;persian&quot;&lt;/code&gt; , &lt;code&gt;&quot;roc&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fbce4777ecf7e4fc72ebe54c4e04060cedde117" translate="yes" xml:space="preserve">
          <source>Call on &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;[object &lt;em&gt;Null&lt;/em&gt;]&lt;/code&gt;, and &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;[object &lt;em&gt;Undefined&lt;/em&gt;]&lt;/code&gt;</source>
          <target state="translated">에 전화 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;[object &lt;em&gt;Null&lt;/em&gt;]&lt;/code&gt; , 그리고 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;[object &lt;em&gt;Undefined&lt;/em&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e186b3d8ff5821b46c8f7369ddda98fc1e0ffed" translate="yes" xml:space="preserve">
          <source>Callable regular expressions were a non-standard addition in some browsers.</source>
          <target state="translated">호출 가능한 정규 표현식은 일부 브라우저에서 비표준 추가입니다.</target>
        </trans-unit>
        <trans-unit id="d5157eb03ac0f1193906f8c156634761b124dd4b" translate="yes" xml:space="preserve">
          <source>Callback syntax</source>
          <target state="translated">콜백 구문</target>
        </trans-unit>
        <trans-unit id="2e460981c486df13f5d0cd1868eb0746a20c9cf2" translate="yes" xml:space="preserve">
          <source>Called on incompatible type</source>
          <target state="translated">호환되지 않는 유형으로 호출</target>
        </trans-unit>
        <trans-unit id="889f0e32311aeca12d2e298ab0f2f76248da8fb8" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;unwatch()&lt;/code&gt; on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; object throws a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; since Firefox 23 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=903332&quot;&gt;bug 903332&lt;/a&gt;). This regression has been fixed with Firefox 27.</source>
          <target state="translated">호출 &lt;code&gt;unwatch()&lt;/code&gt; 상의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 객체는 발생 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 파이어 폭스 (23) (이후 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=903332&quot;&gt;버그 903332을&lt;/a&gt; ). 이 회귀는 Firefox 27에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6575e91d0422fff5661a7b9b7443646d92438f7b" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;watch()&lt;/code&gt; on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; object throws a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; since Firefox 23 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=903332&quot;&gt;bug 903332&lt;/a&gt;). This regression has been fixed with Firefox 27.</source>
          <target state="translated">Firefox 23 이후 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;code&gt;watch()&lt;/code&gt; 를 호출 하면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=903332&quot;&gt;버그 903332&lt;/a&gt; ). 이 회귀는 Firefox 27에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="f42ab521cde0170d0efb7b998bdc09448e1809ac" translate="yes" xml:space="preserve">
          <source>Calling a generator function does not execute its body immediately; an &lt;a href=&quot;../iteration_protocols#iterator&quot;&gt;iterator&lt;/a&gt; object for the function is returned instead. When the iterator's &lt;code&gt;next()&lt;/code&gt; method is called, the generator function's body is executed until the first &lt;a href=&quot;../operators/yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; expression, which specifies the value to be returned from the iterator or, with &lt;a href=&quot;../operators/yield*&quot;&gt;&lt;code&gt;yield*&lt;/code&gt;&lt;/a&gt;, delegates to another generator function. The &lt;code&gt;next()&lt;/code&gt; method returns an object with a &lt;code&gt;value&lt;/code&gt; property containing the yielded value and a &lt;code&gt;done&lt;/code&gt; property which indicates whether the generator has yielded its last value as a boolean. Calling the &lt;code&gt;next()&lt;/code&gt; method with an argument will resume the generator function execution, replacing the &lt;code&gt;yield&lt;/code&gt; expression where execution was paused with the argument from &lt;code&gt;next()&lt;/code&gt;.</source>
          <target state="translated">생성기 함수를 호출해도 본문이 즉시 실행되지는 않습니다. 대신 함수 의 &lt;a href=&quot;../iteration_protocols#iterator&quot;&gt;반복자&lt;/a&gt; 객체가 반환됩니다. 반복자의 &lt;code&gt;next()&lt;/code&gt; 메소드가 호출되면, 첫 번째 &lt;a href=&quot;../operators/yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; 표현식 까지 생성기 함수의 본문이 실행 됩니다.이 표현식은 반복자에서 리턴 될 값을 지정하거나 &lt;a href=&quot;../operators/yield*&quot;&gt; &lt;code&gt;yield*&lt;/code&gt; &lt;/a&gt; 로 다른 생성기 함수에 위임합니다. &lt;code&gt;next()&lt;/code&gt; 메소드는 객체와 반환 &lt;code&gt;value&lt;/code&gt; 수득 된 값 및 속성 함유 &lt;code&gt;done&lt;/code&gt; 발전기 부울로서의 최종 값을 산출 하였는지의 여부를 나타내는 속성. &lt;code&gt;next()&lt;/code&gt; 인수와 함께 메소드를 호출하면 생성기 함수 실행이 재개되어 &lt;code&gt;yield&lt;/code&gt; &lt;code&gt;next()&lt;/code&gt; 의 인수로 실행이 일시 중지 된 yield 식 입니다.</target>
        </trans-unit>
        <trans-unit id="a75b1d81e9b82935964d222b2ad5170a861e55c0" translate="yes" xml:space="preserve">
          <source>Calling a generator function does not execute its body immediately; an &lt;a href=&quot;../iteration_protocols#iterator&quot;&gt;iterator&lt;/a&gt; object for the function is returned instead. When the iterator's &lt;code&gt;next()&lt;/code&gt; method is called, the generator function's body is executed until the first &lt;a href=&quot;../operators/yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt; expression, which specifies the value to be returned from the iterator or, with &lt;a href=&quot;../operators/yield*&quot;&gt;&lt;code&gt;yield*&lt;/code&gt;&lt;/a&gt;, delegates to another generator function. The &lt;code&gt;next()&lt;/code&gt; method returns an object with a &lt;code&gt;value&lt;/code&gt; property containing the yielded value and a &lt;code&gt;done&lt;/code&gt; property which indicates whether the generator has yielded its last value, as a boolean. Calling the &lt;code&gt;next()&lt;/code&gt; method with an argument will resume the generator function execution, replacing the &lt;code&gt;yield&lt;/code&gt; expression where an execution was paused with the argument from &lt;code&gt;next()&lt;/code&gt;.</source>
          <target state="translated">제너레이터 함수를 호출해도 본문이 즉시 실행되지는 않습니다. &lt;a href=&quot;../iteration_protocols#iterator&quot;&gt;반복자&lt;/a&gt; 함수의 객체 대신 반환됩니다. 반복기의 &lt;code&gt;next()&lt;/code&gt; 메서드가 호출되면 생성기 함수의 본문은 반복기에서 반환 될 값을 지정하는 첫 번째 &lt;a href=&quot;../operators/yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; 표현식 까지 실행 되거나 &lt;a href=&quot;../operators/yield*&quot;&gt; &lt;code&gt;yield*&lt;/code&gt; &lt;/a&gt; 를 사용하여 다른 생성기 함수에 위임됩니다. &lt;code&gt;next()&lt;/code&gt; 메소드는 객체와 반환 &lt;code&gt;value&lt;/code&gt; 수득 된 값 및 속성 함유 &lt;code&gt;done&lt;/code&gt; 발전기 부울, 마지막 값을 산출 하였는지의 여부를 나타내는 속성. &lt;code&gt;next()&lt;/code&gt; 호출인수가있는 메서드는 생성기 함수 실행을 재개하여 실행이 일시 중지 된 &lt;code&gt;yield&lt;/code&gt; 표현식을 &lt;code&gt;next()&lt;/code&gt; 의 인수로 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e901561b4a22e5f9eacea38ce285943904d42ddf" translate="yes" xml:space="preserve">
          <source>Calling on &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 을 호출</target>
        </trans-unit>
        <trans-unit id="ea379a24ab68b305d9c0aa33f04920490c92d81b" translate="yes" xml:space="preserve">
          <source>Calling static members from a class constructor and other methods</source>
          <target state="translated">클래스 생성자 및 기타 메서드에서 정적 멤버 호출</target>
        </trans-unit>
        <trans-unit id="b7666378058b0722ea7d905219476325c4b0e543" translate="yes" xml:space="preserve">
          <source>Calling static members from another static method</source>
          <target state="translated">다른 정적 메서드에서 정적 멤버 호출</target>
        </trans-unit>
        <trans-unit id="f1261188c334d4f578f6c32e2f64fa810ffc2511" translate="yes" xml:space="preserve">
          <source>Calling static methods</source>
          <target state="translated">정적 메소드 호출</target>
        </trans-unit>
        <trans-unit id="4af1b3ced70e5598a015a0ed094936bcafe046a5" translate="yes" xml:space="preserve">
          <source>Calls (executes) a function and sets its &lt;em&gt;this&lt;/em&gt; to the provided value, arguments can be passed as they are.</source>
          <target state="translated">함수를 호출 (실행)하고 &lt;em&gt;이를&lt;/em&gt; 제공된 값으로 설정하면 인수를 그대로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2cdf79658501a4a681dd5a5557f58c8403077ee" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;object/tostring&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;object/tostring&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8abcebb38f72b783a3dbe8dcf4f949c70b525c8f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;tostring&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;tostring&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="615b966f8f0c002877179f680de5615470fa4cb0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt; once for each key-value pair present in the &lt;code&gt;Map&lt;/code&gt; object, in insertion order. If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;forEach&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; value for each callback.</source>
          <target state="translated">삽입 순서 에 따라 &lt;code&gt;Map&lt;/code&gt; 객체 에있는 각 키-값 쌍에 대해 &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt; 을 한 번씩 호출 합니다. 경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 의 파라미터가 제공된다 &lt;code&gt;forEach&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 각 콜백 값.</target>
        </trans-unit>
        <trans-unit id="4684663bd20d289a845c569e5f959bd5507b0a37" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt; once for each value present in the &lt;code&gt;Set&lt;/code&gt; object, in insertion order. If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided, it will be used as the &lt;code&gt;this&lt;/code&gt; value for each invocation of &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">삽입 순서대로 &lt;code&gt;Set&lt;/code&gt; 개체 에있는 각 값에 대해 &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt; 을 한 번씩 호출 합니다. 경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 의 파라미터가 제공되고, 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 각각의 호출에 대한 값 &lt;code&gt;&lt;var&gt;callbackFn&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43fa8d127c1ffbb91af039b977d206cfbf6ac83b" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;callbackFn&lt;/code&gt; once for each value present in the &lt;code&gt;Set&lt;/code&gt; object, in insertion order. If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;forEach&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; value for each callback.</source>
          <target state="translated">삽입 순서대로 &lt;code&gt;Set&lt;/code&gt; 객체 에있는 각 값에 대해 &lt;code&gt;callbackFn&lt;/code&gt; 을 한 번 호출 합니다. 경우 &lt;code&gt;thisArg&lt;/code&gt; 의 파라미터가 제공된다 &lt;code&gt;forEach&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 각 콜백 값.</target>
        </trans-unit>
        <trans-unit id="3594748321e62e7bdbb192e86808f906b02d35c2" translate="yes" xml:space="preserve">
          <source>Calls a &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; function with arguments as specified by the &lt;code&gt;&lt;var&gt;argumentsList&lt;/var&gt;&lt;/code&gt; parameter. See also &lt;a href=&quot;function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;argumentsList&lt;/var&gt;&lt;/code&gt; 매개 변수에 지정된 인수를 사용 하여 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 함수를 호출합니다 . &lt;a href=&quot;function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d2cac206f8f3b6e52ce7731524dfbd26e537e1e" translate="yes" xml:space="preserve">
          <source>Calls a function and sets its &lt;code&gt;this&lt;/code&gt; to the provided &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt;. Arguments can be passed as an &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">함수를 호출하고 &lt;code&gt;this&lt;/code&gt; 를 제공된 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 로 설정 합니다. 인수는 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 객체 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5d0058f8e1cbf4b92fd726f1a826ae92e591626" translate="yes" xml:space="preserve">
          <source>Calls a function and sets its &lt;code&gt;this&lt;/code&gt; to the provided value. Arguments can be passed as they are.</source>
          <target state="translated">함수를 호출하고 &lt;code&gt;this&lt;/code&gt; 를 제공된 값으로 설정 합니다. 인수는 그대로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f7549cf84d65e8e7769e045872eccc8294d6e4" translate="yes" xml:space="preserve">
          <source>Calls a function and sets its &lt;em&gt;this&lt;/em&gt; to the provided value, arguments can be passed as an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">함수를 호출하고 &lt;em&gt;이를&lt;/em&gt; 제공된 값으로 설정하면 인수를 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 객체 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b09d006bb82d5a4c264605f63a1bd10e28dc317" translate="yes" xml:space="preserve">
          <source>Calls a function and sets its &lt;em&gt;this&lt;/em&gt; to the provided value, arguments can be passed as an &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">함수를 호출하고 &lt;em&gt;이를&lt;/em&gt; 제공된 값으로 설정하면 인수를 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 객체 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0e0146189882ee8e04fff56d3944d2d03acdb88" translate="yes" xml:space="preserve">
          <source>Calls a function for each element in the array.</source>
          <target state="translated">배열의 각 요소에 대한 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b4e174aca340d974eda375094f3873ba6f49a1de" translate="yes" xml:space="preserve">
          <source>Calls a function for each element in the array. See also &lt;a href=&quot;../array/foreach&quot;&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 각 요소에 대한 함수를 호출합니다. &lt;a href=&quot;../array/foreach&quot;&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fca1c9d7e964ddedab04d30530ab836310a60c9e" translate="yes" xml:space="preserve">
          <source>Calls a function for each element in the array. See also &lt;a href=&quot;array/foreach&quot;&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 각 요소에 대한 함수를 호출합니다. &lt;a href=&quot;array/foreach&quot;&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="212f094d04a22c9ac2e2bbf28e3e6aa87dd373e3" translate="yes" xml:space="preserve">
          <source>Calls a target function with arguments as specified by the &lt;code&gt;args&lt;/code&gt; parameter. See also &lt;a href=&quot;function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 매개 변수 로 지정된 인수를 사용하여 대상 함수를 호출합니다 . &lt;a href=&quot;function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96510284b9c7d34dfc5d4219cb5ed3647d47d48b" translate="yes" xml:space="preserve">
          <source>Calls callbackFn once for each key-value pair present in the &lt;code&gt;Map&lt;/code&gt; object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 객체 에있는 각 키-값 쌍마다 삽입 순서로 callbackFn을 한 번 호출 합니다. thisArg 매개 변수가 forEach에 제공되면 각 콜백에 대한 this 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcb6937ffe306468d9d6341f2c2b0711cb864cb" translate="yes" xml:space="preserve">
          <source>Can I put a &lt;code&gt;default&lt;/code&gt; between cases?</source>
          <target state="translated">케이스 사이 에 &lt;code&gt;default&lt;/code&gt; 둘 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="193f9932fdf9edf2457858d4680968cd3cdbdc42" translate="yes" xml:space="preserve">
          <source>Can I put a default between cases?</source>
          <target state="translated">사례간에 기본값을 지정할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="69ec9025ffcb602ac7cb3c0b98a529f094fa30eb" translate="yes" xml:space="preserve">
          <source>Can be converted to:</source>
          <target state="translated">로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="772956de60ed5504e26d8561e1c902e102b0db98" translate="yes" xml:space="preserve">
          <source>Can not be used as &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/constructor&quot;&gt;constructors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/constructor&quot;&gt;constructors&lt;/a&gt;&lt;/code&gt; 로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a03c4726a68aa3c5301aaef47f2e386ce661c57e" translate="yes" xml:space="preserve">
          <source>Can not use &lt;code&gt;&lt;a href=&quot;../operators/yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt;, within its body.</source>
          <target state="translated">본문 내에서 &lt;code&gt;&lt;a href=&quot;../operators/yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="857d5f648425a0efc56254b89efdbfc0c12bb65f" translate="yes" xml:space="preserve">
          <source>Candidate (3)</source>
          <target state="translated">후보자 (3)</target>
        </trans-unit>
        <trans-unit id="a7f5e4b809d5399b107f212ff2236558b40af3f2" translate="yes" xml:space="preserve">
          <source>Cannot change the value of a property to be different from the value of the corresponding target object property if the corresponding target object property is a non-writable, non-configurable data property.</source>
          <target state="translated">해당 대상 개체 속성이 쓸 수없고 구성 할 수없는 데이터 속성 인 경우 속성 값을 해당 대상 개체 속성 값과 다르게 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61491dd9dad40acf2792466281a6621448536cf7" translate="yes" xml:space="preserve">
          <source>Cannot set the value of a property if the corresponding target object property is a non-configurable accessor property that has &lt;code&gt;undefined&lt;/code&gt; as its &lt;code&gt;[[Set]]&lt;/code&gt; attribute.</source>
          <target state="translated">해당 대상 객체 속성이있는 비 접근 구성 속성 인 경우 속성 값을 설정할 수 없다 &lt;code&gt;undefined&lt;/code&gt; 의로 &lt;code&gt;[[Set]]&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="5227cc47318ced556addb0fb0570438b92aa0b4d" translate="yes" xml:space="preserve">
          <source>Cannot set the value of a property if the corresponding target object property is a non-configurable accessor property that has &lt;code&gt;undefined&lt;/code&gt; as its [[Set]] attribute.</source>
          <target state="translated">해당 대상 개체 속성이 [[Set]] 특성으로 &lt;code&gt;undefined&lt;/code&gt; 구성 할 수없는 접근 자 속성 인 경우 속성 값을 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="80571b58aaaeb0b704cda407a24b8a006fd1aa06" translate="yes" xml:space="preserve">
          <source>Canonical Decomposition, followed by Canonical Composition.</source>
          <target state="translated">정식 분해, 정식 구성이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="877dfd797913376f8e15c59bf278932d979a66a4" translate="yes" xml:space="preserve">
          <source>Canonical Decomposition.</source>
          <target state="translated">정규 분해.</target>
        </trans-unit>
        <trans-unit id="fb1512e3e8f1f68c04addc04ef3bd4a5eae6dbd7" translate="yes" xml:space="preserve">
          <source>Canonical equivalence normalization</source>
          <target state="translated">정규 동등성 정규화</target>
        </trans-unit>
        <trans-unit id="8db520a3f09f2b998ddd13d07e46b10c70323685" translate="yes" xml:space="preserve">
          <source>Cant access lexical declaration before init</source>
          <target state="translated">init 이전의 캔트 액세스 어휘 선언</target>
        </trans-unit>
        <trans-unit id="ceb052af6694338d4ca7f970e15c5e474e927257" translate="yes" xml:space="preserve">
          <source>Cant access property</source>
          <target state="translated">캔트 액세스 속성</target>
        </trans-unit>
        <trans-unit id="6cddf0ea095f935a5dfdfa4a63cb8bc6c2683704" translate="yes" xml:space="preserve">
          <source>Cant define property object not extensible</source>
          <target state="translated">캔트 정의 속성 개체를 확장 할 수 없음</target>
        </trans-unit>
        <trans-unit id="64d8bae6685aa9295032aec1eb9e7127a8dffd66" translate="yes" xml:space="preserve">
          <source>Cant delete</source>
          <target state="translated">캔트 삭제</target>
        </trans-unit>
        <trans-unit id="53fda823e63c79adb65308d70cd1e546ca255fa1" translate="yes" xml:space="preserve">
          <source>Cant redefine property</source>
          <target state="translated">캔트 재정의</target>
        </trans-unit>
        <trans-unit id="4c0d1ab046c23f4c05e3fe4fe963a156b88fcceb" translate="yes" xml:space="preserve">
          <source>Capture groups are ignored when using &lt;a href=&quot;match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; with the global &lt;code&gt;/g&lt;/code&gt; flag:</source>
          <target state="translated">전역 &lt;code&gt;/g&lt;/code&gt; 플래그 와 함께 &lt;a href=&quot;match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 를 사용할 때 캡처 그룹은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e7e04a65fbbef1ea666ad8824dca1fa4c12a8e7" translate="yes" xml:space="preserve">
          <source>Capturing groups</source>
          <target state="translated">그룹 캡처</target>
        </trans-unit>
        <trans-unit id="968a449286e7dba99d61444f2f3c3b4ce94286e4" translate="yes" xml:space="preserve">
          <source>Capturing groups have a performance penalty. If you don't need the matched substring to be recalled, prefer non-capturing parentheses (see below).</source>
          <target state="translated">캡처 그룹은 성능이 저하됩니다. 일치하는 부분 문자열을 불러올 필요가 없으면 캡처되지 않은 괄호를 선호하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="159392d633c2cffbc6a491daf2bedda249a234bf" translate="yes" xml:space="preserve">
          <source>Carriage Return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="37160635d7fcea80b889e50c530839adfee56375" translate="yes" xml:space="preserve">
          <source>Case folding is implemented in version 13</source>
          <target state="translated">케이스 폴딩은 버전 13에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="0f3ded69256e3963f4a988788ac30cda1f845698" translate="yes" xml:space="preserve">
          <source>Case folding is implemented in version 8.6.0</source>
          <target state="translated">케이스 접기는 버전 8.6.0에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d40586098bcb31c0615249ab2992b8cddbf26177" translate="yes" xml:space="preserve">
          <source>Case-insensitive search.</source>
          <target state="translated">대소 문자를 구분하지 않는 검색.</target>
        </trans-unit>
        <trans-unit id="42a4f5b1edd00e96ccdcd395b8d7ad27fdb67d58" translate="yes" xml:space="preserve">
          <source>Case-sensitivity</source>
          <target state="translated">Case-sensitivity</target>
        </trans-unit>
        <trans-unit id="fc1abe74bd4ac1d8b2552132bda2e7eda851c06c" translate="yes" xml:space="preserve">
          <source>Catching a &lt;code&gt;ReferenceError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ReferenceError&lt;/code&gt; 잡기</target>
        </trans-unit>
        <trans-unit id="ae22123a234e448c41ac11520930d854ff6f6c53" translate="yes" xml:space="preserve">
          <source>Catching a &lt;code&gt;SyntaxError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SyntaxError&lt;/code&gt; 잡기</target>
        </trans-unit>
        <trans-unit id="a67f726138638a207f598c0a8d70a3a5cd069f26" translate="yes" xml:space="preserve">
          <source>Catching a &lt;code&gt;TypeError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TypeError&lt;/code&gt; 잡기</target>
        </trans-unit>
        <trans-unit id="04402809781943ccfc6c9cfaf50df6c3961bf23d" translate="yes" xml:space="preserve">
          <source>Catching a ReferenceError</source>
          <target state="translated">ReferenceError 잡기</target>
        </trans-unit>
        <trans-unit id="5edd9bc4aa66a56f3c2d894fe68f1e141b7b6c29" translate="yes" xml:space="preserve">
          <source>Catching a SyntaxError</source>
          <target state="translated">SyntaxError 잡기</target>
        </trans-unit>
        <trans-unit id="eeb17c4d826a75dd22a9e18dd874ccd7c77023fa" translate="yes" xml:space="preserve">
          <source>Catching a TypeError</source>
          <target state="translated">TypeError 잡기</target>
        </trans-unit>
        <trans-unit id="66b684e76a6cbe5d74c7bf8d68a3d7ce0fbf9a7b" translate="yes" xml:space="preserve">
          <source>Catching an &lt;code&gt;URIError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;URIError&lt;/code&gt; 잡기</target>
        </trans-unit>
        <trans-unit id="272301279dff8c9e5afdae1cb7d22c840919d746" translate="yes" xml:space="preserve">
          <source>Catching an AggregateError</source>
          <target state="translated">AggregateError 잡기</target>
        </trans-unit>
        <trans-unit id="0d74940232cfc4f01ef267ce26fa5c668400a878" translate="yes" xml:space="preserve">
          <source>Catching an URIError</source>
          <target state="translated">URIError 잡기</target>
        </trans-unit>
        <trans-unit id="9417ed24965e3b15bb78730b447c82b48c97f1e0" translate="yes" xml:space="preserve">
          <source>Catching errors</source>
          <target state="translated">잡기 오류</target>
        </trans-unit>
        <trans-unit id="0e8f0f0fd420495e939a7cfe7aa1cb89f252cd29" translate="yes" xml:space="preserve">
          <source>Chained Promises</source>
          <target state="translated">연결된 약속</target>
        </trans-unit>
        <trans-unit id="480bd17189258d07915ad129dccf24a948c44df7" translate="yes" xml:space="preserve">
          <source>Chaining</source>
          <target state="translated">Chaining</target>
        </trans-unit>
        <trans-unit id="afb6cfa111e784e9b1307fa3011033d8673fb57c" translate="yes" xml:space="preserve">
          <source>Chaining function calls</source>
          <target state="translated">체이닝 함수 호출</target>
        </trans-unit>
        <trans-unit id="84b23927b8ac4bbc76f034cc852eed2298496624" translate="yes" xml:space="preserve">
          <source>Chakma digits</source>
          <target state="translated">차크 마 숫자</target>
        </trans-unit>
        <trans-unit id="9e16e3399456889de8fe3a9cf3f5214520758871" translate="yes" xml:space="preserve">
          <source>Cham digits</source>
          <target state="translated">참 숫자</target>
        </trans-unit>
        <trans-unit id="83805dad481f8eda906be98799a52ec52fd9332a" translate="yes" xml:space="preserve">
          <source>Change to &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 변경</target>
        </trans-unit>
        <trans-unit id="4bae4c84ac55b0db3e5795375e15e78d0ec525e5" translate="yes" xml:space="preserve">
          <source>Changed that generator methods should also not have a [[Construct]] trap and will throw when used with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">생성기 메소드에도 [[Construct]] 트랩이 없어야하며 &lt;code&gt;new&lt;/code&gt; 와 함께 사용될 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="479e48122230cd898c40b37870004b3ac000fde5" translate="yes" xml:space="preserve">
          <source>Changed that generators should not have [[Construct]] trap and will throw when used with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">발전기에 [[Construct]] 트랩이 없어야하고 &lt;code&gt;new&lt;/code&gt; 와 함께 사용될 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1bb3f9f06e25e53e48e9b120b80f043fa26acda1" translate="yes" xml:space="preserve">
          <source>Changes in strict mode</source>
          <target state="translated">엄격 모드의 변경</target>
        </trans-unit>
        <trans-unit id="e92beb6824637c63ce2f1c3b59d875dc39b4b038" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;code&gt;Object&lt;/code&gt; prototype object are seen by &lt;strong&gt;all&lt;/strong&gt; objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 프로토 타입 객체 에 대한 변경 사항 은 프로토 타입 체인을 통해 &lt;strong&gt;모든&lt;/strong&gt; 객체에서 볼 수 있습니다 . 단, 이러한 변경이 적용되는 속성과 메서드가 프로토 타입 체인을 따라 재정의되지 않는 한. 이는 객체 동작을 재정의하거나 확장하는 잠재적으로 위험한 메커니즘이지만 매우 강력합니다.</target>
        </trans-unit>
        <trans-unit id="1dc0b26d4bf7240f67754c1adcd01a4c7445afc2" translate="yes" xml:space="preserve">
          <source>Changing the constructor of a function</source>
          <target state="translated">함수 생성자 변경</target>
        </trans-unit>
        <trans-unit id="d0cf536bc57d40a4f5a94263457fbe66091624f5" translate="yes" xml:space="preserve">
          <source>Changing the constructor of an object</source>
          <target state="translated">객체의 생성자 변경</target>
        </trans-unit>
        <trans-unit id="cb6cc576576581f057ef011656a91eaaca063dbf" translate="yes" xml:space="preserve">
          <source>Chapter about JavaScript classes introduced in ECMAScript 2015.</source>
          <target state="translated">ECMAScript 2015에 도입 된 JavaScript 클래스에 관한 장.</target>
        </trans-unit>
        <trans-unit id="63c9a66eb6c66063b1b10fe8596c803c58cbd60d" translate="yes" xml:space="preserve">
          <source>Chapter about JavaScript functions.</source>
          <target state="translated">JavaScript 함수에 관한 장.</target>
        </trans-unit>
        <trans-unit id="60668b1994544deb729e910abf30842b6407c838" translate="yes" xml:space="preserve">
          <source>Chapter about JavaScript version history.</source>
          <target state="translated">JavaScript 버전 기록에 관한 장.</target>
        </trans-unit>
        <trans-unit id="423fe430ed25af9d3fa6a149b31770b5ad11826d" translate="yes" xml:space="preserve">
          <source>Chapter about specific errors, exceptions and warnings thrown by JavaScript.</source>
          <target state="translated">JavaScript에 의해 발생 된 특정 오류, 예외 및 경고에 대한 장.</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="89a0d26064c88761be4481b9b52065531e5e024c" translate="yes" xml:space="preserve">
          <source>Character Classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="0e7c11d7a7200a36005057b0e953e12aae6033f0" translate="yes" xml:space="preserve">
          <source>Character Sets</source>
          <target state="translated">문자 세트</target>
        </trans-unit>
        <trans-unit id="45c55510b8e6ddea96a28172e7f341683b02bdc7" translate="yes" xml:space="preserve">
          <source>Character access</source>
          <target state="translated">캐릭터 액세스</target>
        </trans-unit>
        <trans-unit id="536f0f1015299e73ab8379e221c9a9f5233e3f04" translate="yes" xml:space="preserve">
          <source>Character tabulation</source>
          <target state="translated">문자표</target>
        </trans-unit>
        <trans-unit id="67b1bbfc35c89d4dcc994be3e6c61f07a3fd9429" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called &lt;code&gt;stringName&lt;/code&gt; is &lt;code&gt;stringName.length - 1&lt;/code&gt;. If the &lt;code&gt;index&lt;/code&gt; you supply is out of this range, JavaScript returns an empty string.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 색인됩니다. 첫 번째 문자의 색인은 0이고 &lt;code&gt;stringName&lt;/code&gt; 이라는 문자열에서 마지막 문자의 색인 은 &lt;code&gt;stringName.length - 1&lt;/code&gt; 입니다. 제공 한 &lt;code&gt;index&lt;/code&gt; 이이 범위를 벗어나면 JavaScript는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3a430bf0019fde9e5035e898a80f9a9a264979e" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character is &lt;code&gt;str.length - 1&lt;/code&gt;.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 색인됩니다. 첫 번째 문자의 색인은 0이고 마지막 문자의 색인은 &lt;code&gt;str.length - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35117224c0b2f55971d08a800cf983c9401503a4" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character of a string called &lt;code&gt;stringName&lt;/code&gt; is &lt;code&gt;stringName.length - 1&lt;/code&gt;.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 색인됩니다. 첫 번째 문자의 색인은 0이고 &lt;code&gt;stringName&lt;/code&gt; 이라는 문자열의 마지막 문자의 색인 은 &lt;code&gt;stringName.length - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3696b5e78c0dffcae6e7eaf0428b1d94aed98132" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is &lt;code&gt;0&lt;/code&gt;, and the index of the last character is &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length - 1&lt;/code&gt;.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 인덱싱됩니다. 첫 번째 문자의 인덱스는 &lt;code&gt;0&lt;/code&gt; 이고 마지막 문자의 인덱스는 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2caaa9704db83aeed48dbfe94ff30de8a659365c" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is &lt;code&gt;0&lt;/code&gt;, and the index of the last character of a string called &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;&lt;/code&gt; is &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;.length - 1&lt;/code&gt;.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 인덱싱됩니다. 첫 번째 문자의 인덱스는 &lt;code&gt;0&lt;/code&gt; 이고 &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;&lt;/code&gt; 이라는 문자열의 마지막 문자 인덱스 는 &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;.length - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0c9af5fa1238c13a5e4c6073e20c38fab650935" translate="yes" xml:space="preserve">
          <source>Characters in a string are indexed from left to right. The index of the first character is &lt;code&gt;0&lt;/code&gt;, and the index of the last character&amp;mdash;in a string called &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;&lt;/code&gt;&amp;mdash;is &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;.length - 1&lt;/code&gt;. If the &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; you supply is out of this range, JavaScript returns an empty string.</source>
          <target state="translated">문자열의 문자는 왼쪽에서 오른쪽으로 인덱싱됩니다. 첫 번째 문자의 인덱스는 &lt;code&gt;0&lt;/code&gt; , 마지막 문자의 문자열의 인덱스라는 &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;&lt;/code&gt; -is &lt;code&gt;&lt;var&gt;stringName&lt;/var&gt;.length - 1&lt;/code&gt; . 제공 한 &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; 이이 범위를 벗어나면 JavaScript는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0170a1fee39ff37af419f1b3ee3ae3fea96051d3" translate="yes" xml:space="preserve">
          <source>Check browser support for extended arguments</source>
          <target state="translated">확장 인수에 대한 브라우저 지원 확인</target>
        </trans-unit>
        <trans-unit id="25068dcc83b92a8b7e8ef58133df57f8ff115074" translate="yes" xml:space="preserve">
          <source>Check if you are in the correct scope. Should this constant appear in this scope or was it meant to appear in a function, for example?</source>
          <target state="translated">올바른 범위에 있는지 확인하십시오. 이 상수가이 범위에 나타나야합니까 아니면 예를 들어 함수에 나타나야합니까?</target>
        </trans-unit>
        <trans-unit id="01525f626a795bc22815e04a455bae77bfb137c2" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_Compatibility&quot;&gt;Browser compatibility&lt;/a&gt; section to see which browsers support the &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments, and &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;Checking for support for &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments&lt;/a&gt; for feature detection.</source>
          <target state="translated">&lt;code&gt;locales&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 인수를 지원하는 브라우저 &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;와&lt;/a&gt; 기능 감지를 위한 &lt;code&gt;locales&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 인수 지원을 확인하려면 &lt;a href=&quot;#Browser_Compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7a65cc5d2df77be22c6b275f9c4817bb0a5efc7" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_Compatibility&quot;&gt;Browser compatibility&lt;/a&gt; section to see which browsers support the &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments, and the &lt;a href=&quot;#Example:_Checking_for_support_for_locales_and_options_arguments&quot;&gt;Example: Checking for support for &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments&lt;/a&gt; for feature detection.</source>
          <target state="translated">체크 &lt;a href=&quot;#Browser_Compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 브라우저가 지원하는 참조 섹션을 &lt;code&gt;locales&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인수 및 &lt;a href=&quot;#Example:_Checking_for_support_for_locales_and_options_arguments&quot;&gt;지원에 대한 확인 : 예를 &lt;code&gt;locales&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인수&lt;/a&gt; 특징 검출합니다.</target>
        </trans-unit>
        <trans-unit id="245374780def29c61ce1165c1fdbe13bc3583f38" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility table&lt;/a&gt; carefully before using this in production.</source>
          <target state="translated">프로덕션 환경에서 사용하기 전에 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성 표를&lt;/a&gt; 주의 해서 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="48cf3564e854e04d30104437ef4e3e4d44f37cb2" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; section to see which browsers support the &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments, and &lt;a href=&quot;#Check_browser_support_for_extended_arguments&quot;&gt;Check browser support for extended arguments&lt;/a&gt; for feature detection.</source>
          <target state="translated">체크 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 지원되는 브라우저를 참조 섹션을 &lt;code&gt;locales&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인수 및 &lt;a href=&quot;#Check_browser_support_for_extended_arguments&quot;&gt;확장 인수 브라우저 지원 확인&lt;/a&gt; 기능을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="f80c9d0733b71fdc9860c7dbe39fec2c83bba5d7" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; section to see which browsers support the &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments, and the &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;Example: Checking for support for &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments&lt;/a&gt; for feature detection.</source>
          <target state="translated">체크 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 브라우저가 지원하는 참조 섹션을 &lt;code&gt;locales&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인수 및 &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;지원에 대한 확인 : 예를 &lt;code&gt;locales&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 인수&lt;/a&gt; 특징 검출합니다.</target>
        </trans-unit>
        <trans-unit id="0429fb6eeb4e98571016558b14e9f2c0b1253bc9" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; section to see which browsers support the &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments, and the Example: &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;Checking for support for locales and options arguments&lt;/a&gt; for feature detection.</source>
          <target state="translated">체크 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 브라우저가 지원하는 참조 섹션을 &lt;code&gt;locales&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; : 인수하고, 예를 &lt;a href=&quot;#Checking_for_support_for_locales_and_options_arguments&quot;&gt;로케일과 옵션 인수에 대한 지원 확인&lt;/a&gt; 기능을 감지.</target>
        </trans-unit>
        <trans-unit id="4867d558aef432b9d28dac1b27502e619090fc40" translate="yes" xml:space="preserve">
          <source>Check to ensure the previous lines / declaration does not end with a comma instead of a semi-colon.</source>
          <target state="translated">이전 줄 / 선언이 세미콜론 대신 쉼표로 끝나지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ad7d828d07110519d233bc6d31f6990d2639286b" translate="yes" xml:space="preserve">
          <source>Checking for support for &lt;code&gt;locales&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; arguments</source>
          <target state="translated">&lt;code&gt;locales&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 인수에 대한 지원 확인</target>
        </trans-unit>
        <trans-unit id="c830fd591c56ff15f9230ea09e1297b1b745b2fa" translate="yes" xml:space="preserve">
          <source>Checking for support for locales and options arguments</source>
          <target state="translated">로케일 및 옵션 인수에 대한 지원 확인</target>
        </trans-unit>
        <trans-unit id="8c9a5804172e6be2b4b01d8ac43b740c1002d8b3" translate="yes" xml:space="preserve">
          <source>Checking if an object is dead</source>
          <target state="translated">물체가 죽었는지 확인</target>
        </trans-unit>
        <trans-unit id="b8c65930befa58265ea2e6b8c3ed29591458c85f" translate="yes" xml:space="preserve">
          <source>Checking if property definition has been successful</source>
          <target state="translated">속성 정의가 성공적인지 확인</target>
        </trans-unit>
        <trans-unit id="70029cb4f538112f0598c035cff6dcd78d29f471" translate="yes" xml:space="preserve">
          <source>Checking occurrences</source>
          <target state="translated">발생 확인</target>
        </trans-unit>
        <trans-unit id="13ebc3aee732bbc914165b97900a2dd6e93e9aa0" translate="yes" xml:space="preserve">
          <source>Checking the instance of an object</source>
          <target state="translated">개체의 인스턴스 확인</target>
        </trans-unit>
        <trans-unit id="5f454490cc91645af52114ab06a59db098cfbbb7" translate="yes" xml:space="preserve">
          <source>Checking the value of a function's &lt;code&gt;caller&lt;/code&gt; property</source>
          <target state="translated">함수의 &lt;code&gt;caller&lt;/code&gt; 속성 값 확인</target>
        </trans-unit>
        <trans-unit id="d784f9079d0b1ed3546113c218b2b80cdd4b5940" translate="yes" xml:space="preserve">
          <source>Checking whether a value exists in an array</source>
          <target state="translated">배열에 값이 있는지 확인</target>
        </trans-unit>
        <trans-unit id="742e78f3e91fee3483ddd25bf992577b5ea16c43" translate="yes" xml:space="preserve">
          <source>Checking whether a value exists using an arrow function</source>
          <target state="translated">화살표 기능을 사용하여 값이 존재하는지 확인</target>
        </trans-unit>
        <trans-unit id="e6694cfbbafef813e8f957ea844523dcc8fc9359" translate="yes" xml:space="preserve">
          <source>Checking whether values are numeric</source>
          <target state="translated">값이 숫자인지 확인</target>
        </trans-unit>
        <trans-unit id="218e75c7a912404b048fff0747e40108873b6334" translate="yes" xml:space="preserve">
          <source>Chrome</source>
          <target state="translated">Chrome</target>
        </trans-unit>
        <trans-unit id="7a65851cb092c55a9c0f7d28ab0033b657820895" translate="yes" xml:space="preserve">
          <source>Chrome 37 (and below) has a &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=3448&quot;&gt;bug&lt;/a&gt; where an attempt to define a &quot;prototype&quot; property, on a function, with &lt;code&gt;writable: false&lt;/code&gt; doesn't work as expected.</source>
          <target state="translated">Chrome 37 (이하)에는 &lt;code&gt;writable: false&lt;/code&gt; 로 함수에서 &quot;prototype&quot;속성을 정의하려는 시도가 예상대로 작동하지 않는 &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=3448&quot;&gt;버그&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca75d529d9e37ce916254ef4065840afe16cb6c" translate="yes" xml:space="preserve">
          <source>Chrome 37 (and below) specific notes</source>
          <target state="translated">Chrome 37 (이하) 관련 참고 사항</target>
        </trans-unit>
        <trans-unit id="1bc76fcce779da9b7294b7917bea607eed2865c4" translate="yes" xml:space="preserve">
          <source>Chrome disabled &lt;code&gt;SharedArrayBuffer&lt;/code&gt; on January 5, 2018 to help reduce the efficacy of &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;speculative side-channel attacks&lt;/a&gt;. This is intended as a temporary measure until other mitigations are in place.</source>
          <target state="translated">Chrome 은 2018 년 1 월 5 일에 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 를 비활성화 하여 &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;추론 적 사이드 채널 공격&lt;/a&gt; 의 효과를 줄였습니다 . 이는 다른 완화 조치가 취해질 때까지 임시 조치로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f46551e1ef3a452fa46817707b191c83ac38094f" translate="yes" xml:space="preserve">
          <source>Chrome disabled &lt;code&gt;SharedArrayBuffer&lt;/code&gt; on January 5, 2018 to help reduce the efficacy of &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;speculative side-channel attacks&lt;/a&gt;. This was a temporary removal while mitigations were put in place.</source>
          <target state="translated">Chrome 은 2018 년 1 월 5 일에 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 를 비활성화 하여 &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;추론 적 사이드 채널 공격&lt;/a&gt; 의 효과를 줄였습니다 . 완화 조치를 취하는 동안 이것은 일시적으로 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="5ce37c3b8bf3a38ca7fcfbb76e8e28879d0100bb" translate="yes" xml:space="preserve">
          <source>Chrome disabled SharedArrayBuffer on January 5, 2018 to help reduce the efficacy of &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;speculative side-channel attacks&lt;/a&gt;. This is intended as a temporary measure until other mitigations are in place.</source>
          <target state="translated">Chrome은 2018 년 1 월 5 일에 SharedArrayBuffer를 비활성화하여 &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;추론 적 사이드 채널 공격&lt;/a&gt; 의 효과를 줄였습니다 . 이는 다른 완화 조치가 취해질 때까지 임시 조치로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a98d66902acd22fd0965bfed20780ce505de06f9" translate="yes" xml:space="preserve">
          <source>Chrome disabled SharedArrayBuffer on January 5, 2018 to help reduce the efficacy of &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;speculative side-channel attacks&lt;/a&gt;. This was a temporary removal while mitigations were put in place.</source>
          <target state="translated">Chrome은 2018 년 1 월 5 일에 SharedArrayBuffer를 비활성화하여 &lt;a href=&quot;https://www.chromium.org/Home/chromium-security/ssca&quot;&gt;추론 적 사이드 채널 공격&lt;/a&gt; 의 효과를 줄였습니다 . 완화 조치를 취하는 동안 이것은 일시적으로 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="d099f88b010d4398cebebe8e633ffe4874c4aa01" translate="yes" xml:space="preserve">
          <source>Chrome for Android</source>
          <target state="translated">Android 용 Chrome</target>
        </trans-unit>
        <trans-unit id="8bb70606465f092dbcf7df43444ff3988b46dce4" translate="yes" xml:space="preserve">
          <source>Chrome intends to implement similar restrictions.</source>
          <target state="translated">Chrome은 유사한 제한을 구현하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1ad6eacf907a8e577b51ed2386597a7f6f70f9d7" translate="yes" xml:space="preserve">
          <source>Chrome, Opera (V8)</source>
          <target state="translated">크롬, 오페라 (V8)</target>
        </trans-unit>
        <trans-unit id="1b7351d5a86a31280da0f41dc40b7ceed76e184e" translate="yes" xml:space="preserve">
          <source>Circular references</source>
          <target state="translated">순환 참조</target>
        </trans-unit>
        <trans-unit id="25d69c8bf262c3599a03918a1039906fcc6fa1c4" translate="yes" xml:space="preserve">
          <source>Civil (algorithmic) Arabic calendar</source>
          <target state="translated">시민 (알고리즘) 아랍어 달력</target>
        </trans-unit>
        <trans-unit id="ec03a926866f57741f7a227b4d38f9ebb70d4c1f" translate="yes" xml:space="preserve">
          <source>Class body and method definitions</source>
          <target state="translated">클래스 본문 및 메소드 정의</target>
        </trans-unit>
        <trans-unit id="a63af16b434d9e15731c58d422c6d699bcd88cab" translate="yes" xml:space="preserve">
          <source>Class constructor</source>
          <target state="translated">클래스 생성자</target>
        </trans-unit>
        <trans-unit id="b962feed9b53d905a946d8343f4d11fa49293614" translate="yes" xml:space="preserve">
          <source>Class context</source>
          <target state="translated">클래스 컨텍스트</target>
        </trans-unit>
        <trans-unit id="40c69a9ab1aa40a9a4ae362841d5877c79410c42" translate="yes" xml:space="preserve">
          <source>Class declaration</source>
          <target state="translated">클래스 선언</target>
        </trans-unit>
        <trans-unit id="92812dbecd62945462d6707495446285d5a7ed58" translate="yes" xml:space="preserve">
          <source>Class declarations</source>
          <target state="translated">클래스 선언</target>
        </trans-unit>
        <trans-unit id="cadac57d671500e625355754fa346cbd8408f86f" translate="yes" xml:space="preserve">
          <source>Class declarations are not &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;hoisted&lt;/a&gt; (unlike &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt;).</source>
          <target state="translated">클래스 선언은 &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 과 달리 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;게양&lt;/a&gt; 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8c8e9baf3d5df03d5a58efdb1ddf8367cb56c047" translate="yes" xml:space="preserve">
          <source>Class error: too much recursion</source>
          <target state="translated">클래스 오류 : 너무 많은 재귀</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">클래스 표현</target>
        </trans-unit>
        <trans-unit id="21a6483d7e78da5eb5f6db4b7bc2082d19ced60a" translate="yes" xml:space="preserve">
          <source>Class expressions allow you to redefine (re-declare) classes &lt;strong&gt;without throwing&lt;/strong&gt; a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;. This is not the case with &lt;a href=&quot;../statements/class&quot;&gt;class statements&lt;/a&gt;.</source>
          <target state="translated">클래스 표현은 (재 선언) 클래스를 재정의 할 수 있도록 &lt;strong&gt;던지는없이 &lt;/strong&gt;&lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;a href=&quot;../statements/class&quot;&gt;클래스 문&lt;/a&gt; 에는 해당되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c53fdfff79071be301e33abe05bc51edbb8d46" translate="yes" xml:space="preserve">
          <source>Class expressions may omit the class name (&quot;binding identifier&quot;), which is not possible with &lt;a href=&quot;../statements/class&quot;&gt;class statements&lt;/a&gt;.</source>
          <target state="translated">클래스 표현식은 클래스 이름 ( &quot;바인딩 식별자&quot;)을 생략 할 수 있지만 &lt;a href=&quot;../statements/class&quot;&gt;클래스 문&lt;/a&gt; 에서는 불가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed1812f061fb89b2ae95353482ac32b4b847994" translate="yes" xml:space="preserve">
          <source>Class properties are public by default and can be examined or modified outside the class. There is however &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;an experimental proposal&lt;/a&gt; to allow defining private class fields using a hash &lt;code&gt;#&lt;/code&gt; prefix.</source>
          <target state="translated">클래스 속성은 기본적으로 공용이며 클래스 외부에서 검사하거나 수정할 수 있습니다. 그러나 해시 &lt;code&gt;#&lt;/code&gt; 접두사를 사용하여 개인 클래스 필드를 정의 할 수 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;있는 실험적인 제안&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="efafbd4b2c2d4ba12a0b4bae024f5186ec9a7d32" translate="yes" xml:space="preserve">
          <source>Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are not shared with ES5 classalike semantics.</source>
          <target state="translated">클래스는 개체를 만들기위한 템플릿입니다. 그들은 데이터를 작업하기 위해 코드로 데이터를 캡슐화합니다. JS의 클래스는 프로토 타입을 기반으로 구축되지만 ES5 클래스 유사 시맨틱과 공유되지 않는 일부 구문 및 시맨틱도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a62711f21d061784f6184121613d134009b236" translate="yes" xml:space="preserve">
          <source>Classes are in fact &quot;special &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;&quot;, and just as you can define &lt;a href=&quot;operators/function&quot;&gt;function expressions&lt;/a&gt; and &lt;a href=&quot;statements/function&quot;&gt;function declarations&lt;/a&gt;, the class syntax has two components: &lt;a href=&quot;operators/class&quot;&gt;class expressions&lt;/a&gt; and &lt;a href=&quot;statements/class&quot;&gt;class declarations&lt;/a&gt;.</source>
          <target state="translated">클래스는 실제로 &quot;특수 &lt;a href=&quot;functions&quot;&gt;함수&lt;/a&gt; &quot;이며 &lt;a href=&quot;operators/function&quot;&gt;함수 표현식&lt;/a&gt; 과 &lt;a href=&quot;statements/function&quot;&gt;함수 선언을&lt;/a&gt; 정의 할 수있는 것처럼 클래스 구문에는 &lt;a href=&quot;operators/class&quot;&gt;클래스 표현식&lt;/a&gt; 과 &lt;a href=&quot;statements/class&quot;&gt;클래스 선언의&lt;/a&gt; 두 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c240d1a5911ec065cfa8c1fc7e652b8cf7de4399" translate="yes" xml:space="preserve">
          <source>Classical inheritance with &lt;code&gt;Object.create()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.create()&lt;/code&gt; 이용한 클래식 상속</target>
        </trans-unit>
        <trans-unit id="20827d1a03a342fab6d405f70d2610b9a815dbc4" translate="yes" xml:space="preserve">
          <source>Clever usage of &lt;code&gt;apply&lt;/code&gt; allows you to use built-in functions for some tasks that would probably have otherwise been written by looping over the array values.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 를 영리하게 사용 하면 배열 값을 반복하여 작성했을 수있는 일부 작업에 내장 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159186d16cd85cfe1f0fd8c0967a81a8ce57d61e" translate="yes" xml:space="preserve">
          <source>Clever usage of &lt;code&gt;apply&lt;/code&gt; allows you to use built-in functions for some tasks, that otherwise probably would have been written by looping over the array values. As an example here we are going to use &lt;code&gt;Math.max&lt;/code&gt;/&lt;code&gt;Math.min&lt;/code&gt;, to find out the maximum/minimum value in an array.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 를 영리하게 사용 하면 일부 작업에 내장 함수를 사용할 수 있습니다. 그렇지 않으면 아마도 배열 값을 반복하여 작성했을 것입니다. 예를 들어 &lt;code&gt;Math.max&lt;/code&gt; / &lt;code&gt;Math.min&lt;/code&gt; 을 사용 하여 배열의 최대 / 최소 값을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="adff11da65e94ea55758937a5d0bd27584629a58" translate="yes" xml:space="preserve">
          <source>Clipping a value with &lt;code&gt;Math.min()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Math.min()&lt;/code&gt; 으로 값 클리핑</target>
        </trans-unit>
        <trans-unit id="a255299b6435865d997ac493e62aaa383097a14b" translate="yes" xml:space="preserve">
          <source>Clipping a value with Math.min()</source>
          <target state="translated">Math.min ()으로 값 자르기</target>
        </trans-unit>
        <trans-unit id="85fb0940516348e1a72a1f878103be3346084dda" translate="yes" xml:space="preserve">
          <source>Cloning an object</source>
          <target state="translated">객체 복제</target>
        </trans-unit>
        <trans-unit id="71427f396f56dccc094a99ad628b77b1002050dc" translate="yes" xml:space="preserve">
          <source>Cloning and merging &lt;code&gt;Maps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Maps&lt;/code&gt; 복제 및 병합</target>
        </trans-unit>
        <trans-unit id="5c66c8a399220ae7c6594525f99a3e2a47ae0c3c" translate="yes" xml:space="preserve">
          <source>Cloning and merging Maps</source>
          <target state="translated">맵 복제 및 병합</target>
        </trans-unit>
        <trans-unit id="b2cdd87c13a55b67b7a7053ea83d9f10ad1f2a19" translate="yes" xml:space="preserve">
          <source>Closes the generator, so that when calling &lt;code&gt;next()&lt;/code&gt; an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; error will be thrown. This corresponds to the &lt;code&gt;return()&lt;/code&gt; method in the ES2015 generator object.</source>
          <target state="translated">호출 할 때 그래서, 발전기를 닫습니다 &lt;code&gt;next()&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 오류가 발생합니다. 이것은 ES2015 생성기 객체 의 &lt;code&gt;return()&lt;/code&gt; 메서드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d736b1b3337c4a1e865bb10334f9e4f5bd3f7cf0" translate="yes" xml:space="preserve">
          <source>Closing iterators</source>
          <target state="translated">이터레이터 닫기</target>
        </trans-unit>
        <trans-unit id="16b1546bfaf51b2730baa3cec8823ad69c6d520a" translate="yes" xml:space="preserve">
          <source>Closures</source>
          <target state="translated">Closures</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="720f8fc81853680964ac25cfc1c4a554f966aad3" translate="yes" xml:space="preserve">
          <source>Code after each await expression can be thought of as existing in a &lt;code&gt;.then&lt;/code&gt; callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.</source>
          <target state="translated">각 await 표현식 이후의 코드는 &lt;code&gt;.then&lt;/code&gt; 콜백 에있는 것으로 간주 할 수 있습니다 . 이러한 방식으로 프로 미스 체인은 기능을 통한 재진입 단계마다 점진적으로 구성됩니다. 반환 값은 체인의 최종 링크를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="f60f36f4db67f21e71a72761d315435a9c529b04" translate="yes" xml:space="preserve">
          <source>Code point</source>
          <target state="translated">코드 포인트</target>
        </trans-unit>
        <trans-unit id="a809433cf66e2c59e60de4aa71c982ddad377c2c" translate="yes" xml:space="preserve">
          <source>Coercion</source>
          <target state="translated">Coercion</target>
        </trans-unit>
        <trans-unit id="4ae19290f8e476675bf6f7fd603852594ce0bf7d" translate="yes" xml:space="preserve">
          <source>Collation Type</source>
          <target state="translated">데이터 정렬 유형</target>
        </trans-unit>
        <trans-unit id="dda51688cdd37ec522f37d0de6304c842416ee66" translate="yes" xml:space="preserve">
          <source>Collation is the process of ordering strings of characters. It is used whenever strings must be sorted and placed into a certain order, from search query results to ordering records in a database. While the idea of placing strings in order might seem trivial, the idea of order can vary from region to region and language to language. The &lt;code&gt;collation&lt;/code&gt; property helps to make it easier for JavaScript programmers to access the collation type used by a particular locale.</source>
          <target state="translated">데이터 정렬은 문자열을 정렬하는 프로세스입니다. 검색 쿼리 결과에서 데이터베이스의 레코드 정렬에 이르기까지 문자열을 특정 순서로 정렬하고 배치해야 할 때마다 사용됩니다. 문자열을 순서대로 배치하는 아이디어는 사소한 것처럼 보일 수 있지만 순서에 대한 아이디어는 지역 및 언어마다 다를 수 있습니다. &lt;code&gt;collation&lt;/code&gt; 속성은 쉽게 자바 스크립트 프로그래머가 특정 로케일에 의해 사용되는 데이터 정렬 유형에 액세스 할 수 있도록하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="76e2f93a7b66626151662333f42b2be7287b5233" translate="yes" xml:space="preserve">
          <source>Colons vs. equal signs</source>
          <target state="translated">콜론 대 등호</target>
        </trans-unit>
        <trans-unit id="dbf092f09b76a6f2453e282ef8f2b8bf433d9bb1" translate="yes" xml:space="preserve">
          <source>Column number in line that raised this error.</source>
          <target state="translated">이 오류가 발생한 행의 열 번호</target>
        </trans-unit>
        <trans-unit id="ce2a9d862f97ecd682f9df7d2276f484b17c5a62" translate="yes" xml:space="preserve">
          <source>Column number in line that raised this error. Inherited from &lt;a href=&quot;../error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류를 일으킨 행 번호입니다. &lt;a href=&quot;../error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 에서 상속되었습니다 .</target>
        </trans-unit>
        <trans-unit id="45367426a5d0996e0279386d310f3aa188f6457c" translate="yes" xml:space="preserve">
          <source>Column number in line that raised this error. Inherited from &lt;a href=&quot;error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류를 일으킨 행 번호입니다. &lt;a href=&quot;error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 에서 상속되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c151c81772760823598010a75dc1ec1f74a65c39" translate="yes" xml:space="preserve">
          <source>Combined Array and Object Destructuring</source>
          <target state="translated">결합 된 배열 및 객체 분해</target>
        </trans-unit>
        <trans-unit id="8332a3493504e95c2fca7108c5f7e5ae8d9fb54c" translate="yes" xml:space="preserve">
          <source>Combines the text of two (or more) strings and returns a new string.</source>
          <target state="translated">두 개 이상의 문자열의 텍스트를 결합하고 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="105b6ea34c923a2a3d6b66b9fe741254a5e89b96" translate="yes" xml:space="preserve">
          <source>Combines the text of two strings and returns a new string.</source>
          <target state="translated">두 문자열의 텍스트를 결합하고 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="907754fe6c9463cd13c704328122033a4517e82b" translate="yes" xml:space="preserve">
          <source>Combining with the nullish coalescing operator</source>
          <target state="translated">nullish 병합 연산자와 결합</target>
        </trans-unit>
        <trans-unit id="d625ea326feb65d6f24b54ebdef0a0bd95ae57ea" translate="yes" xml:space="preserve">
          <source>Comma / Sequence</source>
          <target state="translated">쉼표 / 시퀀스</target>
        </trans-unit>
        <trans-unit id="32bae387055126d95306c7bb6532b73268f5a2d5" translate="yes" xml:space="preserve">
          <source>Comma Operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="b506b24efb6525b0ee356cf0162e2de834afe47c" translate="yes" xml:space="preserve">
          <source>Comma operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="9a5e486ba0184d4b42fd4dcc0768b5f7d7ffa822" translate="yes" xml:space="preserve">
          <source>Comments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.</source>
          <target state="translated">주석은 JavaScript 코드에 힌트, 메모, 제안 또는 경고를 추가하는 데 사용됩니다. 이를 통해 더 쉽게 읽고 이해할 수 있습니다. 또한 코드가 실행되지 않도록 코드를 비활성화하는 데 사용될 수도 있습니다. 이것은 유용한 디버깅 도구가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e89188eb5b49b1238ddabeafbc3597fb0a0565e1" translate="yes" xml:space="preserve">
          <source>Common causes of memory leaks in extensions</source>
          <target state="translated">확장에서 메모리 누수의 일반적인 원인</target>
        </trans-unit>
        <trans-unit id="eacd29e150bf7f4b19b8fab3eb797604a6c1b6f2" translate="yes" xml:space="preserve">
          <source>Common operations</source>
          <target state="translated">일반적인 작업</target>
        </trans-unit>
        <trans-unit id="0318a73036a46f0f8a141499cd73521dd9c49b95" translate="yes" xml:space="preserve">
          <source>Compare the following:</source>
          <target state="translated">다음을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="7d7f628e8dcc4103d238aec5e6ea87d14dfb9dc3" translate="yes" xml:space="preserve">
          <source>Compared to &lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; 와 비교</target>
        </trans-unit>
        <trans-unit id="bb29c7581a6ad2220cfbf22c9e06c48492f18dde" translate="yes" xml:space="preserve">
          <source>Compared to &lt;code&gt;fromCharCode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fromCharCode()&lt;/code&gt; 와 비교</target>
        </trans-unit>
        <trans-unit id="d7c7b804472bb9c2221dba855c8979c36d47e19b" translate="yes" xml:space="preserve">
          <source>Compared to Object.getPrototypeOf()</source>
          <target state="translated">Object.getPrototypeOf ()와 비교</target>
        </trans-unit>
        <trans-unit id="c486068f142dd18e8eae77363e6842b9a3922425" translate="yes" xml:space="preserve">
          <source>Compares if two values are the same value. Equates all &lt;code&gt;NaN&lt;/code&gt; values (which differs from both Abstract Equality Comparison and Strict Equality Comparison).</source>
          <target state="translated">두 값이 같은 값인지 비교합니다. 모든 &lt;code&gt;NaN&lt;/code&gt; 값을 동일시 합니다 (추상 동등 비교 및 ​​엄격한 동등 비교와 다름).</target>
        </trans-unit>
        <trans-unit id="86214e3cdb8ec5301da0371f4da85bfd01cfe478" translate="yes" xml:space="preserve">
          <source>Compares if two values are the same value. Equates all NaN values (which differs from both Abstract Equality Comparison and Strict Equality Comparison).</source>
          <target state="translated">두 값이 같은 값인지 비교합니다. 모든 NaN 값을 동일하게합니다 (추상 같음 비교 및 ​​엄격한 같음 비교와는 다름).</target>
        </trans-unit>
        <trans-unit id="23db2b341a919f13e47cb167974fbc38f6f89065" translate="yes" xml:space="preserve">
          <source>Comparing Boolean, null, undefined, NaN</source>
          <target state="translated">Boolean, null, undefined, NaN 비교</target>
        </trans-unit>
        <trans-unit id="4b18b5742acde50e59926664c8b854ae578604de" translate="yes" xml:space="preserve">
          <source>Comparing Dates and strings</source>
          <target state="translated">날짜와 문자열 비교</target>
        </trans-unit>
        <trans-unit id="118b25a45a8567ec63e03a40be7d32ee56d43ca2" translate="yes" xml:space="preserve">
          <source>Comparing actual source code and toString results</source>
          <target state="translated">실제 소스 코드와 toString 결과 비교</target>
        </trans-unit>
        <trans-unit id="8486eeb280c1db59f088b3504b119f1ac4120ab3" translate="yes" xml:space="preserve">
          <source>Comparing format and formatToParts</source>
          <target state="translated">형식 및 formatToParts 비교</target>
        </trans-unit>
        <trans-unit id="3e9a07241ecb7fd5c1f83975cd62cd490f5c7b13" translate="yes" xml:space="preserve">
          <source>Comparing objects</source>
          <target state="translated">개체 비교</target>
        </trans-unit>
        <trans-unit id="5c9fd252c78765245ca6724900277e03bd6deae9" translate="yes" xml:space="preserve">
          <source>Comparing operands of different types</source>
          <target state="translated">다른 유형의 피연산자 비교</target>
        </trans-unit>
        <trans-unit id="de48228ba309a93bef16c8852488bb43d678e6cd" translate="yes" xml:space="preserve">
          <source>Comparing operands of the same type</source>
          <target state="translated">동일한 유형의 피연산자 비교</target>
        </trans-unit>
        <trans-unit id="56636862149ba9455cfa10dcf654e98196d3820b" translate="yes" xml:space="preserve">
          <source>Comparing strings</source>
          <target state="translated">문자열 비교</target>
        </trans-unit>
        <trans-unit id="570b5eadf2eeeebf91fc12d99e3a48b87b017be8" translate="yes" xml:space="preserve">
          <source>Comparing strings and String objects</source>
          <target state="translated">문자열과 문자열 객체 비교</target>
        </trans-unit>
        <trans-unit id="a5a33d9655bb4449a333726e1c96003dd5fa2185" translate="yes" xml:space="preserve">
          <source>Comparing the two code snippets above, the two code snippets might seem to work the same way, but think again: the &lt;code&gt;eval()&lt;/code&gt; one is a great deal slower. Notice &lt;code&gt;c: new Date()&lt;/code&gt; in the evaluated object. In the function without the &lt;code&gt;eval()&lt;/code&gt;, the object is being evaluated in the global scope, so it is safe for the browser to assume that &lt;code&gt;Date&lt;/code&gt; refers to &lt;code&gt;window.Date()&lt;/code&gt; instead of a local variable called &lt;code&gt;Date&lt;/code&gt;. But, in the code using &lt;code&gt;eval()&lt;/code&gt;, the browser cannot assume this since what if your code looked like the following:</source>
          <target state="translated">위의 두 코드 스 니펫을 비교하면 두 코드 스 니펫이 동일한 방식으로 작동하는 것처럼 보일 수 있지만 다시 생각해보십시오. &lt;code&gt;eval()&lt;/code&gt; 하나가 훨씬 느립니다. 평가 된 객체의 &lt;code&gt;c: new Date()&lt;/code&gt; 에 주목 하십시오. 빼고 함수에서 &lt;code&gt;eval()&lt;/code&gt; 브라우저가 있다고 가정하는 것이 안전하므로 객체는 전역에서 평가되는 &lt;code&gt;Date&lt;/code&gt; 를 의미 &lt;code&gt;window.Date()&lt;/code&gt; 대신 불리는 로컬 변수의 &lt;code&gt;Date&lt;/code&gt; . 그러나 &lt;code&gt;eval()&lt;/code&gt; 사용하는 코드 에서 브라우저는 코드가 다음과 같이 보이기 때문에이를 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="491af6e089de075cb1cddc844a85aed35b1303e3" translate="yes" xml:space="preserve">
          <source>Comparing the two code snippets above, the two code snippets might seem to work the same way, but think again: the eval one is a huge amount slower. Notice &lt;code&gt;c: new Date()&lt;/code&gt; in the evaluated object. In the function without the eval, the object is being evaluated in the global scope, so it is safe for the browser to assume that &lt;code&gt;Date&lt;/code&gt; refers to &lt;code&gt;window.Date&lt;/code&gt; instead of a local variable called Date. But, in the code using &lt;code&gt;eval()&lt;/code&gt;, the browser cannot assume this since what if your code looked like the following:</source>
          <target state="translated">위의 두 코드 스 니펫을 비교하면 두 코드 스 니펫은 동일한 방식으로 작동하는 것처럼 보이지만 다시 생각하십시오. 평가판 코드는 엄청나게 느립니다. 공지 사항 &lt;code&gt;c: new Date()&lt;/code&gt; 평가 대상이다. eval이없는 ​​함수에서 객체는 전역 범위에서 평가되므로 브라우저는 &lt;code&gt;Date&lt;/code&gt; 라는 로컬 변수 대신 Date 가 &lt;code&gt;window.Date&lt;/code&gt; 를 참조 한다고 가정하는 것이 안전합니다 . 그러나 &lt;code&gt;eval()&lt;/code&gt; 사용하는 코드 에서는 코드가 다음과 같은 경우 브라우저가이를 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25acda77b0bc6b058bd349dd6f4a271e2a967bfe" translate="yes" xml:space="preserve">
          <source>Comparison Operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="87b9d64e30f99622e78f324257f1751495414584" translate="yes" xml:space="preserve">
          <source>Comparison of objects</source>
          <target state="translated">개체 비교</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="f7cf7733ad31698cd2948e3b5515768590fe965e" translate="yes" xml:space="preserve">
          <source>Comparison to &lt;code&gt;Object.freeze()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.freeze()&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="863058f0e63c30ee906e3bbce288176602ad060e" translate="yes" xml:space="preserve">
          <source>Comparison to &lt;code&gt;Object.seal()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.seal()&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="84c310ee18192732f5f41f433768e9fdc502e226" translate="yes" xml:space="preserve">
          <source>Comparison to Object.freeze()</source>
          <target state="translated">Object.freeze ()와 비교</target>
        </trans-unit>
        <trans-unit id="d35d03b7a4c8b558b09f712f1601b7eb56fbc77b" translate="yes" xml:space="preserve">
          <source>Comparison to Object.seal()</source>
          <target state="translated">Object.seal ()과 비교</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
