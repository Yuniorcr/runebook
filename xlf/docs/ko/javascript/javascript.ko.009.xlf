<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="javascript">
    <body>
      <group id="javascript">
        <trans-unit id="9fd706dc1d0360b94ec21dbf8552ac9d5f3e383e" translate="yes" xml:space="preserve">
          <source>If used postfix (for example, x--), then it returns the value before decrementing.</source>
          <target state="translated">접미사 (예 : x--)를 사용하면 감소하기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="666b24bff72e7b0ae328538333aadcca72ea53da" translate="yes" xml:space="preserve">
          <source>If used postfix, with operator after operand (for example, &lt;code&gt;&lt;var&gt;x&lt;/var&gt;++&lt;/code&gt;), the increment operator increments and returns the value before incrementing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f855a65a9af260d40b455c64310a2ba4c6b6d08e" translate="yes" xml:space="preserve">
          <source>If used postfix, with operator after operand (for example, &lt;code&gt;&lt;var&gt;x&lt;/var&gt;--&lt;/code&gt;), the decrement operator decrements and returns the value before decrementing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1231f0f16dedb361c482a319c20aff31b05c5e" translate="yes" xml:space="preserve">
          <source>If used postfix, with operator after operand (for example, x++), then it returns the value before incrementing.</source>
          <target state="translated">피연산자 뒤에 연산자 (예 : x ++)와 함께 접미사를 사용하면 증분하기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6e40e35ce4cf016961cce9be2454b86125ceb4b" translate="yes" xml:space="preserve">
          <source>If used prefix (for example, --x), then it returns the value after decrementing.</source>
          <target state="translated">접두사 (예 : --x)를 사용하면 감소 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9df9321ebb8182da95c82368fad1cd967b2ab528" translate="yes" xml:space="preserve">
          <source>If used prefix with operator before operand (for example, ++x), then it returns the value after incrementing.</source>
          <target state="translated">피연산자 앞에 연산자와 함께 접두사를 사용하면 (예 : ++ x) 증분 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b6212de07c63d01cabe699415882ecbebb40109" translate="yes" xml:space="preserve">
          <source>If used prefix, with operator before operand (for example, &lt;code&gt;++&lt;var&gt;x&lt;/var&gt;&lt;/code&gt;), the increment operator increments and returns the value after incrementing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e162f955f0a0066b38485f62cae53c79f16a7b0" translate="yes" xml:space="preserve">
          <source>If used prefix, with operator before operand (for example, &lt;code&gt;--&lt;var&gt;x&lt;/var&gt;&lt;/code&gt;), the decrement operator decrements and returns the value after decrementing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ff4cc4432ffc5f89ff00a0952d717a8a1a68b0" translate="yes" xml:space="preserve">
          <source>If we rewrite the above using traditional function-based syntax in non&amp;ndash;strict mode, then &lt;code&gt;this&lt;/code&gt; method calls are automatically bound to the initial &lt;code&gt;this&lt;/code&gt; value, which by default is the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Global_object&quot;&gt;global object&lt;/a&gt;. In strict mode, autobinding will not happen; the value of &lt;code&gt;this&lt;/code&gt; remains as passed.</source>
          <target state="translated">엄격하지 않은 모드에서 전통적인 함수 기반 구문을 사용하여 위를 다시 작성하면 &lt;code&gt;this&lt;/code&gt; 메서드 호출은 기본적으로 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Global_object&quot;&gt;전역 객체 인&lt;/a&gt; 초기 &lt;code&gt;this&lt;/code&gt; 값에 자동으로 바인딩됩니다 . 엄격 모드에서는 자동 바인딩이 발생하지 않습니다. 값 &lt;code&gt;this&lt;/code&gt; 전달로 남아있다.</target>
        </trans-unit>
        <trans-unit id="263dbd217b7b782c539a10e8e47d0cd7d0c685a1" translate="yes" xml:space="preserve">
          <source>If we want to calculate the height of an equalateral triangle, and we know its side length is 100, we can use the formulae &lt;em&gt;length of the adjacent multiplied by the tangent of the angle is equal to the opposite.&lt;/em&gt;</source>
          <target state="translated">등각 삼각형의 높이를 계산하고 그 변의 길이가 100이라는 것을 알고 있다면, 우리는 &lt;em&gt;각도의 탄젠트를 곱한 인접의 길이가 반대와 같다는&lt;/em&gt; 공식을 사용할 수 있습니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44416e4cb440058b3e2168092fa043d526ea6bd6" translate="yes" xml:space="preserve">
          <source>If we want to export a single value or to have a fallback value for our module, we could use a default export:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 폴백 값을 가지려면 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ced299cf7385e721622ed81fc4d2edb2bdf9e3" translate="yes" xml:space="preserve">
          <source>If we want to export a single value or to have a fallback value for your module, you could use a default export:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 대한 대체 값을 가지려면 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1e42279903ed183e261f8299c80921fedf73370" translate="yes" xml:space="preserve">
          <source>If we want to export default, and star from another module (effectively creating a &quot;redirect&quot;):</source>
          <target state="translated">기본값을 내보내고 다른 모듈에서 별표를 표시하려면 (효과적으로 &quot;리디렉션&quot;작성) :</target>
        </trans-unit>
        <trans-unit id="d6463f6ee85e1b3683452de8f289526c45b1d166" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language (like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt;), it is also easy to mix up the dot operator (&lt;code&gt;.&lt;/code&gt;) and the concatenation operator (&lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt; 와 같은 다른 프로그래밍 언어에서 오는 경우 도트 연산자 ( &lt;code&gt;.&lt;/code&gt; )와 연결 연산자 ( &lt;code&gt;+&lt;/code&gt; )를 쉽게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b266e11ed2f48331bcbc5cd3a2651fd6ea8db942" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language (like &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt;), it is also easy to mix up the dot operator (&lt;code&gt;.&lt;/code&gt;) and the concatenation operator (&lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">다른 프로그래밍 언어 (예 : &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt; )를 사용하는 경우 도트 연산자 ( &lt;code&gt;.&lt;/code&gt; )와 연결 연산자 ( &lt;code&gt;+&lt;/code&gt; ) 를 혼동하기 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="bb66cb61a06782782fcf8588e20af249ee21a6b0" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language, it is also easy to add keywords that don't mean the same or have no meaning at all in JavaScript.</source>
          <target state="translated">다른 프로그래밍 언어를 사용하는 경우 JavaScript에서 전혀 의미가 없거나 전혀 의미가없는 키워드를 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659845dc301670bca252df4853db8e2f3ac23b6a" translate="yes" xml:space="preserve">
          <source>If you are creating an &lt;code&gt;Array&lt;/code&gt;, using the constructor, you probably want to use the literal notation instead, as the first argument is interpreted as the length of the &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">생성자를 사용하여 &lt;code&gt;Array&lt;/code&gt; 를 작성하는 경우 첫 번째 인수가 &lt;code&gt;Array&lt;/code&gt; 의 길이로 해석되므로 리터럴 표기법을 대신 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="0d24793ed02c1f52e768f26367f343405e5dd686" translate="yes" xml:space="preserve">
          <source>If you are executing a match simply to find &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, use &lt;a href=&quot;test&quot;&gt;&lt;code&gt;RegExp.prototype.test()&lt;/code&gt;&lt;/a&gt; method or &lt;a href=&quot;../string/search&quot;&gt;&lt;code&gt;String.prototype.search()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">단순히 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 찾기 위해 일치를 실행하는 경우 &lt;a href=&quot;test&quot;&gt; &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../string/search&quot;&gt; &lt;code&gt;String.prototype.search()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23c1a323209deeb808a2a36b6ad4684b94b02231" translate="yes" xml:space="preserve">
          <source>If you are executing a match simply to find true or false, use the &lt;a href=&quot;test&quot;&gt;&lt;code&gt;RegExp.prototype.test()&lt;/code&gt;&lt;/a&gt; method or the &lt;a href=&quot;../string/search&quot;&gt;&lt;code&gt;String.prototype.search()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">단순히 true 또는 false를 찾기 위해 일치를 실행하는 경우 &lt;a href=&quot;test&quot;&gt; &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../string/search&quot;&gt; &lt;code&gt;String.prototype.search()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68b817fe3ff3a62bc615632f841b38339b8524eb" translate="yes" xml:space="preserve">
          <source>If you are new to JavaScript, start with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;guide&lt;/a&gt;. Once you have a firm grasp of the fundamentals, you can use the &lt;a href=&quot;index&quot;&gt;reference&lt;/a&gt; to get more details on individual objects and language constructs.</source>
          <target state="translated">JavaScript를 처음 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;안내서로&lt;/a&gt; 시작하십시오 . 기본 사항을 제대로 이해 하면 &lt;a href=&quot;index&quot;&gt;참조&lt;/a&gt; 를 사용하여 개별 객체 및 언어 구성에 대한 자세한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a535257a688b66c7fecab217e89655ac1ba3f8dc" translate="yes" xml:space="preserve">
          <source>If you are new to JavaScript, start with the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;guide&lt;/a&gt;. Once you have a firm grasp of the fundamentals, you can use the &lt;a href=&quot;index&quot;&gt;reference&lt;/a&gt; to get more details on individual objects and language constructs.</source>
          <target state="translated">JavaScript를 처음 사용하는 경우 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;가이드&lt;/a&gt; 부터 시작하십시오 . 기본 사항을 확실히 이해하면 &lt;a href=&quot;index&quot;&gt;참조&lt;/a&gt; 를 사용하여 개별 개체 및 언어 구성에 대한 자세한 내용을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="613a62f0a62a3e51be50183314f313d624f6bc5b" translate="yes" xml:space="preserve">
          <source>If you are using an older browser that does not yet implement &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../statements/class&quot;&gt;class&lt;/a&gt;&lt;/code&gt;, for example, you should update to a more recent browser version that does support these new language features.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../statements/class&quot;&gt;class&lt;/a&gt;&lt;/code&gt; 를 아직 구현하지 않은 이전 브라우저를 사용하는 경우 이러한 새 언어 기능을 지원하는 최신 브라우저 버전으로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c3a9d53d40d1800d714f24dc84a4f4ba306069" translate="yes" xml:space="preserve">
          <source>If you are using function &lt;a href=&quot;../statements/label&quot;&gt;labels&lt;/a&gt;, you will still need to provide a function name after the &lt;code&gt;function&lt;/code&gt; keyword. This doesn't work:</source>
          <target state="translated">함수 &lt;a href=&quot;../statements/label&quot;&gt;레이블&lt;/a&gt; 을 사용하는 경우 &lt;code&gt;function&lt;/code&gt; 키워드 뒤에 함수 이름을 제공해야 합니다. 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77903e97dc13aed96b929fd6a5c838a5b3a347a1" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; in an ECMAScript 5 environment, then the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement will resolve to &lt;code&gt;obj&lt;/code&gt;. However, ECMAScript 2015 introduces a &lt;code&gt;values&lt;/code&gt; property on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; (so that it will be available on every array). So, in a JavaScript environment that supports ECMAScript 2015, the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement could resolve to &lt;code&gt;[1,2,3].values&lt;/code&gt;. However, in this particular example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; has been defined with &lt;code&gt;values&lt;/code&gt; in its &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt;&lt;code&gt;Symbol.unscopables&lt;/code&gt;&lt;/a&gt; object. If it were not, one can see how this would be a difficult issue to debug.</source>
          <target state="translated">ECMAScript 5 환경에서 &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; 를 호출 하면 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 가 &lt;code&gt;obj&lt;/code&gt; 로 확인 됩니다. 그러나 ECMAScript 2015에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;values&lt;/code&gt; 속성이 도입 되어 모든 배열에서 사용할 수 있습니다. 따라서 ECMAScript 2015를 지원하는 JavaScript 환경 에서 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 는 &lt;code&gt;[1,2,3].values&lt;/code&gt; 로 확인할 수 있습니다. 그러나,이 특정 예에서, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로는&lt;/a&gt; 정의 된 &lt;code&gt;values&lt;/code&gt; 그 안에 &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt; &lt;code&gt;Symbol.unscopables&lt;/code&gt; &lt;/a&gt;목적. 그렇지 않은 경우 디버깅하기 어려운 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a590cd4ce738fdd82efe0e9731e381f8954b9061" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; in an ECMAScript 5 environment, then the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement will resolve to &lt;code&gt;obj&lt;/code&gt;. However, ECMAScript 6 introduces a &lt;code&gt;values&lt;/code&gt; property on &lt;a href=&quot;../global_objects/array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; (so that it will be available on every array). So, in a JavaScript environment that supports ECMAScript 6, the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement could resolve to &lt;code&gt;[1,2,3].values&lt;/code&gt;. However, in this particular example, &lt;a href=&quot;../global_objects/array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; has been defined with &lt;code&gt;values&lt;/code&gt; in its &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt;&lt;code&gt;Symbol.unscopables&lt;/code&gt;&lt;/a&gt; object. If it were not, one can see how this would be a difficult issue to debug.</source>
          <target state="translated">ECMAScript 5 환경에서 &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; 를 호출 하면 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 가 &lt;code&gt;obj&lt;/code&gt; 로 해석됩니다 . 그러나 ECMAScript 6에서는 &lt;a href=&quot;../global_objects/array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;values&lt;/code&gt; 속성을 도입하여 모든 배열에서 사용할 수 있습니다. 따라서 ECMAScript 6을 지원하는 JavaScript 환경 에서 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 는 &lt;code&gt;[1,2,3].values&lt;/code&gt; 로 해석 될 수 있습니다. 그러나,이 특정 예에서, &lt;a href=&quot;../global_objects/array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로는&lt;/a&gt; 정의 된 &lt;code&gt;values&lt;/code&gt; 그 안에 &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt; &lt;code&gt;Symbol.unscopables&lt;/code&gt; &lt;/a&gt;목적. 그렇지 않은 경우 어떻게 디버깅하기 어려운 문제인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c956ed676ebd4cdf0ef2b881c4cdd44209fec2e" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;pop()&lt;/code&gt; on an empty array, it returns &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">빈 배열에서 &lt;code&gt;pop()&lt;/code&gt; 을 호출하면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 가&lt;/a&gt; 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="982fa524918e289d54b948aa1c92f09ae356ee5c" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;toString()&lt;/code&gt; method on this custom object, it returns the default value inherited from &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 사용자 정의 객체 에서 &lt;code&gt;toString()&lt;/code&gt; 메서드 를 호출하면 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 에서 상속 된 기본값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d335486efc475b952d22569f82a62a2788b89c6" translate="yes" xml:space="preserve">
          <source>If you choose to use this partial implementation, &lt;strong&gt;you must not rely on those cases where behavior deviates from ECMA-262, 5&lt;sup&gt;th&lt;/sup&gt; edition!&lt;/strong&gt; Thankfully, these deviations from the specification rarely (if ever) come up in most coding situations. If you do not understand any of the deviations from the specification above, then it is safe in this particular case to not worry about these noncompliant deviation details.</source>
          <target state="translated">이 부분 구현을 사용하기로 선택한 &lt;strong&gt;경우 동작이 ECMA-262, &lt;sup&gt;5th&lt;/sup&gt; edition 에서 벗어나는 경우에 의존해서는 안됩니다 ! &lt;/strong&gt;고맙게도 이러한 사양의 편차는 대부분의 코딩 상황에서 거의 나타나지 않습니다. 위 사양의 편차를 이해하지 못하는 경우 이러한 비준수 편차 세부 사항에 대해 걱정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="67afcf342da3e90693d7ecef744d3642516938dd" translate="yes" xml:space="preserve">
          <source>If you choose to use this partial implementation, &lt;strong&gt;you must not rely on those cases where behavior deviates from ECMA-262, 5th edition!&lt;/strong&gt; With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when &lt;code&gt;bind()&lt;/code&gt; is widely implemented according to the specification.</source>
          <target state="translated">이 부분 구현을 사용하기로 선택한 &lt;strong&gt;경우 ECMA-262, 5 판에서 동작이 벗어난 경우에 의존해서는 안됩니다! &lt;/strong&gt;그러나 일부주의를 기울이면 (및 특정 요구에 맞게 추가 수정이 적용됨),이 부분 구현은 &lt;code&gt;bind()&lt;/code&gt; 가 사양에 따라 광범위하게 구현 되는 시간에 대한 합리적인 브리지가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d8ff152a7506a8df981872cd6144a994c604418" translate="yes" xml:space="preserve">
          <source>If you come from another programming language, it is also common to use keywords that don't mean the same or have no meaning at all in javaScript:</source>
          <target state="translated">다른 프로그래밍 언어를 사용하는 경우 javaScript에서 동일하지 않거나 전혀 의미가없는 키워드를 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="56181bd1d66f2b2ed3709ed12001807e1c6d7be4" translate="yes" xml:space="preserve">
          <source>If you construct an arithmetic expression as a string, you can use &lt;code&gt;eval()&lt;/code&gt; to evaluate it at a later time. For example, suppose you have a variable &lt;code&gt;x&lt;/code&gt;. You can postpone evaluation of an expression involving &lt;code&gt;x&lt;/code&gt; by assigning the string value of the expression, say &quot;&lt;code&gt;3 * x + 2&lt;/code&gt;&quot;, to a variable, and then calling &lt;code&gt;eval()&lt;/code&gt; at a later point in your script.</source>
          <target state="translated">산술 표현식을 문자열로 구성하는 경우 &lt;code&gt;eval()&lt;/code&gt; 을 사용 하여 나중에 평가할 수 있습니다. 예를 들어, 변수 &lt;code&gt;x&lt;/code&gt; 가 있다고 가정하십시오 . &quot; &lt;code&gt;3 * x + 2&lt;/code&gt; &quot; 와 같은 표현식의 문자열 값을 변수에 할당 한 다음 나중에 스크립트의 &lt;code&gt;eval()&lt;/code&gt; 을 호출 하여 &lt;code&gt;x&lt;/code&gt; 와 관련된 표현식의 평가를 연기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d68f6b9f418726c69743b66c16ac037f82b5627" translate="yes" xml:space="preserve">
          <source>If you create a property key from an expression, you need to use square brackets. Otherwise the property name can't be computed:</source>
          <target state="translated">식에서 속성 키를 만드는 경우 대괄호를 사용해야합니다. 그렇지 않으면 속성 이름을 계산할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="be14b3ea8c1e9826f6190d19d2cab72fdf85cb50" translate="yes" xml:space="preserve">
          <source>If you define multiple values then the last value is returned.</source>
          <target state="translated">여러 값을 정의하면 마지막 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f10d361ef5a163329364a3df976bc77ea83e3dc0" translate="yes" xml:space="preserve">
          <source>If you delete a property for which a watchpoint has been set, that watchpoint does not disappear. If you later recreate the property, the watchpoint is still in effect.</source>
          <target state="translated">감시 점이 설정된 속성을 삭제하면 해당 감시 점이 사라지지 않습니다. 나중에 속성을 다시 만들면 감시 점이 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9e2bd2b895541007ef32841e0415947532555ac7" translate="yes" xml:space="preserve">
          <source>If you delete a property with the &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; operator, the &lt;code&gt;in&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; for that property.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 연산자 를 사용하여 속성을 삭제 하면 &lt;code&gt;in&lt;/code&gt; 연산자는 해당 속성에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5f6e1de3c0913e4cc6a427cd152ae3adbdbf83ba" translate="yes" xml:space="preserve">
          <source>If you didn't write the &lt;code&gt;new&lt;/code&gt; operator, &lt;strong&gt;the Constructor Function would be invoked like any Regular Function,&lt;/strong&gt;&lt;em&gt;without creating an Object.&lt;/em&gt; In this case, the value of &lt;code&gt;this&lt;/code&gt; is also different.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 연산자를 작성하지 않은 경우 &lt;strong&gt;생성자 함수는 &lt;/strong&gt;&lt;em&gt;객체를 생성하지 않고 &lt;/em&gt;&lt;strong&gt;일반 함수처럼 호출됩니다 &lt;/strong&gt;&lt;em&gt;. &lt;/em&gt;이 경우, 값 &lt;code&gt;this&lt;/code&gt; 도 다르다.</target>
        </trans-unit>
        <trans-unit id="bddfe554f36b287490547eed85632d9e23d92c9d" translate="yes" xml:space="preserve">
          <source>If you didn't write the &lt;code&gt;new&lt;/code&gt; operator, &lt;strong&gt;the Constructor Function would be invoked like any Regular Function,&lt;/strong&gt;&lt;em&gt;without creating an Object.&lt;/em&gt;In this case, the value of &lt;code&gt;this&lt;/code&gt; is also different.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 연산자 를 쓰지 않으면 &lt;strong&gt;생성자 함수는 &lt;/strong&gt;&lt;em&gt;객체를 만들지 않고 &lt;/em&gt;&lt;strong&gt;일반 함수처럼 호출됩니다 &lt;/strong&gt;&lt;em&gt;. &lt;/em&gt;이 경우, 값 &lt;code&gt;this&lt;/code&gt; 도 다르다.</target>
        </trans-unit>
        <trans-unit id="d5715ce7b490b3178a67fbab44e46e0895854da4" translate="yes" xml:space="preserve">
          <source>If you do not specify a constructor method, a default constructor is used.</source>
          <target state="translated">생성자 메서드를 지정하지 않으면 기본 생성자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91809d53b8b015a60ef70d0dcdc8f1e75e790479" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad54b71740a03f15b390b615e6bf7ef289e62f3" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getminutes&quot;&gt;&lt;code&gt;getMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getminutes&quot;&gt; &lt;code&gt;getMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b14924a4ad8ffa7796c3bfab19bb7a60650112" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcminutes&quot;&gt;&lt;code&gt;getUTCMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcminutes&quot;&gt; &lt;code&gt;getUTCMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa69a0144131eaebaa23e3873fb3414a94568f" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;dateValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getmonth&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;dateValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmonth&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3df5d83c279d0c8023216b21336a639196b7ed77" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcmonth&quot;&gt;&lt;code&gt;getUTCMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmonth&quot;&gt; &lt;code&gt;getUTCMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47bc293e91c6175b64ee14299e94b76f046b77c1" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80f5fcbf1f345056595a0febb2d4450e65ef680f" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9f19a7f8ab4f40f5bd17f11354e3f6271fb12c" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59226b478f68551a725b4904aa9e073fdd1245c0" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;dayValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f69c9e92ce00676ee4d2916a406ce0640412ab41" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;dayValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a6e5b4b10c44b2a624b4d411895f115df5e9376" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;minutesValue&lt;/code&gt;, &lt;code&gt;secondsValue&lt;/code&gt;, and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getminutes&quot;&gt;&lt;code&gt;getMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;minutesValue&lt;/code&gt; , &lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getminutes&quot;&gt; &lt;code&gt;getMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="196d20153d788622cbd58314f072ed3ac7c88814" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;minutesValue&lt;/code&gt;, &lt;code&gt;secondsValue&lt;/code&gt;, and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcminutes&quot;&gt;&lt;code&gt;getUTCMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;minutesValue&lt;/code&gt; , &lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcminutes&quot;&gt; &lt;code&gt;getUTCMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e065f2df26eadd9c019745d680d610654be27e8" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;monthValue&lt;/code&gt; and &lt;code&gt;dateValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getmonth&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;monthValue&lt;/code&gt; 및 &lt;code&gt;dateValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmonth&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f17a4828fb9f406dde0b1835b9d908b2753f5da" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;monthValue&lt;/code&gt; and &lt;code&gt;dayValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcmonth&quot;&gt;&lt;code&gt;getUTCMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;monthValue&lt;/code&gt; 및 &lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmonth&quot;&gt; &lt;code&gt;getUTCMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d6a263711a564bafff20ce9a44e33aecf895b2" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;msValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13b2fd50258a2835809a9814d00ddc68fb9b08a2" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;msValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae79f7fb255a43982f924ce9d07ff130cc8750c" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;secondsValue&lt;/code&gt; and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b9c693ad5b1943fcbb6c027381de26570f41e6" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;secondsValue&lt;/code&gt; and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="05cb4b511b1661f5586af08ed24530681a2151ee" translate="yes" xml:space="preserve">
          <source>If you don't give any parameter and use the &lt;code&gt;match()&lt;/code&gt; method directly, you will get an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; with an empty string: &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="translated">매개 변수를 제공하지 않고 &lt;code&gt;match()&lt;/code&gt; 메서드를 직접 사용하면 빈 문자열 인 &lt;code&gt;[&quot;&quot;]&lt;/code&gt; &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="af40479ee91482e63e43f4df0bb7624dbe144771" translate="yes" xml:space="preserve">
          <source>If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:</source>
          <target state="translated">자체 생성자를 제공하지 않으면 기본 생성자가 제공됩니다. 클래스가 기본 클래스 인 경우 기본 생성자는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66dd09e3fe776430cf1ff34ceed95cf4774ef642" translate="yes" xml:space="preserve">
          <source>If you don't specify this parameter, or its value is &lt;code&gt;null&lt;/code&gt;, the new &lt;code&gt;Set&lt;/code&gt; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c32852d31c81ac10578986fc553bf83224d9e5" translate="yes" xml:space="preserve">
          <source>If you express color as a hexadecimal RGB triplet, you must use the format &lt;code&gt;rrggbb&lt;/code&gt;. For example, the hexadecimal RGB values for salmon are red=FA, green=80, and blue=72, so the RGB triplet for salmon is &lt;code&gt;&quot;FA8072&quot;&lt;/code&gt;.</source>
          <target state="translated">색상을 16 진수 RGB 삼중 항으로 표현하는 경우 &lt;code&gt;rrggbb&lt;/code&gt; 형식을 사용해야 합니다. 예를 들어 연어의 16 진수 RGB 값은 빨강 = FA, 녹색 = 80 및 파랑 = 72이므로 연어의 RGB 삼중 항은 &lt;code&gt;&quot;FA8072&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="424cbece6047c20988ec0b925f0d69bf351d88e0" translate="yes" xml:space="preserve">
          <source>If you forget a &lt;code&gt;break&lt;/code&gt; then the script will run from the &lt;code&gt;case&lt;/code&gt; where the criterion is met and will run the cases after that &lt;strong&gt;regardless if a criterion was met&lt;/strong&gt;.</source>
          <target state="translated">당신이 잊어 버린 경우 &lt;code&gt;break&lt;/code&gt; 다음 스크립트에서 실행할 &lt;code&gt;case&lt;/code&gt; 기준이 충족되고 그 후 케이스를 실행 &lt;strong&gt;기준이 충족 된 경우에 관계없이&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5829843e73f7b32286683290a76dfea716fae9b0" translate="yes" xml:space="preserve">
          <source>If you forget a break then the script will run from the case where the criterion is met and will run the case after that regardless if criterion was met. See example here:</source>
          <target state="translated">중단을 잊어 버린 경우 기준이 충족 된 경우 스크립트가 실행되고 기준이 충족되었는지 여부에 관계없이 스크립트가 실행됩니다. 여기 예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="392bc9770f3f38cbe5fa9323408292a9e2ec9a76" translate="yes" xml:space="preserve">
          <source>If you intended to create a method of an object, you will need to create an object. The following syntax without a name after the &lt;code&gt;function&lt;/code&gt; keyword is valid then.</source>
          <target state="translated">객체의 메서드를 만들려면 객체를 만들어야합니다. &lt;code&gt;function&lt;/code&gt; 키워드 다음에 이름이없는 다음 구문 이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2b7602e387bd2af7647914f024cab0e3d3062237" translate="yes" xml:space="preserve">
          <source>If you meant to declare another constant, pick another name and re-name. This constant name is already taken in this scope.</source>
          <target state="translated">다른 상수를 선언하려면 다른 이름을 선택하고 이름을 바꾸십시오. 이 상수 이름은 이미이 범위에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b291683dec2952c4e31e0fe8036f8e1ee692efb" translate="yes" xml:space="preserve">
          <source>If you might want to unregister an object later, you pass a third value, which is the &lt;em&gt;unregistration token&lt;/em&gt; you'll use later when calling the registry's &lt;code&gt;unregister&lt;/code&gt; function to unregister the object. The registry only keeps a weak reference to the unregister token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1e13b196b133d23d16e2eca23049991007c75b" translate="yes" xml:space="preserve">
          <source>If you must run the code, consider running it with reduced privileges. This advice applies mainly to extensions and XUL applications, which can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.evalInSandbox&quot;&gt;Components.utils.evalInSandbox&lt;/a&gt; for this.</source>
          <target state="translated">코드를 실행해야하는 경우 축소 된 권한으로 코드를 실행하십시오. 이 조언은 주로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.evalInSandbox&quot;&gt;Components.utils.evalInSandbox&lt;/a&gt; 를 사용할 수있는 확장 및 XUL 응용 프로그램에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f05da75db7bf9aa79df3571a16ac371a8a1c09b8" translate="yes" xml:space="preserve">
          <source>If you need the &lt;strong&gt;index&lt;/strong&gt; of the found element in the array, use &lt;a href=&quot;findindex&quot;&gt;&lt;code&gt;findIndex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에서 찾은 요소 의 &lt;strong&gt;인덱스&lt;/strong&gt; 가 필요한 경우 &lt;a href=&quot;findindex&quot;&gt; &lt;code&gt;findIndex()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44577c6fc47c8a13363a3871df6144ffae8f08db" translate="yes" xml:space="preserve">
          <source>If you need the natural log of 2 or 10, use the constants &lt;a href=&quot;ln2&quot;&gt;&lt;code&gt;Math.LN2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ln10&quot;&gt;&lt;code&gt;Math.LN10&lt;/code&gt;&lt;/a&gt; . If you need a logarithm to base 2 or 10, use &lt;a href=&quot;log2&quot;&gt;&lt;code&gt;Math.log2()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;log10&quot;&gt;&lt;code&gt;Math.log10()&lt;/code&gt;&lt;/a&gt; . If you need a logarithm to other bases, use Math.log(x) / Math.log(otherBase) as in the example below; you might want to precalculate 1 / Math.log(otherBase) .</source>
          <target state="translated">자연 로그 2 또는 10이 필요한 경우 &lt;a href=&quot;ln2&quot;&gt; &lt;code&gt;Math.LN2&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;ln10&quot;&gt; &lt;code&gt;Math.LN10&lt;/code&gt; &lt;/a&gt; 또는 Math.LN10을 사용하십시오 . 2 또는 10을 밑으로하는 로그가 필요한 경우 &lt;a href=&quot;log2&quot;&gt; &lt;code&gt;Math.log2()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;log10&quot;&gt; &lt;code&gt;Math.log10()&lt;/code&gt; &lt;/a&gt; . 다른 염기에 대한 로그가 필요한 경우 아래 예와 같이 Math.log (x) / Math.log (otherBase)를 사용하십시오. 1 / Math.log (otherBase)를 미리 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68beaac9d5aafe09513d7eccd070b1b3d71bb486" translate="yes" xml:space="preserve">
          <source>If you need the natural log of 2 or 10, use the constants &lt;a href=&quot;ln2&quot;&gt;&lt;code&gt;Math.LN2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ln10&quot;&gt;&lt;code&gt;Math.LN10&lt;/code&gt;&lt;/a&gt;. If you need a logarithm to base 2 or 10, use &lt;a href=&quot;log2&quot;&gt;&lt;code&gt;Math.log2()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;log10&quot;&gt;&lt;code&gt;Math.log10()&lt;/code&gt;&lt;/a&gt;. If you need a logarithm to other bases, use Math.log(x) / Math.log(otherBase) as in the example below; you might want to precalculate 1 / Math.log(otherBase).</source>
          <target state="translated">2 또는 10의 자연 로그가 필요하면 &lt;a href=&quot;ln2&quot;&gt; &lt;code&gt;Math.LN2&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;ln10&quot;&gt; &lt;code&gt;Math.LN10&lt;/code&gt; &lt;/a&gt; 또는 Math.LN10을 사용하십시오 . 2 또는 10을 밑으로하는 로그가 필요하면 &lt;a href=&quot;log2&quot;&gt; &lt;code&gt;Math.log2()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;log10&quot;&gt; &lt;code&gt;Math.log10()&lt;/code&gt; &lt;/a&gt; . 다른 밑수에 대한 로그가 필요하면 아래 예제와 같이 Math.log (x) / Math.log (otherBase)를 사용하십시오. 1 / Math.log (otherBase)를 미리 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9dd66eafaabe75ecf9115145d2b767ab19cb10" translate="yes" xml:space="preserve">
          <source>If you need to define a property without a value, you might use &lt;a href=&quot;../global_objects/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; as a value.</source>
          <target state="translated">값없이 속성을 정의해야하는 경우 &lt;a href=&quot;../global_objects/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f2598944e0ea66e2ceaf4e11c59c0cdff9b64a0" translate="yes" xml:space="preserve">
          <source>If you need to export the default, write the following instead:</source>
          <target state="translated">기본값을 내 보내야하는 경우 대신 다음을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="48354edaa3e95aef6e6a48c3e5f6b6df17eeb92b" translate="yes" xml:space="preserve">
          <source>If you need to find if a value &lt;strong&gt;exists&lt;/strong&gt; in an array, use &lt;a href=&quot;includes&quot;&gt;&lt;code&gt;Array.prototype.includes()&lt;/code&gt;&lt;/a&gt;. Again, it checks each element for equality with the value instead of using a testing function.</source>
          <target state="translated">값 &lt;strong&gt;이&lt;/strong&gt; 배열에 &lt;strong&gt;있는지&lt;/strong&gt; 확인해야하는 경우 &lt;a href=&quot;includes&quot;&gt; &lt;code&gt;Array.prototype.includes()&lt;/code&gt; &lt;/a&gt; . 다시 말하지만, 테스트 기능을 사용하는 대신 각 요소가 값과 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f6d63d0046baee1f832f04d68cdceccdcee365fd" translate="yes" xml:space="preserve">
          <source>If you need to find if any element satisfies the provided testing function, use &lt;a href=&quot;some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 테스트 함수를 충족하는 요소가 있는지 확인하려면 &lt;a href=&quot;some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92ed2ad090bbb7a6fac237e3660f1c52e2f3ec91" translate="yes" xml:space="preserve">
          <source>If you need to find the &lt;strong&gt;index of a value&lt;/strong&gt;, use &lt;a href=&quot;indexof&quot;&gt;&lt;code&gt;Array.prototype.indexOf()&lt;/code&gt;&lt;/a&gt;. (It&amp;rsquo;s similar to &lt;a href=&quot;findindex&quot;&gt;&lt;code&gt;findIndex()&lt;/code&gt;&lt;/a&gt;, but checks each element for equality with the value instead of using a testing function.)</source>
          <target state="translated">&lt;strong&gt;값&lt;/strong&gt; 의 &lt;strong&gt;인덱스&lt;/strong&gt; 를 찾아야하는 경우 &lt;a href=&quot;indexof&quot;&gt; &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; . ( &lt;a href=&quot;findindex&quot;&gt; &lt;code&gt;findIndex()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 테스트 함수를 사용하는 대신 각 요소가 값과 같은지 확인합니다.)</target>
        </trans-unit>
        <trans-unit id="2f7b0f1b470fc3559b362594aea4dada581a211a" translate="yes" xml:space="preserve">
          <source>If you need to find the position of an element or whether an element exists in an array, use &lt;a href=&quot;indexof&quot;&gt;&lt;code&gt;Array.prototype.indexOf()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;includes&quot;&gt;&lt;code&gt;Array.prototype.includes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소의 위치를 ​​찾거나 요소가 배열에 있는지 여부를 확인하려면 &lt;a href=&quot;indexof&quot;&gt; &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;includes&quot;&gt; &lt;code&gt;Array.prototype.includes()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53ac54e6412bacc63b8624a67da085e48a736a3a" translate="yes" xml:space="preserve">
          <source>If you need to know if a string matches a regular expression &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;../regexp/test&quot;&gt;&lt;code&gt;RegExp.test()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열이 정규식 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 와 일치하는지 알아야하는 경우 &lt;a href=&quot;../regexp/test&quot;&gt; &lt;code&gt;RegExp.test()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9701887d047bb96bcab9229f97c6b2c436038b1d" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that do not support &lt;a href=&quot;../object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;, it is best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you cannot make them non-enumerable.</source>
          <target state="translated">&lt;a href=&quot;../object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; 를&lt;/a&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메서드를 열거 불가능하게 만들 수 없으므로 폴리 필하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="98c814d727deb065c2a896b0632604aebd175c33" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;a href=&quot;../object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;a href=&quot;../object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; 를&lt;/a&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메서드를 열거 불가능하게 만들 수 없으므로 폴리 필하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe432265bccad633d8efa5ca4d1fac0eea99e3f" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them &lt;strong&gt;non-enumerable&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메소드 를 polyfill하지 않는 것이 가장 좋습니다 . &lt;strong&gt;열거&lt;/strong&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b656e640c400c1887a63c15bbd8901d8a955a1f8" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 열거 할 수 없으므로 &lt;code&gt;Array.prototype&lt;/code&gt; 메소드 를 polyfill하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bd9f376dc29844e3f900bec4366cbbf039c586ee" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt;, it is best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; at all, as you cannot make it non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt; 를 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 을 열거 불가능하게 만들 수 없으므로 Polyfill Array.prototype 을 아예 사용하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="57168d3fef20557c94e31ea753dbe3ba115b9dc4" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt; 를 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 , &lt;code&gt;Array.prototype&lt;/code&gt; 메소드를 열거 할 수 없으므로 polyfill하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3edaaddf2630ab4d776484bd61b50696d946fc29" translate="yes" xml:space="preserve">
          <source>If you need to use an assignment in a conditional expression, a common practice is to put additional parentheses around the assignment. For example:</source>
          <target state="translated">조건식에 대입을 사용해야하는 경우 일반적으로 대입을 괄호로 묶는 것이 일반적입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d40d82c950e9a812cd674e6001dbf28de03af32b" translate="yes" xml:space="preserve">
          <source>If you only want the first match found, you might want to use &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">첫 번째 일치 항목 만 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 려면 RegExp.exec ()를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c57242f318553d3f36f9cf38af0a4f7480baa928" translate="yes" xml:space="preserve">
          <source>If you only want to consider properties attached to the object itself, and not its prototypes, use &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt;&lt;code&gt;getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt; or perform a &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt; check (&lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt;&lt;code&gt;propertyIsEnumerable()&lt;/code&gt;&lt;/a&gt; can also be used). Alternatively, if you know there won't be any outside code interference, you can extend built-in prototypes with a check method.</source>
          <target state="translated">프로토 타입이 아니라 객체 자체에 연결된 속성 만 고려하려는 경우 &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt; &lt;code&gt;getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 검사를 수행합니다 ( &lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt; &lt;code&gt;propertyIsEnumerable()&lt;/code&gt; &lt;/a&gt; 도 사용할 수 있음). 또는 외부 코드 간섭이 없다는 것을 알고 있다면 check 메서드를 사용하여 내장 프로토 타입을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735530012ac3a4439f6528b8ed499f68e90f9884" translate="yes" xml:space="preserve">
          <source>If you only want to consider properties attached to the object itself, and not its prototypes, use &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt;&lt;code&gt;getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt; or perform a &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt; check (&lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt;&lt;code&gt;propertyIsEnumerable&lt;/code&gt;&lt;/a&gt; can also be used). Alternatively, if you know there won't be any outside code interference, you can extend built-in prototypes with a check method.</source>
          <target state="translated">프로토 타입이 아닌 객체 자체에 연결된 속성 만 고려하려면 &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt; &lt;code&gt;getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 검사를 수행 하십시오 ( &lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt; &lt;code&gt;propertyIsEnumerable&lt;/code&gt; &lt;/a&gt; 도 사용할 수 있음). 또는 외부 코드 간섭이 없다는 것을 알고 있다면 확인 방법으로 내장 프로토 타입을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e97d2b27233fdaf7731ef52386bfd0124047bc8" translate="yes" xml:space="preserve">
          <source>If you really want to create a &lt;code&gt;Symbol&lt;/code&gt; wrapper object, you can use the &lt;code&gt;Object()&lt;/code&gt; function:</source>
          <target state="translated">실제로 &lt;code&gt;Symbol&lt;/code&gt; 래퍼 객체 를 만들려면 &lt;code&gt;Object()&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1843b29c2d5c6fd4913d7563bf6437e92296a87" translate="yes" xml:space="preserve">
          <source>If you return &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be added to the JSON string.</source>
          <target state="translated">당신이 돌아 오면 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 가 json으로 문자열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec5df79d7c885974c5aa582c610905dc7cdac8d" translate="yes" xml:space="preserve">
          <source>If you return &lt;code&gt;undefined&lt;/code&gt;, the property is not included (i.e., filtered out) in the output JSON string.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 속성이 출력 JSON 문자열에 포함되지 않습니다 (즉, 필터링 됨).</target>
        </trans-unit>
        <trans-unit id="2c70929d7e200a5fe36f9edeb06a1b0a8c7a9d88" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, &quot;true&quot; or &quot;false&quot; is used as the property's value, as appropriate, when adding it to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 을 반환 하면 JSON 문자열에 추가 할 때 &quot;true&quot;또는 &quot;false&quot;가 속성 값으로 적절하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aebe43fc49075ca5e764acfd1f8b57b86a33df55" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, the property is not included in the output.</source>
          <target state="translated">&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 를 반환 하면 속성이 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dba4f295774a527ffbb538fec3b29039be43a105" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, the stringified version of that value is used as the property's value.</source>
          <target state="translated">&lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 반환하는 경우 해당 값의 문자열 버전이 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb68ba0a762626c3b4353aedeeb2ffb44a69ed51" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, the string corresponding to that number is used as the value for the property when added to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 를 반환하면 해당 숫자에 해당하는 문자열이 JSON 문자열에 추가 될 때 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b5099af9e7be5c72550fd23afd94bd55e6142b2" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, that string is used as the property's value when adding it to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 반환하면 해당 문자열이 JSON 문자열에 추가 될 때 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="131cdc0db5e0530808f6767f2a2daddd0e55eba1" translate="yes" xml:space="preserve">
          <source>If you return any other object, the object is recursively stringified into the JSON string, calling the &lt;code&gt;replacer&lt;/code&gt; function on each property, unless the object is a function, in which case nothing is added to the JSON string.</source>
          <target state="translated">다른 객체를 반환하면 객체가 함수가 아닌 한 JSON 문자열에 아무것도 추가되지 않는 한 각 속성 에서 &lt;code&gt;replacer&lt;/code&gt; 함수를 호출하여 객체가 JSON 문자열로 반복적으로 문자열 화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce9a704ee385f7c72710bc2ca6fef00b73d2fb09" translate="yes" xml:space="preserve">
          <source>If you return any other object, the object is recursively stringified, calling the &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; function on each property.</source>
          <target state="translated">다른 객체를 반환하면 객체가 재귀 적으로 문자열 화 되어 각 속성에 대해 &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="61d92592decdab65c8c7d88c8b2e526399e93164" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;getBaseLog(10, 1000)&lt;/code&gt; it returns &lt;code&gt;2.9999999999999996&lt;/code&gt; due to floating-point rounding, which is very close to the actual answer of 3.</source>
          <target state="translated">&lt;code&gt;getBaseLog(10, 1000)&lt;/code&gt; 를 실행 하면 부동 소수점 반올림으로 인해 &lt;code&gt;2.9999999999999996&lt;/code&gt; 을 반환 하며 이는 실제 답변 3에 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="935b1b976508db5afe6cca08176c17239b09c114" translate="yes" xml:space="preserve">
          <source>If you set a property to &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; but do not delete it, the &lt;code&gt;in&lt;/code&gt; operator returns true for that property.</source>
          <target state="translated">속성을 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 로&lt;/a&gt; 설정 했지만 삭제하지 않으면 &lt;code&gt;in&lt;/code&gt; 연산자는 해당 속성에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34e10440b87179c5669d287c33d08bce47b6fa19" translate="yes" xml:space="preserve">
          <source>If you specify a different number of elements to insert than the number you're removing, the array will have a different length at the end of the call.</source>
          <target state="translated">제거 할 번호와 다른 개수의 요소를 삽입하면 통화 종료시 배열의 길이가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="682d3439d2fa9871ecad9eae1652e23eb74f6221" translate="yes" xml:space="preserve">
          <source>If you specify a number outside the expected range, the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object is updated accordingly. For example, if you specify 1005, the number of seconds is incremented by 1, and 5 is used for the milliseconds.</source>
          <target state="translated">예상 범위를 벗어난 숫자를 지정하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보 가 그에 따라 업데이트됩니다. 예를 들어 1005를 지정하면 초 수가 1 씩 증가하고 5가 밀리 초로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="32c4cced0b807fb68ae6694984513b4abd3c73a9" translate="yes" xml:space="preserve">
          <source>If you specify any object, including a &lt;code&gt;Boolean&lt;/code&gt; object whose value is &lt;code&gt;false&lt;/code&gt;, as the initial value of a &lt;code&gt;Boolean&lt;/code&gt; object, the new &lt;code&gt;Boolean&lt;/code&gt; object has a value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">당신이 포함 개체 지정하면 &lt;code&gt;Boolean&lt;/code&gt; 값입니다 오브젝트 &lt;code&gt;false&lt;/code&gt; a의 초기 값으로, &lt;code&gt;Boolean&lt;/code&gt; 개체, 새로운 &lt;code&gt;Boolean&lt;/code&gt; 객체의 값이 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ae5f892e8f6de3201d6782cad351ca1383c87b" translate="yes" xml:space="preserve">
          <source>If you use a method for a numeric literal and the numeric literal has no exponent and no decimal point, leave white-space(s) before the dot that precedes the method call to prevent the dot from being interpreted as a decimal point.</source>
          <target state="translated">숫자 리터럴에 메소드를 사용하고 숫자 리터럴에 지수가없고 소수점이없는 경우, 점이 소수점으로 해석되지 않도록 메소드 호출 앞에있는 점 앞에 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="edd6afd92c9f7a2538aece19a2aa77da3a6f3da8" translate="yes" xml:space="preserve">
          <source>If you use a method for a numeric literal, and the numeric literal has no exponent and no decimal point, you should leave &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;white-space(s)&lt;/a&gt; before the dot preceding the method call, so that the dot is not interpreted as a decimal point.</source>
          <target state="translated">숫자 리터럴에 메서드를 사용하고 숫자 리터럴에 지수와 소수점이없는 경우 메서드 호출 앞의 점 앞에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;공백을&lt;/a&gt; 두어야 점이 소수점으로 해석되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="a5f1d9b94d0b0382335af42f55617a4070d22713" translate="yes" xml:space="preserve">
          <source>If you use an unconditional &lt;code&gt;catch&lt;/code&gt; clause with one or more conditional &lt;code&gt;catch&lt;/code&gt; clauses, the unconditional &lt;code&gt;catch&lt;/code&gt; clause must be specified last. Otherwise, the unconditional &lt;code&gt;catch&lt;/code&gt; clause will intercept all types of exception before they can reach the conditional ones.</source>
          <target state="translated">당신이 무조건 사용하는 경우 &lt;code&gt;catch&lt;/code&gt; 하나 개 이상의 조건과 절을 &lt;code&gt;catch&lt;/code&gt; 조항, 무조건 &lt;code&gt;catch&lt;/code&gt; 절은 마지막으로 지정해야합니다. 그렇지 않으면 무조건 &lt;code&gt;catch&lt;/code&gt; 절은 조건부 예외에 도달하기 전에 모든 유형의 예외를 가로 챌 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7698d65a3ba0451a9068546d38d02d3c21a92ac" translate="yes" xml:space="preserve">
          <source>If you use callbacks or fetch methods from an object with &lt;a href=&quot;destructuring_assignment#Object_destructuring&quot;&gt;a destructuring assignment&lt;/a&gt;, you may have non-existent values that you cannot call as functions unless you have tested their existence. Using &lt;code&gt;?.&lt;/code&gt;, you can avoid this extra test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78afbb13097de5c8b78471387fa8f8af3bf94b11" translate="yes" xml:space="preserve">
          <source>If you use normal JavaScript floating point numbers in imul, you will experience a degrade in performance. This is because of the costly conversion from a floating point to an integer for multiplication, and then converting the multiplied integer back into a floating point. The reason imul exists is because it is faster in only one (so far) circumstance: AsmJS. AsmJS allows for JIST-optimizers to more easily implement internal integers in JavaScript. Multiplying two numbers stored internally as integers (which is only possible with AsmJS) with imul is the only potential circumstance where Math.imul may prove performant in current browsers.</source>
          <target state="translated">imul에서 일반 JavaScript 부동 소수점 숫자를 사용하면 성능이 저하됩니다. 이는 곱하기 위해 부동 소수점에서 정수로의 비용이 많이 드는 변환과 곱한 정수를 다시 부동 소수점으로 변환하기 때문입니다. imul이 존재하는 이유는 오직 하나의 (지금까지) 상황에서 더 빠르기 때문입니다 : AsmJS. AsmJS를 사용하면 JIST 최적화 프로그램이 JavaScript에서 내부 정수를보다 쉽게 ​​구현할 수 있습니다. 내부적으로 정수로 저장된 두 숫자 (AsmJS에서만 가능함)를 imul과 곱하는 것은 Math.imul이 현재 브라우저에서 성능을 입증 할 수있는 유일한 잠재적 상황입니다.</target>
        </trans-unit>
        <trans-unit id="5d05f89ff9b94e2efe15b7bec1cbbc6dcdeb7392" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;eval&lt;/code&gt; function &lt;em&gt;indirectly,&lt;/em&gt; by invoking it via a reference other than &lt;code&gt;eval&lt;/code&gt;, &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;as of ECMAScript 5&lt;/a&gt; it works in the global scope rather than the local scope. This means, for instance, that function declarations create global functions, and that the code being evaluated doesn't have access to local variables within the scope where it's being called.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;eval&lt;/code&gt; 기능을 &lt;em&gt;간접적&lt;/em&gt; 이외의 참조를 통해 호출에 의해 &lt;code&gt;eval&lt;/code&gt; , &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMAScript를 5로&lt;/a&gt; 는 전역 영역이 아닌 로컬 범위에서 작동합니다. 예를 들어, 함수 선언은 전역 함수를 작성하고 평가중인 코드는 호출되는 범위 내에서 로컬 변수에 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73d1c2ee0e60284da071d578e3277739538eefac" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;toExponential()&lt;/code&gt; method for a numeric literal and the numeric literal has no exponent and no decimal point, leave whitespace(s) before the dot that precedes the method call to prevent the dot from being interpreted as a decimal point.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;toExponential()&lt;/code&gt; 숫자 리터럴에 대한 방법과 숫자 리터럴 메서드 호출 선행는 소수점으로 해석되는 점을 방지한다는 점 이전에는 지수없이 소수점, 휴가 공백 (들)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="597a2c20eb78f0898e472f8de984f91f02ea471c" translate="yes" xml:space="preserve">
          <source>If you want &lt;em&gt;all&lt;/em&gt; properties&amp;mdash;including non-enumerables&amp;mdash;see &lt;a href=&quot;getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 형이 아닌 속성을 포함한 &lt;em&gt;모든&lt;/em&gt; 속성 을 원하는 경우 &lt;a href=&quot;getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d19c207f7baf216ddd324adb7472fc913a7eb3d" translate="yes" xml:space="preserve">
          <source>If you want all properties, even non-enumerables, see &lt;a href=&quot;getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 불가능한 모든 속성을 원하면 &lt;a href=&quot;getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2948b5beeb992bfbdd3d635cd05e062df02e23d7" translate="yes" xml:space="preserve">
          <source>If you want an array element to exist but have an undefined value, use the &lt;code&gt;undefined&lt;/code&gt; value instead of the &lt;code&gt;delete&lt;/code&gt; operator. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is assigned the value &lt;code&gt;undefined&lt;/code&gt;, but the array element still exists:</source>
          <target state="translated">배열 요소가 존재하지만 &lt;code&gt;undefined&lt;/code&gt; 값을 가지려면 &lt;code&gt;delete&lt;/code&gt; 연산자 대신 정의되지 않은 값을 사용하십시오 . 다음 예에서 &lt;code&gt;trees[3]&lt;/code&gt; 에는 &lt;code&gt;undefined&lt;/code&gt; 값이 할당 되지만 배열 요소는 여전히 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9b17dbe4a9978e35e0df77cda82cc871d93e5145" translate="yes" xml:space="preserve">
          <source>If you want an array element to exist but have an undefined value, use the &lt;code&gt;undefined&lt;/code&gt; value instead of the &lt;code&gt;delete&lt;/code&gt; operator. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is assigned the value undefined, but the array element still exists:</source>
          <target state="translated">배열 요소가 존재하지만 &lt;code&gt;undefined&lt;/code&gt; 값을 가지려면 &lt;code&gt;delete&lt;/code&gt; 연산자 대신 정의되지 않은 값을 사용하십시오 . 다음 예제에서 &lt;code&gt;trees[3]&lt;/code&gt; 에는 undefined 값이 할당되지만 배열 요소는 여전히 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2418cdf14fe502c2af1708e66eb2202ca0a9648f" translate="yes" xml:space="preserve">
          <source>If you want only the enumerable properties, see &lt;a href=&quot;keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; or use a &lt;a href=&quot;../../statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/a&gt; loop (although note that this will return enumerable properties not only found directly upon that object but also along the prototype chain for the object unless the latter is filtered with &lt;a href=&quot;hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">열거 가능한 속성 만 원하는 경우 &lt;a href=&quot;keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 참조 하거나 &lt;a href=&quot;../../statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt; 루프를 사용하십시오 (그러나 이것은 객체에서 직접 찾을 수있을뿐만 아니라 객체의 프로토 타입 체인을 따라 열거 가능한 속성을 반환합니다. 후자는 &lt;a href=&quot;hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 로 필터링됩니다 .</target>
        </trans-unit>
        <trans-unit id="39e653fdc0628060fb29f300dfac7bff4e0e7b80" translate="yes" xml:space="preserve">
          <source>If you want only the enumerable properties, see &lt;a href=&quot;keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; or use a &lt;a href=&quot;../../statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/a&gt; loop (note that this will also return enumerable properties found along the prototype chain for the object unless the latter is filtered with &lt;a href=&quot;hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">열거 가능한 속성 만 원하면 &lt;a href=&quot;keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 참조 하거나 &lt;a href=&quot;../../statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt; 루프 를 사용합니다 (후자가 &lt;a href=&quot;hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 필터링되지 않는 한 객체의 프로토 타입 체인을 따라 발견 된 열거 가능한 속성도 반환됩니다 ) .</target>
        </trans-unit>
        <trans-unit id="081dc7a00575a1581dcf7b3a349ab503bed65012" translate="yes" xml:space="preserve">
          <source>If you want to change the value of &quot;arg&quot; in the function body, you can do so, but you do not need to declare the same variable again. In other words: you can omit the &lt;code&gt;let&lt;/code&gt; keyword. If you want to create a new variable, you need to rename it as conflicts with the function parameter already.</source>
          <target state="translated">함수 본문에서 &quot;arg&quot;값을 변경하려면 변경할 수 있지만 동일한 변수를 다시 선언 할 필요는 없습니다. 즉, &lt;code&gt;let&lt;/code&gt; 키워드를 생략 할 수 있습니다 . 새 변수를 작성하려면 이미 함수 매개 변수와 충돌하여 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c69934f7bf2e4d350baba14d96404b2849e4d9" translate="yes" xml:space="preserve">
          <source>If you want to create an &lt;code&gt;&lt;a href=&quot;../global_objects/array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../global_objects/boolean&quot;&gt;Booleans&lt;/a&gt;&lt;/code&gt; from a mask you can use this code:</source>
          <target state="translated">당신이 만들려면 &lt;code&gt;&lt;a href=&quot;../global_objects/array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../global_objects/boolean&quot;&gt;Booleans&lt;/a&gt;&lt;/code&gt; 마스크에서이 코드를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c34494acb146a03229822964024372e46e20d7ed" translate="yes" xml:space="preserve">
          <source>If you want to disallow setting a new prototype for your object, your handler's &lt;code&gt;setPrototypeOf()&lt;/code&gt; method can either return &lt;code&gt;false&lt;/code&gt;, or it can throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a31baeccc4d5cda15fdaad0b7733d54070608b" translate="yes" xml:space="preserve">
          <source>If you want to disallow setting a new prototype for your object, your handler's &lt;code&gt;setPrototypeOf&lt;/code&gt; method can either return &lt;code&gt;false&lt;/code&gt;, or it can throw an exception.</source>
          <target state="translated">객체에 새 프로토 타입을 설정하지 못하게하려면 처리기의 &lt;code&gt;setPrototypeOf&lt;/code&gt; 메서드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 예외를 throw 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4823c44fafa3ab81be841e2d53941d57b47410" translate="yes" xml:space="preserve">
          <source>If you want to export a single value or need a fallback value for a module, a default export can be used:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 대한 폴백 값이 필요한 경우 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50cbe95c4ee11ee4d5865b13d455d501fdd62c86" translate="yes" xml:space="preserve">
          <source>If you want to obtain capture groups and the global flag is set, you need to use &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;matchall&quot;&gt;&lt;code&gt;String.prototype.matchAll()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">캡처 그룹을 얻으려면 전역 플래그가 설정되어 있으면 대신 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;matchall&quot;&gt; &lt;code&gt;String.prototype.matchAll()&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d27f9e5e25120e14455ea16bd96cef1e320218ef" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current class inside the class body, you can create a &lt;em&gt;named class expression&lt;/em&gt;. The name is only visible within the scope of the class expression itself.</source>
          <target state="translated">클래스 본문 내에서 현재 클래스를 참조하려면 &lt;em&gt;명명 된 클래스 expression을&lt;/em&gt; 만들 수 있습니다 . 이름은 클래스 표현식 자체의 범위 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc47424fb527730f62198aaaa25c3348ff0fba7" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current class inside the class body, you can create a named class expression. This name is only visible in the scope of the class expression itself.</source>
          <target state="translated">클래스 본문 내에서 현재 클래스를 참조하려는 경우 명명 된 클래스 표현식을 작성할 수 있습니다. 이 이름은 클래스 표현식 자체의 범위에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481ba14f2f65c81318d305b87a92b52bfe033114" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current function inside the function body, you need to create a named function expression. &lt;u&gt;&lt;strong&gt;This name is then local only to the function body (scope)&lt;/strong&gt;&lt;/u&gt;. This also avoids using the non-standard &lt;a href=&quot;../functions/arguments/callee&quot;&gt;&lt;code&gt;arguments.callee&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">함수 본문 내에서 현재 함수를 참조하려면 명명 된 함수 표현식을 만들어야합니다. &lt;u&gt;&lt;strong&gt;이 이름은 함수 본문 (범위)에만 로컬&lt;/strong&gt;&lt;/u&gt; 입니다. 이것은 또한 비표준 &lt;a href=&quot;../functions/arguments/callee&quot;&gt; &lt;code&gt;arguments.callee&lt;/code&gt; &lt;/a&gt; 속성 사용을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="9597ad4f9e7ad14879829bc41d7ee7dd8599f31b" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current function inside the function body, you need to create a named function expression. &lt;u&gt;&lt;strong&gt;This name is then local only to the function body (scope)&lt;/strong&gt;&lt;/u&gt;. This also avoids using the non-standard &lt;code&gt;&lt;a href=&quot;../functions/arguments/callee&quot;&gt;arguments.callee&lt;/a&gt;&lt;/code&gt; property.</source>
          <target state="translated">함수 본문 내에서 현재 함수를 참조하려면 명명 된 함수 표현식을 작성해야합니다. &lt;u&gt;&lt;strong&gt;이 이름은 함수 본문 (scope)에만 로컬&lt;/strong&gt;&lt;/u&gt; 입니다. 또한 비표준 &lt;code&gt;&lt;a href=&quot;../functions/arguments/callee&quot;&gt;arguments.callee&lt;/a&gt;&lt;/code&gt; 속성을 사용하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="99528303e4fa98874c6d3b7da8c65a874a1f9d0b" translate="yes" xml:space="preserve">
          <source>If you want to remove the getter, you can just &lt;a href=&quot;../operators/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; it:</source>
          <target state="translated">getter를 제거 &lt;a href=&quot;../operators/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a7fc22c8401e0f59ce33412d5d1a62fa14a2a8f0" translate="yes" xml:space="preserve">
          <source>If you want to remove the getter, you can just &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; it:</source>
          <target state="translated">게터를 제거 &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e1fd57c263b80cc07ff24ec488e383d11e16fe7f" translate="yes" xml:space="preserve">
          <source>If you want to remove the setter, you can just &lt;a href=&quot;../operators/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; it:</source>
          <target state="translated">setter를 제거 &lt;a href=&quot;../operators/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="afab6a24815f73f4c694b81bf63bd41e2e5c193b" translate="yes" xml:space="preserve">
          <source>If you want to remove the setter, you can just &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; it:</source>
          <target state="translated">세터를 제거 &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a8801610bdd961430a0f13ef356227a205175f" translate="yes" xml:space="preserve">
          <source>If you want to see how to use the &lt;code&gt;Object.defineProperty&lt;/code&gt; method with a &lt;em&gt;binary-flags-like&lt;/em&gt; syntax, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;additional examples&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이진 플래그와 같은&lt;/em&gt; 구문으로 &lt;code&gt;Object.defineProperty&lt;/code&gt; 메서드 를 사용하는 방법을 보려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;추가 예제를&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a33a81af4ee501f0c074526b9710c19c67c2ea6e" translate="yes" xml:space="preserve">
          <source>If you want to see how to use the &lt;code&gt;Object.defineProperty&lt;/code&gt; method with a &lt;em&gt;binary-flags-like&lt;/em&gt; syntax, see &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;additional examples&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;바이너리 플래그와 유사한&lt;/em&gt; 구문으로 &lt;code&gt;Object.defineProperty&lt;/code&gt; 메서드 를 사용하는 방법을 보려면 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;추가 예제를&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="088b49e17dfc48492f7ae931aa8eea2f898fed94" translate="yes" xml:space="preserve">
          <source>If you want to use an ordered associative array in a cross-browser environment, use a &lt;a href=&quot;../global_objects/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; object if available, or simulate this structure with two separate arrays (one for the keys and the other for the values), or build an array of single-property objects, etc.</source>
          <target state="translated">크로스 브라우저 환경에서 정렬 된 연관 배열을 사용하려면 사용 가능한 경우 &lt;a href=&quot;../global_objects/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 오브젝트를 사용하거나 두 개의 개별 배열 (키 및 다른 값)로이 구조를 시뮬레이션하거나 단일 배열을 빌드하십시오. 속성 개체 등</target>
        </trans-unit>
        <trans-unit id="19381b630a3a814e91674608c14a389044af178b" translate="yes" xml:space="preserve">
          <source>If you were to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; as the second argument to &lt;code&gt;reduce()&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 대한 두 번째 인수로 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 를 제공 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffb5ffcd2b43a51e7c0b5d8ecc72c4f2fa812052" translate="yes" xml:space="preserve">
          <source>If you were to provide an initial value as the second argument to &lt;code&gt;reduce()&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 의 두 번째 인수로 초기 값을 제공 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9641348677babae98e66baf7b0dc8fe9f67d1d9b" translate="yes" xml:space="preserve">
          <source>If you wish to await two or more promises in parallel, you must still use &lt;code&gt;Promise#then&lt;/code&gt;, as &lt;code&gt;parallel&lt;/code&gt; does in the example.</source>
          <target state="translated">두 개 이상의 약속을 병렬로 기다리 려면 예제에서 &lt;code&gt;parallel&lt;/code&gt; 과 마찬가지로 &lt;code&gt;Promise#then&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c253c1c3b6acd6d4520eacac9b373475e00e1fb8" translate="yes" xml:space="preserve">
          <source>If you wish to inherit from multiple objects, then mixins are a possibility.</source>
          <target state="translated">여러 객체에서 상속하려면 믹스 인이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b358a85c79019bc0c27a5e9a086df327f3612e47" translate="yes" xml:space="preserve">
          <source>If you wish to safely perform two or more jobs in parallel, you must await a call to &lt;code&gt;&lt;a href=&quot;../global_objects/promise/all&quot;&gt;Promise.all&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../global_objects/promise/allsettled&quot;&gt;Promise.allSettled&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 작업을 병렬로 안전하게 수행하려면 &lt;code&gt;&lt;a href=&quot;../global_objects/promise/all&quot;&gt;Promise.all&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../global_objects/promise/allsettled&quot;&gt;Promise.allSettled&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 기다려야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d85b069cf65c1056e4db1149435fcd8a68335dc" translate="yes" xml:space="preserve">
          <source>If you wish to support the use of a bound function only using &lt;a href=&quot;../../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, or only by calling it, the target function must enforce that restriction.</source>
          <target state="translated">&lt;a href=&quot;../../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 만 사용 하거나 호출 하여 바인딩 함수 사용을 지원 하려면 대상 함수가 해당 제한을 시행해야합니다.</target>
        </trans-unit>
        <trans-unit id="28b16738f775180a66d096e17e9c0fac48e31c55" translate="yes" xml:space="preserve">
          <source>If you're experimenting with code in a web browser, such as the Firefox Web Console (&lt;strong&gt;Tools &lt;/strong&gt;&amp;gt;&lt;strong&gt; Web Developer &lt;/strong&gt;&amp;gt;&lt;strong&gt; Web Console&lt;/strong&gt;) and you 'Run' a definition of a class with the same name twice, you'll get a &lt;code&gt;SyntaxError: redeclaration of let &lt;em&gt;ClassName&lt;/em&gt;;&lt;/code&gt;. (See further discussion of this issue in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1428672&quot;&gt;bug 1428672&lt;/a&gt;.) Doing something similar in Chrome Developer Tools gives you a message like &lt;code&gt;Uncaught SyntaxError: Identifier '&lt;em&gt;ClassName&lt;/em&gt;' has already been declared at &amp;lt;anonymous&amp;gt;:1:1&lt;/code&gt;.</source>
          <target state="translated">Firefox Web Console ( &lt;strong&gt;Tools&lt;/strong&gt; &amp;gt; &lt;strong&gt;Web Developer&lt;/strong&gt; &amp;gt; &lt;strong&gt;Web Console&lt;/strong&gt; )과 같은 웹 브라우저에서 코드를 실험 하고 같은 이름의 클래스 정의를 두 번 '실행'하면 &lt;code&gt;SyntaxError: redeclaration of let &lt;em&gt;ClassName&lt;/em&gt;;&lt;/code&gt; . ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1428672&quot;&gt;버그 1428672&lt;/a&gt; 에서이 문제에 대한 자세한 설명을 참조하십시오 .) Chrome 개발자 도구에서 비슷한 작업을 수행하면 &lt;code&gt;Uncaught SyntaxError: Identifier '&lt;em&gt;ClassName&lt;/em&gt;' has already been declared at &amp;lt;anonymous&amp;gt;:1:1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1718e56ab56bc63e9b5c1230d10ad98783a6bcb6" translate="yes" xml:space="preserve">
          <source>If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:</source>
          <target state="translated">클래스가 파생 클래스 인 경우 기본 생성자는 부모 생성자를 호출하여 제공된 모든 인수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ff747b0e98166bc150b8d30636e3f74d34a1334b" translate="yes" xml:space="preserve">
          <source>If your code has just created a &lt;code&gt;WeakRef&lt;/code&gt; for a target object, or has gotten a target object from a &lt;code&gt;WeakRef&lt;/code&gt;'s &lt;code&gt;deref&lt;/code&gt; method, that target object will not be reclaimed until the end of the current JavaScript &lt;a href=&quot;https://tc39.es/ecma262/#job&quot;&gt;job&lt;/a&gt; (including any promise reaction jobs that run at the end of a script job). That is, you can only &quot;see&quot; an object get reclaimed between turns of the event loop. This is primarily to avoid making the behavior of any given JavaScript engine's garbage collector apparent in code &amp;mdash; because if it were, people would write code relying on that behavior, which would break when the garbage collector's behavior changed. (Garbage collection is a hard problem; JavaScript engine implementers are constantly refining and improving how it works.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3ce3648420f55b4147d24cab187f467076e9ce" translate="yes" xml:space="preserve">
          <source>If your project uses packages that export ESM, you can also import them for side effects only. This will run the code in the package entry point file (and any files it imports) only.</source>
          <target state="translated">프로젝트에서 ESM을 내보내는 패키지를 사용하는 경우 부작용을 위해서만 가져올 수도 있습니다. 그러면 패키지 진입 점 파일 (및 가져 오는 모든 파일)의 코드 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9752f0db065b6780513593f5577369639a2acaaf" translate="yes" xml:space="preserve">
          <source>If your regular expression uses the &quot;&lt;code&gt;g&lt;/code&gt;&quot; flag, you can use the &lt;code&gt;exec()&lt;/code&gt; method multiple times to find successive matches in the same string. When you do so, the search starts at the substring of &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; specified by the regular expression's &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property (&lt;a href=&quot;test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; will also advance the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property). Note that the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property will not be reset when searching a different string, it will start its search at its existing &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; .</source>
          <target state="translated">정규식에서 &quot; &lt;code&gt;g&lt;/code&gt; &quot;플래그를 사용하는 경우 &lt;code&gt;exec()&lt;/code&gt; 메서드를 여러 번 사용하여 동일한 문자열에서 연속적으로 일치하는 항목을 찾을 수 있습니다. 이렇게하면 정규식의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성 ( &lt;a href=&quot;test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 지정된 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; 의 하위 문자열에서 검색이 시작됩니다. .&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성). 참고는 것을&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성은 다른 문자열을 검색 할 때, 그것은 기존에 자사의 검색을 시작합니다 재설정되지 않습니다&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2d04674a5af9a41b5f728b702f2b91de19a7082" translate="yes" xml:space="preserve">
          <source>If your regular expression uses the &quot;&lt;code&gt;g&lt;/code&gt;&quot; flag, you can use the &lt;code&gt;exec()&lt;/code&gt; method multiple times to find successive matches in the same string. When you do so, the search starts at the substring of &lt;code&gt;str&lt;/code&gt; specified by the regular expression's &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property (&lt;a href=&quot;test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; will also advance the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property). Note that the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property will not be reset when searching a different string it will start its search at its existing &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; .</source>
          <target state="translated">정규 표현식에서 &quot; &lt;code&gt;g&lt;/code&gt; &quot;플래그를 사용하는 경우 &lt;code&gt;exec()&lt;/code&gt; 메소드를 여러 번 사용하여 동일한 문자열에서 연속되는 일치 항목을 찾을 수 있습니다. 그렇게 하면 정규 표현식의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성 으로 지정된 &lt;code&gt;str&lt;/code&gt; 의 하위 문자열에서 검색이 시작됩니다 ( &lt;a href=&quot;test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성을 진행시킵니다 ). 참고는 것을 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 다른 캐릭터는 기존에 자사의 검색이 시작됩니다 검색 할 때 속성을 다시 설정되지 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9f12b1dc332abbb2f8fc8ea3de59b0640a4c8e" translate="yes" xml:space="preserve">
          <source>If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:</source>
          <target state="translated">값 배열이 수만 개로 늘어날 수있는 경우 하이브리드 전략을 사용하십시오. 한 번에 배열 청크에 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="00f07d80e0be0674f46c91673837e8b3acb3567d" translate="yes" xml:space="preserve">
          <source>Ignoring some returned values</source>
          <target state="translated">일부 반환 값 무시</target>
        </trans-unit>
        <trans-unit id="57f2c95b766adf67d35d720bd7a552837b1ff2f2" translate="yes" xml:space="preserve">
          <source>Illegal character</source>
          <target state="translated">불법 캐릭터</target>
        </trans-unit>
        <trans-unit id="006c1273c557356ca8147a2c650461ccbefa1ba8" translate="yes" xml:space="preserve">
          <source>Illegal trailing commas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8a946bee9899de71266d734c579d7b3e7c14a0" translate="yes" xml:space="preserve">
          <source>Immediately Invoked Function Expressions</source>
          <target state="translated">즉시 호출 된 함수 표현식</target>
        </trans-unit>
        <trans-unit id="0a98f9ab649d5842f0e2d4409933f707c73e764f" translate="yes" xml:space="preserve">
          <source>Implementation Progress</source>
          <target state="translated">구현 진행</target>
        </trans-unit>
        <trans-unit id="9b0280d6d574941666f9c9ec653db289388ad81c" translate="yes" xml:space="preserve">
          <source>Implementation progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a91ab6749a390ea156750cfc17b1f94b74bf782" translate="yes" xml:space="preserve">
          <source>Implementations may support other subsets, and requests will be negotiated against all available subset-representation combinations to find the best match. Two algorithms are available for this negotiation and selected by the &lt;code&gt;formatMatcher&lt;/code&gt; property: A &lt;a href=&quot;http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher&quot;&gt;fully specified &quot;&lt;code&gt;basic&lt;/code&gt;&quot; algorithm&lt;/a&gt; and an implementation-dependent &quot;&lt;code&gt;best fit&lt;/code&gt;&quot; algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d77a4da59a498bc0526734d1d32ceaf44b25a12" translate="yes" xml:space="preserve">
          <source>Implementations may support other subsets, and requests will be negotiated against all available subset-representation combinations to find the best match. Two algorithms are available for this negotiation and selected by the &lt;code&gt;formatMatcher&lt;/code&gt; property: A &lt;a href=&quot;http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher&quot;&gt;fully specified &lt;code&gt;&quot;basic&quot;&lt;/code&gt; algorithm&lt;/a&gt; and an implementation-dependent &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; algorithm.</source>
          <target state="translated">구현은 다른 부분 집합을 지원할 수 있으며 요청은 사용 가능한 모든 부분 집합 표현 조합에 대해 협상되어 가장 일치하는 것을 찾습니다. 이 협상에 두 가지 알고리즘을 사용할 수 있으며 &lt;code&gt;formatMatcher&lt;/code&gt; 속성에 의해 선택됩니다 . &lt;a href=&quot;http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher&quot;&gt;완전하게 지정된 &lt;code&gt;&quot;basic&quot;&lt;/code&gt; 알고리즘&lt;/a&gt; 과 구현에 따른 &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="9891b7f1f9d2e885ea5e7211c73846949ae5ce55" translate="yes" xml:space="preserve">
          <source>Implemented in JavaScript 1.0.</source>
          <target state="translated">JavaScript 1.0에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="f33ba6d0736fb021c9fc01268c7a34b22e5f56c8" translate="yes" xml:space="preserve">
          <source>Implementing a &lt;code&gt;WeakMap&lt;/code&gt;-like class with a .clear() method</source>
          <target state="translated">.clear () 메소드를 사용 하여 &lt;code&gt;WeakMap&lt;/code&gt; 유사 클래스 구현</target>
        </trans-unit>
        <trans-unit id="0532eeb0dfeca745a29b54a058021727371ec22f" translate="yes" xml:space="preserve">
          <source>Implementing a WeakMap-like class with a .clear() method</source>
          <target state="translated">.clear () 메서드를 사용하여 WeakMap과 유사한 클래스 구현</target>
        </trans-unit>
        <trans-unit id="c749b374aeb24624ee8aa56bb696c115d5f5e9a5" translate="yes" xml:space="preserve">
          <source>Implementing basic set operations</source>
          <target state="translated">기본 설정 작업 구현</target>
        </trans-unit>
        <trans-unit id="b88a338120312301e3ec4ab586557d6a7e9f0f33" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;Function.prototype.toString&lt;/code&gt; revision</source>
          <target state="translated">&lt;code&gt;Function.prototype.toString&lt;/code&gt; 개정을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="380f227f10005ab46ff9c7c323b946317aa5a7e7" translate="yes" xml:space="preserve">
          <source>Implicit call:</source>
          <target state="translated">암시 적 호출 :</target>
        </trans-unit>
        <trans-unit id="7cf7edc6eed680f670f1903e2fa95dffe98c8491" translate="yes" xml:space="preserve">
          <source>Implicit globals and outer function scope</source>
          <target state="translated">암시 적 전역 및 외부 기능 범위</target>
        </trans-unit>
        <trans-unit id="23dadb4aba4124154d197243dcf4d7ef8b8da923" translate="yes" xml:space="preserve">
          <source>Import a module for its side effects only</source>
          <target state="translated">부작용에 대해서만 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">모듈에서 단일 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="a221101514292b5fcf882207fe6e9cbe5953924e" translate="yes" xml:space="preserve">
          <source>Import an entire module for side effects only, without importing anything. This runs the module's global code, but doesn't actually import any values.</source>
          <target state="translated">가져 오기없이 부작용없이 전체 모듈을 가져옵니다. 모듈의 전역 코드를 실행하지만 실제로는 값을 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dba1b2f0c4295b30c790350d8885ab2810a087e" translate="yes" xml:space="preserve">
          <source>Import an entire module's contents</source>
          <target state="translated">전체 모듈 내용 가져 오기</target>
        </trans-unit>
        <trans-unit id="b51d3f221713e66532ca8daeac5ec886156d5d57" translate="yes" xml:space="preserve">
          <source>Import an export with a more convenient alias</source>
          <target state="translated">보다 편리한 별명으로 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="478b4766b3a380867a3862a6ca8bdb0a668262eb" translate="yes" xml:space="preserve">
          <source>Import multiple exports from a module with convenient aliases.</source>
          <target state="translated">편리한 별명을 가진 모듈에서 여러 내보내기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bd9c8faa833f0f94f37e3eaac33816aac5e508cc" translate="yes" xml:space="preserve">
          <source>Import multiple exports from module</source>
          <target state="translated">모듈에서 여러 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="2adb455832e9c0f94412f3522b3179fa5ada0ef0" translate="yes" xml:space="preserve">
          <source>Import the exported module correctly</source>
          <target state="translated">내 보낸 모듈을 올바르게 가져 오기</target>
        </trans-unit>
        <trans-unit id="8d4ecf2834d54b456e6157b4f56fd8d7bf4ecc2a" translate="yes" xml:space="preserve">
          <source>Import/Export mutable globals proposal</source>
          <target state="translated">가변 글로벌 가져 오기 / 내보내기 제안</target>
        </trans-unit>
        <trans-unit id="102ff9d8f76a710f00d76cead3a7e8bba6f5cdfc" translate="yes" xml:space="preserve">
          <source>Importing defaults</source>
          <target state="translated">기본값 가져 오기</target>
        </trans-unit>
        <trans-unit id="f71dcbf6278006d50e621d3d0c3ded43630b6564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt;, &lt;code&gt;new.target&lt;/code&gt; is inherited from the surrounding scope.</source>
          <target state="translated">에 &lt;a href=&quot;../functions/arrow_functions&quot;&gt; 화살표 기능&lt;/a&gt; , &lt;code&gt;new.target&lt;/code&gt; 은 주변 영역에서 상속한다.</target>
        </trans-unit>
        <trans-unit id="a195036ba7dec4c4382e6cf6537c69752b0ed431" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt;, &lt;code&gt;this&lt;/code&gt; retains the value of the enclosing lexical context's &lt;code&gt;this&lt;/code&gt;. In global code, it will be set to the global object:</source>
          <target state="translated">에서는 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; , &lt;code&gt;this&lt;/code&gt; 클로징 콘텍스트 어휘의 값의 유지 &lt;code&gt;this&lt;/code&gt; . 전역 코드에서는 전역 객체로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="140cefc12826afba19082ed8e5c642424d6c64fa" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;&lt;code&gt;Strict_mode&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;../global_objects/typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised when attempting to create a property on &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/primitive&quot;&gt;primitive&lt;/a&gt; value such as a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/symbol&quot;&gt;symbol&lt;/a&gt;, a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/string&quot;&gt;string&lt;/a&gt;, a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/number&quot;&gt;number&lt;/a&gt; or a &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/boolean&quot;&gt;boolean&lt;/a&gt;. &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;Primitive&lt;/a&gt; values cannot hold any &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/property/JavaScript&quot;&gt;property&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c73f4538311a378c8c9424d32c3f8811910d419" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; code, however, this will throw a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 코드에서는 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82dc5204fd47b97a4c4e971fee4ed30a2687404c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; code, you can't use &quot;&lt;code&gt;let&lt;/code&gt;&quot; as a label name. It will throw a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; (let is a reserved identifier).</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격한 모드&lt;/a&gt; 코드, 당신은 &quot;사용할 수 &lt;code&gt;let&lt;/code&gt; 레이블 이름으로&quot;. 그것은 발생합니다 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; (하자가 예약 된 식별자입니다).</target>
        </trans-unit>
        <trans-unit id="c6054ae0aa42f967abbaaff8c7c370a661682c9b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, attempting to add new properties to a non-extensible object throws a &lt;code&gt;TypeError&lt;/code&gt;. In sloppy mode, the addition of the &quot;x&quot; property is silently ignored.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 확장 할 수없는 객체에 새 속성을 추가하려고하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다. 조잡한 모드에서는 &quot;x&quot;속성 추가가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="af9aba5cd8d260931e6c60474eae352d67a9887b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, starting with ES2015, functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 ES2015부터 블록 내부의 함수가 해당 블록으로 범위가 지정됩니다. ES2015 이전에는 블록 수준 기능이 엄격 모드에서 금지되었습니다.</target>
        </trans-unit>
        <trans-unit id="216d48a6757220d152e7f994000123b4833e4e79" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, the &lt;a href=&quot;../global_objects/function/caller&quot;&gt;&lt;code&gt;Function.caller&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/function/arguments&quot;&gt;&lt;code&gt;Function.arguments&lt;/code&gt;&lt;/a&gt; properties are used and shouldn't be. They are deprecated, because they leak the function caller, are non-standard, hard to optimize and potentially a performance-harmful feature.</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 의 &lt;a href=&quot;../global_objects/function/caller&quot;&gt; &lt;code&gt;Function.caller&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../global_objects/function/arguments&quot;&gt; &lt;code&gt;Function.arguments&lt;/code&gt; &lt;/a&gt; 속성은 사용이 아니어야합니다. 함수 호출자를 유출하고 비표준이며 최적화하기 어렵고 잠재적으로 성능에 유해한 기능이므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3ea4e9343d838f1294b3b7ae8cc65f8857960e3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller&quot;&gt;&lt;code&gt;Function.caller&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/function/arguments&quot;&gt;&lt;code&gt;Function.arguments&lt;/code&gt;&lt;/a&gt; properties are used and shouldn't be. They are deprecated, because they leak the function caller, are non-standard, hard to optimize and potentially a performance-harmful feature.</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller&quot;&gt; &lt;code&gt;Function.caller&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/function/arguments&quot;&gt; &lt;code&gt;Function.arguments&lt;/code&gt; &lt;/a&gt; 속성은 사용이 아니어야합니다. 함수 호출자를 누설하고 비표준이며 최적화하기 어렵고 잠재적으로 성능에 유해한 기능이기 때문에 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ae11f4b28ed355c17fb2cf7b60c3de003e3a4a0" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, identifiers can contain only alphanumeric characters (or &quot;$&quot; or &quot;_&quot;), and may not start with a digit. An identifier differs from a &lt;strong&gt;string&lt;/strong&gt; in that a string is data, while an identifier is part of the code.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;자바 스크립트&lt;/a&gt; , 식별자는 숫자 (또는 &quot;$&quot;또는 &quot;_&quot;)를 포함 할 수 있으며 숫자로 시작되지 않을 수 있습니다. 식별자는 문자열이 데이터 인 반면 식별자는 코드의 일부라는 점에서 &lt;strong&gt;문자열&lt;/strong&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b1cf0c9af0f3437de670684af61db176a2e024d0" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, identifiers can contain only alphanumeric characters (or &quot;$&quot; or &quot;_&quot;), and may not start with a digit. An identifier differs from a &lt;strong&gt;string&lt;/strong&gt; in that a string is data, while an identifier is part of the code.</source>
          <target state="translated">에 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt; 자바 스크립트&lt;/a&gt; , 식별자는 숫자 (또는 &quot;$&quot;또는 &quot;_&quot;)를 포함 할 수 있으며 숫자로 시작되지 않을 수 있습니다. 식별자는 문자열이 데이터 인 반면 식별자는 코드의 일부라는 점에서 &lt;strong&gt;문자열&lt;/strong&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9ceac41023ca7e64457c2a69427be9598fb1653c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;strict_mode&quot;&gt;strict mode&lt;/a&gt;, all browsers that support ES2015 handle this the same way: &lt;code&gt;zero&lt;/code&gt; is defined only if &lt;code&gt;shouldDefineZero&lt;/code&gt; is true, and only in the scope of the &lt;code&gt;if&lt;/code&gt;-block.</source>
          <target state="translated">에서 &lt;a href=&quot;strict_mode&quot;&gt;엄격 모드&lt;/a&gt; , 지원 ES2015이 같은 방식으로 처리하는 모든 브라우저 : &lt;code&gt;zero&lt;/code&gt; 경우에만 정의 &lt;code&gt;shouldDefineZero&lt;/code&gt; 는 사실입니다 만의 범위에있는 &lt;code&gt;if&lt;/code&gt; - 블록.</target>
        </trans-unit>
        <trans-unit id="29666e4908ed732ae018d4d4721ff9754d3c167b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;strict_mode&quot;&gt;strict mode&lt;/a&gt;, starting with ES2015, functions inside blocks are now scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</source>
          <target state="translated">&lt;a href=&quot;strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 ES2015부터 블록 내부의 기능이 해당 블록으로 범위가 지정됩니다. ES2015 이전에는 엄격 모드에서 블록 레벨 기능이 금지되었습니다.</target>
        </trans-unit>
        <trans-unit id="873415a6a8f203e4bdfe8b79a65ee0b40b608117" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentPromise,&lt;/code&gt;&lt;code&gt;Promise.all&lt;/code&gt; wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises, and the error will always occur within the configured promise chain, enabling it to be caught in the normal way.</source>
          <target state="translated">에서 &lt;code&gt;concurrentPromise,&lt;/code&gt; &lt;code&gt;Promise.all&lt;/code&gt; 의 한 가지의 약속 체인 최대 전선, 조작에 관계없이 약속의 거부의 순서의 빠른 실패하고 오류가 항상 잡힐 수 있도록, 구성된 약속 체인 내에서 발생하는 것을 의미 정상적인 방법으로.</target>
        </trans-unit>
        <trans-unit id="221555bbaf990eeb6c49e029c703b9faa3ef204e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, both timers are created and then &lt;code&gt;await&lt;/code&gt;ed. The timers are running concurrently but the &lt;code&gt;await&lt;/code&gt; calls are still running in series, meaning the second &lt;code&gt;await&lt;/code&gt; will wait for the first one to finish. This leads the code to finish in 2 rather than 3 seconds, which is the time the slowest timer needs. The same happens in &lt;code&gt;stillConcurrent&lt;/code&gt; using &lt;code&gt;Promise.all&lt;/code&gt; this time.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; 두 타이머는 다음 생성되는 &lt;code&gt;await&lt;/code&gt; 를 에드. 타이머는 동시에 실행되지만 &lt;code&gt;await&lt;/code&gt; 통화는 계속 직렬로 실행됩니다. 즉, 두 번째 &lt;code&gt;await&lt;/code&gt; 는 첫 번째 대기 가 완료 될 때까지 대기합니다. 이로 인해 코드가 3 초가 아닌 2 초 안에 완료됩니다. 이는 가장 느린 타이머에 필요한 시간입니다. &lt;code&gt;stillConcurrent&lt;/code&gt; 사용하는 &lt;code&gt;Promise.all&lt;/code&gt; 에서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="dca20ace845e482ba3a705f727cc3a8ad77cf9d7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, both timers are created and then &lt;code&gt;await&lt;/code&gt;ed. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e. the slowest timer.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; 두 타이머는 다음 생성된다 &lt;code&gt;await&lt;/code&gt; 를 에드. 타이머는 동시에 실행됩니다. 이는 코드가 3 초가 아닌 2 초, 즉 가장 느린 타이머에 완료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4f97a7bbaeebe37b6849072c8d4d0a9f173528d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, if promise &lt;code&gt;fast&lt;/code&gt; rejects before promise &lt;code&gt;slow&lt;/code&gt; is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller has configured a catch clause.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; , 만약 약속 &lt;code&gt;fast&lt;/code&gt; 약속하기 전에 거부 &lt;code&gt;slow&lt;/code&gt; 성취 된 다음 처리되지 않은 약속 거부에 관계없이 오류가 호출자가 캐치 절을 구성 여부, 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d7a6fe3cf2916c84be2ef5c18d5e7128c24c00e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;for...of&lt;/code&gt; loops, abrupt iteration termination can be caused by &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. In these cases, the iterator is closed.</source>
          <target state="translated">에서 &lt;code&gt;for...of&lt;/code&gt; 루프, 갑작스러운 반복 종료가 발생할 수 있습니다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; . 이 경우 반복자가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f24173b93852ae7003f7140596ebc37c863720d7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;for...of&lt;/code&gt; loops, abrupt iteration termination can be caused by &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. In these cases, the iterator is closed.</source>
          <target state="translated">에서 &lt;code&gt;for...of&lt;/code&gt; 루프, 갑작스러운 반복 종료가 발생할 수 있습니다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; . 이 경우 반복기가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4d6add7a612b365f8147b939f3c6f66bc22b629f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequentialStart&lt;/code&gt;, execution suspends 2 seconds for the first &lt;code&gt;await&lt;/code&gt;, and then again another 1 second for the second &lt;code&gt;await&lt;/code&gt;. The second timer is not created until the first has already fired.</source>
          <target state="translated">에서는 &lt;code&gt;sequentialStart&lt;/code&gt; 실행은 상기 제 2 초 중지 &lt;code&gt;await&lt;/code&gt; 후 다시 다른 제 1 초와 &lt;code&gt;await&lt;/code&gt; . 두 번째 타이머는 첫 번째 타이머가 이미 시작될 때까지 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ffa1771a0ac6f2ae699ccfcc00a18930b4b803c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequentialStart&lt;/code&gt;, execution suspends 2 seconds for the first &lt;code&gt;await&lt;/code&gt;, and then another second for the second &lt;code&gt;await&lt;/code&gt;. The second timer is not created until the first has already fired, so the code finishes after 3 seconds.</source>
          <target state="translated">에서는 &lt;code&gt;sequentialStart&lt;/code&gt; 실행은 상기 제 2 초 중지 &lt;code&gt;await&lt;/code&gt; 및 초 후 다른 제 &lt;code&gt;await&lt;/code&gt; . 두 번째 타이머는 첫 번째 타이머가 이미 실행될 때까지 생성되지 않으므로 코드는 3 초 후에 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="176a20a11517113033606aab1e61e3d4ca20c6ad" translate="yes" xml:space="preserve">
          <source>In C, the &lt;code&gt;strcmp()&lt;/code&gt; function is used for comparing strings. In JavaScript, you just use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;less-than and greater-than operators&lt;/a&gt;:</source>
          <target state="translated">C에서 &lt;code&gt;strcmp()&lt;/code&gt; 함수는 문자열을 비교하는 데 사용됩니다. JavaScript에서는&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt; 보다 작음 및보다 큼 연산자를 사용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="309d60f8743568aecbdf811d2d351da393f4b34d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015 There is a way to concisely define properties whose values are generator functions:</source>
          <target state="translated">ECMAScript 2015에는 값이 생성기 함수 인 속성을 간결하게 정의하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ee30c3781491b37d2d91aa12c3f275c2e033a0" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, a shorthand notation is available, so that the keyword &quot;&lt;code&gt;function&lt;/code&gt;&quot; is no longer necessary.</source>
          <target state="translated">ECMAScript 2015에서는 축약 표기법을 사용할 수 있으므로 키워드 &quot; &lt;code&gt;function&lt;/code&gt; &quot;이 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7df1fd3d991e32f1320629672612245d3c92c0f7" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, a shorthand notation is available, so that the keyword &quot;function&quot; is no longer necessary.</source>
          <target state="translated">ECMAScript 2015에서는 약식 표기법을 사용할 수 있으므로 키워드 &quot;function&quot;이 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbe274850fe44af194eea5fda8294e245f5d4c8b" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, there is a way to concisely define properties whose values are generator functions:</source>
          <target state="translated">ECMAScript 2015에는 값이 생성기 함수 인 속성을 간결하게 정의하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="948177c7ae9848dd8e493ddbacacd75cb5473d9a" translate="yes" xml:space="preserve">
          <source>In ECMAScript 3/5, the &lt;code&gt;this&lt;/code&gt; issue was fixable by assigning the value in &lt;code&gt;this&lt;/code&gt; to a variable that could be closed over.</source>
          <target state="translated">ECMAScript 3/5에서는 &lt;code&gt;this&lt;/code&gt; 문제를 해결할 수 있는 변수 &lt;code&gt;this&lt;/code&gt; 값을 할당 하여이 문제를 해결할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="4fd06900882a105e2510f94e9cdbf294840e46f9" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5 strict mode code, duplicate property names were considered a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;. With the introduction of computed property names making duplication possible at runtime, ECMAScript 2015 has removed this restriction.</source>
          <target state="translated">ECMAScript 5 엄격 모드 코드에서 중복 특성 이름은 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 로 간주되었습니다 . ECMAScript 2015는 런타임시 중복을 가능하게하는 계산 된 속성 이름이 도입되면서이 제한을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="02e140d416437887a7872326dba6eed9437d2415" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5, this behavior was changed for &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;. Assignment to an unqualified identifier in strict mode will result in a &lt;code&gt;ReferenceError&lt;/code&gt;, to avoid the accidental creation of properties on the global object.</source>
          <target state="translated">ECMAScript 5에서이 동작은 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드에&lt;/a&gt; 대해 변경되었습니다 . 엄격 모드에서 규정되지 않은 식별자에 할당하면 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다. 가 발생하여 전역 개체에서 실수로 속성이 생성되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82de7fe847ca3c223f7295513a60c00f3cc6f251" translate="yes" xml:space="preserve">
          <source>In ES2015 with nested template literals:</source>
          <target state="translated">중첩 템플릿 리터럴이있는 ES2015에서 :</target>
        </trans-unit>
        <trans-unit id="2e28d1359b78caea73bd201eb664d9160434980d" translate="yes" xml:space="preserve">
          <source>In ES2015 with template literals and without nesting:</source>
          <target state="translated">템플릿 리터럴과 중첩없이 ES2015에서 :</target>
        </trans-unit>
        <trans-unit id="f3672427c7965f113f3fe4cb570beacc248c8428" translate="yes" xml:space="preserve">
          <source>In ES2015, the class syntax allows for sub-classing of both built-in and user defined classes; as a result, static methods such as &lt;code&gt;Array.from&lt;/code&gt; are &quot;inherited&quot; by subclasses of &lt;code&gt;Array&lt;/code&gt; and create new instances of the subclass, not &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">ES2015에서 클래스 구문을 사용하면 내장 클래스와 사용자 정의 클래스를 모두 서브 클래 싱 할 수 있습니다. 그 결과, 같은 정적 방법 &lt;code&gt;Array.from&lt;/code&gt; 는 서브 클래스가 &quot;상속&quot;되는 &lt;code&gt;Array&lt;/code&gt; 및 서브 아닌 새로운 인스턴스 생성 &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c41c52a21154ec2619b7bacc530a4f16cecd0dd3" translate="yes" xml:space="preserve">
          <source>In ES2015, the class syntax allows sub-classing of both built-in and user-defined classes. As a result, static methods such as &lt;code&gt;Array.from()&lt;/code&gt; are &quot;inherited&quot; by subclasses of &lt;code&gt;Array&lt;/code&gt;, and create new instances &lt;em&gt;of the subclass&lt;/em&gt;, not &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">ES2015에서 클래스 구문은 내장 및 사용자 정의 클래스 모두의 하위 분류를 허용합니다. 그 결과, 같은 정적 방법 &lt;code&gt;Array.from()&lt;/code&gt; 서브 클래스가 &quot;상속&quot;되어 &lt;code&gt;Array&lt;/code&gt; , 새로운 인스턴스 생성 &lt;em&gt;서브 클래스의이&lt;/em&gt; 아닌 &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef0e40b46bde57de45d710a8decfe4f424e88a4" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (기본)가 아니면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. .</target>
        </trans-unit>
        <trans-unit id="53864ec850c8528b35459bfdb64c830661afe252" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be coerced to an object.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서는 객체가 아닌 인수가 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="0030a6d3d27dbe9c4a6e9e4e06ecd6adb4308138" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a frozen ordinary object, simply return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 얼어 붙은 일반 객체 인 것처럼 취급되므로 단순히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ca534830639609923b78d052142ef445d9da986" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 확장 할 수없는 일반 객체 인 것처럼 취급되며 단순히 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9bcfc35ed6e7f198824d6e0b0dcb22d3b293ba28" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 확장 할 수없는 일반 객체 인 것처럼 처리되므로 간단히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="007cf956ed6956737327164237b3afece1b87b2b" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object by simply returning it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (기본)가 아니면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. . ES2015에서 객체가 아닌 인자는 단순히 반환함으로써 봉인 된 일반 객체 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d58ae111e6808420d9135fd6bfc1e632b51c47" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object, simply return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 봉인 된 일반 객체 인 것처럼 취급되므로 간단히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a25f137ee01cf4301c10ca6fc3d32a3d19298e37" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object, simply return it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 봉인 된 일반 객체 인 것처럼 취급되므로 간단히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d0bff99dd5b84da47050253c2c62698a5c39a02" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it were a frozen ordinary object, and be simply returned.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 고정 된 일반 객체 인 것처럼 처리되고 간단히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8598ec4f16e006f73c4b98ace30ef3c88220ab1a" translate="yes" xml:space="preserve">
          <source>In ES5, if the first argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">ES5에서이 메소드의 첫 번째 인수가 객체 (기본)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 첫 번째 인수는 처음에 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c167c36d97c1d699b099b1ec68b4a0acdf0879" translate="yes" xml:space="preserve">
          <source>In ES5, it will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception if the &lt;var&gt;obj&lt;/var&gt; parameter isn't an object. In ES2015, the parameter will be coerced to an &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ES5에서는 &lt;var&gt;obj&lt;/var&gt; 매개 변수가 객체가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생 합니다. ES2015에서 매개 변수는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 로 강제 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6d38ce849906adde58d4d32cd183bb3cd5e181f" translate="yes" xml:space="preserve">
          <source>In ES5, you typically use the &lt;a href=&quot;../function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; method to call a function with a given &lt;code&gt;this&lt;/code&gt; value and &lt;code&gt;arguments&lt;/code&gt; provided as an array (or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;array-like object&lt;/a&gt;).</source>
          <target state="translated">ES5에서는 일반적으로 &lt;a href=&quot;../function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 주어진 &lt;code&gt;this&lt;/code&gt; 값과 배열 (또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;배열과 같은 객체&lt;/a&gt; ) 로 제공된 &lt;code&gt;arguments&lt;/code&gt; 사용하여 함수 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6653f25dc7136aed24c5070c600b114c374f9a" translate="yes" xml:space="preserve">
          <source>In ES5, you typically use the &lt;a href=&quot;../function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; method to call a function with a given &lt;code&gt;this&lt;/code&gt; value and &lt;code&gt;arguments&lt;/code&gt; provided as an array (or an &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;array-like object&lt;/a&gt;).</source>
          <target state="translated">ES5에서는 일반적으로 &lt;a href=&quot;../function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 주어진 &lt;code&gt;this&lt;/code&gt; 값과 배열 (또는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;배열과 같은 객체)&lt;/a&gt; 로 제공된 &lt;code&gt;arguments&lt;/code&gt; 로 함수를 호출 합니다. ) .</target>
        </trans-unit>
        <trans-unit id="cb9d84f212ebfd0b494629810bc4f123430adee3" translate="yes" xml:space="preserve">
          <source>In ES5:</source>
          <target state="translated">ES5에서 :</target>
        </trans-unit>
        <trans-unit id="4867ea47a940c21ea6c6af42152c706a4ec82ba3" translate="yes" xml:space="preserve">
          <source>In Edge 12 and 13, &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop initializer does not create a separate variable for each loop iteration as defined by ES2015. Instead, it behaves as though the loop were wrapped in a scoping block with the &lt;code&gt;let&lt;/code&gt; immediately before the loop.</source>
          <target state="translated">에지 (12, 13)에 &lt;code&gt;let&lt;/code&gt; 내에 &lt;code&gt;for&lt;/code&gt; ES2015에 의해 정의 된 각각의 루프 반복에 대해 별도의 변수를 생성하지 않는 초기화 루프. 대신 루프 바로 앞에 &lt;code&gt;let&lt;/code&gt; 이 있는 범위 지정 블록에 루프가 래핑 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="38f05042b00889b690877f9c1f38bccf3790a39b" translate="yes" xml:space="preserve">
          <source>In Firefox 18 - 39, the name of this method was &lt;code&gt;contains()&lt;/code&gt;. It was renamed to &lt;code&gt;includes()&lt;/code&gt; in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1102219&quot;&gt;bug 1102219&lt;/a&gt; due to the following reason:</source>
          <target state="translated">Firefox 18-39에서이 메소드의 이름은 &lt;code&gt;contains()&lt;/code&gt; 입니다. 다음과 같은 이유로 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1102219&quot;&gt;버그 1102219&lt;/a&gt; 에서 contains &lt;code&gt;includes()&lt;/code&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b3441497965bb64df9474736353a9248115e770e" translate="yes" xml:space="preserve">
          <source>In Firefox 42, the implementation got updated to reflect the final ES2015 specification: The result is now checked if it is an array and if the array elements are either of type string or of type symbol. Enumerating duplicate own property names is not a failure anymore.</source>
          <target state="translated">Firefox 42에서 구현은 최종 ES2015 사양을 반영하도록 업데이트되었습니다. 이제 배열인지 배열 요소가 문자열 유형 또는 기호 유형인지 확인합니다. 중복 된 고유 속성 이름을 열거해도 더 이상 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8d03fdcab501aecd669f36c6937ea8fde7271a" translate="yes" xml:space="preserve">
          <source>In Firefox 48, &lt;code&gt;String.prototype.contains()&lt;/code&gt; has been removed. Use &lt;code&gt;String.prototype.includes()&lt;/code&gt; only.</source>
          <target state="translated">Firefox 48에서 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 제거되었습니다. &lt;code&gt;String.prototype.includes()&lt;/code&gt; 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eab913afe11ef8c151060fcbf4894152ade8632" translate="yes" xml:space="preserve">
          <source>In Firefox 58, when the exception is unused, the identifier can be omitted, as in the code below. This is also &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html&quot;&gt;allowed in TypeScript 2.5&lt;/a&gt; and later. However, at the time of this writing (August 2018), &lt;a href=&quot;https://github.com/tc39/proposal-optional-catch-binding&quot;&gt;the proposal to support this&lt;/a&gt; has not yet been included into an ECMAScript standard, so this syntax may not work in other browsers.</source>
          <target state="translated">Firefox 58에서 예외가 사용되지 않는 경우 아래 코드와 같이 식별자를 생략 할 수 있습니다. 이것은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html&quot;&gt;TypeScript 2.5 이상&lt;/a&gt; 에서도 허용됩니다 . 그러나이 글을 쓰는 시점 (2018 년 8 월)에는 &lt;a href=&quot;https://github.com/tc39/proposal-optional-catch-binding&quot;&gt;이를 지원하기위한 제안이&lt;/a&gt; 아직 ECMAScript 표준에 포함되어 있지 않기 때문에이 구문은 다른 브라우저에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1730c0df30cd5ba97c5141ded4e91edebdb5d504" translate="yes" xml:space="preserve">
          <source>In Firefox, &lt;code&gt;handler&lt;/code&gt; is only called from assignments in script, not from native code. For example, &lt;code&gt;window.watch('location', myHandler)&lt;/code&gt; will not call &lt;code&gt;myHandler&lt;/code&gt; if the user clicks a link to an anchor within the current document. However, &lt;code&gt;window.location += '#myAnchor'&lt;/code&gt; will call &lt;code&gt;myHandler&lt;/code&gt;.</source>
          <target state="translated">Firefox에서 &lt;code&gt;handler&lt;/code&gt; 는 기본 코드가 아닌 스크립트의 지정에서만 호출됩니다. 예를 들어, 사용자가 현재 문서 내에서 앵커에 대한 링크를 클릭하면 &lt;code&gt;window.watch('location', myHandler)&lt;/code&gt; 는 &lt;code&gt;myHandler&lt;/code&gt; 를 호출하지 않습니다 . 그러나 &lt;code&gt;window.location += '#myAnchor'&lt;/code&gt; 는 &lt;code&gt;myHandler&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="20427e6f530262dedd1f66d1091224f92b38be66" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 20&amp;micro;s in Firefox 59; in 60 it will be 2ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 기본 설정이 기본적으로 활성화되어 있으며 Firefox 59에서는 기본값이 20&amp;micro;s입니다. 60 분에는 2ms가됩니다.</target>
        </trans-unit>
        <trans-unit id="0af97ad69484c392ea6d2c53e11669126d6b3def" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 20us in Firefox 59; in 60 it will be 2ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 환경 설정이 기본적으로 사용되며 Firefox 59에서는 기본값이 20us입니다. 60에서는 2ms입니다.</target>
        </trans-unit>
        <trans-unit id="2760c20e75f06135284b55f675e6ca0ea87f3385" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enable &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;, the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수 있으며 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9c7ba06ca4f441cd2e83c2b7bd2b5b0d766466d1" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enabled &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;, the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수 있으며 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5b8bed5863664df70343acda1590937b7118915f" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 11, numbers are rounded to 15 decimal digits. For example, &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; returns &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 11에서 숫자는 십진수 15 자리로 반올림됩니다. 예를 들어 &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; 는 &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0fa3c7d01b63aee4083af5bf6ff39193c2213851" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 11, numbers are rounded to 15 decimal digits. For example, &lt;code&gt;new Intl.NumberFormat('en-US').format(1000000000000005)&lt;/code&gt; returns &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ae8ad7d0e4ba6962d4b6f17b97388cf31cdc72" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8, this was only supported on DOM objects and with some non-standard behaviors. This was later fixed in Internet Explorer 9.</source>
          <target state="translated">Internet Explorer 8에서는 DOM 개체와 일부 비표준 동작에서만 지원되었습니다. 이것은 나중에 Internet Explorer 9에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4db24d0846e3ba3185a867d8668c69a5571ec019" translate="yes" xml:space="preserve">
          <source>In Internet Explorer, &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop initializer does not create a separate variable for each loop iteration as defined by ES2015. Instead, it behaves as though the loop were wrapped in a scoping block with the &lt;code&gt;let&lt;/code&gt; immediately before the loop.</source>
          <target state="translated">Internet Explorer에서 &lt;code&gt;for&lt;/code&gt; 루프 이니셜 라이저 내의 &lt;code&gt;let&lt;/code&gt; 은 ES2015에 정의 된대로 각 루프 반복에 대해 별도의 변수를 생성하지 않습니다. 대신 루프 바로 앞에 &lt;code&gt;let&lt;/code&gt; 이 있는 범위 지정 블록에 루프가 래핑 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a5615497b68ccaa1ea32d698e965d876cea2548f" translate="yes" xml:space="preserve">
          <source>In JSON the values can only be strings, numbers, arrays, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or another (JSON) object.</source>
          <target state="translated">JSON에서 값은 문자열, 숫자, 배열, &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 다른 (JSON) 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="668b19b6452d0e28e81f530219de59631b89f0c9" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;s are not iterable unless they implement the &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt;. Therefore, you cannot use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip;of &lt;/a&gt;to iterate over the properties of an object.</source>
          <target state="translated">JavaScript에서 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt; 을 구현하지 않으면 반복 할 수 없습니다 . 따라서 객체의 속성을 반복 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;하는&lt;/a&gt; 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="895cd1421cbf51353ea473367f38e162aabe3974" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;s are not iterable unless they implement the &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt;. Therefore, you cannot use &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip;of &lt;/a&gt;to iterate over the properties of an object.</source>
          <target state="translated">JavaScript에서 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;반복 가능한 프로토콜&lt;/a&gt; 을 구현하지 않는 한 반복 할 수 없습니다 . 따라서 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip; of&lt;/a&gt; 를 사용하여 개체의 속성을 반복 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2855ac845af4473bd3a6be21040f1c7e0ad7b25b" translate="yes" xml:space="preserve">
          <source>In JavaScript, a setter can be used to execute a function whenever a specified property is attempted to be changed. Setters are most often used in conjunction with getters to create a type of pseudo-property. It is not possible to simultaneously have a setter on a property that holds an actual value.</source>
          <target state="translated">JavaScript에서는 지정된 속성을 변경하려고 할 때마다 setter를 사용하여 함수를 실행할 수 있습니다. 세터는 의사 속성 유형을 생성하기 위해 게터와 함께 가장 자주 사용됩니다. 실제 값을 보유한 속성에 세터를 동시에 가질 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca543fb85472cc8f29fc43d21952496053e3fecd" translate="yes" xml:space="preserve">
          <source>In JavaScript, function parameters default to &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. However, it's often useful to set a different default value. This is where default parameters can help.</source>
          <target state="translated">JavaScript에서 함수 매개 변수는 기본적으로 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 그러나 다른 기본값을 설정하는 것이 유용한 경우가 많습니다. 여기에서 기본 매개 변수가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19c8d5903929df29ffd31d91bc12841578c097c" translate="yes" xml:space="preserve">
          <source>In JavaScript, function parameters default to &lt;code&gt;&lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;. However, it's often useful to set a different default value. This is where default parameters can help.</source>
          <target state="translated">JavaScript에서 함수 매개 변수의 기본값은 &lt;code&gt;&lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 입니다. 그러나 종종 다른 기본값을 설정하는 것이 유용합니다. 기본 매개 변수가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20f27b3f1c13809f77edbf8f97737045dcbcf21" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. In brief, they are &lt;code&gt;&lt;a href=&quot;global_objects/function&quot;&gt;Function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">JavaScript에서 함수는 다른 개체와 마찬가지로 속성과 메서드를 가질 수 있기 때문에 일류 개체입니다. 다른 객체와 구별되는 것은 함수를 호출 할 수 있다는 것입니다. 간단히 말해서 그것들은 &lt;code&gt;&lt;a href=&quot;global_objects/function&quot;&gt;Function&lt;/a&gt;&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="8c0c83ea411bdaf4088e6dd68be95506dcafee3c" translate="yes" xml:space="preserve">
          <source>In JavaScript, it is impossible to write an ambiguous exponentiation expression. That is, you cannot put a unary operator (&lt;code&gt;+/-/~/!/delete/void/typeof&lt;/code&gt;) immediately before the base number; doing so will cause a SyntaxError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0482de27c3e98ed79056a4c8e3487f1d9c7e2eb4" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are several reduce functions:</source>
          <target state="translated">JavaScript에는 몇 가지 축소 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e500e271dd9c768e0229c1f8cd060c64d5a885f" translate="yes" xml:space="preserve">
          <source>In JavaScript, we can do this with the following:</source>
          <target state="translated">JavaScript에서는 다음과 같이이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67dd1e314b8d816c5d9c9ed86c33a7c3051041e8" translate="yes" xml:space="preserve">
          <source>In Promises</source>
          <target state="translated">약속에서</target>
        </trans-unit>
        <trans-unit id="8753023eb7cfee3b18013db421fe39f22ac9cfb7" translate="yes" xml:space="preserve">
          <source>In UTF-16, the most common characters can be represented by a single 16-bit value (i.e. a code unit). However, this set of characters, known as the Base Multilingual Plane (BMP), is only &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;17&lt;/sub&gt;&lt;sup&gt;th&lt;/sup&gt; of the total addressable Unicode code points. The remaining code points, in the range of &lt;code&gt;65536&lt;/code&gt; (&lt;code&gt;0x010000&lt;/code&gt;) to &lt;code&gt;1114111&lt;/code&gt; (&lt;code&gt;0x10FFFF&lt;/code&gt;) are known as supplementary characters. In UTF-16, supplementary characters are represented by two 16-bit code units, known as surrogates, that were reserved for this purpose. A valid combination of two surrogates used to represent a supplementary character is known as a surrogate pair.</source>
          <target state="translated">UTF-16에서 가장 일반적인 문자는 단일 16 비트 값 (예 : 코드 단위)으로 표현 될 수 있습니다. 그러나, 언어 자료의 평면 (BMP)으로 알려진 문자 세트는, 단지 인 &lt;sup&gt;1&lt;/sup&gt; / &lt;sub&gt;17 &lt;/sub&gt;&lt;sup&gt;일&lt;/sup&gt; 총 드레서 유니 코드 코드 포인트. &lt;code&gt;65536&lt;/code&gt; ( &lt;code&gt;0x010000&lt;/code&gt; )에서 &lt;code&gt;1114111&lt;/code&gt; ( &lt;code&gt;0x10FFFF&lt;/code&gt; ) 범위의 나머지 코드 포인트 는 보충 문자로 알려져 있습니다. UTF-16에서 보조 문자는이 목적을 위해 예약 된 두 개의 16 비트 코드 단위 (대리자)로 표시됩니다. 보충 문자를 나타내는 데 사용되는 두 개의 서로 게이트의 유효한 조합을 서로 게이트 쌍이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3af0213442e56d88e4f08027d4396f1d413cc06e" translate="yes" xml:space="preserve">
          <source>In Unicode, two sequences of code points are compatible if they represent the same abstract characters, and should be treated alike in some &amp;mdash; but not necessarily all &amp;mdash; applications.</source>
          <target state="translated">유니 코드에서 코드 포인트의 두 시퀀스는 동일한 추상 문자를 나타내는 경우 호환되며 일부 (반드시 전부는 아님) 응용 프로그램에서 동일하게 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06fcf052ca7ee2994caca99f7c2a53bdfa453a22" translate="yes" xml:space="preserve">
          <source>In Unicode, two sequences of code points have canonical equivalence if they represent the same abstract characters, and should always have the same visual appearance and behavior (for example, they should always be sorted in the same way).</source>
          <target state="translated">유니 코드에서 코드 포인트의 두 시퀀스는 동일한 추상 문자를 나타내는 경우 표준 동등성을 가지며 항상 동일한 시각적 모양과 동작을 가져야합니다 (예 : 항상 동일한 방식으로 정렬되어야 함).</target>
        </trans-unit>
        <trans-unit id="30ccea940dd72f9de64442358a3ee98e6136515f" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop, it jumps to the update expression.</source>
          <target state="translated">A의 &lt;a href=&quot;for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프, 그것은 업데이트 표현으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f0090629de3eb7e932efc2299ea2b0e11274be76" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; loop, it jumps back to the condition.</source>
          <target state="translated">A의 &lt;a href=&quot;while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 루프, 그것은 다시 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="802ad80650674fefbc5baab939de5d45ff49c037" translate="yes" xml:space="preserve">
          <source>In a case where you want to store an object created by your user and allowing it to be restored even after the browser has been closed, the following example is a model for the applicability of &lt;code&gt;JSON.stringify()&lt;/code&gt;:</source>
          <target state="translated">사용자가 만든 객체를 저장하고 브라우저를 닫은 후에도 객체를 복원 할 수 있도록하려는 경우 다음 예제는 &lt;code&gt;JSON.stringify()&lt;/code&gt; 의 적용 가능성에 대한 모델입니다 .</target>
        </trans-unit>
        <trans-unit id="b974b8e0c8cc3adb8992389d2d0a1cd08b75c03c" translate="yes" xml:space="preserve">
          <source>In a circular structure like the following</source>
          <target state="translated">다음과 같은 원형 구조에서</target>
        </trans-unit>
        <trans-unit id="9a9eae68242ed66a24716ccc35563a64f014c279" translate="yes" xml:space="preserve">
          <source>In a concise body, only an expression is specified, which becomes the implicit return value. In a block body, you must use an explicit &lt;code&gt;return&lt;/code&gt; statement.</source>
          <target state="translated">간결한 본문에는 식만 지정되어 암시 적 반환 값이됩니다. 블록 본문에서 명시적인 &lt;code&gt;return&lt;/code&gt; 문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4f1b8f09e11f544c05027c4ef2b7cb80ca9f74d" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom array &lt;code&gt;MyArray&lt;/code&gt;), the &lt;code&gt;MyArray&lt;/code&gt; species is the &lt;code&gt;MyArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Array&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 배열 &lt;code&gt;MyArray&lt;/code&gt; )에서 &lt;code&gt;MyArray&lt;/code&gt; 종은 &lt;code&gt;MyArray&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;Array&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6e2e091bde1b1e25306a26d58b0ccc4c15bee3" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom array buffer &lt;code&gt;MyArrayBuffer&lt;/code&gt;), the &lt;code&gt;MyArrayBuffer&lt;/code&gt; species is the &lt;code&gt;MyArrayBuffer&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;ArrayBuffer&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 배열 버퍼 &lt;code&gt;MyArrayBuffer&lt;/code&gt; )에서 &lt;code&gt;MyArrayBuffer&lt;/code&gt; 종은 &lt;code&gt;MyArrayBuffer&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;ArrayBuffer&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8676f845dcd23c9b49f4af2f5389c64e7e8218ba" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom map &lt;code&gt;MyMap&lt;/code&gt;), the &lt;code&gt;MyMap&lt;/code&gt; species is the &lt;code&gt;MyMap&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Map&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 객체 (예 : 사용자 지정 맵 &lt;code&gt;MyMap&lt;/code&gt; )에서 &lt;code&gt;MyMap&lt;/code&gt; 종은 &lt;code&gt;MyMap&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 상위 &lt;code&gt;Map&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a21922d4d45a039d44b74194264a3b6620d0aa9" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom regexp &lt;code&gt;MyRegExp&lt;/code&gt;), the &lt;code&gt;MyRegExp&lt;/code&gt; species is the &lt;code&gt;MyRegExp&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;RegExp&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 regexp &lt;code&gt;MyRegExp&lt;/code&gt; )에서 &lt;code&gt;MyRegExp&lt;/code&gt; 종은 &lt;code&gt;MyRegExp&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;RegExp&lt;/code&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1c37cca7fcf5c973f743b17eb0dd855d1eeaf6f" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom set &lt;code&gt;MySet&lt;/code&gt;), the &lt;code&gt;MySet&lt;/code&gt; species is the &lt;code&gt;MySet&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Set&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 집합 &lt;code&gt;MySet&lt;/code&gt; )에서 &lt;code&gt;MySet&lt;/code&gt; 종은 &lt;code&gt;MySet&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;Set&lt;/code&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1133b3da65f4298a37b3e1fc081e7c925554e075" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom typed array &lt;code&gt;MyTypedArray&lt;/code&gt;), the &lt;code&gt;MyTypedArray&lt;/code&gt; species is the &lt;code&gt;MyTypedArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return a parent &lt;a href=&quot;../typedarray#TypedArray_objects&quot;&gt;typed array&lt;/a&gt; object in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 형식 배열 &lt;code&gt;MyTypedArray&lt;/code&gt; )에서 &lt;code&gt;MyTypedArray&lt;/code&gt; 종은 &lt;code&gt;MyTypedArray&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;a href=&quot;../typedarray#TypedArray_objects&quot;&gt;형식의 배열&lt;/a&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ce247dad140e8fba2d68c52d0b5deed3560020a" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom typed array &lt;code&gt;MyTypedArray&lt;/code&gt;), the &lt;code&gt;MyTypedArray&lt;/code&gt; species is the &lt;code&gt;MyTypedArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return a parent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects&quot;&gt;typed array&lt;/a&gt; object in your derived class methods:</source>
          <target state="translated">파생 된 컬렉션 개체 (예 : 사용자 지정 형식 배열 &lt;code&gt;MyTypedArray&lt;/code&gt; )에서 &lt;code&gt;MyTypedArray&lt;/code&gt; 종은 &lt;code&gt;MyTypedArray&lt;/code&gt; 생성자입니다. 그러나 부모 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects&quot;&gt;유형 배열&lt;/a&gt; 을 반환하기 위해 이것을 덮어 쓸 수 있습니다. 파생 클래스 메서드에서 개체 .</target>
        </trans-unit>
        <trans-unit id="350adacc4d9e715c786318e8468e47b1e9d05e5a" translate="yes" xml:space="preserve">
          <source>In a module &lt;code&gt;my-module.js&lt;/code&gt;, we could include the following code:</source>
          <target state="translated">&lt;code&gt;my-module.js&lt;/code&gt; 모듈에서 에 다음 코드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="340c77fb144b30a4542ea8a0c0d5a2ac8c4b516d" translate="yes" xml:space="preserve">
          <source>In a non-constructor context (i.e., without the &lt;a href=&quot;../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator), &lt;code&gt;Number&lt;/code&gt; can be used to perform a type conversion.</source>
          <target state="translated">생성자가 아닌 컨텍스트에서 (즉, &lt;a href=&quot;../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자가 없는 경우 ) &lt;code&gt;Number&lt;/code&gt; 를 사용하여 유형 변환을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dda02a1acb072f90af69f2907af38348fc815a" translate="yes" xml:space="preserve">
          <source>In a related circumstance, what if you actually wanted your &lt;code&gt;Date()&lt;/code&gt; function to be able to be called from the code inside &lt;code&gt;Function()&lt;/code&gt;. Should you just take the easy way out and fall back to &lt;code&gt;eval()&lt;/code&gt;? No! Never. Instead try the approach below.</source>
          <target state="translated">관련 상황에서 실제로 &lt;code&gt;Date()&lt;/code&gt; 함수가 &lt;code&gt;Function()&lt;/code&gt; 내부의 코드에서 호출 될 수 있도록하려면 어떻게해야합니까 ? 쉬운 방법을 택하고 &lt;code&gt;eval()&lt;/code&gt; 돌아 가야 합니까? 아니! 못. 대신 아래 접근 방식을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="810fedbd7d3efd9acd82311336fa539410213dc0" translate="yes" xml:space="preserve">
          <source>In a related circumstance, what if you actually wanted your &lt;code&gt;Date&lt;/code&gt; function to be able to be called from the code inside &lt;code&gt;Function()&lt;/code&gt;. Should you just wimp out and fall back to &lt;code&gt;eval()&lt;/code&gt;? Absolutely not, never ever. Instead try the approach below.</source>
          <target state="translated">관련 상황에서 실제로 &lt;code&gt;Date&lt;/code&gt; 함수를 &lt;code&gt;Function()&lt;/code&gt; 내부의 코드에서 호출 할 수있게하려면 어떻게해야합니까 ? 그냥 겁 내고 &lt;code&gt;eval()&lt;/code&gt; 넘어 가야 합니까? 절대로 절대로 아닙니다. 대신 아래 방법을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b2fc3d6faac50dc84e09287729aea3901d7164ff" translate="yes" xml:space="preserve">
          <source>In a word: Don't.</source>
          <target state="translated">한마디로 :하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3a3bc3b6e0682977940132c5c77dc0be406db238" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;white space&lt;/a&gt; characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;automatic semicolon insertion&lt;/a&gt;. Line terminators are matched by the &lt;strong&gt;\s&lt;/strong&gt; class in &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;공백&lt;/a&gt; 문자 외에도 줄 종결 문자를 사용하여 소스 텍스트의 가독성을 향상시킵니다. 그러나 어떤 경우에는 금지 된 곳이 몇 군데 있기 때문에 줄 종결자가 JavaScript 코드 실행에 영향을 미칠 수 있습니다. 줄 종결자는 &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;자동 세미콜론 삽입&lt;/a&gt; 프로세스에도 영향을줍니다 . 줄 종결자는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;정규식&lt;/a&gt; 에서 &lt;strong&gt;\ s&lt;/strong&gt; 클래스 와 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="45902b9c216bd387d2fe70315207b8d21f3b38a8" translate="yes" xml:space="preserve">
          <source>In addition to methods to read and alter individual components of the local date and time (such as &lt;a href=&quot;date/getday&quot;&gt;&lt;code&gt;getDay()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/sethours&quot;&gt;&lt;code&gt;setHours()&lt;/code&gt;&lt;/a&gt;), there are also versions of the same methods that read and manipulate the date and time using UTC (such as &lt;a href=&quot;date/getutcday&quot;&gt;&lt;code&gt;getUTCDay()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/setutchours&quot;&gt;&lt;code&gt;setUTCHours()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">로컬 날짜 및 시간의 개별 구성 요소 (예 : &lt;a href=&quot;date/getday&quot;&gt; &lt;code&gt;getDay()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/sethours&quot;&gt; &lt;code&gt;setHours()&lt;/code&gt; &lt;/a&gt; ) 를 읽고 변경하는 메서드 외에도 UTC를 사용하여 날짜 및 시간을 읽고 조작하는 동일한 메서드 버전 (예 : &lt;a href=&quot;date/getutcday&quot;&gt; &lt;code&gt;getUTCDay()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/setutchours&quot;&gt; &lt;code&gt;setUTCHours()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eae3ca63d02d68155e6bfd686d4025760d2e921e" translate="yes" xml:space="preserve">
          <source>In addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;automatic semicolon insertion&lt;/a&gt;. Line terminators are matched by the &lt;strong&gt;\s&lt;/strong&gt; class in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;.</source>
          <target state="translated">공백 문자 외에도 줄 종결 자 문자를 사용하여 소스 텍스트의 가독성을 향상시킵니다. 그러나 일부 경우에는 라인 터미네이터가 JavaScript 코드 실행에 영향을 줄 수 있습니다. 라인 터미네이터는 &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;자동 세미콜론 삽입&lt;/a&gt; 프로세스에도 영향을줍니다 . 줄 종결자는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;정규식&lt;/a&gt; 에서 &lt;strong&gt;\ s&lt;/strong&gt; 클래스 와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="d1dbbf23ea13be77ce53036651bf06faa4f98b65" translate="yes" xml:space="preserve">
          <source>In addition to your own symbols, JavaScript has some built-in symbols which represent internal language behaviors which were not exposed to developers in ECMAScript 5 and before. These symbols can be accessed using the following properties:</source>
          <target state="translated">JavaScript에는 자체 심볼 외에도 ECMAScript 5 및 그 이전의 개발자에게 노출되지 않은 내부 언어 동작을 나타내는 일부 내장 심볼이 있습니다. 이러한 기호는 다음 속성을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="541fce84d020f8e809b1424cc43c2d8605b35d86" translate="yes" xml:space="preserve">
          <source>In addition, since true iterables cannot be polyfilled, this implementation does not support generic iterables as defined in the 6&lt;sup&gt;th&lt;/sup&gt; Edition of ECMA-262.</source>
          <target state="translated">또한 진정한 이터 러블은 폴리 필 할 수 없기 때문에이 구현은 ECMA-262 의 6 &lt;sup&gt;번째&lt;/sup&gt; 에디션에 정의 된 일반 이터 러블을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="772f53b7684325c70c59fb803ea949efc447df73" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;global_objects/string/raw&quot;&gt;&lt;code&gt;String.raw()&lt;/code&gt;&lt;/a&gt; method exists to create raw strings just like the default template function and string concatenation would create.</source>
          <target state="translated">또한 &lt;a href=&quot;global_objects/string/raw&quot;&gt; &lt;code&gt;String.raw()&lt;/code&gt; &lt;/a&gt; 메서드는 기본 템플릿 함수 및 문자열 연결과 같은 원시 문자열을 만들기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="afdac2e1c883f1486c41d87b72385f76020d0b90" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;global_objects/string/raw&quot;&gt;&lt;code&gt;String.raw()&lt;/code&gt;&lt;/a&gt; method exists to create raw strings&amp;mdash;just like the default template function and string concatenation would create.</source>
          <target state="translated">또한 &lt;a href=&quot;global_objects/string/raw&quot;&gt; &lt;code&gt;String.raw()&lt;/code&gt; &lt;/a&gt; 메서드는 기본 템플릿 함수 및 문자열 연결이 만드는 것처럼 원시 문자열을 만들기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="dc6c8d3bc5587fba3a2992288ddc497a933c9e1d" translate="yes" xml:space="preserve">
          <source>In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:</source>
          <target state="translated">또한 코드를 주석에 래핑하여 코드가 실행되지 않도록 코드를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3895a9d4c10daddb44b0baf3cea41b98e617fe5c" translate="yes" xml:space="preserve">
          <source>In all cases, the returned promise is fulfilled with an array containing &lt;strong&gt;all &lt;/strong&gt;the values of the &lt;var&gt;iterable&lt;/var&gt; passed as argument (also non-promise values).</source>
          <target state="translated">모든 경우에, 리턴 된 약속은 인수로 전달 된 &lt;var&gt;iterable&lt;/var&gt; 의 &lt;strong&gt;모든&lt;/strong&gt; 값을 포함하는 배열 (약속이 아닌 값)로 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="c81b508fa4aa4f5e76e7a5fb07f3df97a3e6e267" translate="yes" xml:space="preserve">
          <source>In all other cases, a resolving Promise is returned. In the following example, the first &lt;code&gt;then()&lt;/code&gt; will return &lt;code&gt;42&lt;/code&gt; wrapped in a resolving Promise even though the previous Promise in the chain was rejected.</source>
          <target state="translated">다른 모든 경우에는 해결 약속이 반환됩니다. 다음 예제에서 첫 번째 &lt;code&gt;then()&lt;/code&gt; 은 체인의 이전 Promise가 거부 되었음에도 불구하고 해결 Promise에 래핑 된 &lt;code&gt;42&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8f2e12a377e763cd095116ed09fef665af7281bf" translate="yes" xml:space="preserve">
          <source>In all other cases, a resolving Promise is returned. In the following example, the first &lt;code&gt;then()&lt;/code&gt; will return &lt;code&gt;42&lt;/code&gt; wrapped resolving Promise even though the previous Promise in the chain was rejected.</source>
          <target state="translated">다른 모든 경우에는 해결 약속이 반환됩니다. 다음 예에서 첫 번째 &lt;code&gt;then()&lt;/code&gt; 은 체인의 이전 약속이 거부 된 경우에도 &lt;code&gt;42&lt;/code&gt; 개의 랩핑 된 약속을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4f386d0fd63e7041445027553d8387adba4f48a3" translate="yes" xml:space="preserve">
          <source>In an ECMAScript 2016 environment which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does increment for an incrementing variable automatically (if the character warrants it in being a surrogate pair).</source>
          <target state="translated">구조화되지 않은 할당을 허용하는 ECMAScript 2016 환경에서 다음은 증분 변수에 대해 자동으로 증가한다는 점에서보다 간결하고 다소 유연한 대안입니다 (캐릭터가 대리 쌍이라는 것을 보증하는 경우).</target>
        </trans-unit>
        <trans-unit id="b003a314ef1e4fb418bf66b8bc466ac14403b108" translate="yes" xml:space="preserve">
          <source>In an ECMAScript 2016 environment which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).</source>
          <target state="translated">비 구조적 할당을 허용하는 ECMAScript 2016 환경에서 다음은 증분 변수를 자동으로 증분한다는 점에서보다 간결하고 다소 유연한 대안입니다 (문자가 대리 쌍으로 보증하는 경우).</target>
        </trans-unit>
        <trans-unit id="6ae1d411c5185e7a3f1b56084729d3af21f20494" translate="yes" xml:space="preserve">
          <source>In an inline event handler</source>
          <target state="translated">인라인 이벤트 핸들러에서</target>
        </trans-unit>
        <trans-unit id="15a234979acf5c85ed72ab3a44cfa7cf0c039e37" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, &lt;code&gt;DateTimeFormat&lt;/code&gt; uses the default locale and default options.</source>
          <target state="translated">로캘을 지정하지 않고 기본적으로 사용하는 경우 &lt;code&gt;DateTimeFormat&lt;/code&gt; 은 기본 로캘 및 기본 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c8fca8d2d4d72fbc7ff12349b16baad5284d084" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, a formatted string in the default locale and with default options is returned.</source>
          <target state="translated">로케일을 지정하지 않고 기본적으로 사용하면 기본 로케일 및 기본 옵션이있는 형식화 된 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e30dc2f73ac6e65084e81c106ff21218b79a2446" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, a formatted string in the default locale and with default options is returned. This is useful to distinguish between singular and plural forms, e.g. &quot;dog&quot; and &quot;dogs&quot;.</source>
          <target state="translated">로케일을 지정하지 않고 기본적으로 사용하면 기본 로케일 및 기본 옵션이있는 형식화 된 문자열이 리턴됩니다. 이는 단수형과 복수형, 예를 들어 &quot;개&quot;와 &quot;개&quot;를 구별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4e6edcf1e99e27f4a3c003689651a55d0701af0f" translate="yes" xml:space="preserve">
          <source>In both, &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; and sloppy mode, a call to &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; throws when adding a new property to a non-extensible object.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 와 조잡한 모드 모두에서 확장 할 수없는 객체에 새 속성을 추가하면 &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c5b208d6a1696deaa27e5631e305def887a5f0d" translate="yes" xml:space="preserve">
          <source>In browser versions supporting named capturing groups, will be an object whose keys are the used group names, and whose values are the matched portions (&lt;code&gt;undefined&lt;/code&gt; if not matched).</source>
          <target state="translated">명명 된 캡처 링 그룹을 지원하는 브라우저 버전에서는 키가 사용 된 그룹 이름이고 값이 일치하는 부분 ( 일치하지 않으면 &lt;code&gt;undefined&lt;/code&gt; 않음) 인 객체가됩니다 .</target>
        </trans-unit>
        <trans-unit id="212201f4cd8f19efb2a09bdffc69dc9cf7ec33b3" translate="yes" xml:space="preserve">
          <source>In browsers which support named capturing groups, the following code captures &quot;&lt;code&gt;fox&lt;/code&gt;&quot; or &quot;&lt;code&gt;cat&lt;/code&gt;&quot; into a group named &quot;&lt;code&gt;animal&lt;/code&gt;&quot;:</source>
          <target state="translated">명명 된 캡처 그룹을 지원하는 브라우저에서 다음 코드는 &quot; &lt;code&gt;fox&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;cat&lt;/code&gt; &quot;을 &quot; &lt;code&gt;animal&lt;/code&gt; &quot; 이라는 그룹으로 캡처합니다 .</target>
        </trans-unit>
        <trans-unit id="2fec9e70a7a8e5a0b462b870bc9aad4fb731e521" translate="yes" xml:space="preserve">
          <source>In case of an error, for example if a property is non-writable, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised, and the &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; object is changed if any properties are added before the error is raised.</source>
          <target state="translated">오류가 발생한 경우 (예 : 속성이 쓰기 불가능한 경우) &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 하고 오류가 발생하기 전에 속성이 추가되면 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 객체가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5c53b39ddf5eb1e541cbcb2fd25d92feed9aab69" translate="yes" xml:space="preserve">
          <source>In case of an error, for example if a property is non-writable, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised, and the &lt;code&gt;target&lt;/code&gt; object can be changed if any properties are added before error is raised.</source>
          <target state="translated">예를 들어 속성을 쓸 수없는 경우와 같은 오류가 발생하면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생하고 오류가 발생하기 전에 속성이 추가되면 &lt;code&gt;target&lt;/code&gt; 개체가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743863f600d0a0b25842692572596ef37053d3d1" translate="yes" xml:space="preserve">
          <source>In cases where the &lt;code&gt;year&lt;/code&gt; would be output, &lt;code&gt;.format()&lt;/code&gt; may commonly present these side-by-side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2715483284a25ba548ae565967fe75b81647c6bb" translate="yes" xml:space="preserve">
          <source>In certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backticked template, it is simple to allow inner backticks simply by using them inside a placeholder &lt;code&gt;${ }&lt;/code&gt; within the template.</source>
          <target state="translated">어떤 경우에는 템플릿을 중첩하는 것이 구성 가능한 문자열을 갖는 가장 쉬운 (그리고 아마도 더 읽기 쉬운) 방법입니다. 백틱이있는 템플릿 내에서 단순히 템플릿 내의 자리 표시 자 &lt;code&gt;${ }&lt;/code&gt; 내에서 내부 백틱을 사용하여 내부 백틱을 허용하는 것은 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="185b559f3c0aaf526e6b24fa70557e54bd43808c" translate="yes" xml:space="preserve">
          <source>In certain times, nesting a template is the easiest and perhaps more readable way to have configurable strings. Within a backticked template it is simple to allow inner backticks simply by using them inside a placeholder &lt;code&gt;${ }&lt;/code&gt; within the template. For instance, if condition a is true: then return this templated literal.</source>
          <target state="translated">어떤 경우에는 템플릿 중첩이 구성 가능한 문자열을 갖는 가장 쉽고 읽기 쉬운 방법입니다. 백틱 템플릿 내에서 템플릿 내의 자리 표시 자 &lt;code&gt;${ }&lt;/code&gt; 안에서 내부 백틱을 사용하여 간단하게 내부 백틱을 허용 할 수 있습니다. 예를 들어, 조건 a가 true 인 경우이 템플릿 리터럴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4db1a326096311ea6af1c3fb975c7c9930e3121d" translate="yes" xml:space="preserve">
          <source>In class constructors, &lt;code&gt;new.target&lt;/code&gt; refers to the constructor that was directly invoked by &lt;code&gt;new&lt;/code&gt;. This is also the case if the constructor is in a parent class and was delegated from a child constructor.</source>
          <target state="translated">클래스 생성자에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;code&gt;new&lt;/code&gt; 에서 직접 호출 한 생성자를 나타냅니다 . 생성자가 부모 클래스에 있고 자식 생성자로부터 위임 된 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6bdb1b0d5feb35f9fbe77dd15e2d3235928fcdf4" translate="yes" xml:space="preserve">
          <source>In class constructors, it refers to the constructed class.</source>
          <target state="translated">클래스 생성자에서는 생성 된 클래스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="94af82422eceede92c75ba324542543e93fcf1e0" translate="yes" xml:space="preserve">
          <source>In code using XPCOM &lt;code&gt;instanceof&lt;/code&gt; has special effect: &lt;code&gt;obj instanceof &lt;/code&gt;&lt;em&gt;&lt;code&gt;xpcomInterface&lt;/code&gt;&lt;/em&gt; (e.g. &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt;) calls &lt;code&gt;obj.QueryInterface(&lt;em&gt;xpcomInterface&lt;/em&gt;)&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt; if QueryInterface succeeded. A side effect of such call is that you can use &lt;em&gt;&lt;code&gt;xpcomInterface&lt;/code&gt;&lt;/em&gt;'s properties on &lt;code&gt;obj&lt;/code&gt; after a successful &lt;code&gt;instanceof&lt;/code&gt; test. Unlike standard JavaScript globals, the test &lt;code&gt;obj instanceof xpcomInterface&lt;/code&gt; works as expected even if &lt;code&gt;obj&lt;/code&gt; is from a different scope.</source>
          <target state="translated">XPCOM &lt;code&gt;instanceof&lt;/code&gt; 를 사용하는 코드에서 특별한 효과가 있습니다 : &lt;code&gt;obj instanceof &lt;/code&gt; &lt;em&gt; &lt;code&gt;xpcomInterface&lt;/code&gt; &lt;/em&gt; (예 : &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt; )는 &lt;code&gt;obj.QueryInterface(&lt;em&gt;xpcomInterface&lt;/em&gt;)&lt;/code&gt; 호출 하고 QueryInterface가 성공하면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 이러한 호출의 부작용은 테스트 의 성공적인 &lt;code&gt;instanceof&lt;/code&gt; 후에 &lt;code&gt;obj&lt;/code&gt; 에서 &lt;em&gt; &lt;code&gt;xpcomInterface&lt;/code&gt; &lt;/em&gt; 속성을 사용할 수 있다는 것 입니다. 표준 JavaScript 전역과 달리 &lt;code&gt;obj instanceof xpcomInterface&lt;/code&gt; 의 테스트 obj 인스턴스 는 &lt;code&gt;obj&lt;/code&gt; 가 다른 범위에 있더라도 예상대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="14cfe9e8018b79bf958a062759f1007e85f4498c" translate="yes" xml:space="preserve">
          <source>In code using XPCOM, &lt;code&gt;instanceof&lt;/code&gt; has special effect: &lt;code&gt;&lt;var&gt;obj&lt;/var&gt; instanceof &lt;var&gt;xpcomInterface&lt;/var&gt;&lt;/code&gt; (e.g. &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt;) calls &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;.QueryInterface(&lt;var&gt;xpcomInterface&lt;/var&gt;)&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;QueryInterface&lt;/code&gt; succeeded.</source>
          <target state="translated">XPCOM을 사용하는 코드에서 &lt;code&gt;instanceof&lt;/code&gt; 는 특별한 효과가 있습니다. &lt;code&gt;&lt;var&gt;obj&lt;/var&gt; instanceof &lt;var&gt;xpcomInterface&lt;/var&gt;&lt;/code&gt; (예 : &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt; )는 &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;.QueryInterface(&lt;var&gt;xpcomInterface&lt;/var&gt;)&lt;/code&gt; 호출 하고 &lt;code&gt;QueryInterface&lt;/code&gt; 가 성공 하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="992fc64c413d9c88cc713416bf184f970d9fbfac" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isfinite&quot;&gt;&lt;code&gt;isFinite()&lt;/code&gt;&lt;/a&gt; function, this method doesn't first convert the parameter to a number. This means only values of the type number &lt;em&gt;and&lt;/em&gt; are finite return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isfinite&quot;&gt; &lt;code&gt;isFinite()&lt;/code&gt; &lt;/a&gt; 함수와 비교 하여이 메서드는 먼저 매개 변수를 숫자로 변환하지 않습니다. 이 방법은 타입 번호의 값 &lt;em&gt;과&lt;/em&gt; 유한 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a613e3bd8d9172c0deeee7a9b7b65c63525ed0bb" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isfinite&quot;&gt;&lt;code&gt;isFinite()&lt;/code&gt;&lt;/a&gt; function, this method doesn't forcibly convert the parameter to a number. This means only values of the type number, that are also finite, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isfinite&quot;&gt; &lt;code&gt;isFinite()&lt;/code&gt; &lt;/a&gt; 함수와 비교 하여이 메소드는 매개 변수를 강제로 숫자로 변환하지 않습니다. 이는 유형 번호의 값만, 유한 한 값만 &lt;code&gt;true&lt;/code&gt; 를 리턴 함을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d244f5107598de168b205e3c43fd027e6571c188" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isnan&quot;&gt;&lt;code&gt;isNaN()&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;Number.isNaN()&lt;/code&gt; doesn't suffer the problem of forcefully converting the parameter to a number. This means it is now safe to pass values that would normally convert to &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;, but aren't actually the same value as &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;. This also means that only values of the type number, that are also &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isnan&quot;&gt; &lt;code&gt;isNaN()&lt;/code&gt; &lt;/a&gt; 함수와 비교하여 &lt;code&gt;Number.isNaN()&lt;/code&gt; 은 매개 변수를 숫자로 강제 변환하는 문제를 겪지 않습니다. 즉, 일반적으로 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 으로 변환되는 값을 전달하는 것이 안전 하지만 실제로 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 과 동일한 값은 아닙니다 . 이것은 또한 유형 번호의 값, 즉 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 인 값만 &lt;code&gt;true&lt;/code&gt; 를 반환 함을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="b720da4b14164a69ca218bd2c91051947f21b9ad" translate="yes" xml:space="preserve">
          <source>In comparison, the Promise returned by &lt;a href=&quot;all&quot;&gt;&lt;code&gt;Promise.all()&lt;/code&gt;&lt;/a&gt; may be more appropriate if the tasks are dependent on each other / if you'd like to immediately reject upon any of them rejecting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8217e6b58b2edad9f5a6741e352a92ad99a7c0e8" translate="yes" xml:space="preserve">
          <source>In constructors, &lt;code&gt;new.target&lt;/code&gt; refers to the constructor that was invoked by &lt;a href=&quot;operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 에서 호출 한 생성자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f621dfa4be91ca91418c57854499d4ee4a81c259" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Sets&lt;/code&gt;, &lt;code&gt;WeakSets&lt;/code&gt; are &lt;strong&gt;collections of objects only&lt;/strong&gt; and not of arbitrary values of any type.</source>
          <target state="translated">대조적 &lt;code&gt;Sets&lt;/code&gt; , &lt;code&gt;WeakSets&lt;/code&gt; 이 있는 &lt;strong&gt;개체 만 모음&lt;/strong&gt; 이 아닌 임의의 종류의 임의의 값이.</target>
        </trans-unit>
        <trans-unit id="29612058b2a37d96155ca6d8e8846e19f5383f8e" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Symbol()&lt;/code&gt;, the &lt;code&gt;Symbol.for()&lt;/code&gt; function creates a symbol available in a global symbol registry list. &lt;code&gt;Symbol.for()&lt;/code&gt; does also not necessarily create a new symbol on every call, but checks first if a symbol with the given &lt;code&gt;key&lt;/code&gt; is already present in the registry. In that case, that symbol is returned. If no symbol with the given key is found, &lt;code&gt;Symbol.for()&lt;/code&gt; will create a new global symbol.</source>
          <target state="translated">대조적으로 &lt;code&gt;Symbol()&lt;/code&gt; 는 &lt;code&gt;Symbol.for()&lt;/code&gt; 함수는 전역 심볼 레지스트리 목록에서 사용할 수있는 기호를 작성합니다. &lt;code&gt;Symbol.for()&lt;/code&gt; 는 모든 호출에서 반드시 새 심볼을 만들 필요는 없지만 주어진 &lt;code&gt;key&lt;/code&gt; 가 있는 심볼 이 레지스트리에 이미 있는지 먼저 확인합니다 . 이 경우 해당 기호가 반환됩니다. 주어진 키를 가진 심볼이 없으면 &lt;code&gt;Symbol.for()&lt;/code&gt; 는 새로운 전역 심볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2ff9ea516bcf681c13dab78eda856670cc61010b" translate="yes" xml:space="preserve">
          <source>In contrast to the &lt;a href=&quot;break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt; statement, &lt;code&gt;continue&lt;/code&gt; does not terminate the execution of the loop entirely: instead,</source>
          <target state="translated">&lt;a href=&quot;break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; 문과 달리 &lt;code&gt;continue&lt;/code&gt; 는 루프 실행을 완전히 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abde0a67e7f66ee66240fa3ae208e8af08646767" translate="yes" xml:space="preserve">
          <source>In dealing with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Constructor&quot;&gt;constructors&lt;/a&gt; it is possible to use the &lt;code&gt;let&lt;/code&gt; bindings to share one or more private members without using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Constructor&quot;&gt;생성자를&lt;/a&gt; 처리 할 때 &lt;code&gt;let&lt;/code&gt; 바인딩을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;클로저&lt;/a&gt; 를 사용하지 않고 하나 이상의 개인 멤버를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add9606929e73b3d9b2d5274b0b0c6a25af99476" translate="yes" xml:space="preserve">
          <source>In depth analysis on delete</source>
          <target state="translated">삭제에 대한 심층 분석</target>
        </trans-unit>
        <trans-unit id="1ee02026d6da5c79915a450ae4a367bd8161a9d5" translate="yes" xml:space="preserve">
          <source>In following code, values yielded by &lt;code&gt;g1()&lt;/code&gt; are returned from &lt;code&gt;next()&lt;/code&gt; calls just like those which are yielded by &lt;code&gt;g2()&lt;/code&gt;.</source>
          <target state="translated">다음 코드에서 &lt;code&gt;g1()&lt;/code&gt; 의해 생성 된 값은 &lt;code&gt;g2()&lt;/code&gt; 의해 생성 된 것과 마찬가지로 &lt;code&gt;next()&lt;/code&gt; 호출 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a15b0c2b14bd2c1fe2943c815c7efbf0fce1279" translate="yes" xml:space="preserve">
          <source>In function calls like &lt;code&gt;f()&lt;/code&gt;, the &lt;code&gt;this&lt;/code&gt; value was the global object. In strict mode, it is now &lt;code&gt;undefined&lt;/code&gt;. When a function was called with &lt;code&gt;&lt;a href=&quot;../global_objects/function/call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../global_objects/function/apply&quot;&gt;apply&lt;/a&gt;&lt;/code&gt;, if the value was a primitive value, this one was boxed into an object (or the global object for &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;). In strict mode, the value is passed directly without conversion or replacement.</source>
          <target state="translated">같은 함수 호출에서 &lt;code&gt;f()&lt;/code&gt; 는 &lt;code&gt;this&lt;/code&gt; 값은 글로벌 개체였다. 엄격 모드에서는 이제 &lt;code&gt;undefined&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;../global_objects/function/call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../global_objects/function/apply&quot;&gt;apply&lt;/a&gt;&lt;/code&gt; 로 함수를 호출 할 때 값이 기본 값인 경우이 값은 객체 (또는 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 의 경우 전역 객체)에 상자로 표시되었습니다 . 엄격 모드에서는 값이 변환이나 교체없이 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb456854f7e12a1b6d3067042522e245c1c473c" translate="yes" xml:space="preserve">
          <source>In general, it is best not to add, modify, or remove properties from the object during iteration, other than the property currently being visited. There is no guarantee whether an added property will be visited, whether a modified property (other than the current one) will be visited before or after it is modified, or whether a deleted property will be visited before it is deleted.</source>
          <target state="translated">일반적으로 현재 방문중인 속성 이외의 반복 중에 객체에서 속성을 추가, 수정 또는 제거하지 않는 것이 가장 좋습니다. 추가 된 속성을 방문할지, 수정 된 속성 (현재 속성 이외의 속성)을 수정하기 전후에 방문할지 또는 삭제 된 속성을 삭제하기 전에 방문할지 여부는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1736f0236423f733081a8390c0b2e0a21ffb4c0" translate="yes" xml:space="preserve">
          <source>In many engines &lt;code&gt;globalThis&lt;/code&gt; will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a &lt;a href=&quot;proxy&quot;&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/a&gt; around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0afde6863fc1a738ab65eba09c55d6be415dfebb" translate="yes" xml:space="preserve">
          <source>In many locales, accounting format means to wrap the number with parentheses instead of appending a minus sign. You can enable this formatting by setting the &lt;code&gt;currencySign&lt;/code&gt; option to &quot;&lt;code&gt;accounting&lt;/code&gt;&quot;. The default value is &quot;&lt;code&gt;standard&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469cf6b2ef6e68adf3f920541f214faf833cd651" translate="yes" xml:space="preserve">
          <source>In math, you can write 2 &amp;times; (3 + 5) as 2*(3 + 5) or just 2(3 + 5).</source>
          <target state="translated">수학에서는 2 &amp;times; (3 + 5)를 2 * (3 + 5) 또는 2 (3 + 5)로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd4e3c69a66abeb7081b617a2e513e6ed402c377" translate="yes" xml:space="preserve">
          <source>In math, you can write 2 x (3 + 5) as 2*(3 + 5) or just 2(3 + 5). Using the latter will throw an error:</source>
          <target state="translated">수학에서는 2 x (3 + 5)를 2 * (3 + 5) 또는 2 (3 + 5)로 쓸 수 있습니다. 후자를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15f72587f05206c7a8bbb329e12777545b394d35" translate="yes" xml:space="preserve">
          <source>In modern browsers (JavaScript 1.8.5 / Firefox 4+), &lt;code&gt;undefined&lt;/code&gt; is a non-configurable, non-writable property per the ECMAScript 5 specification. Even when this is not the case, avoid overriding it.</source>
          <target state="translated">최신 브라우저 (JavaScript 1.8.5 / Firefox 4+)에서 &lt;code&gt;undefined&lt;/code&gt; 는 ECMAScript 5 사양에 따라 구성 할 수없고 쓸 수없는 속성입니다. 그렇지 않은 경우에도 무시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4e0d4934fe476d8eb4009f64ddad5959ccf4aadb" translate="yes" xml:space="preserve">
          <source>In modern browsers (JavaScript 1.8.5 / Firefox 4+), &lt;code&gt;undefined&lt;/code&gt; is a non-configurable, non-writable property, per the ECMAScript 5 specification. (Even when this is not the case, avoid overriding it.)</source>
          <target state="translated">최신 브라우저 (JavaScript 1.8.5 / Firefox 4+)에서 &lt;code&gt;undefined&lt;/code&gt; 는 ECMAScript 5 사양에 따라 구성 할 수없고 쓸 수없는 속성입니다. (이 경우가 아니더라도 재정의하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="c6effb59d91f10a30d514644f887cd90896f02d7" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;String.raw()&lt;/code&gt; is used with template strings. The first syntax mentioned above is only rarely used, because the JavaScript engine will call this with proper arguments for you, (just like with other &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;tag functions&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 &lt;code&gt;String.raw()&lt;/code&gt; 는 템플릿 문자열과 함께 사용됩니다. 위에서 언급 한 첫 번째 구문은 JavaScript 엔진이 적절한 인수를 사용하여이를 호출하기 때문에 거의 사용되지 않습니다 (다른 &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;태그 함수&lt;/a&gt; 와 마찬가지로 ).</target>
        </trans-unit>
        <trans-unit id="5a29654e172b7c9185515aad6d728b59b008dcd2" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;String.raw()&lt;/code&gt; is used with template strings. The first syntax mentioned above is only rarely used, because the JavaScript engine will call this with proper arguments for you, just like with other &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;tag functions&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;String.raw()&lt;/code&gt; 는 템플릿 문자열과 함께 사용됩니다. 위에서 언급 한 첫 번째 구문은 다른 &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;태그 함수&lt;/a&gt; 와 마찬가지로 JavaScript 엔진이이를 적절한 인수로 호출하기 때문에 거의 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eb884e7d7586dde23b9e701c398786a65a36db9b" translate="yes" xml:space="preserve">
          <source>In most cases, the value of &lt;code&gt;this&lt;/code&gt; is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the &lt;a href=&quot;../global_objects/function/bind&quot;&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/a&gt; method to &lt;a href=&quot;this#The_bind_method&quot;&gt;set the value of a function's &lt;code&gt;this&lt;/code&gt; regardless of how it's called&lt;/a&gt;, and ES2015 introduced &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt; which don't provide their own &lt;code&gt;this&lt;/code&gt; binding (it retains the &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical context).</source>
          <target state="translated">대부분의 &lt;code&gt;this&lt;/code&gt; 값은 함수가 호출되는 방식 (런타임 바인딩)에 의해 결정됩니다. 실행 중 할당으로 설정할 수 없으며 함수가 호출 될 때마다 다를 수 있습니다. ES5는 도입 &lt;a href=&quot;../global_objects/function/bind&quot;&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;/a&gt; 하는 방법에 &lt;a href=&quot;this#The_bind_method&quot;&gt;함수의 값의 설정 &lt;code&gt;this&lt;/code&gt; 없이이 호출 방법&lt;/a&gt; 및 ES2015 도입 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;기능 화살표를&lt;/a&gt; 자신이 제공하지 않는 &lt;code&gt;this&lt;/code&gt; (그것은 유지 바인딩 &lt;code&gt;this&lt;/code&gt; 클로징 어휘 문맥의 값).</target>
        </trans-unit>
        <trans-unit id="ac60cdf424b99dce62b5701d4d143d86d375a54d" translate="yes" xml:space="preserve">
          <source>In most cases, the value of &lt;code&gt;this&lt;/code&gt; is determined by how a function is called. It can't be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the &lt;a href=&quot;../global_objects/function/bind&quot;&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/a&gt; method to &lt;a href=&quot;#The_bind_method&quot;&gt;set the value of a function's &lt;code&gt;this&lt;/code&gt; regardless of how it's called&lt;/a&gt;, and ES2015 introduced &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt; which don't provide their own &lt;code&gt;this&lt;/code&gt; binding (it retains the &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical context).</source>
          <target state="translated">대부분의 &lt;code&gt;this&lt;/code&gt; 값은 함수 호출 방법에 따라 결정됩니다. 실행 중에 할당하여 설정할 수 없으며 함수가 호출 될 때마다 다를 수 있습니다. ES5는 도입 &lt;a href=&quot;../global_objects/function/bind&quot;&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;/a&gt; 하는 방법에 &lt;a href=&quot;#The_bind_method&quot;&gt;함수의 값의 설정 &lt;code&gt;this&lt;/code&gt; 없이이 호출 방법&lt;/a&gt; 및 ES2015 도입 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;기능 화살표를&lt;/a&gt; 자신이 제공하지 않는 &lt;code&gt;this&lt;/code&gt; (그것은 유지 바인딩 &lt;code&gt;this&lt;/code&gt; 클로징 어휘 문맥의 값).</target>
        </trans-unit>
        <trans-unit id="6d3bbd72aff7458ac96d23ca8ea12c673fb557f5" translate="yes" xml:space="preserve">
          <source>In most cases, using &lt;a href=&quot;rest_parameters&quot;&gt;rest parameters&lt;/a&gt; is a good alternative to using an &lt;code&gt;arguments&lt;/code&gt; object.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;rest_parameters&quot;&gt;나머지 매개 변수&lt;/a&gt; 를 사용하는 것이 &lt;code&gt;arguments&lt;/code&gt; 객체 를 사용하는 좋은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="5fc6c6c77ddc6a5c73413e02d1078992067d9c03" translate="yes" xml:space="preserve">
          <source>In most languages like PHP and Python and others that have an exponentiation operator (**), the exponentiation operator is defined to have a higher precedence than unary operators such as unary + and unary -, but there are a few exceptions. For example, in Bash the ** operator is defined to have a lower precedence than unary operators. In JavaScript, it is impossible to write an ambiguous exponentiation expression, i.e. you cannot put a unary operator (&lt;code&gt;+/-/~/!/delete/void/typeof&lt;/code&gt;) immediately before the base number.</source>
          <target state="translated">PHP, Python 및 지수 연산자 (**)가있는 다른 언어의 경우, 지수 연산자는 unary + 및 unary-와 같은 단항 연산자보다 우선 순위가 높지만 몇 가지 예외가 있습니다. 예를 들어, Bash에서 ** 연산자는 단항 연산자보다 우선 순위가 낮도록 정의됩니다. JavaScript에서는 모호한 지수 표현식을 작성할 수 없습니다. 즉 , 기본 번호 바로 앞에 단항 연산자 ( &lt;code&gt;+/-/~/!/delete/void/typeof&lt;/code&gt; )를 넣을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6d5c9eb07397ac19d66c304576f166f918d4ccd9" translate="yes" xml:space="preserve">
          <source>In most languages, such as PHP, Python, and others that have an exponentiation operator (&lt;code&gt;**&lt;/code&gt;), the exponentiation operator is defined to have a higher precedence than unary operators, such as unary &lt;code&gt;+&lt;/code&gt; and unary &lt;code&gt;-&lt;/code&gt;, but there are a few exceptions. For example, in Bash, the &lt;code&gt;**&lt;/code&gt; operator is defined to have a lower precedence than unary operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a5793df1225a02f211cbab4dd35b2dfa4aa24a" translate="yes" xml:space="preserve">
          <source>In non-strict code, function declarations inside blocks behave strangely. Do not use them.</source>
          <target state="translated">엄격하지 않은 코드에서 블록 내부의 함수 선언은 이상하게 작동합니다. 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1874ca4c77d194ed9a187f427ff439010d26be13" translate="yes" xml:space="preserve">
          <source>In non-strict code, function declarations inside blocks behave strangely. For example:</source>
          <target state="translated">엄격하지 않은 코드에서 블록 내의 함수 선언은 이상하게 동작합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="860c9839372531fc54aae6d18e28914fe55a5604" translate="yes" xml:space="preserve">
          <source>In non-strict mode, modifying a value in the &lt;code&gt;arguments&lt;/code&gt; object modifies the corresponding named argument. This made optimizations complicated for JavaScript engine and made code harder to read/understand. In strict mode, the &lt;code&gt;arguments&lt;/code&gt; object is created and initialized with the same values than the named arguments, but changes to either the &lt;code&gt;arguments&lt;/code&gt; object or the named arguments aren't reflected in one another.</source>
          <target state="translated">엄격하지 않은 모드에서 &lt;code&gt;arguments&lt;/code&gt; 객체 의 값을 수정하면 해당하는 명명 된 인수가 수정됩니다. 이로 인해 JavaScript 엔진에 대한 최적화가 복잡해지고 코드를 읽고 이해하기가 더 어려워졌습니다. 엄격 모드에서는 &lt;code&gt;arguments&lt;/code&gt; 객체가 명명 된 인수와 동일한 값으로 만들어지고 초기화되지만 &lt;code&gt;arguments&lt;/code&gt; 객체 또는 명명 된 인수에 대한 변경 내용 은 서로 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95aa3b03b2032d638c1633fec4e82b00ad7a1890" translate="yes" xml:space="preserve">
          <source>In non-strict, this would silently fail, in contradiction with the user expectation.</source>
          <target state="translated">엄격하지 않은 경우, 이는 사용자의 기대와 모순되어 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cb7ee7b5cd4eb0f5efd8c7fee9d564b5efb524f6" translate="yes" xml:space="preserve">
          <source>In normal function calls (as opposed to constructor function calls), &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. This lets you detect if a function was called with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; as a constructor.</source>
          <target state="translated">생성자 함수 호출과 달리 일반적인 함수 호출에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 이를 통해 생성자 가 &lt;a href=&quot;new&quot;&gt;new 인&lt;/a&gt; 함수가 호출되었는지 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="230572d6652702c77e4d55e58d676991394f1446" translate="yes" xml:space="preserve">
          <source>In normal function calls (as opposed to constructor function calls), &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. This lets you detect whether a function was called with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; as a constructor.</source>
          <target state="translated">일반 함수 호출 (생성자 함수 호출과 반대)에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 이렇게하면 &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; 를 생성자로 사용하여 함수가 호출되었는지 여부를 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0a271923b767ecf71d00311996c399f935078d0" translate="yes" xml:space="preserve">
          <source>In older implementations, which ignore the &lt;code&gt;&lt;var&gt;locales&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;options&lt;/var&gt;&lt;/code&gt; arguments, the locale used and the form of the string returned are entirely implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;locales&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;options&lt;/var&gt;&lt;/code&gt; 인수 를 무시하는 이전 구현에서는 사용 된 로케일 과 반환되는 문자열 형식이 전적으로 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a68eef8c5fb49c60634ed1d21df3a98ae0e0f974" translate="yes" xml:space="preserve">
          <source>In order to be &lt;strong&gt;iterable&lt;/strong&gt;, an object must implement the &lt;code&gt;@@iterator&lt;/code&gt; method, meaning that the object (or one of the objects up its &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;prototype chain&lt;/a&gt;) must have a property with a &lt;code&gt;@@iterator&lt;/code&gt; key which is available via constant &lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;반복&lt;/strong&gt; 할 수 있으 려면 객체가 &lt;code&gt;@@iterator&lt;/code&gt; 메서드를 구현해야합니다. 즉, 객체 (또는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;프로토 타입 체인&lt;/a&gt; 위의 객체 중 하나 )에는 상수 &lt;a href=&quot;global_objects/symbol/iterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; 를 통해 사용할 수 있는 &lt;code&gt;@@iterator&lt;/code&gt; 키 가있는 속성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e0eefb52bc8e7160456b7047e4f143d09203972a" translate="yes" xml:space="preserve">
          <source>In order to be &lt;strong&gt;iterable&lt;/strong&gt;, an object must implement the &lt;strong&gt;@@iterator&lt;/strong&gt; method, meaning that the object (or one of the objects up its &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;prototype chain&lt;/a&gt;) must have a property with a &lt;strong&gt;@@iterator &lt;/strong&gt;key which is available via constant &lt;code&gt;&lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;반복 가능&lt;/strong&gt; 하기 위해 객체는 &lt;strong&gt;@@ iterator&lt;/strong&gt; 메소드를 구현해야합니다. 즉, 객체 (또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;프로토 타입 체인&lt;/a&gt; 에있는 객체 중 하나 )에는 상수 &lt;code&gt;&lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 를 통해 사용할 수 있는 &lt;strong&gt;@@ iterator&lt;/strong&gt; 키 가있는 특성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f6054beeb1ffdb7a5b2ec1e645efc7c30d6fb57" translate="yes" xml:space="preserve">
          <source>In order to be a valid Unicode locale identifier, a string must start with the language subtag. The main argument to the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; constructor must be a valid Unicode locale identifier, so whenever the constructor is used, it must be passed an identifier with a language subtag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de074ed49182f2a1dc2aec280709fa9abad4868" translate="yes" xml:space="preserve">
          <source>In order to call a static method or property within another static method of the same class, you can use the &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">동일한 클래스의 다른 정적 메서드 내에서 정적 메서드 또는 속성을 호출하려면 &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="862bd58d82c44825625f345f8000cff5f3f26277" translate="yes" xml:space="preserve">
          <source>In order to call a static method within another static method of the same class, you can use the &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">같은 클래스의 다른 정적 메서드 내에서 정적 메서드를 호출하려면 &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e455045de218103473f428d3071d54854bd467dc" translate="yes" xml:space="preserve">
          <source>In order to create and get dates between the years 0 and 99 the &lt;a href=&quot;date/setfullyear&quot;&gt;&lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/getfullyear&quot;&gt;&lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt;&lt;/a&gt; methods should be used.</source>
          <target state="translated">0에서 99 년 사이의 날짜를 만들고 가져 오려면 &lt;a href=&quot;date/setfullyear&quot;&gt; &lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/getfullyear&quot;&gt; &lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt; &lt;/a&gt; 메서드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7bdbb65503f173efe6d93b336bcc3c56478167b" translate="yes" xml:space="preserve">
          <source>In order to create and get dates between the years &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;99&lt;/code&gt; the &lt;a href=&quot;date/setfullyear&quot;&gt;&lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/getfullyear&quot;&gt;&lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt;&lt;/a&gt; methods should be used.</source>
          <target state="translated">만들고 년 사이에 날짜를 얻기 위해 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;99&lt;/code&gt; &lt;a href=&quot;date/setfullyear&quot;&gt; &lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;date/getfullyear&quot;&gt; &lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt; &lt;/a&gt; 방법이 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="a06ff19557c3cd24895157a5889dec3667d90b42" translate="yes" xml:space="preserve">
          <source>In order to embed expressions within normal strings, you would use the following syntax:</source>
          <target state="translated">일반 문자열 내에 표현식을 포함 시키려면 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="261c57c7b8631ce4358a48ec7330061dc4f99420" translate="yes" xml:space="preserve">
          <source>In ordinary functions, it refers to the function itself, assuming it was invoked via the &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; operator; otherwise &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 함수에서는 &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; 연산자 를 통해 호출되었다고 가정하고 함수 자체를 참조합니다 . 그렇지 않으면 &lt;code&gt;new.target&lt;/code&gt; 이 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c30f8199b4dd458c0968198031c49f62bc167924" translate="yes" xml:space="preserve">
          <source>In our example above, the arrow function does not have its own &lt;code&gt;this&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt; is used; arrow functions follow the normal variable lookup rules. So while searching for &lt;code&gt;this&lt;/code&gt; which is not present in the current &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt;, an arrow function ends up finding the &lt;code&gt;this&lt;/code&gt; from its enclosing &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 화살표 함수에는 자체 &lt;code&gt;this&lt;/code&gt; 가 없습니다 . 둘러싼 어휘 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위&lt;/a&gt; 의 &lt;code&gt;this&lt;/code&gt; 값 이 사용됩니다. 화살표 함수는 일반 변수 조회 규칙을 따릅니다. 따라서 현재 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위&lt;/a&gt; 에없는 &lt;code&gt;this&lt;/code&gt; 검색하는 동안 화살표 함수는 둘러싸는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위 &lt;/a&gt; &lt;code&gt;this&lt;/code&gt; 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa11c5c2db715285eac1e1df98254200504f278" translate="yes" xml:space="preserve">
          <source>In practice, it is often desirable to catch rejected promises rather than use &lt;code&gt;then&lt;/code&gt;'s two case syntax, as demonstrated below.</source>
          <target state="translated">실제로, 거부 약속보다는 사용을 잡으려고하는 것이 바람직하다 &lt;code&gt;then&lt;/code&gt; 아래 있듯이,의 두 경우 구문.</target>
        </trans-unit>
        <trans-unit id="b5314d4403484a0b484bf7da0c5f2397cb2f703b" translate="yes" xml:space="preserve">
          <source>In some cases, calendars use named years. Chinese and Tibetan calendars, for example, use a 60-year &lt;a href=&quot;https://en.wikipedia.org/wiki/Sexagenary_cycle&quot;&gt;sexagenary cycle&lt;/a&gt; of named years. These years are disambiguated by relationship to corresponding years on the Gregorian calendar. When this is the case, the result of &lt;code&gt;formatToParts()&lt;/code&gt; will contain an entry for &lt;code&gt;relatedYear&lt;/code&gt; when a year would normally be present, containing the 4-digit Gregorian year, instead of an entry for &lt;code&gt;year&lt;/code&gt;. Setting an entry in the bag for &lt;code&gt;year&lt;/code&gt; (with any value) will yield both the and the &lt;code&gt;yearName&lt;/code&gt; Gregorian &lt;code&gt;relatedYear&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbd7dce6756453ed26553376d0427f3b5a41799" translate="yes" xml:space="preserve">
          <source>In some respects (such as sorting) they should be treated as equivalent&amp;mdash;and in some (such as visual appearance) they should not, so they are not canonically equivalent.</source>
          <target state="translated">일부 측면 (예 : 정렬)에서는 동등하게 취급되어야하고 일부 (예 : 시각적 모양)에서는 그렇지 않으므로 표준 적으로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7bd329bf1a6fca5cc1d9f8ca14653cea85fd687" translate="yes" xml:space="preserve">
          <source>In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case). When there are too many function calls, or a function is missing a base case, JavaScript will throw this error.</source>
          <target state="translated">어떤면에서 재귀는 루프와 유사합니다. 둘 다 동일한 코드를 여러 번 실행하며 둘 다 조건이 필요합니다 (이 경우 무한 루프 또는 오히려 무한 재귀를 방지하기 위해). 함수 호출이 너무 많거나 함수에 기본 케이스가 누락 된 경우 JavaScript에서이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dcc3359fcfde967d3f070026eabf07f701112c4c" translate="yes" xml:space="preserve">
          <source>In strict mode code, &lt;code&gt;eval&lt;/code&gt; doesn't create a new variable in the scope from which it was called. Also, of course, in strict mode, the string is evaluated with strict mode rules. Thorough testing will need to be performed to make sure nothing breaks. Not using eval if you don't really need it may be another pragmatic solution.</source>
          <target state="translated">엄격 모드 코드에서 &lt;code&gt;eval&lt;/code&gt; 은 호출 된 범위에서 새 변수를 작성하지 않습니다. 또한 엄격 모드에서 문자열은 엄격 모드 규칙으로 평가됩니다. 파손되지 않도록 철저한 테스트를 수행해야합니다. 실제로 필요하지 않은 경우 eval을 사용하지 않으면 다른 실용적인 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c986ac9c061545ea61f73243c079a502c902273c" translate="yes" xml:space="preserve">
          <source>In strict mode code, more identifiers are reserved.</source>
          <target state="translated">엄격 모드 코드에서는 더 많은 식별자가 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d079a909161f0d359caa88bbeb2a5a566ff9a8" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;defineProperty()&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0305e05ae84323bdcca0727b14cfc634f066fb00" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;defineProperty&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">엄격 모드 에서 &lt;code&gt;defineProperty&lt;/code&gt; 핸들러 의 &lt;code&gt;false&lt;/code&gt; 리턴 값은 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3c2feb1056dffcf47d947141322a5d14d785d80d" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;set()&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d09582a0bc85e38ae88283afb2b5fcbd5053155" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;set&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">엄격 모드에서는 &lt;code&gt;set&lt;/code&gt; 처리기 의 &lt;code&gt;false&lt;/code&gt; 반환 값으로 인해 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b6d02975bb8de9c2d2b0b5332c5792b28df3140" translate="yes" xml:space="preserve">
          <source>In strict mode, however, if the value of &lt;code&gt;this&lt;/code&gt; is not set when entering an execution context, it remains as &lt;code&gt;undefined&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">그러나 엄격 모드에서 실행 컨텍스트를 입력 할 때 &lt;code&gt;this&lt;/code&gt; 값 이 설정 &lt;code&gt;undefined&lt;/code&gt; 경우 다음 예제와 같이 undefined로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d4bd884970a79efd62e157b542fb73cb029e026" translate="yes" xml:space="preserve">
          <source>In strict mode, however, the value of &lt;code&gt;this&lt;/code&gt; remains at whatever it was set to when entering the execution context, so, in the following case, &lt;code&gt;this&lt;/code&gt;will default to &lt;code&gt;undefined&lt;/code&gt;&lt;strong&gt;:&lt;/strong&gt;</source>
          <target state="translated">엄격 모드에서는, 그러나,의 값 &lt;code&gt;this&lt;/code&gt; 유물은 무엇 이건이 다음과 같은 경우에, 그래서 실행 컨텍스트를 입력 할 때로 설정, &lt;code&gt;this&lt;/code&gt; 기본값으로 사용됩니다 &lt;code&gt;undefined&lt;/code&gt; &lt;strong&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5edd29a28bbd08562217025986be25352d683242" translate="yes" xml:space="preserve">
          <source>In strict mode, this would have raised an exception.</source>
          <target state="translated">엄격 모드에서는 예외가 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d019380674a16813ef94c54a0d343b4618bc0042" translate="yes" xml:space="preserve">
          <source>In strict-mode code, the &lt;code&gt;arguments&lt;/code&gt; object behaves the same whether or not a function is passed rest, default, or destructured parameters. That is, assigning new values to variables in the body of the function will not affect the &lt;code&gt;arguments&lt;/code&gt; object. Nor will assigning new variables to the &lt;code&gt;arguments&lt;/code&gt; object affect the value of variables.</source>
          <target state="translated">Strict 모드 코드에서 &lt;code&gt;arguments&lt;/code&gt; 객체는 함수에 rest, default 또는 destructured 매개 변수가 전달되었는지 여부에 관계없이 동일하게 작동합니다. 즉, 함수 본문의 변수에 새 값을 할당해도 &lt;code&gt;arguments&lt;/code&gt; 객체 에는 영향을주지 않습니다 . &lt;code&gt;arguments&lt;/code&gt; 개체에 새 변수를 할당하는 것도 변수 값에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ba434dcfc26a308be81afbb8f480fb122aa093" translate="yes" xml:space="preserve">
          <source>In that very line, the &lt;u&gt;if block's &quot;foo&quot;&lt;/u&gt; has already been created in the lexical environment, but has not yet reached (and &lt;strong&gt;terminated&lt;/strong&gt;) its initialization (which is part of the statement itself): it's still in the temporal dead zone.</source>
          <target state="translated">바로 그 줄에서 &lt;u&gt;if 블록의 &quot;foo&quot;&lt;/u&gt; 는 어휘 환경에서 이미 생성되었지만 초기화 (문 자체의 일부 임)에 아직 도달하지 않았으며 아직 &lt;strong&gt;종료&lt;/strong&gt; 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="344dc469ad2fb516272004fea64179e2bc4964ae" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey&quot;&gt;SpiderMonkey&lt;/a&gt; JavaScript engine, this string would be &quot;&lt;code&gt;[object Object]&lt;/code&gt;&quot;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey&quot;&gt;의 SpiderMonkey&lt;/a&gt; 자바 스크립트 엔진이 문자열은 &quot;것 &lt;code&gt;[object Object]&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="2f01b7df0e94b2c5a699d1fecf9f8ddd43527537" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/reports/tr35/&quot;&gt;Unicode locale string spec&lt;/a&gt;, collation types are locale key &quot;extension subtags&quot;. These subtags add additional data about the locale, and are added to locale identifiers by using the &lt;code&gt;-u&lt;/code&gt; extension. Thus, the collation type can be added to the inital locale identifier string that is passed into the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; constructor. To add the collation type, first add the &lt;code&gt;-u&lt;/code&gt; extension to the string. Next, add the &lt;code&gt;-co&lt;/code&gt; extension to indicate that you are adding a collation type. Finally, add the collation to the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d189429b0f687a4f0e5ff4660d7b92375acaac" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/reports/tr35/&quot;&gt;Unicode locale string spec&lt;/a&gt;, the hour cycle is a locale string &quot;extension subtag&quot;. These subtags add additional data about the locale, and are added to locale identifiers by using the &lt;code&gt;-u&lt;/code&gt; extension key. Thus, the hour cycle type can be added to the inital locale identifier string that is passed into the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; constructor. To add the hour cycle type, first add the &lt;code&gt;-u&lt;/code&gt; extension key to the string. Next, add the &lt;code&gt;-hc&lt;/code&gt; extension key to indicate that you are adding an hour cycle. Finally, add the hour cycle type to the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ad45086ef7a69452ca7d46cab9920270569daf" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/reports/tr35/&quot;&gt;Unicode locale string spec&lt;/a&gt;, the values that &lt;code&gt;caseFirst&lt;/code&gt; represents correspond to the key &lt;code&gt;kf&lt;/code&gt;. &lt;code&gt;kf&lt;/code&gt; is treated as a locale string &quot;extension subtag&quot;. These subtags add additional data about the locale, and are added to locale identifiers by using the &lt;code&gt;-u&lt;/code&gt; extension key. Thus, the &lt;code&gt;caseFirst&lt;/code&gt; value can be added to the inital locale identifier string that is passed into the &lt;code&gt;Locale&lt;/code&gt; constructor. To add the &lt;code&gt;caseFirst&lt;/code&gt; value, first add the &lt;code&gt;-u&lt;/code&gt; extension key to the string. Next, add the &lt;code&gt;-kf&lt;/code&gt; extension key to indicate that you are adding a value for &lt;code&gt;caseFirst&lt;/code&gt;. Finally, add the &lt;code&gt;caseFirst&lt;/code&gt; value to the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28917499e1bb33c1d7b116bc6054d0eaaf2e651" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/reports/tr35/&quot;&gt;Unicode locale string spec&lt;/a&gt;, the values that &lt;code&gt;numberingSystem&lt;/code&gt; represents correspond to the key &lt;code&gt;nu&lt;/code&gt;. &lt;code&gt;nu&lt;/code&gt; is considered a locale string &quot;extension subtag&quot;. These subtags add additional data about the locale, and are added to locale identifiers by first adding the &lt;code&gt;-u&lt;/code&gt; key. To set the &lt;code&gt;numberingSystem&lt;/code&gt; value via the string argument to the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; constructor, first add the &lt;code&gt;-u&lt;/code&gt; extension key. Next, add the &lt;code&gt;-nu&lt;/code&gt; extension key to indicate that you are adding a value for &lt;code&gt;numberingSystem&lt;/code&gt;. Finally, add the &lt;code&gt;numberingSystem&lt;/code&gt; value to the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15ebc2cb79884d71926e58bf751c5b3a9b2f83c" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://www.unicode.org/reports/tr35/&quot;&gt;Unicode locale string spec&lt;/a&gt;, the values that &lt;code&gt;numeric&lt;/code&gt; represents correspond to the key &lt;code&gt;kn&lt;/code&gt;. &lt;code&gt;kn&lt;/code&gt; is considered a locale string &quot;extension subtag&quot;. These subtags add additional data about the locale, and are added to locale identifiers by using the &lt;code&gt;-u&lt;/code&gt; extension key. Thus, the &lt;code&gt;numeric&lt;/code&gt; value can be added to the inital locale identifier string that is passed into the &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; constructor. To set the &lt;code&gt;numeric&lt;/code&gt; value, first add the &lt;code&gt;-u&lt;/code&gt; extension key to the string. Next, add the &lt;code&gt;-kn&lt;/code&gt; extension key to indicate that you are adding a value for &lt;code&gt;numeric&lt;/code&gt;. Finally, add the &lt;code&gt;numeric&lt;/code&gt; value to the string. If you want to set &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, simply adding the &lt;code&gt;kn&lt;/code&gt; key will suffice. To set the value to &lt;code&gt;false&lt;/code&gt;, you must specify in by adding &quot;&lt;code&gt;false&lt;/code&gt;&quot; after the &lt;code&gt;kn&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc766e1776bb917de6591132669602b3df9697de" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;3d&lt;/code&gt; example, &lt;code&gt;'3d'&lt;/code&gt;&lt;em&gt;had &lt;/em&gt;to be quoted (because it begins with a digit). But it's also possible to quote the array indexes as well (e.g., &lt;code&gt;years['2']&lt;/code&gt; instead of &lt;code&gt;years[2]&lt;/code&gt;), although it's not necessary.</source>
          <target state="translated">에서 &lt;code&gt;3d&lt;/code&gt; 예를 들어, &lt;code&gt;'3d'&lt;/code&gt; &lt;em&gt;했다&lt;/em&gt; (이 숫자로 시작하기 때문에) 인용 될 수 있습니다. 하지만 필요하지는 않지만 배열 인덱스를 인용 할 수도 있습니다 (예 : &lt;code&gt;years['2']&lt;/code&gt; 대신 years [ '2' &lt;code&gt;years[2]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfb123889f9c99fb835bcc26628fcbd3f7f67f01" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;var&gt;object.property&lt;/var&gt;&lt;/code&gt; syntax, the &lt;code&gt;property&lt;/code&gt; must be a valid JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/identifier&quot;&gt;identifier&lt;/a&gt;. (In the ECMAScript standard, the names of properties are technically &quot;IdentifierNames&quot;, not &quot;Identifiers&quot;, so reserved words can be used but are not recommended). For example, &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.$1&lt;/code&gt; is valid, while &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.1&lt;/code&gt; is not.</source>
          <target state="translated">에서 &lt;code&gt;&lt;var&gt;object.property&lt;/var&gt;&lt;/code&gt; 의 구문의 &lt;code&gt;property&lt;/code&gt; 유효한 자바 스크립트해야합니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/identifier&quot;&gt;식별자&lt;/a&gt; . (ECMAScript 표준에서 속성 이름은 기술적으로 &quot;Identifiers&quot;가 아니라 &quot;IdentifierNames&quot;이므로 예약어를 사용할 수 있지만 권장되지는 않습니다. 예를 들어 &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.$1&lt;/code&gt; 은 유효하지만 &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.1&lt;/code&gt; 은 유효 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dc2a210be3838d3448081d22f4b72f5712e5f4a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;if&lt;/code&gt; statement, you want to use a comparison operator (&quot;==&quot;), and for the string concatenation, the plus (&quot;+&quot;) operator is needed.</source>
          <target state="translated">에서 &lt;code&gt;if&lt;/code&gt; 문, 당신은 ( &quot;==&quot;) 비교 연산자를 사용하려면, 그리고 문자열 연결, 더하기 ( &quot;+&quot;) 연산자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc49181d6c445c536525c61ec569330429a69827" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;object[property_name]&lt;/code&gt; syntax, the &lt;code&gt;&lt;var&gt;property_name&lt;/var&gt;&lt;/code&gt; is just a string or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Symbol&quot;&gt;Symbol&lt;/a&gt;. So, it can be any string, including &lt;code&gt;'1foo'&lt;/code&gt;, &lt;code&gt;'!bar!'&lt;/code&gt;, or even &lt;code&gt;' '&lt;/code&gt; (a space).</source>
          <target state="translated">에서 &lt;code&gt;object[property_name]&lt;/code&gt; 구문은 &lt;code&gt;&lt;var&gt;property_name&lt;/var&gt;&lt;/code&gt; 단순한 문자열이거나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Symbol&quot;&gt;기호&lt;/a&gt; . 따라서 &lt;code&gt;'1foo'&lt;/code&gt; , &lt;code&gt;'!bar!'&lt;/code&gt; 포함한 모든 문자열이 될 수 있습니다 . , 또는 &lt;code&gt;' '&lt;/code&gt; (공백).</target>
        </trans-unit>
        <trans-unit id="504e2effa4c01ce2afda7c35aaa16e32fcaa9400" translate="yes" xml:space="preserve">
          <source>In the JavaScript reference you can find the following chapters:</source>
          <target state="translated">JavaScript 참조에서 다음 장을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ebab3674334dea74506ab92354e81bf49a5348" translate="yes" xml:space="preserve">
          <source>In the above example, notice there is no &lt;code&gt;await&lt;/code&gt; statement after the &lt;code&gt;return&lt;/code&gt; keyword, although that would be valid too: The return value of an &lt;code&gt;async function&lt;/code&gt; is implicitly wrapped in &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;&lt;code&gt;Promise.resolve&lt;/code&gt;&lt;/a&gt; - if it's not already a promise itself (as in this example).</source>
          <target state="translated">위의 예 에서 &lt;code&gt;return&lt;/code&gt; 키워드 뒤에 &lt;code&gt;await&lt;/code&gt; 문 이 없다는 것을 알 수 있습니다.이 역시 유효합니다. &lt;code&gt;async function&lt;/code&gt; 의 반환 값은 &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt; &lt;code&gt;Promise.resolve&lt;/code&gt; 에&lt;/a&gt; 암시 적으로 래핑됩니다 -이미 약속 자체가 아닌 경우 (이 예에서와 같이) ).</target>
        </trans-unit>
        <trans-unit id="51b25d369879120965a73c97bd3bb3c4bc0dcba2" translate="yes" xml:space="preserve">
          <source>In the above example, the spread syntax does not work as one might expect: it spreads an &lt;em&gt;array&lt;/em&gt; of arguments into the object literal, due to the rest parameter.</source>
          <target state="translated">위의 예에서 스프레드 구문은 예상대로 작동하지 않습니다 . rest 매개 변수로 인해 인수 &lt;em&gt;배열&lt;/em&gt; 을 오브젝트 리터럴로 스프레드합니다 .</target>
        </trans-unit>
        <trans-unit id="639bc8814e61c3ad66222c2a753077d09d6095ed" translate="yes" xml:space="preserve">
          <source>In the above polyfill, no extra type-coercing is needed to make &lt;code&gt;(x &amp;gt; 0) or&amp;nbsp;(x &amp;lt; 0)&lt;/code&gt; numbers because subtracting them from each other forces a type conversion from boolean to numbers.</source>
          <target state="translated">위의 폴리 필에서 &lt;code&gt;(x &amp;gt; 0) or&amp;nbsp;(x &amp;lt; 0)&lt;/code&gt; 숫자를 빼기 위해 다른 유형의 강제 변환 이 필요하지 않습니다. 서로를 빼면 형식이 부울에서 숫자로 변환되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="97c92f0acdf5c43d4bf308a9791b1d873616af45" translate="yes" xml:space="preserve">
          <source>In the above polyfill, no extra type-coercing is needed to make &lt;code&gt;(x &amp;gt; 0)&lt;/code&gt; or &lt;code&gt;(x &amp;lt; 0)&lt;/code&gt; numbers because subtracting them from each other forces a type conversion from booleans to numbers.</source>
          <target state="translated">위의 폴리 필에서는 &lt;code&gt;(x &amp;gt; 0)&lt;/code&gt; 또는 &lt;code&gt;(x &amp;lt; 0)&lt;/code&gt; 숫자 를 만드는 데 추가 유형 강제가 필요하지 않습니다. 서로 빼면 부울에서 숫자로 유형 변환이 강제되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3320efd6ed4bd76923685057972479f17a63057a" translate="yes" xml:space="preserve">
          <source>In the above, the function (call it anonymous function A) assigned to &lt;code&gt;obj.bar&lt;/code&gt; returns another function (call it anonymous function B) that is created as an arrow function. As a result, function B's &lt;code&gt;this&lt;/code&gt; is permanently set to the &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;obj.bar&lt;/code&gt; (function A) when called. When the returned function (function B) is called, its &lt;code&gt;this&lt;/code&gt; will always be what it was set to initially. In the above code example, function B's &lt;code&gt;this&lt;/code&gt; is set to function A's &lt;code&gt;this&lt;/code&gt; which is &lt;code&gt;obj&lt;/code&gt;, so it remains set to &lt;code&gt;obj&lt;/code&gt; even when called in a manner that would normally set its &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or the global object (or any other method as in the previous example in the global execution context).</source>
          <target state="translated">위의 &lt;code&gt;obj.bar&lt;/code&gt; 에 할당 된 함수 (익명 함수 A라고 함)는 화살표 함수로 생성 된 다른 함수 (익명 함수 B라고 함)를 반환합니다. 그 결과, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 영구적으로 설정되고 &lt;code&gt;this&lt;/code&gt; 중 &lt;code&gt;obj.bar&lt;/code&gt; 호출하면 (함수 A). 반환 된 기능 (기능 B)가 호출되면, 그 &lt;code&gt;this&lt;/code&gt; 항상 처음에 설정 무슨 일 것이다. 위의 코드 예제에서 함수 B의 &lt;code&gt;this&lt;/code&gt; 는 함수 A의 &lt;code&gt;this&lt;/code&gt; 인 &lt;code&gt;obj&lt;/code&gt; 로 설정되어 있으므로 일반적으로 &lt;code&gt;this&lt;/code&gt; 를 &lt;code&gt;undefined&lt;/code&gt; 로 설정하는 방식으로 호출하더라도 &lt;code&gt;obj&lt;/code&gt; 로 설정된 상태로 유지됩니다. 또는 전역 개체 (또는 전역 실행 컨텍스트의 이전 예제에서와 같은 다른 메서드).</target>
        </trans-unit>
        <trans-unit id="62bdda2e0a21fb28a7f5675957c393b044577a67" translate="yes" xml:space="preserve">
          <source>In the above, the function(call it anonymous function A) assigned to &lt;code&gt;obj.bar&lt;/code&gt; returns another function(call it anonymous function B) that is created as an arrow function. As a result, function B's &lt;code&gt;this&lt;/code&gt; is permanently set to the &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;obj.bar&lt;/code&gt; (function A)when called. When the returned function(function B) is called, its &lt;code&gt;this&lt;/code&gt; will always be what it was set to initially. In the above code example, function B's &lt;code&gt;this&lt;/code&gt; is set to function A's &lt;code&gt;this&lt;/code&gt; which is obj, so it remains set to &lt;code&gt;obj&lt;/code&gt; even when called in a manner that would normally set its &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or the global object (or any other method as in the previous example in the global execution context).</source>
          <target state="translated">위에서 &lt;code&gt;obj.bar&lt;/code&gt; 에 할당 된 함수 (익명 함수 A라고 함)는 화살표 함수로 생성 된 다른 함수 (익명 함수 B라고 함)를 반환합니다. 그 결과, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 영구적으로 설정되고 &lt;code&gt;this&lt;/code&gt; 중 &lt;code&gt;obj.bar&lt;/code&gt; 호출하면 (함수 A). 반환 된 기능 (기능 B)가 호출되면, 그 &lt;code&gt;this&lt;/code&gt; 항상 처음에 설정 무슨 일 것이다. 상기 코드의 예에서, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 기능 (A)에 설정되어있어 &lt;code&gt;this&lt;/code&gt; 그것을 위해 설정된 남아 있도록 OBJ 인 &lt;code&gt;obj&lt;/code&gt; 와 심지어 보통 그 설정하는 방식으로 호출 할 때 &lt;code&gt;this&lt;/code&gt; 로 &lt;code&gt;undefined&lt;/code&gt; 또는 전역 객체 (또는 전역 실행 컨텍스트의 이전 예와 같은 다른 방법).</target>
        </trans-unit>
        <trans-unit id="42d2f894ef11d503ede81ebcedd96f07d7f0fab6" translate="yes" xml:space="preserve">
          <source>In the case of recursion, i.e. if function &lt;code&gt;f&lt;/code&gt; appears several times on the call stack, the value of &lt;code&gt;f.arguments&lt;/code&gt; represents the arguments corresponding to the most recent invocation of the function.</source>
          <target state="translated">재귀의 경우, 즉 함수 &lt;code&gt;f&lt;/code&gt; 가 호출 스택에 여러 번 나타나는 경우 &lt;code&gt;f.arguments&lt;/code&gt; 값은 함수의 가장 최근 호출에 해당하는 인수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="661fd464b4a2050134037311daed90c57e20fd0a" translate="yes" xml:space="preserve">
          <source>In the current ECMAScript specification, &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal, although this was not so in earlier drafts. See &lt;em&gt;&quot;Value equality for -0 and 0&quot;&lt;/em&gt; in the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; table for details.</source>
          <target state="translated">현재 ECMAScript 사양에서 &lt;code&gt;-0&lt;/code&gt; 과 &lt;code&gt;+0&lt;/code&gt; 은 동일한 것으로 간주되지만 이전 초안에서는 그렇지 않습니다. 자세한 내용 은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 표 에서 &lt;em&gt;&quot;-0 및 0의 값 같음&quot;&lt;/em&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de188306b04f104700fac924cdd1e9567febef02" translate="yes" xml:space="preserve">
          <source>In the example above the exception will be shown since constructor links to Parent.</source>
          <target state="translated">위 예제에서는 생성자가 Parent에 연결되어 있으므로 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acef3bf46acb0ba10cb256e32b5f0d0bb458c455" translate="yes" xml:space="preserve">
          <source>In the example above the exception will be shown since the constructor links to Parent.</source>
          <target state="translated">위의 예에서는 생성자가 Parent에 링크하기 때문에 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad8390434acf6607f1bb47c24b30e5f18f5b3f46" translate="yes" xml:space="preserve">
          <source>In the example below, we invoke the &lt;code&gt;display&lt;/code&gt; function without passing the first argument. If the first argument is not passed, the value of &lt;code&gt;this&lt;/code&gt; is bound to the global object.</source>
          <target state="translated">아래 예제 에서 첫 번째 인수를 전달하지 않고 &lt;code&gt;display&lt;/code&gt; 함수를 호출합니다 . 첫 번째 인수가 전달되지 않으면 &lt;code&gt;this&lt;/code&gt; 값 이 전역 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4da435fcb2e56dfca1fdbb66425c53d9f93888" translate="yes" xml:space="preserve">
          <source>In the example below, when we call &lt;code&gt;greet&lt;/code&gt;, the value of &lt;code&gt;this&lt;/code&gt; will be bound to object &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;greet&lt;/code&gt; 을 호출하면 &lt;code&gt;this&lt;/code&gt; 의 값 이 &lt;code&gt;obj&lt;/code&gt; 객체에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="c878dda71bd4d57212f4760d1a5d6612fffe1a77" translate="yes" xml:space="preserve">
          <source>In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was 0. &lt;code&gt;null&lt;/code&gt; was represented as the NULL pointer (0x00 in most platforms). Consequently, null had 0 as type tag, hence the bogus &lt;code&gt;typeof&lt;/code&gt; return value. (&lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;reference&lt;/a&gt;)</source>
          <target state="translated">JavaScript의 첫 번째 구현에서 JavaScript 값은 유형 태그와 값으로 표시되었습니다. 객체의 유형 태그는 0입니다. &lt;code&gt;null&lt;/code&gt; 은 NULL 포인터 (대부분의 플랫폼에서 0x00)로 표시되었습니다. 따라서, 널 타입 태그, 따라서 위조 0 있었다 &lt;code&gt;typeof&lt;/code&gt; 리턴 값. ( &lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;참고&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="857eee85d465027bf36c77ed510b6ca131138764" translate="yes" xml:space="preserve">
          <source>In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;null&lt;/code&gt; was represented as the NULL pointer (&lt;code&gt;0x00&lt;/code&gt; in most platforms). Consequently, &lt;code&gt;null&lt;/code&gt; had &lt;code&gt;0&lt;/code&gt; as type tag, hence the &lt;code&gt;&quot;object&quot;&lt;/code&gt;&lt;code&gt;typeof&lt;/code&gt; return value. (&lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;reference&lt;/a&gt;)</source>
          <target state="translated">JavaScript의 첫 번째 구현에서 JavaScript 값은 유형 태그와 값으로 표시되었습니다. 객체의 유형 태그는 &lt;code&gt;0&lt;/code&gt; 입니다. &lt;code&gt;null&lt;/code&gt; 은 NULL 포인터 ( 대부분의 플랫폼에서 &lt;code&gt;0x00&lt;/code&gt; )로 표시되었습니다. 결과적으로 &lt;code&gt;null&lt;/code&gt; 은 유형 태그로 &lt;code&gt;0&lt;/code&gt; 이 있으므로 &lt;code&gt;&quot;object&quot;&lt;/code&gt; &lt;code&gt;typeof&lt;/code&gt; 반환 값이됩니다. ( &lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c4c1b2e168bd2c3f0960e008564fab4afcfb0149" translate="yes" xml:space="preserve">
          <source>In the following code, &lt;code&gt;flag.toString()&lt;/code&gt; returns &quot;&lt;code&gt;true&lt;/code&gt;&quot;:</source>
          <target state="translated">다음 코드에서 &lt;code&gt;flag.toString()&lt;/code&gt; 은 &quot; &lt;code&gt;true&lt;/code&gt; &quot;를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="326dc4a22d6e5d66e05e913ed076ab8871545c67" translate="yes" xml:space="preserve">
          <source>In the following code, both of the statements containing &lt;code&gt;eval()&lt;/code&gt; return 42. The first evaluates the string &quot;&lt;code&gt;x + y + 1&lt;/code&gt;&quot;; the second evaluates the string &quot;&lt;code&gt;42&lt;/code&gt;&quot;.</source>
          <target state="translated">다음 코드에서 &lt;code&gt;eval()&lt;/code&gt; 포함하는 두 명령문은 모두 42를 리턴합니다. 첫 번째는 문자열 &quot; &lt;code&gt;x + y + 1&lt;/code&gt; &quot;을 평가합니다 . 두 번째는 문자열 &quot; &lt;code&gt;42&lt;/code&gt; &quot;를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="7227f231dba8b388ff90697deb637f835c642754" translate="yes" xml:space="preserve">
          <source>In the following example we will create a global &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; method called &lt;code&gt;construct&lt;/code&gt;, which will enable you to use an array-like object with a constructor instead of an arguments list.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;construct&lt;/code&gt; 라는 전역 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; 메서드를 생성 하여 인수 목록 대신 생성자와 함께 배열과 같은 객체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccaa53cc09c2b150a701f3de632d7c64e3076c6" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;match()&lt;/code&gt; is used to find '&lt;code&gt;Chapter&lt;/code&gt;' followed by 1 or more numeric characters followed by a decimal point and numeric character 0 or more times.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;match()&lt;/code&gt; 를 사용하여 ' &lt;code&gt;Chapter&lt;/code&gt; '뒤에 1 개 이상의 숫자와 소수점, 숫자 0 개 이상을 차례로 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="551908074dab38737ca378f22dc2a0152b483db4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;match()&lt;/code&gt; is used to find &lt;code&gt;'Chapter'&lt;/code&gt; followed by 1 or more numeric characters followed by a decimal point and numeric character 0 or more times. The regular expression includes the &lt;code&gt;i&lt;/code&gt; flag so that upper/lower case differences will be ignored.</source>
          <target state="translated">다음 예에서 &lt;code&gt;match()&lt;/code&gt; 는 &lt;code&gt;'Chapter'&lt;/code&gt; 다음에 1 개 이상의 숫자와 소수점 및 0 개 이상의 숫자 를 찾는 데 사용됩니다 . 정규식에는 &lt;code&gt;i&lt;/code&gt; 플래그가 포함되므로 대 / 소문자의 차이는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1da1e1b8bfab54b105a4ada0152c93b74660c6" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;slice&lt;/code&gt; creates a new array, &lt;code&gt;newCar&lt;/code&gt;, from &lt;code&gt;myCar&lt;/code&gt;. Both include a reference to the object &lt;code&gt;myHonda&lt;/code&gt;. When the color of &lt;code&gt;myHonda&lt;/code&gt; is changed to purple, both arrays reflect the change.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;slice&lt;/code&gt; 는 &lt;code&gt;myCar&lt;/code&gt; 에서 새 배열 &lt;code&gt;newCar&lt;/code&gt; 를 만듭니다 . 둘 다 &lt;code&gt;myHonda&lt;/code&gt; 객체에 대한 참조를 포함합니다 . &lt;code&gt;myHonda&lt;/code&gt; 의 색상이 자주색 으로 변경되면 두 배열 모두 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="b027578ad80c9e8c2b2c3dd35b71ae535a33dd33" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for 0 or more spaces followed by a semicolon followed by 0 or more spaces and, when found, removes the spaces and the semicolon from the string. &lt;code&gt;nameList&lt;/code&gt; is the array returned as a result of &lt;code&gt;split()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 0 개 이상의 공백과 세미콜론, 0 개 이상의 공백을 찾은 후 문자열에서 공백과 세미콜론을 제거합니다. &lt;code&gt;nameList&lt;/code&gt; 는 &lt;code&gt;split()&lt;/code&gt; 의 결과로 반환 된 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="5c2e6d8d45fd169d7a77ecae81e085840f806133" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for spaces in a string and returns the first 3 splits that it finds.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 문자열에서 공백을 찾고 찾은 처음 3 개의 분할을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2489eb3658fe2037e9cdda5effddf0b3a84f250d" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for zero or more spaces, followed by a semicolon, followed by zero or more spaces&amp;mdash;and, when found, removes the spaces and the semicolon from the string. &lt;code&gt;nameList&lt;/code&gt; is the array returned as a result of &lt;code&gt;split()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 0 개 이상의 공백, 뒤에 세미콜론, 0 개 이상의 공백을 찾습니다. 찾은 경우 문자열에서 공백과 세미콜론을 제거합니다. &lt;code&gt;nameList&lt;/code&gt; 는 &lt;code&gt;split()&lt;/code&gt; 의 결과로 반환되는 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="ccb536da7c5287e832a975ca6e887bf6be2e7026" translate="yes" xml:space="preserve">
          <source>In the following example, a statement labeled &lt;code&gt;checkiandj&lt;/code&gt; contains a statement labeled &lt;code&gt;checkj&lt;/code&gt;. If &lt;code&gt;continue&lt;/code&gt; is encountered, the program continues at the top of the &lt;code&gt;checkj&lt;/code&gt; statement. Each time &lt;code&gt;continue&lt;/code&gt; is encountered, &lt;code&gt;checkj&lt;/code&gt; reiterates until its condition returns false. When false is returned, the remainder of the &lt;code&gt;checkiandj&lt;/code&gt; statement is completed.</source>
          <target state="translated">다음 예에서 표시된 문 &lt;code&gt;checkiandj&lt;/code&gt; 은 성명 표시가 포함되어 &lt;code&gt;checkj&lt;/code&gt; 을 . 경우 &lt;code&gt;continue&lt;/code&gt; 발생, 프로그램은 상단에 계속 &lt;code&gt;checkj&lt;/code&gt; 의 문. 때마다 &lt;code&gt;continue&lt;/code&gt; , 발생 &lt;code&gt;checkj&lt;/code&gt; 의 의 상태를 반환 거짓 때까지 되풀이한다. false가 리턴되면 &lt;code&gt;checkiandj&lt;/code&gt; 문의 나머지 가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="0b489dc35a2ac4c8c478d127272578dceb8f8cdb" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &quot;Bananas&quot;, the program matches the value with case &quot;Bananas&quot; and executes the associated statement. When &lt;code&gt;break&lt;/code&gt; is encountered, the program breaks out of &lt;code&gt;switch&lt;/code&gt; and executes the statement following &lt;code&gt;switch&lt;/code&gt;. If &lt;code&gt;break&lt;/code&gt; were omitted, the statement for case &quot;Cherries&quot; would also be executed.</source>
          <target state="translated">다음 예에서 &lt;code&gt;expr&lt;/code&gt; 이 &quot;Bananas&quot;로 평가되면 프로그램은 값을 대소 문자 &quot;Bananas&quot;와 일치시키고 연관된 명령문을 실행합니다. 때 &lt;code&gt;break&lt;/code&gt; 중, 프로그램 나누기 발생 &lt;code&gt;switch&lt;/code&gt; 하고 다음 문 실행 &lt;code&gt;switch&lt;/code&gt; . 경우 &lt;code&gt;break&lt;/code&gt; 생략 된, 경우 &quot;체리&quot;에 대한 문은 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="96f6335874bf336b7e951fdce7655cff74fd7933" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &quot;Oranges&quot; or &quot;Apples&quot;, the program matches the values with either the case &quot;Oranges&quot; or &quot;Apples&quot; and executes the corresponding statement. The &lt;code&gt;default&lt;/code&gt; keyword will help in any other case and executes the associated statement.</source>
          <target state="translated">다음 예에서 &lt;code&gt;expr&lt;/code&gt; 이 &quot;Oranges&quot;또는 &quot;Apples&quot;로 평가되면 프로그램은 값을 &quot;Oranges&quot;또는 &quot;Apples&quot;와 일치시키고 해당 명령문을 실행합니다. &lt;code&gt;default&lt;/code&gt; 키워드는 다른 경우에 도움이 및 관련 문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8237fe8e3542597e9f1b9aab949f95c7735fe5b9" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &lt;code&gt;Bananas&lt;/code&gt;, the program matches the value with case &lt;code&gt;case 'Bananas'&lt;/code&gt; and executes the associated statement. When &lt;code&gt;break&lt;/code&gt; is encountered, the program breaks out of &lt;code&gt;switch&lt;/code&gt; and executes the statement following &lt;code&gt;switch&lt;/code&gt;. If &lt;code&gt;break&lt;/code&gt; were omitted, the statement for the &lt;code&gt;case 'Cherries'&lt;/code&gt; would also be executed.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;expr&lt;/code&gt; 이 &lt;code&gt;Bananas&lt;/code&gt; 로 평가 되면 프로그램은 case &lt;code&gt;case 'Bananas'&lt;/code&gt; 가 있는 값을 일치 시키고 연관된 명령문을 실행합니다. 때 &lt;code&gt;break&lt;/code&gt; 중, 프로그램 나누기 발생 &lt;code&gt;switch&lt;/code&gt; 하고 다음 문 실행 &lt;code&gt;switch&lt;/code&gt; . 경우 &lt;code&gt;break&lt;/code&gt; 생략 된의의 문 &lt;code&gt;case 'Cherries'&lt;/code&gt; 또한 실행된다.</target>
        </trans-unit>
        <trans-unit id="6f90002f54cb6c6ac4fe50fef20e7a2668d7f3de" translate="yes" xml:space="preserve">
          <source>In the following example, if no value is provided for &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; when &lt;code&gt;multiply&lt;/code&gt; is called, &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt;'s value would be &lt;code&gt;undefined&lt;/code&gt; when evaluating &lt;code&gt;&lt;var&gt;a&lt;/var&gt; * &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; would return &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;multiply&lt;/code&gt; 가 호출 될 때 &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; 에 대한 값이 제공되지 않으면 &lt;code&gt;&lt;var&gt;a&lt;/var&gt; * &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; * &lt;var&gt;b&lt;/var&gt; 를 평가할 때 &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; 의 값이 &lt;code&gt;undefined&lt;/code&gt; 않고 &lt;code&gt;multiply&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="16ddded5321b57a0d866951feace6e4cea99bc3c" translate="yes" xml:space="preserve">
          <source>In the following example, if no value is provided for &lt;code&gt;b&lt;/code&gt; when &lt;code&gt;multiply&lt;/code&gt; is called, &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s value would be &lt;code&gt;undefined&lt;/code&gt; when evaluating &lt;code&gt;a * b&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; would return &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;multiply&lt;/code&gt; 가 호출 될 때 &lt;code&gt;b&lt;/code&gt; 에 값이 제공되지 않으면 &lt;code&gt;a * b&lt;/code&gt; 평가할 때 &lt;code&gt;b&lt;/code&gt; 값이 &lt;code&gt;undefined&lt;/code&gt; 않고 &lt;code&gt;multiply&lt;/code&gt; &lt;code&gt;NaN&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="9742f1b1d9915daea9f896ab1adc27f1b391e232" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;do...while&lt;/code&gt; loop iterates at least once and reiterates until &lt;code&gt;i&lt;/code&gt; is no longer less than 5.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;do...while&lt;/code&gt; 루프는 적어도 한 번 반복하고 &lt;code&gt;i&lt;/code&gt; 가 5보다 작을 때까지 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="290da318e59120487518c92d769cd84cc341a64b" translate="yes" xml:space="preserve">
          <source>In the following example, the array &lt;code&gt;numbers&lt;/code&gt; is iterated through by looking at the &lt;code&gt;length&lt;/code&gt; property. The value in each element is then doubled.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;length&lt;/code&gt; 속성을 확인 하여 배열 &lt;code&gt;numbers&lt;/code&gt; 를 반복 합니다. 그런 다음 각 요소의 값이 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="3e970986a7e8da7faf5f169eb8ef1a860c621631" translate="yes" xml:space="preserve">
          <source>In the following example, the constructor for the &lt;code&gt;Product&lt;/code&gt; object is defined with two parameters: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;price&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;Product&lt;/code&gt; 개체 의 생성자 는 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;price&lt;/code&gt; 의 두 매개 변수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c716507b55f4e7d36a7bf5bbf5705d645b4cfbd" translate="yes" xml:space="preserve">
          <source>In the following example, the object has a getter as its own property. On getting the property, the property is removed from the object and re-added, but implicitly as a data property this time. Finally the value gets returned.</source>
          <target state="translated">다음 예제에서 객체에는 자체 속성으로 getter가 있습니다. 속성을 가져 오면 속성이 개체에서 제거되고 다시 추가되지만 이번에는 데이터 속성으로 암시 적으로 지정됩니다. 마지막으로 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="948e31f9a2ae361570277883f29ebf342acf68b5" translate="yes" xml:space="preserve">
          <source>In the following example, the object has a getter as its own property. On getting the property, the property is removed from the object and re-added, but implicitly as a data property this time. Finally, the value gets returned.</source>
          <target state="translated">다음 예제에서 객체에는 자체 속성으로 getter가 있습니다. 속성을 가져 오면 속성이 개체에서 제거되고 다시 추가되지만 이번에는 암시 적으로 데이터 속성으로 추가됩니다. 마지막으로 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63491fcad57234202d5746abce8c2f912c702dac" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression is defined in &lt;code&gt;replace()&lt;/code&gt; and includes the ignore case flag.</source>
          <target state="translated">다음 예제에서 정규식은 &lt;code&gt;replace()&lt;/code&gt; 정의되며 대소 문자 무시 플래그를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e10c0f043f02b2123d978ede8da98693e4584598" translate="yes" xml:space="preserve">
          <source>In the following example, the usage is probably not intentional:</source>
          <target state="translated">다음 예에서 사용은 의도적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3a594f9a72b0094faccc4763da19747b8d1679" translate="yes" xml:space="preserve">
          <source>In the following example, the variable &lt;code&gt;bigNumber&lt;/code&gt; is assigned a value that is larger than the maximum value. When the &lt;a href=&quot;../../statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; statement executes, &lt;code&gt;bigNumber&lt;/code&gt; has the value &lt;code&gt;Infinity&lt;/code&gt;, so &lt;code&gt;bigNumber&lt;/code&gt; is set to a more manageable value before continuing.</source>
          <target state="translated">다음 예에서 변수 &lt;code&gt;bigNumber&lt;/code&gt; 에는 최대 값보다 큰 값이 지정됩니다. &lt;a href=&quot;../../statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 문이 실행될 때 &lt;code&gt;bigNumber&lt;/code&gt; 의 값은 &lt;code&gt;Infinity&lt;/code&gt; 이므로 계속하기 전에 &lt;code&gt;bigNumber&lt;/code&gt; 가 관리하기 쉬운 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0d991c308ff8ad2345c76fb15afab7a3798cf66" translate="yes" xml:space="preserve">
          <source>In the following example, the variable &lt;code&gt;smallNumber&lt;/code&gt; is assigned a value that is smaller than the minimum value. When the &lt;a href=&quot;../../statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; statement executes, &lt;code&gt;smallNumber&lt;/code&gt; has the value &lt;code&gt;-Infinity&lt;/code&gt;, so &lt;code&gt;smallNumber&lt;/code&gt; is set to a more manageable value before continuing.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;smallNumber&lt;/code&gt; 변수 에는 최소값보다 작은 값이 할당됩니다. &lt;a href=&quot;../../statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 문이 실행될 때 &lt;code&gt;smallNumber&lt;/code&gt; 의 값은 &lt;code&gt;-Infinity&lt;/code&gt; 이므로 &lt;code&gt;smallNumber&lt;/code&gt; 는 계속하기 전에 관리하기 쉬운 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bdf3814229a99d3d55903e9dbbccafa691e79d" translate="yes" xml:space="preserve">
          <source>In the following example, we delete an own property of an object while a property with the same name is available on the prototype chain:</source>
          <target state="translated">다음 예에서는 이름이 같은 속성을 프로토 타입 체인에서 사용할 수있는 동안 객체의 고유 속성을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d1688dd1bc4311871facdb22d215ac29f4cfd269" translate="yes" xml:space="preserve">
          <source>In the following example, we first define a class named &lt;code&gt;Polygon&lt;/code&gt;, then extend it to create a class named &lt;code&gt;Square&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 먼저 &lt;code&gt;Polygon&lt;/code&gt; 이라는 클래스를 정의한 다음이를 확장하여 &lt;code&gt;Square&lt;/code&gt; 라는 클래스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3915fb85a203c34c4701029950bb8a9c14f92f1b" translate="yes" xml:space="preserve">
          <source>In the following example, we first define a class named Polygon, then extend it to create a class named Square. Note that super(), used in the constructor, can only be used in constructors and must be called before the &lt;code&gt;this&lt;/code&gt; keyword can be used.</source>
          <target state="translated">다음 예제에서는 먼저 Polygon이라는 클래스를 정의한 다음 확장하여 Square라는 클래스를 만듭니다. 생성자에서 사용되는 super ()는 생성자에서만 사용할 수 있으며 &lt;code&gt;this&lt;/code&gt; 키워드를 사용 하기 전에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="382dd03774580bb2f9d04acd67e5dab59c412528" translate="yes" xml:space="preserve">
          <source>In the following example, we successively await two promises. Progress moves through function &lt;code&gt;foo&lt;/code&gt; in three stages.</source>
          <target state="translated">다음 예에서는 두 가지 약속을 연속적으로 기다립니다. 진행률은 함수 &lt;code&gt;foo&lt;/code&gt; 를 통해 3 단계로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0ec0333973c02fd58485ca1aa0e462c7548eff95" translate="yes" xml:space="preserve">
          <source>In the following example, when &lt;code&gt;o.f()&lt;/code&gt; is invoked, inside the function &lt;code&gt;this&lt;/code&gt; is bound to the &lt;code&gt;o&lt;/code&gt; object.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;o.f()&lt;/code&gt; 가 호출되면 함수 내에서 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;o&lt;/code&gt; 오브젝트에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="04bcd5d96a4ccd8139ff398132b2d5a23f10fbfa" translate="yes" xml:space="preserve">
          <source>In the following piece of code, &lt;code&gt;slice()&lt;/code&gt; is a bound function to the &lt;a href=&quot;apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function.prototype&lt;/code&gt;&lt;/a&gt;, with the &lt;code&gt;this&lt;/code&gt; value set to the &lt;a href=&quot;../array/slice&quot;&gt;&lt;code&gt;slice()&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt;. This means that additional &lt;code&gt;apply()&lt;/code&gt; calls can be eliminated:</source>
          <target state="translated">코드의 다음 부분에서, &lt;code&gt;slice()&lt;/code&gt; 받는 바운드 함수 &lt;a href=&quot;apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 의 함수 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function.prototype&lt;/code&gt; &lt;/a&gt; 와, &lt;code&gt;this&lt;/code&gt; 받는 값 세트 &lt;a href=&quot;../array/slice&quot;&gt; &lt;code&gt;slice()&lt;/code&gt; &lt;/a&gt; 의 함수 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로&lt;/a&gt; . 이는 추가 &lt;code&gt;apply()&lt;/code&gt; 호출을 제거 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="910701d472ecd5b702fc4b46aec86e952f4bac39" translate="yes" xml:space="preserve">
          <source>In the former instance, JS seems to find an empty string just after the specified index value. In the latter instance, JS seems to be finding an empty string at the end of the searched string.</source>
          <target state="translated">전자의 경우 JS는 지정된 인덱스 값 바로 뒤에 빈 문자열을 찾는 것 같습니다. 후자의 경우 JS는 검색된 문자열의 끝에서 빈 문자열을 찾는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e95ef1758d9879398c7d717728553d776121d64a" translate="yes" xml:space="preserve">
          <source>In the function signature for &lt;code&gt;drawChart&lt;/code&gt; above, the destructured left-hand side is assigned to an empty object literal on the right-hand side: &lt;code&gt;{size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt;. You could have also written the function without the right-hand side assignment. However, if you leave out the right-hand side assignment, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can simply call &lt;code&gt;&lt;strong&gt;drawChart()&lt;/strong&gt;&lt;/code&gt; without supplying any parameters. The current design is useful if you want to be able to call the function without supplying any parameters, the other can be useful when you want to ensure an object is passed to the function.</source>
          <target state="translated">위의 &lt;code&gt;drawChart&lt;/code&gt; 에 대한 함수 시그니처에서 구조화 해제 된 왼쪽은 오른쪽의 빈 개체 리터럴에 할당됩니다. &lt;code&gt;{size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt; . 오른쪽 할당없이 함수를 작성할 수도 있습니다. 그러나 오른쪽 할당을 생략하면 함수가 호출 될 때 제공 할 인수를 하나 이상 찾는 반면 현재 형식에서는 매개 변수를 제공하지 않고 간단히 &lt;code&gt;&lt;strong&gt;drawChart()&lt;/strong&gt;&lt;/code&gt; 를 호출 할 수 있습니다 . 현재 디자인은 매개 변수를 제공하지 않고 함수를 호출하려는 경우 유용하고 다른 하나는 객체가 함수에 전달되는지 확인하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320ac0eafa6debb7dcd8b9758ef8cfe6b6f8db61" translate="yes" xml:space="preserve">
          <source>In the function signature for &lt;code&gt;drawES2015Chart&lt;/code&gt; above, the destructured left-hand side is assigned to an empty object literal on the right-hand side: &lt;code&gt;{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt;. You could have also written the function without the right-hand side assignment. However, if you leave out the right-hand side assignment, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can simply call &lt;code&gt;&lt;strong&gt;drawES2015Chart()&lt;/strong&gt;&lt;/code&gt; without supplying any parameters. The current design is useful if you want to be able to call the function without supplying any parameters, the other can be useful when you want to ensure an object is passed to the function.</source>
          <target state="translated">위의 &lt;code&gt;drawES2015Chart&lt;/code&gt; 에 대한 함수 시그니처에서, 비 구조화 된 왼쪽은 오른쪽의 빈 객체 리터럴에 할당됩니다 : &lt;code&gt;{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt; . 오른쪽 할당없이 함수를 작성할 수도 있습니다. 그러나 오른쪽 할당을 생략하면 함수는 호출 될 때 제공 할 인수를 하나 이상 찾습니다. 현재 형식에서는 매개 변수를 제공하지 않고 &lt;code&gt;&lt;strong&gt;drawES2015Chart()&lt;/strong&gt;&lt;/code&gt; 를 호출 할 수 있습니다 . 현재 디자인은 매개 변수를 제공하지 않고 함수를 호출 할 수있는 경우에 유용하며, 다른 하나는 객체가 함수에 전달되도록 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384cd9fe2f63891e05c6315f490a0fe09b2696a0" translate="yes" xml:space="preserve">
          <source>In the global context, a variable declared using &lt;code&gt;var&lt;/code&gt; is added as a non-configurable property of the global object. This means its property descriptor cannot be changed and it cannot be deleted using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;. The corresponding name is also added to a list on the internal &lt;code&gt;[[VarNames]]&lt;/code&gt; slot on the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-global-environment-records&quot;&gt;global environment record&lt;/a&gt; (which forms part of the global lexical environment). The list of names in &lt;code&gt;[[VarNames]]&lt;/code&gt; enables the runtime to distinguish between global variables and straightforward properties on the global object.</source>
          <target state="translated">전역 컨텍스트에서 &lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 변수는 전역 개체의 구성 할 수없는 속성으로 추가됩니다. 이는 속성 설명자를 변경할 수 없으며 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; 를&lt;/a&gt; 사용하여 삭제할 수 없음을 의미합니다 . 해당 이름은 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-global-environment-records&quot;&gt;전역 환경 레코드&lt;/a&gt; (전역 어휘 환경의 일부를 형성) 의 내부 &lt;code&gt;[[VarNames]]&lt;/code&gt; 슬롯에 있는 목록에도 추가됩니다 . &lt;code&gt;[[VarNames]]&lt;/code&gt; 의 이름 목록을 사용하면 런타임에서 전역 변수와 전역 개체의 간단한 속성을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec2ed1a49c59897eb318170d9b6bd3065461b6d" translate="yes" xml:space="preserve">
          <source>In the global execution context (outside of any function), &lt;code&gt;this&lt;/code&gt; refers to the global object whether in strict mode or not.</source>
          <target state="translated">전역 실행 컨텍스트 (함수 외부)에서 &lt;code&gt;this&lt;/code&gt; 엄격 모드에 있든 없든 전역 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4323cb3e94dbb71c6dea4adf5e31307a360729a9" translate="yes" xml:space="preserve">
          <source>In the last example (&lt;code&gt;C2&lt;/code&gt;), because an object was returned during construction, the new object that &lt;code&gt;this&lt;/code&gt; was bound to simply gets discarded. (This essentially makes the statement &quot;&lt;code&gt;this.a = 37;&lt;/code&gt;&quot; dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)</source>
          <target state="translated">마지막 예 (에서는 &lt;code&gt;C2&lt;/code&gt; 개체 생성 중에 되돌려 때문에), 그 새로운 오브젝트 &lt;code&gt;this&lt;/code&gt; 묶여 단순히 폐기 도착한다. (이것은 본질적으로 &quot; &lt;code&gt;this.a = 37;&lt;/code&gt; &quot;죽은 코드입니다. 실행되기 때문에 정확히 죽지는 않았지만 외부 효과없이 제거 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="00e90f9a8f3cbcb6e3ee4661127d9871d59bd623" translate="yes" xml:space="preserve">
          <source>In the module, we could use the following code:</source>
          <target state="translated">모듈에서 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a9e58aa43466c9b9026972ff36cb4dd102c297" translate="yes" xml:space="preserve">
          <source>In the next example, a rest parameter is used to collect all arguments after the first one in an array. Each one of them is then multiplied by the first parameter and the array is returned:</source>
          <target state="translated">다음 예제에서 rest 매개 변수는 배열에서 첫 번째 인수 이후의 모든 인수를 수집하는 데 사용됩니다. 그런 다음 각 매개 변수에 첫 번째 매개 변수를 곱하면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d0de29c2467a1bcda0bcf6cead5586e0aa1d34" translate="yes" xml:space="preserve">
          <source>In the next example, a rest parameter is used to collect all parameters after the first into an array. Each one of them is then multiplied by the first parameter, and the array is returned:</source>
          <target state="translated">다음 예에서 나머지 매개 변수는 첫 번째 매개 변수 이후의 모든 매개 변수를 배열로 수집하는 데 사용됩니다. 그런 다음 각각에 첫 번째 매개 변수를 곱하고 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb91bb9b2b1254cf0c448c27969519e3a92034" translate="yes" xml:space="preserve">
          <source>In the next example, an &lt;a href=&quot;if...else&quot;&gt;&lt;code&gt;if...else&lt;/code&gt;&lt;/a&gt; statement without curly braces (&lt;code&gt;{}&lt;/code&gt;) is used.</source>
          <target state="translated">다음 예에서는 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )가 없는 &lt;a href=&quot;if...else&quot;&gt; &lt;code&gt;if...else&lt;/code&gt; &lt;/a&gt; 문 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e204d4b72625c73764da0600a44e35ab5711b4a" translate="yes" xml:space="preserve">
          <source>In the past, the general strategy for setting defaults was to test parameter values in the function body and assign a value if they are &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">과거에는 기본값을 설정하는 일반적인 전략이 함수 본문에서 매개 변수 값을 테스트하고 &lt;code&gt;undefined&lt;/code&gt; 경우 값을 지정하는 것이 었습니다 .</target>
        </trans-unit>
        <trans-unit id="118743fe11f8aa51b1246d6b929e4cf6c2a3a3c4" translate="yes" xml:space="preserve">
          <source>In the replacement text, the script uses &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; to indicate the results of the corresponding matching parentheses in the regular expression pattern.</source>
          <target state="translated">대체 텍스트에서 스크립트는 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 를 사용하여 정규식 패턴에서 일치하는 괄호의 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="18901524c393bd6c9d4140d7173cf206ad8f759d" translate="yes" xml:space="preserve">
          <source>In the same line, the &lt;code&gt;if&lt;/code&gt; block's &lt;code&gt;foo&lt;/code&gt; has already been created in the lexical environment, but has not yet reached (and terminated) its initialization (which is part of the statement itself).</source>
          <target state="translated">같은 줄에서 &lt;code&gt;if&lt;/code&gt; 블록의 &lt;code&gt;foo&lt;/code&gt; 는 어휘 환경에서 이미 생성되었지만 아직 초기화 (문 자체의 일부)에 도달 (및 종료)되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6f67384bff317df6dc3f3c5721272dbec196a342" translate="yes" xml:space="preserve">
          <source>In the second call in this example, even if the first argument is set explicitly to &lt;code&gt;undefined&lt;/code&gt; (though not &lt;code&gt;null&lt;/code&gt; or other &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;falsy&lt;/a&gt; values), the value of the &lt;code&gt;&lt;var&gt;num&lt;/var&gt;&lt;/code&gt; argument is still the default.</source>
          <target state="translated">이 예제의 두 번째 호출에서 첫 번째 인수가 명시 적으로 &lt;code&gt;undefined&lt;/code&gt; ( &lt;code&gt;null&lt;/code&gt; 또는 다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;잘못된&lt;/a&gt; 값은 아님)로 설정되어 있어도 &lt;code&gt;&lt;var&gt;num&lt;/var&gt;&lt;/code&gt; 인수 의 값 은 여전히 ​​기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c8b8cef8365495d74b0b650d8145880b109b506c" translate="yes" xml:space="preserve">
          <source>In the second call in this example, even if the first argument is set explicitly to &lt;code&gt;undefined&lt;/code&gt; (though not &lt;code&gt;null&lt;/code&gt; or other &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;falsy&lt;/a&gt; values&lt;/em&gt;), the value of the &lt;code&gt;num&lt;/code&gt; argument is still the default.</source>
          <target state="translated">이 예제의 두 번째 호출에서 첫 번째 인수가 명시 적으로 &lt;code&gt;undefined&lt;/code&gt; ( &lt;code&gt;null&lt;/code&gt; 또는 기타 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;잘못된&lt;/a&gt; 값은&lt;/em&gt; 아니지만 ) 설정되어 &lt;em&gt;있어도&lt;/em&gt; &lt;code&gt;num&lt;/code&gt; 인수 의 값 은 여전히 ​​기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7b79ff68d3fff0dd724c0e66e2c8369970388f4e" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;this&lt;/code&gt; should be &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, because &lt;code&gt;f2&lt;/code&gt; was called directly and not as a method or property of an object (e.g. &lt;code&gt;window.f2()&lt;/code&gt;). This feature wasn't implemented in some browsers when they first started to support &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;. As a result, they incorrectly returned the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">두 번째 예에서는 &lt;code&gt;this&lt;/code&gt; 되어야 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 때문에, &lt;code&gt;f2&lt;/code&gt; 객체의 메소드 또는 속성으로 직접 호출하지 하였다 (예 &lt;code&gt;window.f2()&lt;/code&gt; ). 이 기능은 일부 브라우저에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 지원을 처음 시작했을 때 구현되지 않았습니다 . 결과적으로 &lt;code&gt;window&lt;/code&gt; 개체 를 잘못 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="0cd33ef758331369d99dcee31aeb7e6ca215fa7f" translate="yes" xml:space="preserve">
          <source>In the syntax, the text string represents the literal text that you want the user to see. The &lt;code&gt;name&lt;/code&gt; parameter string represents the &lt;code&gt;name&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">구문에서 텍스트 문자열은 사용자에게 표시 할 리터럴 텍스트를 나타냅니다. &lt;code&gt;name&lt;/code&gt; 매개 변수 문자열이 나타내는 &lt;code&gt;name&lt;/code&gt; 의 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를.</target>
        </trans-unit>
        <trans-unit id="eae556c3be7f945436b5d6044a42766b280d5e47" translate="yes" xml:space="preserve">
          <source>In the table below, &lt;strong&gt;Grouping&lt;/strong&gt; is listed as having the highest precedence. However, that does not always mean the expression within the grouping symbols &lt;code&gt;( &amp;hellip; )&lt;/code&gt; is evaluated first, especially when it comes to short-circuiting.</source>
          <target state="translated">아래 표에서 &lt;strong&gt;그룹화&lt;/strong&gt; 는 우선 순위가 가장 높은 것으로 나열됩니다. 그러나 이것이 항상 그룹화 기호 &lt;code&gt;( &amp;hellip; )&lt;/code&gt; 내의 표현식 이 먼저 평가 된다는 것을 의미하지는 않습니다 . 특히 단락과 관련하여 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="53bb1c4268b088f014ea5a9a7d9ea551816d49cc" translate="yes" xml:space="preserve">
          <source>In the uncompressed version, the program runs into the truthy-branch and logs &quot;&lt;code&gt;'foo' is an instance of 'Foo'&lt;/code&gt;&quot;. Whereas, in the compressed version it behaves differently, and runs into the else-branch. If you rely on &lt;code&gt;Function.name&lt;/code&gt;, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function to have a particular name.</source>
          <target state="translated">압축되지 않은 버전에서 프로그램은 truthy-branch로 실행되고 &quot; &lt;code&gt;'foo' is an instance of 'Foo'&lt;/code&gt; foo'is an instance of 'Foo' &quot;를 기록합니다. 반면 압축 된 버전에서는 다르게 동작하고 else-branch로 실행됩니다. 위의 예와 같이 &lt;code&gt;Function.name&lt;/code&gt; 에 의존하는 경우 빌드 파이프 라인이 함수 이름을 변경하지 않도록하거나 함수에 특정 이름이 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="79bb87933d62241b361f74acb67f3e98a281c829" translate="yes" xml:space="preserve">
          <source>In the uncompressed version, the program runs into the truthy-branch and logs &lt;em&gt;'foo' is an instance of 'Foo'&lt;/em&gt;. Whereas, in the compressed version it behaves differently, and runs into the else-branch. If you rely on &lt;code&gt;Function.name&lt;/code&gt;, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function to have a particular name.</source>
          <target state="translated">압축되지 않은 버전에서 프로그램은 진리 지점으로 실행되며 &lt;em&gt;'foo'는 'Foo'의 인스턴스입니다&lt;/em&gt; . 반면 압축 버전에서는 다르게 동작하고 else-branch로 실행됩니다. 위의 예와 같이 &lt;code&gt;Function.name&lt;/code&gt; 에 의존하는 경우 빌드 파이프 라인이 함수 이름을 변경하지 않거나 특정 이름을 가진 함수를 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a6045774c4491fab11ca343b8a71fe9f28294720" translate="yes" xml:space="preserve">
          <source>In the worker (see &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt;) we define an import object for the module to use, then set up an event handler to receive the module from the main thread. When the module is received, we create an instance from it using the &lt;a href=&quot;instantiate&quot;&gt;&lt;code&gt;WebAssembly.instantiate()&lt;/code&gt;&lt;/a&gt; method and invoke an exported function from inside it.</source>
          <target state="translated">워커 ( &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt; 참조 )에서 모듈이 사용할 가져 오기 오브젝트를 정의한 후 기본 스레드에서 모듈을 수신하도록 이벤트 핸들러를 설정하십시오. 모듈이 수신되면 &lt;a href=&quot;instantiate&quot;&gt; &lt;code&gt;WebAssembly.instantiate()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 모듈에서 인스턴스를 작성하고 내부에서 내 보낸 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="012ee32c213d819cb9d3fb7476f49f1095628ce9" translate="yes" xml:space="preserve">
          <source>In the worker (see &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt;) we define an import object for the module to use, then set up an event handler to receive the module from the main thread. when the module is received, we create an instance from it using the &lt;a href=&quot;../instantiate&quot;&gt;&lt;code&gt;WebAssembly.Instantiate()&lt;/code&gt;&lt;/a&gt; method, invoke an exported function from inside it, then show how we can return information on the available exports on a module using &lt;code&gt;WebAssembly.Module.exports&lt;/code&gt;.</source>
          <target state="translated">워커 ( &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt; 참조 )에서 모듈이 사용할 가져 오기 오브젝트를 정의한 후 기본 스레드에서 모듈을 수신하도록 이벤트 핸들러를 설정하십시오. 모듈이 수신되면 &lt;a href=&quot;../instantiate&quot;&gt; &lt;code&gt;WebAssembly.Instantiate()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 인스턴스를 작성하고 그 안에서 내 보낸 함수를 호출 한 다음 &lt;code&gt;WebAssembly.Module.exports&lt;/code&gt; 를 사용하여 모듈에서 사용 가능한 내보내기에 대한 정보를 리턴하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="70bec1ed815f54f78684ae17e4732e9e7306cdd6" translate="yes" xml:space="preserve">
          <source>In this case it's important to return only an integer (so a simple division won't do), and also to only return actually elapsed seconds (that's why this code uses &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt; and not &lt;a href=&quot;math/round&quot;&gt;&lt;code&gt;Math.round()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 경우 정수만 반환하므로 간단한 나누기가 수행되지 않고 실제로 경과 한 초만 반환하는 것이 중요합니다 (이 코드는 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;math/round&quot;&gt; &lt;code&gt;Math.round()&lt;/code&gt; &lt;/a&gt; 는 사용 하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="8c9f7d01af5e1fce725fc980e3a1487d78434b0a" translate="yes" xml:space="preserve">
          <source>In this case, it's important to return only an integer&amp;mdash;so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt;, and &lt;em&gt;not&lt;/em&gt;&lt;a href=&quot;math/round&quot;&gt;&lt;code&gt;Math.round()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">이 경우 정수만 반환하는 것이 중요하므로 간단한 나눗셈은 수행하지 않습니다. 실제로 경과 한 초만 반환하는 것도 중요합니다. (이 코드가 사용하는 이유입니다 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 하고 &lt;em&gt;있지 &lt;/em&gt;&lt;a href=&quot;math/round&quot;&gt; &lt;code&gt;Math.round()&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="186a0d96b6bdd1c3792c513064740ed74358e3ab" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;console.log()&lt;/code&gt; call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.</source>
          <target state="translated">이 경우 &lt;code&gt;console.log()&lt;/code&gt; 호출은 주석 안에 있으므로 실행되지 않습니다. 이 방법으로 여러 줄의 코드를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c6fb8b542b497eb35334ab759b3e7f836b4e4a" translate="yes" xml:space="preserve">
          <source>In this case, the function &lt;code&gt;sum&lt;/code&gt; has default parameters &lt;code&gt;a=1&lt;/code&gt; and &lt;code&gt;b=2&lt;/code&gt;:</source>
          <target state="translated">이 경우 함수 &lt;code&gt;sum&lt;/code&gt; 에는 기본 매개 변수 &lt;code&gt;a=1&lt;/code&gt; 및 &lt;code&gt;b=2&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c25e00d5dc533083c80281b6cb39e68fc1bfd2" translate="yes" xml:space="preserve">
          <source>In this case, the inner function's &lt;code&gt;this&lt;/code&gt; isn't set so it returns the global/window object (i.e. the default object in non&amp;ndash;strict mode where &lt;code&gt;this&lt;/code&gt; isn't set by the call).</source>
          <target state="translated">이 경우, 내부 기능의 &lt;code&gt;this&lt;/code&gt; 는 글로벌 / 창 개체를 반환 있도록 설정되지 않은 (즉, 비 엄격 모드의 기본 목적 &lt;code&gt;this&lt;/code&gt; 호출에 의해 설정되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="ee090e37a02dcb4f76244ca9578ebc7366ff2c73" translate="yes" xml:space="preserve">
          <source>In this case, the property &lt;code&gt;bar&lt;/code&gt; is an undefined property, so a &lt;code&gt;ReferenceError&lt;/code&gt; will occur.</source>
          <target state="translated">이 경우 속성 &lt;code&gt;bar&lt;/code&gt; 은 정의되지 않은 속성이므로 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ba12f762c8080d1368efbc5da9ff771dc86bdae" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;arg&quot; redeclares the argument.</source>
          <target state="translated">이 경우 변수 &quot;arg&quot;는 인수를 다시 선언합니다.</target>
        </trans-unit>
        <trans-unit id="37c152d2215becaac46c7389493a06f938d3439c" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;bar&quot; is an undeclared variable.</source>
          <target state="translated">이 경우 변수 &quot;bar&quot;는 선언되지 않은 변수입니다.</target>
        </trans-unit>
        <trans-unit id="1089c3880315f3e567e584d5eccf757d257bcc7e" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;foo&quot; is redeclared in the block statement using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;let&lt;/code&gt; 을 사용하여 &quot;foo&quot;변수를 블록 명령문에서 다시 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="607fad50d33fb3b355e7cc4cdeae47a48846941f" translate="yes" xml:space="preserve">
          <source>In this case, we return all the selected &lt;code&gt;option&lt;/code&gt;s' values on the screen:</source>
          <target state="translated">이 경우 선택한 모든 &lt;code&gt;option&lt;/code&gt; 값을 화면에 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5233ec322e51b52c87cb640dd6c9fe7a2b2a7d5" translate="yes" xml:space="preserve">
          <source>In this case, which happens way too often, there is a typo in the method name:</source>
          <target state="translated">이 경우 너무 자주 발생하는 메서드 이름에 오타가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce98cc8bdab5c6d18ec608646a8a392ecc6990dc" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;property&lt;/code&gt; must be a valid JavaScript identifier, i.e. a sequence of alphanumerical characters, also including the underscore (&quot;&lt;code&gt;_&lt;/code&gt;&quot;) and dollar sign (&quot;&lt;code&gt;$&lt;/code&gt;&quot;), that cannot start with a number. For example, &lt;code&gt;object.$1&lt;/code&gt; is valid, while &lt;code&gt;object.1&lt;/code&gt; is not.</source>
          <target state="translated">이 코드에서 &lt;code&gt;property&lt;/code&gt; 는 유효한 JavaScript 식별자, 즉 밑줄 ( &quot; &lt;code&gt;_&lt;/code&gt; &quot;)과 달러 기호 ( &quot; &lt;code&gt;$&lt;/code&gt; &quot;)를 포함하여 숫자로 시작할 수없는 일련의 영숫자 문자 여야합니다 . 예를 들어 &lt;code&gt;object.$1&lt;/code&gt; 은 유효하지만 &lt;code&gt;object.1&lt;/code&gt; 은 유효 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c8360a647a18e7467e5241af714ffdf2ee3543e" translate="yes" xml:space="preserve">
          <source>In this example the target has two properties, &lt;code&gt;notProxied&lt;/code&gt; and &lt;code&gt;proxied&lt;/code&gt;. We define a handler that returns a different value for &lt;code&gt;proxied&lt;/code&gt;, and lets any other accesses through to the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcac0f21dd62d88cc1fc1d7c5edc9c0b7b37a5fd" translate="yes" xml:space="preserve">
          <source>In this example we define a function that can add two or more numbers together.</source>
          <target state="translated">이 예에서는 둘 이상의 숫자를 더할 수있는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="44ecc52fcc1dd532a59d37d9c27852cb4e6632c6" translate="yes" xml:space="preserve">
          <source>In this example when the setter is triggered, it is told to do the same thing again: &lt;em&gt;to set the same property that it is meant to handle.&lt;/em&gt; This causes the function to call itself, again and again, making it infinitely recursive.</source>
          <target state="translated">이 예제에서는 setter가 트리거 될 때 동일한 작업을 다시 수행하도록 지시합니다 &lt;em&gt;. 처리 할 동일한 속성을 설정합니다. &lt;/em&gt;이로 인해 함수가 계속해서 자신을 호출하여 무한 재귀 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bfda2fb9a04305f886bcd0e49716e0ef48179b89" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;f()&lt;/code&gt; returns the values &lt;code&gt;[1, 2]&lt;/code&gt; as its output, which can be parsed in a single line with destructuring.</source>
          <target state="translated">이 예에서 &lt;code&gt;f()&lt;/code&gt; 는 &lt;code&gt;[1, 2]&lt;/code&gt; 값을 출력으로 반환하며,이 값 은 한 줄로 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec37b22188853fa195e1eb0a40dd6fc5647d4b0" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;next&lt;/code&gt; is called with a value.</source>
          <target state="translated">이 예에서 &lt;code&gt;next&lt;/code&gt; 는 값으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a73078322457f6e2a4f76866f7f2bd2d296423" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;next&lt;/code&gt; is called with a value. Note that the first call did not log anything, because the generator was not yielding anything initially.</source>
          <target state="translated">이 예에서 &lt;code&gt;next&lt;/code&gt; 는 값으로 호출됩니다. 생성기가 처음에 아무것도 생성하지 않았기 때문에 첫 번째 호출은 아무것도 기록하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="563d6171046b28102d99d569274b89bdabeb1e27" translate="yes" xml:space="preserve">
          <source>In this example, a getter always returns the same value.</source>
          <target state="translated">이 예제에서 getter는 항상 같은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d925e67a635ae1e3d2c5b8950ddc3283286c2d1" translate="yes" xml:space="preserve">
          <source>In this example, all occurrences of capital letters in the string are converted to lower case, and a hyphen is inserted just before the match location. The important thing here is that additional operations are needed on the matched item before it is given back as a replacement.</source>
          <target state="translated">이 예에서 문자열에서 모든 대문자는 소문자로 변환되며 일치 위치 바로 앞에 하이픈이 삽입됩니다. 여기서 중요한 것은 일치 항목에 대한 추가 작업이 교체품으로 다시 제공되기 전에 필요하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="759ee36c2266471d3c6cb72f53c573291607c4d8" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;toGMTString()&lt;/code&gt; method converts the date to GMT (UTC) using the operating system's time-zone offset and returns a string value that is similar to the following form. The exact format depends on the platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33012959cef3631ac1b179a71cdf251a2d34c8f" translate="yes" xml:space="preserve">
          <source>In this example, the first argument is mapped to &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the second to &lt;code&gt;&quot;b&quot;&lt;/code&gt;, so these named arguments are used like normal. However the third argument &lt;code&gt;&quot;manyMoreArgs&quot;&lt;/code&gt; will be an array that contains the 3rd, 4th, 5th, 6th ... nth -- as many arguments that the user includes.</source>
          <target state="translated">이 예에서 첫 번째 인수는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 에 매핑되고 두 번째 인수는 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 에 매핑 되므로 이러한 명명 된 인수는 일반처럼 사용됩니다. 그러나 세 번째 인수 &lt;code&gt;&quot;manyMoreArgs&quot;&lt;/code&gt; 는 사용자가 포함하는 많은 인수 인 3 번째, 4 번째, 5 번째, 6 번째 ... n 번째를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b5ba9ccc89fc1604d1696a6f06c45a0e15818a82" translate="yes" xml:space="preserve">
          <source>In this example, the first argument is mapped to &lt;code&gt;a&lt;/code&gt; and the second to &lt;code&gt;b&lt;/code&gt;, so these named arguments are used as normal.</source>
          <target state="translated">이 예에서 첫 번째 인수는 &lt;code&gt;a&lt;/code&gt; 에 매핑되고 두 번째 인수는 &lt;code&gt;b&lt;/code&gt; 에 되므로 이러한 명명 된 인수가 정상적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="694ce76b4ee53e67741df07c604b0136305f4feb" translate="yes" xml:space="preserve">
          <source>In this example, the object assigned to the variable &lt;code&gt;p&lt;/code&gt; doesn't have its own &lt;code&gt;f&lt;/code&gt; property, it inherits it from its prototype. But it doesn't matter that the lookup for &lt;code&gt;f&lt;/code&gt; eventually finds a member with that name on &lt;code&gt;o&lt;/code&gt;; the lookup began as a reference to &lt;code&gt;p.f&lt;/code&gt;, so &lt;code&gt;this&lt;/code&gt; inside the function takes the value of the object referred to as &lt;code&gt;p&lt;/code&gt;. That is, since &lt;code&gt;f&lt;/code&gt; is called as a method of &lt;code&gt;p&lt;/code&gt;, its &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;p&lt;/code&gt;. This is an interesting feature of JavaScript's prototype inheritance.</source>
          <target state="translated">이 예에서 변수 &lt;code&gt;p&lt;/code&gt; 에 지정된 객체 에는 고유 한 &lt;code&gt;f&lt;/code&gt; 속성 이 없으며 프로토 타입에서 상속됩니다. 그러나 &lt;code&gt;f&lt;/code&gt; 에 대한 조회가 결국 &lt;code&gt;o&lt;/code&gt; 에서 해당 이름을 가진 멤버를 찾는 것은 중요하지 않습니다 . 룩업은 참조로 시작 &lt;code&gt;p.f&lt;/code&gt; 있으므로, &lt;code&gt;this&lt;/code&gt; 함수라고 대상물의 내부 값 걸리는 &lt;code&gt;p&lt;/code&gt; . 이후, 즉 &lt;code&gt;f&lt;/code&gt; 방법으로 불린다 &lt;code&gt;p&lt;/code&gt; 그 &lt;code&gt;this&lt;/code&gt; 지칭 &lt;code&gt;p&lt;/code&gt; . 이것은 JavaScript 프로토 타입 상속의 흥미로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="66ff041dbef1cfc7f06522a5a35ef052cd6ff39d" translate="yes" xml:space="preserve">
          <source>In this example, we are using a native JavaScript object to which our proxy will forward all operations that are applied to it.</source>
          <target state="translated">이 예에서는 프록시가 적용되는 모든 작업을 프록시가 전달할 기본 JavaScript 객체를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d44b171c423b36c9ffde273c548d0bbfbac36f" translate="yes" xml:space="preserve">
          <source>In this example, we create a 8-byte buffer with a &lt;a href=&quot;../int32array&quot;&gt;&lt;code&gt;Int32Array&lt;/code&gt;&lt;/a&gt; view referring to the buffer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f8bcdd4576e052baef77d87b035aec5006ad25" translate="yes" xml:space="preserve">
          <source>In this example, we create a 8-byte buffer with a &lt;a href=&quot;int32array&quot;&gt;&lt;code&gt;Int32Array&lt;/code&gt;&lt;/a&gt; view referring to the buffer:</source>
          <target state="translated">이 예제에서는 버퍼를 참조 하는 &lt;a href=&quot;int32array&quot;&gt; &lt;code&gt;Int32Array&lt;/code&gt; &lt;/a&gt; 보기를 사용하여 8 바이트 버퍼를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="87a870c20fd5c4ac21e8e1fefbf9420b0799bf46" translate="yes" xml:space="preserve">
          <source>In this example, we create an anonymous function and use &lt;code&gt;call&lt;/code&gt; to invoke it on every object in an array.</source>
          <target state="translated">이 예에서는 익명 함수를 만들고 &lt;code&gt;call&lt;/code&gt; 을 하여 배열의 모든 개체에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="02d622e8d0d99304a0a0a4b1c302b418fb7d05cf" translate="yes" xml:space="preserve">
          <source>In this example, we create an anonymous function and use &lt;code&gt;call&lt;/code&gt; to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as &lt;code&gt;this&lt;/code&gt; value was not strictly necessary, but is done for explanatory purpose.</source>
          <target state="translated">이 예제에서는 익명 함수를 만들고 &lt;code&gt;call&lt;/code&gt; 을 사용 하여 배열의 모든 객체에서 호출합니다. 여기서 익명 함수의 주요 목적은 모든 객체에 인쇄 기능을 추가하여 배열에서 객체의 올바른 색인을 인쇄 할 수 있도록하는 것입니다. &lt;code&gt;this&lt;/code&gt; 값을 객체로 전달하는 것이 꼭 필요한 것은 아니지만 설명 목적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f672f93e1db2c6bc3b7a46e652d5ed693037774" translate="yes" xml:space="preserve">
          <source>In this example, we have a function that fetches an image and returns a blob. We use &lt;code&gt;Promise.any()&lt;/code&gt; to fetch a couple of images and display the first one available (i.e. whose promise has resolved).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d1a734c2b7c768d448203122432bbe776e5b05" translate="yes" xml:space="preserve">
          <source>In this example, we will provide default values but keep values other than &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35974a3e7587dcc087e5970b5717fe14b1ffcde" translate="yes" xml:space="preserve">
          <source>In this list, each page is listed by name (the type of error) and message (a more detailed human-readable error message). Together, these two properties provide a starting point toward understanding and resolving the error. For more information, follow the links below!</source>
          <target state="translated">이 목록에서 각 페이지는 이름 (오류 유형) 및 메시지 (보다 자세한 사람이 읽을 수있는 오류 메시지)로 나열됩니다. 이 두 가지 특성은 함께 오류를 이해하고 해결하는 출발점을 제공합니다. 자세한 내용은 아래 링크를 참조하십시오!</target>
        </trans-unit>
        <trans-unit id="84cc35eeca38031ad4f482983b4a69f835b760cf" translate="yes" xml:space="preserve">
          <source>In this simple example the number &lt;code&gt;37&lt;/code&gt; gets returned as the default value when the property name is not in the object. It is using the &lt;a href=&quot;proxy/handler/get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 간단한 예제에서 속성 이름이 객체에 없으면 숫자 &lt;code&gt;37&lt;/code&gt; 이 기본값으로 반환됩니다. &lt;a href=&quot;proxy/handler/get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 핸들러를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9f63da3eb0045c2357f1cdb851b284fdcaffc13" translate="yes" xml:space="preserve">
          <source>In this simple example, the number &lt;code&gt;37&lt;/code&gt; gets returned as the default value when the property name is not in the object. It is using the &lt;a href=&quot;proxy/proxy/get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 간단한 예 에서 속성 이름이 개체에 없으면 숫자 &lt;code&gt;37&lt;/code&gt; 이 기본값으로 반환됩니다. 그것은 사용하고 있습니다&lt;a href=&quot;proxy/proxy/get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 핸들러를있습니다.</target>
        </trans-unit>
        <trans-unit id="590403612835e59c245f0cdab1e404168d22e494" translate="yes" xml:space="preserve">
          <source>In unusual situations, the assignment operator (e.g.&lt;code&gt; x += y&lt;/code&gt;) is not identical to the meaning expression (here &lt;code&gt;x = x + y&lt;/code&gt;). When the left operand of an assignment operator itself contains an assignment operator, the left operand is evaluated only once. For example:</source>
          <target state="translated">비정상적인 상황에서 대입 연산자 (예 : &lt;code&gt; x += y&lt;/code&gt; )는 의미 표현식 (여기서 &lt;code&gt;x = x + y&lt;/code&gt; ) 과 동일하지 않습니다 . 대입 연산자 자체의 왼쪽 피연산자에 대입 연산자가 있으면 왼쪽 피연산자가 한 번만 평가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a131dacbe54fb64553702d39cdf6558030b34fb8" translate="yes" xml:space="preserve">
          <source>Included in the (normative) annex for additional ECMAScript legacy features for Web browsers (note that the specification codifies what is already in implementations).</source>
          <target state="translated">웹 브라우저에 대한 추가 ECMAScript 레거시 기능에 대한 (표준) 부록에 포함되어 있습니다 (사양에는 이미 구현중인 내용이 나와 있습니다).</target>
        </trans-unit>
        <trans-unit id="4041f4126b0351dfe2e79c79a3f6557e3c70b29b" translate="yes" xml:space="preserve">
          <source>Incomplete array initializer</source>
          <target state="translated">불완전한 배열 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="4c69aeda2103b6e78518bbb410b414f8da34036f" translate="yes" xml:space="preserve">
          <source>Increases the size of the Table instance by a specified number of elements.</source>
          <target state="translated">지정된 수의 요소만큼 Table 인스턴스의 크기를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="1ad7f4e9bdfd8b6afc5185d816fa7e2287a97748" translate="yes" xml:space="preserve">
          <source>Increases the size of the Table instance by a specified number of references.</source>
          <target state="translated">지정된 수의 참조만큼 Table 인스턴스의 크기를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c99f880b72799cc04c963d4317c186789a75c6d6" translate="yes" xml:space="preserve">
          <source>Increases the size of the memory instance by a specified number of WebAssembly pages (each one is 64KB in size).</source>
          <target state="translated">지정된 수의 웹 어셈블리 페이지 수만큼 메모리 인스턴스 크기를 증가시킵니다 (각 페이지는 64KB입니다).</target>
        </trans-unit>
        <trans-unit id="401d8f49917326f6d322f2dadc2fa0c24677d373" translate="yes" xml:space="preserve">
          <source>Increasing the &lt;a href=&quot;array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="65bc9ccd743dd3dce9047eb75c52a48c168f2c7a" translate="yes" xml:space="preserve">
          <source>Increment &amp;amp; decrement</source>
          <target state="translated">증가 및 감소</target>
        </trans-unit>
        <trans-unit id="f6baea39d0ecb0d64a9c1b43f7ae26c1991070ca" translate="yes" xml:space="preserve">
          <source>Increment (++)</source>
          <target state="translated">증분 (++)</target>
        </trans-unit>
        <trans-unit id="7137b97519cd5a3352b194f1a47ef7b8d00c0803" translate="yes" xml:space="preserve">
          <source>Increment (&lt;code&gt;++&lt;/code&gt;)</source>
          <target state="translated">증가 ( &lt;code&gt;++&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="0a8e6a5dfdc997a2260400369cf30f33da622e5c" translate="yes" xml:space="preserve">
          <source>Increment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffb5e37a0de256063704a907edfe0ba275b1cf7" translate="yes" xml:space="preserve">
          <source>Indeterminate form (e.g. &lt;code&gt;0 * Infinity&lt;/code&gt;, or &lt;code&gt;undefined + undefined&lt;/code&gt;)</source>
          <target state="translated">불확실한 형태 (예 : &lt;code&gt;0 * Infinity&lt;/code&gt; 또는 &lt;code&gt;undefined + undefined&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e37f91419162687bd95af5bf7c6d8af3c0b436e1" translate="yes" xml:space="preserve">
          <source>Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.</source>
          <target state="translated">배열 변경을 시작하는 인덱스 (원점 0). 배열의 길이보다 큰 경우 실제 시작 색인은 배열의 길이로 설정됩니다. 음수 인 경우, 배열의 끝에서부터 시작하여 많은 요소 (원점 -1 사용)를 시작하고 절대 값이 배열의 길이보다 큰 경우 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="45e917d5246c9f80b81acc22465ce7ef8dada20f" translate="yes" xml:space="preserve">
          <source>Indexed Collections</source>
          <target state="translated">인덱싱 된 컬렉션</target>
        </trans-unit>
        <trans-unit id="0a5a3ab920950c8b210b9bac77077845cb8eefef" translate="yes" xml:space="preserve">
          <source>Indexed collections</source>
          <target state="translated">인덱싱 된 컬렉션</target>
        </trans-unit>
        <trans-unit id="ad269f38c4b63f8bfa0ecb35d25d42a1aaead76a" translate="yes" xml:space="preserve">
          <source>Indexed properties not consulting prototype</source>
          <target state="translated">프로토 타입을 참조하지 않는 인덱싱 된 속성</target>
        </trans-unit>
        <trans-unit id="718a228559e4b8042e0e85d2b6d3589cc237d81b" translate="yes" xml:space="preserve">
          <source>Indian calendar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7600e0fb90c939a2d9f2134c598b9b3ebcc27ac1" translate="yes" xml:space="preserve">
          <source>Indicates an error during WebAssembly decoding or validation.</source>
          <target state="translated">WebAssembly 디코딩 또는 유효성 검사 중 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="018b8e5d38f9e27fad5f584feea16ea2dc658705" translate="yes" xml:space="preserve">
          <source>Indicates an error during module instantiation (besides &lt;a href=&quot;http://webassembly.org/docs/semantics/#traps&quot;&gt;traps&lt;/a&gt; from the start function).</source>
          <target state="translated">모듈 인스턴스화 중 오류를 나타냅니다 ( &lt;a href=&quot;http://webassembly.org/docs/semantics/#traps&quot;&gt;트랩&lt;/a&gt; 외에 시작 함수의 ).</target>
        </trans-unit>
        <trans-unit id="20c0a83d7993f36b5134ae07826c8ecfe2d53d68" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;g&lt;/code&gt; flag was used for a global match.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 플래그가 전역 일치에 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7dceb2034a666f7087defcc0f1f7e6314d0528af" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;i&lt;/code&gt; flag was used to ignore case.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 플래그가 대소 문자를 무시하는 데 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8b87a4dc659a01a5ec6a2bb79eda040056bd8bfe" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;m&lt;/code&gt; flag was used to search across multiple lines.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 플래그가 여러 행을 검색하는 데 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="92e93f5013ae6f94626f480539fb519f721cf52a" translate="yes" xml:space="preserve">
          <source>Individual date and time component values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3c699849bd9690ce57a8e4f7dfc1232fdafc22" translate="yes" xml:space="preserve">
          <source>Individual flag values can be extracted by ANDing them with a bitmask, where each bit with the value of one will &quot;extract&quot; the corresponding flag. The bitmask &lt;em&gt;masks&lt;/em&gt; out the non-relevant flags by ANDing with zeroes (hence the term &quot;bitmask&quot;). For example, the bitmask 0100 can be used to see if flag C is set:</source>
          <target state="translated">비트 마스크로 AND를 AND하여 각 플래그 값을 추출 할 수 있습니다. 여기서 값이 1 인 각 비트는 해당 플래그를 &quot;추출&quot;합니다. 비트 &lt;em&gt;마스크&lt;/em&gt; 는 0으로 AND를 지정하여 관련이없는 플래그를 마스크합니다 (따라서 &quot;비트 마스크&quot;라는 용어). 예를 들어 비트 마스크 0100을 사용하여 플래그 C가 설정되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e2bf39c1e2a07161681d68dede8a4a0984febe" translate="yes" xml:space="preserve">
          <source>Individual operators</source>
          <target state="translated">개별 사업자</target>
        </trans-unit>
        <trans-unit id="8d4cadd23dc0f47618e0017475e1b69c0cbc8e21" translate="yes" xml:space="preserve">
          <source>Inequality</source>
          <target state="translated">Inequality</target>
        </trans-unit>
        <trans-unit id="e6cec31e8a65681ae7ec444c7f456b4cab73fee8" translate="yes" xml:space="preserve">
          <source>Inequality (!=)</source>
          <target state="translated">불평등 (! =)</target>
        </trans-unit>
        <trans-unit id="68eb52167d8b6624a0b93dc5831d7c86c5135093" translate="yes" xml:space="preserve">
          <source>Inequality (&lt;code&gt;a != b&lt;/code&gt;)</source>
          <target state="translated">불평등 ( &lt;code&gt;a != b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="075d57d117ce1bc9282861df11d51f4826ba829b" translate="yes" xml:space="preserve">
          <source>Inequality operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d488f35d25db0196ffb7b0d1ffbbaed095958c24" translate="yes" xml:space="preserve">
          <source>Inequality operator.</source>
          <target state="translated">불평등 연산자.</target>
        </trans-unit>
        <trans-unit id="a79dc3d005cf68005384e3b181f0842a749aefcd" translate="yes" xml:space="preserve">
          <source>Inferred function names</source>
          <target state="translated">유추 된 함수 이름</target>
        </trans-unit>
        <trans-unit id="ae29dd030af2c6013a342baa4496df5423ffebe1" translate="yes" xml:space="preserve">
          <source>Inferred names on anonymous functions</source>
          <target state="translated">익명 함수에 대한 유추 된 이름</target>
        </trans-unit>
        <trans-unit id="f6c883b54018ef7a4cdbcff87341648a7e230e30" translate="yes" xml:space="preserve">
          <source>Infinite iterator</source>
          <target state="translated">무한 반복자</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="59e354f06c04e0eb393e460ca726f509ae4ece3e" translate="yes" xml:space="preserve">
          <source>Inheritance of properties</source>
          <target state="translated">속성의 상속</target>
        </trans-unit>
        <trans-unit id="7951150c36a5b0078509be63ec158d0a10f3f90a" translate="yes" xml:space="preserve">
          <source>Inherited properties</source>
          <target state="translated">상속 된 속성</target>
        </trans-unit>
        <trans-unit id="401219b9a38e6944e96008d3d9469f2296a8f5b9" translate="yes" xml:space="preserve">
          <source>Inherited property access: &lt;code&gt;Object.create(&lt;var&gt;proxy&lt;/var&gt;)[&lt;var&gt;foo&lt;/var&gt;]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df616f44e2c500bdaf1406df4828fd9ed5d52f72" translate="yes" xml:space="preserve">
          <source>Inherited property access: &lt;code&gt;Object.create(proxy)[foo]&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 액세스 : &lt;code&gt;Object.create(proxy)[foo]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e80bf283b45a2a89da1dbc94e786f5f0ba62b400" translate="yes" xml:space="preserve">
          <source>Inherited property assignment: &lt;code&gt;Object.create(&lt;var&gt;proxy&lt;/var&gt;)[&lt;var&gt;foo&lt;/var&gt;] = &lt;var&gt;bar&lt;/var&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2150882f012dfc772b92621683506749d96ecd3" translate="yes" xml:space="preserve">
          <source>Inherited property assignment: &lt;code&gt;Object.create(proxy)[foo] = bar&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 할당 : &lt;code&gt;Object.create(proxy)[foo] = bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d1cfc052e5b58eb7c5741cab4b785cb23dd45a" translate="yes" xml:space="preserve">
          <source>Inherited property query: &lt;code&gt;foo in Object.create(&lt;var&gt;proxy&lt;/var&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75868d63eb79c862251acc96e281c4c93b846e2" translate="yes" xml:space="preserve">
          <source>Inherited property query: &lt;code&gt;foo in Object.create(proxy)&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 쿼리 : &lt;code&gt;foo in Object.create(proxy)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78bf1f0ee0b483d322b97ba37fe2a667145f86c8" translate="yes" xml:space="preserve">
          <source>Initial ECMAScript proposal: &lt;a href=&quot;https://github.com/tc39/proposal-trailing-function-commas&quot;&gt;trailing function commas&lt;/a&gt; by Jeff Morrison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd7f16fa284794d2ca981389668e28d3cd48524" translate="yes" xml:space="preserve">
          <source>Initial WebAssembly draft definition.</source>
          <target state="translated">초기 웹 어셈블리 초안 정의.</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="translated">초기 정의</target>
        </trans-unit>
        <trans-unit id="a37acae44fb32c850ce995533205c3c2eb69f53c" translate="yes" xml:space="preserve">
          <source>Initial definition in ECMA standard.</source>
          <target state="translated">ECMA 표준의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="35e9e36e8328392208cdb962c3a79bddae0d63a2" translate="yes" xml:space="preserve">
          <source>Initial definition in ECMAScript 2017.</source>
          <target state="translated">ECMAScript 2017의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="f7d55f8d05c9e8c07926850628936b042dbed3d6" translate="yes" xml:space="preserve">
          <source>Initial definition in ES2017.</source>
          <target state="translated">ES2017의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="6b379dfab4923f85c6fe72c56d94f6fd30cd942c" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard</source>
          <target state="translated">ECMA 표준의 초기 정의</target>
        </trans-unit>
        <trans-unit id="bee4945b5c9770ada5b145f4f6bd2f1332eb9f3f" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard.</source>
          <target state="translated">ECMA 표준의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="e29784b04e2a292b41764fd796f01398698302ab" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard. Specified behaviour for indexed and named properties. Specified that &lt;code&gt;new&lt;/code&gt; is required.</source>
          <target state="translated">ECMA 표준의 초기 정의. 인덱스 및 명명 된 속성에 대해 지정된 동작 &lt;code&gt;new&lt;/code&gt; 것이 필요함을 명시했다 .</target>
        </trans-unit>
        <trans-unit id="82c35f70e5937c8e4260b39081fd9fc366d7bedb" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard. Specified that &lt;code&gt;new&lt;/code&gt; is required.</source>
          <target state="translated">ECMA 표준의 초기 정의. &lt;code&gt;new&lt;/code&gt; 것이 필요함을 명시했다 .</target>
        </trans-unit>
        <trans-unit id="804103ada9286a91818a9c6f943e1357a3cee5f3" translate="yes" xml:space="preserve">
          <source>Initial definition was in ECMAScript 3.</source>
          <target state="translated">초기 정의는 ECMAScript 3에있었습니다.</target>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="translated">초기 정의.</target>
        </trans-unit>
        <trans-unit id="c74d3aa9086119cde5be85b65c88465515b8ab05" translate="yes" xml:space="preserve">
          <source>Initial definition. Defined in several section of the specification: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-template-literals&quot;&gt;Template Literals&lt;/a&gt;, &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-tagged-templates&quot;&gt;Tagged Templates&lt;/a&gt;</source>
          <target state="translated">초기 정의. 사양의 여러 섹션에 정의되어 있습니다 : &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-template-literals&quot;&gt;템플릿 리터럴&lt;/a&gt; , &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-tagged-templates&quot;&gt;태그가 지정된 템플릿&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d8b74490582a852fffa70f4fc964c8e54beb501" translate="yes" xml:space="preserve">
          <source>Initial definition. Defined in the (normative) Annex B for Additional ECMAScript Features for Web Browsers.</source>
          <target state="translated">초기 정의. 웹 브라우저에 대한 추가 ECMAScript 기능에 대해서는 (표준) 부록 B에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf63efa5c0322f19ea7d903fb16ba743a12e456d" translate="yes" xml:space="preserve">
          <source>Initial definition. Does not specify let expressions or let blocks.</source>
          <target state="translated">초기 정의. let 식 또는 let 블록을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40263062f582b9167e63d837c485ac319158cdd4" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현</target>
        </trans-unit>
        <trans-unit id="4ce05f6ce50ee64e9b4ab5c56bb413d0aef9cda2" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef9ece1071525c79ebc962c49979dc6140499d8b" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0. Defined in the (normative) Annex B for Additional ECMAScript Features for Web Browsers.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다. 웹 브라우저에 대한 추가 ECMAScript 기능에 대해서는 (표준) 부록 B에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3477ed16aca83fcc6cb881f80d7e09ec7c62282" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0. Deprecated in favor of &lt;a href=&quot;../../functions/arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; in ES3.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다. ES3 에서는 &lt;a href=&quot;../../functions/arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 에 찬성하여 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed464ab05f4b7a4db1b22334a85ff353174c997" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.1</source>
          <target state="translated">초기 정의. JavaScript 1.1에서 구현</target>
        </trans-unit>
        <trans-unit id="ac3e55bf74a2e48b37e9ce44c0f80517a3bec394" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.1.</source>
          <target state="translated">초기 정의. JavaScript 1.1에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb8e116565952c369a0e33d04e78e8cfdb7d6847" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현</target>
        </trans-unit>
        <trans-unit id="941a5c7ff7cd2d2d4aa695b24556fd6f3bfb1a20" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc7ad3d394c062cdaa8069fe5fd888ffa41f60f1" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;global&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;global&lt;/code&gt; 은 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="c66c9736512070345f9e9afd89f67fb870b37654" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;ignoreCase&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;ignoreCase&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="bbd4b92992b6ccec49a23065c54399ff4c99f8d4" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;lastIndex&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;lastIndex&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="fad0be06a8ade79e3f7b0862a68a4d8db5a2420c" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;multiline&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. 자바 스크립트 1.5 : &lt;code&gt;multiline&lt;/code&gt; (A)의 속성입니다 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cbac5462a80516b70d45fe45a2fbbd5e4d6ceb8d" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;source&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;source&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="a85f7a92d71856d124832fd97d098db448fd811d" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3</source>
          <target state="translated">초기 정의. 자바 스크립트 1.3에서 구현</target>
        </trans-unit>
        <trans-unit id="b38e7ce9b5cf83a8b1f0b1490a6268e2b973a0a3" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3.</source>
          <target state="translated">초기 정의. JavaScript 1.3으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae0b462c8892ec0161d3febb8a3272c7c02d863f" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3. Format is implementation dependent.</source>
          <target state="translated">초기 정의. JavaScript 1.3으로 구현되었습니다. 형식은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="059285ca9aa0072aad8a001d0290031512394a78" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.4</source>
          <target state="translated">초기 정의. 자바 스크립트 1.4에서 구현</target>
        </trans-unit>
        <trans-unit id="c1808274911cabdf7ca684c1f1735365f7772fde" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.4.</source>
          <target state="translated">초기 정의. JavaScript 1.4로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="a40791e2d6b8b660293bab3f511003e62d469c50" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.5.</source>
          <target state="translated">초기 정의. JavaScript 1.5에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="b912d0e0846319e918d16802811ba094f6f47499" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.6.</source>
          <target state="translated">초기 정의. JavaScript 1.6으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="26a478c8236e6faa48a87a57bc5275286f41b4d7" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.7.</source>
          <target state="translated">초기 정의. JavaScript 1.7에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="078ca5ed2fd128eff8b0b9a2d46b4238264e128c" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.</source>
          <target state="translated">초기 정의. JavaScript 1.8에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a4d24fd7dd67bd64acdeb068c2c167ada819f10" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.1.</source>
          <target state="translated">초기 정의. JavaScript로 구현 1.8.1.</target>
        </trans-unit>
        <trans-unit id="58d49a89bac6a7dedf8b042873e15e72e65f0ebb" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.5</source>
          <target state="translated">초기 정의. JavaScript 1.8.5에서 구현</target>
        </trans-unit>
        <trans-unit id="cad1ad3e2afcf629593f6eb50d4bac93cd34486b" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.5.</source>
          <target state="translated">초기 정의. 자바 스크립트로 구현 1.8.5.</target>
        </trans-unit>
        <trans-unit id="2018c675b7f3b4f89b1656e50a4ae4c9277685f2" translate="yes" xml:space="preserve">
          <source>Initial definition. JavaScript 1.0 (UNIX Only) / JavaScript 1.1 (All platforms).</source>
          <target state="translated">초기 정의. JavaScript 1.0 (UNIX 만 해당) / JavaScript 1.1 (모든 플랫폼).</target>
        </trans-unit>
        <trans-unit id="7173bef762ccdf92ab23687cfc1d5be4a9ad804d" translate="yes" xml:space="preserve">
          <source>Initial definition. See also: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-C&quot;&gt;Strict mode restriction and exceptions&lt;/a&gt;</source>
          <target state="translated">초기 정의. &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-C&quot;&gt;엄격한 모드 제한 및 예외&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57325d451f55171c368ce61331d89e6d3d0aeaf6" translate="yes" xml:space="preserve">
          <source>Initial definition. Unlabeled version.</source>
          <target state="translated">초기 정의. 라벨이없는 버전.</target>
        </trans-unit>
        <trans-unit id="022515f406a57864f40cd1203eb4dcb41febf436" translate="yes" xml:space="preserve">
          <source>Initial defintion.</source>
          <target state="translated">초기 정의.</target>
        </trans-unit>
        <trans-unit id="69a9e0de842d8ae55591da42504603cd7e7262df" translate="yes" xml:space="preserve">
          <source>Initial draft definition.</source>
          <target state="translated">초기 초안 정의.</target>
        </trans-unit>
        <trans-unit id="b975dbb1192b113cadea247a55fa22b519dfca4d" translate="yes" xml:space="preserve">
          <source>Initial publication</source>
          <target state="translated">최초 발행</target>
        </trans-unit>
        <trans-unit id="c02800d28cb9343126029438b218e44c2370a6a7" translate="yes" xml:space="preserve">
          <source>Initial value of the variable. It can be any legal expression. Default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">변수의 초기 값. 모든 법적 표현이 될 수 있습니다. 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e1b224617736038fb54e6a25aa285ec6283eba9" translate="yes" xml:space="preserve">
          <source>Initial value of the variable. It can be any legal expression. Default value is &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">변수의 초기 값. 어떤 법적 표현이라도 가능합니다. 기본값은 &lt;em&gt;undefined&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c5eae6e8ad5c7eff82b70392594bd4874c1a340" translate="yes" xml:space="preserve">
          <source>Initialization of several variables</source>
          <target state="translated">여러 변수의 초기화</target>
        </trans-unit>
        <trans-unit id="9f8693a57ce3d9a432b19813a82043b25a29e309" translate="yes" xml:space="preserve">
          <source>Initially, the &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; function is called with an empty string as key representing the object being stringified. It is then called for each property on the object or array being stringified.</source>
          <target state="translated">처음에 &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; 함수는 문자열 화되는 객체를 나타내는 키로 빈 문자열로 호출됩니다. 그런 다음 문자열 화되는 객체 또는 배열의 각 속성에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d858124bcdda6ccdc66224e0325d22439387781d" translate="yes" xml:space="preserve">
          <source>Initially, the &lt;code&gt;replacer&lt;/code&gt; function is called with an empty string as key representing the object being stringified. It is then called for each property on the object or array being stringified.</source>
          <target state="translated">처음에, &lt;code&gt;replacer&lt;/code&gt; 기능은 문자열 화 될 객체를 나타내는 키로 빈 문자열로 호출됩니다. 그런 다음 문자열 화되는 객체 또는 배열의 각 속성에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="08711e711134e579523d56126b09874d8022e4b2" translate="yes" xml:space="preserve">
          <source>Inserts</source>
          <target state="translated">Inserts</target>
        </trans-unit>
        <trans-unit id="2b48e8876ecb78ba7e1968f36e0fd6a0717b2571" translate="yes" xml:space="preserve">
          <source>Inserts a &quot;$&quot;.</source>
          <target state="translated">&quot;$&quot;를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="40864899bf9e01467baa3d38448be2a7cdcbcb11" translate="yes" xml:space="preserve">
          <source>Inserts a &lt;code&gt;&quot;$&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;$&quot;&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="3ce7b5d4c8da12992edd7415b06c863f63baa582" translate="yes" xml:space="preserve">
          <source>Inserts the matched substring.</source>
          <target state="translated">일치하는 부분 문자열을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="e58f47bb0ef2776a10dd15f573a06a8e5d0afde5" translate="yes" xml:space="preserve">
          <source>Inserts the portion of the string that follows the matched substring.</source>
          <target state="translated">일치하는 부분 문자열 뒤에 오는 문자열 부분을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="4fed5693b7d1971ffd7cacdb16b81e94032e1511" translate="yes" xml:space="preserve">
          <source>Inserts the portion of the string that precedes the matched substring.</source>
          <target state="translated">일치하는 부분 문자열 앞에 오는 문자열 부분을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ca5c1c3094ae7abe52cdce1ab07a6ed84f2ed2aa" translate="yes" xml:space="preserve">
          <source>Inside a character set, the dot loses its special meaning and matches a literal dot.</source>
          <target state="translated">문자 집합 내에서 점은 특별한 의미를 잃고 리터럴 점과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="362024d61ebb70536bd9394b65dd78d5aad24d05" translate="yes" xml:space="preserve">
          <source>Inside a function, the value of &lt;code&gt;this&lt;/code&gt; depends on how the function is called.</source>
          <target state="translated">함수 내 &lt;code&gt;this&lt;/code&gt; 값은 함수 호출 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d0721f17dea6dcfcdf19c0b198b3112c883bdb01" translate="yes" xml:space="preserve">
          <source>Inside array comprehensions, these two kinds of components are allowed:</source>
          <target state="translated">배열 이해 내에서 다음 두 종류의 구성 요소가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fe9bbfb9b980fa6c2f05256bb9bacf12e9bebf9" translate="yes" xml:space="preserve">
          <source>Inside instance methods, &lt;code&gt;this&lt;/code&gt; refers to the instance itself. In subclasses, &lt;code&gt;super&lt;/code&gt; lets you access the superclass prototype, allowing you to call methods from the superclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e60640aa891200ac53331b0be76d088bf2cff8" translate="yes" xml:space="preserve">
          <source>Insignificant &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/whitespace&quot;&gt;whitespace&lt;/a&gt; may be present anywhere except within a &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (numbers must contain no whitespace) or &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (where it is interpreted as the corresponding character in the string, or would cause an error). The tab character (&lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U+0009&lt;/a&gt;), carriage return (&lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U+000D&lt;/a&gt;), line feed (&lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U+000A&lt;/a&gt;), and space (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U+0020&lt;/a&gt;) characters are the only valid whitespace characters.</source>
          <target state="translated">중요하지 않은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/whitespace&quot;&gt;공백&lt;/a&gt; 은 &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (숫자에 공백이 없어야 함) 또는 &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (문자열의 해당 문자로 해석되거나 오류가 발생하는 경우)을 제외하고 어디에나 존재할 수 있습니다 . 탭 문자 ( &lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U + 0009&lt;/a&gt; ), 캐리지 리턴 ( &lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U + 000D&lt;/a&gt; ), 줄 바꿈 ( &lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U + 000A&lt;/a&gt; ) 및 공백 (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt; U + 0020&lt;/a&gt; ) 문자는 유일하게 유효한 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2f3b9e6560de73eb8bc85eb42a04c1141865b37d" translate="yes" xml:space="preserve">
          <source>Insignificant whitespace may be present anywhere except within a &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (numbers must contain no whitespace) or &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (where it is interpreted as the corresponding character in the string, or would cause an error). The tab character (&lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U+0009&lt;/a&gt;), carriage return (&lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U+000D&lt;/a&gt;), line feed (&lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U+000A&lt;/a&gt;), and space (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U+0020&lt;/a&gt;) characters are the only valid whitespace characters.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (숫자에는 공백이 없어야 함) 또는 &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (문자열에서 해당 문자로 해석되거나 오류가 발생 함)을 제외하고는 중요 하지 않은 공백 이있을 수 있습니다. 탭 문자 ( &lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U + 0009&lt;/a&gt; ), 캐리지 리턴 ( &lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U + 000D&lt;/a&gt; ), 줄 바꿈 ( &lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U + 000A&lt;/a&gt; ) 및 공백 ( &lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U + 0020&lt;/a&gt; ) 문자 만 유효한 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="6ab7d1d49dd26afc2c53ee28fa81799fd390b0a3" translate="yes" xml:space="preserve">
          <source>Instance methods</source>
          <target state="translated">인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="c1f424042c7e8bee2655a6672ddd3752109cc8d7" translate="yes" xml:space="preserve">
          <source>Instance properties</source>
          <target state="translated">인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="755387148de4cd392d1630cb598a8c5176cd9afc" translate="yes" xml:space="preserve">
          <source>Instance properties must be defined inside of class methods:</source>
          <target state="translated">인스턴스 속성은 클래스 메서드 내에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="f3a70c71d702bb70b2b487042ba6e7c30d331112" translate="yes" xml:space="preserve">
          <source>Instantiating streaming</source>
          <target state="translated">스트리밍 인스턴스화</target>
        </trans-unit>
        <trans-unit id="581ba3673a3337b2762fb544acd4152c49002ae6" translate="yes" xml:space="preserve">
          <source>Instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;ken&lt;/code&gt; as the parameters for the owners. To find out the name of the owner of &lt;code&gt;car2&lt;/code&gt;, you can access the following property:</source>
          <target state="translated">새 오브젝트를 작성할 때 리터럴 문자열 또는 정수 값을 전달하는 대신 위의 명령문은 오브젝트 &lt;code&gt;rand&lt;/code&gt; 및 &lt;code&gt;ken&lt;/code&gt; 을 소유자의 매개 변수로 전달합니다 . &lt;code&gt;car2&lt;/code&gt; 소유자의 이름을 찾으려면 다음 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd76677e2d8a3bd5f8a89f1a1eada212b419dfdf" translate="yes" xml:space="preserve">
          <source>Instead of throwing, &lt;code&gt;JSON.stringify&lt;/code&gt; now produces a string like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75193ab1f417d6c56a3655429671908b8e061a5" translate="yes" xml:space="preserve">
          <source>Instead of using regular expressions for parsing URLs, it is usually better to use the browsers built-in URL parser by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL_API&quot;&gt;URL API&lt;/a&gt;.</source>
          <target state="translated">URL 구문 분석에 정규식을 사용하는 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL_API&quot;&gt;URL API&lt;/a&gt; 를 사용하여 브라우저에 내장 된 URL 구문 분석기를 사용하는 것이 일반적으로 더 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="31e05bde158595118d55e0ce91c002d27d730c1f" translate="yes" xml:space="preserve">
          <source>Instead write &quot;foo&quot;:</source>
          <target state="translated">대신 &quot;foo&quot;를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c2466dca884b77085cade35f77be32e5976572af" translate="yes" xml:space="preserve">
          <source>Instead write just 1 without a zero and use at least one digit after a decimal point:</source>
          <target state="translated">대신 0없이 1을 쓰고 소수점 뒤에 적어도 하나의 숫자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b2d66e7682b0dcb605d4bd8661e57ecd97726ab" translate="yes" xml:space="preserve">
          <source>Instead you have to use &lt;a href=&quot;../global_objects/object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/object/entries&quot;&gt;&lt;code&gt;Object.entries&lt;/code&gt;&lt;/a&gt;, to iterate over the properties or entries of an object.</source>
          <target state="translated">대신 객체의 속성 또는 항목을 반복 하려면 &lt;a href=&quot;../global_objects/object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/object/entries&quot;&gt; &lt;code&gt;Object.entries&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e0dc4bb2296425f8a0793107a400c064a277518e" translate="yes" xml:space="preserve">
          <source>Instead you need to use a correct &lt;a href=&quot;../operators/comparison_operators&quot;&gt;comparison operator&lt;/a&gt;. For example:</source>
          <target state="translated">대신 올바른 &lt;a href=&quot;../operators/comparison_operators&quot;&gt;비교 연산자&lt;/a&gt; 를 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7532357558d58b8bad52cc03601e93e8920a39f9" translate="yes" xml:space="preserve">
          <source>Instead you need to use a correct &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;comparison operator&lt;/a&gt;. For example:</source>
          <target state="translated">대신 올바른 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;비교 연산자&lt;/a&gt; 를 사용해야합니다. . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="26ecae46cb3e3f193194f48e69fb49562b84b075" translate="yes" xml:space="preserve">
          <source>Instead you need to use a plus sign for concatenation:</source>
          <target state="translated">대신 연결에 더하기 부호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="76292350e40ad23d7d412256c27e38fdaf0dd3a1" translate="yes" xml:space="preserve">
          <source>Instead you will need to use &lt;a href=&quot;../global_objects/string/indexof&quot;&gt;&lt;code&gt;String.prototype.indexOf()&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">대신 예를 들어 &lt;a href=&quot;../global_objects/string/indexof&quot;&gt; &lt;code&gt;String.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="44e2680b0a0c17af639aaffa8f68cf146a07b0f5" translate="yes" xml:space="preserve">
          <source>Instead, by using &lt;code&gt;matchAll&lt;/code&gt;, you get an iterator to use with the more convenient &lt;a href=&quot;../../statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../operators/spread_syntax&quot;&gt;&lt;code&gt;array spread&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../array/from&quot;&gt;&lt;code&gt;Array.from()&lt;/code&gt;&lt;/a&gt; constructs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e718841d850e49aba103de513cdaa93d90232f63" translate="yes" xml:space="preserve">
          <source>Instead, omit the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">대신 &lt;code&gt;var&lt;/code&gt; 키워드를 생략하십시오 .</target>
        </trans-unit>
        <trans-unit id="1757078b656e7c52f58307e98a78b7315354f37c" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;function&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;:</source>
          <target state="translated">대신 &lt;code&gt;def&lt;/code&gt; 대신 &lt;code&gt;function&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="599aca68c4dc962e7acfb73fd721311eb7302ad6" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;../operators/arithmetic_operators#Addition&quot;&gt;+ operator&lt;/a&gt;, a backslash, or &lt;a href=&quot;../template_literals&quot;&gt;template literals&lt;/a&gt;. The &lt;code&gt;+&lt;/code&gt; operator variant looks like this:</source>
          <target state="translated">대신 &lt;a href=&quot;../operators/arithmetic_operators#Addition&quot;&gt;+ 연산자&lt;/a&gt; , 백 슬래시 또는 &lt;a href=&quot;../template_literals&quot;&gt;템플릿 리터럴을 사용하십시오&lt;/a&gt; . &lt;code&gt;+&lt;/code&gt; 의 이 같은 운영자 변형 외모 :</target>
        </trans-unit>
        <trans-unit id="4feb09025f8ee92644b05f5d28aa4adb7bc126b7" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Addition&quot;&gt;+ operator&lt;/a&gt;, a backslash, or &lt;a href=&quot;../template_literals&quot;&gt;template literals&lt;/a&gt;. The &lt;code&gt;+&lt;/code&gt; operator variant looks like this:</source>
          <target state="translated">대신 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Addition&quot;&gt;+ 연산자&lt;/a&gt; , 백 슬래시 또는 &lt;a href=&quot;../template_literals&quot;&gt;템플릿 리터럴을 사용&lt;/a&gt; 하세요. &lt;code&gt;+&lt;/code&gt; 이 같은 운영자 변형 외모 :</target>
        </trans-unit>
        <trans-unit id="9fbc895f8d9aa2582102b700c1698001202a6907" translate="yes" xml:space="preserve">
          <source>Instead, use the&lt;a href=&quot;../global_objects/promise/resolve&quot;&gt; Promise.resolve()&lt;/a&gt; or &lt;a href=&quot;../global_objects/promise/reject&quot;&gt;Promise.reject()&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods&quot;&gt;static methods&lt;/a&gt;:</source>
          <target state="translated">대신 &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;Promise.resolve ()&lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/promise/reject&quot;&gt;Promise.reject () &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods&quot;&gt;정적 메서드를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="74dd3902502e084a4df1e4b02b2810f3e797cd06" translate="yes" xml:space="preserve">
          <source>Int16Array.int16Array</source>
          <target state="translated">Int16Array.int16Array</target>
        </trans-unit>
        <trans-unit id="0c9c8691e93fc3ce025dc71a355d7393d4850061" translate="yes" xml:space="preserve">
          <source>Int16Array.length</source>
          <target state="translated">Int16Array.length</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="b53556ea6ca360f680ca700a1230dca12e610dab" translate="yes" xml:space="preserve">
          <source>Int32Array.int32Array</source>
          <target state="translated">Int32Array.int32Array</target>
        </trans-unit>
        <trans-unit id="f26c93914721585282e868e1c2ebee5732099508" translate="yes" xml:space="preserve">
          <source>Int32Array.length</source>
          <target state="translated">Int32Array.length</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="ba334a0153c1765c52a5ebf35e29734b709f62d5" translate="yes" xml:space="preserve">
          <source>Int8Array.int8Array</source>
          <target state="translated">Int8Array.int8Array</target>
        </trans-unit>
        <trans-unit id="10b20c86b339c682e7d8ffa6aba23f3f2f096672" translate="yes" xml:space="preserve">
          <source>Int8Array.length</source>
          <target state="translated">Int8Array.length</target>
        </trans-unit>
        <trans-unit id="1105090c6c0a2edf92fa65478c36a65f5ad15cbc" translate="yes" xml:space="preserve">
          <source>Integer range for &lt;code&gt;Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; 정수 범위</target>
        </trans-unit>
        <trans-unit id="1d12bfc6efb01cb013ad7062520bad116239a06a" translate="yes" xml:space="preserve">
          <source>Integer range for Number</source>
          <target state="translated">숫자의 정수 범위</target>
        </trans-unit>
        <trans-unit id="c73bb4b5b8345a476d2718ae49ba14176bceb702" translate="yes" xml:space="preserve">
          <source>Integer specifying a limit on the number of splits to be found. The &lt;code&gt;[@@split]()&lt;/code&gt; method still splits on every match of &lt;code&gt;this&lt;/code&gt; RegExp pattern (or, in the Syntax above, &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt;), until the number of split items match the &lt;code&gt;&lt;var&gt;limit&lt;/var&gt;&lt;/code&gt; or the string falls short of &lt;code&gt;this&lt;/code&gt; pattern.</source>
          <target state="translated">찾을 분할 수에 대한 제한을 지정하는 정수입니다. &lt;code&gt;[@@split]()&lt;/code&gt; 메소드는 여전히 모든 매치에 분할 &lt;code&gt;this&lt;/code&gt; (위의 구문 또는 정규식 패턴 &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt; 분할 아이템의 개수가 일치 할 때까지) &lt;code&gt;&lt;var&gt;limit&lt;/var&gt;&lt;/code&gt; 또는 문자열 단락의 하강 &lt;code&gt;this&lt;/code&gt; 패턴.</target>
        </trans-unit>
        <trans-unit id="7c58c51c392fd6e958ce0e7867611f13bdeb40ff" translate="yes" xml:space="preserve">
          <source>Integer specifying a limit on the number of splits to be found. When this parameter is provided, the &lt;code&gt;split()&lt;/code&gt; method splits the string at each occurrence of the specified &lt;code&gt;separator&lt;/code&gt; but stops when &lt;code&gt;limit&lt;/code&gt; entries have been placed into the array. It may still contain fewer entries than &lt;code&gt;limit&lt;/code&gt; if the end of the string is reached before the specified limit is reached. The left-over text is not returned in the new array.</source>
          <target state="translated">찾을 분할 수에 대한 제한을 지정하는 정수입니다. 이 매개 변수가 제공되면 &lt;code&gt;split()&lt;/code&gt; 메소드는 지정된 &lt;code&gt;separator&lt;/code&gt; 가 나타날 때 마다 문자열을 분할 하지만 &lt;code&gt;limit&lt;/code&gt; 항목이 배열에 배치 되면 중지됩니다 . 지정된 한계에 도달하기 전에 문자열의 끝에 &lt;code&gt;limit&lt;/code&gt; 하면 여전히 한계 보다 적은 수의 항목을 포함 할 수 있습니다 . 남은 텍스트는 새 배열에 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f9b7d1768a1e02150ecacea6dc02e42357f890" translate="yes" xml:space="preserve">
          <source>Integer value representing the day of the month.</source>
          <target state="translated">월의 일을 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="2a6db6285e2f46e28c696a0f07cb580eee07e0b6" translate="yes" xml:space="preserve">
          <source>Integer value representing the day of the month. The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bcbe074de1314a8090bd96f91252df74c70b0e7" translate="yes" xml:space="preserve">
          <source>Integer value representing the hour of the day.</source>
          <target state="translated">하루 중 시간을 나타내는 정수 값.</target>
        </trans-unit>
        <trans-unit id="6a92ec5d33817f2d3eb3f1246ff89042bc00c1f4" translate="yes" xml:space="preserve">
          <source>Integer value representing the hour of the day. The default is &lt;code&gt;0&lt;/code&gt; (midnight).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cf13846246cef5d1c62df7a0b15451169bda90" translate="yes" xml:space="preserve">
          <source>Integer value representing the millisecond segment of a time.</source>
          <target state="translated">시간의 밀리 초 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="ca334588231b02151923da985b15d0517f7044d8" translate="yes" xml:space="preserve">
          <source>Integer value representing the millisecond segment of a time. The default is &lt;code&gt;0&lt;/code&gt; milliseconds past the second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241a7a4eb2efe8cc61b6dd45dbfef2428df56460" translate="yes" xml:space="preserve">
          <source>Integer value representing the minute segment of a time.</source>
          <target state="translated">시간의 분 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="c55b1b23638822b002f872ef1399c1dce7c43bce" translate="yes" xml:space="preserve">
          <source>Integer value representing the minute segment of a time. The default is &lt;code&gt;0&lt;/code&gt; minutes past the hour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be02731127495b3b13396f2468f942ddd732796e" translate="yes" xml:space="preserve">
          <source>Integer value representing the month, beginning with 0 for January to 11 for December.</source>
          <target state="translated">월을 나타내는 정수 값으로, 1 월은 0부터 12 월까지는 11로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ec6061d76ffe3bdd32f9a9b9467335359184763f" translate="yes" xml:space="preserve">
          <source>Integer value representing the month, beginning with &lt;code&gt;0&lt;/code&gt; for January to &lt;code&gt;11&lt;/code&gt; for December.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbce99ca6771dbb1b8cb6588d10e62f7b1e9d10d" translate="yes" xml:space="preserve">
          <source>Integer value representing the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored (Unix Epoch; but consider that most Unix timestamp functions count in seconds).</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC 이후 윤초를 무시하고 밀리 초 수를 나타내는 정수 값 (Unix Epoch; 대부분의 Unix 타임 스탬프 함수는 초 단위로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="83e39e42a0a037d33ecb1c8a3c5eea08f0b99cf3" translate="yes" xml:space="preserve">
          <source>Integer value representing the second segment of a time.</source>
          <target state="translated">시간의 두 번째 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="990d07e9428e4e06b28d65c12610c0be2bea1de5" translate="yes" xml:space="preserve">
          <source>Integer value representing the second segment of a time. The default is &lt;code&gt;0&lt;/code&gt; seconds past the minute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32cf3539f6dcc069f8ad832c4717fc44eb3a7ac" translate="yes" xml:space="preserve">
          <source>Integer value representing the year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db4d14c7dc17afe340582090d55b7545c1b3eb0" translate="yes" xml:space="preserve">
          <source>Integer value representing the year. Values from 0 to 99 map to the years 1900 to 1999. See the &lt;a href=&quot;#Two_digit_years_map_to_1900_-_1999&quot;&gt;example below&lt;/a&gt;.</source>
          <target state="translated">연도를 나타내는 정수 값. 0에서 99 사이의 값은 1900에서 1999 년으로 매핑 &lt;a href=&quot;#Two_digit_years_map_to_1900_-_1999&quot;&gt;됩니다&lt;/a&gt; . 아래 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d19aea53b7c71a47e68c4a4db3ee1abb16b291" translate="yes" xml:space="preserve">
          <source>Integers with arbitrary precision: &lt;a href=&quot;../bigint&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71c075259752a2939bdd6faa004b91f60e192a1" translate="yes" xml:space="preserve">
          <source>Integers with arbitrary precision: &lt;a href=&quot;bigint&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">임의 정밀도의 정수 : &lt;a href=&quot;bigint&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a04591ed8cd35a609e53970d909ddd65bdd9925c" translate="yes" xml:space="preserve">
          <source>Interceptions</source>
          <target state="translated">Interceptions</target>
        </trans-unit>
        <trans-unit id="d68324d2f9cb7da0deed981cf558925381f4aba7" translate="yes" xml:space="preserve">
          <source>InternalError: too much recursion</source>
          <target state="translated">InternalError : 너무 많은 재귀</target>
        </trans-unit>
        <trans-unit id="6e5a8eb19bb596773f3a9570412498f21d3b1c30" translate="yes" xml:space="preserve">
          <source>Internally calls &lt;code&gt;Promise.prototype.then&lt;/code&gt; on the object upon which is called, passing the parameters &lt;code&gt;undefined&lt;/code&gt; and the &lt;code&gt;onRejected&lt;/code&gt; handler received; then returns the value of that call (which is a &lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">내부적으로 호출 되는 객체에서 &lt;code&gt;Promise.prototype.then&lt;/code&gt; 을 호출 하여 매개 변수가 &lt;code&gt;undefined&lt;/code&gt; 않고 수신 된 &lt;code&gt;onRejected&lt;/code&gt; 핸들러를 전달합니다. 그런 다음 해당 호출의 값을 반환합니다 ( &lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a01e8a33df41e96537ebd6e4fa7dbce634312754" translate="yes" xml:space="preserve">
          <source>Internally calls &lt;code&gt;Promise.prototype.then&lt;/code&gt; on the object upon which it was called, passing the parameters &lt;code&gt;undefined&lt;/code&gt; and the received &lt;code&gt;&lt;var&gt;onRejected&lt;/var&gt;&lt;/code&gt; handler. Returns the value of that call, which is a &lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Promise.prototype.then&lt;/code&gt; 을 호출 된 객체에서 호출하여 &lt;code&gt;undefined&lt;/code&gt; 매개 변수 와 수신 된 &lt;code&gt;&lt;var&gt;onRejected&lt;/var&gt;&lt;/code&gt; 핸들러 를 전달 합니다. &lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 인 해당 호출의 값을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">인터넷 익스플로러</target>
        </trans-unit>
        <trans-unit id="28e5441a7bdfedada4425bf69cae741f24bb602b" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 implemented a &lt;code&gt;Object.defineProperty()&lt;/code&gt; method that could &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx&quot;&gt;only be used on DOM objects&lt;/a&gt;. A few things need to be noted:</source>
          <target state="translated">Internet Explorer 8 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx&quot;&gt;은 DOM 객체에서만 사용할&lt;/a&gt; 수 있는 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 메소드를 구현했습니다 . 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5790aa85105b2f707aa89140c69ddea48c4d6e3e" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 specific notes</source>
          <target state="translated">Internet Explorer 8 관련 참고 사항</target>
        </trans-unit>
        <trans-unit id="4138084098c5ad0c43aa900db4e2093e03cbf674" translate="yes" xml:space="preserve">
          <source>Interrupt a function</source>
          <target state="translated">기능 중단</target>
        </trans-unit>
        <trans-unit id="148008a6c97111d9a4baac98fac041378bd84ebd" translate="yes" xml:space="preserve">
          <source>Intl</source>
          <target state="translated">Intl</target>
        </trans-unit>
        <trans-unit id="9fec477cb4348073d98179a98fcd20fd16c1b51a" translate="yes" xml:space="preserve">
          <source>Intl Plural Rules Draft</source>
          <target state="translated">국제 복수 규칙 초안</target>
        </trans-unit>
        <trans-unit id="691a439705b6454b10075bcadfd1eba82e0809bf" translate="yes" xml:space="preserve">
          <source>Intl.Collator</source>
          <target state="translated">Intl.Collator</target>
        </trans-unit>
        <trans-unit id="94effe562809ae6b476c47a05969b7d808a1b064" translate="yes" xml:space="preserve">
          <source>Intl.Collator.prototype</source>
          <target state="translated">Intl.Collator.prototype</target>
        </trans-unit>
        <trans-unit id="0b377b74eeb9851f1e25bb146f28a1f051d72446" translate="yes" xml:space="preserve">
          <source>Intl.Collator.supportedLocalesOf</source>
          <target state="translated">Intl.Collator.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="91770c02e353a04997b7e8198eb99e13c00635b2" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat</source>
          <target state="translated">Intl.DateTimeFormat</target>
        </trans-unit>
        <trans-unit id="53b8e3b29a45365d097c861e02a57b921194fd5a" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.formatRange&lt;br/&gt;&lt;small&gt;The definition of 'formatRange()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a480f494bd8bc90d0c95105b3580be8e208e1c" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.formatRange&lt;br/&gt;&lt;small&gt;The definition of 'formatRangeToParts()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f720195e10d50c2f6666c80ded510eb7e91ee56" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.prototype</source>
          <target state="translated">Intl.DateTimeFormat.prototype</target>
        </trans-unit>
        <trans-unit id="8c35054313946594df544a441084c18f481dc900" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.supportedLocalesOf</source>
          <target state="translated">Intl.DateTimeFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="9b7d88b2642ca09451d39add3790c1cc14a36aa2" translate="yes" xml:space="preserve">
          <source>Intl.DisplayNames&lt;br/&gt;&lt;small&gt;The definition of 'DisplayNames' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94b5310b4384eb20295eeaf505395a6d991d83f" translate="yes" xml:space="preserve">
          <source>Intl.DisplayNames&lt;br/&gt;&lt;small&gt;The definition of 'of()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662f14f46884aa95834a1588d40549e8d3ef42f3" translate="yes" xml:space="preserve">
          <source>Intl.DisplayNames&lt;br/&gt;&lt;small&gt;The definition of 'resolvedOptions()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce74ef0e2026bcb703e439098d39a9c66944cfe" translate="yes" xml:space="preserve">
          <source>Intl.DisplayNames&lt;br/&gt;&lt;small&gt;The definition of 'supportedLocalesOf()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7d60aefef8890739b8a0d5560eb4be9242f7aa" translate="yes" xml:space="preserve">
          <source>Intl.DisplayNames&lt;br/&gt;&lt;small&gt;The definition of 'the Intl.DisplayNames constructor' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10690905177146e152defb42870864c9ae82485e" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'ListFormat' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3415ade088a57e89a79047d0290559751e61d1e1" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'ListFormat()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15efe36f8e2851508049e320d433a7b34a9ff35" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'format()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fb80ad846ab7bc465f233a69fbf968aea0e12e" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'formatToParts()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6831e2799cb40587c25cec0c3ee885ef3a1521df" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'resolvedOptions()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2f955c3652989863016f35127b98b5b16cf423" translate="yes" xml:space="preserve">
          <source>Intl.ListFormat&lt;br/&gt;&lt;small&gt;The definition of 'supportedLocalesOf()' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7267adddab78d6c517f39c7fbcf74e8abc940038" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat</source>
          <target state="translated">Intl.NumberFormat</target>
        </trans-unit>
        <trans-unit id="3d26a08d98ebcd5d28de6ddf3c2bd9cb829194a0" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat.prototype</source>
          <target state="translated">Intl.NumberFormat.prototype</target>
        </trans-unit>
        <trans-unit id="607ba4bc780b223d3fd5127334576ba2f8e0667c" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat.supportedLocalesOf</source>
          <target state="translated">Intl.NumberFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="2ae330bc0409789151c5dbe293103be5c2738356" translate="yes" xml:space="preserve">
          <source>Intl.collator</source>
          <target state="translated">Intl.collator</target>
        </trans-unit>
        <trans-unit id="37a2147bca7a81e445be254639695b2d36e9dab4" translate="yes" xml:space="preserve">
          <source>Intl.collator.Collator</source>
          <target state="translated">Intl.collator.Collator</target>
        </trans-unit>
        <trans-unit id="66c7f57d39868752ebca01af0acb783a59f9ca74" translate="yes" xml:space="preserve">
          <source>Intl.collator.compare</source>
          <target state="translated">Intl.collator.compare</target>
        </trans-unit>
        <trans-unit id="9236ad9d72ffabd8ab8b1fdd93b3ae2fe0889b2d" translate="yes" xml:space="preserve">
          <source>Intl.collator.resolvedOptions</source>
          <target state="translated">Intl.collator.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="2eff65bc6ac8aa78a77d1e6eac11169f6ab1c433" translate="yes" xml:space="preserve">
          <source>Intl.collator.supportedLocalesOf</source>
          <target state="translated">Intl.collator.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="9caee312952f9b273482708a3e2762010e2777b1" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat</source>
          <target state="translated">Intl.dateTimeFormat</target>
        </trans-unit>
        <trans-unit id="af147f1d60eb72b1058536312710d721d237f528" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.DateTimeFormat</source>
          <target state="translated">Intl.dateTimeFormat.DateTimeFormat</target>
        </trans-unit>
        <trans-unit id="ac6e598b10bdd85f1d5e69697d5f02158893d3a3" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.format</source>
          <target state="translated">Intl.dateTimeFormat.format</target>
        </trans-unit>
        <trans-unit id="14060908061e54d402820099ffd049487afb6f1d" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.formatRange</source>
          <target state="translated">Intl.dateTimeFormat.formatRange</target>
        </trans-unit>
        <trans-unit id="460f3dc6b35b7da8c7a513f341e23ca5ff9bf3ff" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.formatRangeToParts</source>
          <target state="translated">Intl.dateTimeFormat.formatRangeToParts</target>
        </trans-unit>
        <trans-unit id="79234597f72df02f1a94d543bde865a99bd7d684" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.formatToParts</source>
          <target state="translated">Intl.dateTimeFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="904c6383f067aec078a7b1768309a99adb54dfca" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.resolvedOptions</source>
          <target state="translated">Intl.dateTimeFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="f8a740d0eafa0ee07ba2e7c434f454b6b8bc7428" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.supportedLocalesOf</source>
          <target state="translated">Intl.dateTimeFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="6d237b991b0c3257a2fbaef02e081940bc0aae9a" translate="yes" xml:space="preserve">
          <source>Intl.displayNames</source>
          <target state="translated">Intl.displayNames</target>
        </trans-unit>
        <trans-unit id="69700f39c952d99d6ae7f02241c9f9cb5140a715" translate="yes" xml:space="preserve">
          <source>Intl.displayNames.DisplayNames</source>
          <target state="translated">Intl.displayNames.DisplayNames</target>
        </trans-unit>
        <trans-unit id="32b575e92ce4f4812cf3fb180702341bc4da9ee1" translate="yes" xml:space="preserve">
          <source>Intl.displayNames.of</source>
          <target state="translated">Intl.displayNames.of</target>
        </trans-unit>
        <trans-unit id="b86091119aaf39a52f1f0f5a0d2c3f547864c1ad" translate="yes" xml:space="preserve">
          <source>Intl.displayNames.resolvedOptions</source>
          <target state="translated">Intl.displayNames.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="69727f4fd19fd0407728cc227a1aeb300024545c" translate="yes" xml:space="preserve">
          <source>Intl.displayNames.supportedLocalesOf</source>
          <target state="translated">Intl.displayNames.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="091fff844313d48a74de1aab92c22d59e6263ad4" translate="yes" xml:space="preserve">
          <source>Intl.getCanonicalLocales</source>
          <target state="translated">Intl.getCanonicalLocales</target>
        </trans-unit>
        <trans-unit id="a906112163b80fea73f2be42d39dcead37da1403" translate="yes" xml:space="preserve">
          <source>Intl.listFormat</source>
          <target state="translated">Intl.listFormat</target>
        </trans-unit>
        <trans-unit id="6c15036de402e442ffa3a29ae9b2ab02496ee004" translate="yes" xml:space="preserve">
          <source>Intl.listFormat.ListFormat</source>
          <target state="translated">Intl.listFormat.ListFormat</target>
        </trans-unit>
        <trans-unit id="8ce65e2c1e95e19ecaed09979db016b070b04a26" translate="yes" xml:space="preserve">
          <source>Intl.listFormat.format</source>
          <target state="translated">Intl.listFormat.format</target>
        </trans-unit>
        <trans-unit id="da88e49fb21512b04845c41bab7e09b1b7d195fa" translate="yes" xml:space="preserve">
          <source>Intl.listFormat.formatToParts</source>
          <target state="translated">Intl.listFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="f62ffd3d29eb39589268510804510a36bcd55905" translate="yes" xml:space="preserve">
          <source>Intl.listFormat.resolvedOptions</source>
          <target state="translated">Intl.listFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="e4e0224dd7998a9842e6edd21a4692a79b929faf" translate="yes" xml:space="preserve">
          <source>Intl.listFormat.supportedLocalesOf</source>
          <target state="translated">Intl.listFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="08561a48a489f4f7f6ee56c9a6f187e074ffdb79" translate="yes" xml:space="preserve">
          <source>Intl.locale</source>
          <target state="translated">Intl.locale</target>
        </trans-unit>
        <trans-unit id="fa032c5ea1238cadc23a1168dfd04e1a043db3fe" translate="yes" xml:space="preserve">
          <source>Intl.locale.Locale</source>
          <target state="translated">Intl.locale.Locale</target>
        </trans-unit>
        <trans-unit id="1a875d1e6fb3e5f5a46a514d4470577e00c67940" translate="yes" xml:space="preserve">
          <source>Intl.locale.baseName</source>
          <target state="translated">Intl.locale.baseName</target>
        </trans-unit>
        <trans-unit id="1aa888bea57baaf2a37d6236dfb67c007b8f6634" translate="yes" xml:space="preserve">
          <source>Intl.locale.calendar</source>
          <target state="translated">Intl.locale.calendar</target>
        </trans-unit>
        <trans-unit id="29e6d2d488eedec82f01fea961b9c9590f0d4073" translate="yes" xml:space="preserve">
          <source>Intl.locale.caseFirst</source>
          <target state="translated">Intl.locale.caseFirst</target>
        </trans-unit>
        <trans-unit id="308af03ef6a3583cd5cccfa55381094ce4e3c3c2" translate="yes" xml:space="preserve">
          <source>Intl.locale.collation</source>
          <target state="translated">Intl.locale.collation</target>
        </trans-unit>
        <trans-unit id="87e8ae3048ca020c3e4413b58b69ffda90271325" translate="yes" xml:space="preserve">
          <source>Intl.locale.hourCycle</source>
          <target state="translated">Intl.locale.hourCycle</target>
        </trans-unit>
        <trans-unit id="07e3a47c0986027f4022247f753d1582a33fb61a" translate="yes" xml:space="preserve">
          <source>Intl.locale.language</source>
          <target state="translated">Intl.locale.language</target>
        </trans-unit>
        <trans-unit id="6038b6b47b5bbbcf2c4c4278eca304afd2fa5932" translate="yes" xml:space="preserve">
          <source>Intl.locale.maximize</source>
          <target state="translated">Intl.locale.maximize</target>
        </trans-unit>
        <trans-unit id="8a57daabe28cd8ee22749029bac37f3bf8428d98" translate="yes" xml:space="preserve">
          <source>Intl.locale.minimize</source>
          <target state="translated">Intl.locale.minimize</target>
        </trans-unit>
        <trans-unit id="56416fbb3e0021a60979a3602afede3388c7a0fc" translate="yes" xml:space="preserve">
          <source>Intl.locale.numberingSystem</source>
          <target state="translated">Intl.locale.numberingSystem</target>
        </trans-unit>
        <trans-unit id="4d3b740a61e1ac7474a9cd43de223a5ace0261f8" translate="yes" xml:space="preserve">
          <source>Intl.locale.numeric</source>
          <target state="translated">Intl.locale.numeric</target>
        </trans-unit>
        <trans-unit id="f61448222f4cca64b198d65e7d6ae5292c46ed08" translate="yes" xml:space="preserve">
          <source>Intl.locale.region</source>
          <target state="translated">Intl.locale.region</target>
        </trans-unit>
        <trans-unit id="2020f57e6cf55934e1c82125e12e990823c866a0" translate="yes" xml:space="preserve">
          <source>Intl.locale.script</source>
          <target state="translated">Intl.locale.script</target>
        </trans-unit>
        <trans-unit id="1365bbc7432f7b058db80e95fbd6cc1fae7b7260" translate="yes" xml:space="preserve">
          <source>Intl.locale.toString</source>
          <target state="translated">Intl.locale.toString</target>
        </trans-unit>
        <trans-unit id="00c49a3f60c71eb0652e150e70eda353d6e3d28f" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat</source>
          <target state="translated">Intl.numberFormat</target>
        </trans-unit>
        <trans-unit id="fac7fc610981ccf14fdd96f89dc96b9c670b6546" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.NumberFormat</source>
          <target state="translated">Intl.numberFormat.NumberFormat</target>
        </trans-unit>
        <trans-unit id="461a6cbec9e5f4d76bf0dcce35f41b5fae08133d" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.format</source>
          <target state="translated">Intl.numberFormat.format</target>
        </trans-unit>
        <trans-unit id="0244be6b0c3a6a82ba4428fb87fd56189351f3d2" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.formatToParts</source>
          <target state="translated">Intl.numberFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="e2d465b50d59450e9d5c5b8344aa05c1fd17b8ed" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.resolvedOptions</source>
          <target state="translated">Intl.numberFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="21062d29d6112b3f7f85af6fb38e12691e3f11a1" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.supportedLocalesOf</source>
          <target state="translated">Intl.numberFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="430b53d7d14202a263350cdd04ff07e88211d747" translate="yes" xml:space="preserve">
          <source>Intl.pluralRules</source>
          <target state="translated">Intl.pluralRules</target>
        </trans-unit>
        <trans-unit id="fd2f22fa4c29c3c36614cdf023556b97cd569b4d" translate="yes" xml:space="preserve">
          <source>Intl.pluralRules.PluralRules</source>
          <target state="translated">Intl.pluralRules.PluralRules</target>
        </trans-unit>
        <trans-unit id="4f59f59b29c8388f6de17e37ec0528ba37e2cff6" translate="yes" xml:space="preserve">
          <source>Intl.pluralRules.resolvedOptions</source>
          <target state="translated">Intl.pluralRules.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="41db67d9ea99fc95bedc6d9e5b890fe25d8909d9" translate="yes" xml:space="preserve">
          <source>Intl.pluralRules.select</source>
          <target state="translated">Intl.pluralRules.select</target>
        </trans-unit>
        <trans-unit id="c4a92c0c0d272b10504443d2fd4f5325c08e376a" translate="yes" xml:space="preserve">
          <source>Intl.pluralRules.supportedLocalesOf</source>
          <target state="translated">Intl.pluralRules.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="7fd24315668dbf01040e1a9bb075a97317179a27" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat</source>
          <target state="translated">Intl.relativeTimeFormat</target>
        </trans-unit>
        <trans-unit id="d9d49968b9259489052d18289280b6822771b019" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat.RelativeTimeFormat</source>
          <target state="translated">Intl.relativeTimeFormat.RelativeTimeFormat</target>
        </trans-unit>
        <trans-unit id="ac75dc9aba67385a4289991c18f95c80f8dab62b" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat.format</source>
          <target state="translated">Intl.relativeTimeFormat.format</target>
        </trans-unit>
        <trans-unit id="6a31de526e47ad783339c29abd1107d416f82ce0" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat.formatToParts</source>
          <target state="translated">Intl.relativeTimeFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="e6f9c5f560ca141d9484c53dffaa38190f162775" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat.resolvedOptions</source>
          <target state="translated">Intl.relativeTimeFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="66e80d0cf0bf911556166f07120b2b030cb869c6" translate="yes" xml:space="preserve">
          <source>Intl.relativeTimeFormat.supportedLocalesOf</source>
          <target state="translated">Intl.relativeTimeFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="0f821397d0f52bfe785a3b5ae0994d5665808b0d" translate="yes" xml:space="preserve">
          <source>Introduced in Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30). Functions declared in the function body cannot be referred to inside the outer function]s default parameters. If attempted, a &lt;a href=&quot;../global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt; is thrown. Default parameters are always executed first, so function declarations inside the function body evaluate afterwards.</source>
          <target state="translated">Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30)에 도입되었습니다. 함수 본문에 선언 된 함수는 외부 함수의 기본 매개 변수 내부에서 참조 할 수 없습니다. 시도하면 &lt;a href=&quot;../global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 기본 매개 변수는 항상 먼저 실행되므로 함수 본문 내부의 함수 선언은 나중에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3fbd2398c4e535f509ed566c2214525cbf5078" translate="yes" xml:space="preserve">
          <source>Introduction to Object-Oriented JavaScript</source>
          <target state="translated">객체 지향 JavaScript 소개</target>
        </trans-unit>
        <trans-unit id="8e006f5d6c51e5f500e63738a7a4e5ab708ef28b" translate="yes" xml:space="preserve">
          <source>Introduction to source maps &amp;ndash; HTML5 rocks</source>
          <target state="translated">소스 맵 소개 &amp;ndash; HTML5 rock</target>
        </trans-unit>
        <trans-unit id="685d8b8a451d5c25429cf00e02a70396ec23ea94" translate="yes" xml:space="preserve">
          <source>Introduction: &lt;a href=&quot;http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;The ECMAScript Internationalization API&lt;/a&gt;</source>
          <target state="translated">소개 : &lt;a href=&quot;http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;ECMAScript 국제화 API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43c9754a8861b7fd0f8dd51ab243bdb722045151" translate="yes" xml:space="preserve">
          <source>Introduction: &lt;a href=&quot;https://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;The ECMAScript Internationalization API&lt;/a&gt;</source>
          <target state="translated">소개 : &lt;a href=&quot;https://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;ECMAScript 국제화 API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d94a1b20a86da8d8ef52d86140d5faa7244a1b37" translate="yes" xml:space="preserve">
          <source>Invalid &lt;code&gt;for-of&lt;/code&gt; loop</source>
          <target state="translated">잘못된 &lt;code&gt;for-of&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="660272f83ac71948bccc6b24478abcb5e8309a01" translate="yes" xml:space="preserve">
          <source>Invalid JavaScript identifier as a property name</source>
          <target state="translated">속성 이름으로 잘못된 JavaScript 식별자</target>
        </trans-unit>
        <trans-unit id="6cb64cdbd8ca48ac355e5ba934792e50b7b643a3" translate="yes" xml:space="preserve">
          <source>Invalid array length</source>
          <target state="translated">유효하지 않은 배열 길이</target>
        </trans-unit>
        <trans-unit id="2bb5db0093030ed959d9e116d255a162895d06b8" translate="yes" xml:space="preserve">
          <source>Invalid assignment left-hand side</source>
          <target state="translated">왼쪽의 잘못된 할당</target>
        </trans-unit>
        <trans-unit id="b7aa12cebc342348149a588c562fbe64f3283163" translate="yes" xml:space="preserve">
          <source>Invalid cases</source>
          <target state="translated">잘못된 경우</target>
        </trans-unit>
        <trans-unit id="9e0f593040b832479d554e779693995956176e29" translate="yes" xml:space="preserve">
          <source>Invalid const assignment</source>
          <target state="translated">잘못된 const 할당</target>
        </trans-unit>
        <trans-unit id="3f45d8ccffe75e10e46696189989b5121bdc235b" translate="yes" xml:space="preserve">
          <source>Invalid date</source>
          <target state="translated">잘못된 날짜</target>
        </trans-unit>
        <trans-unit id="1ee4d92944915ed61af938fd4b4fb38eb5ca730a" translate="yes" xml:space="preserve">
          <source>Invalid for-in initializer</source>
          <target state="translated">잘못된 초기화 프로그램</target>
        </trans-unit>
        <trans-unit id="a1afb0a15ce516af40f158e64da36cf6e02266c4" translate="yes" xml:space="preserve">
          <source>Invalid for-of initializer</source>
          <target state="translated">잘못된 초기화 프로그램</target>
        </trans-unit>
        <trans-unit id="a0a196b58c85a10ea9cf485d0b56fe28ac2f61a4" translate="yes" xml:space="preserve">
          <source>Invalid input:</source>
          <target state="translated">잘못된 입력:</target>
        </trans-unit>
        <trans-unit id="3a4b82ac678593606aa369204a68abe42e54f0ff" translate="yes" xml:space="preserve">
          <source>Invalid octal numbers</source>
          <target state="translated">잘못된 8 진수</target>
        </trans-unit>
        <trans-unit id="d6e64d0ec42180ad42843b3147e19fa8b02da721" translate="yes" xml:space="preserve">
          <source>Invalid redeclaration</source>
          <target state="translated">잘못된 재 선언</target>
        </trans-unit>
        <trans-unit id="3390616cafac7ff314d6aadaf20e48034cbb3314" translate="yes" xml:space="preserve">
          <source>Invariants</source>
          <target state="translated">Invariants</target>
        </trans-unit>
        <trans-unit id="4e1321c7e45e4c40761381b9b683387d488bf32f" translate="yes" xml:space="preserve">
          <source>Inverts the bits of its operand.</source>
          <target state="translated">피연산자의 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fd458722c8cfcbb53c39ea1f3c5645c09338076" translate="yes" xml:space="preserve">
          <source>Invoked through call or apply</source>
          <target state="translated">전화 또는 신청을 통해 호출</target>
        </trans-unit>
        <trans-unit id="32a22853078d6023f226d27e51d0b2a6e5b9ae81" translate="yes" xml:space="preserve">
          <source>Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.</source>
          <target state="translated">사용 가능한 디버깅 기능을 호출합니다. 디버깅 기능을 사용할 수 없으면이 명령문은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="546fbb50ff089e3855d79b13d86e4a369e5a842d" translate="yes" xml:space="preserve">
          <source>Invoking JavaScript &lt;code&gt;Date&lt;/code&gt; as a function (i.e., without the &lt;a href=&quot;../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator) will return a string representing the current date and time.</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; 를 함수로 호출하면 (즉, &lt;a href=&quot;../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자 없이 ) 현재 날짜와 시간을 나타내는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bc5e46ab780fcbc7794152fa6c4870b7d727aa2" translate="yes" xml:space="preserve">
          <source>Invoking strict mode</source>
          <target state="translated">엄격 모드 호출</target>
        </trans-unit>
        <trans-unit id="208ae9750e5d18010716a63f7a64c8864b8720b3" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;AsyncFunction&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;AsyncFunction&lt;/code&gt; 의 하십시오 (사용하지 않고 함수 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="1f49636aa3cddb53862e739e488ae9fb9c6c0139" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;Function&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;Function&lt;/code&gt; (없이 함수로서 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="a09fdf87d82db4d13b9fdd5d76e4b7e7f19d7fac" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;GeneratorFunction&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;GeneratorFunction&lt;/code&gt; 의 하십시오 (사용하지 않고 함수 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="b4cd7f60b4d184101c2a6bf4b757b7b2b30bac77" translate="yes" xml:space="preserve">
          <source>Is a generator object an iterator or an iterable?</source>
          <target state="translated">생성기 객체는 반복자입니까, 반복 가능한가요?</target>
        </trans-unit>
        <trans-unit id="0b0d56ef77469a2f756007c6a62fa7926b600b31" translate="yes" xml:space="preserve">
          <source>Is a stateful, executable instance of a &lt;a href=&quot;webassembly/module&quot;&gt;WebAssembly.Module&lt;/a&gt;</source>
          <target state="translated">Is a stateful, executable instance of a &lt;a href=&quot;webassembly/module&quot;&gt;WebAssembly.Module&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="690a13704ccda7c99a1f2a9585cf62a8ecc1ef9e" translate="yes" xml:space="preserve">
          <source>Is the same function as the &lt;code&gt;values()&lt;/code&gt; function and returns a new &lt;code&gt;Iterator&lt;/code&gt; object that contains the values for each element in the &lt;code&gt;Set&lt;/code&gt; object in insertion order.</source>
          <target state="translated">&lt;code&gt;values()&lt;/code&gt; 함수와 동일한 함수 이며 &lt;code&gt;Set&lt;/code&gt; 객체의 각 요소에 대한 값을 삽입 순서대로 포함 하는 새 &lt;code&gt;Iterator&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="85e72c54a7bd7b359f951ce0cec2a49a4cc1a1e9" translate="yes" xml:space="preserve">
          <source>Islamic calendar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6c9b7721983d028dd6b6835424ec02386ee0ea" translate="yes" xml:space="preserve">
          <source>Islamic calendar, Saudi Arabia sighting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5234d4e22a68028d391c6d5b36a0c601c53b1db" translate="yes" xml:space="preserve">
          <source>Islamic calendar, Umm al-Qura</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8b677d93215863df058f74ef8e8d0b7e1ea5cd" translate="yes" xml:space="preserve">
          <source>Islamic calendar, tabular (intercalary years [2,5,7,10,13,16,18,21,24,26,29] - astronomical epoch)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21fcea05d1e7a967786aa80619b946ca2d58671" translate="yes" xml:space="preserve">
          <source>Islamic calendar, tabular (intercalary years [2,5,7,10,13,16,18,21,24,26,29] - civil epoch)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237c366b14d4ac2c7ac8dcc981e25cf07610f224" translate="yes" xml:space="preserve">
          <source>Issue with &lt;code&gt;JSON.stringify()&lt;/code&gt; when serializing circular references</source>
          <target state="translated">순환 참조를 직렬화 할 때 &lt;code&gt;JSON.stringify()&lt;/code&gt; 문제</target>
        </trans-unit>
        <trans-unit id="0fe883a4a2cebd3337cac0b6f63f321bc9cfbcf4" translate="yes" xml:space="preserve">
          <source>Issue with JSON.stringify() when serializing circular references</source>
          <target state="translated">Issue with JSON.stringify() when serializing circular references</target>
        </trans-unit>
        <trans-unit id="5600fcf5422fc9dfe3b3d78fa586442113fe282e" translate="yes" xml:space="preserve">
          <source>Issue with plain &lt;code&gt;JSON.stringify&lt;/code&gt; for use as JavaScript</source>
          <target state="translated">JavaScript로 사용하기 위해 일반 &lt;code&gt;JSON.stringify&lt;/code&gt; 관련 문제</target>
        </trans-unit>
        <trans-unit id="cfecb0665bc38a3d23f86eec2febbf45d4496177" translate="yes" xml:space="preserve">
          <source>Issue with plain JSON.stringify for use as JavaScript</source>
          <target state="translated">Issue with plain JSON.stringify for use as JavaScript</target>
        </trans-unit>
        <trans-unit id="b5f064f8234fa60048c058abe8b49b99a3a6d87a" translate="yes" xml:space="preserve">
          <source>It accepts three arguments:</source>
          <target state="translated">It accepts three arguments:</target>
        </trans-unit>
        <trans-unit id="41203c0da0da22d05561ac067143a1455ee0fac2" translate="yes" xml:space="preserve">
          <source>It allows the code in the string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; to be minified.</source>
          <target state="translated">It allows the code in the string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; to be minified.</target>
        </trans-unit>
        <trans-unit id="00081e6a2ee8da25b0c2fa487f2293a0e3a9300f" translate="yes" xml:space="preserve">
          <source>It also avoids a problem if the magnitude of your numbers is huge. The largest number you can represent in JS's double floats is &lt;code&gt;Number.MAX_VALUE =&amp;nbsp;1.797...e+308&lt;/code&gt; . If your numbers are larger than about 1e154, taking the square of them will result in Infinity, demolishing your results. For example, &lt;code&gt;Math.sqrt(1e200*1e200 + 1e200*1e200) =&amp;nbsp;Infinity&lt;/code&gt; . If you use &lt;code&gt;hypot()&lt;/code&gt; instead, you get a good answer &lt;code&gt;Math.hypot(1e200, 1e200) =&amp;nbsp;1.4142...e+200&lt;/code&gt; . This is also true with very small numbers. &lt;code&gt;Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) =&amp;nbsp;0&lt;/code&gt;, but &lt;code&gt;Math.hypot(1e-200, 1e-200) =&lt;/code&gt;&lt;code&gt;1.4142...e-200&lt;/code&gt;, a good answer.</source>
          <target state="translated">또한 숫자의 크기가 크면 문제를 피할 수 있습니다. JS의 double float에서 나타낼 수있는 가장 큰 숫자는 &lt;code&gt;Number.MAX_VALUE =&amp;nbsp;1.797...e+308&lt;/code&gt; 입니다. 숫자가 약 1e154보다 큰 경우, 제곱을 취하면 무한대가되고 결과가 철거됩니다. 예를 들어 &lt;code&gt;Math.sqrt(1e200*1e200 + 1e200*1e200) =&amp;nbsp;Infinity&lt;/code&gt; 입니다. &lt;code&gt;hypot()&lt;/code&gt; 대신 사용 하면 &lt;code&gt;Math.hypot(1e200, 1e200) =&amp;nbsp;1.4142...e+200&lt;/code&gt; 좋은 대답을 얻습니다 . 이것은 매우 작은 숫자에서도 마찬가지입니다. &lt;code&gt;Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) =&amp;nbsp;0&lt;/code&gt; 이지만 &lt;code&gt;Math.hypot(1e-200, 1e-200) =&lt;/code&gt; &lt;code&gt;1.4142...e-200&lt;/code&gt; , 좋은 대답입니다.</target>
        </trans-unit>
        <trans-unit id="e475453a8d4616b44db70ed2898a74507d1d08d9" translate="yes" xml:space="preserve">
          <source>It also means that variables declared inside the function body using &lt;code&gt;var&lt;/code&gt; will mask parameters of the same name, instead of the usual behavior of duplicate &lt;code&gt;var&lt;/code&gt; declarations having no effect.</source>
          <target state="translated">It also means that variables declared inside the function body using &lt;code&gt;var&lt;/code&gt; will mask parameters of the same name, instead of the usual behavior of duplicate &lt;code&gt;var&lt;/code&gt; declarations having no effect.</target>
        </trans-unit>
        <trans-unit id="046a89c09b8e69d7519433ee5f4799dde2a0f2f5" translate="yes" xml:space="preserve">
          <source>It also works when you put &lt;code&gt;default&lt;/code&gt; before all other &lt;code&gt;case&lt;/code&gt;s.</source>
          <target state="translated">It also works when you put &lt;code&gt;default&lt;/code&gt; before all other &lt;code&gt;case&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5c1ebb7ab8937cf2664e8c849a22e22823d62684" translate="yes" xml:space="preserve">
          <source>It also works when you put default before all other cases.</source>
          <target state="translated">다른 모든 경우보다 기본값을 설정하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="898d6cff7f0d4ac02e7c8c72fea0f382f5f1a39e" translate="yes" xml:space="preserve">
          <source>It attempted to call a value from a function, but the value is not actually a function. Some code expects you to provide a function, but that didn't happen.</source>
          <target state="translated">함수에서 값을 호출하려고 시도했지만 실제로는 함수가 아닙니다. 일부 코드에서는 함수를 제공 할 것으로 예상하지만 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2adb77288fe8601577f558b0c9e3989d99e0757" translate="yes" xml:space="preserve">
          <source>It can be a Function or other non-primitive value.</source>
          <target state="translated">함수 또는 다른 기본이 아닌 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48068ce741966c4d12a0279fea298e01c807447" translate="yes" xml:space="preserve">
          <source>It can be more obscure when using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt; 또는 다른 괄호와 중괄호를 사용하는 다른 구문을 사용할 때는 더 모호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaf4352228b453b336e8eafbf659e9e48282c4b5" translate="yes" xml:space="preserve">
          <source>It can be more obscure when using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</source>
          <target state="translated">It can be more obscure when using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</target>
        </trans-unit>
        <trans-unit id="637735e5f525f257cdcfa7d7c573a1134e3b31c0" translate="yes" xml:space="preserve">
          <source>It can have an identifier which is either a number or a string;</source>
          <target state="translated">숫자 또는 문자열 인 식별자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc2307e6eaf1fcf0e38e3e61b5ed2ac365de539" translate="yes" xml:space="preserve">
          <source>It doesn't have to be the same object, though; it can be a different one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee2b94ebdffc711d03534a6c9c32859543eb863" translate="yes" xml:space="preserve">
          <source>It doesn't work if the string contains grapheme clusters, even when using a unicode aware split (use for example &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead).</source>
          <target state="translated">유니 코드 인식 분할을 사용하는 경우에도 문자열에 grapheme 클러스터가 포함되어 있으면 작동하지 않습니다 (예 &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;:&lt;/a&gt; 대신 esrever 사용).</target>
        </trans-unit>
        <trans-unit id="f947e606472d4347ad32397429bfe2112731e5ac" translate="yes" xml:space="preserve">
          <source>It doesn't work if the string contains grapheme clusters, even when using a unicode-aware split. (Use, for example, &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead.)</source>
          <target state="translated">It doesn't work if the string contains grapheme clusters, even when using a unicode-aware split. (Use, for example, &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead.)</target>
        </trans-unit>
        <trans-unit id="a4fafc92e6281926700d4d162cec8f063e6ae134" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; called for missing elements of the array; that is:</source>
          <target state="translated">It is &lt;em&gt;not&lt;/em&gt; called for missing elements of the array; that is:</target>
        </trans-unit>
        <trans-unit id="adef4106e76e6addc70a8d2ae997c1248d91d94f" translate="yes" xml:space="preserve">
          <source>It is a good idea to comment &lt;em&gt;intentional&lt;/em&gt; use of the empty statement, as it is not really obvious to distinguish from a normal semicolon.</source>
          <target state="translated">It is a good idea to comment &lt;em&gt;intentional&lt;/em&gt; use of the empty statement, as it is not really obvious to distinguish from a normal semicolon.</target>
        </trans-unit>
        <trans-unit id="10eb0a5f9478db379a0c234799a056177e982243" translate="yes" xml:space="preserve">
          <source>It is advisable to not use simple assignments in a conditional expression (such as &lt;code&gt;&lt;a href=&quot;../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt;), because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</source>
          <target state="translated">조건식 (예 : &lt;code&gt;&lt;a href=&quot;../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt; 등)에 간단한 대입을 사용하지 않는 것이 좋습니다 . 코드를 살펴볼 때 대입이 동일하게 혼동 될 수 있기 때문입니다. 예를 들어 다음 코드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b1f5b1660aed98af62b5049d964d12af0b3a267c" translate="yes" xml:space="preserve">
          <source>It is advisable to not use simple assignments in a conditional expression, because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</source>
          <target state="translated">코드를 살펴볼 때 할당이 동일하게 혼동 될 수 있으므로 조건식에 간단한 할당을 사용하지 않는 것이 좋습니다. 예를 들어 다음 코드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="24d3facbde01a9ba1b0055ecd1c1d62977eb59f1" translate="yes" xml:space="preserve">
          <source>It is almost always safer to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt;, because there can be up to &lt;em&gt;four&lt;/em&gt; possible output types without &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">It is almost always safer to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; , because there can be up to &lt;em&gt;four&lt;/em&gt; possible output types without &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; , as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="8e0b595c50396c3cdbc92c5f6b750e905ed42003" translate="yes" xml:space="preserve">
          <source>It is also possible to &quot;import/export&quot; from different modules in a parent module so that they are available to import from that module. In other words, one can create a single module concentrating various exports from various modules.</source>
          <target state="translated">It is also possible to &quot;import/export&quot; from different modules in a parent module so that they are available to import from that module. In other words, one can create a single module concentrating various exports from various modules.</target>
        </trans-unit>
        <trans-unit id="bb4cc67af098b1db09d7c4c8d6064bf4903ec064" translate="yes" xml:space="preserve">
          <source>It is also possible to provide a name inside the definition in order to create a &lt;strong&gt;named&lt;/strong&gt; function expression:</source>
          <target state="translated">&lt;strong&gt;명명 된&lt;/strong&gt; 함수 표현식 을 작성하기 위해 정의 내에 이름을 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d15511bc331dcf794b253aed11d5d6bc426cf771" translate="yes" xml:space="preserve">
          <source>It is also possible to use the default syntax with the ones seen above (namespace imports or named imports). In such cases, the default import will have to be declared first. For instance:</source>
          <target state="translated">위에서 본 구문 (네임 스페이스 가져 오기 또는 명명 된 가져 오기)과 함께 기본 구문을 사용할 수도 있습니다. 이 경우 기본 가져 오기를 먼저 선언해야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="af4edb990c5fdf727cafe82fdb0540d797482226" translate="yes" xml:space="preserve">
          <source>It is an array of bytes, often referred to in other languages as a &quot;byte array&quot;.You cannot directly manipulate the contents of an &lt;code&gt;ArrayBuffer&lt;/code&gt;; instead, you create one of the &lt;a href=&quot;typedarray&quot;&gt;typed array objects&lt;/a&gt; or a &lt;a href=&quot;dataview&quot;&gt;&lt;code&gt;DataView&lt;/code&gt;&lt;/a&gt; object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.</source>
          <target state="translated">It is an array of bytes, often referred to in other languages as a &quot;byte array&quot;.You cannot directly manipulate the contents of an &lt;code&gt;ArrayBuffer&lt;/code&gt; ; instead, you create one of the &lt;a href=&quot;typedarray&quot;&gt;typed array objects&lt;/a&gt; or a &lt;a href=&quot;dataview&quot;&gt; &lt;code&gt;DataView&lt;/code&gt; &lt;/a&gt; object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.</target>
        </trans-unit>
        <trans-unit id="e582cadd5e2af8a250319887c5b15dd0b445e4ca" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</source>
          <target state="translated">It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</target>
        </trans-unit>
        <trans-unit id="ccb9df029f10f1c4b5a120be3422d4cce76c0172" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply&lt;/code&gt;&lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</source>
          <target state="translated">배열의 요소를 함수의 인수로 사용하려는 경우 &lt;a href=&quot;../global_objects/function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="e47762cbcbb8539a041b86f5911c627bfe43782a" translate="yes" xml:space="preserve">
          <source>It is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors.</source>
          <target state="translated">하나의 인수 (트래버스되는 요소)와 함께 콜백을 사용하는 것이 일반적입니다. 특정 함수는 추가 선택적 인수를 사용하더라도 일반적으로 하나의 인수와 함께 사용됩니다. 이러한 습관은 혼란스러운 행동으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85416cea4b3eddb14fb95e0c0cb8577b27c9847a" translate="yes" xml:space="preserve">
          <source>It is important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using &lt;code&gt;Object.defineProperty()&lt;/code&gt;, as shown in the example below.</source>
          <target state="translated">속성의 기본값이 적용되는 방식을 고려해야합니다. 아래 예제와 같이 단순히 점 표기법을 사용하여 값을 할당하는 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 를 사용하는 것 사이에는 종종 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1db1351f7a897a851f490253a603fa473ce35df" translate="yes" xml:space="preserve">
          <source>It is important to note the following:</source>
          <target state="translated">It is important to note the following:</target>
        </trans-unit>
        <trans-unit id="e840f3b9350f6801d0ff3e924eb8f373bbcc7491" translate="yes" xml:space="preserve">
          <source>It is not possible to combine both the AND (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) and OR operators (&lt;code&gt;||&lt;/code&gt;) directly with &lt;code&gt;??&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;SyntaxError&lt;/a&gt;&lt;/code&gt; will be thrown in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dda9f554abc422ea39aabc120a7ac0d13f88f6" translate="yes" xml:space="preserve">
          <source>It is not possible to know reflectively whether a particular object implements the iterator protocol, however it is easy to create an object that satisfies both the iterator and iterable protocols (as shown in the example below). Doing so allows an iterator to be consumed by the various syntaxes expecting iterables. Thus it is rarely desireable to implement the iterator protocol without also implementing iterable.</source>
          <target state="translated">특정 객체가 반복자 프로토콜을 구현하는지 여부를 반사적으로 알 수는 없지만 반복자와 반복 가능한 프로토콜을 모두 만족하는 객체를 쉽게 만들 수 있습니다 (아래 예 참조). 그렇게하면 반복자를 기대하는 다양한 구문에 의해 반복자를 사용할 수 있습니다. 따라서 iterable을 구현하지 않고 iterator 프로토콜을 구현하는 것은 거의 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbba11b1cf2f60a0f1e56080fd83cc82be1fb642" translate="yes" xml:space="preserve">
          <source>It is not possible to simultaneously have a getter bound to a property and have that property actually hold a value, although it &lt;em&gt;is&lt;/em&gt; possible to use a getter and a setter in conjunction to create a type of pseudo-property.</source>
          <target state="translated">It is not possible to simultaneously have a getter bound to a property and have that property actually hold a value, although it &lt;em&gt;is&lt;/em&gt; possible to use a getter and a setter in conjunction to create a type of pseudo-property.</target>
        </trans-unit>
        <trans-unit id="34110370fd48f5a59887b0bd5220e344fd6f9b8c" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;Date.parse&lt;/code&gt; as until ES5, parsing of strings was entirely implementation dependent. There are still many differences in how different hosts parse date strings, therefore date strings should be manually parsed (a library can help if many different formats are to be accommodated).</source>
          <target state="translated">ES5까지 문자열 구문 분석이 구현에 전적으로 의존 하기 때문에 &lt;code&gt;Date.parse&lt;/code&gt; 를 사용하지 않는 것이 좋습니다 . 다른 호스트가 날짜 문자열을 구문 분석하는 방법에는 여전히 많은 차이가 있으므로 날짜 문자열을 수동으로 구문 분석해야합니다 (다양한 형식을 수용해야하는 경우 라이브러리가 도움이 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="677b2c5760aff019715d68bc654186d7dc6c4634" translate="yes" xml:space="preserve">
          <source>It is now possible to do this in a standardized way using &lt;a href=&quot;getownpropertydescriptor&quot;&gt;&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getprototypeof&quot;&gt;&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7bb09bbffe2c1b00845a3a7df51c721c3f4425" translate="yes" xml:space="preserve">
          <source>It is now possible to do this in a standardized way using &lt;a href=&quot;getownpropertydescriptor&quot;&gt;&lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73dcdfa951545bec950ab075835e1130523dd188" translate="yes" xml:space="preserve">
          <source>It is possible to change this behaviour by handling possible rejections:</source>
          <target state="translated">가능한 거부를 처리하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc88e3e25b3ab537eecc21b53f748a8be78bdb7" translate="yes" xml:space="preserve">
          <source>It is possible to have a default &lt;a href=&quot;export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; (whether it is an object, a function, a class, etc.). The &lt;code&gt;import&lt;/code&gt; statement may then be used to import such defaults.</source>
          <target state="translated">기본 &lt;a href=&quot;export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; (객체, 함수, 클래스 등) 를 가질 수 있습니다 . &lt;code&gt;import&lt;/code&gt; 문은 다음과 같은 기본 설정을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bd6a46ab029adb771c2868831032b213e42613" translate="yes" xml:space="preserve">
          <source>It is possible to redefine the &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property of arrays, subject to the usual redefinition restrictions. (The &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property is initially non-configurable, non-enumerable, and writable. Thus on an unaltered array, it's possible to change the &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property's value or to make it non-writable. It is not allowed to change its enumerability or configurability, or if it is non-writable to change its value or writability.) However, not all browsers permit this redefinition.</source>
          <target state="translated">일반적인 재정의 제한에 따라 배열 의 &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성 을 재정의 할 수 있습니다 . ( &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성은 초기에 구성 불가능, 열거 불가능 및 쓰기 가능하므로 변경되지 않은 배열에서는 &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성 값 을 변경 하거나 쓰기 불가능하게 만들 수 있습니다. 열거 성 또는 구성 가능성을 변경할 수 없습니다. 또는 값이나 쓰기 가능성을 변경하기 위해 쓰기가 불가능한 경우.) 그러나 모든 브라우저가이 재정의를 허용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="17363cb0eabd22f47d17a9988c7026669edaebf7" translate="yes" xml:space="preserve">
          <source>It is possible to use a couple of NOT operators in series to explicitly force the conversion of any value to the corresponding &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;boolean primitive&lt;/a&gt;. The conversion is based on the &quot;truthyness&quot; or &quot;falsyness&quot; of the value (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/truthy&quot;&gt;truthy&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;falsy&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba7c66856ef3424f32c864a39cb61a9c7d5f9b7" translate="yes" xml:space="preserve">
          <source>It is rather rare to use &lt;code&gt;NaN&lt;/code&gt; in a program. It is the returned value when &lt;a href=&quot;math&quot;&gt;&lt;code&gt;Math&lt;/code&gt;&lt;/a&gt; functions fail (&lt;code&gt;Math.sqrt(-1)&lt;/code&gt;) or when a function trying to parse a number fails (&lt;code&gt;parseInt(&quot;blabla&quot;)&lt;/code&gt;).</source>
          <target state="translated">프로그램에서 &lt;code&gt;NaN&lt;/code&gt; 을 사용하는 것은 다소 드 rare니다 . &lt;a href=&quot;math&quot;&gt; &lt;code&gt;Math&lt;/code&gt; &lt;/a&gt; 함수가 실패 하거나 ( &lt;code&gt;Math.sqrt(-1)&lt;/code&gt; ) 숫자를 구문 분석하려는 함수가 실패하면 ( &lt;code&gt;parseInt(&quot;blabla&quot;)&lt;/code&gt; ) 반환되는 값 입니다.</target>
        </trans-unit>
        <trans-unit id="8d807a334bdce03af9753e48784800ecd42f96a6" translate="yes" xml:space="preserve">
          <source>It is sometime useful to have a stricter way to parse float values, regular expressions can help :</source>
          <target state="translated">float 값을 구문 분석하는 더 엄격한 방법을 사용하는 것이 유용 할 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9028e6cb1ea88953f0056159fb43c778bc96771" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have a stricter way to parse int values. Regular expressions can help:</source>
          <target state="translated">int 값을 구문 분석하는보다 엄격한 방법을 사용하는 것이 유용한 경우가 있습니다. 정규식이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbdea303761b144c9595974be207942a85ce77f9" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have a stricter way to parse integers.</source>
          <target state="translated">It is sometimes useful to have a stricter way to parse integers.</target>
        </trans-unit>
        <trans-unit id="788331654327003b9a3e20533f1dd22dd0adf40e" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the &lt;a href=&quot;../../operators/assignment_operators&quot;&gt;assignment operators&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;concat()&lt;/code&gt; 메서드 대신 &lt;a href=&quot;../../operators/assignment_operators&quot;&gt;할당 연산자&lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; )를 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a1c18ba9110166bc671d87e12d9f825477f805" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;assignment operators&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</source>
          <target state="translated">It is strongly recommended that the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;assignment operators&lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; ) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="bd2458b39f289fa23472c88198103bb696bbdb21" translate="yes" xml:space="preserve">
          <source>It is typically used when you have multiple asynchronous tasks that are not dependent on one another to complete successfully, or you'd always like to know the result of each promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64ce9678fde9b6ccb870d85fc1f1595c83b8450" translate="yes" xml:space="preserve">
          <source>It is usually safer to provide an initial value because there are three possible outputs without &lt;code&gt;initialValue&lt;/code&gt;, as shown in the following example.</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;initialValue&lt;/code&gt; 없이 가능한 세 개의 출력이 있으므로 일반적으로 초기 값을 제공하는 것이 더 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="f39e377b324a5c9f08b33569e89ef7d1ecc19a5e" translate="yes" xml:space="preserve">
          <source>It may be most practically used for debugging purposes, being an easy way to check the properties of an object (by outputting to the console or otherwise). Although arrays are often more practical for storing data, in situations where a key-value pair is preferred for working with data (with properties acting as the &quot;key&quot;), there may be instances where you want to check if any of those keys hold a particular value.</source>
          <target state="translated">It may be most practically used for debugging purposes, being an easy way to check the properties of an object (by outputting to the console or otherwise). Although arrays are often more practical for storing data, in situations where a key-value pair is preferred for working with data (with properties acting as the &quot;key&quot;), there may be instances where you want to check if any of those keys hold a particular value.</target>
        </trans-unit>
        <trans-unit id="dae584578a863d7bff34ff1b67e5fef9249f60d6" translate="yes" xml:space="preserve">
          <source>It may seem strange to have a special exception-related clause that executes &lt;strong&gt;regardless&lt;/strong&gt; of whether there is an exception, but this construct actually does serve a purpose. The important point is not that the &lt;code&gt;finally&lt;/code&gt;-clause always executes, but rather that ordinary code following a &lt;code&gt;try..catch&lt;/code&gt; does not.</source>
          <target state="translated">예외 가 있는지 여부에 &lt;strong&gt;관계없이&lt;/strong&gt; 실행되는 특수 예외 관련 절이있는 것은 이상하게 보일 수 있지만이 구조는 실제로 목적을 제공합니다. 중요한 점은 &lt;code&gt;finally&lt;/code&gt; -clause가 항상 실행되는 것이 아니라 &lt;code&gt;try..catch&lt;/code&gt; 를 따르는 일반 코드가 항상 실행 되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="641a1f1bfb9cdea9572c9f6c64ca77cd267d097a" translate="yes" xml:space="preserve">
          <source>It might be tempting to use &lt;code&gt;Math.round()&lt;/code&gt; to accomplish that, but doing so would cause your random numbers to follow a non-uniform distribution, which may not be acceptable for your needs.</source>
          <target state="translated">그것을 달성 하기 위해 &lt;code&gt;Math.round()&lt;/code&gt; 를 사용 하고 싶을 수도 있지만, 그렇게하면 임의의 숫자가 비 균일 분포를 따르게되어 필요에 맞지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d68bf98ccf8c0937c95ad24485ddb23a78f60f" translate="yes" xml:space="preserve">
          <source>It might just be an oversight, carefully check all you parenthesis in your code.</source>
          <target state="translated">그것은 단지 감독 일 수 있습니다. 코드에서 모든 괄호를주의 깊게 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="09d6a7960d6344daf110a07aa0f46e23fd7619dd" translate="yes" xml:space="preserve">
          <source>It must have exactly one parameter (see &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;Incompatible &lt;abbr&gt;ES5&lt;/abbr&gt; change: literal getter and setter functions must now have exactly zero or one arguments&lt;/a&gt; for more information);</source>
          <target state="translated">정확히 하나의 매개 변수를 가져야합니다 ( &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;호환되지 않는 &lt;abbr&gt;ES5&lt;/abbr&gt; 변경&lt;/a&gt; 참조 : 리터럴 getter 및 setter 함수는 이제 자세한 정보를 위해 정확히 0 또는 하나의 인수 를 가져야 함 ).</target>
        </trans-unit>
        <trans-unit id="e0d34231d840869638e3aa9002ecd024ffbeb1d0" translate="yes" xml:space="preserve">
          <source>It must have exactly zero parameters (see &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;Incompatible &lt;abbr&gt;ES5&lt;/abbr&gt; change: literal getter and setter functions must now have exactly zero or one arguments&lt;/a&gt; for more information);</source>
          <target state="translated">매개 변수는 정확히 0이어야합니다 ( &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;호환되지 않는 &lt;abbr&gt;ES5&lt;/abbr&gt; 변경&lt;/a&gt; 참조 : 리터럴 게터 및 설정자 함수는 이제 정확히 0 개 또는 1 개의 인수 를 가져야합니다 ).</target>
        </trans-unit>
        <trans-unit id="657ebce6cc38bce8085a97e3ff70384ec64422e5" translate="yes" xml:space="preserve">
          <source>It must not appear in an object literal with another &lt;code&gt;get&lt;/code&gt; or with a data entry for the same property (&lt;code&gt;{ get x() { }, get x() { } }&lt;/code&gt; and &lt;code&gt;{ x: ..., get x() { } }&lt;/code&gt; are forbidden).</source>
          <target state="translated">동일한 속성 ( &lt;code&gt;{ get x() { }, get x() { } }&lt;/code&gt; 및 &lt;code&gt;{ x: ..., get x() { } }&lt;/code&gt; 대한 다른 &lt;code&gt;get&lt;/code&gt; 또는 데이터 항목이 있는 객체 리터럴에 표시되지 않아야합니다 . } 금지되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="05463fbb4aaf21f08a3ab5f26554235003d67ae9" translate="yes" xml:space="preserve">
          <source>It must not appear in an object literal with another &lt;code&gt;set&lt;/code&gt; or with a data entry for the same property.</source>
          <target state="translated">다른 &lt;code&gt;set&lt;/code&gt; 또는 동일한 특성에 대한 데이터 항목이 있는 오브젝트 리터럴에 표시되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="de37cc0fc3c6bed823b6d0ee0f3b91c3251ed188" translate="yes" xml:space="preserve">
          <source>It returns an object with a &lt;code&gt;url&lt;/code&gt; property indicating the base URL of the module. This will either be the URL from which the script was obtained, for external scripts, or the document base URL of the containing document, for inline scripts.</source>
          <target state="translated">모듈의 기본 URL을 나타내는 &lt;code&gt;url&lt;/code&gt; 속성을 가진 객체를 반환합니다 . 외부 스크립트의 경우 스크립트를 가져온 URL이거나 인라인 스크립트의 경우 포함 문서의 문서 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="bb2fc09f8688c1fd395eb3e9195d969486229a89" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;a href=&quot;operator_precedence&quot;&gt;the precedence&lt;/a&gt; of the &lt;code&gt;void&lt;/code&gt; operator should be taken into account and that parentheses can help clarify the resolution of the expression following the &lt;code&gt;void&lt;/code&gt; operator:</source>
          <target state="translated">It should be noted that &lt;a href=&quot;operator_precedence&quot;&gt;the precedence&lt;/a&gt; of the &lt;code&gt;void&lt;/code&gt; operator should be taken into account and that parentheses can help clarify the resolution of the expression following the &lt;code&gt;void&lt;/code&gt; operator:</target>
        </trans-unit>
        <trans-unit id="0ea4eb774c6833ffc646efd58e60903a08815e06" translate="yes" xml:space="preserve">
          <source>It should be noted that the maximum &lt;code&gt;Date&lt;/code&gt; is not of the same value as the maximum safe integer (&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; is 9,007,199,254,740,991). Instead, it is defined in ECMA-262 that a maximum of &amp;plusmn;100,000,000 (one hundred million) days relative to January 1, 1970 UTC (that is, April 20, 271821 BCE ~ September 13, 275760 CE) can be represented by the standard &lt;code&gt;Date&lt;/code&gt; object (equivalent to &amp;plusmn;8,640,000,000,000,000 milliseconds).</source>
          <target state="translated">It should be noted that the maximum &lt;code&gt;Date&lt;/code&gt; is not of the same value as the maximum safe integer ( &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; is 9,007,199,254,740,991). Instead, it is defined in ECMA-262 that a maximum of &amp;plusmn;100,000,000 (one hundred million) days relative to January 1, 1970 UTC (that is, April 20, 271821 BCE ~ September 13, 275760 CE) can be represented by the standard &lt;code&gt;Date&lt;/code&gt; object (equivalent to &amp;plusmn;8,640,000,000,000,000 milliseconds).</target>
        </trans-unit>
        <trans-unit id="954e387ac20208cc03c4f242e0c768abc0226976" translate="yes" xml:space="preserve">
          <source>It should be noted, however, that function expressions and function declarations nested within the function generated by parsing a &lt;code&gt;Function constructor&lt;/code&gt; 's string aren't parsed repeatedly. For example:</source>
          <target state="translated">그러나 &lt;code&gt;Function constructor&lt;/code&gt; 의 문자열 을 구문 분석하여 생성 된 함수 내에 중첩 된 함수 표현식 및 함수 선언 은 반복적으로 구문 분석되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5add076469b11cb8d7fb6364d8cdde585210a41c" translate="yes" xml:space="preserve">
          <source>It should return the value that should be added to the JSON string, as follows:</source>
          <target state="translated">JSON 문자열에 추가해야하는 값을 다음과 같이 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8133026fa0d9fb510eaf9a781595de1b0f3fe04" translate="yes" xml:space="preserve">
          <source>It takes four arguments:</source>
          <target state="translated">It takes four arguments:</target>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">세 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49a4eb485bbd793345a88879a66885954804a585" translate="yes" xml:space="preserve">
          <source>It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</source>
          <target state="translated">배열 &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;의 길이&lt;/a&gt; 를 줄이려고 시도했지만 배열의 요소 중 하나를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . 배열을 단축하면 새 배열 길이를 초과하는 요소가 삭제되어이 상황에서 실패합니다.</target>
        </trans-unit>
        <trans-unit id="02e2c9120f5b81da0f3dc90fab1cb8d051a5e07e" translate="yes" xml:space="preserve">
          <source>It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</source>
          <target state="translated">It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</target>
        </trans-unit>
        <trans-unit id="3b01aa32def2c0fe928809ced8d9324a50887fe5" translate="yes" xml:space="preserve">
          <source>It was attempted to delete a property, but that property is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed.</source>
          <target state="translated">특성을 삭제하려고 시도했지만 해당 특성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . &lt;code&gt;configurable&lt;/code&gt; 속성이 (이외의 속성 객체에서 여부 삭제 될 수 있는지 여부를 속성 컨트롤을 &lt;code&gt;writable&lt;/code&gt; ) 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef26e246ba549e7961e66ec8bd877f8126498a0" translate="yes" xml:space="preserve">
          <source>It was attempted to delete a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed.</source>
          <target state="translated">It was attempted to delete a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt; ) can be changed.</target>
        </trans-unit>
        <trans-unit id="ccad8caf638b4903b95cc599d522675b3d9021ba" translate="yes" xml:space="preserve">
          <source>It was attempted to redefine a property, but that property is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt;, the property isn't configurable by default.</source>
          <target state="translated">속성을 재정의하려고 시도했지만 해당 속성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . &lt;code&gt;configurable&lt;/code&gt; 속성이 (이외의 속성 객체에서 여부 삭제 될 수 있는지 여부를 속성 컨트롤을 &lt;code&gt;writable&lt;/code&gt; ) 변경할 수 있습니다. 일반적으로 &lt;a href=&quot;../operators/object_initializer&quot;&gt;객체 이니셜 라이저에&lt;/a&gt; 의해 생성 된 객체의 속성을 구성 할 수 있습니다. 그러나 예를 들어 &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 사용하는 경우 기본적으로이 속성을 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec1f1b3574980048baf67633369823cce4b51a22" translate="yes" xml:space="preserve">
          <source>It was attempted to redefine a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt;, the property isn't configurable by default.</source>
          <target state="translated">It was attempted to redefine a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt; ) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt;, the property isn't configurable by default.</target>
        </trans-unit>
        <trans-unit id="bab397dbab28fef0eebb4b36ff8f4cad76612d87" translate="yes" xml:space="preserve">
          <source>It will create an infinite loop if there is a match, due to the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property being reset upon each iteration.</source>
          <target state="translated">It will create an infinite loop if there is a match, due to the &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; property being reset upon each iteration.</target>
        </trans-unit>
        <trans-unit id="1d60210731c923bbd8d426ee1b331915626a35b0" translate="yes" xml:space="preserve">
          <source>It will return &lt;code&gt;0&lt;/code&gt; on non-shared &lt;code&gt;ArrayBuffer&lt;/code&gt; objects.</source>
          <target state="translated">It will return &lt;code&gt;0&lt;/code&gt; on non-shared &lt;code&gt;ArrayBuffer&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="4c6ba868b0d358d7be2e94d5d913452de49af160" translate="yes" xml:space="preserve">
          <source>It's also possible to explicitly get the string representation of a function using the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">It's also possible to explicitly get the string representation of a function using the &lt;code&gt;+&lt;/code&gt; operator:</target>
        </trans-unit>
        <trans-unit id="d0ae4f0160efc5dbbcb8104a8d363de06b4efe61" translate="yes" xml:space="preserve">
          <source>It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise.</source>
          <target state="translated">항상 함수에서 배열을 반환 할 수있었습니다. 해체는 배열 반환 값을 사용하여보다 간결하게 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab096b013facf5171fb20f7a5008433704a6c33" translate="yes" xml:space="preserve">
          <source>It's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things which are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change version to version.</source>
          <target state="translated">클래스 외부에서 개인 필드를 참조하는 것은 오류입니다. 수업 본문 내에서만 읽거나 쓸 수 있습니다. 클래스 외부에서 볼 수없는 것을 정의함으로써 클래스 사용자가 내부에 의존 할 수 없도록하여 버전을 버전으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03716457a38dd613fb146f492439c6694b559017" translate="yes" xml:space="preserve">
          <source>It's been &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036&quot;&gt;reported&lt;/a&gt; that some websites using MooTools 1.2 broke on Firefox 17. This version of MooTools checks whether &lt;code&gt;String.prototype.contains()&lt;/code&gt; exists and, if it doesn't, MooTools adds its own function. With the introduction of this function in Firefox 17, the behavior of that check changed in a way that causes code based on MooTools' &lt;code&gt;String.prototype.contains()&lt;/code&gt; implementation to break. As a result, the implementation was &lt;a href=&quot;https://hg.mozilla.org/releases/mozilla-aurora/rev/086db97198a8&quot;&gt;disabled&lt;/a&gt; in Firefox 17 and &lt;code&gt;String.prototype.contains()&lt;/code&gt; was available one version later, in Firefox 18, when &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036#c32&quot;&gt;outreach to MooTools &lt;/a&gt;was leading to the &lt;a href=&quot;http://mootools.net/blog/2013/02/19/mootools-1-2-6-released&quot;&gt;release of MooTools version 1.2.6&lt;/a&gt;.</source>
          <target state="translated">MooTools 1.2를 사용하는 일부 웹 사이트가 Firefox 17에서 중단 된 것으로 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036&quot;&gt;보고&lt;/a&gt; 되었습니다 .이 MooTools 버전은 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 존재 하는지 여부를 확인 하고 존재하지 않는 경우 MooTools는 자체 기능을 추가합니다. Firefox 17에이 함수가 도입되면서 MooTools의 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 구현을 기반으로하는 코드 가 중단 되는 방식으로 검사 기능이 변경되었습니다 . 결과적으로 Firefox 17에서 구현이 &lt;a href=&quot;https://hg.mozilla.org/releases/mozilla-aurora/rev/086db97198a8&quot;&gt;비활성화&lt;/a&gt; 되었으며 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036#c32&quot;&gt;MooTools&lt;/a&gt; 에 대한 지원 &lt;a href=&quot;http://mootools.net/blog/2013/02/19/mootools-1-2-6-released&quot;&gt;이 MooTools 버전 1.2.6&lt;/a&gt; 의 출시 로 이어질 때 Firefox 18에서 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 한 버전 이후에 사용 가능했습니다 .</target>
        </trans-unit>
        <trans-unit id="0c19fe72e04edd33a42aaf0c6b73b631cf5819eb" translate="yes" xml:space="preserve">
          <source>It's common to use the object itself as the unregister token, which is just fine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad42705853bcc5b13365e9dd36fbcbb6ceb6b2bb" translate="yes" xml:space="preserve">
          <source>It's easy to forget a character here or there.</source>
          <target state="translated">여기 저기 문자를 잊어 버리기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="aa341c3ae049b775c45f18a031d679d3313fdb7e" translate="yes" xml:space="preserve">
          <source>It's important to note the nature of block scoping.</source>
          <target state="translated">It's important to note the nature of block scoping.</target>
        </trans-unit>
        <trans-unit id="b7e9905f65f341e990222d4ff317bc808ce28e95" translate="yes" xml:space="preserve">
          <source>It's important to point out that the hoisting will affect the variable declaration, but not its value's initialization. The value will be indeed assigned when the assignment statement is reached:</source>
          <target state="translated">호이 스팅은 변수 선언에 영향을 미치지 만 값의 초기화에는 영향을 미치지 않습니다. 대 입문에 도달하면 값이 실제로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5a0154d078b534157bccc5cebf69bbf141a3ea" translate="yes" xml:space="preserve">
          <source>It's likely that major implementations will call cleanup callbacks at some point during execution, but those calls may be substantially after the related object was reclaimed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bec33562b92cfeb84dad9aaca2fd74a7fdf2830" translate="yes" xml:space="preserve">
          <source>It's possible to use &lt;code&gt;String&lt;/code&gt; as a more reliable &lt;a href=&quot;string/tostring&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; alternative, as it works when used on &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, and on &lt;a href=&quot;symbol&quot;&gt;&lt;code&gt;symbols&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">그것은 사용하는 것이 가능 &lt;code&gt;String&lt;/code&gt; 더 신뢰할으로 &lt;a href=&quot;string/tostring&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 가 사용 때 작동하기 때문에, 다른 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; , 그리고에 &lt;a href=&quot;symbol&quot;&gt; &lt;code&gt;symbols&lt;/code&gt; &lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b848ab2fb08e43e529543c6e2fab3e9726bc663" translate="yes" xml:space="preserve">
          <source>It's tough coming up with good variable names. We all have been there.</source>
          <target state="translated">좋은 변수 이름을 찾기가 어렵습니다. 우리 모두 거기에 왔습니다.</target>
        </trans-unit>
        <trans-unit id="9386f043281c3ea26d3f1bdde2724658066699bc" translate="yes" xml:space="preserve">
          <source>It's typical when speaking of an object's properties to make a distinction between properties and methods. However, the property/method distinction is little more than a convention. A method is simply a property that can be called (for example, if it has a reference to a &lt;a href=&quot;../global_objects/function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; instance as its value).</source>
          <target state="translated">It's typical when speaking of an object's properties to make a distinction between properties and methods. However, the property/method distinction is little more than a convention. A method is simply a property that can be called (for example, if it has a reference to a &lt;a href=&quot;../global_objects/function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; instance as its value).</target>
        </trans-unit>
        <trans-unit id="5feb4718af1649655101d14d39d1577ed4fe6db2" translate="yes" xml:space="preserve">
          <source>Items on the prototype chain are not listed:</source>
          <target state="translated">프로토 타입 체인의 항목이 나열되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b526c83f0fbd860687a229f7de46226cbf3f2a" translate="yes" xml:space="preserve">
          <source>Iterable examples</source>
          <target state="translated">반복 가능한 예제</target>
        </trans-unit>
        <trans-unit id="303add622a0aab032fae6819c4ebe6b995c08abd" translate="yes" xml:space="preserve">
          <source>Iterable in constructor</source>
          <target state="translated">생성자에서 반복 가능</target>
        </trans-unit>
        <trans-unit id="12279667aeedad166b3a644b34522ec0663e7e6b" translate="yes" xml:space="preserve">
          <source>Iterable is an Array or other iterable object whose elements are key-value pairs (2-element Arrays). Each key-value pair will be added to the new WeakMap. null is treated as undefined.</source>
          <target state="translated">Iterable은 요소가 키-값 쌍 (2 요소 배열) 인 Array 또는 기타 반복 가능한 객체입니다. 각 키-값 쌍이 새 WeakMap에 추가됩니다. null은 정의되지 않은 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2b023afbe3bb8465459d650343ef64c1ac087ed9" translate="yes" xml:space="preserve">
          <source>Iterates a specified variable over all values of object's properties. For each distinct property, a specified statement is executed.</source>
          <target state="translated">객체 속성의 모든 값에 대해 지정된 변수를 반복합니다. 각 고유 속성에 대해 지정된 명령문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="21fbe6e5ed65189e6f03abfbf39cf77716f2b19a" translate="yes" xml:space="preserve">
          <source>Iterates over async iterable objects, array-like objects, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;iterators and generators&lt;/a&gt;, invoking a custom iteration hook with statements to be executed for the value of each distinct property.</source>
          <target state="translated">비동기 반복 가능 객체, 배열과 유사한 객체, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;반복자 및 생성기&lt;/a&gt; 를 반복하여 각 고유 특성의 값에 대해 실행될 명령문으로 사용자 정의 반복 후크를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7fee0e8392755185b42e899080e03939cef85638" translate="yes" xml:space="preserve">
          <source>Iterates over iterable objects (including &lt;a href=&quot;global_objects/array&quot;&gt;arrays&lt;/a&gt;, array-like objects, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;iterators and generators&lt;/a&gt;), invoking a custom iteration hook with statements to be executed for the value of each distinct property.</source>
          <target state="translated">반복 가능한 객체 ( &lt;a href=&quot;global_objects/array&quot;&gt;배열&lt;/a&gt; , 배열과 유사한 객체, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;반복자 및 생성기 포함&lt;/a&gt; )를 반복하여 각 고유 특성의 값에 대해 실행될 명령문으로 사용자 정의 반복 후크를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1b94f212c1058f85e4abf17b4fe48c9e33edefdc" translate="yes" xml:space="preserve">
          <source>Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.</source>
          <target state="translated">객체의 열거 가능한 속성을 임의의 순서로 반복합니다. 각각의 고유 한 속성에 대해 문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d3a70287785e5fa4e941a07061cdd1478f560f" translate="yes" xml:space="preserve">
          <source>Iterating &lt;code&gt;Maps&lt;/code&gt; with &lt;code&gt;for..of&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 를 사용 하여 &lt;code&gt;Maps&lt;/code&gt; 반복</target>
        </trans-unit>
        <trans-unit id="496362b32a792f687bc6cb94d683922c1b2faeb0" translate="yes" xml:space="preserve">
          <source>Iterating &lt;code&gt;Maps&lt;/code&gt; with &lt;code&gt;forEach()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;forEach()&lt;/code&gt; 하여 &lt;code&gt;Maps&lt;/code&gt; 반복</target>
        </trans-unit>
        <trans-unit id="40ab9f00419e3d7a971bf12b9e6bdeb7069a3374" translate="yes" xml:space="preserve">
          <source>Iterating Map with for..of</source>
          <target state="translated">Iterating Map with for..of</target>
        </trans-unit>
        <trans-unit id="3b13732009253de3c0e616d1484eb8249d06df9d" translate="yes" xml:space="preserve">
          <source>Iterating Map with forEach()</source>
          <target state="translated">Iterating Map with forEach()</target>
        </trans-unit>
        <trans-unit id="d27439a31a816c4d2a55814b1d2a74e6be2b97e8" translate="yes" xml:space="preserve">
          <source>Iterating Sets</source>
          <target state="translated">반복 세트</target>
        </trans-unit>
        <trans-unit id="4d045ad50ff36df18ffc24df4519d293570d9402" translate="yes" xml:space="preserve">
          <source>Iterating generators asynchronously</source>
          <target state="translated">비동기 적으로 생성기 반복</target>
        </trans-unit>
        <trans-unit id="4ca2c07db7642120f42b8ddc127bd59d4545455f" translate="yes" xml:space="preserve">
          <source>Iterating over DOM collections like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NodeList&quot;&gt;&lt;code&gt;NodeList&lt;/code&gt;&lt;/a&gt;: the following example adds a &lt;code&gt;read&lt;/code&gt; class to paragraphs that are direct descendants of an article:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NodeList&quot;&gt; &lt;code&gt;NodeList&lt;/code&gt; &lt;/a&gt; 와 같은 DOM 콜렉션을 반복 합니다. 다음 예제는 기사의 직접적인 후손 인 단락에 &lt;code&gt;read&lt;/code&gt; 클래스를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="15eb37b3d4eaeab4e4041b1203c12a7e51a06e97" translate="yes" xml:space="preserve">
          <source>Iterating over Object properties</source>
          <target state="translated">객체 속성에 대한 반복</target>
        </trans-unit>
        <trans-unit id="5785379b283506426da37af2daac50321c939cf1" translate="yes" xml:space="preserve">
          <source>Iterating over a &lt;a href=&quot;../global_objects/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global_objects/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 반복</target>
        </trans-unit>
        <trans-unit id="faf9e7e150ab3aadac7b42beae071f087812406b" translate="yes" xml:space="preserve">
          <source>Iterating over a &lt;a href=&quot;../global_objects/set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global_objects/set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 반복</target>
        </trans-unit>
        <trans-unit id="67435ad9c2794513dba566d0fd08bbd265b7e9af" translate="yes" xml:space="preserve">
          <source>Iterating over a &lt;a href=&quot;../global_objects/string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global_objects/string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 반복</target>
        </trans-unit>
        <trans-unit id="ee7063025fae3e507f8e9ddcbd6728d7df3e3817" translate="yes" xml:space="preserve">
          <source>Iterating over a &lt;a href=&quot;../global_objects/typedarray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global_objects/typedarray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; 를&lt;/a&gt; 반복</target>
        </trans-unit>
        <trans-unit id="fc7709ac59619dbe62326f750cb2e5dbe03c2089" translate="yes" xml:space="preserve">
          <source>Iterating over a DOM collection</source>
          <target state="translated">DOM 콜렉션에 대한 반복</target>
        </trans-unit>
        <trans-unit id="f0dd8cb2fd3f7d0a7d9ad1e2575ac2d8bef1fc81" translate="yes" xml:space="preserve">
          <source>Iterating over a custom iterable</source>
          <target state="translated">Iterating over a custom iterable</target>
        </trans-unit>
        <trans-unit id="c3dc9daac57270ee67396bd5364644ae68886b7b" translate="yes" xml:space="preserve">
          <source>Iterating over a generator</source>
          <target state="translated">발전기 반복</target>
        </trans-unit>
        <trans-unit id="a0dc6e73ee2e37d38beb08f50a02dc45573ef71c" translate="yes" xml:space="preserve">
          <source>Iterating over a null-able array</source>
          <target state="translated">널 입력 가능 배열에 대한 반복</target>
        </trans-unit>
        <trans-unit id="94e4424cf8cedd9015568a70cb7d3b5ee4affdcc" translate="yes" xml:space="preserve">
          <source>Iterating over an &lt;a href=&quot;../global_objects/array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../global_objects/array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 반복</target>
        </trans-unit>
        <trans-unit id="2e60e562508b0ed60988554d07223e7b2d99da86" translate="yes" xml:space="preserve">
          <source>Iterating over an &lt;code&gt;Object&lt;/code&gt; requires obtaining its keys in some fashion and iterating over them.</source>
          <target state="translated">Iterating over an &lt;code&gt;Object&lt;/code&gt; requires obtaining its keys in some fashion and iterating over them.</target>
        </trans-unit>
        <trans-unit id="f68897b9a5f552a14700497db5885c704c7ef951" translate="yes" xml:space="preserve">
          <source>Iterating over an array</source>
          <target state="translated">배열을 반복</target>
        </trans-unit>
        <trans-unit id="4cc7ed0da156acec2c68ed9bf0a521a98d8d6e0b" translate="yes" xml:space="preserve">
          <source>Iterating over an object's key-value pair</source>
          <target state="translated">객체의 키-값 쌍에 대한 반복</target>
        </trans-unit>
        <trans-unit id="88bb9e15d633e1057b3bc67f5bceb61e9de30cc6" translate="yes" xml:space="preserve">
          <source>Iterating over async generators</source>
          <target state="translated">비동기 생성기 반복</target>
        </trans-unit>
        <trans-unit id="2de9ec73e2d0f138fa633c55f04c2ed679f286c5" translate="yes" xml:space="preserve">
          <source>Iterating over async iterables</source>
          <target state="translated">비동기 이터 러블에 대한 반복</target>
        </trans-unit>
        <trans-unit id="8261b2bba8471445708c79a32892c6c29ef1a417" translate="yes" xml:space="preserve">
          <source>Iterating over generators</source>
          <target state="translated">발전기 반복</target>
        </trans-unit>
        <trans-unit id="455adf44859e7fb0cfd2c5e7ab19ab8ee204fe91" translate="yes" xml:space="preserve">
          <source>Iterating over other iterable objects</source>
          <target state="translated">다른 반복 가능한 객체를 반복</target>
        </trans-unit>
        <trans-unit id="d2b2115ccf256747d8672ffc5d69d7406c205ab8" translate="yes" xml:space="preserve">
          <source>Iterating over own properties only</source>
          <target state="translated">자체 속성에 대해서만 반복</target>
        </trans-unit>
        <trans-unit id="b706b05db27d81be7980fff650e1efd676429131" translate="yes" xml:space="preserve">
          <source>Iterating over sync iterables and generators</source>
          <target state="translated">Iterating over sync iterables and generators</target>
        </trans-unit>
        <trans-unit id="197fe49a2a1c4d237370fea18854987d4402b9d6" translate="yes" xml:space="preserve">
          <source>Iterating over the arguments object</source>
          <target state="translated">arguments 객체를 반복</target>
        </trans-unit>
        <trans-unit id="a0c9b1100058d497cbedce594920f40748a99b04" translate="yes" xml:space="preserve">
          <source>Iterating over the properties of an object</source>
          <target state="translated">객체의 속성을 반복</target>
        </trans-unit>
        <trans-unit id="f00d02193dcc47913c30580455567325cb2dfc7d" translate="yes" xml:space="preserve">
          <source>Iterating own properties</source>
          <target state="translated">Iterating own properties</target>
        </trans-unit>
        <trans-unit id="6fcc61476205d976879fe5c5834ef09fdec97d05" translate="yes" xml:space="preserve">
          <source>Iterating through an &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 통한 반복</target>
        </trans-unit>
        <trans-unit id="b729f2bb4ecffd58ba4c201a1207816bbea198ab" translate="yes" xml:space="preserve">
          <source>Iterating with index and element</source>
          <target state="translated">Iterating with index and element</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="e57f738f4cf22de41d9639f210cde2805b2f793b" translate="yes" xml:space="preserve">
          <source>Iteration methods</source>
          <target state="translated">반복 방법</target>
        </trans-unit>
        <trans-unit id="cb861e59baf33cf5ef305c875f90f2d688e7c3a8" translate="yes" xml:space="preserve">
          <source>Iteration protocols</source>
          <target state="translated">반복 프로토콜</target>
        </trans-unit>
        <trans-unit id="87fc3eb7786823f67bfe4af13f35f991a544dbc4" translate="yes" xml:space="preserve">
          <source>Iteration symbols</source>
          <target state="translated">반복 기호</target>
        </trans-unit>
        <trans-unit id="5424022050225204cf8727255495e6b24e82ff2f" translate="yes" xml:space="preserve">
          <source>Iteration using .next()</source>
          <target state="translated">Iteration using .next()</target>
        </trans-unit>
        <trans-unit id="eb79f142ae3daf3d1b99a2963dd0297f477bdb9c" translate="yes" xml:space="preserve">
          <source>Iteration using &lt;code&gt;&lt;a href=&quot;../../statements/for...of&quot;&gt;for...of&lt;/a&gt;&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../statements/for...of&quot;&gt;for...of&lt;/a&gt;&lt;/code&gt; 루프를 사용한 반복</target>
        </trans-unit>
        <trans-unit id="ab213d9f3b72f0094031342e450e11230c30ff03" translate="yes" xml:space="preserve">
          <source>Iteration using &lt;code&gt;for...of&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; 루프를 사용한 반복</target>
        </trans-unit>
        <trans-unit id="caa6a77d6122fb34e678cfd0ceac3f71a3842492" translate="yes" xml:space="preserve">
          <source>Iteration using for...of loop</source>
          <target state="translated">Iteration using for...of loop</target>
        </trans-unit>
        <trans-unit id="b0c34a82a6cb315de14486f56ef52965c9d62447" translate="yes" xml:space="preserve">
          <source>Iterations</source>
          <target state="translated">Iterations</target>
        </trans-unit>
        <trans-unit id="56c3f198d3a131f50b3aedf9e825651f8c11a967" translate="yes" xml:space="preserve">
          <source>Iterator examples</source>
          <target state="translated">반복자 예제</target>
        </trans-unit>
        <trans-unit id="0685bbcbd8ed67f28143ac80d8c20ee967c3be97" translate="yes" xml:space="preserve">
          <source>Iterators and generators</source>
          <target state="translated">반복자와 생성기</target>
        </trans-unit>
        <trans-unit id="a5fff14a8fe4cf0ab4b7206119ff5ade05d8866a" translate="yes" xml:space="preserve">
          <source>JS Guide: Defining Getters and Setters</source>
          <target state="translated">JS 안내서 : Getter 및 Setter 정의</target>
        </trans-unit>
        <trans-unit id="9680a1e52ba14f160bd036f4c6ffa903b1428b1a" translate="yes" xml:space="preserve">
          <source>JS1.7/JS1.8 comprehensions are removed from Gecko starting with version 46 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1220564&quot;&gt;bug 1220564&lt;/a&gt;).</source>
          <target state="translated">JS1.7 / JS1.8 이해는 버전 46 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1220564&quot;&gt;버그 1220564&lt;/a&gt; ) 부터 Gecko에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="c0ad391892841c8ebe22bd1fcdd0679b25d24c17" translate="yes" xml:space="preserve">
          <source>JSON Beautifier/editor</source>
          <target state="translated">JSON Beautifier/editor</target>
        </trans-unit>
        <trans-unit id="100ffe778ac7ccdc31372ac8a52b744ce3cda1c0" translate="yes" xml:space="preserve">
          <source>JSON Parser</source>
          <target state="translated">JSON 파서</target>
        </trans-unit>
        <trans-unit id="1c79289ed03d4e908f749949854866b01446c023" translate="yes" xml:space="preserve">
          <source>JSON Validator</source>
          <target state="translated">JSON Validator</target>
        </trans-unit>
        <trans-unit id="d37128db436e358a875a4420cb7e2d8bdc28ad9e" translate="yes" xml:space="preserve">
          <source>JSON bad parse</source>
          <target state="translated">JSON 나쁜 파싱</target>
        </trans-unit>
        <trans-unit id="811285db50f8a8eb83d950550317fb65834a9157" translate="yes" xml:space="preserve">
          <source>JSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. It is based upon JavaScript syntax but is distinct from it: some JavaScript is &lt;em&gt;not&lt;/em&gt; JSON.</source>
          <target state="translated">JSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt;. It is based upon JavaScript syntax but is distinct from it: some JavaScript is &lt;em&gt;not&lt;/em&gt; JSON.</target>
        </trans-unit>
        <trans-unit id="bf54a2760253e5523dd126645682e6342ba96377" translate="yes" xml:space="preserve">
          <source>JSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. It is based upon JavaScript syntax but is distinct from it: some JavaScript is not JSON.</source>
          <target state="translated">JSON은 객체, 배열, 숫자, 문자열, 부울 및 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 직렬화하는 구문입니다 . JavaScript 구문을 기반으로하지만 고유하지 않습니다. 일부 JavaScript는 JSON이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4f2a89c61c86c35467830a85aa4b232738cf254f" translate="yes" xml:space="preserve">
          <source>JSON permits &lt;em&gt;only&lt;/em&gt; property definition using &lt;code&gt;&quot;property&quot;: value&lt;/code&gt; syntax. The property name must be double-quoted, and the definition cannot be a shorthand.</source>
          <target state="translated">JSON은 &lt;code&gt;&quot;property&quot;: value&lt;/code&gt; 구문을 사용하여 속성 정의 &lt;em&gt;만&lt;/em&gt; 허용 합니다. 속성 이름은 큰 따옴표로 묶어야하며 정의는 속기 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b5375f0360e9044ba38df47f55f6d563d59252" translate="yes" xml:space="preserve">
          <source>JSON.parse</source>
          <target state="translated">JSON.parse</target>
        </trans-unit>
        <trans-unit id="9644748ebd63f29d453cce2a8979bae8f40c9f10" translate="yes" xml:space="preserve">
          <source>JSON.parse() does not allow single quotes</source>
          <target state="translated">JSON.parse() does not allow single quotes</target>
        </trans-unit>
        <trans-unit id="cbd48627b99656cef31788a0ab301f29b0738042" translate="yes" xml:space="preserve">
          <source>JSON.parse() does not allow trailing commas</source>
          <target state="translated">JSON.parse() does not allow trailing commas</target>
        </trans-unit>
        <trans-unit id="3898286ce044bc87123989a97e0cdf2ef51669ae" translate="yes" xml:space="preserve">
          <source>JSON.stringify</source>
          <target state="translated">JSON.stringify</target>
        </trans-unit>
        <trans-unit id="74e384b6b5577955a3669ecd037932490c489e66" translate="yes" xml:space="preserve">
          <source>Jake Archibald: JavaScript Promises: There and Back Again</source>
          <target state="translated">Jake Archibald : JavaScript 약속 : 저기 및 다시</target>
        </trans-unit>
        <trans-unit id="0942e78f8a190da08261f8ccef3d6a376c82e4b5" translate="yes" xml:space="preserve">
          <source>Japanese Imperial calendar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ef979301f791d1b453aaf533e873600b238f94" translate="yes" xml:space="preserve">
          <source>Japanese financial numerals &amp;mdash; algorithmic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0eb594e5ab66b21d34ef73b600b41237b029ed" translate="yes" xml:space="preserve">
          <source>Japanese first-year Gannen numbering for Japanese calendar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703ff01d4fd7d32c94d0671cfc5a4dce09dc56ad" translate="yes" xml:space="preserve">
          <source>Japanese numerals &amp;mdash; algorithmic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cf9f0b7d11604683e3cd3536c286c1fbb6a1a234" translate="yes" xml:space="preserve">
          <source>JavaScript &quot;use strict&quot; tutorial for beginners.</source>
          <target state="translated">초보자를위한 JavaScript &quot;엄격한 사용&quot;자습서.</target>
        </trans-unit>
        <trans-unit id="95f38db69c9860d4c53e8e685654bf16597668ff" translate="yes" xml:space="preserve">
          <source>JavaScript 1.6's &lt;a href=&quot;../statements/for_each...in&quot;&gt;&lt;code&gt;for each (variable in obj)&lt;/code&gt;&lt;/a&gt; statement is deprecated, and will be removed in the near future.</source>
          <target state="translated">&lt;a href=&quot;../statements/for_each...in&quot;&gt; &lt;code&gt;for each (variable in obj)&lt;/code&gt; &lt;/a&gt; 문장 에 대한 JavaScript 1.6 은 더 이상 사용되지 않으며 조만간 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="b11fcfb5e6c4095c390cc74243bf136eff9202ee" translate="yes" xml:space="preserve">
          <source>JavaScript 1.6's &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;&lt;code&gt;for each (variable in obj)&lt;/code&gt;&lt;/a&gt; statement is deprecated, and will be removed in the near future.</source>
          <target state="translated">JavaScript 1.6's &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt; &lt;code&gt;for each (variable in obj)&lt;/code&gt; &lt;/a&gt; statement is deprecated, and will be removed in the near future.</target>
        </trans-unit>
        <trans-unit id="ea7b87afcbfa3966fea708fd6422311e4516f203" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; instances inherit from &lt;code&gt;Date.prototype&lt;/code&gt;. You can modify the constructor's prototype object to affect properties and methods inherited by JavaScript &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">JavaScript &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;code&gt;Date.prototype&lt;/code&gt; 을 상속 합니다. 생성자의 프로토 타입 객체를 수정하여 JavaScript &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 인스턴스에 상속 된 속성과 메서드에 영향을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bfd90e7c2dbb27dce27ca27bdac42e0dcc0f232" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; objects are &lt;strong&gt;stateful&lt;/strong&gt; when they have the &lt;a href=&quot;global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sticky&quot;&gt;&lt;code&gt;sticky&lt;/code&gt;&lt;/a&gt; flags set (e.g. &lt;code&gt;/foo/g&lt;/code&gt; or &lt;code&gt;/foo/y&lt;/code&gt;). They store a &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; from the previous match. Using this internally, &lt;code&gt;exec()&lt;/code&gt; can be used to iterate over multiple matches in a string of text (with capture groups), as opposed to getting just the matching strings with &lt;a href=&quot;../string/match&quot;&gt;&lt;code&gt;String.prototype.match()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; objects are &lt;strong&gt;stateful&lt;/strong&gt; when they have the &lt;a href=&quot;global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;sticky&quot;&gt; &lt;code&gt;sticky&lt;/code&gt; &lt;/a&gt; flags set (e.g. &lt;code&gt;/foo/g&lt;/code&gt; or &lt;code&gt;/foo/y&lt;/code&gt; ). They store a &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; from the previous match. Using this internally, &lt;code&gt;exec()&lt;/code&gt; can be used to iterate over multiple matches in a string of text (with capture groups), as opposed to getting just the matching strings with &lt;a href=&quot;../string/match&quot;&gt; &lt;code&gt;String.prototype.match()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e185614f6000d0678a516450668693294c69226e" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Date&lt;/code&gt; instances</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; 인스턴스</target>
        </trans-unit>
        <trans-unit id="0c24fd7a6e89387c4f243f44598ae892c1180321" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Date&lt;/code&gt; objects represent a single moment in time in a platform-independent format. &lt;code&gt;Date&lt;/code&gt; objects contain a &lt;code&gt;Number&lt;/code&gt; that represents milliseconds since 1 January 1970 UTC.</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; objects represent a single moment in time in a platform-independent format. &lt;code&gt;Date&lt;/code&gt; objects contain a &lt;code&gt;Number&lt;/code&gt; that represents milliseconds since 1 January 1970 UTC.</target>
        </trans-unit>
        <trans-unit id="8a87f819f80e77daa36501c55d2c2194b0cf3fe2" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;String.length&lt;/code&gt; and Internationalizing Web Applications</source>
          <target state="translated">JavaScript &lt;code&gt;String.length&lt;/code&gt; 및 국제화 웹 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="e3e1e7a0cc811b106bfef783b0416af73ca33679" translate="yes" xml:space="preserve">
          <source>JavaScript Guide: &amp;ldquo;Indexing object properties&amp;rdquo;</source>
          <target state="translated">JavaScript 안내서 : &quot;인덱싱 객체 속성&quot;</target>
        </trans-unit>
        <trans-unit id="6a82cb7626330736e6c599c3af57e1f82e2ef675" translate="yes" xml:space="preserve">
          <source>JavaScript Guide: &amp;ldquo;Predefined Core Objects: &lt;code&gt;Array&lt;/code&gt; Object&amp;rdquo;</source>
          <target state="translated">JavaScript 안내서 : &quot;사전 정의 된 핵심 객체 : &lt;code&gt;Array&lt;/code&gt; 객체&quot;</target>
        </trans-unit>
        <trans-unit id="f586882c868e8d1ea5952465445447e739fcd864" translate="yes" xml:space="preserve">
          <source>JavaScript Guide: Inheritance revisited</source>
          <target state="translated">JavaScript 가이드 : 상속 재검토</target>
        </trans-unit>
        <trans-unit id="8a9eb27e2d92ebadf6635ebf472954fddd2b2da1" translate="yes" xml:space="preserve">
          <source>JavaScript URIs</source>
          <target state="translated">자바 스크립트 URI</target>
        </trans-unit>
        <trans-unit id="54e3077631b43981930a15403a3d80fa000df5fe" translate="yes" xml:space="preserve">
          <source>JavaScript and JSON differences</source>
          <target state="translated">JavaScript와 JSON의 차이점</target>
        </trans-unit>
        <trans-unit id="e296c3871618d551c3deb57435cdb708b2ce43ec" translate="yes" xml:space="preserve">
          <source>JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.</source>
          <target state="translated">JavaScript 응용 프로그램은 적절한 구문이있는 문장으로 구성됩니다. 단일 문장은 여러 줄에 걸쳐있을 수 있습니다. 각 명령문이 세미콜론으로 구분되면 한 줄에 여러 명령문이 발생할 수 있습니다. 이것은 키워드가 아니라 키워드 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="4c6223ca18121abcd5886040798a9233e0f4edd4" translate="yes" xml:space="preserve">
          <source>JavaScript arguments object and beyond</source>
          <target state="translated">JavaScript 인수 객체 이상</target>
        </trans-unit>
        <trans-unit id="d99bc0de4948386c462dba4ba7e8077b8ebf7e66" translate="yes" xml:space="preserve">
          <source>JavaScript arrays are zero-indexed. The first element of an array is at index &lt;code&gt;0&lt;/code&gt;, and the last element is at the index value equal to the value of the array's &lt;a href=&quot;array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property minus &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">JavaScript arrays are zero-indexed. The first element of an array is at index &lt;code&gt;0&lt;/code&gt; , and the last element is at the index value equal to the value of the array's &lt;a href=&quot;array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; property minus &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f21e4eca6175c2b188c4fef15f8f69d8441431c" translate="yes" xml:space="preserve">
          <source>JavaScript arrays are zero-indexed: the first element of an array is at index &lt;code&gt;0&lt;/code&gt;, and the last element is at the index equal to the value of the array's &lt;a href=&quot;array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property minus 1. Using an invalid index number returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">JavaScript 배열은 인덱스가 0입니다. 배열의 첫 번째 요소는 인덱스 &lt;code&gt;0&lt;/code&gt; 이고 마지막 요소는 배열의 &lt;a href=&quot;array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성에서 1을 뺀 값과 같은 인덱스에 있습니다. 잘못된 인덱스 번호를 사용하면 &lt;code&gt;undefined&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f140eaf1bc562f42183779bed82bd97513bcc4c" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;[@@toPrimitive]()&lt;/code&gt; method to convert an object to a primitive value. You rarely need to invoke the &lt;code&gt;[@@toPrimitive]()&lt;/code&gt; method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</source>
          <target state="translated">JavaScript는 &lt;code&gt;[@@toPrimitive]()&lt;/code&gt; 메서드를 호출하여 객체를 기본 값으로 변환합니다. &lt;code&gt;[@@toPrimitive]()&lt;/code&gt; 메소드를 직접 호출 할 필요는 없습니다 . 프리미티브 값이 필요한 객체를 만나면 JavaScript가 자동으로이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="50294983ecbb0dfe18825d0151cd8d983a64aa0d" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;toString()&lt;/code&gt; method automatically when a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; is to be represented as a text value or when a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; is referred to in a string concatenation.</source>
          <target state="translated">JavaScript calls the &lt;code&gt;toString()&lt;/code&gt; method automatically when a &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; is to be represented as a text value or when a &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; is referred to in a string concatenation.</target>
        </trans-unit>
        <trans-unit id="5066082528c32a0346c3e4a351fbb930d1b3fa37" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;toString&lt;/code&gt; method automatically when a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; is to be represented as a text value or when a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt; is referred to in a string concatenation.</source>
          <target state="translated">&lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 이 텍스트 값으로 표시되거나 문자열 연결에서 &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 이 참조 되면 JavaScript는 자동으로 &lt;code&gt;toString&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4c3f5e361a1003614ebc1a7ce6eeb53269aa5790" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;toString&lt;/code&gt; method automatically when a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; is to be represented as a text value, e.g. when a function is concatenated with a string.</source>
          <target state="translated">&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; 가 텍스트 값으로 표시 될 때 (예 : 함수가 문자열과 연결될 때) JavaScript는 &lt;code&gt;toString&lt;/code&gt; 메소드를 자동으로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="393f0b6efbb93056c0b250145a8ea958adf4262a" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;toString&lt;/code&gt; method automatically when a typed array is to be represented as a text value or when an array is referred to in a string concatenation.</source>
          <target state="translated">JavaScript 는 형식이 지정된 배열이 텍스트 값으로 표시되거나 배열이 문자열 연결에서 참조 될 때 자동으로 &lt;code&gt;toString&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="683fa5acf0e0743489be2182726e924b6e304505" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;toString&lt;/code&gt; method automatically when an array is to be represented as a text value or when an array is referred to in a string concatenation.</source>
          <target state="translated">배열이 텍스트 값으로 표시되거나 배열이 문자열 연결에서 참조 될 때 JavaScript는 &lt;code&gt;toString&lt;/code&gt; 메소드를 자동으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="184b276782b0e1581363d9931664ae6bc740c6f7" translate="yes" xml:space="preserve">
          <source>JavaScript calls the &lt;code&gt;valueOf&lt;/code&gt; method to convert an object to a primitive value. You rarely need to invoke the &lt;code&gt;valueOf&lt;/code&gt; method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</source>
          <target state="translated">JavaScript는 &lt;code&gt;valueOf&lt;/code&gt; 메소드를 호출하여 객체를 기본 값으로 변환합니다. &lt;code&gt;valueOf&lt;/code&gt; 메소드를 직접 호출 할 필요는 거의 없습니다 . 프리미티브 값이 필요한 객체를 만나면 JavaScript가 자동으로이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a577236e04190d40c6076c0d7d543e39819cea97" translate="yes" xml:space="preserve">
          <source>JavaScript classes use prototype-based inheritance.</source>
          <target state="translated">JavaScript classes use prototype-based inheritance.</target>
        </trans-unit>
        <trans-unit id="2931f30ff332619933e36eefb2c8dedc78c4d337" translate="yes" xml:space="preserve">
          <source>JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript's existing prototype-based inheritance. The class syntax &lt;em&gt;does not&lt;/em&gt; introduce a new object-oriented inheritance model to JavaScript.</source>
          <target state="translated">ECMAScript 2015에 도입 된 JavaScript 클래스는 주로 JavaScript의 기존 프로토 타입 기반 상속에 비해 구문상의 설탕입니다. 클래스 구문 &lt;em&gt;은&lt;/em&gt; JavaScript에 새로운 객체 지향 상속 모델을 도입 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f90b832f4be39c9624e04c4d939b964593b45fbc" translate="yes" xml:space="preserve">
          <source>JavaScript compressors and minifiers</source>
          <target state="translated">JavaScript 압축기 및 축소 기</target>
        </trans-unit>
        <trans-unit id="0a62b40b41ce0d42df8ba4b0874263a7aa928401" translate="yes" xml:space="preserve">
          <source>JavaScript content</source>
          <target state="translated">자바 스크립트 내용</target>
        </trans-unit>
        <trans-unit id="1e969f4dea65068f57af2163d858ddfb54949632" translate="yes" xml:space="preserve">
          <source>JavaScript documentation of core language features (pure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;ECMAScript&lt;/a&gt;, for the most part) includes the following:</source>
          <target state="translated">핵심 언어 기능에 대한 JavaScript 문서 ( 대부분 순수한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;ECMAScript&lt;/a&gt; )에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1762e80126b8c04f9760ca489f7c178ef60a0f3e" translate="yes" xml:space="preserve">
          <source>JavaScript documentation of core language features (pure &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;ECMAScript&lt;/a&gt;, for the most part) includes the following:</source>
          <target state="translated">JavaScript documentation of core language features (pure &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;ECMAScript&lt;/a&gt;, for the most part) includes the following:</target>
        </trans-unit>
        <trans-unit id="b93db76fbe081ca564a2858e45a41eafa11ee556" translate="yes" xml:space="preserve">
          <source>JavaScript does not protect the property name &lt;code&gt;hasOwnProperty&lt;/code&gt;; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an &lt;em&gt;external&lt;/em&gt;&lt;code&gt;hasOwnProperty&lt;/code&gt; to get correct results:</source>
          <target state="translated">JavaScript는 속성 이름을 보호하지 않습니다 . &lt;code&gt;hasOwnProperty&lt;/code&gt; ; 따라서 객체에이 이름의 속성이있을 가능성이있는 경우 올바른 결과를 얻으려면 &lt;em&gt;외부 &lt;/em&gt; &lt;code&gt;hasOwnProperty&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="744ac18ff13febca682b94a53d3b047df2f4abee" translate="yes" xml:space="preserve">
          <source>JavaScript has &lt;a href=&quot;http://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:</source>
          <target state="translated">JavaScript에는 &lt;a href=&quot;http://en.wikipedia.org/wiki/First-class_function&quot;&gt;일급 함수가&lt;/a&gt; 있으므로 함수를 다른 API에 인수로 전달하고 변수 및 객체의 속성 등에 저장할 수 있습니다. 많은 DOM API는이를 염두에두고 설계되었으므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f73fb099b33ee3d477b6e6ec4117cca801b107" translate="yes" xml:space="preserve">
          <source>JavaScript has a Unicode problem &amp;ndash; Mathias Bynens</source>
          <target state="translated">JavaScript에는 유니 코드 문제가 있습니다 &amp;ndash; Mathias Bynens</target>
        </trans-unit>
        <trans-unit id="fe987f3f1de727bc1d26668a4b26b5bf03d1bef6" translate="yes" xml:space="preserve">
          <source>JavaScript has allowed trailing commas in array literals since the beginning, and later added them to object literals (ECMAScript 5) and most recently (ECMAScript 2017) to function parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56309979b027f223f5f71cfacdefde8dd70b7b0d" translate="yes" xml:space="preserve">
          <source>JavaScript has both strict and type&amp;ndash;converting comparisons. A strict comparison (e.g., &lt;code&gt;===&lt;/code&gt;) is only true if the operands are of the same type and the contents match. The more commonly-used abstract comparison (e.g. &lt;code&gt;==&lt;/code&gt;) converts the operands to the same type before making the comparison. For relational abstract comparisons (e.g., &lt;code&gt;&amp;lt;=&lt;/code&gt;), the operands are first converted to primitives, then to the same type, before comparison.</source>
          <target state="translated">JavaScript에는 엄격한 변환과 형식 변환 비교가 있습니다. 피연산자가 같은 유형이고 내용이 일치하는 경우에만 엄격한 비교 (예 : &lt;code&gt;===&lt;/code&gt; )가 적용됩니다. 보다 일반적으로 사용되는 추상 비교 (예 : &lt;code&gt;==&lt;/code&gt; )는 비교하기 전에 피연산자를 동일한 유형으로 변환합니다. 관계형 추상 비교 (예 : &lt;code&gt;&amp;lt;=&lt;/code&gt; )의 경우, 피연산자는 먼저 비교 전에 프리미티브로 변환 된 다음 동일한 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e1bdbb8ec850c38a8026b2608b3250a593c52c81" translate="yes" xml:space="preserve">
          <source>JavaScript has two long-standing ways to add comments to code.</source>
          <target state="translated">JavaScript has two long-standing ways to add comments to code.</target>
        </trans-unit>
        <trans-unit id="d451ffb310870083fd5a49cb2b8ef66dfdfe1f3c" translate="yes" xml:space="preserve">
          <source>JavaScript has two ways of assigning comments in its code.</source>
          <target state="translated">JavaScript에는 코드에 주석을 할당하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ec0e823a61940b27a5f542f56623c76135407d" translate="yes" xml:space="preserve">
          <source>JavaScript ignores trailing commas in arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5fe2946ae7adfe543cac944c95cd7b341ce22" translate="yes" xml:space="preserve">
          <source>JavaScript is a superset of JSON</source>
          <target state="translated">JavaScript는 JSON의 상위 집합입니다</target>
        </trans-unit>
        <trans-unit id="b4076ff618dfacee58cdf4a93cbdfdfe84945b25" translate="yes" xml:space="preserve">
          <source>JavaScript looks up an unqualified name by searching a scope chain associated with the execution context of the script or function containing that unqualified name. The 'with' statement adds the given object to the head of this scope chain during the evaluation of its statement body. If an unqualified name used in the body matches a property in the scope chain, then the name is bound to the property and the object containing the property. Otherwise a &lt;a href=&quot;../global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">JavaScript는 규정되지 않은 이름을 포함하는 스크립트 또는 함수의 실행 컨텍스트와 연관된 범위 체인을 검색하여 규정되지 않은 이름을 찾습니다. 'with'문은 명령문 본문을 평가하는 동안 지정된 오브젝트를이 범위 체인의 헤드에 추가합니다. 본문에 사용 된 규정되지 않은 이름이 범위 체인의 특성과 일치하면 이름이 특성 및 특성을 포함하는 오브젝트에 바인드됩니다. 그렇지 않으면 &lt;a href=&quot;../global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed0db572e5996fee5b434deb324bc5076fbb6fd1" translate="yes" xml:space="preserve">
          <source>JavaScript novices often make the mistake of using &lt;a href=&quot;../global_objects/eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; where the bracket notation can be used instead.</source>
          <target state="translated">JavaScript novices often make the mistake of using &lt;a href=&quot;../global_objects/eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; where the bracket notation can be used instead.</target>
        </trans-unit>
        <trans-unit id="500d283647b665226bc80b83e62ac36d1f5c187d" translate="yes" xml:space="preserve">
          <source>JavaScript novices often make the mistake of using &lt;a href=&quot;../global_objects/eval&quot;&gt;eval&lt;/a&gt; where the bracket notation can be used instead. For example, the following syntax is often seen in many scripts.</source>
          <target state="translated">JavaScript 초보자는 종종 대괄호 표기법을 대신 사용할 수있는 &lt;a href=&quot;../global_objects/eval&quot;&gt;eval&lt;/a&gt; 을 사용하는 실수를 합니다. 예를 들어, 다음 구문은 많은 스크립트에서 자주 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21dab6f4cb682e4bba5a78456152ff1d779abee" translate="yes" xml:space="preserve">
          <source>JavaScript sources are often combined and minified to make delivering them from the server more efficient. With &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;, the debugger can map the code being executed to the original source files.</source>
          <target state="translated">JavaScript 소스는 종종 서버에서보다 효율적으로 제공하기 위해 결합 및 축소됩니다. 로 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;소스 맵&lt;/a&gt; 코드를 매핑 할 수 있습니다 디버거는 원래 소스 파일에 실행되고.</target>
        </trans-unit>
        <trans-unit id="ad8cd050ac71fdbacf40f64310ee52ea5ed02597" translate="yes" xml:space="preserve">
          <source>JavaScript sources are often combined and minified to make delivering them from the server more efficient. With &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;source maps&lt;/a&gt;, the debugger can map the code being executed to the original source files. There are two ways to assign a source map, either by using a comment or by setting a header to the JavaScript file.</source>
          <target state="translated">JavaScript 소스는 종종 서버에서보다 효율적으로 제공하기 위해 결합 및 축소됩니다. 로 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;소스 맵&lt;/a&gt; 코드를 매핑 할 수 있습니다 디버거는 원래 소스 파일에 실행되고. 주석을 사용하거나 JavaScript 파일에 헤더를 설정하여 소스 맵을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9181d1be8221d2a98ab781830924aa6d7f552254" translate="yes" xml:space="preserve">
          <source>JavaScript statements</source>
          <target state="translated">자바 스크립트 문</target>
        </trans-unit>
        <trans-unit id="259994f4d52f71d4fbed52e072b9ba70b6557f01" translate="yes" xml:space="preserve">
          <source>JavaScript statements and declarations</source>
          <target state="translated">JavaScript statements and declarations</target>
        </trans-unit>
        <trans-unit id="37b17512d10a675de7d71fd732c55ebc7a3b9f99" translate="yes" xml:space="preserve">
          <source>JavaScript typed arrays</source>
          <target state="translated">자바 스크립트 타입 배열</target>
        </trans-unit>
        <trans-unit id="d9f300a88147dae849b96edf9997d43decbfc431" translate="yes" xml:space="preserve">
          <source>JavaScript used to silently fail in contexts where what was done was an error. Strict mode throws in such cases. If your code base contains such cases, testing will be necessary to be sure nothing is broken. Once again, it can happen at the function granularity level.</source>
          <target state="translated">수행 된 작업이 오류 인 컨텍스트에서 자동으로 실패하는 JavaScript가 사용되었습니다. 이러한 경우 엄격한 모드가 발생합니다. 코드베이스에 이러한 경우가 포함되어 있으면 테스트 된 것이 없는지 테스트해야합니다. 다시 한 번, 기능 세분성 수준에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a77ef21cb7721ec6f8aebd2995c230f5309fb642" translate="yes" xml:space="preserve">
          <source>JavaScript uses 64-bit double floating-point numbers internally, which offer a very high precision. However, sometimes you may be working with 32-bit floating-point numbers, for example if you are reading values from a &lt;a href=&quot;../float32array&quot;&gt;&lt;code&gt;Float32Array&lt;/code&gt;&lt;/a&gt;. This can create confusion: Checking a 64-bit float and a 32-bit float for equality may fail even though the numbers are seemingly identical.</source>
          <target state="translated">JavaScript는 내부적으로 64 비트 이중 부동 소수점 숫자를 사용하므로 매우 높은 정밀도를 제공합니다. 그러나 때때로 &lt;a href=&quot;../float32array&quot;&gt; &lt;code&gt;Float32Array&lt;/code&gt; &lt;/a&gt; 에서 값을 읽는 경우와 같이 32 비트 부동 소수점 숫자로 작업 할 수 있습니다 . 혼동을 일으킬 수 있습니다. 64 비트 부동 소수점과 32 비트 부동 소수점이 같은지 확인해도 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc81a73fdcb27f667ca60560af29085d17998baf" translate="yes" xml:space="preserve">
          <source>JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;primitive types&lt;/a&gt;</source>
          <target state="translated">JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;primitive types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7518d19c0a8ea33bde8476c80bb0232ba1ac7e0b" translate="yes" xml:space="preserve">
          <source>JavaScript's strict mode, introduced in ECMAScript 5, is a way to &lt;em&gt;opt in&lt;/em&gt; to a restricted variant of JavaScript, thereby implicitly opting-out of &quot;&lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/Sloppy_mode&quot;&gt;sloppy mode&lt;/a&gt;&quot;. Strict mode isn't just a subset: it &lt;em&gt;intentionally&lt;/em&gt; has different semantics from normal code. Browsers not supporting strict mode will run strict mode code with different behavior from browsers that do, so don't rely on strict mode without feature-testing for support for the relevant aspects of strict mode. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.</source>
          <target state="translated">인 ECMAScript 5에서 도입 된 자바 스크립트의 엄격한 모드는하는 방법입니다 &lt;em&gt;옵트&lt;/em&gt; 하여 암시 적으로 탈퇴 아웃 &quot;의 자바 스크립트의 제한된 변형에 &lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/Sloppy_mode&quot;&gt;실수 모드&lt;/a&gt; &quot;. 엄격한 모드는 단순한 하위 집합이 아닙니다. &lt;em&gt;의도적&lt;/em&gt; 으로 일반 코드와 다른 의미가 있습니다. 엄격 모드를 지원하지 않는 브라우저는 브라우저와 동작이 다른 엄격 모드 코드를 실행하므로 엄격 모드의 관련 측면을 지원하기 위해 기능 테스트없이 엄격 모드에 의존하지 마십시오. 엄격한 모드 코드와 엄격하지 않은 모드 코드가 공존 할 수 있으므로 스크립트가 엄격하게 엄격 모드를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55db58b59d8be8a78f6efed8c161a77bb356a376" translate="yes" xml:space="preserve">
          <source>Javanese digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e32ab2db9b079eda92fa09b2355bca2f171c5d" translate="yes" xml:space="preserve">
          <source>Jeff Walden: Binary and octal numbers</source>
          <target state="translated">Jeff Walden : 이진수와 8 진수</target>
        </trans-unit>
        <trans-unit id="b658a93f5080a188c9235ee53c6be002c9eab5c1" translate="yes" xml:space="preserve">
          <source>John Resig - ECMAScript 5 Strict Mode, JSON, and More</source>
          <target state="translated">John Resig-ECMAScript 5 엄격한 모드, JSON 등</target>
        </trans-unit>
        <trans-unit id="e109b48140a2c26bae797c244c9bfbe125064793" translate="yes" xml:space="preserve">
          <source>John Resig's post on &lt;a href=&quot;http://ejohn.org/blog/objectgetprototypeof/&quot;&gt;getPrototypeOf()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/blog/objectgetprototypeof/&quot;&gt;getPrototypeOf ()&lt;/a&gt; 에 대한 John Resig의 게시물</target>
        </trans-unit>
        <trans-unit id="1cb2dd32eeadac5ce1b22baa719abf0989f79767" translate="yes" xml:space="preserve">
          <source>John Resig's post on &lt;a href=&quot;http://ejohn.org/blog/objectgetprototypeof/&quot;&gt;getPrototypeOf&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/blog/objectgetprototypeof/&quot;&gt;getPrototypeOf&lt;/a&gt; 에 대한 John Resig의 게시물</target>
        </trans-unit>
        <trans-unit id="ce7fefe555466a8ed76878d9ad48a19e9f5ed947" translate="yes" xml:space="preserve">
          <source>Joining an array four different ways</source>
          <target state="translated">4 가지 다른 방법으로 배열에 참여</target>
        </trans-unit>
        <trans-unit id="ca75637a97b45df264928724e8c930f8f2374d29" translate="yes" xml:space="preserve">
          <source>Joining an array-like object</source>
          <target state="translated">배열과 같은 객체 결합</target>
        </trans-unit>
        <trans-unit id="58cf6e8e2b4250d2ee6acd3e6658db4bca072f47" translate="yes" xml:space="preserve">
          <source>Joins all elements of an array into a string.</source>
          <target state="translated">배열의 모든 요소를 ​​문자열로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="c5cf3b0b8befbf9cb5a1bdb4c752da3d1915e294" translate="yes" xml:space="preserve">
          <source>Joins all elements of an array into a string. See also &lt;a href=&quot;../array/join&quot;&gt;&lt;code&gt;Array.prototype.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 모든 요소를 ​​문자열로 결합합니다. &lt;a href=&quot;../array/join&quot;&gt; &lt;code&gt;Array.prototype.join()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="562ca02600cc3d32d6d31461ceb9523ce4867295" translate="yes" xml:space="preserve">
          <source>Joins all elements of an array into a string. See also &lt;a href=&quot;array/join&quot;&gt;&lt;code&gt;Array.prototype.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 모든 요소를 ​​문자열로 결합합니다. &lt;a href=&quot;array/join&quot;&gt; &lt;code&gt;Array.prototype.join()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42a137bec040460e475257375a4cce301ea33e78" translate="yes" xml:space="preserve">
          <source>Just in the same manner at which you can check if an object is an instance of a class using the &lt;code&gt;instanceof&lt;/code&gt; keyword, we can also use &lt;code&gt;Symbol.hasInstance&lt;/code&gt; for such checks also.</source>
          <target state="translated">Just in the same manner at which you can check if an object is an instance of a class using the &lt;code&gt;instanceof&lt;/code&gt; keyword, we can also use &lt;code&gt;Symbol.hasInstance&lt;/code&gt; for such checks also.</target>
        </trans-unit>
        <trans-unit id="ef4fda55212e685f6922b9ab18069589fa05df90" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;../statements/const#Description&quot;&gt;&lt;code&gt;const&lt;/code&gt;&lt;/a&gt; the &lt;code&gt;let&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; create properties of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; object when declared globally (in the top-most scope).</source>
          <target state="translated">Just like &lt;a href=&quot;../statements/const#Description&quot;&gt; &lt;code&gt;const&lt;/code&gt; &lt;/a&gt; the &lt;code&gt;let&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; create properties of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; object when declared globally (in the top-most scope).</target>
        </trans-unit>
        <trans-unit id="31908c57894e69aa4075c11a7827e02a40c3d02e" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;Array&lt;/code&gt;s, &lt;code&gt;Map&lt;/code&gt;s can be cloned:</source>
          <target state="translated">Just like &lt;code&gt;Array&lt;/code&gt; s, &lt;code&gt;Map&lt;/code&gt; s can be cloned:</target>
        </trans-unit>
        <trans-unit id="3171f5f59eaafdb8bfb35802f80f8d75b1cb8d82" translate="yes" xml:space="preserve">
          <source>Just like Arrays, Maps can be cloned:</source>
          <target state="translated">배열과 마찬가지로지도를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97172eff647c6d5219091962ca2611beb32eeb98" translate="yes" xml:space="preserve">
          <source>Just like spread for argument lists, &lt;code&gt;...&lt;/code&gt; can be used anywhere in the array literal and it can be used multiple times.</source>
          <target state="translated">인수 목록의 스프레드와 마찬가지로 &lt;code&gt;...&lt;/code&gt; 은 배열 리터럴의 어느 곳에서나 사용할 수 있으며 여러 번 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="448cce5867e24f2c805aa405815a60c7e121ab75" translate="yes" xml:space="preserve">
          <source>Just like spread for argument lists, &lt;code&gt;...&lt;/code&gt; can be used anywhere in the array literal, and may be used more than once.</source>
          <target state="translated">Just like spread for argument lists, &lt;code&gt;...&lt;/code&gt; can be used anywhere in the array literal, and may be used more than once.</target>
        </trans-unit>
        <trans-unit id="9bc13bdbc40dbbf16930c00359072c0a20a24037" translate="yes" xml:space="preserve">
          <source>Just like with class statements, the class body of class expressions is executed in &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;.</source>
          <target state="translated">클래스 명령문과 마찬가지로 클래스 표현식의 클래스 본문은 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 로 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="334d0e27a60ef5578e3f70a25c79218f4fe82068" translate="yes" xml:space="preserve">
          <source>Just like with regular functions, the value of &lt;code&gt;this&lt;/code&gt; within methods depends on how they are called. Sometimes it is useful to override this behavior so that &lt;code&gt;this&lt;/code&gt; within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:</source>
          <target state="translated">Just like with regular functions, the value of &lt;code&gt;this&lt;/code&gt; within methods depends on how they are called. Sometimes it is useful to override this behavior so that &lt;code&gt;this&lt;/code&gt; within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:</target>
        </trans-unit>
        <trans-unit id="ea8d5d9dd5e3281acced50c00b1bc4da4fe58b29" translate="yes" xml:space="preserve">
          <source>Kannada digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac24ed589bbf9e00c5b7a9a247ae0c9a606ebae" translate="yes" xml:space="preserve">
          <source>Kayah Li digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d426e0b0b4de27b15660b01fc62946e5938d84" translate="yes" xml:space="preserve">
          <source>Keep in mind that returning object literals using the concise body syntax &lt;code&gt;params =&amp;gt; {object:literal}&lt;/code&gt; will not work as expected.</source>
          <target state="translated">간결한 본문 구문 &lt;code&gt;params =&amp;gt; {object:literal}&lt;/code&gt; 을 사용하여 객체 리터럴을 반환 하면 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45641e7e3979cd965842335c014475cef41a87fc" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;em&gt;data&lt;/em&gt; itself is not cloned</source>
          <target state="translated">것을 명심 &lt;em&gt;데이터&lt;/em&gt; 자체가 복제되지 않는다</target>
        </trans-unit>
        <trans-unit id="2c4957a169b89c153b565ae42b9ef3901c360eac" translate="yes" xml:space="preserve">
          <source>Key Order</source>
          <target state="translated">Key Order</target>
        </trans-unit>
        <trans-unit id="d8fda7e7073ab6e066cc5fdfad0bb7200902f96f" translate="yes" xml:space="preserve">
          <source>Key Types</source>
          <target state="translated">Key Types</target>
        </trans-unit>
        <trans-unit id="58858bc70a5dcc03fe17b9c1101d84c397faeb12" translate="yes" xml:space="preserve">
          <source>Key equality</source>
          <target state="translated">키 평등</target>
        </trans-unit>
        <trans-unit id="418428fa68e56676339f9e99c7d969243f4dcf32" translate="yes" xml:space="preserve">
          <source>Key equality for -0 and 0</source>
          <target state="translated">-0과 0의 키 평등</target>
        </trans-unit>
        <trans-unit id="6563e14e4c7f853e64030f302a776db20d4f7014" translate="yes" xml:space="preserve">
          <source>Key equality is based on the &quot;SameValueZero&quot; algorithm: &lt;code&gt;NaN&lt;/code&gt; is considered the same as &lt;code&gt;NaN&lt;/code&gt; (even though &lt;code&gt;NaN !== NaN&lt;/code&gt;) and all other values are considered equal according to the semantics of the &lt;code&gt;===&lt;/code&gt; operator. In the current ECMAScript specification &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal, although this was not so in earlier drafts. See &quot;Value equality for -0 and 0&quot; in the &lt;a href=&quot;#Browser_compatibility&quot;&gt;browser compatibility&lt;/a&gt; table for details.</source>
          <target state="translated">키 어떤지는 &quot;SameValueZero&quot;알고리즘에 기초한다 : &lt;code&gt;NaN&lt;/code&gt; 이이 같은 고려 &lt;code&gt;NaN&lt;/code&gt; 이 (비록 &lt;code&gt;NaN !== NaN&lt;/code&gt; ) 모든 다른 값의 의미에있어서 동일하다고 &lt;code&gt;===&lt;/code&gt; 연산자. 현재 ECMAScript 사양에서 &lt;code&gt;-0&lt;/code&gt; 과 &lt;code&gt;+0&lt;/code&gt; 은 이전 초안에서는 같지 않지만 동일하게 간주됩니다. 자세한 내용은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 표 에서 &quot;-0과 0의 값 평등&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="560f7deb9fbd3419ef9f86474562f05574fd62b6" translate="yes" xml:space="preserve">
          <source>Key equality is based on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Same-value-zero_equality&quot;&gt;&lt;code&gt;sameValueZero&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">Key equality is based on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Same-value-zero_equality&quot;&gt; &lt;code&gt;sameValueZero&lt;/code&gt; &lt;/a&gt; algorithm.</target>
        </trans-unit>
        <trans-unit id="e058bd41ac73e100088d83fe4389c6bbf1edf666" translate="yes" xml:space="preserve">
          <source>Key iterator doesn't ignore holes</source>
          <target state="translated">키 반복기는 구멍을 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4b1e3d15db5cb909c8e5c3bc50d9848da8a66a6" translate="yes" xml:space="preserve">
          <source>Key of each iteration.</source>
          <target state="translated">Key of each iteration.</target>
        </trans-unit>
        <trans-unit id="21bcd8b61da1a79642efef50ec42b117725cfd0b" translate="yes" xml:space="preserve">
          <source>Keyed collections</source>
          <target state="translated">키 컬렉션</target>
        </trans-unit>
        <trans-unit id="e858ac0582f24507144f71eb06b9663abeb13fe9" translate="yes" xml:space="preserve">
          <source>Keys of WeakMaps are of the type &lt;code&gt;Object&lt;/code&gt; only. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;Primitive data types&lt;/a&gt; as keys are not allowed (e.g. a &lt;a href=&quot;symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; can't be a &lt;code&gt;WeakMap&lt;/code&gt; key).</source>
          <target state="translated">WeakMaps의 키는 &lt;code&gt;Object&lt;/code&gt; 유형 입니다. 키와 같은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Primitive&quot;&gt;기본 데이터 유형&lt;/a&gt; 은 허용되지 않습니다 (예 : &lt;a href=&quot;symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;WeakMap&lt;/code&gt; 키일 수 없음 ).</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="a3cf5eac597b4cdb5c1551ce55da00eed7f5f487" translate="yes" xml:space="preserve">
          <source>Khmer digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ecf2e0d44300af965f346ef743f1e9c72a537a" translate="yes" xml:space="preserve">
          <source>Khudawadi digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325af73483fcf5c08a91b8eb3976b4d6df09fb26" translate="yes" xml:space="preserve">
          <source>Labeled function declarations</source>
          <target state="translated">레이블이있는 함수 선언</target>
        </trans-unit>
        <trans-unit id="b410fe2d42fb15e228b8ae7a8709673d13e20776" translate="yes" xml:space="preserve">
          <source>Labeled functions</source>
          <target state="translated">라벨이 붙은 기능</target>
        </trans-unit>
        <trans-unit id="fbfac8f52cada2e823dffb384cec8f92ee566cc1" translate="yes" xml:space="preserve">
          <source>Labeled version added.</source>
          <target state="translated">라벨 버전이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="18ec3a98210aeff5bfef56e8e71a0e2c6e2d980e" translate="yes" xml:space="preserve">
          <source>Labelled Block Statement</source>
          <target state="translated">라벨링 된 블록 설명</target>
        </trans-unit>
        <trans-unit id="50550ca3f3e20c021daaadbf48051f0b1c9e3492" translate="yes" xml:space="preserve">
          <source>Language Display Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fff668f8644ef34b4e4c1bbce33e800d4528eeb" translate="yes" xml:space="preserve">
          <source>Language is one of the core features of a locale. The Unicode specification treats the language identifier of a locale as the language and the region together (to make a distiction between dialects and variations, e.g. British English vs. American English). The &lt;code&gt;language&lt;/code&gt; property of a &lt;a href=&quot;../locale&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; returns strictly the locale's language subtag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7104e2c25aa070a91e885d5ff1817c33ae1079" translate="yes" xml:space="preserve">
          <source>Lao digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41fcf1417b00add077b976c546098d3e0536e21" translate="yes" xml:space="preserve">
          <source>Larger numbers can be represented using the &lt;a href=&quot;bigint&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Larger numbers can be represented using the &lt;a href=&quot;bigint&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; type.</target>
        </trans-unit>
        <trans-unit id="d4d22d5671692704cf9c12c2f01bc613043ef602" translate="yes" xml:space="preserve">
          <source>Last expression is evaluated</source>
          <target state="translated">마지막 표현이 평가됩니다</target>
        </trans-unit>
        <trans-unit id="7071422e0583b8e4fb6b9167f225e466e2e38239" translate="yes" xml:space="preserve">
          <source>Lastly, let's examine minification. With using &lt;code&gt;Function()&lt;/code&gt; as shown above, you can minify the code string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; far more efficiently because the function arguments names can be minified too as seen in the minified code below.</source>
          <target state="translated">Lastly, let's examine minification. With using &lt;code&gt;Function()&lt;/code&gt; as shown above, you can minify the code string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; far more efficiently because the function arguments names can be minified too as seen in the minified code below.</target>
        </trans-unit>
        <trans-unit id="330564a59eaa49b0ee4ffeca30a4dbf5c461f71d" translate="yes" xml:space="preserve">
          <source>Lastly, let's examine minification. With using &lt;code&gt;Function()&lt;/code&gt; as shown above, you can minify the code string passed to &lt;code&gt;runCodeWithDateFunction&lt;/code&gt; far more efficiently because the function arguments names can be minified too as seen in the minified code below.</source>
          <target state="translated">마지막으로 축소를 살펴 보겠습니다. 위와 같이 &lt;code&gt;Function()&lt;/code&gt; 을 사용하면 아래 축소 코드에서 볼 수 있듯이 함수 인수 이름을 축소 할 수 있으므로 &lt;code&gt;runCodeWithDateFunction&lt;/code&gt; 에 전달 된 코드 문자열을 훨씬 효율적 으로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aa4aab1a73079a7a03a21d601b44b620c94346c" translate="yes" xml:space="preserve">
          <source>Latin digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38df12cc2e08bdc92e4c234437ee9953901f40b0" translate="yes" xml:space="preserve">
          <source>Leading and trailing spaces in the argument are ignored.</source>
          <target state="translated">Leading and trailing spaces in the argument are ignored.</target>
        </trans-unit>
        <trans-unit id="ed2e9e2a0d6f7444c85a01dfc9c3452d30b19c69" translate="yes" xml:space="preserve">
          <source>Leading zeros and decimal points</source>
          <target state="translated">선행 0과 소수점</target>
        </trans-unit>
        <trans-unit id="839d8fec4eaf98bd81c386bc951d0be390bc6b7d" translate="yes" xml:space="preserve">
          <source>Leading zeros are prohibited. A decimal point must be followed by at least one digit. &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are unsupported.</source>
          <target state="translated">Leading zeros are prohibited. A decimal point must be followed by at least one digit. &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are unsupported.</target>
        </trans-unit>
        <trans-unit id="3550917d985bcf43d7da8e759629c3801030e94d" translate="yes" xml:space="preserve">
          <source>Left bracket, i.e. &quot;(&quot;</source>
          <target state="translated">왼쪽 대괄호, 즉 &quot;(&quot;</target>
        </trans-unit>
        <trans-unit id="4e329848308f51ed814ae607db0d48ff6b12bc29" translate="yes" xml:space="preserve">
          <source>Left operand with another assignment operator</source>
          <target state="translated">다른 대입 연산자와 왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="5ab1c2256c381beee948a90f36638f4339d1df90" translate="yes" xml:space="preserve">
          <source>Left shift</source>
          <target state="translated">왼쪽 교대</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
