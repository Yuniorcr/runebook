<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="javascript">
    <body>
      <group id="javascript">
        <trans-unit id="e410f550731be85f946b7f2f4aed03a005c57a1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; is omitted, &lt;code&gt;substr()&lt;/code&gt; extracts characters to the end of the string.</source>
          <target state="translated">경우 &lt;code&gt;length&lt;/code&gt; 생략 &lt;code&gt;substr()&lt;/code&gt; 문자열의 끝으로 추출 문자.</target>
        </trans-unit>
        <trans-unit id="a34d5712abc36aaa2eaef3f633100f03db354c27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is specified and is smaller than &lt;code&gt;initial&lt;/code&gt;, a &lt;a href=&quot;../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;maximum&lt;/code&gt; 지정보다 작은되는 &lt;code&gt;initial&lt;/code&gt; 하는 &lt;a href=&quot;../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c0f0bc257bf3b949201321dcae7fcebf0bb14339" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memoryDescriptor&lt;/code&gt; is not of type object, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;memoryDescriptor&lt;/code&gt; 가 객체 유형이 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73a182f41773189b8cfdf256c034f5a1d80c29e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is not a &lt;a href=&quot;../module&quot;&gt;&lt;code&gt;WebAssembly.Module&lt;/code&gt;&lt;/a&gt; object instance, a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 이 &lt;a href=&quot;../module&quot;&gt; &lt;code&gt;WebAssembly.Module&lt;/code&gt; &lt;/a&gt; 객체 인스턴스 가 아닌 경우 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ae5c7ddce76e5aae957eb4fa1138ed2f02a10861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;onFulfilled&lt;/code&gt; returns a promise, the return value of &lt;code&gt;then&lt;/code&gt; will be resolved/rejected by the promise.</source>
          <target state="translated">경우 &lt;code&gt;onFulfilled&lt;/code&gt; 이 약속을 반환의 반환 값 &lt;code&gt;then&lt;/code&gt; / 해결 약속에 의해 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2728a4f70add9e2f77317adda6b2ef26418eaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parseFloat&lt;/code&gt; encounters a character other than a plus sign (&lt;code&gt;+&lt;/code&gt;), minus sign (&lt;code&gt;-&lt;/code&gt; U+002D HYPHEN-MINUS), numeral (&lt;code&gt;0&lt;/code&gt;&amp;ndash;&lt;code&gt;9&lt;/code&gt;), decimal point (&lt;code&gt;.&lt;/code&gt;), or exponent (&lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt;), it returns the value up to that character, ignoring the invalid character and characters following it.</source>
          <target state="translated">경우 &lt;code&gt;parseFloat&lt;/code&gt; A A 더하기 기호 (이외의 문자가 발생 &lt;code&gt;+&lt;/code&gt; (), 빼기 기호 &lt;code&gt;-&lt;/code&gt; U + 002D 하이픈-MINUS), 숫자 ( &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; ) (소수점 &lt;code&gt;.&lt;/code&gt; ), 또는 지수를 ( &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 를 ), 그것은을 반환 유효하지 않은 문자와 그 뒤에 오는 문자를 무시하고 해당 문자까지 값</target>
        </trans-unit>
        <trans-unit id="83728eb0d2a9e584dc04b1ee5d31294530473376" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parseInt&lt;/code&gt; encounters a character that is not a numeral in the specified &lt;code&gt;radix&lt;/code&gt;, it ignores it and all succeeding characters and returns the integer value parsed up to that point. &lt;code&gt;parseInt&lt;/code&gt; truncates numbers to integer values. Leading and trailing spaces are allowed.</source>
          <target state="translated">&lt;code&gt;parseInt&lt;/code&gt; 가 지정된 &lt;code&gt;radix&lt;/code&gt; 의 숫자가 아닌 문자를 만나는 경우 , 그것을 무시하고 계속되는 모든 문자와 반환 정수 값은 그 시점까지 분석. &lt;code&gt;parseInt&lt;/code&gt; 는 숫자를 정수 값으로 자릅니다. 선행 및 후행 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ead9333b62110d8b1b732ad127cf111fdc2eaf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parseInt&lt;/code&gt; encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding characters and returns the integer value parsed up to that point. &lt;code&gt;parseInt&lt;/code&gt; truncates numbers to integer values. Leading and trailing spaces are allowed.</source>
          <target state="translated">경우 &lt;code&gt;parseInt&lt;/code&gt; 지정된 기수 숫자가 아닌 문자를 만나면, 그것을 무시하고 계속되는 모든 문자와 반환 정수 값은 그 시점까지 분석. &lt;code&gt;parseInt&lt;/code&gt; 는 숫자를 정수 값으로 자릅니다. 선행 및 후행 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffbeddf0bcd7aec9bc1eee89d991e6401f78d4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision&lt;/code&gt; is not between 1 and 100 (inclusive), a &lt;a href=&quot;../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown. Implementations are allowed to support larger and smaller values as well. ECMA-262 only requires a precision of up to 21 significant digits.</source>
          <target state="translated">경우 &lt;code&gt;precision&lt;/code&gt; 1과 100 (포함) 사이에하지하는 &lt;a href=&quot;../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생합니다. 구현은 더 크고 작은 값도 지원할 수 있습니다. ECMA-262는 최대 21 자리의 정밀도 만 요구합니다.</target>
        </trans-unit>
        <trans-unit id="46150c365467758d22f0868ddafd9b7825000fcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;precision&lt;/code&gt; is not between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt; (inclusive), a &lt;a href=&quot;../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown. Implementations are allowed to support larger and smaller values as well. ECMA-262 only requires a precision of up to 21 significant digits.</source>
          <target state="translated">경우 &lt;code&gt;precision&lt;/code&gt; 사이 아닌 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;100&lt;/code&gt; (포함)하는 &lt;a href=&quot;../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생합니다. 구현은 더 크고 작은 값도 지원할 수 있습니다. ECMA-262는 최대 21 개의 유효 숫자의 정밀도 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9a5460969a95744dffb5bbddf36d4bfb1069be0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;proto&lt;/code&gt; is neither of these a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;proto&lt;/code&gt; 가 이들 중 어느 것도 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33c87e445a7edd2b640f50dae6ac2b0133882f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replacer&lt;/code&gt; is an array, the array's values indicate the names of the properties in the object that should be included in the resulting JSON string.</source>
          <target state="translated">경우 &lt;code&gt;replacer&lt;/code&gt; 배열이며, 배열의 값은 결과 JSON 문자열에 포함되어야하는 객체의 속성의 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3c3a227a6da9d264dbe28f5f791a62dedb0625b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return(&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; is called on a generator that is already in &quot;completed&quot; state, the generator will remain in &quot;completed&quot; state.</source>
          <target state="translated">경우 &lt;code&gt;return(&lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; &quot;완료&quot;상태에 이미 발전기에서 호출, 발전기가 &quot;완료&quot;상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="87bf4b6e3dc943f062b1864ad40de7d0964087f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return(value)&lt;/code&gt; is called on a generator that is already in &quot;completed&quot; state, the generator will remain in &quot;completed&quot; state. If no argument is provided, the return object is the same as if &lt;code&gt;.next()&lt;/code&gt;. If an argument is provided, it will be set to the value of the &lt;code&gt;value&lt;/code&gt; property of the returned object.</source>
          <target state="translated">경우 &lt;code&gt;return(value)&lt;/code&gt; &quot;완료&quot;상태에 이미 발전기에서 호출, 발전기가 &quot;완료&quot;상태를 유지합니다. 인수가 제공되지 않으면 반환 객체는 if &lt;code&gt;.next()&lt;/code&gt; . 인수가 제공되면 , 리턴 된 오브젝트 의 &lt;code&gt;value&lt;/code&gt; 특성 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc1bfe2351b82485683c733bf222344eda1527d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;separator&lt;/code&gt; is a regular expression that contains capturing parentheses &lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;, matched results are included in the array.</source>
          <target state="translated">&lt;code&gt;separator&lt;/code&gt; 가 캡처 괄호 &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 를 포함하는 정규식 인 경우 일치하는 결과가 배열에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d1eff576ddb621e4680b204ed4d5b41859eeef85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;separator&lt;/code&gt; is a regular expression that contains capturing parentheses, then each time &lt;code&gt;separator&lt;/code&gt; is matched, the results (including any undefined results) of the capturing parentheses are spliced into the output array.</source>
          <target state="translated">&lt;code&gt;separator&lt;/code&gt; 가 캡처 괄호를 포함하는 정규식 인 경우 , &lt;code&gt;separator&lt;/code&gt; 가 일치 할 때마다 캡처 괄호 의 결과 (정의되지 않은 결과 포함)가 출력 배열에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="58a1c53b01b40592a9c84549b9f166da18ea38eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is a negative number, the index starts counting from the end of the string. Its value is capped at &lt;code&gt;-str.length&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 음의 번호입니다, 인덱스가 문자열의 끝에서 계산을 시작합니다. 값은 &lt;code&gt;-str.length&lt;/code&gt; 로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="c54578109a534f15d42b5a741a3d3d14d8a65f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is a positive number, the index starts counting at the start of the string. Its value is capped at &lt;code&gt;str.length&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 양수이며, 인덱스는 문자열의 시작에서 계산을 시작합니다. 그 값은 &lt;code&gt;str.length&lt;/code&gt; 에 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca01d0a0b0471740d571f8985792b98bb6955453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is negative, it is treated as &lt;code&gt;array.length + start&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 부정적으로, 그것은 처리 &lt;code&gt;array.length + start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a731fd434daa5cb19e9e29afc38306b20ebfb1ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is negative, it is treated as &lt;code&gt;length+start&lt;/code&gt; where &lt;code&gt;length&lt;/code&gt; is the length of the array. If &lt;code&gt;end&lt;/code&gt; is negative, it is treated as &lt;code&gt;length+end&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 제외하고,이를 취급된다 &lt;code&gt;length+start&lt;/code&gt; 여기서 &lt;code&gt;length&lt;/code&gt; 배열의 길이이다. 경우 &lt;code&gt;end&lt;/code&gt; 부의 경우, 그것은로 취급 &lt;code&gt;length+end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4de0599f1ce5809ec70b824f6abdd7e50e9e2834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is omitted, &lt;code&gt;copyWithin&lt;/code&gt; will copy from index &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 생략 &lt;code&gt;copyWithin&lt;/code&gt; 인덱스 복사됩니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebf5416996cbb15b5dc86c882e373b81b313cbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; is omitted, &lt;code&gt;copyWithin&lt;/code&gt; will copy from the start (defaults to 0).</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 생략 &lt;code&gt;copyWithin&lt;/code&gt; 는 처음부터 (0 기본값)를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="779eb5bbe71bf9f737544ad79ab2ebdb40b507a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tableDescriptor&lt;/code&gt; is not of type object, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;tableDescriptor&lt;/code&gt; 가 object 유형이 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e03af582a3944b0e649958576a4fa9f071ece201" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is at or greater than &lt;code&gt;arr.length&lt;/code&gt;, nothing will be copied. If &lt;code&gt;target&lt;/code&gt; is positioned after &lt;code&gt;start&lt;/code&gt;, the copied sequence will be trimmed to fit &lt;code&gt;arr.length&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;target&lt;/code&gt; 또는보다 큰 &lt;code&gt;arr.length&lt;/code&gt; , 아무것도 복사되지 않습니다. 경우 &lt;code&gt;target&lt;/code&gt; 뒤에 배치되는 &lt;code&gt;start&lt;/code&gt; , 복사 된 순서에 맞게 트리밍한다 &lt;code&gt;arr.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0d8e33e57948f6db6a21fc620101b71b816549" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is not extensible, &lt;code&gt;Object.getPrototypeOf(proxy)&lt;/code&gt; method must return the same value as &lt;code&gt;Object.getPrototypeOf(target)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 을 확장 할 수없는 경우 &lt;code&gt;Object.getPrototypeOf(proxy)&lt;/code&gt; 메소드는 &lt;code&gt;Object.getPrototypeOf(target)&lt;/code&gt; 과 동일한 값을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d26238ec78eee84e2aeb55c52477788256e17a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is not extensible, the &lt;code&gt;prototype&lt;/code&gt; parameter must be the same value as &lt;code&gt;Object.getPrototypeOf(target)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 을 확장 할 수없는 경우 &lt;code&gt;prototype&lt;/code&gt; 매개 변수는 &lt;code&gt;Object.getPrototypeOf(target)&lt;/code&gt; 과 동일한 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="984a9eed37b95f2c80689bed658a7a680c02c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this&lt;/code&gt; is a mystery, please refer to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;this document&lt;/a&gt; for more information on how &lt;code&gt;this&lt;/code&gt; works. To summarize, &lt;code&gt;this&lt;/code&gt; refers to the instance. Instances are created when the &lt;code&gt;new&lt;/code&gt; keyword is invoked. Otherwise, &lt;code&gt;this&lt;/code&gt; will default to the window &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;this&lt;/code&gt; 신비를 참조하시기 바랍니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;이 문서의&lt;/a&gt; 방법에 대한 자세한 내용은 &lt;code&gt;this&lt;/code&gt; 작동합니다. 요약하면 &lt;code&gt;this&lt;/code&gt; 인스턴스를 나타냅니다. &lt;code&gt;new&lt;/code&gt; 키워드가 호출 되면 인스턴스가 생성 됩니다. 그렇지 않으면, &lt;code&gt;this&lt;/code&gt; 창을 기본값으로&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt; 범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c19cd77cae60ad00d362fc1024e84e33d0571105" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;three&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, nothing will happen, &lt;code&gt;four&lt;/code&gt; does not matter, and also the &lt;code&gt;launchRocket()&lt;/code&gt; function in the &lt;code&gt;else&lt;/code&gt; case will not be executed.</source>
          <target state="translated">경우 &lt;code&gt;three&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 아무것도 일어날 것 &lt;code&gt;four&lt;/code&gt; 중요하지 않습니다, 또한 &lt;code&gt;launchRocket()&lt;/code&gt; 의 기능이 &lt;code&gt;else&lt;/code&gt; 경우는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eef6456246e4dbfc287e8737faddd2509501cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toString()&lt;/code&gt; is given a &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; less than &lt;code&gt;2&lt;/code&gt; or greater than &lt;code&gt;36&lt;/code&gt;, a &lt;a href=&quot;../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;toString()&lt;/code&gt; 주어진되는 &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 미만 &lt;code&gt;2&lt;/code&gt; 보다 크거나 &lt;code&gt;36&lt;/code&gt; 하는 &lt;a href=&quot;../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="6c379906b5792e3372d4efc200a114b3805195e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toString()&lt;/code&gt; is given a radix less than 2 or greater than 36, a &lt;a href=&quot;../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;toString()&lt;/code&gt; 36보다 2 이상의 기수보다 덜 부여하는 &lt;a href=&quot;../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생된다.</target>
        </trans-unit>
        <trans-unit id="ed0a1bf3b0563282d5e450783f1851ac37bf1a0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not a number, then it will be converted to a number first, then converted to a 32-bit unsigned integer.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 숫자가 아닌 경우 먼저 숫자로 변환 된 다음 부호없는 32 비트 정수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2747de4d9fc8c30f2b40be49e35fdbf847eb82f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;index&lt;/em&gt; is greater than or equal to &lt;a href=&quot;length&quot;&gt;&lt;code&gt;Table.prototype.length&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;../../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;em&gt;지수&lt;/em&gt; 보다 크거나 같다 &lt;a href=&quot;length&quot;&gt; &lt;code&gt;Table.prototype.length&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;../../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c1e63156a59a69e643e2a9b0e2e65948c77850e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is not an exported WebAssembly function or &lt;code&gt;&lt;a href=&quot;../../null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;, a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;em&gt;값이&lt;/em&gt; 내 보낸 WebAssembly 기능인지 아닌지 &lt;code&gt;&lt;a href=&quot;../../null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 하는 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1f4c5491a947837a75b2577ec9165501da34cd8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;radix&lt;/var&gt; is &lt;code&gt;undefined&lt;/code&gt; or 0 (or absent), JavaScript assumes the following:</source>
          <target state="translated">만약 &lt;var&gt;radix&lt;/var&gt; 되어 &lt;code&gt;undefined&lt;/code&gt; 또는 0 (결석)이, 자바 스크립트는 다음을 가정합니다 :</target>
        </trans-unit>
        <trans-unit id="bed881bbe4332a3924a8e5000bd3b3ce26c729d3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; is used a function name and the symbol has a description, the method's name is the description in square brackets.</source>
          <target state="translated">경우 &lt;a href=&quot;../symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 함수 이름을 사용하고, 기호는 설명이 메서드의 이름은 대괄호의 설명이다.</target>
        </trans-unit>
        <trans-unit id="6c5ecf5b73187ab3241c34814c90ceb806d68640" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; is specified, the value computed by parsing is &lt;em&gt;transformed&lt;/em&gt; before being returned. Specifically, the computed value and all its properties (beginning with the most nested properties and proceeding to the original value itself) are individually run through the &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt;. Then it is called, with the object containing the property being processed as &lt;code&gt;this&lt;/code&gt;, and with the property name as a string, and the property value as arguments. If the &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; function returns &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; (or returns no value, for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; 지정되어, 해석에 의해 계산되는 값은 &lt;em&gt;변환 된&lt;/em&gt; 리턴 전에. 특히, 계산 된 값과 모든 속성 (가장 중첩 된 속성으로 시작하여 원래 값 자체로 진행)은 개별적으로 &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; 를 통해 실행됩니다 . 그런 다음 속성을 포함하는 객체를 &lt;code&gt;this&lt;/code&gt; 로 처리 하고 속성 이름을 문자열로, 속성 값을 인수로 사용하여 호출됩니다. 경우] &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; 기능을 리턴 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; (실행 기능의 단부 떨어지면 또는 리턴 값 없음, 예를 들면,), 속성은 개체로부터 삭제된다. 그렇지 않으면 속성이 반환 값으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c53eaa65f5d849d2ba7af580ec11f6071fb51361" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is passed to &lt;code&gt;findIndex()&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; inside each invocation of the &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt;. If it is not provided, then &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 파라미터가 전달 &lt;code&gt;findIndex()&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 의 내부에 각 호출 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; . 제공되지 않은 경우&lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3191155df0440c882d493d118c3dac1f4c66d1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;every&lt;/code&gt;, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 매개 변수에 제공되는 &lt;code&gt;every&lt;/code&gt; , 그것은 콜백의로 사용됩니다 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f498864454499bf2fa726743bb2df845d90f352" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;filter&lt;/code&gt;, it will be used as the callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 파라미터가 제공되는 &lt;code&gt;filter&lt;/code&gt; , 그것의 콜백으로 사용될 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d22cacfb6b4ad93d1afb332b58bc2b8b9e92dbe4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;find&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; value inside each invocation of the &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt;. If it is not provided, then &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 의 파라미터가 제공된다 &lt;code&gt;find&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 의 내부 값 각 호출 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; . 제공되지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09097dc35d89b7d28dbca20d40abc8970c3cab00" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;forEach()&lt;/code&gt;, it will be passed to &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 파라미터가 제공된다 &lt;code&gt;forEach()&lt;/code&gt; ,이를 전달 될 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 그것으로 사용하기 위해 호출 될 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76ab4918e0c8bd05f962be5b62c98b05000b19de" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;forEach()&lt;/code&gt;, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 파라미터가 제공된다 &lt;code&gt;forEach()&lt;/code&gt; , 그것의 콜백으로 사용될 &lt;code&gt;this&lt;/code&gt; 값. &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 에 의해 최종적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ead08dc3ec7c47ac1db79cebb6c9921620ff42a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;forEach&lt;/code&gt;, it will be passed to &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 매개 변수로 제공 &lt;code&gt;forEach&lt;/code&gt; , 전달됩니다 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa8f21a8595a09932fdcda7eaee1666d3af2bf6a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;map()&lt;/code&gt;, it will be passed to &lt;code&gt;&lt;var&gt;mapFn&lt;/var&gt;&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;mapFn&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 매개 변수가 제공됩니다 &lt;code&gt;map()&lt;/code&gt; , 그것은 전달됩니다 &lt;code&gt;&lt;var&gt;mapFn&lt;/var&gt;&lt;/code&gt; 호출 할 때 그와 같은 사용을 위해, &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;mapFn&lt;/var&gt;&lt;/code&gt; 은 에 따라 결정되는 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ad3e1dc3914885dba756cd8beedafc58dbd95b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; parameter is provided to &lt;code&gt;some()&lt;/code&gt;, it will be used as the callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 파라미터에 제공되는 &lt;code&gt;some()&lt;/code&gt; , 그것의 콜백으로 사용될 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2836faa89237b75d06562d178e0d8e7b62b20e4a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Promise&lt;/code&gt; is passed to an &lt;code&gt;await&lt;/code&gt; expression, it waits for the &lt;code&gt;Promise&lt;/code&gt; to be fulfilled and returns the fulfilled value.</source>
          <target state="translated">경우 &lt;code&gt;Promise&lt;/code&gt; 에 전달 &lt;code&gt;await&lt;/code&gt; 를 표현식에 대한, 그것은 기다립니다 &lt;code&gt;Promise&lt;/code&gt; 성취와 성취 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0cd65c256b789ded1c56afc95a831c106e6d12" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;reviver&lt;/code&gt; is specified, the value computed by parsing is &lt;em&gt;transformed&lt;/em&gt; before being returned. Specifically, the computed value and all its properties (beginning with the most nested properties and proceeding to the original value itself) are individually run through the &lt;code&gt;reviver&lt;/code&gt;. Then it is called, with the object containing the property being processed as &lt;code&gt;this&lt;/code&gt;, and with the property name as a string, and the property value as arguments. If the &lt;code&gt;reviver&lt;/code&gt; function returns &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; (or returns no value, for example, if execution falls off the end of the function), the property is deleted from the object. Otherwise, the property is redefined to be the return value.</source>
          <target state="translated">경우 &lt;code&gt;reviver&lt;/code&gt; 지정되어, 해석에 의해 계산되는 값은 &lt;em&gt;변환 된&lt;/em&gt; 리턴 전에. 특히 계산 된 값과 모든 속성 (가장 중첩 된 속성으로 시작하여 원래 값 자체로 진행)은 개별적으로 &lt;code&gt;reviver&lt;/code&gt; 를 통해 실행됩니다 . 등록 정보를 포함하는 객체와 같이 처리되고 그 다음은, 호출 &lt;code&gt;this&lt;/code&gt; 한 문자열로 속성 이름과 인자와 속성 값. 경우] &lt;code&gt;reviver&lt;/code&gt; 기능을 리턴 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; (실행 기능의 단부 떨어지면 또는 리턴 값 없음, 예를 들면,), 속성은 개체로부터 삭제된다. 그렇지 않으면 속성이 반환 값이되도록 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f242b5dc288eac0b5d0ce91ad4f100013514504d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is passed to &lt;code&gt;findIndex&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; inside each invocation of the &lt;code&gt;callback&lt;/code&gt;. If it is not provided, then &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 전달 &lt;code&gt;findIndex&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 의 내부에 각 호출 &lt;code&gt;callback&lt;/code&gt; . 제공되지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6932692e1d4fb28b8121dffe2f3e2d0eb25fc31" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;every&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수에 제공되는 &lt;code&gt;every&lt;/code&gt; 이를 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c67511fcd2a06b290b63f0afdae294248024ceaa" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;every&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수에 제공되는 &lt;code&gt;every&lt;/code&gt; 이를 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03473c038dbaa94c0f2f584238f87bb0a1c995c4" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;every&lt;/code&gt;, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수에 제공되는 &lt;code&gt;every&lt;/code&gt; , 그것은 콜백의로 사용됩니다 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e885503fc50fcf3433a76da451d3a39bdb27787" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;filter&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 제공되는 &lt;code&gt;filter&lt;/code&gt; 이를 전달 될 &lt;code&gt;callback&lt;/code&gt; 그것으로 사용하기 위해 호출 될 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="74757f9a027a1bd668415335ce369872b5c572ad" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;filter&lt;/code&gt;, it will be used as the callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 제공되는 &lt;code&gt;filter&lt;/code&gt; , 그것의 콜백으로 사용될 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf9143a7a8700db09906f59debf6818c19eb9dde" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;find&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; for each invocation of the &lt;code&gt;callback&lt;/code&gt;. If it is not provided, then &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 의 매개 변수가 제공됩니다 &lt;code&gt;find&lt;/code&gt; , 그것은으로 사용되는 &lt;code&gt;this&lt;/code&gt; 의 각 호출에 대한 &lt;code&gt;callback&lt;/code&gt; . 제공되지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1fb27d6a8d4daf130eff947e69b141ae7f6214" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;findIndex&lt;/code&gt;, it will be used as the &lt;code&gt;this&lt;/code&gt; for each invocation of the &lt;code&gt;callback&lt;/code&gt;. If it is not provided, then &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 의 파라미터가 제공된다 &lt;code&gt;findIndex&lt;/code&gt; , 그것은로 사용될 &lt;code&gt;this&lt;/code&gt; 의 각각의 호출에 대한 &lt;code&gt;callback&lt;/code&gt; . 제공되지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf571e8c9fd950c0cba47616f69e3244e8ac908" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;forEach()&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 제공된다 &lt;code&gt;forEach()&lt;/code&gt; ,이를 전달 될 &lt;code&gt;callback&lt;/code&gt; 그것으로 사용하기 위해 호출 될 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dadf3c2d4b8690337dfbe93c3a13c6ba5122a763" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;forEach()&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 제공된다 &lt;code&gt;forEach()&lt;/code&gt; ,이를 전달 될 &lt;code&gt;callback&lt;/code&gt; 그것으로 사용하기 위해 호출 될 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff6f3b4478f7d568a6bd567df8cf574b18334edf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;forEach()&lt;/code&gt;, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터가 제공된다 &lt;code&gt;forEach()&lt;/code&gt; , 그것의 콜백으로 사용될 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b270f7b4f88096d2dc8decbc2a68475af4db9b54" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;forEach&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수로 제공 &lt;code&gt;forEach&lt;/code&gt; , 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c264894e88d2165b79806c0e46c3a7c2ac7698" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;map&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수가 제공됩니다 &lt;code&gt;map&lt;/code&gt; , 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abc6187e52a5196ebde638cf0d74059344cc96a3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;map&lt;/code&gt;, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수가 제공됩니다 &lt;code&gt;map&lt;/code&gt; , 그것은 콜백의로 사용됩니다 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfcc5144fcb480f5a9615bf35d8d640124ed689e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;some()&lt;/code&gt;, it will be used as callbacks' &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 파라미터에 제공되는 &lt;code&gt;some()&lt;/code&gt; , 그 콜백 '로서 이용 될 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c67518b6a0defe9f309867be0175b853cf5c13a8" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;some&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수로 제공되는 &lt;code&gt;some&lt;/code&gt; , 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9064bb0e6133b19da0f634085d617942132a380b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided to &lt;code&gt;some&lt;/code&gt;, it will be passed to &lt;code&gt;callback&lt;/code&gt; when invoked, for use as its &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;code&gt;undefined&lt;/code&gt; will be passed for use as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;callback&lt;/code&gt; is determined according to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수로 제공되는 &lt;code&gt;some&lt;/code&gt; , 전달됩니다 &lt;code&gt;callback&lt;/code&gt; 의로 사용하기 위해, 호출 할 때 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt; 값 &lt;code&gt;this&lt;/code&gt; 값으로 사용되도록 전달됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;callback&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bda7ab606ed3004f2ea85c74dca1da94e54a790" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;thisArg&lt;/code&gt; parameter is provided, it will be used as callback's &lt;code&gt;this&lt;/code&gt; value. Otherwise, the value &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be used as its &lt;code&gt;this&lt;/code&gt; value. The &lt;code&gt;this&lt;/code&gt; value ultimately observable by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; is determined according to &lt;a href=&quot;../../operators/this&quot;&gt;the usual rules for determining the &lt;code&gt;this&lt;/code&gt; seen by a function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;thisArg&lt;/code&gt; 매개 변수를 제공, 그것은 콜백의로 사용됩니다 &lt;code&gt;this&lt;/code&gt; 값. 그렇지 않으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;this&lt;/code&gt; 값 으로 사용됩니다 . &lt;code&gt;this&lt;/code&gt; 에 의해 궁극적으로 관측 값 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 따라 결정되어 &lt;a href=&quot;../../operators/this&quot;&gt;, 상기 결정에 대한 일반적인 규칙 &lt;code&gt;this&lt;/code&gt; 함수를 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b15cc313fa96f0002ca8177237c5a6a7eaf8200b" translate="yes" xml:space="preserve">
          <source>If a browser doesn't support the &lt;code&gt;TypedArray.prototype.toString()&lt;/code&gt; method yet, JavaScript will call the &lt;code&gt;toString&lt;/code&gt; method of &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">브라우저가 &lt;code&gt;TypedArray.prototype.toString()&lt;/code&gt; 메서드를 아직 지원하지 않으면 JavaScript는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;toString&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2d6530ce720bdee0f80c81e26f6ecfbd283b444c" translate="yes" xml:space="preserve">
          <source>If a descriptor has neither of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keys, it is treated as a data descriptor. If a descriptor has both &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;writable&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; keys, an exception is thrown.</source>
          <target state="translated">디스크립터에 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 키 가 없으면 데이터 디스크립터로 취급됩니다. 디스크립터에 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;writable&lt;/code&gt; 키 와 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;set&lt;/code&gt; 키 가 모두 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2c34c6a69dfdce3e819260be6a04cfda0fbf1dc6" translate="yes" xml:space="preserve">
          <source>If a descriptor has neither of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keys, it is treated as a data descriptor. If a descriptor has both [&lt;code&gt;value&lt;/code&gt; or &lt;code&gt;writable&lt;/code&gt;] and [&lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt;] keys, an exception is thrown.</source>
          <target state="translated">설명자에 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 키 가 없으면 데이터 설명 자로 처리됩니다. 설명자에 [ &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;writable&lt;/code&gt; ] 및 [ &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; ] 키가 모두있는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e83c8dedbe6c06d159a3f6dfaa971e14e68ad6d" translate="yes" xml:space="preserve">
          <source>If a function, this prescribes how the value originally produced by parsing is transformed, before being returned.</source>
          <target state="translated">함수 인 경우 파싱에 의해 원래 생성 된 값이 반환되기 전에 어떻게 변환되는지를 규정합니다.</target>
        </trans-unit>
        <trans-unit id="391bf4a33b8c432c6b93a5a5e69abe068858d3be" translate="yes" xml:space="preserve">
          <source>If a negative number is provided for &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt;, the date will be set counting backwards from the last day of the previous month. -1 would result in the date being set to 1 day before the last day of the previous month.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 에 음수가 제공 되면 이전 달의 마지막 날부터 역순으로 날짜가 설정됩니다. -1은 날짜가 이전 달의 마지막 날 1 일 전으로 설정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="676a3f09e860cb1fdd6b7c64da13dd48930a4a79" translate="yes" xml:space="preserve">
          <source>If a new element is added to either array, the other array is not affected.</source>
          <target state="translated">새 요소가 각 배열에 추가되면 다른 배열은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be4193e9e29d983836aef2375c967598b0df9279" translate="yes" xml:space="preserve">
          <source>If a new element is added to either typed array, the other typed array is not affected.</source>
          <target state="translated">유형이 지정된 배열에 새 요소가 추가되면 다른 유형이 지정된 배열에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be50878ec0b2563ddd3389f7eebc5e92b8258b9c" translate="yes" xml:space="preserve">
          <source>If a non-RegExp object &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt; is passed, it is implicitly converted to a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;new RegExp(&lt;var&gt;regexp&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">비 RegExp 객체 &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt; 가 전달되면 &lt;code&gt;new RegExp(&lt;var&gt;regexp&lt;/var&gt;)&lt;/code&gt; &lt;var&gt;regexp&lt;/var&gt; ) 를 사용하여 암시 적으로 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="281423783d855ddb3f0a19f8508114c22a018543" translate="yes" xml:space="preserve">
          <source>If a non-strict function &lt;strong&gt;&lt;strong&gt;does &lt;/strong&gt;not&lt;/strong&gt; contain rest, default, or destructured parameters, then the values in the &lt;code&gt;arguments&lt;/code&gt; object &lt;strong&gt;do&lt;/strong&gt; change in sync with the values of the argument variables. See the code below:</source>
          <target state="translated">비 엄격한 기능이 경우 &lt;strong&gt;&lt;strong&gt;않습니다&lt;/strong&gt; 하지&lt;/strong&gt; 나머지, 기본, 또는 탈구 매개 변수를 포함, 다음의 값을 &lt;code&gt;arguments&lt;/code&gt; 반대 &lt;strong&gt;할&lt;/strong&gt; 인수 변수의 값과 동기화의 변화를. 아래 코드를 참조하십시오 :</target>
        </trans-unit>
        <trans-unit id="25fb90bb85af1ebb4d9188ee2fd33dfe9e1c2f50" translate="yes" xml:space="preserve">
          <source>If a nonempty &lt;em&gt;iterable&lt;/em&gt; is passed, and &lt;strong&gt;all&lt;/strong&gt; of the promises fulfill, or are not promises, then the promise returned by this method is fulfilled asynchronously.</source>
          <target state="translated">비어 있지 않은 &lt;em&gt;iterable&lt;/em&gt; 이 전달되고 &lt;strong&gt;모든&lt;/strong&gt; promise가 이행되거나 promise가 아닌 경우이 메서드에서 반환 된 promise는 비동기 적으로 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="d069c32d6d18bca5b8bc39c5dc8fb8c3caa232ba" translate="yes" xml:space="preserve">
          <source>If a number has more digits than requested by the &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; parameter, the number is rounded to the nearest number represented by &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; digits. See the discussion of rounding in the description of the &lt;a href=&quot;tofixed&quot;&gt;&lt;code&gt;toFixed()&lt;/code&gt;&lt;/a&gt; method, which also applies to &lt;code&gt;toExponential()&lt;/code&gt;.</source>
          <target state="translated">숫자에 &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; 매개 변수에서 요청한 것보다 많은 자릿수가 있으면 해당 숫자는 &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; 자릿수로 표시되는 가장 가까운 숫자로 반올림됩니다 . &lt;a href=&quot;tofixed&quot;&gt; &lt;code&gt;toFixed()&lt;/code&gt; &lt;/a&gt; 메서드 에 대한 설명에서 반올림에 대한 설명을 참조하십시오. 이는 &lt;code&gt;toExponential()&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ea7ce40a49626eb3ae67d76fb0cb47271742b47" translate="yes" xml:space="preserve">
          <source>If a number has more digits than requested by the &lt;code&gt;fractionDigits&lt;/code&gt; parameter, the number is rounded to the nearest number represented by &lt;code&gt;fractionDigits&lt;/code&gt; digits. See the discussion of rounding in the description of the &lt;a href=&quot;tofixed&quot;&gt;&lt;code&gt;toFixed()&lt;/code&gt;&lt;/a&gt; method, which also applies to &lt;code&gt;toExponential()&lt;/code&gt;.</source>
          <target state="translated">숫자가 &lt;code&gt;fractionDigits&lt;/code&gt; 매개 변수에 의해 요청 된 것보다 많은 숫자를 갖는 경우, 숫자는 &lt;code&gt;fractionDigits&lt;/code&gt; 숫자로 표시되는 가장 가까운 숫자로 반올림됩니다 . &lt;a href=&quot;tofixed&quot;&gt; &lt;code&gt;toFixed()&lt;/code&gt; &lt;/a&gt; 메소드 에 대한 설명에서 반올림에 대한 설명을 참조하십시오. 이는 &lt;code&gt;toExponential()&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="288361a178a4532457b48ca23e1080ecff1e23e8" translate="yes" xml:space="preserve">
          <source>If a parameter is outside of the expected range, the &lt;code&gt;UTC()&lt;/code&gt; method updates the other parameters to accommodate the value. For example, if 15 is used for month, the year will be incremented by 1 &lt;code&gt;(year + 1)&lt;/code&gt; and 3 will be used for the month.</source>
          <target state="translated">매개 변수가 예상 범위를 벗어나면 &lt;code&gt;UTC()&lt;/code&gt; 메서드는 다른 매개 변수를 업데이트하여 값을 수용합니다. 예를 들어, 월에 15를 사용하면 연도는 1 &lt;code&gt;(year + 1)&lt;/code&gt; 씩 증가 하고 3은 월에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c725aba9dc8cfc4ecef16eaeb9213edebcbb05da" translate="yes" xml:space="preserve">
          <source>If a parameter is outside of the expected range, the &lt;code&gt;UTC()&lt;/code&gt; method updates the other parameters to accommodate the value. For example, if &lt;code&gt;15&lt;/code&gt; is used for &lt;code&gt;&lt;var&gt;month&lt;/var&gt;&lt;/code&gt;, the year will be incremented by 1 &lt;code&gt;(&lt;var&gt;year&lt;/var&gt; + 1)&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; will be used for the month.</source>
          <target state="translated">매개 변수가 예상 범위를 벗어나면 &lt;code&gt;UTC()&lt;/code&gt; 메서드는 값을 수용하기 위해 다른 매개 변수를 업데이트합니다. 예를 들어 &lt;code&gt;&lt;var&gt;month&lt;/var&gt;&lt;/code&gt; &lt;code&gt;15&lt;/code&gt; 가 사용 되면 연도는 1 &lt;code&gt;(&lt;var&gt;year&lt;/var&gt; + 1)&lt;/code&gt; &lt;var&gt;year&lt;/var&gt; + 1) 및 &lt;code&gt;3&lt;/code&gt; 씩 증가합니다. 은 월에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76e695a5051810de75d193b74766ab525b424229" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setFullYear()&lt;/code&gt; attempts to update the other parameters and the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you specify 15 for &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt;, the year is incremented by 1 (&lt;code&gt;&lt;var&gt;yearValue&lt;/var&gt; + 1&lt;/code&gt;), and 3 is used for the month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setFullYear()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 다른 매개 변수와 날짜 정보를 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 에 15를 지정 하면 연도가 1 씩 증가합니다 ( &lt;code&gt;&lt;var&gt;yearValue&lt;/var&gt; + 1&lt;/code&gt; ) 월에는 3이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc226135066c452e9f891ad0716eedfaf99c4f78" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setFullYear()&lt;/code&gt; attempts to update the other parameters and the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you specify 15 for &lt;code&gt;monthValue&lt;/code&gt;, the year is incremented by 1 (&lt;code&gt;yearValue + 1&lt;/code&gt;), and 3 is used for the month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setFullYear()&lt;/code&gt; 는 다른 매개 변수와 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;monthValue&lt;/code&gt; 에 15를 지정 하면 연도는 1 ( &lt;code&gt;yearValue + 1&lt;/code&gt; ) 씩 증가하고 그 달에 3이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ccc6a64d169dbd4da5c7d23a80b1dd0d637ecc21" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setHours()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setHours()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 에 100을 사용 하면 분이 1 씩 증가합니다 ( &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt; ) 초에는 40이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0bae704c8f363a3c418460072e51a073a948dc4" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setHours()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;minutesValue + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setHours()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 그에 따라 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 분이 1 ( &lt;code&gt;minutesValue + 1&lt;/code&gt; ) 씩 증가 하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23b4dd0c538d62e6f6e8b5adb2fc8de560c3e8ba" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setMinutes()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setMinutes()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 에 100을 사용 하면 분이 1 씩 증가합니다 ( &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt; ) 초에는 40이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd78caa2b59300ea65d3ff5bde2b0076413d09a" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setMinutes()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;minutesValue + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setMinutes()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 분이 1 ( &lt;code&gt;minutesValue + 1&lt;/code&gt; ) 씩 증가 하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="18bd212d1a40736bf3e113a154e00179fdae9e3c" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setMonth()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 15 for &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt;, the year will be incremented by 1, and 3 will be used for month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setMonth()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 에 15를 사용 하면 연도는 1 씩 증가하고 3은 월에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0cbcdc0755030f824b7ef9e0e2ebcf2e5cbc9c6f" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setMonth()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 15 for &lt;code&gt;monthValue&lt;/code&gt;, the year will be incremented by 1, and 3 will be used for month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setMonth()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 그에 따라 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;monthValue&lt;/code&gt; 에 15를 사용 하면 연도는 1 씩 증가하고 3은 월에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6f7cf92def3c1f8a1915da21b1d6f52234d3f7" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setSeconds()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, the minutes stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object will be incremented by 1, and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setSeconds()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 에 100을 사용 하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체에 저장된 분 은 1 씩 증가하고 40은 초에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0c6676cd42b85e15c3ec0b0481c70d568ae9434" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setSeconds()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object will be incremented by 1, and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setSeconds()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체에 저장된 분이 1 씩 증가하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df01689b65802985e92b006b852bab1789537c7d" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCDate()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 40 for &lt;code&gt;dayValue&lt;/code&gt;, and the month stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object is June, the day will be changed to 10 and the month will be incremented to July.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCDate()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;dayValue&lt;/code&gt; 에 40을 사용 하고 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체에 저장된 월이 6 월이면 일이 10으로 변경되고 월이 7 월로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="0f6027596c322cca311a687bf3cf406e0ffc5812" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCFullYear()&lt;/code&gt; attempts to update the other parameters and the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you specify 15 for &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt;, the year is incremented by 1 (&lt;code&gt;&lt;var&gt;yearValue&lt;/var&gt; + 1&lt;/code&gt;), and 3 is used for the month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 &lt;code&gt;setUTCFullYear()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 다른 매개 변수와 날짜 정보를 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 에 15를 지정 하면 연도가 1 씩 증가합니다 ( &lt;code&gt;&lt;var&gt;yearValue&lt;/var&gt; + 1&lt;/code&gt; ) 월에는 3이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="52dac7927320e1182e697b79ec8295155d19dc5c" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCFullYear()&lt;/code&gt; attempts to update the other parameters and the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you specify 15 for &lt;code&gt;monthValue&lt;/code&gt;, the year is incremented by 1 (&lt;code&gt;yearValue + 1&lt;/code&gt;), and 3 is used for the month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 &lt;code&gt;setUTCFullYear()&lt;/code&gt; 는 다른 매개 변수와 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;monthValue&lt;/code&gt; 에 15를 지정 하면 연도는 1 ( &lt;code&gt;yearValue + 1&lt;/code&gt; ) 씩 증가하고 그 달에 3이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a55c9e4f35d76aa47c88004d1e11b285eaed954" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCHours()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;minutesValue + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCHours()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 에 100을 사용 하면 분이 1 씩 증가합니다 ( &lt;code&gt;minutesValue + 1&lt;/code&gt; ) 초에는 40이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c11c6ecd9791e9b4a84c89341e5b7e2f0989ca49" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCHours()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;minutesValue + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCHours()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 분이 1 ( &lt;code&gt;minutesValue + 1&lt;/code&gt; ) 씩 증가 하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0be0566f667d3135990a5889ec32194ccf1a34d5" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCMilliseconds()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 1100 for &lt;code&gt;&lt;var&gt;millisecondsValue&lt;/var&gt;&lt;/code&gt;, the seconds stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object will be incremented by 1, and 100 will be used for milliseconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCMilliseconds()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;millisecondsValue&lt;/var&gt;&lt;/code&gt; 에 1100을 사용 하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; 에&lt;/a&gt; 저장된 초 객체에 는 1 씩 증가하고 100은 밀리 초에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e0fddf94acbeb7b53ae965497ce04cbb007f210" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCMilliseconds()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 1100 for &lt;code&gt;millisecondsValue&lt;/code&gt;, the seconds stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object will be incremented by 1, and 100 will be used for milliseconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCMilliseconds()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;millisecondsValue&lt;/code&gt; 에 1100을 사용 하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체에 저장된 초가 1 씩 증가하고 100이 밀리 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0844e22920653f7ff879d175734f8ca20542884e" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCMinutes()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCMinutes()&lt;/code&gt; 는 그에 따라 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 업데이트하려고합니다 . 예를 들어 &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 에 100을 사용 하면 분이 1 씩 증가합니다 ( &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt; + 1&lt;/code&gt; ) 초에는 40이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ab1e641e438a15929a07e53e62551090004df3" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCMinutes()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes will be incremented by 1 (&lt;code&gt;minutesValue + 1&lt;/code&gt;), and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCMinutes()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 분이 1 ( &lt;code&gt;minutesValue + 1&lt;/code&gt; ) 씩 증가 하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="77a89ca3d2dd51667af8624bdb97060e7f86c012" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCMonth()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 15 for &lt;code&gt;monthValue&lt;/code&gt;, the year will be incremented by 1, and 3 will be used for month.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCMonth()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;monthValue&lt;/code&gt; 에 15를 사용 하면 연도는 1 씩 증가하고 3은 월에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d37c5d009a9e0ab4ebd4c03c9cbe96e7a5031ea7" translate="yes" xml:space="preserve">
          <source>If a parameter you specify is outside of the expected range, &lt;code&gt;setUTCSeconds()&lt;/code&gt; attempts to update the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if you use 100 for &lt;code&gt;secondsValue&lt;/code&gt;, the minutes stored in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object will be incremented by 1, and 40 will be used for seconds.</source>
          <target state="translated">지정한 매개 변수가 예상 범위를 벗어나면 &lt;code&gt;setUTCSeconds()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보를 적절히 업데이트하려고 시도합니다 . 예를 들어 &lt;code&gt;secondsValue&lt;/code&gt; 에 100을 사용 하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체에 저장된 분이 1 씩 증가하고 40이 초 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54e5d5b9374c3920ec4b4ed3a7977f0fa06e19b2" translate="yes" xml:space="preserve">
          <source>If a property has a corresponding target object property then &lt;code&gt;Object.defineProperty(target, prop, descriptor)&lt;/code&gt; will not throw an exception.</source>
          <target state="translated">속성에 해당 대상 개체 속성이 &lt;code&gt;Object.defineProperty(target, prop, descriptor)&lt;/code&gt; 에서 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="837d8d104001710dc6b1a33f7143ccc511c3351f" translate="yes" xml:space="preserve">
          <source>If a property is modified in one iteration and then visited at a later time, its value in the loop is its value at that later time. A property that is deleted before it has been visited will not be visited later. Properties added to the object over which iteration is occurring may either be visited or omitted from iteration.</source>
          <target state="translated">한 번의 반복으로 속성을 수정 한 다음 나중에 방문 할 경우 루프의 값은 그 이후의 값입니다. 방문하기 전에 삭제 된 속성은 나중에 방문하지 않습니다. 반복이 발생하는 오브젝트에 추가 된 특성은 방문에서 반복되거나 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5534a4c3390c3a7ec2f13247ce7f50b399f6066" translate="yes" xml:space="preserve">
          <source>If a property with the same name exists on the object's prototype chain, then, after deletion, the object will use the property from the prototype chain (in other words, &lt;code&gt;delete&lt;/code&gt; only has an effect on own properties).</source>
          <target state="translated">동일한 이름을 가진 속성이 객체의 프로토 타입 체인에 존재하면 삭제 후 객체는 프로토 타입 체인의 속성을 사용합니다 (즉, &lt;code&gt;delete&lt;/code&gt; 는 자신의 속성에만 영향을 미칩니다).</target>
        </trans-unit>
        <trans-unit id="5e95bbcb4d00da3194f60f32b87c232cfe48eb8b" translate="yes" xml:space="preserve">
          <source>If a value can be converted to &lt;code&gt;true&lt;/code&gt;, the value is so-called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/truthy&quot;&gt;truthy&lt;/a&gt;. If a value can be converted to &lt;code&gt;false&lt;/code&gt;, the value is so-called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;falsy&lt;/a&gt;.</source>
          <target state="translated">값을 &lt;code&gt;true&lt;/code&gt; 로 변환 할 수 있으면 값은 소위 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/truthy&quot;&gt;진실&lt;/a&gt; 입니다. 값을 &lt;code&gt;false&lt;/code&gt; 로 변환 할 수 있으면이 값을 소위 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;거짓&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ab400bc46efabee8fe3b7f7d0f93c12a2cfeb1f" translate="yes" xml:space="preserve">
          <source>If all of the passed-in promises fulfill, or are not promises, the promise returned by &lt;code&gt;Promise.all&lt;/code&gt; is fulfilled asynchronously.</source>
          <target state="translated">전달 된 모든 약속이 약속을 이행하거나 약속이 아닌 경우 &lt;code&gt;Promise.all&lt;/code&gt; 에서 반환 한 약속 은 비동기 적으로 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f42c36a852e8a0e3d96038c9b48c242a9784442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../statements/for...of&quot;&gt;iterable object &lt;/a&gt;is passed, all of its elements will be added to the new &lt;code&gt;Set&lt;/code&gt;. If you don't specify this parameter, or its value is &lt;code&gt;null&lt;/code&gt;, the new &lt;code&gt;Set&lt;/code&gt; is empty.</source>
          <target state="translated">경우 &lt;a href=&quot;../statements/for...of&quot;&gt;반복 가능한 객체가&lt;/a&gt; 전달되는 그 모든 요소는 새로운 추가됩니다 &lt;code&gt;Set&lt;/code&gt; . 이 매개 변수를 지정하지 않거나 해당 값이 &lt;code&gt;null&lt;/code&gt; 인 경우 새 &lt;code&gt;Set&lt;/code&gt; 가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d39d83ba6dd7a9c8c32bf2347faf691e07c8e4e" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../statements/for...of&quot;&gt;iterable object &lt;/a&gt;is passed, all of its elements will be added to the new &lt;code&gt;WeakSet&lt;/code&gt;. null is treated as undefined.</source>
          <target state="translated">경우 &lt;a href=&quot;../statements/for...of&quot;&gt;반복 가능한 객체가&lt;/a&gt; 전달되는 그 모든 요소는 새로운 추가됩니다 &lt;code&gt;WeakSet&lt;/code&gt; . null은 정의되지 않은 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3fe08780b4a61c2df0afb894ef6c7d6c984467" translate="yes" xml:space="preserve">
          <source>If an accessor property is inherited, its &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods will be called when the property is accessed and modified on descendant objects. If these methods use a variable to store the value, this value will be shared by all objects.</source>
          <target state="translated">접근 자 속성이 상속되면 하위 개체에서 속성에 액세스하고 수정할 때 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 메서드가 호출됩니다. 이러한 메소드가 변수를 사용하여 값을 저장하는 경우이 값은 모든 오브젝트에서 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6096c9d36c7d06be6e0a07577d30ae12433148" translate="yes" xml:space="preserve">
          <source>If an arrow function needs to access the &lt;code&gt;this&lt;/code&gt; variable, you can use the arrow function as the enclosing function:</source>
          <target state="translated">화살표 함수 &lt;code&gt;this&lt;/code&gt; 변수 에 액세스해야하는 경우 화살표 함수를 묶는 함수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4be48e7bf99e7bb43a149c21ac7c6e39523941" translate="yes" xml:space="preserve">
          <source>If an element is &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, it is converted to the empty string.</source>
          <target state="translated">요소가 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 인 경우 빈 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e363aa536e88387e5c0cbd67a99ffab5a7c14024" translate="yes" xml:space="preserve">
          <source>If an element is &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; or an empty array &lt;code&gt;[]&lt;/code&gt;, it is converted to an empty string.</source>
          <target state="translated">요소가 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;null&lt;/code&gt; 또는 빈 배열 &lt;code&gt;[]&lt;/code&gt; 이면 빈 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="082c0044fd10aae386a6cf9e4adb69b5ca782b44" translate="yes" xml:space="preserve">
          <source>If an empty &lt;var&gt;iterable&lt;/var&gt; is passed, then the promise returned by this method is fulfilled synchronously. The resolved value is an empty array.</source>
          <target state="translated">빈 &lt;var&gt;iterable&lt;/var&gt; 이 전달되면이 메서드에서 반환 한 promise는 동 기적으로 수행됩니다. 해결 된 값은 빈 배열입니다.</target>
        </trans-unit>
        <trans-unit id="54bc642374ee70081e3afb8490bd2269bdefd134" translate="yes" xml:space="preserve">
          <source>If an empty &lt;var&gt;iterable&lt;/var&gt; is passed, then this method returns (synchronously) an already resolved promise.</source>
          <target state="translated">빈 &lt;var&gt;iterable&lt;/var&gt; 이 전달되면이 메소드는 이미 해결 된 약속을 (동 기적으로) 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="115182e50bdd6201c48fa9cf7d25930ad3769130" translate="yes" xml:space="preserve">
          <source>If an existing, yet-unvisited element of the array is changed by &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt;, its value passed to the &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; will be the value at the time &lt;code&gt;find&lt;/code&gt; visits that element's index.</source>
          <target state="translated">아직 방문하지 않은 기존 배열 요소가 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 에 의해 변경된 경우 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 전달 된 값은 해당 요소의 색인을 &lt;code&gt;find&lt;/code&gt; 때의 값이됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd198759ec716bf61d3d545c999fb000e2238a04" translate="yes" xml:space="preserve">
          <source>If an iterable's &lt;code&gt;@@iterator&lt;/code&gt; method does not return an iterator object, then it is a non-well-formed iterable. Using it as such is likely to result in runtime exceptions or buggy behavior:</source>
          <target state="translated">iterable의 &lt;code&gt;@@iterator&lt;/code&gt; 메소드가 iterator 객체를 반환하지 않으면 잘 구성되지 않은 iterable입니다. 그대로 사용하면 런타임 예외 또는 버그가있는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d69c0eecc261f462796bd6ac56dedc90c4a7ce55" translate="yes" xml:space="preserve">
          <source>If an iterable's &lt;code&gt;@@iterator&lt;/code&gt; method doesn't return an iterator object, then it's a non-well-formed iterable. Using it as such is likely to result in runtime exceptions or buggy behavior:</source>
          <target state="translated">iterable의 &lt;code&gt;@@iterator&lt;/code&gt; 메소드가 iterator 객체를 반환하지 않으면 잘 구성되지 않은 iterable입니다. 그대로 사용하면 런타임 예외 또는 버그가있는 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2112de509477c036e2a78f9bd9296395f6174868" translate="yes" xml:space="preserve">
          <source>If an iterable's &lt;code&gt;@@iterator&lt;/code&gt; method doesn't return an iterator object, then it's considered a &lt;em&gt;non-well-formed&lt;/em&gt; iterable.</source>
          <target state="translated">이터 러블의 &lt;code&gt;@@iterator&lt;/code&gt; 메서드가 이터레이터 개체를 반환하지 않으면 제대로 &lt;em&gt;구성된&lt;/em&gt; 이터 러블 이 &lt;em&gt;아닌&lt;/em&gt; 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="31b3cbae51b5fe192cd7a0df742cf2ba526bfcfb" translate="yes" xml:space="preserve">
          <source>If an object being stringified has a property named &lt;code&gt;toJSON&lt;/code&gt; whose value is a function, then the &lt;code&gt;toJSON()&lt;/code&gt; method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the &lt;code&gt;toJSON()&lt;/code&gt; method when called will be serialized. &lt;code&gt;JSON.stringify()&lt;/code&gt; calls &lt;code&gt;toJSON&lt;/code&gt; with one parameter:</source>
          <target state="translated">문자열 화되는 오브젝트에 값이 함수 인 &lt;code&gt;toJSON&lt;/code&gt; 이라는 특성 이있는 &lt;code&gt;toJSON()&lt;/code&gt; 메소드는 JSON 문자열 화 동작을 사용자 정의합니다. 직렬화되는 오브젝트 대신 호출 될 때 &lt;code&gt;toJSON()&lt;/code&gt; 메소드가 리턴 한 값 이 직렬화됩니다. &lt;code&gt;JSON.stringify()&lt;/code&gt; 는 하나의 매개 변수로 &lt;code&gt;toJSON&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cef8f2323faa3f13ce8f7260bf8626d3157109e1" translate="yes" xml:space="preserve">
          <source>If an object is compared with a number or string, JavaScript attempts to return the default value for the object. Operators attempt to convert the object to a primitive value, a &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Number&lt;/code&gt; value, using the &lt;code&gt;valueOf&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; methods of the objects. If this attempt to convert the object fails, a runtime error is generated.</source>
          <target state="translated">객체를 숫자 또는 문자열과 비교하면 JavaScript는 객체의 기본값을 반환하려고 시도합니다. 연산자는 객체 의 &lt;code&gt;valueOf&lt;/code&gt; 및 &lt;code&gt;toString&lt;/code&gt; 메서드를 사용하여 객체를 기본 값인 &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Number&lt;/code&gt; 값 으로 변환하려고 합니다. 이 오브젝트 변환 시도가 실패하면 런타임 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9c8d242f07d4b8da5fc1c766cac77ace48f8da" translate="yes" xml:space="preserve">
          <source>If an optional value is passed to the generator's &lt;code&gt;next()&lt;/code&gt; method, that value becomes the value returned by the generator's current &lt;code&gt;yield&lt;/code&gt; operation.</source>
          <target state="translated">선택적 값이 생성기의 &lt;code&gt;next()&lt;/code&gt; 메서드에 전달되면 해당 값은 생성기의 현재 &lt;code&gt;yield&lt;/code&gt; 작업 에서 반환 된 값이 됩니다.</target>
        </trans-unit>
        <trans-unit id="eab9a8913c422ab58b02bbfa5d83f5998bdc01c2" translate="yes" xml:space="preserve">
          <source>If any of the arguments are &lt;code&gt;NaN&lt;/code&gt; or cannot be converted to a number, the result is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;NaN&lt;/code&gt; 이거나 숫자로 변환 할 수없는 경우 결과는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="14e60bca484450eba75e83eae86d457071ed10b7" translate="yes" xml:space="preserve">
          <source>If any of the passed-in promises reject, &lt;code&gt;Promise.all&lt;/code&gt; asynchronously rejects with the value of the promise that rejected, whether or not the other promises have resolved.</source>
          <target state="translated">전달 된 약속 중 하나라도 거부하면 &lt;code&gt;Promise.all&lt;/code&gt; 은 다른 약속이 해결되었는지 여부에 관계없이 거부 된 약속의 값으로 비동기 적으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="48d47027ffc774196b349859fb3e9da455a451c9" translate="yes" xml:space="preserve">
          <source>If at least one of arguments cannot be converted to a number, the result is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나 이상의 인수를 숫자로 변환 할 수없는 경우 결과는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5be6d3c080275816767e73cf9852e3c597d6d12" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments cannot be converted to a number, the result is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수 중 하나 이상을 숫자로 변환 할 수없는 경우 결과는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09f549348155baea9ff0cca9052911fb73fa52d5" translate="yes" xml:space="preserve">
          <source>If at least two arguments are supplied, missing arguments are either set to 1 (if the day is missing) or 0 for all others.</source>
          <target state="translated">둘 이상의 인수가 제공되면 누락 된 인수는 1 (일이 누락 된 경우) 또는 다른 모든 인수에 대해 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="82315591edcb2db1b2e04264330ce3348f0aee52" translate="yes" xml:space="preserve">
          <source>If compilation fails, the promise rejects with a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;WebAssembly.CompileError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일이 실패하면 약속은 &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;WebAssembly.CompileError&lt;/code&gt; 로&lt;/a&gt; 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="cea3dd981e7a3aff7561a6922483101c40442bb9" translate="yes" xml:space="preserve">
          <source>If default parameters are defined for one or more parameter, then a &lt;a href=&quot;https://tc39.es/ecma262/#sec-functiondeclarationinstantiation&quot;&gt;second scope&lt;/a&gt; (Environment Record) is created, specifically for the identifiers within the parameter list. This scope is a parent of the scope created for the function body.</source>
          <target state="translated">하나 이상의 매개 변수에 대해 기본 매개 변수가 정의 된 경우 , 특히 매개 변수 목록 내의 식별자에 대해 &lt;a href=&quot;https://tc39.es/ecma262/#sec-functiondeclarationinstantiation&quot;&gt;두 번째 범위&lt;/a&gt; (환경 레코드)가 작성됩니다. 이 범위는 함수 본문에 대해 생성 된 범위의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="e1f0c5928a0099cfe5ce965bc4209aa587dd166e" translate="yes" xml:space="preserve">
          <source>If either of the parameters are not of the correct type or structure, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">매개 변수 중 하나가 올바른 유형 또는 구조가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="329fa71267e94c738bbeefa5e7aa0eabd7f7ae7a" translate="yes" xml:space="preserve">
          <source>If either or both of the arguments are negative or &lt;code&gt;NaN&lt;/code&gt;, the &lt;code&gt;substring()&lt;/code&gt; method treats them as if they were &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">인수 중 하나 또는 모두가 음수이거나 &lt;code&gt;NaN&lt;/code&gt; 인 경우 &lt;code&gt;substring()&lt;/code&gt; 메서드는 인수 를 &lt;code&gt;0&lt;/code&gt; 인 것처럼 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="69769f880229b3b08f71eee7e43ec58963b459f3" translate="yes" xml:space="preserve">
          <source>If greater than the length of the array, &lt;code&gt;&lt;var&gt;start&lt;/var&gt;&lt;/code&gt; will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.</source>
          <target state="translated">어레이의 길이보다 크면 &lt;code&gt;&lt;var&gt;start&lt;/var&gt;&lt;/code&gt; 는 어레이 의 길이로 설정됩니다. 이 경우 요소는 삭제되지 않지만 메서드는 제공된 item [n *]만큼 요소를 추가하는 추가 기능으로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="cb72faf000f170f1b80581e4a48d82155c0c3894" translate="yes" xml:space="preserve">
          <source>If instead, you want to remove an array element by changing the contents of the array, use the &lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is removed from the array completely using &lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대신 배열의 내용을 변경하여 배열 요소를 제거하려면 &lt;a href=&quot;../global_objects/array/splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 . 다음 예제에서는 &lt;a href=&quot;../global_objects/array/splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;trees[3]&lt;/code&gt; 배열에서 완전히 제거했습니다. .</target>
        </trans-unit>
        <trans-unit id="49fc2322ca24a4cc53ec295316ce4fd08b085e67" translate="yes" xml:space="preserve">
          <source>If instead, you want to remove an array element by changing the contents of the array, use the &lt;code&gt;&lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; method. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is removed from the array completely using &lt;code&gt;&lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">대신 배열의 내용을 변경하여 배열 요소를 제거하려면 &lt;code&gt;&lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 메소드를 사용하십시오 . 다음 예제에서 &lt;code&gt;&lt;a href=&quot;../global_objects/array/splice&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 를 사용하여 &lt;code&gt;trees[3]&lt;/code&gt; 가 배열에서 완전히 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="2aa5046f9eb74295f861c69f7b20dc6058c9f652" translate="yes" xml:space="preserve">
          <source>If it is a positive number with a positive sign, &lt;code&gt;RegExp()&lt;/code&gt; will ignore the positive sign.</source>
          <target state="translated">양수 부호가있는 양수이면 &lt;code&gt;RegExp()&lt;/code&gt; 는 양수 부호를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6fe41e69103f9edde244c8197d5369fb1ea48d61" translate="yes" xml:space="preserve">
          <source>If it is resolved</source>
          <target state="translated">그것이 해결되면</target>
        </trans-unit>
        <trans-unit id="446ee71b57c4dc727ad4482eb4cb20418b406cbe" translate="yes" xml:space="preserve">
          <source>If it rejects, it is rejected with the reason from the first promise in the iterable that was rejected.</source>
          <target state="translated">거부하면 거부 된 iterable의 첫 번째 약속의 이유와 함께 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d9729db77586d30dcb90e9b3c12a312fac9880" translate="yes" xml:space="preserve">
          <source>If it rejects, it is rejected with the reason from the first promise that was rejected.</source>
          <target state="translated">거부하면 거부 된 첫 번째 약속의 이유와 함께 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb1cc05b2c2ef7200a99e47d5f93b8653470671" translate="yes" xml:space="preserve">
          <source>If it's used, it will be accessed several times, and there is no need to re-calculate that value will never be changed or shouldn't be re-calculated.</source>
          <target state="translated">사용되는 경우 여러 번 액세스되며 값이 변경되지 않거나 다시 계산되어서는 안되는 해당 값을 다시 계산할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d09c7d906444b72f87c57393ac10ac8d90cbc87" translate="yes" xml:space="preserve">
          <source>If it's used, it will be accessed several times, and there is no need to re-calculate that value will never be changed, or shouldn't be re-calculated.</source>
          <target state="translated">사용되는 경우 여러 번 액세스되며 해당 값을 절대로 변경하지 않거나 다시 계산해서는 안되는 값을 다시 계산할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d31244b48c8d3b0b322ef9ce1f75a06324d0d657" translate="yes" xml:space="preserve">
          <source>If module is not a &lt;a href=&quot;../module&quot;&gt;&lt;code&gt;WebAssembly.Module&lt;/code&gt;&lt;/a&gt; object instance, a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">모듈이 &lt;a href=&quot;../module&quot;&gt; &lt;code&gt;WebAssembly.Module&lt;/code&gt; &lt;/a&gt; 객체 인스턴스 가 아닌 경우 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6b8e3ea5e20c3a5881face3771f7491d5f74865" translate="yes" xml:space="preserve">
          <source>If negative, it will begin that many elements from the end of the array. (In this case, the origin &lt;code&gt;-1&lt;/code&gt;, meaning &lt;code&gt;-&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; is the index of the &lt;code&gt;&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; last element, and is therefore equivalent to the index of &lt;code&gt;&lt;var&gt;array&lt;/var&gt;.length - &lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.) If &lt;code&gt;&lt;var&gt;array&lt;/var&gt;.length + &lt;var&gt;start&lt;/var&gt;&lt;/code&gt; is less than &lt;code&gt;0&lt;/code&gt;, it will begin from index &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">음수이면 배열 끝에서 많은 요소를 시작합니다. (이 경우, 원점 &lt;code&gt;-1&lt;/code&gt; 의미하는 &lt;code&gt;-&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 의 인덱스이며 &lt;code&gt;&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;sup&gt; 번째의&lt;/sup&gt; 마지막 요소, 따라서 인덱스에 해당 &lt;code&gt;&lt;var&gt;array&lt;/var&gt;.length - &lt;var&gt;n&lt;/var&gt;&lt;/code&gt; .) 경우 &lt;code&gt;&lt;var&gt;array&lt;/var&gt;.length + &lt;var&gt;start&lt;/var&gt;&lt;/code&gt; 미만이고 &lt;code&gt;0&lt;/code&gt; 그것을 인덱스 &lt;code&gt;0&lt;/code&gt; 부터 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="6f05381949d7c897bb41de21ca73f9e4317dd755" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; is provided to &lt;code&gt;charAt()&lt;/code&gt;, the default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;charAt()&lt;/code&gt; &lt;code&gt;&lt;var&gt;index&lt;/var&gt;&lt;/code&gt; 가 제공 되지 않으면 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f91f0e4cc5abd9a5b3dbdbb7a0297c9b1abf06c5" translate="yes" xml:space="preserve">
          <source>If no argument is provided, the &lt;code&gt;value&lt;/code&gt; property of returned object is the same as if &lt;code&gt;.next()&lt;/code&gt;. If an argument is provided, it will be set to the value of the &lt;code&gt;value&lt;/code&gt; property of the returned object.</source>
          <target state="translated">인수가 제공되지 않으면 반환 된 객체 의 &lt;code&gt;value&lt;/code&gt; 속성은 &lt;code&gt;.next()&lt;/code&gt; 와 동일 합니다. 인수가 제공되는 경우, 그것은의 값으로 설정됩니다 &lt;code&gt;value&lt;/code&gt; 반환 된 개체 속성 .</target>
        </trans-unit>
        <trans-unit id="4e0091f074b8afb9219bdfed384f304735f7b83e" translate="yes" xml:space="preserve">
          <source>If no arguments are given, the result is +0.</source>
          <target state="translated">인수가 제공되지 않으면 결과는 +0입니다.</target>
        </trans-unit>
        <trans-unit id="9990c049d2e8a0255f2ea7fdd43424a88bf9391b" translate="yes" xml:space="preserve">
          <source>If no arguments are given, the result is +0. If any of the arguments is &amp;plusmn;Infinity, the result is Infinity. If any of the arguments is NaN (unless another argument is &amp;plusmn;Infinity), the result is NaN. If at least one of the arguments cannot be converted to a number, the result is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 제공되지 않으면 결과는 +0입니다. 인수 중 하나라도 &amp;plusmn; Infinity이면 결과는 Infinity입니다. 인수 중 하나가 NaN이면 (다른 인수가 &amp;plusmn; Infinity가 아닌 경우) 결과는 NaN입니다. 인수 중 하나 이상을 숫자로 변환 할 수없는 경우 결과는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cec49b483dc5f92d00626cab7c85c35367d1467e" translate="yes" xml:space="preserve">
          <source>If no arguments are given, the result is -&lt;a href=&quot;../infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 제공되지 않으면 결과는 &lt;a href=&quot;../infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d63e690a371b2f42dfb850c4bf3dbb9ed32758d6" translate="yes" xml:space="preserve">
          <source>If no arguments are given, the result is &lt;a href=&quot;../infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 제공되지 않으면 결과는 &lt;a href=&quot;../infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ce565041aff6de5300fa5e4efb7b43bee1e0ca9" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, the constructor creates a JavaScript &lt;code&gt;Date&lt;/code&gt; object for the current date and time according to system settings for timezone offset.</source>
          <target state="translated">인수가 제공되지 않으면 생성자 는 표준 시간대 오프셋에 대한 시스템 설정에 따라 현재 날짜 및 시간에 대한 JavaScript &lt;code&gt;Date&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="349be3fe930215fab503b160fac65a4afd9578ab" translate="yes" xml:space="preserve">
          <source>If no elements are removed, an empty array is returned.</source>
          <target state="translated">제거 된 요소가 없으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f768f5cdd68c2b69894b9dde66eb214e5224574b" translate="yes" xml:space="preserve">
          <source>If no index is provided to &lt;code&gt;charAt()&lt;/code&gt;, the default is 0.</source>
          <target state="translated">&lt;code&gt;charAt()&lt;/code&gt; 인덱스가 제공되지 않으면 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="df2278328be6b4739a3d8c782a34d0454e15f504" translate="yes" xml:space="preserve">
          <source>If no matching &lt;code&gt;case&lt;/code&gt; clause is found, the program looks for the optional &lt;code&gt;default&lt;/code&gt; clause, and if found, transfers control to that clause, executing the associated statements. If no &lt;code&gt;default&lt;/code&gt; clause is found, the program continues execution at the statement following the end of &lt;code&gt;switch&lt;/code&gt;. By convention, the &lt;code&gt;default&lt;/code&gt; clause is the last clause, but it does not need to be so.</source>
          <target state="translated">일치하는 &lt;code&gt;case&lt;/code&gt; 절이 없으면 프로그램은 선택적 &lt;code&gt;default&lt;/code&gt; 절을 찾고 찾은 경우 연관된 절을 실행하여 해당 절로 제어를 전송합니다. &lt;code&gt;default&lt;/code&gt; 절이 없으면 프로그램은 &lt;code&gt;switch&lt;/code&gt; 종료 후 명령문에서 실행을 계속 합니다 . 규칙에 따라 &lt;code&gt;default&lt;/code&gt; 절은 마지막 절이지만 그럴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9c179b8d44481d64d61150bf0f2642fed87585c" translate="yes" xml:space="preserve">
          <source>If no string is explicitly provided, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-tostring&quot;&gt;&lt;var&gt;searchValue&lt;/var&gt; will be coerced to &quot;&lt;code&gt;undefined&lt;/code&gt;&quot;&lt;/a&gt;, and this value will be searched for in &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열이 명시 적으로 제공되지 않으면 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-tostring&quot;&gt; &lt;var&gt;searchValue&lt;/var&gt; 가 &quot; &lt;code&gt;undefined&lt;/code&gt; &quot; 로 강제 변환 되고이&lt;/a&gt; 값은 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; 에서 검색됩니다. .</target>
        </trans-unit>
        <trans-unit id="03d6fe27bce7cb59badbbf88b73e5ae858f2f1f6" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;NaN&lt;/code&gt;, the return value will be the integer that is the first argument taken as a number in the specified &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt;. (For example, a &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; of &lt;code&gt;10&lt;/code&gt; converts from a decimal number, &lt;code&gt;8&lt;/code&gt; converts from octal, &lt;code&gt;16&lt;/code&gt; from hexadecimal, and so on.)</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 이 아니면 반환 값은 지정된 &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 의 숫자로 사용되는 첫 번째 인수 인 정수가됩니다 . (예를 들어, &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 의 &lt;code&gt;10&lt;/code&gt; 개 진수 번호로부터 변환 &lt;code&gt;8&lt;/code&gt; 개 진법으로 변환, &lt;code&gt;16&lt;/code&gt; 등의 진수 및).</target>
        </trans-unit>
        <trans-unit id="157db00b7126c89fc2532f635dc2767990139ad4" translate="yes" xml:space="preserve">
          <source>If one of the operands is &lt;code&gt;Boolean&lt;/code&gt;, the Boolean operand is converted to 1 if it is &lt;code&gt;true&lt;/code&gt; and +0 if it is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">피연산자 중 하나가 &lt;code&gt;Boolean&lt;/code&gt; 인 경우 부울 피연산자는 &lt;code&gt;true&lt;/code&gt; 이면 1로 변환되고 &lt;code&gt;false&lt;/code&gt; 이면 +0으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5aa8b2baae192e612c1543533ffaebb114c4ec0f" translate="yes" xml:space="preserve">
          <source>If one or both arguments are omitted or are provided non-functions, then &lt;code&gt;then&lt;/code&gt; will be missing the handler(s), but will not generate any errors. If the &lt;code&gt;Promise&lt;/code&gt; that &lt;code&gt;then&lt;/code&gt; is called on adopts a state (&lt;code&gt;fulfillment&lt;/code&gt; or &lt;code&gt;rejection&lt;/code&gt;) for which &lt;code&gt;then&lt;/code&gt; has no handler, a new &lt;code&gt;Promise&lt;/code&gt; is created with no additional handlers, simply adopting the final state of the original &lt;code&gt;Promise&lt;/code&gt; on which &lt;code&gt;then&lt;/code&gt; was called.</source>
          <target state="translated">하나 또는 두 개의 인자가 생략되거나 다음 비 기능 제공되면 &lt;code&gt;then&lt;/code&gt; 처리기 (들)를 누락한다, 그러나 어떤 오류가 발생하지 않을 것이다. 는 IF &lt;code&gt;Promise&lt;/code&gt; 것이 &lt;code&gt;then&lt;/code&gt; 에 호출은 상태 (채택 &lt;code&gt;fulfillment&lt;/code&gt; 또는 &lt;code&gt;rejection&lt;/code&gt; 하는) &lt;code&gt;then&lt;/code&gt; 어떤 핸들러가 없습니다를, 새로운 &lt;code&gt;Promise&lt;/code&gt; 단순히 원래의 최종 상태 채택, 추가 핸들러로 만든 &lt;code&gt;Promise&lt;/code&gt; 된 &lt;code&gt;then&lt;/code&gt; 라고했습니다.</target>
        </trans-unit>
        <trans-unit id="3b2d6b28b997335014500b08d8f04f7c3691b2c8" translate="yes" xml:space="preserve">
          <source>If one or both arguments are omitted or are provided non-functions, then &lt;code&gt;then&lt;/code&gt; will be missing the handler(s), but will not generate any errors. If the &lt;code&gt;Promise&lt;/code&gt; that &lt;code&gt;then&lt;/code&gt; is called on adopts a state (&lt;code&gt;fulfillment&lt;/code&gt; or &lt;code&gt;rejection&lt;/code&gt;) for which &lt;code&gt;then&lt;/code&gt; has no handler, the returned promise simply adopts the final state of the original &lt;code&gt;Promise&lt;/code&gt; on which &lt;code&gt;then&lt;/code&gt; was called.</source>
          <target state="translated">하나 또는 두 개의 인자가 생략되거나 다음 비 기능 제공되면 &lt;code&gt;then&lt;/code&gt; 처리기 (들)를 누락한다, 그러나 어떤 오류가 발생하지 않을 것이다. 는 IF &lt;code&gt;Promise&lt;/code&gt; 것이 &lt;code&gt;then&lt;/code&gt; 에 호출은 상태 (채택 &lt;code&gt;fulfillment&lt;/code&gt; 또는 &lt;code&gt;rejection&lt;/code&gt; 하는) &lt;code&gt;then&lt;/code&gt; 어떤 핸들러가 없습니다를 반환 약속은 단순히 원래의 최종 상태 채택 &lt;code&gt;Promise&lt;/code&gt; 된 &lt;code&gt;then&lt;/code&gt; 라고했습니다.</target>
        </trans-unit>
        <trans-unit id="457b342baa5fd75eb025ca9f5b99efd20082c5f4" translate="yes" xml:space="preserve">
          <source>If one wishes to follow the more recent &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; for URLs, which makes square brackets reserved (for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IPv6&quot;&gt;IPv6&lt;/a&gt;) and thus not encoded when forming something which could be part of a URL (such as a host), the following code snippet may help:</source>
          <target state="translated">URL에 대한 최신 &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; 을 따르고 자하는 경우 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IPv6&quot;&gt;IPv6의 경우&lt;/a&gt; ) 대괄호가 예약되어 URL (예 : 호스트)의 일부가 될 수있는 항목을 구성 할 때 인코딩되지 않는 경우 다음 코드 스 니펫이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c69555d0da6cfd17e4847850dca3e2008fe6a4" translate="yes" xml:space="preserve">
          <source>If only one element is removed, an array of one element is returned.</source>
          <target state="translated">하나의 요소 만 제거되면 한 요소의 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89d18e2f04f7d7d60c84e76982daf3b58967d734" translate="yes" xml:space="preserve">
          <source>If passing the function argument using an &lt;a href=&quot;../../functions/arrow_functions&quot;&gt;arrow function expression&lt;/a&gt; the &lt;code&gt;thisArg&lt;/code&gt; parameter can be omitted as arrow functions lexically bind the &lt;a href=&quot;../../operators/this&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">하여 함수 인수를 전달하는 경우, &lt;a href=&quot;../../functions/arrow_functions&quot;&gt;화살표 함수식 &lt;/a&gt; &lt;code&gt;thisArg&lt;/code&gt; 파라미터 어휘 화살표 기능은 생략 될 수 인드 &lt;a href=&quot;../../operators/this&quot;&gt; &lt;code&gt;this&lt;/code&gt; &lt;/a&gt; 값.</target>
        </trans-unit>
        <trans-unit id="6b009fba48b5763df48e0358044ceb1e1dc86d5e" translate="yes" xml:space="preserve">
          <source>If pattern argument is &lt;strong&gt;not&lt;/strong&gt; a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object, &lt;a href=&quot;../string/replace&quot;&gt;&lt;code&gt;String.prototype.replace()&lt;/code&gt;&lt;/a&gt; doesn't call this method, nor creates a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">패턴 인수가 &lt;strong&gt;없는 &lt;/strong&gt;&lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 개체, &lt;a href=&quot;../string/replace&quot;&gt; &lt;code&gt;String.prototype.replace()&lt;/code&gt; &lt;/a&gt; 이 메소드를 호출,도 아니다 생성하지 않는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="6c9e2fc126b23061bb02204abf1952156dba945b" translate="yes" xml:space="preserve">
          <source>If provided, it is used as the length of &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt;. Defaults to &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length&lt;/code&gt;.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; 의 길이로 사용됩니다 . 기본값은 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;.length&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="afe3f0eab5663e5d1ba57f7d29abefac6af921f5" translate="yes" xml:space="preserve">
          <source>If specified and not &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, an object whose enumerable own properties (that is, those properties defined upon itself and &lt;em&gt;not&lt;/em&gt; enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of &lt;a href=&quot;defineproperties&quot;&gt;&lt;code&gt;Object.defineProperties()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정되고 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 가&lt;/a&gt; 아닌 경우 열거 가능한 자체 속성 (즉, 프로토 타입 체인을 따라 열거 가능한 속성이 &lt;em&gt;아닌&lt;/em&gt; 자체에 대해 정의 된 속성)을 가진 객체는 해당 속성 이름과 함께 새로 생성 된 객체에 추가 할 속성 설명자를 지정합니다. 이러한 속성은 &lt;a href=&quot;defineproperties&quot;&gt; &lt;code&gt;Object.defineProperties()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffe4874009bf36af9606205e966fc91f48654a0" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;flags&lt;/code&gt; indicates the flags to add, or if an object is supplied for the pattern, the &lt;code&gt;flags&lt;/code&gt; value will replace any of that object's flags (and &lt;code&gt;lastIndex&lt;/code&gt; will be reset to 0) (as of ES2015). If &lt;code&gt;flags&lt;/code&gt; is not specified and a regular expressions object is supplied, that object's flags (and &lt;code&gt;lastIndex&lt;/code&gt; value) will be copied over. The value is a string containing any combination of the following values:</source>
          <target state="translated">지정된 경우 &lt;code&gt;flags&lt;/code&gt; 는 추가 할 플래그를 나타내거나 패턴에 객체가 제공되면 &lt;code&gt;flags&lt;/code&gt; 값은 해당 객체의 플래그를 대체합니다 (그리고 &lt;code&gt;lastIndex&lt;/code&gt; 는 0으로 재설정 됨) (ES2015 기준). 경우 &lt;code&gt;flags&lt;/code&gt; 지정되지 않고 정규 표현식 객체가 공급되고, 해당 개체의 플래그 (그리고 &lt;code&gt;lastIndex&lt;/code&gt; 값) 복사됩니다. 값은 다음 값의 조합을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0f278705572fe4cf68405aa4e5bdb3c3070a0a9a" translate="yes" xml:space="preserve">
          <source>If specified, flags can have any combination of the following values:</source>
          <target state="translated">지정된 경우 플래그는 다음 값의 조합을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d41c0656b3d2ecfbd3b7ffcf0502574cc52a75c7" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;[@@search]()&lt;/code&gt; returns the index of the first match of the regular expression inside the string. Otherwise, it returns -1.</source>
          <target state="translated">성공하면 &lt;code&gt;[@@search]()&lt;/code&gt; 는 문자열 내에서 정규 표현식의 첫 번째 일치 색인을 리턴합니다. 그렇지 않으면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee11a9ac2ddedc856e6b1b7ccdce4f9c79a7d963" translate="yes" xml:space="preserve">
          <source>If such an element is found, &lt;code&gt;findIndex()&lt;/code&gt; immediately returns the element's index. If &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; never returns a truthy value (or the array's &lt;code&gt;length&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;), &lt;code&gt;findIndex()&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">그러한 요소가 발견되면 &lt;code&gt;findIndex()&lt;/code&gt; 즉시 요소의 인덱스를 반환합니다. &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 이 진실 값을 반환하지 않는 경우 (또는 배열의 &lt;code&gt;length&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; ) &lt;code&gt;findIndex()&lt;/code&gt; 는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="9c16da19397f9747a7c13f6fa34a9db0332a7be3" translate="yes" xml:space="preserve">
          <source>If such an element is found, &lt;code&gt;findIndex&lt;/code&gt; immediately returns that found element's index. If the callback never returns a truthy value or the array's &lt;code&gt;length&lt;/code&gt; is 0, &lt;code&gt;findIndex&lt;/code&gt; returns -1. Unlike some other array methods such as &lt;a href=&quot;some&quot;&gt;&lt;code&gt;Array.some&lt;/code&gt;&lt;/a&gt;, in sparse arrays the &lt;code&gt;callback&lt;/code&gt;&lt;strong&gt;is called&lt;/strong&gt; even for indexes of entries not present in the array.</source>
          <target state="translated">이러한 요소가 발견되면 &lt;code&gt;findIndex&lt;/code&gt; 는 발견 된 요소의 색인을 즉시 리턴합니다. 콜백이 절대 값을 반환하지 않거나 배열의 &lt;code&gt;length&lt;/code&gt; 가 0이면 &lt;code&gt;findIndex&lt;/code&gt; 는 -1을 반환합니다. &lt;a href=&quot;some&quot;&gt; &lt;code&gt;Array.some&lt;/code&gt; &lt;/a&gt; 과 같은 다른 배열 메소드와 달리 , 희소 배열에서는 배열에 없는 항목 색인에 대해서도 &lt;code&gt;callback&lt;/code&gt; &lt;strong&gt;이 호출&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1e6e164506acad60b43c996244e0ccc14c8ac0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; is outside of the range of date values for the month, &lt;code&gt;setDate()&lt;/code&gt; will update the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 가 해당 월의 날짜 값 범위를 벗어나 면 &lt;code&gt;setDate()&lt;/code&gt; 가 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 를 업데이트합니다. 그에 따라 객체를 .</target>
        </trans-unit>
        <trans-unit id="50246270bc94fbe34619b2358197206035242ab3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; argument is omitted, the number of digits after the decimal point defaults to the number of digits necessary to represent the value uniquely.</source>
          <target state="translated">경우] &lt;code&gt;&lt;var&gt;fractionDigits&lt;/var&gt;&lt;/code&gt; 인수를 생략 필요한 숫자의 수에 소수점의 디폴트의 자리수는 고유 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8a042a031513c64b3651a694e6ea1a7b0776593" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; is negative, the sign is preserved. This is the case even if the radix is &lt;code&gt;2&lt;/code&gt;; the string returned is the positive binary representation of the &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; preceded by a &lt;code&gt;-&lt;/code&gt; sign, &lt;strong&gt;not&lt;/strong&gt; the two's complement of the &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; 가 부의 경우, 부호가 유지됩니다. 기수가 &lt;code&gt;2&lt;/code&gt; 인 경우에도 마찬가지입니다 . 반환 된 문자열은 &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; 이 앞에는 &lt;code&gt;-&lt;/code&gt; 기호,&lt;strong&gt; 하지&lt;/strong&gt; 의 2의 보수 &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7a7c24bdbbc78170e073659c5f668b16269b25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; is not a whole number, the 'dot' sign is used to separate the decimal places.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;var&gt;numObj&lt;/var&gt;&lt;/code&gt; 이 정수가 아닌는 '점'기호는 소수점을 분리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b245f6f7566843542a7c173cff50732fbfd3bacf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; is not specified, the preferred radix is assumed to be &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 지정되지 않은 선호 기수는 것으로 가정한다 &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54ad481de4c33588fdb0802190cf8b149d7966ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; is smaller than &lt;code&gt;2&lt;/code&gt; or bigger than &lt;code&gt;36&lt;/code&gt;, and the first non-whitespace character cannot be converted to a number, &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 보다 작다 &lt;code&gt;2&lt;/code&gt; 또는보다 큰 &lt;code&gt;36&lt;/code&gt; , 첫 번째 공백이 아닌 문자를 숫자로 변환 할 수 없습니다 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 이&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a67a27ec1cbf334f567215905a7753278f9f6b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; only transforms some values and not others, be certain to return all untransformed values as-is, otherwise, they will be deleted from the resulting object.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;reviver&lt;/var&gt;&lt;/code&gt; 일부 값이 아닌 다른 사람을 변환,있는 그대로 모든 변형되지 않은 값을 반환 할 확신 그렇지 않으면 결과 객체에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3f05af6384b04457cbb7e13272e0dc49a80bd675" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/getownpropertydescriptor&quot;&gt;&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;&lt;/a&gt;, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">이 메서드에 대한 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 인수가 객체 (기본)가 아니면&lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;. &lt;a href=&quot;../object/getownpropertydescriptor&quot;&gt; &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 를&lt;/a&gt; 사용하면객체가 아닌 첫 번째 인수가 처음에 객체로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9f99648bb256a49a00568bf5dfb30e3033d62e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/isextensible&quot;&gt;&lt;code&gt;Object.isExtensible()&lt;/code&gt;&lt;/a&gt;, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">이 메서드에 대한 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 인수가 객체 (기본)가 아니면&lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;. 와&lt;a href=&quot;../object/isextensible&quot;&gt; &lt;code&gt;Object.isExtensible()&lt;/code&gt; &lt;/a&gt; 객체가 아닌 첫 번째 인수가 처음에 객체로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcf4e160575e283d63147e2cc65d135d2974ea8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/preventextensions&quot;&gt;&lt;code&gt;Object.preventExtensions()&lt;/code&gt;&lt;/a&gt;, a non-object &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; will be coerced to an object.</source>
          <target state="translated">이 메서드에 대한 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 인수가 객체 (기본 요소)가 아니면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 와 &lt;a href=&quot;../object/preventextensions&quot;&gt; &lt;code&gt;Object.preventExtensions()&lt;/code&gt; &lt;/a&gt; , 비 객체 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 객체에 강요한다.</target>
        </trans-unit>
        <trans-unit id="ed3ac025020aed5a0890e8afac6c32f2c8ae815b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; value passed to &lt;code&gt;TypedArray.from()&lt;/code&gt; is not a constructor, &lt;code&gt;TypedArray.from()&lt;/code&gt; will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Array.from()&lt;/code&gt; defaults to creating a new &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TypedArray.from()&lt;/code&gt; 전달 된 &lt;code&gt;&lt;var&gt;thisArg&lt;/var&gt;&lt;/code&gt; 값 이 생성자가 아닌 경우 &lt;code&gt;TypedArray.from()&lt;/code&gt; 은 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 를 발생 &lt;code&gt;Array.from()&lt;/code&gt; . 여기서 Array.from () 기본적으로 새 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e38a2717bbd5bd5ac9ed570a97494bee3fa7ab86" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; is rejected, the &lt;code&gt;await&lt;/code&gt; expression throws the rejected value.</source>
          <target state="translated">는 IF &lt;code&gt;Promise&lt;/code&gt; 거부되면, &lt;code&gt;await&lt;/code&gt; 를 발현이 거부 된 값을 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="35e4d659d7d35a3c85c18d904b4849b0e0e985e0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; is rejected, the rejected value is thrown.</source>
          <target state="translated">는 IF &lt;code&gt;Promise&lt;/code&gt; 거부, 거부 된 값이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be3b876046ad63614f4af66a1f82f87240d95fa8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;configurable&lt;/code&gt; attribute of &lt;code&gt;o.a&lt;/code&gt; had been &lt;code&gt;true&lt;/code&gt;, none of the errors would be thrown and the property would be deleted at the end.</source>
          <target state="translated">&lt;code&gt;o.a&lt;/code&gt; 의 &lt;code&gt;configurable&lt;/code&gt; 속성 이 &lt;code&gt;true&lt;/code&gt; 이면 오류가 발생하지 않으며 속성이 끝날 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ac47f72ce3f75c7a5073bd32d1f6a7c725984cd3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dayValue&lt;/code&gt; is outside of the range of date values for the month, &lt;code&gt;setDate()&lt;/code&gt; will update the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object accordingly. For example, if 0 is provided for &lt;code&gt;dayValue&lt;/code&gt;, the date will be set to the last day of the previous month.</source>
          <target state="translated">&lt;code&gt;dayValue&lt;/code&gt; 가 해당 월의 날짜 값 범위를 벗어나 면 &lt;code&gt;setDate()&lt;/code&gt; 는 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체를 적절 하게 업데이트합니다 . 예를 들어 &lt;code&gt;dayValue&lt;/code&gt; 에 0을 제공 하면 날짜가 전월의 마지막 날로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8c831ca3402dbcf2a32deaa1dbe0ffc5d3e40992" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;finally&lt;/code&gt; block returns a value, this value becomes the return value of the entire &lt;code&gt;try-catch-finally&lt;/code&gt; production, regardless of any &lt;code&gt;return&lt;/code&gt; statements in the &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; blocks. This includes exceptions thrown inside of the catch block:</source>
          <target state="translated">경우 &lt;code&gt;finally&lt;/code&gt; 블록은 값을 반환,이 값은 전체의 반환 값이됩니다 &lt;code&gt;try-catch-finally&lt;/code&gt; 에 상관없이의 생산 &lt;code&gt;return&lt;/code&gt; 에서 문 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 블록. 여기에는 catch 블록 내부에서 발생한 예외가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd8c3283258f28a255b8f9242378a0b430c842d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;finally&lt;/code&gt;-block returns a value, this value becomes the return value of the entire &lt;code&gt;try-catch-finally&lt;/code&gt; statement, regardless of any &lt;code&gt;return&lt;/code&gt; statements in the &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;-blocks. This includes exceptions thrown inside of the &lt;code&gt;catch&lt;/code&gt;-block:</source>
          <target state="translated">는 IF &lt;code&gt;finally&lt;/code&gt; - 블록을 반환 값으로,이 값이 전체의 반환 값이됩니다 &lt;code&gt;try-catch-finally&lt;/code&gt; 어떤 관계없이 문을 &lt;code&gt;return&lt;/code&gt; 에 문을 &lt;code&gt;try&lt;/code&gt; 하고 &lt;code&gt;catch&lt;/code&gt; -blocks. 여기에는 &lt;code&gt;catch&lt;/code&gt; 블록 내부에서 발생한 예외가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="887007377f2e5472d0d2ce3630b6c75058342d26" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fractionDigits&lt;/code&gt; argument is omitted, the number of digits after the decimal point defaults to the number of digits necessary to represent the value uniquely.</source>
          <target state="translated">는 IF &lt;code&gt;fractionDigits&lt;/code&gt; 의 인수를 생략 필요한 숫자의 수에 소수점의 디폴트의 자리수는 고유 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3945a3dae8e73ba351db0fe2aed7b731eb381952" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;g&lt;/code&gt; flag is used, all results matching the complete regular expression will be returned, but capturing groups will not.</source>
          <target state="translated">는 IF &lt;code&gt;g&lt;/code&gt; 의 플래그를 사용, 전체 정규 표현식과 일치하는 모든 결과가 반환하지만 캡처 그룹은하지 않습니다됩니다.</target>
        </trans-unit>
        <trans-unit id="ef660d2f00a701c21aacee179340977e0be81003" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;grow()&lt;/code&gt; operation fails for whatever reason, a &lt;a href=&quot;../../rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">는 IF &lt;code&gt;grow()&lt;/code&gt; 작업이 어떤 이유로 실패하는 &lt;a href=&quot;../../rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62ed07c8a605b46ecbd26f7316bd0d1b6317b32f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;numObj&lt;/code&gt; is negative, the sign is preserved. This is the case even if the radix is 2; the string returned is the positive binary representation of the &lt;code&gt;numObj&lt;/code&gt; preceded by a &lt;code&gt;-&lt;/code&gt; sign, &lt;strong&gt;not&lt;/strong&gt; the two's complement of the &lt;code&gt;numObj&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;numObj&lt;/code&gt; 가 부의 경우, 부호가 유지됩니다. 기수가 2 인 경우에도 마찬가지입니다. 반환 된 문자열의 긍정적 이진 표현이다 &lt;code&gt;numObj&lt;/code&gt; 이 앞에는 &lt;code&gt;-&lt;/code&gt; 기호, &lt;strong&gt;하지&lt;/strong&gt; 의 2의 보수 &lt;code&gt;numObj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964309f504b1e8dbcd7544bd0f936b81ccb62f80" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;numObj&lt;/code&gt; is not a whole number, the 'dot' sign is used to separate the decimal places.</source>
          <target state="translated">&lt;code&gt;numObj&lt;/code&gt; 가 정수가 아닌 경우 '점'부호는 소수점 이하 자릿수를 구분하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a28f6f94f14d2f4d2bb91f60f2a5ef633b20a00e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;precision&lt;/code&gt; argument is omitted, behaves as &lt;a href=&quot;tostring&quot;&gt;&lt;code&gt;Number.prototype.toString()&lt;/code&gt;&lt;/a&gt;. If the &lt;code&gt;precision&lt;/code&gt; argument is a non-integer value, it is rounded to the nearest integer.</source>
          <target state="translated">경우] &lt;code&gt;precision&lt;/code&gt; 인수를 생략로서 동작 &lt;a href=&quot;tostring&quot;&gt; &lt;code&gt;Number.prototype.toString()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;precision&lt;/code&gt; 인수가 정수가 아닌 값, 그것은 가장 가까운 정수로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="6a944bff6bb8c754d1d8d302d8f5101d5f14b110" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;radix&lt;/code&gt; is not specified, the preferred radix is assumed to be 10.</source>
          <target state="translated">경우] &lt;code&gt;radix&lt;/code&gt; 지정되지 않은 선호 기수 10으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="d18fb91572aa023d50209da5a43a714383069e99" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;reviver&lt;/code&gt; only transforms some values and not others, be certain to return all untransformed values as-is, otherwise they will be deleted from the resulting object.</source>
          <target state="translated">경우 &lt;code&gt;reviver&lt;/code&gt; 일부 값이 아닌 다른 사람을 변환,있는 그대로 모든 변형되지 않은 값을 반환 할 확신 할 그렇지 않으면 그들은 결과 객체에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a158dec28bab58d57879567bd00f0791b3830d8a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;revoke()&lt;/code&gt; function gets called, the proxy becomes unusable: Any trap to a handler will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Once a proxy is revoked, it will remain revoked and can be garbage collected. Calling &lt;code&gt;revoke()&lt;/code&gt; again has no effect.</source>
          <target state="translated">는 IF &lt;code&gt;revoke()&lt;/code&gt; 함수가 호출되는 프록시는 사용할 수 없게됩니다 : 핸들러에 대한 모든 트랩이 발생합니다 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . 프록시가 취소되면 취소 된 상태로 유지되며 가비지 수집 될 수 있습니다. &lt;code&gt;revoke()&lt;/code&gt; 다시 호출 해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb5c716988ff9e8f76361370d17e445497a6277b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; argument is &lt;strong&gt;not&lt;/strong&gt; a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object, &lt;a href=&quot;../string/split&quot;&gt;&lt;code&gt;String.prototype.split()&lt;/code&gt;&lt;/a&gt; doesn't call this method, nor create a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 인수가 &lt;strong&gt;없는 &lt;/strong&gt;&lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 개체, &lt;a href=&quot;../string/split&quot;&gt; &lt;code&gt;String.prototype.split()&lt;/code&gt; &lt;/a&gt; 이 메소드를 호출,도 아니다 만들지 않습니다 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="8eb4dd6a3439d48edde8782414da2fc33e520fe8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;this&lt;/code&gt; value passed to &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.of&lt;/code&gt; is not a constructor, &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.of&lt;/code&gt; will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Array.of&lt;/code&gt; defaults to creating a new &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;this&lt;/code&gt; 값을 전달 &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.of&lt;/code&gt; 생성자 아니다, &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.of&lt;/code&gt; 던져 것 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 어디 &lt;code&gt;Array.of&lt;/code&gt; 은 새로운 창조 기본값 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="723c644a1915a6d351777f6cab8660518aaa2659" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;this&lt;/code&gt; value passed to &lt;code&gt;&lt;var&gt;TypedArray&lt;/var&gt;.of&lt;/code&gt; is not a constructor, &lt;code&gt;&lt;var&gt;TypedArray&lt;/var&gt;.of&lt;/code&gt; will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Array.of&lt;/code&gt; defaults to creating a new &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;this&lt;/code&gt; 전달 값 &lt;code&gt;&lt;var&gt;TypedArray&lt;/var&gt;.of&lt;/code&gt; 생성자되지는 &lt;code&gt;&lt;var&gt;TypedArray&lt;/var&gt;.of&lt;/code&gt; 던져됩니다 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Array.of&lt;/code&gt; 의 새로운 창조에 기본값을&lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09c65f33aa598404d3369137e257e8e881b958f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;toString()&lt;/code&gt; method is called on a function created by the &lt;code&gt;Function&lt;/code&gt; constructor, &lt;code&gt;toString()&lt;/code&gt; returns the source code of a synthesized function declaration named &quot;anonymous&quot; using the provided parameters and function body.</source>
          <target state="translated">&lt;code&gt;Function&lt;/code&gt; 생성자가 만든 함수 에서 &lt;code&gt;toString()&lt;/code&gt; 메서드를 호출 하면 &lt;code&gt;toString()&lt;/code&gt; 은 제공된 매개 변수와 함수 본문을 사용하여 &quot;anonymous&quot;라는 합성 함수 선언의 소스 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2d395675e98f1c324b31de3e7f800ca7f0ca1d0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;toString()&lt;/code&gt; method is called on built-in function objects or a function created by &lt;code&gt;Function.prototype.bind&lt;/code&gt;, &lt;code&gt;toString()&lt;/code&gt; returns a &lt;em&gt;native function string&lt;/em&gt; which looks like</source>
          <target state="translated">내장 함수 객체 또는 &lt;code&gt;Function.prototype.bind&lt;/code&gt; 로 작성된 함수 에서 &lt;code&gt;toString()&lt;/code&gt; 메소드가 호출 되면 &lt;code&gt;toString()&lt;/code&gt; 은 다음과 같은 &lt;em&gt;기본 함수 문자열&lt;/em&gt; 을 리턴합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e56640ad0ffad1ff5993fcb62e39036efe032f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;|this|&lt;/code&gt; value passed to &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.from&lt;/code&gt; is not a constructor, &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.from&lt;/code&gt; will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Array.from&lt;/code&gt; defaults to creating a new &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;|this|&lt;/code&gt; 전달 값 &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.from&lt;/code&gt; 생성자 아니다, &lt;code&gt;&lt;em&gt;TypedArray&lt;/em&gt;.from&lt;/code&gt; 던져 것 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 어디 &lt;code&gt;Array.from&lt;/code&gt; 은 새로운 창조 기본값 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77fff64ff9eae8df8bbff897e13e7521a4049f5a" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;iterable&lt;/var&gt; contains non-promise values, they will be ignored, but still counted in the returned promise array value (if the promise is fulfilled):</source>
          <target state="translated">&lt;var&gt;iterable&lt;/var&gt; 에 약속이 아닌 값이 포함되어 있으면 값이 무시되지만 반환 된 약속 배열 값 (약속이 이행 된 경우)에 계속 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="4d5a749e884b72ff7fdb5c875dfb8ade05e78e57" translate="yes" xml:space="preserve">
          <source>If the JavaScript interpreter cannot guarantee that all the provided arguments are numbers at the point that the call is made, it needs to either insert checks for all the arguments before the inlined code, or it cannot inline the function. Now in this particular case a smart interpreter should be able to rearrange the checks to be more optimal and not check any values that would not be used. However in many cases that's just not possible and therefore it becomes impossible to inline.</source>
          <target state="translated">JavaScript 인터프리터가 제공된 모든 인수가 호출 시점의 숫자임을 보장 할 수없는 경우 인라인 된 코드 앞에 모든 인수에 대한 검사를 삽입하거나 함수를 인라인 할 수 없습니다. 이제이 특별한 경우에, 스마트 통역사는보다 최적의 수표를 재정렬하고 사용하지 않을 값을 점검하지 않아야합니다. 그러나 많은 경우에 그것은 가능하지 않으므로 인라인하는 것이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="68a358bd84ef01c0635528f27a3fd8e8510d7208" translate="yes" xml:space="preserve">
          <source>If the above is written using traditional function-based syntax, then autoboxing in method calls will happen in non&amp;ndash;strict mode based on the initial &lt;em&gt;this&lt;/em&gt; value. If the initial value is &lt;code&gt;undefined&lt;/code&gt;, &lt;em&gt;this&lt;/em&gt; will be set to the global object.</source>
          <target state="translated">위가 기존 기능 기반 구문을 사용하여 작성되는 경우, 초기에 따라 비 엄격 모드에서 일어날 메서드 호출에 오토 박싱 &lt;em&gt;이&lt;/em&gt; 값. 초기 값이 경우 &lt;code&gt;undefined&lt;/code&gt; , &lt;em&gt;이것은&lt;/em&gt; 전역 객체로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2de2f8611418b917390e5f634cefd48a2681c4fe" translate="yes" xml:space="preserve">
          <source>If the argument cannot be converted into a number, it returns &lt;a href=&quot;nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수를 숫자로 변환 할 수 없으면 &lt;a href=&quot;nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 을 반환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f86e9bf415bebd29a0f92aca1846c02d35a1eafa" translate="yes" xml:space="preserve">
          <source>If the argument is negative zero, returns &lt;code&gt;-0&lt;/code&gt;.</source>
          <target state="translated">인수가 음수 0이면 다음을 반환합니다. &lt;code&gt;-0&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="289d26426ef6dd5e6d6eab0c14be2df2d5ca5e8d" translate="yes" xml:space="preserve">
          <source>If the argument is negative, returns &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">인수가 음수 &lt;code&gt;-1&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e8a717149be7c86d7d72f862e113481d8afe3c" translate="yes" xml:space="preserve">
          <source>If the argument is positive zero, returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">인수가 정의 제로 인 경우, 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d32df946129f68834ae9d6e3c48b76560ca41a5" translate="yes" xml:space="preserve">
          <source>If the argument is positive, returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">인수가 양수이면 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48a314159461e2f1c2180c3f2cc15ad46da26b49" translate="yes" xml:space="preserve">
          <source>If the argument of &lt;code&gt;eval()&lt;/code&gt; is not a string, &lt;code&gt;eval()&lt;/code&gt; returns the argument unchanged. In the following example, the &lt;code&gt;String&lt;/code&gt; constructor is specified and &lt;code&gt;eval()&lt;/code&gt; returns a &lt;code&gt;String&lt;/code&gt; object rather than evaluating the string.</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 의 인수가 문자열이 아닌 경우 &lt;code&gt;eval()&lt;/code&gt; 은 인수를 변경하지 않고 리턴합니다. 다음 예제에서는 &lt;code&gt;String&lt;/code&gt; 생성자가 지정되고 &lt;code&gt;eval()&lt;/code&gt; 은 문자열을 평가하지 않고 &lt;code&gt;String&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1bfa86a1ae20fafacc59165c12911fe2c76ebf6c" translate="yes" xml:space="preserve">
          <source>If the argument&amp;rsquo;s first character can&amp;rsquo;t be converted to a number (it&amp;rsquo;s not any of the above characters), &lt;code&gt;parseFloat&lt;/code&gt; returns &lt;a href=&quot;nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수의 첫 문자를 숫자로 변환 할 수없는 경우 (위의 문자가 아님) &lt;code&gt;parseFloat&lt;/code&gt; 는 &lt;a href=&quot;nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 을 반환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9039cba0fc2b860a2bac0dd4ce6f62caa5dec6d9" translate="yes" xml:space="preserve">
          <source>If the arguments are not of the type string, they are converted to string values before concatenating.</source>
          <target state="translated">인수가 문자열 유형이 아닌 경우 연결하기 전에 문자열 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa2bcd893cb4d56cf48e54162eb8eabb074cee3" translate="yes" xml:space="preserve">
          <source>If the array is empty and no &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; is provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">배열이 비어 있고 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공 되지 않은 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="251133e014c170d65b3f1b94cd31ef8f9657cbc6" translate="yes" xml:space="preserve">
          <source>If the array is empty and no &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; was provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; would be thrown. If the array has only one element (regardless of position) and no &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; was provided, or if &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; is provided but the array is empty, the solo value would be returned without calling &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">배열이 비어 있고 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공 되지 않은 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열에 (위치에 관계없이) 요소가 하나만 있고 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공 되지 않았 거나 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공되었지만 배열이 비어있는 경우 &lt;code&gt;&lt;var&gt;callback&lt;/var&gt;&lt;/code&gt; 을 호출하지 않고 solo 값이 반환됩니다. .</target>
        </trans-unit>
        <trans-unit id="8ca4c7e25be73952009dedc5b8fea1da899df392" translate="yes" xml:space="preserve">
          <source>If the array is empty and no &lt;code&gt;initialValue &lt;/code&gt;was provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; would be thrown. If the array has only one element (regardless of position) and no &lt;code&gt;initialValue &lt;/code&gt;was provided, or if &lt;code&gt;initialValue&lt;/code&gt; is provided but the array is empty, the solo value would be returned without calling &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">배열이 비어 있고 &lt;code&gt;initialValue &lt;/code&gt; 가 제공 되지 않은 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열에 요소가 하나만 있고 (위치에 관계없이) &lt;code&gt;initialValue &lt;/code&gt; 가 제공 되지 않았 거나 &lt;code&gt;initialValue&lt;/code&gt; 가 제공되었지만 배열이 비어있는 경우 &lt;code&gt;callback&lt;/code&gt; 을 호출하지 않고 솔로 값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c59f20390f4add64d4abadd81feb605dba0b978" translate="yes" xml:space="preserve">
          <source>If the array is empty and no &lt;code&gt;initialValue&lt;/code&gt; is provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be thrown. If the array has only one element (regardless of position) and no &lt;code&gt;initialValue&lt;/code&gt; is provided, or if &lt;code&gt;initialValue&lt;/code&gt; is provided but the array is empty, the solo value will be returned &lt;em&gt;without calling &lt;code&gt;callback&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">배열이 비어 있고 &lt;code&gt;initialValue&lt;/code&gt; 가 제공 되지 않으면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열에 요소가 하나만 있고 (위치에 관계없이) &lt;code&gt;initialValue&lt;/code&gt; 가 제공 되지 않거나 &lt;code&gt;initialValue&lt;/code&gt; 가 제공되었지만 배열이 비어있는 경우 &lt;em&gt; &lt;code&gt;callback&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 을 호출하지 않고&lt;/em&gt; 솔로 값이 반환 &lt;em&gt;됩니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1066bdb8f6e775da5b0f08dd139c62f7735718b8" translate="yes" xml:space="preserve">
          <source>If the array is modified during iteration, other elements might be skipped.</source>
          <target state="translated">반복 중에 배열을 수정하면 다른 요소를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7918e87d675662b81e34c9d4d3015efc6c03c96" translate="yes" xml:space="preserve">
          <source>If the array only has one element (regardless of position) and no &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; is provided, or if &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; is provided but the array is empty, the solo value will be returned &lt;em&gt;without &lt;/em&gt;calling&lt;em&gt; &lt;code&gt;callback&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">배열에 (위치에 관계없이) 요소가 하나만 있고 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공 되지 않거나 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 가 제공되었지만 배열이 비어있는 경우 &lt;em&gt; &lt;code&gt;callback&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 을&lt;/em&gt; 호출 &lt;em&gt;하지 않고&lt;/em&gt; solo 값이 반환 &lt;em&gt;됩니다.&lt;/em&gt;&lt;em&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e8c9b894a110d1dce237c3ffe9e8ff7d483f6e8" translate="yes" xml:space="preserve">
          <source>If the calculation of a property value is expensive (takes much RAM or CPU time, spawns worker thread, retrieves remote file, etc).</source>
          <target state="translated">속성 값 계산이 비싼 경우 (RAM 또는 CPU 시간이 많이 걸리고 작업자 스레드를 생성하고 원격 파일을 검색하는 등)</target>
        </trans-unit>
        <trans-unit id="b4773ffb9070fe50ec4b5a95d53687ea8941a3c4" translate="yes" xml:space="preserve">
          <source>If the calculation of a property value is expensive (takes much RAM or CPU time, spawns worker threads, retrieves remote file, etc).</source>
          <target state="translated">속성 값 계산이 비용이 많이 드는 경우 (RAM 또는 CPU 시간이 많이 걸리고 작업자 스레드가 생성되고 원격 파일을 검색하는 등)</target>
        </trans-unit>
        <trans-unit id="97084eab376f3b04d4908cc6bf47f923311c72b1" translate="yes" xml:space="preserve">
          <source>If the converted 32-bit unsigned integer is &lt;code&gt;0&lt;/code&gt;, then return &lt;code&gt;32&lt;/code&gt;, because all bits are &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">변환 된 32 비트 부호없는 정수가 &lt;code&gt;0&lt;/code&gt; 이면 모든 비트가 &lt;code&gt;0&lt;/code&gt; 이므로 &lt;code&gt;32&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0ad167e307d5ae6b6eba5969fea22aadee5ee633" translate="yes" xml:space="preserve">
          <source>If the first argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/getownpropertydescriptor&quot;&gt;&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;&lt;/a&gt;, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">이 메소드의 첫 번째 인수가 객체 (기본)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;a href=&quot;../object/getownpropertydescriptor&quot;&gt; &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 를&lt;/a&gt; 사용하면 객체가 아닌 첫 번째 인수가 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e9511e31d3fc65e2014860d72bf862465ad596" translate="yes" xml:space="preserve">
          <source>If the first argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/isextensible&quot;&gt;&lt;code&gt;Object.isExtensible()&lt;/code&gt;&lt;/a&gt;, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">이 메소드의 첫 번째 인수가 객체 (기본)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;a href=&quot;../object/isextensible&quot;&gt; &lt;code&gt;Object.isExtensible()&lt;/code&gt; &lt;/a&gt; 사용하면 객체가 아닌 첫 번째 인수가 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="1fce2befc5daf124a888421997f4eb1a74803bb3" translate="yes" xml:space="preserve">
          <source>If the first argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. With &lt;a href=&quot;../object/preventextensions&quot;&gt;&lt;code&gt;Object.preventExtensions()&lt;/code&gt;&lt;/a&gt;, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">이 메소드의 첫 번째 인수가 객체 (기본)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;a href=&quot;../object/preventextensions&quot;&gt; &lt;code&gt;Object.preventExtensions()&lt;/code&gt; &lt;/a&gt; 사용하면 객체 가 아닌 첫 번째 인수가 처음에 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="74367fdf24ade95ee132ed1601c1dd829d6eab8f" translate="yes" xml:space="preserve">
          <source>If the first character cannot be converted to a number with the radix in use, &lt;code&gt;parseInt&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문자를 사용중인 기수가있는 숫자로 변환 할 수없는 경우 &lt;code&gt;parseInt&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ace5bb08886884c70b8510126b7ab1ac0624e793" translate="yes" xml:space="preserve">
          <source>If the first character cannot be converted to a number, &lt;code&gt;parseInt&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">첫 번째 문자를 숫자로 변환 할 수 없으면 &lt;code&gt;parseInt&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2466baa3d5ce80a7bc532ef0c023761bde57195c" translate="yes" xml:space="preserve">
          <source>If the first parameter is an object, each slot in the array will reference that object.</source>
          <target state="translated">첫 번째 매개 변수가 객체이면 배열의 각 슬롯이 해당 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e830391a32752966b6f8d6e46ae869596b43464d" translate="yes" xml:space="preserve">
          <source>If the following invariants are violated, the proxy will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음과 같은 불변이 위반되면 프록시는 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="02ea11ae320384d65baba2b2012559732cdf307a" translate="yes" xml:space="preserve">
          <source>If the following invariants are violated, the proxy will throw a TypeError:</source>
          <target state="translated">다음과 같은 변형이 위반되면 프록시에서 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a774c38f7a09fed2dfaac1cf3398252fa33b21d" translate="yes" xml:space="preserve">
          <source>If the fractional portion of the argument is greater than 0.5, the argument is rounded to the integer with the next higher absolute value. If it is less than 0.5, the argument is rounded to the integer with the lower absolute value. If the fractional portion is exactly 0.5, the argument is rounded to the next integer in the direction of +&amp;infin;. &lt;strong&gt;Note that this differs from many languages' &lt;code&gt;round()&lt;/code&gt; functions, which often round this case to the next integer &lt;em&gt;away from zero&lt;/em&gt;&lt;/strong&gt;, instead giving a different result in the case of negative numbers with a fractional part of exactly 0.5.</source>
          <target state="translated">인수의 소수 부분이 0.5보다 큰 경우 인수는 다음으로 높은 절대 값을 갖는 정수로 반올림됩니다. 0.5보다 작은 경우 인수는 절대 값이 더 낮은 정수로 반올림됩니다. 소수 부분이 정확히 0.5 인 경우 인수는 + &amp;infin; 방향으로 다음 정수로 반올림됩니다. &lt;strong&gt;이것은 많은 언어의 &lt;code&gt;round()&lt;/code&gt; 함수 와 다릅니다.이 함수는 종종이 경우를 &lt;em&gt;0&lt;/em&gt;&lt;/strong&gt; 에서 &lt;strong&gt;&lt;em&gt;멀어지는&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 다음 정수로 반올림&lt;/strong&gt; 하는 대신 분수가 정확히 0.5 인 음수의 경우 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0634e6f899b35ea60f41dd19d559af0166b4abf" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;eval&lt;/code&gt; is invoked by an expression of the form &lt;code&gt;eval(...)&lt;/code&gt; in strict mode code, the code will be evaluated as strict mode code. The code may explicitly invoke strict mode, but it's unnecessary to do so.</source>
          <target state="translated">엄격 모드 코드에서 &lt;code&gt;eval(...)&lt;/code&gt; 형식의 표현식으로 함수 &lt;code&gt;eval&lt;/code&gt; 을 호출 하면 코드는 엄격 모드 코드로 평가됩니다. 코드는 엄격하게 엄격 모드를 호출 할 수 있지만 그렇게 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="24479fad2ce8f41c59aa63feefedbe701c9c9fa0" translate="yes" xml:space="preserve">
          <source>If the function passed as handler to &lt;code&gt;then&lt;/code&gt; returns a &lt;code&gt;Promise&lt;/code&gt;, an equivalent &lt;code&gt;Promise&lt;/code&gt; will be exposed to the subsequent &lt;code&gt;then&lt;/code&gt; in the method chain. The below snippet simulates asynchronous code with the &lt;code&gt;setTimeout&lt;/code&gt; function.</source>
          <target state="translated">핸들러로서 기능이 경과하면 &lt;code&gt;then&lt;/code&gt; 반환 &lt;code&gt;Promise&lt;/code&gt; , 등가 &lt;code&gt;Promise&lt;/code&gt; 이후에 노출되는 &lt;code&gt;then&lt;/code&gt; 있어서 체인. 아래 스 니펫은 &lt;code&gt;setTimeout&lt;/code&gt; 함수를 사용하여 비동기 코드를 시뮬레이션 합니다.</target>
        </trans-unit>
        <trans-unit id="d889ec98d8457e0aea924810e5726b978b821209" translate="yes" xml:space="preserve">
          <source>If the function should be in &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, and the entire script or enclosing function is also okay to be in strict mode, you can move the &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directive outside of the function:</source>
          <target state="translated">함수가 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드에&lt;/a&gt; 있어야 하고 전체 스크립트 또는 엔 클로징 함수도 엄격 모드에있는 것이 괜찮 으면 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 지시문을 함수 외부 로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32ec2a558d2d7d263d497637245a807ee03c4f24" translate="yes" xml:space="preserve">
          <source>If the host system is configured for daylight saving, the offset will change depending on the date and time that the Date represents and that daylight saving applies.</source>
          <target state="translated">호스트 시스템이 일광 절약으로 구성된 경우 오프셋은 날짜가 나타내는 날짜 및 시간과 해당 일광 절약이 적용되는 시간에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="62f63a4a41145b733714a201b2e285ab0739d3b7" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with &quot;0&quot;, &lt;var&gt;radix&lt;/var&gt; is eight (octal) or 10 (decimal). Exactly which radix is chosen is implementation-dependent. ECMAScript 5 specifies that 10 (decimal) is used, but not all browsers support this yet. For this reason &lt;code&gt;parseInt&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 &quot;0&quot;으로 시작하면 &lt;var&gt;radix&lt;/var&gt; 는 8 (8 진수) 또는 10 (10 진수)입니다. 어떤 기수가 선택되는지는 구현에 따라 다릅니다. ECMAScript 5는 10 (10 진수)이 사용되도록 지정하지만 모든 브라우저에서 아직이 기능을 지원하지는 않습니다. 이런 이유로 &lt;code&gt;parseInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="014fd7b5028fdfd4181a76d255e1c44887ca6dae" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with &quot;0x&quot; or &quot;0X&quot;, &lt;var&gt;radix&lt;/var&gt; is 16 (hexadecimal) and the remainder of the string is parsed.</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 &quot;0x&quot;또는 &quot;0X&quot;로 시작하면 &lt;var&gt;radix&lt;/var&gt; 는 16 (16 진수)이고 나머지 문자열은 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="f247d76b51985796282d05631d015cfe0ded8f0d" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with &quot;&lt;code&gt;0&lt;/code&gt;&quot; (a zero), &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; is assumed to be &lt;code&gt;8&lt;/code&gt; (octal) or &lt;code&gt;10&lt;/code&gt; (decimal). Exactly which radix is chosen is implementation-dependent. ECMAScript 5 clarifies that &lt;code&gt;10&lt;/code&gt; (decimal) &lt;em&gt;should&lt;/em&gt; be used, but not all browsers support this yet. For this reason, &lt;strong&gt;always specify a &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; when using &lt;code&gt;parseInt&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 &quot; &lt;code&gt;0&lt;/code&gt; &quot;(0)으로 시작 하는 경우 &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 는 &lt;code&gt;8&lt;/code&gt; (8 진수) 또는 &lt;code&gt;10&lt;/code&gt; (10 진수)으로 간주됩니다 . 정확히 어떤 기수가 선택되는지는 구현에 따라 다릅니다. ECMAScript 5는 &lt;code&gt;10&lt;/code&gt; (십진수)을 &lt;em&gt;사용해야한다고&lt;/em&gt; 명시하지만 모든 브라우저가 아직이를 지원하지는 않습니다. 이러한 이유로 &lt;strong&gt; &lt;code&gt;parseInt&lt;/code&gt; 를&lt;/strong&gt;&lt;strong&gt; 사용할 때는 &lt;/strong&gt;&lt;strong&gt;항상 &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 지정하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="85d899c9908f1b8511a58cfbfbbc6efdff187932" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with &quot;&lt;code&gt;0x&lt;/code&gt;&quot; or &quot;&lt;code&gt;0X&lt;/code&gt;&quot; (a zero, followed by lowercase or uppercase X), &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; is assumed to be &lt;code&gt;16&lt;/code&gt; and the rest of the string is parsed as a hexidecimal number.</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 &quot; &lt;code&gt;0x&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;0X&lt;/code&gt; &quot;(0 다음에 소문자 또는 대문자 X)로 시작하면 &lt;code&gt;&lt;var&gt;radix&lt;/var&gt;&lt;/code&gt; 는 &lt;code&gt;16&lt;/code&gt; 으로 간주됩니다. 나머지 문자열은 16 진수로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="7391a0c805a3a7880ff98c62370413cf4a99a3c4" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with any other value, the radix is 10 (decimal).</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 다른 값으로 시작하면 기수가 10 (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="d48b16e0cf301f14341f3f7bd0a5ddc3c6245fa4" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;string&lt;/code&gt; begins with any other value, the radix is &lt;code&gt;10&lt;/code&gt; (decimal).</source>
          <target state="translated">입력 &lt;code&gt;string&lt;/code&gt; 이 다른 값으로 시작하는 경우 기수는 &lt;code&gt;10&lt;/code&gt; (10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="d8f0eb6abc2d809f6720afec4140ffa6145e1b16" translate="yes" xml:space="preserve">
          <source>If the iterable contains one or more non-promise value and/or an already resolved/rejected promise, then &lt;code&gt;Promise.race&lt;/code&gt; will resolve to the first of these values found in the array:</source>
          <target state="translated">iterable에 하나 이상의 비 약속 값 및 / 또는 이미 해결 / 거절 된 약속이 포함 된 경우 &lt;code&gt;Promise.race&lt;/code&gt; 는 배열에서 찾은 다음 값 중 첫 번째 값으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="42bb8061af2674b09d2e81c3c794c84558b5c8c1" translate="yes" xml:space="preserve">
          <source>If the iterable contains one or more non-promise value and/or an already resolved/rejected promise, then &lt;code&gt;Promise.race&lt;/code&gt; will resolve to the first of these values found in the iterable.</source>
          <target state="translated">iterable에 하나 이상의 비 약속 값 및 / 또는 이미 해결 / 거절 된 약속이 포함 된 경우 &lt;code&gt;Promise.race&lt;/code&gt; 는 iterable에서 찾은 첫 번째 값으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="eba5348fb21f253314c74035ef8a94d981d39d85" translate="yes" xml:space="preserve">
          <source>If the iterable contains one or more non-promise value and/or an already settled promise, then &lt;code&gt;Promise.race&lt;/code&gt; will resolve to the first of these values found in the array:</source>
          <target state="translated">iterable에 하나 이상의 비 약속 값 및 / 또는 이미 확정 된 약속이 포함 된 경우 &lt;code&gt;Promise.race&lt;/code&gt; 는 배열에서 찾은 다음 값 중 첫 번째 값으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="8455736e47a9a384da44aad6c284be518f32649f" translate="yes" xml:space="preserve">
          <source>If the iterable contains one or more non-promise value and/or an already settled promise, then &lt;code&gt;Promise.race&lt;/code&gt; will resolve to the first of these values found in the iterable.</source>
          <target state="translated">iterable에 하나 이상의 비 약속 값 및 / 또는 이미 확정 된 약속이 포함 된 경우 &lt;code&gt;Promise.race&lt;/code&gt; 는 iterable에서 찾은 이러한 값 중 첫 번째 값으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="133cdb90b6400a76c679993e7493ba162315d6a4" translate="yes" xml:space="preserve">
          <source>If the iterable passed is empty, the promise returned will be forever pending.</source>
          <target state="translated">전달 된 iterable이 비어 있으면 리턴 된 약속은 영원히 보류됩니다.</target>
        </trans-unit>
        <trans-unit id="5929c9470016412d62a0f7f3f9a21acab412f404" translate="yes" xml:space="preserve">
          <source>If the match fails, the &lt;code&gt;exec()&lt;/code&gt; method returns &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, and sets &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">일치가 실패하면 &lt;code&gt;exec()&lt;/code&gt; 메서드는 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 을&lt;/a&gt; 반환 하고 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fed5bcc169dd3c7fb57fbf0f3eae42cda09790da" translate="yes" xml:space="preserve">
          <source>If the match fails, the &lt;code&gt;exec()&lt;/code&gt; method returns &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일치에 실패하면 &lt;code&gt;exec()&lt;/code&gt; 메소드는 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 을&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="992c9b88d4c619e867d5faf6f752e55dcfba43d1" translate="yes" xml:space="preserve">
          <source>If the match succeeds, the &lt;code&gt;exec()&lt;/code&gt; method returns an array (with extra properties &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt;; see below) and updates the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property of the regular expression object. The returned array has the matched text as the first item, and then one item for each parenthetical capture group of the matched text.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;exec()&lt;/code&gt; 메서드는 배열 (추가 속성 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;input&lt;/code&gt; , 아래 참조)을 반환하고 정규식 객체 의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성을 업데이트 합니다. 반환 된 배열에는 첫 번째 항목으로 일치하는 텍스트가 있고 일치하는 텍스트의 각 괄호 캡처 그룹에 대해 하나의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad048d5802a4482d98378bb3e60f9d8891c84dff" translate="yes" xml:space="preserve">
          <source>If the match succeeds, the &lt;code&gt;exec()&lt;/code&gt; method returns an array and updates properties of the regular expression object. The returned array has the matched text as the first item, and then one item for each capturing parenthesis that matched containing the text that was captured.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;exec()&lt;/code&gt; 메서드는 배열을 반환하고 정규식 객체의 속성을 업데이트합니다. 반환 된 배열에는 일치하는 텍스트가 첫 번째 항목으로 지정된 다음 캡처 된 텍스트를 포함하는 일치하는 각 캡처 괄호에 대해 하나의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b04d89d7ced98dfbbede5881b9b567808008e8" translate="yes" xml:space="preserve">
          <source>If the method is a function in &lt;a href=&quot;../../strict_mode&quot;&gt;non-strict mode&lt;/a&gt;, &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; will be replaced with the global object, and primitive values will be converted to objects.</source>
          <target state="translated">상기 방법은 함수의 경우 &lt;a href=&quot;../../strict_mode&quot;&gt;비 엄격 모드&lt;/a&gt; , &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 전역 객체로 대체 될 것이며, 기본 값은 오브젝트로 변환한다.</target>
        </trans-unit>
        <trans-unit id="d74a4cb5fa65d9b34a16e5d974e6dcf978094959" translate="yes" xml:space="preserve">
          <source>If the number is greater than 1e+21 (including) or less than 1e-7 (including), it will return &lt;code&gt;1&lt;/code&gt;. (when using radix 10).</source>
          <target state="translated">숫자가 1e + 21 (포함)보다 크거나 1e-7 (포함)보다 작 으면 &lt;code&gt;1&lt;/code&gt; 을 반환합니다. 합니다. (기수 10을 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="076b090beef22f90ac6afa326097c3fb2ace6350" translate="yes" xml:space="preserve">
          <source>If the object is sealed/frozen then the change has no effect and no exception is thrown:</source>
          <target state="translated">객체가 봉인 / 고정 된 경우 변경 사항이 적용되지 않으며 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea7372e8703a5521adb89c3b333094c42fd39770" translate="yes" xml:space="preserve">
          <source>If the only argument passed to the &lt;code&gt;Array&lt;/code&gt; constructor is an integer between 0 and 2&lt;sup&gt;32&lt;/sup&gt;-1 (inclusive), this returns a new JavaScript array with its &lt;code&gt;length&lt;/code&gt; property set to that number (&lt;strong&gt;Note:&lt;/strong&gt; this implies an array of &lt;code&gt;arrayLength&lt;/code&gt; empty slots, not slots with actual &lt;code&gt;undefined&lt;/code&gt; values). If the argument is any other number, a &lt;a href=&quot;rangeerror&quot;&gt;&lt;code&gt;RangeError&lt;/code&gt;&lt;/a&gt; exception is thrown.</source>
          <target state="translated">에 전달되는 유일한 인수하는 경우 &lt;code&gt;Array&lt;/code&gt; 생성자는 0과 2 사이의 정수 &lt;sup&gt;(32)&lt;/sup&gt; -1 (포함), 그와 함께 새로운 자바 스크립트 배열이 반환 &lt;code&gt;length&lt;/code&gt; 그 수 (에 속성 집합 &lt;strong&gt;: 참고&lt;/strong&gt; 이의 배열을 의미한다 &lt;code&gt;arrayLength&lt;/code&gt; 빈 슬롯을하지 않음 실제 &lt;code&gt;undefined&lt;/code&gt; 값이있는 슬롯 ). 인수가 다른 숫자이면 &lt;a href=&quot;rangeerror&quot;&gt; &lt;code&gt;RangeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3de7d3547772b56e44d561daed2b5f4e5c0051e3" translate="yes" xml:space="preserve">
          <source>If the operation fails, the promise rejects with a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;WebAssembly.CompileError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;linkerror&quot;&gt;&lt;code&gt;WebAssembly.LinkError&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;WebAssembly.RuntimeError&lt;/code&gt;&lt;/a&gt;, depending on the cause of the failure.</source>
          <target state="translated">작업이 실패하면 약속은 실패 원인에 따라 &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;WebAssembly.CompileError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;linkerror&quot;&gt; &lt;code&gt;WebAssembly.LinkError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;WebAssembly.RuntimeError&lt;/code&gt; 로&lt;/a&gt; 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7ae6267575070773ce0e34354913d3b4cb253db" translate="yes" xml:space="preserve">
          <source>If the parameter cannot be converted to a number, or it is &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;not-a-number&lt;/a&gt; (&lt;code&gt;NaN&lt;/code&gt;), &lt;code&gt;Math.fround()&lt;/code&gt; will return &lt;code&gt;NaN&lt;/code&gt;:</source>
          <target state="translated">매개 변수를 숫자로 변환 할 수 없거나 숫자가 &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;아닌&lt;/a&gt; ( &lt;code&gt;NaN&lt;/code&gt; ) 경우 &lt;code&gt;Math.fround()&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a4cb915c64d1dc820b0c684cdac48718bd6a3e1d" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, &lt;code&gt;delete&lt;/code&gt; will not have any effect and will return &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">삭제하려는 속성이 존재하지 않으면 &lt;code&gt;delete&lt;/code&gt; 는 아무런 영향을 미치지 않으며 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9571ccb67395bfe77750e491cdef9006177ddfa8" translate="yes" xml:space="preserve">
          <source>If the property which you are trying to delete does not exist, &lt;code&gt;delete&lt;/code&gt; will not have any effect and will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">삭제하려는 속성이 존재하지 않으면 &lt;code&gt;delete&lt;/code&gt; 는 아무런 영향을주지 않으며 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="928fd5633160fac29d5cef2872c5f9bc821a1144" translate="yes" xml:space="preserve">
          <source>If the regex has the global flag set, &lt;code&gt;test()&lt;/code&gt; will advance the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; of the regex. A subsequent use of &lt;code&gt;test()&lt;/code&gt; will start the search at the substring of &lt;code&gt;str&lt;/code&gt; specified by &lt;code&gt;lastIndex&lt;/code&gt; (&lt;a href=&quot;exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; will also advance the &lt;code&gt;lastIndex&lt;/code&gt; property). It is worth noting that the &lt;code&gt;lastIndex&lt;/code&gt; will not reset when testing a different string.</source>
          <target state="translated">정규식에 전역 플래그가 설정되어 있으면 &lt;code&gt;test()&lt;/code&gt; 는 정규식 의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 를 진행시킵니다 . 나중에 &lt;code&gt;test()&lt;/code&gt; 하면 &lt;code&gt;lastIndex&lt;/code&gt; 에 의해 지정된 &lt;code&gt;str&lt;/code&gt; 의 하위 문자열에서 검색이 시작 됩니다 ( &lt;a href=&quot;exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 도 &lt;code&gt;lastIndex&lt;/code&gt; 속성을 진행시킵니다 ). 그것은 것을 주목할 가치가있다 &lt;code&gt;lastIndex&lt;/code&gt; 속성은 다른 문자열을 테스트 할 때 재설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54e623d784ebb3ca9ec36dc663b3600d3fafdecc" translate="yes" xml:space="preserve">
          <source>If the regular expression does not include the &lt;code&gt;g&lt;/code&gt; flag, &lt;code&gt;str.match()&lt;/code&gt; will return the same result as &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정규식에 &lt;code&gt;g&lt;/code&gt; 플래그가 포함되지 않은 경우 &lt;code&gt;str.match()&lt;/code&gt; 는 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ce0d349d09340572916f1b2c5d1d97584f2175f9" translate="yes" xml:space="preserve">
          <source>If the regular expression does not include the &lt;code&gt;g&lt;/code&gt; flag, &lt;code&gt;str.match()&lt;/code&gt; will return the same result as &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt;. The returned &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; has an extra &lt;code&gt;input&lt;/code&gt; property, which contains the original string that was parsed. In addition, it has an &lt;code&gt;index&lt;/code&gt; property, which represents the zero-based index of the match in the string.</source>
          <target state="translated">정규식에 &lt;code&gt;g&lt;/code&gt; 플래그가 포함되지 않은 경우 &lt;code&gt;str.match()&lt;/code&gt; 는 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 . 반환 된 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 에는 구문 분석 된 원래 문자열이 포함 된 추가 &lt;code&gt;input&lt;/code&gt; 속성이 있습니다. 또한 문자열에 일치하는 인덱스 (0부터 시작)를 나타내는 &lt;code&gt;index&lt;/code&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="30138364a3c3af0aa6191de310201697ce047a82" translate="yes" xml:space="preserve">
          <source>If the regular expression includes the &lt;code&gt;g&lt;/code&gt; flag, the method returns an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing all matched substrings rather than match objects. Captured groups are not returned. If there were no matches, the method returns &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정규 표현식에 &lt;code&gt;g&lt;/code&gt; 플래그가 포함 된 경우, 메소드는 일치 오브젝트가 아닌 일치하는 모든 서브 스트링을 포함 하는 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 리턴 합니다. 캡처 한 그룹은 반환되지 않습니다. 일치하는 것이 없으면 메서드는 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8b959552ef94320337e1ed0aeb1c7362f749576d" translate="yes" xml:space="preserve">
          <source>If the returned promise resolves, it is resolved with an aggregating array of the values from the resolved promises, in the same order as defined in the iterable of multiple promises.</source>
          <target state="translated">반환 된 프라 미스가 해결되면 여러 프라 미스의 반복 가능에 정의 된 순서와 동일한 순서로 해결 된 프라 미스에서 값의 집계 배열로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="9aad8e2f8495619d7aae6f0803f38d9b68950bdc" translate="yes" xml:space="preserve">
          <source>If the returned promise resolves, it is resolved with the value of the first promise in the iterable that resolved.</source>
          <target state="translated">반환 된 promise가 해결되면 해결 된 iterable의 첫 번째 promise 값으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="a177c490157a79f5a76e27fe6956e99555e128cb" translate="yes" xml:space="preserve">
          <source>If the selected language tag had a Unicode extension substring, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the language tag. For example, the &quot;&lt;code&gt;co&lt;/code&gt;&quot; key (collation) is only supported by &lt;a href=&quot;intl/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt;, and its &quot;&lt;code&gt;phonebk&lt;/code&gt;&quot; value is only supported for German.</source>
          <target state="translated">선택한 언어 태그에 유니 코드 확장 하위 문자열이있는 경우 해당 확장은 이제 생성 된 개체 또는 함수의 동작을 사용자 지정하는 데 사용됩니다. 각 생성자 또는 함수는 유니 코드 확장에 대해 정의 된 키의 하위 집합 만 지원하며 지원되는 값은 종종 언어 태그에 따라 다릅니다. 예를 들어 &quot; &lt;code&gt;co&lt;/code&gt; &quot;키 ( &lt;code&gt;phonebk&lt;/code&gt; )는 &lt;a href=&quot;intl/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 에서만 지원되고 &quot; phonebk &quot;값은 독일어에 대해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="52e0cd12612909bf0c4a612be8384c6d969c9ac4" translate="yes" xml:space="preserve">
          <source>If the selected language tag had a Unicode extension substring, that extension is now used to customize the constructed object or the behavior of the function. Each constructor or function supports only a subset of the keys defined for the Unicode extension, and the supported values often depend on the language tag. For example, the &lt;code&gt;&quot;co&quot;&lt;/code&gt; key (collation) is only supported by &lt;a href=&quot;collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt;, and its &lt;code&gt;&quot;phonebk&quot;&lt;/code&gt; value is only supported for German.</source>
          <target state="translated">선택한 언어 태그에 유니 코드 확장 하위 문자열이있는 경우 해당 확장은 이제 생성 된 객체 또는 함수의 동작을 사용자 정의하는 데 사용됩니다. 각 생성자 또는 함수는 유니 코드 확장에 대해 정의 된 키의 하위 집합 만 지원하며 지원되는 값은 종종 언어 태그에 따라 다릅니다. 예를 들어, &lt;code&gt;&quot;co&quot;&lt;/code&gt; 키 (데이터 정렬)에서만 지원됩니다 &lt;a href=&quot;collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; , 그 &lt;code&gt;&quot;phonebk&quot;&lt;/code&gt; 값은 독일어로만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0051f2f9e3b0c3c5f0efed5769af9ea4eeaaac1c" translate="yes" xml:space="preserve">
          <source>If the separator is an array, then that Array is coerced to a String and used as a separator.</source>
          <target state="translated">구분자가 배열이면 해당 배열은 문자열로 강제 변환되어 구분자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b286f7a3b45c9d956b26ab348a1958c44fb5f42" translate="yes" xml:space="preserve">
          <source>If the source array is a typed array, the two arrays may share the same underlying &lt;a href=&quot;../arraybuffer&quot;&gt;&lt;code&gt;ArrayBuffer&lt;/code&gt;&lt;/a&gt;; the JavaScript engine will intelligently &lt;strong&gt;copy&lt;/strong&gt; the source range of the buffer to the destination range.</source>
          <target state="translated">소스 배열이 형식화 된 배열 인 경우 두 배열은 동일한 기본 &lt;a href=&quot;../arraybuffer&quot;&gt; &lt;code&gt;ArrayBuffer&lt;/code&gt; 를&lt;/a&gt; 공유 할 수 있습니다 . JavaScript 엔진은 버퍼의 소스 범위를 대상 범위에 지능적으로 &lt;strong&gt;복사&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b353db1fb14273700c08d890316bc02b3fd861ed" translate="yes" xml:space="preserve">
          <source>If the source value is a reference to an object, it only copies the reference value.</source>
          <target state="translated">원본 값이 개체에 대한 참조이면 참조 값만 복사합니다.</target>
        </trans-unit>
        <trans-unit id="6a4ef9aab8e43c2b5e9c78c499c653ff6b14a42f" translate="yes" xml:space="preserve">
          <source>If the specified number of elements to insert differs from the number of elements being removed, the array's &lt;code&gt;length&lt;/code&gt; will be changed.</source>
          <target state="translated">삽입 할 지정된 요소 수가 제거되는 요소 수와 다른 경우 배열의 &lt;code&gt;length&lt;/code&gt; 가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="11118b48f62c5ceba27585b77797df31fab20d6a" translate="yes" xml:space="preserve">
          <source>If the string matches the expression, it will return an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing the entire matched string as the first element, followed by any results captured in parentheses. If there were no matches, &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">문자열이 식과 일치하면 일치하는 전체 문자열이 첫 번째 요소로 포함 된 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 과 괄호로 묶은 결과 가 반환 됩니다. 일치하는 것이 없으면 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8df86ca042f37da0bf772e9d1368d49d51710bb8" translate="yes" xml:space="preserve">
          <source>If the string you're calling &lt;code&gt;eval()&lt;/code&gt; on contains data (for example, an array: &lt;code&gt;&quot;[1, 2, 3]&quot;&lt;/code&gt;), as opposed to code, you should consider switching to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt;, which allows the string to use a subset of JavaScript syntax to represent data. See also &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Downloading_JSON_and_JavaScript_in_extensions&quot;&gt;Downloading JSON and JavaScript in extensions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 을 호출하는 문자열 에 코드와 달리 데이터가 포함 된 경우 (예 : 배열 : &lt;code&gt;&quot;[1, 2, 3]&quot;&lt;/code&gt; ) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON으로&lt;/a&gt; 전환 하여 문자열을 사용할 수 있도록해야합니다. 데이터를 나타내는 JavaScript 구문의 하위 집합입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Downloading_JSON_and_JavaScript_in_extensions&quot;&gt;확장에서 JSON 및 JavaScript 다운로드&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7e003732737f7eeca987515a181e7a6c0886873" translate="yes" xml:space="preserve">
          <source>If the target object is not extensible, then the result List must contain all the keys of the own properties of the target object and no other values.</source>
          <target state="translated">대상 개체를 확장 할 수 없으면 결과 목록에 대상 개체의 고유 속성에 대한 모든 키가 포함되고 다른 값은 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="e848b7dd6ac3915d3833ea99453aeb25eaa52820" translate="yes" xml:space="preserve">
          <source>If the target value is an integer, return &lt;code&gt;true&lt;/code&gt;, otherwise return &lt;code&gt;false&lt;/code&gt;. If the value is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;false&lt;/code&gt;. The method will also return &lt;code&gt;true&lt;/code&gt; for floating point numbers that can be represented as integer.</source>
          <target state="translated">대상 값이 정수 &lt;code&gt;true&lt;/code&gt; 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 값이 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 이 메서드는 정수로 표현할 수있는 부동 소수점 숫자에 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="bdd4f6c5189b324bbcf046826b6268c8f7662e9b" translate="yes" xml:space="preserve">
          <source>If the target value is an integer, return &lt;code&gt;true&lt;/code&gt;, otherwise return &lt;code&gt;false&lt;/code&gt;. If the value is &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; or infinite, return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">대상 값이 정수 &lt;code&gt;true&lt;/code&gt; 반환 하고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 값이 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 또는 무한이면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3b163d07b932ce80b4a6e15721f922f7fb30650e" translate="yes" xml:space="preserve">
          <source>If the typed array is empty and no &lt;code&gt;initialValue &lt;/code&gt;was provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; would be thrown. If the typed array has only one element (regardless of position) and no &lt;code&gt;initialValue &lt;/code&gt;was provided, or if &lt;code&gt;initialValue&lt;/code&gt; is provided but the typed array is empty, the solo value would be returned without calling &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">유형이 지정된 배열이 비어 있고 &lt;code&gt;initialValue &lt;/code&gt; 가 제공 되지 않은 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 형식화 된 배열에 위치에 관계없이 하나의 요소 만 있고 &lt;code&gt;initialValue &lt;/code&gt; 가 제공 되지 않았 거나 &lt;code&gt;initialValue&lt;/code&gt; 가 제공되었지만 형식화 된 배열이 비어있는 경우 &lt;code&gt;callback&lt;/code&gt; 을 호출하지 않고 솔로 값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="32f1892613c48627e71e01cfec6b0670419135f0" translate="yes" xml:space="preserve">
          <source>If the typed array is empty and no &lt;code&gt;initialValue&lt;/code&gt; was provided, &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; would be thrown. If the typed array has only one element (regardless of position) and no &lt;code&gt;initialValue&lt;/code&gt; was provided, or if &lt;code&gt;initialValue&lt;/code&gt; is provided but the typed array is empty, the solo value would be returned without calling &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">유형이 지정된 배열이 비어 있고 &lt;code&gt;initialValue&lt;/code&gt; 가 제공 되지 않은 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 형식화 된 배열에 위치에 관계없이 하나의 요소 만 있고 &lt;code&gt;initialValue&lt;/code&gt; 가 제공 되지 않았 거나 &lt;code&gt;initialValue&lt;/code&gt; 가 제공되었지만 형식화 된 배열이 비어있는 경우 &lt;code&gt;callback&lt;/code&gt; 을 호출하지 않고 솔로 값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="510bd268f45e4d1729f707209afb02f9c7b0083d" translate="yes" xml:space="preserve">
          <source>If the value has a &lt;a href=&quot;#toJSON()_behavior&quot;&gt;toJSON()&lt;/a&gt; method, it's responsible to define what data will be serialized.</source>
          <target state="translated">값에 &lt;a href=&quot;#toJSON()_behavior&quot;&gt;toJSON ()&lt;/a&gt; 메소드 가있는 경우 직렬화 할 데이터를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e00674da0b18b7b91ffb49a53cd9a91a4d73a00f" translate="yes" xml:space="preserve">
          <source>If the value has a &lt;code&gt;&lt;a href=&quot;#toJSON_behavior&quot;&gt;toJSON()&lt;/a&gt;&lt;/code&gt; method, it's responsible to define what data will be serialized.</source>
          <target state="translated">값에 &lt;code&gt;&lt;a href=&quot;#toJSON_behavior&quot;&gt;toJSON()&lt;/a&gt;&lt;/code&gt; 메서드 가있는 경우 직렬화 할 데이터를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="54140dc9eb589e0c204678e22bbbdb9cf79a2d04" translate="yes" xml:space="preserve">
          <source>If the value is &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, it will create and return an empty object.</source>
          <target state="translated">값이 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 인 경우 빈 개체를 만들고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="561c9acef125c9f472e17089eda2c02ed61b2c26" translate="yes" xml:space="preserve">
          <source>If the value is a string and first character cannot be converted to a number, &lt;code&gt;parseFloat&lt;/code&gt; returns &lt;a href=&quot;nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값이 문자열이고 첫 번째 문자를 숫자로 변환 할 수 없으면 &lt;code&gt;parseFloat&lt;/code&gt; 는 &lt;a href=&quot;nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 을 반환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ef9bb279e649c6b04963f948bf7ce36a932c8c2d" translate="yes" xml:space="preserve">
          <source>If the value is an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; is returned; otherwise, &lt;code&gt;false&lt;/code&gt; is.</source>
          <target state="translated">값이 &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53a1da54003d5163c28e486b08412caa8da3e737" translate="yes" xml:space="preserve">
          <source>If the value is an object already, it will return the value.</source>
          <target state="translated">값이 이미 객체이면 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1640abfaf088fbcbdcadda1eedf8dab180bb6242" translate="yes" xml:space="preserve">
          <source>If the value is not a &lt;code&gt;Promise&lt;/code&gt;, it converts the value to a resolved &lt;code&gt;Promise&lt;/code&gt;, and waits for it.</source>
          <target state="translated">값이 &lt;code&gt;Promise&lt;/code&gt; 가 아닌 경우 값을 확인 된 &lt;code&gt;Promise&lt;/code&gt; 로 변환 하고 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f0a64651c26d9a65bc75cc4516d6f569cc7361ac" translate="yes" xml:space="preserve">
          <source>If the value is omitted, &lt;code&gt;undefined&lt;/code&gt; is returned instead.</source>
          <target state="translated">값을 생략하면 &lt;code&gt;undefined&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea4c0759ce10f3ec998abec7f06323cfdcb044e" translate="yes" xml:space="preserve">
          <source>If the value isn't needed just now. It will be used later, or in some case it's not used at all.</source>
          <target state="translated">값이 지금 필요하지 않은 경우. 나중에 사용되거나 어떤 경우에는 전혀 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcd7892bd313c45ff27bee53ccf94aa493673289" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is 0, the return value is always &lt;a href=&quot;../number/negative_infinity&quot;&gt;&lt;code&gt;-Infinity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 의 값 이 0이면 반환 값은 항상 &lt;a href=&quot;../number/negative_infinity&quot;&gt; &lt;code&gt;-Infinity&lt;/code&gt; 입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4f9318ece72f4c2eeef6e7c2a93aef5af0daf69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is less than 0, the return value is always &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 값 이 0보다 작 으면 반환 값은 항상 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1239996883a93b9b2c50ccbd8a405e2eb8177812" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is negative, &lt;code&gt;Math.sqrt()&lt;/code&gt; returns &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 값 이 음수이면 &lt;code&gt;Math.sqrt()&lt;/code&gt; 는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 을 반환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="059376bc4439a5267686d0fa5d49aac6a927f1ff" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; is negative, the return value is always &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 값 이 음수이면 반환 값은 항상 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac2d5fb2a300d0369ab4234e82cc168cc8762ee4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;x&lt;/code&gt; is less than -1, the return value is always &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 이 -1보다 작은 경우 반환 값은 항상 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9274a7a137b577eeaa2f04b6902d872eb4466cee" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;x&lt;/code&gt; is less than 0, the return value is always &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 이 0보다 작은 경우 반환 값은 항상 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9eb70669a6e170dc1e8ae977b8cb8a15a0498f1" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;x&lt;/code&gt; is negative, &lt;code&gt;Math.sqrt()&lt;/code&gt; returns &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 이 음수이면 &lt;code&gt;Math.sqrt()&lt;/code&gt; 는 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; 을 반환&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6dbda7783aa9232721a5872c34710ccbbff0ffb5" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;x&lt;/code&gt; is negative, the return value is always &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 이 음수이면 반환 값은 항상 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c96df6c0dbc7425e0d4c9a6c302f795ee1fc7c1" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;em&gt;expression&lt;/em&gt; following the &lt;code&gt;await&lt;/code&gt; operator is not a &lt;code&gt;Promise&lt;/code&gt;, it's converted to a &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;resolved Promise&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; 연산자 다음 의 &lt;em&gt;표현식&lt;/em&gt; 값이 &lt;code&gt;Promise&lt;/code&gt; 가 아닌 경우 , &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;해결 된 Promise&lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7777a3173c1fc93619bfe4928f7864e3ee37ca7e" translate="yes" xml:space="preserve">
          <source>If there is a constructor present in the subclass, it needs to first call super() before using &quot;this&quot;.</source>
          <target state="translated">서브 클래스에 생성자가 있으면 &quot;this&quot;를 사용하기 전에 먼저 super ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="21978f541a285d4f0f6b8649673a45e9d8c65652" translate="yes" xml:space="preserve">
          <source>If there is no element at the specified position, &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is returned. If no UTF-16 surrogate pair begins at &lt;code&gt;&lt;var&gt;pos&lt;/var&gt;&lt;/code&gt;, the code unit at &lt;code&gt;&lt;var&gt;pos&lt;/var&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 위치에 요소가 없으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 반환됩니다. 더 UTF-16 서로 게이트 쌍에서 시작하지 않는 경우 &lt;code&gt;&lt;var&gt;pos&lt;/var&gt;&lt;/code&gt; ,의 코드 단위 &lt;code&gt;&lt;var&gt;pos&lt;/var&gt;&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="73a5e90cc482f2c146104da9fc8a32ddba669924" translate="yes" xml:space="preserve">
          <source>If there is no element at the specified position, &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; is returned. If no UTF-16 surrogate pair begins at &lt;code&gt;pos&lt;/code&gt;, the code unit at &lt;code&gt;pos&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 위치에 요소가 없으면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 가 반환됩니다. 더 UTF-16 서로 게이트 쌍에서 시작하지 않는 경우 &lt;code&gt;pos&lt;/code&gt; ,의 코드 단위 &lt;code&gt;pos&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="afdb33990e63ce9b5d36a9e521b9b2dbdc06c9d9" translate="yes" xml:space="preserve">
          <source>If this is a &lt;code&gt;Number&lt;/code&gt;, it indicates the number of space characters to use as white space; this number is capped at 10 (if it is greater, the value is just &lt;code&gt;10&lt;/code&gt;). Values less than 1 indicate that no space should be used.</source>
          <target state="translated">이것이 &lt;code&gt;Number&lt;/code&gt; 이면 공백으로 사용할 공백 문자 수를 나타냅니다. 이 숫자는 10으로 제한됩니다 (더 큰 경우 값은 &lt;code&gt;10&lt;/code&gt; 임). 1보다 작은 값은 사용 된 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4657fbccd094cf1a6aae2b07836eaa2e143cf7da" translate="yes" xml:space="preserve">
          <source>If this is a &lt;code&gt;String&lt;/code&gt;, the string (or the first 10 characters of the string, if it's longer than that) is used as white space. If this parameter is not provided (or is &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;), no white space is used.</source>
          <target state="translated">이것이 &lt;code&gt;String&lt;/code&gt; 이면 문자열 (또는 그보다 긴 경우 문자열의 처음 10 자)이 공백으로 사용됩니다. 이 매개 변수가 제공되지 않거나 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 인 경우&lt;/a&gt; 공백이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fe1411948efd2142af6ac7caf00bbd4cd925703" translate="yes" xml:space="preserve">
          <source>If this method is invoked on an object that is not a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 객체에 호출하면 그건 아닙니다 &lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe15855eb8f13ceac6922262bfec88886e019764" translate="yes" xml:space="preserve">
          <source>If used immediately after any of the quantifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, or &lt;code&gt;{}&lt;/code&gt;, makes the quantifier non-greedy (matching the minimum number of times), as opposed to the default, which is greedy (matching the maximum number of times).</source>
          <target state="translated">수량 지시의 직후에 사용하면 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , 또는 &lt;code&gt;{}&lt;/code&gt; 은 욕심 인 (최대 횟수와 일치하는) 기본값과 달리 수량자를 욕심없는 (최소 횟수와 일치하는) 것으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9fd706dc1d0360b94ec21dbf8552ac9d5f3e383e" translate="yes" xml:space="preserve">
          <source>If used postfix (for example, x--), then it returns the value before decrementing.</source>
          <target state="translated">접미사 (예 : x--)를 사용하면 감소하기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de1231f0f16dedb361c482a319c20aff31b05c5e" translate="yes" xml:space="preserve">
          <source>If used postfix, with operator after operand (for example, x++), then it returns the value before incrementing.</source>
          <target state="translated">피연산자 뒤에 연산자 (예 : x ++)와 함께 접미사를 사용하면 증분하기 전에 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6e40e35ce4cf016961cce9be2454b86125ceb4b" translate="yes" xml:space="preserve">
          <source>If used prefix (for example, --x), then it returns the value after decrementing.</source>
          <target state="translated">접두사 (예 : --x)를 사용하면 감소 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9df9321ebb8182da95c82368fad1cd967b2ab528" translate="yes" xml:space="preserve">
          <source>If used prefix with operator before operand (for example, ++x), then it returns the value after incrementing.</source>
          <target state="translated">피연산자 앞에 연산자와 함께 접두사를 사용하면 (예 : ++ x) 증분 후 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7ff4cc4432ffc5f89ff00a0952d717a8a1a68b0" translate="yes" xml:space="preserve">
          <source>If we rewrite the above using traditional function-based syntax in non&amp;ndash;strict mode, then &lt;code&gt;this&lt;/code&gt; method calls are automatically bound to the initial &lt;code&gt;this&lt;/code&gt; value, which by default is the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Global_object&quot;&gt;global object&lt;/a&gt;. In strict mode, autobinding will not happen; the value of &lt;code&gt;this&lt;/code&gt; remains as passed.</source>
          <target state="translated">엄격하지 않은 모드에서 전통적인 함수 기반 구문을 사용하여 위를 다시 작성하면 &lt;code&gt;this&lt;/code&gt; 메서드 호출은 기본적으로 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Global_object&quot;&gt;전역 객체 인&lt;/a&gt; 초기 &lt;code&gt;this&lt;/code&gt; 값에 자동으로 바인딩됩니다 . 엄격 모드에서는 자동 바인딩이 발생하지 않습니다. 값 &lt;code&gt;this&lt;/code&gt; 전달로 남아있다.</target>
        </trans-unit>
        <trans-unit id="263dbd217b7b782c539a10e8e47d0cd7d0c685a1" translate="yes" xml:space="preserve">
          <source>If we want to calculate the height of an equalateral triangle, and we know its side length is 100, we can use the formulae &lt;em&gt;length of the adjacent multiplied by the tangent of the angle is equal to the opposite.&lt;/em&gt;</source>
          <target state="translated">등각 삼각형의 높이를 계산하고 그 변의 길이가 100이라는 것을 알고 있다면, 우리는 &lt;em&gt;각도의 탄젠트를 곱한 인접의 길이가 반대와 같다는&lt;/em&gt; 공식을 사용할 수 있습니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44416e4cb440058b3e2168092fa043d526ea6bd6" translate="yes" xml:space="preserve">
          <source>If we want to export a single value or to have a fallback value for our module, we could use a default export:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 폴백 값을 가지려면 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ced299cf7385e721622ed81fc4d2edb2bdf9e3" translate="yes" xml:space="preserve">
          <source>If we want to export a single value or to have a fallback value for your module, you could use a default export:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 대한 대체 값을 가지려면 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1e42279903ed183e261f8299c80921fedf73370" translate="yes" xml:space="preserve">
          <source>If we want to export default, and star from another module (effectively creating a &quot;redirect&quot;):</source>
          <target state="translated">기본값을 내보내고 다른 모듈에서 별표를 표시하려면 (효과적으로 &quot;리디렉션&quot;작성) :</target>
        </trans-unit>
        <trans-unit id="d6463f6ee85e1b3683452de8f289526c45b1d166" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language (like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt;), it is also easy to mix up the dot operator (&lt;code&gt;.&lt;/code&gt;) and the concatenation operator (&lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt; 와 같은 다른 프로그래밍 언어에서 오는 경우 도트 연산자 ( &lt;code&gt;.&lt;/code&gt; )와 연결 연산자 ( &lt;code&gt;+&lt;/code&gt; )를 쉽게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b266e11ed2f48331bcbc5cd3a2651fd6ea8db942" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language (like &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt;), it is also easy to mix up the dot operator (&lt;code&gt;.&lt;/code&gt;) and the concatenation operator (&lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">다른 프로그래밍 언어 (예 : &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/PHP&quot;&gt;PHP&lt;/a&gt; )를 사용하는 경우 도트 연산자 ( &lt;code&gt;.&lt;/code&gt; )와 연결 연산자 ( &lt;code&gt;+&lt;/code&gt; ) 를 혼동하기 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="bb66cb61a06782782fcf8588e20af249ee21a6b0" translate="yes" xml:space="preserve">
          <source>If you are coming from another programming language, it is also easy to add keywords that don't mean the same or have no meaning at all in JavaScript.</source>
          <target state="translated">다른 프로그래밍 언어를 사용하는 경우 JavaScript에서 전혀 의미가 없거나 전혀 의미가없는 키워드를 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659845dc301670bca252df4853db8e2f3ac23b6a" translate="yes" xml:space="preserve">
          <source>If you are creating an &lt;code&gt;Array&lt;/code&gt;, using the constructor, you probably want to use the literal notation instead, as the first argument is interpreted as the length of the &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">생성자를 사용하여 &lt;code&gt;Array&lt;/code&gt; 를 작성하는 경우 첫 번째 인수가 &lt;code&gt;Array&lt;/code&gt; 의 길이로 해석되므로 리터럴 표기법을 대신 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="0d24793ed02c1f52e768f26367f343405e5dd686" translate="yes" xml:space="preserve">
          <source>If you are executing a match simply to find &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, use &lt;a href=&quot;test&quot;&gt;&lt;code&gt;RegExp.prototype.test()&lt;/code&gt;&lt;/a&gt; method or &lt;a href=&quot;../string/search&quot;&gt;&lt;code&gt;String.prototype.search()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">단순히 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 찾기 위해 일치를 실행하는 경우 &lt;a href=&quot;test&quot;&gt; &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../string/search&quot;&gt; &lt;code&gt;String.prototype.search()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23c1a323209deeb808a2a36b6ad4684b94b02231" translate="yes" xml:space="preserve">
          <source>If you are executing a match simply to find true or false, use the &lt;a href=&quot;test&quot;&gt;&lt;code&gt;RegExp.prototype.test()&lt;/code&gt;&lt;/a&gt; method or the &lt;a href=&quot;../string/search&quot;&gt;&lt;code&gt;String.prototype.search()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">단순히 true 또는 false를 찾기 위해 일치를 실행하는 경우 &lt;a href=&quot;test&quot;&gt; &lt;code&gt;RegExp.prototype.test()&lt;/code&gt; &lt;/a&gt; 메서드 또는 &lt;a href=&quot;../string/search&quot;&gt; &lt;code&gt;String.prototype.search()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68b817fe3ff3a62bc615632f841b38339b8524eb" translate="yes" xml:space="preserve">
          <source>If you are new to JavaScript, start with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;guide&lt;/a&gt;. Once you have a firm grasp of the fundamentals, you can use the &lt;a href=&quot;index&quot;&gt;reference&lt;/a&gt; to get more details on individual objects and language constructs.</source>
          <target state="translated">JavaScript를 처음 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;안내서로&lt;/a&gt; 시작하십시오 . 기본 사항을 제대로 이해 하면 &lt;a href=&quot;index&quot;&gt;참조&lt;/a&gt; 를 사용하여 개별 객체 및 언어 구성에 대한 자세한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a535257a688b66c7fecab217e89655ac1ba3f8dc" translate="yes" xml:space="preserve">
          <source>If you are new to JavaScript, start with the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;guide&lt;/a&gt;. Once you have a firm grasp of the fundamentals, you can use the &lt;a href=&quot;index&quot;&gt;reference&lt;/a&gt; to get more details on individual objects and language constructs.</source>
          <target state="translated">JavaScript를 처음 사용하는 경우 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide&quot;&gt;가이드&lt;/a&gt; 부터 시작하십시오 . 기본 사항을 확실히 이해하면 &lt;a href=&quot;index&quot;&gt;참조&lt;/a&gt; 를 사용하여 개별 개체 및 언어 구성에 대한 자세한 내용을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="613a62f0a62a3e51be50183314f313d624f6bc5b" translate="yes" xml:space="preserve">
          <source>If you are using an older browser that does not yet implement &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../statements/class&quot;&gt;class&lt;/a&gt;&lt;/code&gt;, for example, you should update to a more recent browser version that does support these new language features.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;../statements/let&quot;&gt;let&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../statements/class&quot;&gt;class&lt;/a&gt;&lt;/code&gt; 를 아직 구현하지 않은 이전 브라우저를 사용하는 경우 이러한 새 언어 기능을 지원하는 최신 브라우저 버전으로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c3a9d53d40d1800d714f24dc84a4f4ba306069" translate="yes" xml:space="preserve">
          <source>If you are using function &lt;a href=&quot;../statements/label&quot;&gt;labels&lt;/a&gt;, you will still need to provide a function name after the &lt;code&gt;function&lt;/code&gt; keyword. This doesn't work:</source>
          <target state="translated">함수 &lt;a href=&quot;../statements/label&quot;&gt;레이블&lt;/a&gt; 을 사용하는 경우 &lt;code&gt;function&lt;/code&gt; 키워드 뒤에 함수 이름을 제공해야 합니다. 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77903e97dc13aed96b929fd6a5c838a5b3a347a1" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; in an ECMAScript 5 environment, then the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement will resolve to &lt;code&gt;obj&lt;/code&gt;. However, ECMAScript 2015 introduces a &lt;code&gt;values&lt;/code&gt; property on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; (so that it will be available on every array). So, in a JavaScript environment that supports ECMAScript 2015, the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement could resolve to &lt;code&gt;[1,2,3].values&lt;/code&gt;. However, in this particular example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; has been defined with &lt;code&gt;values&lt;/code&gt; in its &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt;&lt;code&gt;Symbol.unscopables&lt;/code&gt;&lt;/a&gt; object. If it were not, one can see how this would be a difficult issue to debug.</source>
          <target state="translated">ECMAScript 5 환경에서 &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; 를 호출 하면 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 가 &lt;code&gt;obj&lt;/code&gt; 로 확인 됩니다. 그러나 ECMAScript 2015에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;values&lt;/code&gt; 속성이 도입 되어 모든 배열에서 사용할 수 있습니다. 따라서 ECMAScript 2015를 지원하는 JavaScript 환경 에서 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 는 &lt;code&gt;[1,2,3].values&lt;/code&gt; 로 확인할 수 있습니다. 그러나,이 특정 예에서, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로는&lt;/a&gt; 정의 된 &lt;code&gt;values&lt;/code&gt; 그 안에 &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt; &lt;code&gt;Symbol.unscopables&lt;/code&gt; &lt;/a&gt;목적. 그렇지 않은 경우 디버깅하기 어려운 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a590cd4ce738fdd82efe0e9731e381f8954b9061" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; in an ECMAScript 5 environment, then the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement will resolve to &lt;code&gt;obj&lt;/code&gt;. However, ECMAScript 6 introduces a &lt;code&gt;values&lt;/code&gt; property on &lt;a href=&quot;../global_objects/array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; (so that it will be available on every array). So, in a JavaScript environment that supports ECMAScript 6, the &lt;code&gt;values&lt;/code&gt; reference inside the &lt;code&gt;with&lt;/code&gt; statement could resolve to &lt;code&gt;[1,2,3].values&lt;/code&gt;. However, in this particular example, &lt;a href=&quot;../global_objects/array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt; has been defined with &lt;code&gt;values&lt;/code&gt; in its &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt;&lt;code&gt;Symbol.unscopables&lt;/code&gt;&lt;/a&gt; object. If it were not, one can see how this would be a difficult issue to debug.</source>
          <target state="translated">ECMAScript 5 환경에서 &lt;code&gt;f([1,2,3], obj)&lt;/code&gt; 를 호출 하면 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 가 &lt;code&gt;obj&lt;/code&gt; 로 해석됩니다 . 그러나 ECMAScript 6에서는 &lt;a href=&quot;../global_objects/array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;values&lt;/code&gt; 속성을 도입하여 모든 배열에서 사용할 수 있습니다. 따라서 ECMAScript 6을 지원하는 JavaScript 환경 에서 &lt;code&gt;with&lt;/code&gt; 문 내부의 &lt;code&gt;values&lt;/code&gt; 참조 는 &lt;code&gt;[1,2,3].values&lt;/code&gt; 로 해석 될 수 있습니다. 그러나,이 특정 예에서, &lt;a href=&quot;../global_objects/array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로는&lt;/a&gt; 정의 된 &lt;code&gt;values&lt;/code&gt; 그 안에 &lt;a href=&quot;../global_objects/symbol/unscopables&quot;&gt; &lt;code&gt;Symbol.unscopables&lt;/code&gt; &lt;/a&gt;목적. 그렇지 않은 경우 어떻게 디버깅하기 어려운 문제인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c956ed676ebd4cdf0ef2b881c4cdd44209fec2e" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;pop()&lt;/code&gt; on an empty array, it returns &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">빈 배열에서 &lt;code&gt;pop()&lt;/code&gt; 을 호출하면 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 가&lt;/a&gt; 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="982fa524918e289d54b948aa1c92f09ae356ee5c" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;toString()&lt;/code&gt; method on this custom object, it returns the default value inherited from &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 사용자 정의 객체 에서 &lt;code&gt;toString()&lt;/code&gt; 메서드 를 호출하면 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 에서 상속 된 기본값이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d335486efc475b952d22569f82a62a2788b89c6" translate="yes" xml:space="preserve">
          <source>If you choose to use this partial implementation, &lt;strong&gt;you must not rely on those cases where behavior deviates from ECMA-262, 5&lt;sup&gt;th&lt;/sup&gt; edition!&lt;/strong&gt; Thankfully, these deviations from the specification rarely (if ever) come up in most coding situations. If you do not understand any of the deviations from the specification above, then it is safe in this particular case to not worry about these noncompliant deviation details.</source>
          <target state="translated">이 부분 구현을 사용하기로 선택한 &lt;strong&gt;경우 동작이 ECMA-262, &lt;sup&gt;5th&lt;/sup&gt; edition 에서 벗어나는 경우에 의존해서는 안됩니다 ! &lt;/strong&gt;고맙게도 이러한 사양의 편차는 대부분의 코딩 상황에서 거의 나타나지 않습니다. 위 사양의 편차를 이해하지 못하는 경우 이러한 비준수 편차 세부 사항에 대해 걱정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="67afcf342da3e90693d7ecef744d3642516938dd" translate="yes" xml:space="preserve">
          <source>If you choose to use this partial implementation, &lt;strong&gt;you must not rely on those cases where behavior deviates from ECMA-262, 5th edition!&lt;/strong&gt; With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when &lt;code&gt;bind()&lt;/code&gt; is widely implemented according to the specification.</source>
          <target state="translated">이 부분 구현을 사용하기로 선택한 &lt;strong&gt;경우 ECMA-262, 5 판에서 동작이 벗어난 경우에 의존해서는 안됩니다! &lt;/strong&gt;그러나 일부주의를 기울이면 (및 특정 요구에 맞게 추가 수정이 적용됨),이 부분 구현은 &lt;code&gt;bind()&lt;/code&gt; 가 사양에 따라 광범위하게 구현 되는 시간에 대한 합리적인 브리지가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d8ff152a7506a8df981872cd6144a994c604418" translate="yes" xml:space="preserve">
          <source>If you come from another programming language, it is also common to use keywords that don't mean the same or have no meaning at all in javaScript:</source>
          <target state="translated">다른 프로그래밍 언어를 사용하는 경우 javaScript에서 동일하지 않거나 전혀 의미가없는 키워드를 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="56181bd1d66f2b2ed3709ed12001807e1c6d7be4" translate="yes" xml:space="preserve">
          <source>If you construct an arithmetic expression as a string, you can use &lt;code&gt;eval()&lt;/code&gt; to evaluate it at a later time. For example, suppose you have a variable &lt;code&gt;x&lt;/code&gt;. You can postpone evaluation of an expression involving &lt;code&gt;x&lt;/code&gt; by assigning the string value of the expression, say &quot;&lt;code&gt;3 * x + 2&lt;/code&gt;&quot;, to a variable, and then calling &lt;code&gt;eval()&lt;/code&gt; at a later point in your script.</source>
          <target state="translated">산술 표현식을 문자열로 구성하는 경우 &lt;code&gt;eval()&lt;/code&gt; 을 사용 하여 나중에 평가할 수 있습니다. 예를 들어, 변수 &lt;code&gt;x&lt;/code&gt; 가 있다고 가정하십시오 . &quot; &lt;code&gt;3 * x + 2&lt;/code&gt; &quot; 와 같은 표현식의 문자열 값을 변수에 할당 한 다음 나중에 스크립트의 &lt;code&gt;eval()&lt;/code&gt; 을 호출 하여 &lt;code&gt;x&lt;/code&gt; 와 관련된 표현식의 평가를 연기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d68f6b9f418726c69743b66c16ac037f82b5627" translate="yes" xml:space="preserve">
          <source>If you create a property key from an expression, you need to use square brackets. Otherwise the property name can't be computed:</source>
          <target state="translated">식에서 속성 키를 만드는 경우 대괄호를 사용해야합니다. 그렇지 않으면 속성 이름을 계산할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="be14b3ea8c1e9826f6190d19d2cab72fdf85cb50" translate="yes" xml:space="preserve">
          <source>If you define multiple values then the last value is returned.</source>
          <target state="translated">여러 값을 정의하면 마지막 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f10d361ef5a163329364a3df976bc77ea83e3dc0" translate="yes" xml:space="preserve">
          <source>If you delete a property for which a watchpoint has been set, that watchpoint does not disappear. If you later recreate the property, the watchpoint is still in effect.</source>
          <target state="translated">감시 점이 설정된 속성을 삭제하면 해당 감시 점이 사라지지 않습니다. 나중에 속성을 다시 만들면 감시 점이 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9e2bd2b895541007ef32841e0415947532555ac7" translate="yes" xml:space="preserve">
          <source>If you delete a property with the &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; operator, the &lt;code&gt;in&lt;/code&gt; operator returns &lt;code&gt;false&lt;/code&gt; for that property.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 연산자 를 사용하여 속성을 삭제 하면 &lt;code&gt;in&lt;/code&gt; 연산자는 해당 속성에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5f6e1de3c0913e4cc6a427cd152ae3adbdbf83ba" translate="yes" xml:space="preserve">
          <source>If you didn't write the &lt;code&gt;new&lt;/code&gt; operator, &lt;strong&gt;the Constructor Function would be invoked like any Regular Function,&lt;/strong&gt;&lt;em&gt;without creating an Object.&lt;/em&gt; In this case, the value of &lt;code&gt;this&lt;/code&gt; is also different.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 연산자를 작성하지 않은 경우 &lt;strong&gt;생성자 함수는 &lt;/strong&gt;&lt;em&gt;객체를 생성하지 않고 &lt;/em&gt;&lt;strong&gt;일반 함수처럼 호출됩니다 &lt;/strong&gt;&lt;em&gt;. &lt;/em&gt;이 경우, 값 &lt;code&gt;this&lt;/code&gt; 도 다르다.</target>
        </trans-unit>
        <trans-unit id="bddfe554f36b287490547eed85632d9e23d92c9d" translate="yes" xml:space="preserve">
          <source>If you didn't write the &lt;code&gt;new&lt;/code&gt; operator, &lt;strong&gt;the Constructor Function would be invoked like any Regular Function,&lt;/strong&gt;&lt;em&gt;without creating an Object.&lt;/em&gt;In this case, the value of &lt;code&gt;this&lt;/code&gt; is also different.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 연산자 를 쓰지 않으면 &lt;strong&gt;생성자 함수는 &lt;/strong&gt;&lt;em&gt;객체를 만들지 않고 &lt;/em&gt;&lt;strong&gt;일반 함수처럼 호출됩니다 &lt;/strong&gt;&lt;em&gt;. &lt;/em&gt;이 경우, 값 &lt;code&gt;this&lt;/code&gt; 도 다르다.</target>
        </trans-unit>
        <trans-unit id="d5715ce7b490b3178a67fbab44e46e0895854da4" translate="yes" xml:space="preserve">
          <source>If you do not specify a constructor method, a default constructor is used.</source>
          <target state="translated">생성자 메서드를 지정하지 않으면 기본 생성자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91809d53b8b015a60ef70d0dcdc8f1e75e790479" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad54b71740a03f15b390b615e6bf7ef289e62f3" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getminutes&quot;&gt;&lt;code&gt;getMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getminutes&quot;&gt; &lt;code&gt;getMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b14924a4ad8ffa7796c3bfab19bb7a60650112" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt;, and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcminutes&quot;&gt;&lt;code&gt;getUTCMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;minutesValue&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcminutes&quot;&gt; &lt;code&gt;getUTCMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa69a0144131eaebaa23e3873fb3414a94568f" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;dateValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getmonth&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;dateValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmonth&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3df5d83c279d0c8023216b21336a639196b7ed77" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcmonth&quot;&gt;&lt;code&gt;getUTCMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;monthValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;dayValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmonth&quot;&gt; &lt;code&gt;getUTCMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47bc293e91c6175b64ee14299e94b76f046b77c1" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80f5fcbf1f345056595a0febb2d4450e65ef680f" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9f19a7f8ab4f40f5bd17f11354e3f6271fb12c" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;secondsValue&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;msValue&lt;/var&gt;&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59226b478f68551a725b4904aa9e073fdd1245c0" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;dayValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f69c9e92ce00676ee4d2916a406ce0640412ab41" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;dayValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a6e5b4b10c44b2a624b4d411895f115df5e9376" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;minutesValue&lt;/code&gt;, &lt;code&gt;secondsValue&lt;/code&gt;, and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getminutes&quot;&gt;&lt;code&gt;getMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;minutesValue&lt;/code&gt; , &lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getminutes&quot;&gt; &lt;code&gt;getMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="196d20153d788622cbd58314f072ed3ac7c88814" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;minutesValue&lt;/code&gt;, &lt;code&gt;secondsValue&lt;/code&gt;, and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcminutes&quot;&gt;&lt;code&gt;getUTCMinutes()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;minutesValue&lt;/code&gt; , &lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcminutes&quot;&gt; &lt;code&gt;getUTCMinutes()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e065f2df26eadd9c019745d680d610654be27e8" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;monthValue&lt;/code&gt; and &lt;code&gt;dateValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getmonth&quot;&gt;&lt;code&gt;getMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getdate&quot;&gt;&lt;code&gt;getDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;monthValue&lt;/code&gt; 및 &lt;code&gt;dateValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmonth&quot;&gt; &lt;code&gt;getMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getdate&quot;&gt; &lt;code&gt;getDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f17a4828fb9f406dde0b1835b9d908b2753f5da" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;monthValue&lt;/code&gt; and &lt;code&gt;dayValue&lt;/code&gt; parameters, the values returned from the &lt;a href=&quot;getutcmonth&quot;&gt;&lt;code&gt;getUTCMonth()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcdate&quot;&gt;&lt;code&gt;getUTCDate()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;monthValue&lt;/code&gt; 및 &lt;code&gt;dayValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmonth&quot;&gt; &lt;code&gt;getUTCMonth()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcdate&quot;&gt; &lt;code&gt;getUTCDate()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d6a263711a564bafff20ce9a44e33aecf895b2" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;msValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13b2fd50258a2835809a9814d00ddc68fb9b08a2" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;msValue&lt;/code&gt; parameter, the value returned from the &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; method is used.</source>
          <target state="translated">&lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae79f7fb255a43982f924ce9d07ff130cc8750c" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;secondsValue&lt;/code&gt; and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getseconds&quot;&gt;&lt;code&gt;getSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getmilliseconds&quot;&gt;&lt;code&gt;getMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getseconds&quot;&gt; &lt;code&gt;getSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getmilliseconds&quot;&gt; &lt;code&gt;getMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b9c693ad5b1943fcbb6c027381de26570f41e6" translate="yes" xml:space="preserve">
          <source>If you do not specify the &lt;code&gt;secondsValue&lt;/code&gt; and &lt;code&gt;msValue&lt;/code&gt; parameters, the values returned from &lt;a href=&quot;getutcseconds&quot;&gt;&lt;code&gt;getUTCSeconds()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;getutcmilliseconds&quot;&gt;&lt;code&gt;getUTCMilliseconds()&lt;/code&gt;&lt;/a&gt; methods are used.</source>
          <target state="translated">&lt;code&gt;secondsValue&lt;/code&gt; 및 &lt;code&gt;msValue&lt;/code&gt; 매개 변수를 지정하지 않으면 &lt;a href=&quot;getutcseconds&quot;&gt; &lt;code&gt;getUTCSeconds()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;getutcmilliseconds&quot;&gt; &lt;code&gt;getUTCMilliseconds()&lt;/code&gt; &lt;/a&gt; 메소드 에서 리턴 된 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="05cb4b511b1661f5586af08ed24530681a2151ee" translate="yes" xml:space="preserve">
          <source>If you don't give any parameter and use the &lt;code&gt;match()&lt;/code&gt; method directly, you will get an &lt;a href=&quot;../array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; with an empty string: &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="translated">매개 변수를 제공하지 않고 &lt;code&gt;match()&lt;/code&gt; 메서드를 직접 사용하면 빈 문자열 인 &lt;code&gt;[&quot;&quot;]&lt;/code&gt; &lt;a href=&quot;../array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="af40479ee91482e63e43f4df0bb7624dbe144771" translate="yes" xml:space="preserve">
          <source>If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:</source>
          <target state="translated">자체 생성자를 제공하지 않으면 기본 생성자가 제공됩니다. 클래스가 기본 클래스 인 경우 기본 생성자는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="35c32852d31c81ac10578986fc553bf83224d9e5" translate="yes" xml:space="preserve">
          <source>If you express color as a hexadecimal RGB triplet, you must use the format &lt;code&gt;rrggbb&lt;/code&gt;. For example, the hexadecimal RGB values for salmon are red=FA, green=80, and blue=72, so the RGB triplet for salmon is &lt;code&gt;&quot;FA8072&quot;&lt;/code&gt;.</source>
          <target state="translated">색상을 16 진수 RGB 삼중 항으로 표현하는 경우 &lt;code&gt;rrggbb&lt;/code&gt; 형식을 사용해야 합니다. 예를 들어 연어의 16 진수 RGB 값은 빨강 = FA, 녹색 = 80 및 파랑 = 72이므로 연어의 RGB 삼중 항은 &lt;code&gt;&quot;FA8072&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="424cbece6047c20988ec0b925f0d69bf351d88e0" translate="yes" xml:space="preserve">
          <source>If you forget a &lt;code&gt;break&lt;/code&gt; then the script will run from the &lt;code&gt;case&lt;/code&gt; where the criterion is met and will run the cases after that &lt;strong&gt;regardless if a criterion was met&lt;/strong&gt;.</source>
          <target state="translated">당신이 잊어 버린 경우 &lt;code&gt;break&lt;/code&gt; 다음 스크립트에서 실행할 &lt;code&gt;case&lt;/code&gt; 기준이 충족되고 그 후 케이스를 실행 &lt;strong&gt;기준이 충족 된 경우에 관계없이&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5829843e73f7b32286683290a76dfea716fae9b0" translate="yes" xml:space="preserve">
          <source>If you forget a break then the script will run from the case where the criterion is met and will run the case after that regardless if criterion was met. See example here:</source>
          <target state="translated">중단을 잊어 버린 경우 기준이 충족 된 경우 스크립트가 실행되고 기준이 충족되었는지 여부에 관계없이 스크립트가 실행됩니다. 여기 예를보십시오 :</target>
        </trans-unit>
        <trans-unit id="392bc9770f3f38cbe5fa9323408292a9e2ec9a76" translate="yes" xml:space="preserve">
          <source>If you intended to create a method of an object, you will need to create an object. The following syntax without a name after the &lt;code&gt;function&lt;/code&gt; keyword is valid then.</source>
          <target state="translated">객체의 메서드를 만들려면 객체를 만들어야합니다. &lt;code&gt;function&lt;/code&gt; 키워드 다음에 이름이없는 다음 구문 이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2b7602e387bd2af7647914f024cab0e3d3062237" translate="yes" xml:space="preserve">
          <source>If you meant to declare another constant, pick another name and re-name. This constant name is already taken in this scope.</source>
          <target state="translated">다른 상수를 선언하려면 다른 이름을 선택하고 이름을 바꾸십시오. 이 상수 이름은 이미이 범위에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f1e13b196b133d23d16e2eca23049991007c75b" translate="yes" xml:space="preserve">
          <source>If you must run the code, consider running it with reduced privileges. This advice applies mainly to extensions and XUL applications, which can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.evalInSandbox&quot;&gt;Components.utils.evalInSandbox&lt;/a&gt; for this.</source>
          <target state="translated">코드를 실행해야하는 경우 축소 된 권한으로 코드를 실행하십시오. 이 조언은 주로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Components.utils.evalInSandbox&quot;&gt;Components.utils.evalInSandbox&lt;/a&gt; 를 사용할 수있는 확장 및 XUL 응용 프로그램에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f05da75db7bf9aa79df3571a16ac371a8a1c09b8" translate="yes" xml:space="preserve">
          <source>If you need the &lt;strong&gt;index&lt;/strong&gt; of the found element in the array, use &lt;a href=&quot;findindex&quot;&gt;&lt;code&gt;findIndex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에서 찾은 요소 의 &lt;strong&gt;인덱스&lt;/strong&gt; 가 필요한 경우 &lt;a href=&quot;findindex&quot;&gt; &lt;code&gt;findIndex()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44577c6fc47c8a13363a3871df6144ffae8f08db" translate="yes" xml:space="preserve">
          <source>If you need the natural log of 2 or 10, use the constants &lt;a href=&quot;ln2&quot;&gt;&lt;code&gt;Math.LN2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ln10&quot;&gt;&lt;code&gt;Math.LN10&lt;/code&gt;&lt;/a&gt; . If you need a logarithm to base 2 or 10, use &lt;a href=&quot;log2&quot;&gt;&lt;code&gt;Math.log2()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;log10&quot;&gt;&lt;code&gt;Math.log10()&lt;/code&gt;&lt;/a&gt; . If you need a logarithm to other bases, use Math.log(x) / Math.log(otherBase) as in the example below; you might want to precalculate 1 / Math.log(otherBase) .</source>
          <target state="translated">자연 로그 2 또는 10이 필요한 경우 &lt;a href=&quot;ln2&quot;&gt; &lt;code&gt;Math.LN2&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;ln10&quot;&gt; &lt;code&gt;Math.LN10&lt;/code&gt; &lt;/a&gt; 또는 Math.LN10을 사용하십시오 . 2 또는 10을 밑으로하는 로그가 필요한 경우 &lt;a href=&quot;log2&quot;&gt; &lt;code&gt;Math.log2()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;log10&quot;&gt; &lt;code&gt;Math.log10()&lt;/code&gt; &lt;/a&gt; . 다른 염기에 대한 로그가 필요한 경우 아래 예와 같이 Math.log (x) / Math.log (otherBase)를 사용하십시오. 1 / Math.log (otherBase)를 미리 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68beaac9d5aafe09513d7eccd070b1b3d71bb486" translate="yes" xml:space="preserve">
          <source>If you need the natural log of 2 or 10, use the constants &lt;a href=&quot;ln2&quot;&gt;&lt;code&gt;Math.LN2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ln10&quot;&gt;&lt;code&gt;Math.LN10&lt;/code&gt;&lt;/a&gt;. If you need a logarithm to base 2 or 10, use &lt;a href=&quot;log2&quot;&gt;&lt;code&gt;Math.log2()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;log10&quot;&gt;&lt;code&gt;Math.log10()&lt;/code&gt;&lt;/a&gt;. If you need a logarithm to other bases, use Math.log(x) / Math.log(otherBase) as in the example below; you might want to precalculate 1 / Math.log(otherBase).</source>
          <target state="translated">2 또는 10의 자연 로그가 필요하면 &lt;a href=&quot;ln2&quot;&gt; &lt;code&gt;Math.LN2&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;ln10&quot;&gt; &lt;code&gt;Math.LN10&lt;/code&gt; &lt;/a&gt; 또는 Math.LN10을 사용하십시오 . 2 또는 10을 밑으로하는 로그가 필요하면 &lt;a href=&quot;log2&quot;&gt; &lt;code&gt;Math.log2()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;log10&quot;&gt; &lt;code&gt;Math.log10()&lt;/code&gt; &lt;/a&gt; . 다른 밑수에 대한 로그가 필요하면 아래 예제와 같이 Math.log (x) / Math.log (otherBase)를 사용하십시오. 1 / Math.log (otherBase)를 미리 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9dd66eafaabe75ecf9115145d2b767ab19cb10" translate="yes" xml:space="preserve">
          <source>If you need to define a property without a value, you might use &lt;a href=&quot;../global_objects/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; as a value.</source>
          <target state="translated">값없이 속성을 정의해야하는 경우 &lt;a href=&quot;../global_objects/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f2598944e0ea66e2ceaf4e11c59c0cdff9b64a0" translate="yes" xml:space="preserve">
          <source>If you need to export the default, write the following instead:</source>
          <target state="translated">기본값을 내 보내야하는 경우 대신 다음을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="48354edaa3e95aef6e6a48c3e5f6b6df17eeb92b" translate="yes" xml:space="preserve">
          <source>If you need to find if a value &lt;strong&gt;exists&lt;/strong&gt; in an array, use &lt;a href=&quot;includes&quot;&gt;&lt;code&gt;Array.prototype.includes()&lt;/code&gt;&lt;/a&gt;. Again, it checks each element for equality with the value instead of using a testing function.</source>
          <target state="translated">값 &lt;strong&gt;이&lt;/strong&gt; 배열에 &lt;strong&gt;있는지&lt;/strong&gt; 확인해야하는 경우 &lt;a href=&quot;includes&quot;&gt; &lt;code&gt;Array.prototype.includes()&lt;/code&gt; &lt;/a&gt; . 다시 말하지만, 테스트 기능을 사용하는 대신 각 요소가 값과 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f6d63d0046baee1f832f04d68cdceccdcee365fd" translate="yes" xml:space="preserve">
          <source>If you need to find if any element satisfies the provided testing function, use &lt;a href=&quot;some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 테스트 함수를 충족하는 요소가 있는지 확인하려면 &lt;a href=&quot;some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92ed2ad090bbb7a6fac237e3660f1c52e2f3ec91" translate="yes" xml:space="preserve">
          <source>If you need to find the &lt;strong&gt;index of a value&lt;/strong&gt;, use &lt;a href=&quot;indexof&quot;&gt;&lt;code&gt;Array.prototype.indexOf()&lt;/code&gt;&lt;/a&gt;. (It&amp;rsquo;s similar to &lt;a href=&quot;findindex&quot;&gt;&lt;code&gt;findIndex()&lt;/code&gt;&lt;/a&gt;, but checks each element for equality with the value instead of using a testing function.)</source>
          <target state="translated">&lt;strong&gt;값&lt;/strong&gt; 의 &lt;strong&gt;인덱스&lt;/strong&gt; 를 찾아야하는 경우 &lt;a href=&quot;indexof&quot;&gt; &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; . ( &lt;a href=&quot;findindex&quot;&gt; &lt;code&gt;findIndex()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 테스트 함수를 사용하는 대신 각 요소가 값과 같은지 확인합니다.)</target>
        </trans-unit>
        <trans-unit id="2f7b0f1b470fc3559b362594aea4dada581a211a" translate="yes" xml:space="preserve">
          <source>If you need to find the position of an element or whether an element exists in an array, use &lt;a href=&quot;indexof&quot;&gt;&lt;code&gt;Array.prototype.indexOf()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;includes&quot;&gt;&lt;code&gt;Array.prototype.includes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소의 위치를 ​​찾거나 요소가 배열에 있는지 여부를 확인하려면 &lt;a href=&quot;indexof&quot;&gt; &lt;code&gt;Array.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;includes&quot;&gt; &lt;code&gt;Array.prototype.includes()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53ac54e6412bacc63b8624a67da085e48a736a3a" translate="yes" xml:space="preserve">
          <source>If you need to know if a string matches a regular expression &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;../regexp/test&quot;&gt;&lt;code&gt;RegExp.test()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열이 정규식 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 와 일치하는지 알아야하는 경우 &lt;a href=&quot;../regexp/test&quot;&gt; &lt;code&gt;RegExp.test()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9701887d047bb96bcab9229f97c6b2c436038b1d" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that do not support &lt;a href=&quot;../object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;, it is best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you cannot make them non-enumerable.</source>
          <target state="translated">&lt;a href=&quot;../object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; 를&lt;/a&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메서드를 열거 불가능하게 만들 수 없으므로 폴리 필하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="98c814d727deb065c2a896b0632604aebd175c33" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;a href=&quot;../object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;a href=&quot;../object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; 를&lt;/a&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메서드를 열거 불가능하게 만들 수 없으므로 폴리 필하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe432265bccad633d8efa5ca4d1fac0eea99e3f" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them &lt;strong&gt;non-enumerable&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 메소드 를 polyfill하지 않는 것이 가장 좋습니다 . &lt;strong&gt;열거&lt;/strong&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b656e640c400c1887a63c15bbd8901d8a955a1f8" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty()&lt;/a&gt;&lt;/code&gt; 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 열거 할 수 없으므로 &lt;code&gt;Array.prototype&lt;/code&gt; 메소드 를 polyfill하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bd9f376dc29844e3f900bec4366cbbf039c586ee" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt;, it is best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; at all, as you cannot make it non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt; 를 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 을 열거 불가능하게 만들 수 없으므로 Polyfill Array.prototype 을 아예 사용하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="57168d3fef20557c94e31ea753dbe3ba115b9dc4" translate="yes" xml:space="preserve">
          <source>If you need to support truly obsolete JavaScript engines that don't support &lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt;, it's best not to polyfill &lt;code&gt;Array.prototype&lt;/code&gt; methods at all, as you can't make them non-enumerable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../object/defineproperty&quot;&gt;Object.defineProperty&lt;/a&gt;&lt;/code&gt; 를 지원하지 않는 진정으로 쓸모없는 JavaScript 엔진을 지원 해야하는 경우 , &lt;code&gt;Array.prototype&lt;/code&gt; 메소드를 열거 할 수 없으므로 polyfill하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3edaaddf2630ab4d776484bd61b50696d946fc29" translate="yes" xml:space="preserve">
          <source>If you need to use an assignment in a conditional expression, a common practice is to put additional parentheses around the assignment. For example:</source>
          <target state="translated">조건식에 대입을 사용해야하는 경우 일반적으로 대입을 괄호로 묶는 것이 일반적입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d40d82c950e9a812cd674e6001dbf28de03af32b" translate="yes" xml:space="preserve">
          <source>If you only want the first match found, you might want to use &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">첫 번째 일치 항목 만 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 려면 RegExp.exec ()를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c57242f318553d3f36f9cf38af0a4f7480baa928" translate="yes" xml:space="preserve">
          <source>If you only want to consider properties attached to the object itself, and not its prototypes, use &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt;&lt;code&gt;getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt; or perform a &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt; check (&lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt;&lt;code&gt;propertyIsEnumerable()&lt;/code&gt;&lt;/a&gt; can also be used). Alternatively, if you know there won't be any outside code interference, you can extend built-in prototypes with a check method.</source>
          <target state="translated">프로토 타입이 아니라 객체 자체에 연결된 속성 만 고려하려는 경우 &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt; &lt;code&gt;getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 검사를 수행합니다 ( &lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt; &lt;code&gt;propertyIsEnumerable()&lt;/code&gt; &lt;/a&gt; 도 사용할 수 있음). 또는 외부 코드 간섭이 없다는 것을 알고 있다면 check 메서드를 사용하여 내장 프로토 타입을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735530012ac3a4439f6528b8ed499f68e90f9884" translate="yes" xml:space="preserve">
          <source>If you only want to consider properties attached to the object itself, and not its prototypes, use &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt;&lt;code&gt;getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt; or perform a &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt; check (&lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt;&lt;code&gt;propertyIsEnumerable&lt;/code&gt;&lt;/a&gt; can also be used). Alternatively, if you know there won't be any outside code interference, you can extend built-in prototypes with a check method.</source>
          <target state="translated">프로토 타입이 아닌 객체 자체에 연결된 속성 만 고려하려면 &lt;a href=&quot;../global_objects/object/getownpropertynames&quot;&gt; &lt;code&gt;getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;../global_objects/object/hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 검사를 수행 하십시오 ( &lt;a href=&quot;../global_objects/object/propertyisenumerable&quot;&gt; &lt;code&gt;propertyIsEnumerable&lt;/code&gt; &lt;/a&gt; 도 사용할 수 있음). 또는 외부 코드 간섭이 없다는 것을 알고 있다면 확인 방법으로 내장 프로토 타입을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e97d2b27233fdaf7731ef52386bfd0124047bc8" translate="yes" xml:space="preserve">
          <source>If you really want to create a &lt;code&gt;Symbol&lt;/code&gt; wrapper object, you can use the &lt;code&gt;Object()&lt;/code&gt; function:</source>
          <target state="translated">실제로 &lt;code&gt;Symbol&lt;/code&gt; 래퍼 객체 를 만들려면 &lt;code&gt;Object()&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1843b29c2d5c6fd4913d7563bf6437e92296a87" translate="yes" xml:space="preserve">
          <source>If you return &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be added to the JSON string.</source>
          <target state="translated">당신이 돌아 오면 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 가 json으로 문자열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec5df79d7c885974c5aa582c610905dc7cdac8d" translate="yes" xml:space="preserve">
          <source>If you return &lt;code&gt;undefined&lt;/code&gt;, the property is not included (i.e., filtered out) in the output JSON string.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 속성이 출력 JSON 문자열에 포함되지 않습니다 (즉, 필터링 됨).</target>
        </trans-unit>
        <trans-unit id="2c70929d7e200a5fe36f9edeb06a1b0a8c7a9d88" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, &quot;true&quot; or &quot;false&quot; is used as the property's value, as appropriate, when adding it to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 을 반환 하면 JSON 문자열에 추가 할 때 &quot;true&quot;또는 &quot;false&quot;가 속성 값으로 적절하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aebe43fc49075ca5e764acfd1f8b57b86a33df55" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, the property is not included in the output.</source>
          <target state="translated">&lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 를 반환 하면 속성이 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dba4f295774a527ffbb538fec3b29039be43a105" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, the stringified version of that value is used as the property's value.</source>
          <target state="translated">&lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 을 반환하는 경우 해당 값의 문자열 버전이 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb68ba0a762626c3b4353aedeeb2ffb44a69ed51" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, the string corresponding to that number is used as the value for the property when added to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 를 반환하면 해당 숫자에 해당하는 문자열이 JSON 문자열에 추가 될 때 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b5099af9e7be5c72550fd23afd94bd55e6142b2" translate="yes" xml:space="preserve">
          <source>If you return a &lt;a href=&quot;../string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, that string is used as the property's value when adding it to the JSON string.</source>
          <target state="translated">&lt;a href=&quot;../string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 반환하면 해당 문자열이 JSON 문자열에 추가 될 때 속성 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="131cdc0db5e0530808f6767f2a2daddd0e55eba1" translate="yes" xml:space="preserve">
          <source>If you return any other object, the object is recursively stringified into the JSON string, calling the &lt;code&gt;replacer&lt;/code&gt; function on each property, unless the object is a function, in which case nothing is added to the JSON string.</source>
          <target state="translated">다른 객체를 반환하면 객체가 함수가 아닌 한 JSON 문자열에 아무것도 추가되지 않는 한 각 속성 에서 &lt;code&gt;replacer&lt;/code&gt; 함수를 호출하여 객체가 JSON 문자열로 반복적으로 문자열 화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce9a704ee385f7c72710bc2ca6fef00b73d2fb09" translate="yes" xml:space="preserve">
          <source>If you return any other object, the object is recursively stringified, calling the &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; function on each property.</source>
          <target state="translated">다른 객체를 반환하면 객체가 재귀 적으로 문자열 화 되어 각 속성에 대해 &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="61d92592decdab65c8c7d88c8b2e526399e93164" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;getBaseLog(10, 1000)&lt;/code&gt; it returns &lt;code&gt;2.9999999999999996&lt;/code&gt; due to floating-point rounding, which is very close to the actual answer of 3.</source>
          <target state="translated">&lt;code&gt;getBaseLog(10, 1000)&lt;/code&gt; 를 실행 하면 부동 소수점 반올림으로 인해 &lt;code&gt;2.9999999999999996&lt;/code&gt; 을 반환 하며 이는 실제 답변 3에 매우 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="935b1b976508db5afe6cca08176c17239b09c114" translate="yes" xml:space="preserve">
          <source>If you set a property to &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt; but do not delete it, the &lt;code&gt;in&lt;/code&gt; operator returns true for that property.</source>
          <target state="translated">속성을 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; 로&lt;/a&gt; 설정 했지만 삭제하지 않으면 &lt;code&gt;in&lt;/code&gt; 연산자는 해당 속성에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34e10440b87179c5669d287c33d08bce47b6fa19" translate="yes" xml:space="preserve">
          <source>If you specify a different number of elements to insert than the number you're removing, the array will have a different length at the end of the call.</source>
          <target state="translated">제거 할 번호와 다른 개수의 요소를 삽입하면 통화 종료시 배열의 길이가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="682d3439d2fa9871ecad9eae1652e23eb74f6221" translate="yes" xml:space="preserve">
          <source>If you specify a number outside the expected range, the date information in the &lt;a href=&quot;../date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; object is updated accordingly. For example, if you specify 1005, the number of seconds is incremented by 1, and 5 is used for the milliseconds.</source>
          <target state="translated">예상 범위를 벗어난 숫자를 지정하면 &lt;a href=&quot;../date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 객체 의 날짜 정보 가 그에 따라 업데이트됩니다. 예를 들어 1005를 지정하면 초 수가 1 씩 증가하고 5가 밀리 초로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="32c4cced0b807fb68ae6694984513b4abd3c73a9" translate="yes" xml:space="preserve">
          <source>If you specify any object, including a &lt;code&gt;Boolean&lt;/code&gt; object whose value is &lt;code&gt;false&lt;/code&gt;, as the initial value of a &lt;code&gt;Boolean&lt;/code&gt; object, the new &lt;code&gt;Boolean&lt;/code&gt; object has a value of &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">당신이 포함 개체 지정하면 &lt;code&gt;Boolean&lt;/code&gt; 값입니다 오브젝트 &lt;code&gt;false&lt;/code&gt; a의 초기 값으로, &lt;code&gt;Boolean&lt;/code&gt; 개체, 새로운 &lt;code&gt;Boolean&lt;/code&gt; 객체의 값이 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98ae5f892e8f6de3201d6782cad351ca1383c87b" translate="yes" xml:space="preserve">
          <source>If you use a method for a numeric literal and the numeric literal has no exponent and no decimal point, leave white-space(s) before the dot that precedes the method call to prevent the dot from being interpreted as a decimal point.</source>
          <target state="translated">숫자 리터럴에 메소드를 사용하고 숫자 리터럴에 지수가없고 소수점이없는 경우, 점이 소수점으로 해석되지 않도록 메소드 호출 앞에있는 점 앞에 공백을 두십시오.</target>
        </trans-unit>
        <trans-unit id="edd6afd92c9f7a2538aece19a2aa77da3a6f3da8" translate="yes" xml:space="preserve">
          <source>If you use a method for a numeric literal, and the numeric literal has no exponent and no decimal point, you should leave &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;white-space(s)&lt;/a&gt; before the dot preceding the method call, so that the dot is not interpreted as a decimal point.</source>
          <target state="translated">숫자 리터럴에 메서드를 사용하고 숫자 리터럴에 지수와 소수점이없는 경우 메서드 호출 앞의 점 앞에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;공백을&lt;/a&gt; 두어야 점이 소수점으로 해석되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="a5f1d9b94d0b0382335af42f55617a4070d22713" translate="yes" xml:space="preserve">
          <source>If you use an unconditional &lt;code&gt;catch&lt;/code&gt; clause with one or more conditional &lt;code&gt;catch&lt;/code&gt; clauses, the unconditional &lt;code&gt;catch&lt;/code&gt; clause must be specified last. Otherwise, the unconditional &lt;code&gt;catch&lt;/code&gt; clause will intercept all types of exception before they can reach the conditional ones.</source>
          <target state="translated">당신이 무조건 사용하는 경우 &lt;code&gt;catch&lt;/code&gt; 하나 개 이상의 조건과 절을 &lt;code&gt;catch&lt;/code&gt; 조항, 무조건 &lt;code&gt;catch&lt;/code&gt; 절은 마지막으로 지정해야합니다. 그렇지 않으면 무조건 &lt;code&gt;catch&lt;/code&gt; 절은 조건부 예외에 도달하기 전에 모든 유형의 예외를 가로 챌 것입니다.</target>
        </trans-unit>
        <trans-unit id="78afbb13097de5c8b78471387fa8f8af3bf94b11" translate="yes" xml:space="preserve">
          <source>If you use normal JavaScript floating point numbers in imul, you will experience a degrade in performance. This is because of the costly conversion from a floating point to an integer for multiplication, and then converting the multiplied integer back into a floating point. The reason imul exists is because it is faster in only one (so far) circumstance: AsmJS. AsmJS allows for JIST-optimizers to more easily implement internal integers in JavaScript. Multiplying two numbers stored internally as integers (which is only possible with AsmJS) with imul is the only potential circumstance where Math.imul may prove performant in current browsers.</source>
          <target state="translated">imul에서 일반 JavaScript 부동 소수점 숫자를 사용하면 성능이 저하됩니다. 이는 곱하기 위해 부동 소수점에서 정수로의 비용이 많이 드는 변환과 곱한 정수를 다시 부동 소수점으로 변환하기 때문입니다. imul이 존재하는 이유는 오직 하나의 (지금까지) 상황에서 더 빠르기 때문입니다 : AsmJS. AsmJS를 사용하면 JIST 최적화 프로그램이 JavaScript에서 내부 정수를보다 쉽게 ​​구현할 수 있습니다. 내부적으로 정수로 저장된 두 숫자 (AsmJS에서만 가능함)를 imul과 곱하는 것은 Math.imul이 현재 브라우저에서 성능을 입증 할 수있는 유일한 잠재적 상황입니다.</target>
        </trans-unit>
        <trans-unit id="5d05f89ff9b94e2efe15b7bec1cbbc6dcdeb7392" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;eval&lt;/code&gt; function &lt;em&gt;indirectly,&lt;/em&gt; by invoking it via a reference other than &lt;code&gt;eval&lt;/code&gt;, &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;as of ECMAScript 5&lt;/a&gt; it works in the global scope rather than the local scope. This means, for instance, that function declarations create global functions, and that the code being evaluated doesn't have access to local variables within the scope where it's being called.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;eval&lt;/code&gt; 기능을 &lt;em&gt;간접적&lt;/em&gt; 이외의 참조를 통해 호출에 의해 &lt;code&gt;eval&lt;/code&gt; , &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.2&quot;&gt;ECMAScript를 5로&lt;/a&gt; 는 전역 영역이 아닌 로컬 범위에서 작동합니다. 예를 들어, 함수 선언은 전역 함수를 작성하고 평가중인 코드는 호출되는 범위 내에서 로컬 변수에 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73d1c2ee0e60284da071d578e3277739538eefac" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;toExponential()&lt;/code&gt; method for a numeric literal and the numeric literal has no exponent and no decimal point, leave whitespace(s) before the dot that precedes the method call to prevent the dot from being interpreted as a decimal point.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;toExponential()&lt;/code&gt; 숫자 리터럴에 대한 방법과 숫자 리터럴 메서드 호출 선행는 소수점으로 해석되는 점을 방지한다는 점 이전에는 지수없이 소수점, 휴가 공백 (들)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="597a2c20eb78f0898e472f8de984f91f02ea471c" translate="yes" xml:space="preserve">
          <source>If you want &lt;em&gt;all&lt;/em&gt; properties&amp;mdash;including non-enumerables&amp;mdash;see &lt;a href=&quot;getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 형이 아닌 속성을 포함한 &lt;em&gt;모든&lt;/em&gt; 속성 을 원하는 경우 &lt;a href=&quot;getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d19c207f7baf216ddd324adb7472fc913a7eb3d" translate="yes" xml:space="preserve">
          <source>If you want all properties, even non-enumerables, see &lt;a href=&quot;getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 불가능한 모든 속성을 원하면 &lt;a href=&quot;getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2948b5beeb992bfbdd3d635cd05e062df02e23d7" translate="yes" xml:space="preserve">
          <source>If you want an array element to exist but have an undefined value, use the &lt;code&gt;undefined&lt;/code&gt; value instead of the &lt;code&gt;delete&lt;/code&gt; operator. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is assigned the value &lt;code&gt;undefined&lt;/code&gt;, but the array element still exists:</source>
          <target state="translated">배열 요소가 존재하지만 &lt;code&gt;undefined&lt;/code&gt; 값을 가지려면 &lt;code&gt;delete&lt;/code&gt; 연산자 대신 정의되지 않은 값을 사용하십시오 . 다음 예에서 &lt;code&gt;trees[3]&lt;/code&gt; 에는 &lt;code&gt;undefined&lt;/code&gt; 값이 할당 되지만 배열 요소는 여전히 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9b17dbe4a9978e35e0df77cda82cc871d93e5145" translate="yes" xml:space="preserve">
          <source>If you want an array element to exist but have an undefined value, use the &lt;code&gt;undefined&lt;/code&gt; value instead of the &lt;code&gt;delete&lt;/code&gt; operator. In the following example, &lt;code&gt;trees[3]&lt;/code&gt; is assigned the value undefined, but the array element still exists:</source>
          <target state="translated">배열 요소가 존재하지만 &lt;code&gt;undefined&lt;/code&gt; 값을 가지려면 &lt;code&gt;delete&lt;/code&gt; 연산자 대신 정의되지 않은 값을 사용하십시오 . 다음 예제에서 &lt;code&gt;trees[3]&lt;/code&gt; 에는 undefined 값이 할당되지만 배열 요소는 여전히 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2418cdf14fe502c2af1708e66eb2202ca0a9648f" translate="yes" xml:space="preserve">
          <source>If you want only the enumerable properties, see &lt;a href=&quot;keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; or use a &lt;a href=&quot;../../statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/a&gt; loop (although note that this will return enumerable properties not only found directly upon that object but also along the prototype chain for the object unless the latter is filtered with &lt;a href=&quot;hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">열거 가능한 속성 만 원하는 경우 &lt;a href=&quot;keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 참조 하거나 &lt;a href=&quot;../../statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt; 루프를 사용하십시오 (그러나 이것은 객체에서 직접 찾을 수있을뿐만 아니라 객체의 프로토 타입 체인을 따라 열거 가능한 속성을 반환합니다. 후자는 &lt;a href=&quot;hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 로 필터링됩니다 .</target>
        </trans-unit>
        <trans-unit id="39e653fdc0628060fb29f300dfac7bff4e0e7b80" translate="yes" xml:space="preserve">
          <source>If you want only the enumerable properties, see &lt;a href=&quot;keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; or use a &lt;a href=&quot;../../statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/a&gt; loop (note that this will also return enumerable properties found along the prototype chain for the object unless the latter is filtered with &lt;a href=&quot;hasownproperty&quot;&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">열거 가능한 속성 만 원하면 &lt;a href=&quot;keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 참조 하거나 &lt;a href=&quot;../../statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt; 루프 를 사용합니다 (후자가 &lt;a href=&quot;hasownproperty&quot;&gt; &lt;code&gt;hasOwnProperty()&lt;/code&gt; &lt;/a&gt; 필터링되지 않는 한 객체의 프로토 타입 체인을 따라 발견 된 열거 가능한 속성도 반환됩니다 ) .</target>
        </trans-unit>
        <trans-unit id="081dc7a00575a1581dcf7b3a349ab503bed65012" translate="yes" xml:space="preserve">
          <source>If you want to change the value of &quot;arg&quot; in the function body, you can do so, but you do not need to declare the same variable again. In other words: you can omit the &lt;code&gt;let&lt;/code&gt; keyword. If you want to create a new variable, you need to rename it as conflicts with the function parameter already.</source>
          <target state="translated">함수 본문에서 &quot;arg&quot;값을 변경하려면 변경할 수 있지만 동일한 변수를 다시 선언 할 필요는 없습니다. 즉, &lt;code&gt;let&lt;/code&gt; 키워드를 생략 할 수 있습니다 . 새 변수를 작성하려면 이미 함수 매개 변수와 충돌하여 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c69934f7bf2e4d350baba14d96404b2849e4d9" translate="yes" xml:space="preserve">
          <source>If you want to create an &lt;code&gt;&lt;a href=&quot;../global_objects/array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../global_objects/boolean&quot;&gt;Booleans&lt;/a&gt;&lt;/code&gt; from a mask you can use this code:</source>
          <target state="translated">당신이 만들려면 &lt;code&gt;&lt;a href=&quot;../global_objects/array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../global_objects/boolean&quot;&gt;Booleans&lt;/a&gt;&lt;/code&gt; 마스크에서이 코드를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b4a31baeccc4d5cda15fdaad0b7733d54070608b" translate="yes" xml:space="preserve">
          <source>If you want to disallow setting a new prototype for your object, your handler's &lt;code&gt;setPrototypeOf&lt;/code&gt; method can either return &lt;code&gt;false&lt;/code&gt;, or it can throw an exception.</source>
          <target state="translated">객체에 새 프로토 타입을 설정하지 못하게하려면 처리기의 &lt;code&gt;setPrototypeOf&lt;/code&gt; 메서드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 예외를 throw 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4823c44fafa3ab81be841e2d53941d57b47410" translate="yes" xml:space="preserve">
          <source>If you want to export a single value or need a fallback value for a module, a default export can be used:</source>
          <target state="translated">단일 값을 내보내거나 모듈에 대한 폴백 값이 필요한 경우 기본 내보내기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50cbe95c4ee11ee4d5865b13d455d501fdd62c86" translate="yes" xml:space="preserve">
          <source>If you want to obtain capture groups and the global flag is set, you need to use &lt;a href=&quot;../regexp/exec&quot;&gt;&lt;code&gt;RegExp.exec()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;matchall&quot;&gt;&lt;code&gt;String.prototype.matchAll()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">캡처 그룹을 얻으려면 전역 플래그가 설정되어 있으면 대신 &lt;a href=&quot;../regexp/exec&quot;&gt; &lt;code&gt;RegExp.exec()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;matchall&quot;&gt; &lt;code&gt;String.prototype.matchAll()&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d27f9e5e25120e14455ea16bd96cef1e320218ef" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current class inside the class body, you can create a &lt;em&gt;named class expression&lt;/em&gt;. The name is only visible within the scope of the class expression itself.</source>
          <target state="translated">클래스 본문 내에서 현재 클래스를 참조하려면 &lt;em&gt;명명 된 클래스 expression을&lt;/em&gt; 만들 수 있습니다 . 이름은 클래스 표현식 자체의 범위 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dc47424fb527730f62198aaaa25c3348ff0fba7" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current class inside the class body, you can create a named class expression. This name is only visible in the scope of the class expression itself.</source>
          <target state="translated">클래스 본문 내에서 현재 클래스를 참조하려는 경우 명명 된 클래스 표현식을 작성할 수 있습니다. 이 이름은 클래스 표현식 자체의 범위에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481ba14f2f65c81318d305b87a92b52bfe033114" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current function inside the function body, you need to create a named function expression. &lt;u&gt;&lt;strong&gt;This name is then local only to the function body (scope)&lt;/strong&gt;&lt;/u&gt;. This also avoids using the non-standard &lt;a href=&quot;../functions/arguments/callee&quot;&gt;&lt;code&gt;arguments.callee&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">함수 본문 내에서 현재 함수를 참조하려면 명명 된 함수 표현식을 만들어야합니다. &lt;u&gt;&lt;strong&gt;이 이름은 함수 본문 (범위)에만 로컬&lt;/strong&gt;&lt;/u&gt; 입니다. 이것은 또한 비표준 &lt;a href=&quot;../functions/arguments/callee&quot;&gt; &lt;code&gt;arguments.callee&lt;/code&gt; &lt;/a&gt; 속성 사용을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="9597ad4f9e7ad14879829bc41d7ee7dd8599f31b" translate="yes" xml:space="preserve">
          <source>If you want to refer to the current function inside the function body, you need to create a named function expression. &lt;u&gt;&lt;strong&gt;This name is then local only to the function body (scope)&lt;/strong&gt;&lt;/u&gt;. This also avoids using the non-standard &lt;code&gt;&lt;a href=&quot;../functions/arguments/callee&quot;&gt;arguments.callee&lt;/a&gt;&lt;/code&gt; property.</source>
          <target state="translated">함수 본문 내에서 현재 함수를 참조하려면 명명 된 함수 표현식을 작성해야합니다. &lt;u&gt;&lt;strong&gt;이 이름은 함수 본문 (scope)에만 로컬&lt;/strong&gt;&lt;/u&gt; 입니다. 또한 비표준 &lt;code&gt;&lt;a href=&quot;../functions/arguments/callee&quot;&gt;arguments.callee&lt;/a&gt;&lt;/code&gt; 속성을 사용하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="99528303e4fa98874c6d3b7da8c65a874a1f9d0b" translate="yes" xml:space="preserve">
          <source>If you want to remove the getter, you can just &lt;a href=&quot;../operators/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; it:</source>
          <target state="translated">getter를 제거 &lt;a href=&quot;../operators/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a7fc22c8401e0f59ce33412d5d1a62fa14a2a8f0" translate="yes" xml:space="preserve">
          <source>If you want to remove the getter, you can just &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; it:</source>
          <target state="translated">게터를 제거 &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e1fd57c263b80cc07ff24ec488e383d11e16fe7f" translate="yes" xml:space="preserve">
          <source>If you want to remove the setter, you can just &lt;a href=&quot;../operators/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; it:</source>
          <target state="translated">setter를 제거 &lt;a href=&quot;../operators/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="afab6a24815f73f4c694b81bf63bd41e2e5c193b" translate="yes" xml:space="preserve">
          <source>If you want to remove the setter, you can just &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; it:</source>
          <target state="translated">세터를 제거 &lt;code&gt;&lt;a href=&quot;../operators/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a8801610bdd961430a0f13ef356227a205175f" translate="yes" xml:space="preserve">
          <source>If you want to see how to use the &lt;code&gt;Object.defineProperty&lt;/code&gt; method with a &lt;em&gt;binary-flags-like&lt;/em&gt; syntax, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;additional examples&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이진 플래그와 같은&lt;/em&gt; 구문으로 &lt;code&gt;Object.defineProperty&lt;/code&gt; 메서드 를 사용하는 방법을 보려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;추가 예제를&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a33a81af4ee501f0c074526b9710c19c67c2ea6e" translate="yes" xml:space="preserve">
          <source>If you want to see how to use the &lt;code&gt;Object.defineProperty&lt;/code&gt; method with a &lt;em&gt;binary-flags-like&lt;/em&gt; syntax, see &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;additional examples&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;바이너리 플래그와 유사한&lt;/em&gt; 구문으로 &lt;code&gt;Object.defineProperty&lt;/code&gt; 메서드 를 사용하는 방법을 보려면 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples&quot;&gt;추가 예제를&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="088b49e17dfc48492f7ae931aa8eea2f898fed94" translate="yes" xml:space="preserve">
          <source>If you want to use an ordered associative array in a cross-browser environment, use a &lt;a href=&quot;../global_objects/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; object if available, or simulate this structure with two separate arrays (one for the keys and the other for the values), or build an array of single-property objects, etc.</source>
          <target state="translated">크로스 브라우저 환경에서 정렬 된 연관 배열을 사용하려면 사용 가능한 경우 &lt;a href=&quot;../global_objects/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 오브젝트를 사용하거나 두 개의 개별 배열 (키 및 다른 값)로이 구조를 시뮬레이션하거나 단일 배열을 빌드하십시오. 속성 개체 등</target>
        </trans-unit>
        <trans-unit id="19381b630a3a814e91674608c14a389044af178b" translate="yes" xml:space="preserve">
          <source>If you were to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; as the second argument to &lt;code&gt;reduce()&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 대한 두 번째 인수로 &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; 를 제공 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffb5ffcd2b43a51e7c0b5d8ecc72c4f2fa812052" translate="yes" xml:space="preserve">
          <source>If you were to provide an initial value as the second argument to &lt;code&gt;reduce()&lt;/code&gt;, the result would look like this:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 의 두 번째 인수로 초기 값을 제공 하면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9641348677babae98e66baf7b0dc8fe9f67d1d9b" translate="yes" xml:space="preserve">
          <source>If you wish to await two or more promises in parallel, you must still use &lt;code&gt;Promise#then&lt;/code&gt;, as &lt;code&gt;parallel&lt;/code&gt; does in the example.</source>
          <target state="translated">두 개 이상의 약속을 병렬로 기다리 려면 예제에서 &lt;code&gt;parallel&lt;/code&gt; 과 마찬가지로 &lt;code&gt;Promise#then&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c253c1c3b6acd6d4520eacac9b373475e00e1fb8" translate="yes" xml:space="preserve">
          <source>If you wish to inherit from multiple objects, then mixins are a possibility.</source>
          <target state="translated">여러 객체에서 상속하려면 믹스 인이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b358a85c79019bc0c27a5e9a086df327f3612e47" translate="yes" xml:space="preserve">
          <source>If you wish to safely perform two or more jobs in parallel, you must await a call to &lt;code&gt;&lt;a href=&quot;../global_objects/promise/all&quot;&gt;Promise.all&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../global_objects/promise/allsettled&quot;&gt;Promise.allSettled&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 작업을 병렬로 안전하게 수행하려면 &lt;code&gt;&lt;a href=&quot;../global_objects/promise/all&quot;&gt;Promise.all&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../global_objects/promise/allsettled&quot;&gt;Promise.allSettled&lt;/a&gt;&lt;/code&gt; 에 대한 호출을 기다려야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d85b069cf65c1056e4db1149435fcd8a68335dc" translate="yes" xml:space="preserve">
          <source>If you wish to support the use of a bound function only using &lt;a href=&quot;../../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, or only by calling it, the target function must enforce that restriction.</source>
          <target state="translated">&lt;a href=&quot;../../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 만 사용 하거나 호출 하여 바인딩 함수 사용을 지원 하려면 대상 함수가 해당 제한을 시행해야합니다.</target>
        </trans-unit>
        <trans-unit id="28b16738f775180a66d096e17e9c0fac48e31c55" translate="yes" xml:space="preserve">
          <source>If you're experimenting with code in a web browser, such as the Firefox Web Console (&lt;strong&gt;Tools &lt;/strong&gt;&amp;gt;&lt;strong&gt; Web Developer &lt;/strong&gt;&amp;gt;&lt;strong&gt; Web Console&lt;/strong&gt;) and you 'Run' a definition of a class with the same name twice, you'll get a &lt;code&gt;SyntaxError: redeclaration of let &lt;em&gt;ClassName&lt;/em&gt;;&lt;/code&gt;. (See further discussion of this issue in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1428672&quot;&gt;bug 1428672&lt;/a&gt;.) Doing something similar in Chrome Developer Tools gives you a message like &lt;code&gt;Uncaught SyntaxError: Identifier '&lt;em&gt;ClassName&lt;/em&gt;' has already been declared at &amp;lt;anonymous&amp;gt;:1:1&lt;/code&gt;.</source>
          <target state="translated">Firefox Web Console ( &lt;strong&gt;Tools&lt;/strong&gt; &amp;gt; &lt;strong&gt;Web Developer&lt;/strong&gt; &amp;gt; &lt;strong&gt;Web Console&lt;/strong&gt; )과 같은 웹 브라우저에서 코드를 실험 하고 같은 이름의 클래스 정의를 두 번 '실행'하면 &lt;code&gt;SyntaxError: redeclaration of let &lt;em&gt;ClassName&lt;/em&gt;;&lt;/code&gt; . ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1428672&quot;&gt;버그 1428672&lt;/a&gt; 에서이 문제에 대한 자세한 설명을 참조하십시오 .) Chrome 개발자 도구에서 비슷한 작업을 수행하면 &lt;code&gt;Uncaught SyntaxError: Identifier '&lt;em&gt;ClassName&lt;/em&gt;' has already been declared at &amp;lt;anonymous&amp;gt;:1:1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1718e56ab56bc63e9b5c1230d10ad98783a6bcb6" translate="yes" xml:space="preserve">
          <source>If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:</source>
          <target state="translated">클래스가 파생 클래스 인 경우 기본 생성자는 부모 생성자를 호출하여 제공된 모든 인수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1c3ce3648420f55b4147d24cab187f467076e9ce" translate="yes" xml:space="preserve">
          <source>If your project uses packages that export ESM, you can also import them for side effects only. This will run the code in the package entry point file (and any files it imports) only.</source>
          <target state="translated">프로젝트에서 ESM을 내보내는 패키지를 사용하는 경우 부작용을 위해서만 가져올 수도 있습니다. 그러면 패키지 진입 점 파일 (및 가져 오는 모든 파일)의 코드 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9752f0db065b6780513593f5577369639a2acaaf" translate="yes" xml:space="preserve">
          <source>If your regular expression uses the &quot;&lt;code&gt;g&lt;/code&gt;&quot; flag, you can use the &lt;code&gt;exec()&lt;/code&gt; method multiple times to find successive matches in the same string. When you do so, the search starts at the substring of &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; specified by the regular expression's &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property (&lt;a href=&quot;test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; will also advance the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property). Note that the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property will not be reset when searching a different string, it will start its search at its existing &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; .</source>
          <target state="translated">정규식에서 &quot; &lt;code&gt;g&lt;/code&gt; &quot;플래그를 사용하는 경우 &lt;code&gt;exec()&lt;/code&gt; 메서드를 여러 번 사용하여 동일한 문자열에서 연속적으로 일치하는 항목을 찾을 수 있습니다. 이렇게하면 정규식의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성 ( &lt;a href=&quot;test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 지정된 &lt;code&gt;&lt;var&gt;str&lt;/var&gt;&lt;/code&gt; 의 하위 문자열에서 검색이 시작됩니다. .&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성). 참고는 것을&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성은 다른 문자열을 검색 할 때, 그것은 기존에 자사의 검색을 시작합니다 재설정되지 않습니다&lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2d04674a5af9a41b5f728b702f2b91de19a7082" translate="yes" xml:space="preserve">
          <source>If your regular expression uses the &quot;&lt;code&gt;g&lt;/code&gt;&quot; flag, you can use the &lt;code&gt;exec()&lt;/code&gt; method multiple times to find successive matches in the same string. When you do so, the search starts at the substring of &lt;code&gt;str&lt;/code&gt; specified by the regular expression's &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property (&lt;a href=&quot;test&quot;&gt;&lt;code&gt;test()&lt;/code&gt;&lt;/a&gt; will also advance the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property). Note that the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property will not be reset when searching a different string it will start its search at its existing &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; .</source>
          <target state="translated">정규 표현식에서 &quot; &lt;code&gt;g&lt;/code&gt; &quot;플래그를 사용하는 경우 &lt;code&gt;exec()&lt;/code&gt; 메소드를 여러 번 사용하여 동일한 문자열에서 연속되는 일치 항목을 찾을 수 있습니다. 그렇게 하면 정규 표현식의 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성 으로 지정된 &lt;code&gt;str&lt;/code&gt; 의 하위 문자열에서 검색이 시작됩니다 ( &lt;a href=&quot;test&quot;&gt; &lt;code&gt;test()&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 속성을 진행시킵니다 ). 참고는 것을 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; 다른 캐릭터는 기존에 자사의 검색이 시작됩니다 검색 할 때 속성을 다시 설정되지 &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a9f12b1dc332abbb2f8fc8ea3de59b0640a4c8e" translate="yes" xml:space="preserve">
          <source>If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:</source>
          <target state="translated">값 배열이 수만 개로 늘어날 수있는 경우 하이브리드 전략을 사용하십시오. 한 번에 배열 청크에 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="00f07d80e0be0674f46c91673837e8b3acb3567d" translate="yes" xml:space="preserve">
          <source>Ignoring some returned values</source>
          <target state="translated">일부 반환 값 무시</target>
        </trans-unit>
        <trans-unit id="57f2c95b766adf67d35d720bd7a552837b1ff2f2" translate="yes" xml:space="preserve">
          <source>Illegal character</source>
          <target state="translated">불법 캐릭터</target>
        </trans-unit>
        <trans-unit id="bf8a946bee9899de71266d734c579d7b3e7c14a0" translate="yes" xml:space="preserve">
          <source>Immediately Invoked Function Expressions</source>
          <target state="translated">즉시 호출 된 함수 표현식</target>
        </trans-unit>
        <trans-unit id="0a98f9ab649d5842f0e2d4409933f707c73e764f" translate="yes" xml:space="preserve">
          <source>Implementation Progress</source>
          <target state="translated">구현 진행</target>
        </trans-unit>
        <trans-unit id="1d77a4da59a498bc0526734d1d32ceaf44b25a12" translate="yes" xml:space="preserve">
          <source>Implementations may support other subsets, and requests will be negotiated against all available subset-representation combinations to find the best match. Two algorithms are available for this negotiation and selected by the &lt;code&gt;formatMatcher&lt;/code&gt; property: A &lt;a href=&quot;http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher&quot;&gt;fully specified &lt;code&gt;&quot;basic&quot;&lt;/code&gt; algorithm&lt;/a&gt; and an implementation-dependent &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; algorithm.</source>
          <target state="translated">구현은 다른 부분 집합을 지원할 수 있으며 요청은 사용 가능한 모든 부분 집합 표현 조합에 대해 협상되어 가장 일치하는 것을 찾습니다. 이 협상에 두 가지 알고리즘을 사용할 수 있으며 &lt;code&gt;formatMatcher&lt;/code&gt; 속성에 의해 선택됩니다 . &lt;a href=&quot;http://www.ecma-international.org/ecma-402/1.0/#BasicFormatMatcher&quot;&gt;완전하게 지정된 &lt;code&gt;&quot;basic&quot;&lt;/code&gt; 알고리즘&lt;/a&gt; 과 구현에 따른 &lt;code&gt;&quot;best fit&quot;&lt;/code&gt; 알고리즘.</target>
        </trans-unit>
        <trans-unit id="9891b7f1f9d2e885ea5e7211c73846949ae5ce55" translate="yes" xml:space="preserve">
          <source>Implemented in JavaScript 1.0.</source>
          <target state="translated">JavaScript 1.0에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="f33ba6d0736fb021c9fc01268c7a34b22e5f56c8" translate="yes" xml:space="preserve">
          <source>Implementing a &lt;code&gt;WeakMap&lt;/code&gt;-like class with a .clear() method</source>
          <target state="translated">.clear () 메소드를 사용 하여 &lt;code&gt;WeakMap&lt;/code&gt; 유사 클래스 구현</target>
        </trans-unit>
        <trans-unit id="0532eeb0dfeca745a29b54a058021727371ec22f" translate="yes" xml:space="preserve">
          <source>Implementing a WeakMap-like class with a .clear() method</source>
          <target state="translated">.clear () 메서드를 사용하여 WeakMap과 유사한 클래스 구현</target>
        </trans-unit>
        <trans-unit id="c749b374aeb24624ee8aa56bb696c115d5f5e9a5" translate="yes" xml:space="preserve">
          <source>Implementing basic set operations</source>
          <target state="translated">기본 설정 작업 구현</target>
        </trans-unit>
        <trans-unit id="b88a338120312301e3ec4ab586557d6a7e9f0f33" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;Function.prototype.toString&lt;/code&gt; revision</source>
          <target state="translated">&lt;code&gt;Function.prototype.toString&lt;/code&gt; 개정을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="380f227f10005ab46ff9c7c323b946317aa5a7e7" translate="yes" xml:space="preserve">
          <source>Implicit call:</source>
          <target state="translated">암시 적 호출 :</target>
        </trans-unit>
        <trans-unit id="7cf7edc6eed680f670f1903e2fa95dffe98c8491" translate="yes" xml:space="preserve">
          <source>Implicit globals and outer function scope</source>
          <target state="translated">암시 적 전역 및 외부 기능 범위</target>
        </trans-unit>
        <trans-unit id="23dadb4aba4124154d197243dcf4d7ef8b8da923" translate="yes" xml:space="preserve">
          <source>Import a module for its side effects only</source>
          <target state="translated">부작용에 대해서만 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">모듈에서 단일 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="a221101514292b5fcf882207fe6e9cbe5953924e" translate="yes" xml:space="preserve">
          <source>Import an entire module for side effects only, without importing anything. This runs the module's global code, but doesn't actually import any values.</source>
          <target state="translated">가져 오기없이 부작용없이 전체 모듈을 가져옵니다. 모듈의 전역 코드를 실행하지만 실제로는 값을 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dba1b2f0c4295b30c790350d8885ab2810a087e" translate="yes" xml:space="preserve">
          <source>Import an entire module's contents</source>
          <target state="translated">전체 모듈 내용 가져 오기</target>
        </trans-unit>
        <trans-unit id="b51d3f221713e66532ca8daeac5ec886156d5d57" translate="yes" xml:space="preserve">
          <source>Import an export with a more convenient alias</source>
          <target state="translated">보다 편리한 별명으로 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="478b4766b3a380867a3862a6ca8bdb0a668262eb" translate="yes" xml:space="preserve">
          <source>Import multiple exports from a module with convenient aliases.</source>
          <target state="translated">편리한 별명을 가진 모듈에서 여러 내보내기를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bd9c8faa833f0f94f37e3eaac33816aac5e508cc" translate="yes" xml:space="preserve">
          <source>Import multiple exports from module</source>
          <target state="translated">모듈에서 여러 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="2adb455832e9c0f94412f3522b3179fa5ada0ef0" translate="yes" xml:space="preserve">
          <source>Import the exported module correctly</source>
          <target state="translated">내 보낸 모듈을 올바르게 가져 오기</target>
        </trans-unit>
        <trans-unit id="8d4ecf2834d54b456e6157b4f56fd8d7bf4ecc2a" translate="yes" xml:space="preserve">
          <source>Import/Export mutable globals proposal</source>
          <target state="translated">가변 글로벌 가져 오기 / 내보내기 제안</target>
        </trans-unit>
        <trans-unit id="102ff9d8f76a710f00d76cead3a7e8bba6f5cdfc" translate="yes" xml:space="preserve">
          <source>Importing defaults</source>
          <target state="translated">기본값 가져 오기</target>
        </trans-unit>
        <trans-unit id="f71dcbf6278006d50e621d3d0c3ded43630b6564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt;, &lt;code&gt;new.target&lt;/code&gt; is inherited from the surrounding scope.</source>
          <target state="translated">에 &lt;a href=&quot;../functions/arrow_functions&quot;&gt; 화살표 기능&lt;/a&gt; , &lt;code&gt;new.target&lt;/code&gt; 은 주변 영역에서 상속한다.</target>
        </trans-unit>
        <trans-unit id="a195036ba7dec4c4382e6cf6537c69752b0ed431" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt;, &lt;code&gt;this&lt;/code&gt; retains the value of the enclosing lexical context's &lt;code&gt;this&lt;/code&gt;. In global code, it will be set to the global object:</source>
          <target state="translated">에서는 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;화살표 기능&lt;/a&gt; , &lt;code&gt;this&lt;/code&gt; 클로징 콘텍스트 어휘의 값의 유지 &lt;code&gt;this&lt;/code&gt; . 전역 코드에서는 전역 객체로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6c73f4538311a378c8c9424d32c3f8811910d419" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; code, however, this will throw a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 코드에서는 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82dc5204fd47b97a4c4e971fee4ed30a2687404c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; code, you can't use &quot;&lt;code&gt;let&lt;/code&gt;&quot; as a label name. It will throw a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; (let is a reserved identifier).</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격한 모드&lt;/a&gt; 코드, 당신은 &quot;사용할 수 &lt;code&gt;let&lt;/code&gt; 레이블 이름으로&quot;. 그것은 발생합니다 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; (하자가 예약 된 식별자입니다).</target>
        </trans-unit>
        <trans-unit id="c6054ae0aa42f967abbaaff8c7c370a661682c9b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, attempting to add new properties to a non-extensible object throws a &lt;code&gt;TypeError&lt;/code&gt;. In sloppy mode, the addition of the &quot;x&quot; property is silently ignored.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 확장 할 수없는 객체에 새 속성을 추가하려고하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다. 조잡한 모드에서는 &quot;x&quot;속성 추가가 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="af9aba5cd8d260931e6c60474eae352d67a9887b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, starting with ES2015, functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 ES2015부터 블록 내부의 함수가 해당 블록으로 범위가 지정됩니다. ES2015 이전에는 블록 수준 기능이 엄격 모드에서 금지되었습니다.</target>
        </trans-unit>
        <trans-unit id="216d48a6757220d152e7f994000123b4833e4e79" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, the &lt;a href=&quot;../global_objects/function/caller&quot;&gt;&lt;code&gt;Function.caller&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/function/arguments&quot;&gt;&lt;code&gt;Function.arguments&lt;/code&gt;&lt;/a&gt; properties are used and shouldn't be. They are deprecated, because they leak the function caller, are non-standard, hard to optimize and potentially a performance-harmful feature.</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 의 &lt;a href=&quot;../global_objects/function/caller&quot;&gt; &lt;code&gt;Function.caller&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../global_objects/function/arguments&quot;&gt; &lt;code&gt;Function.arguments&lt;/code&gt; &lt;/a&gt; 속성은 사용이 아니어야합니다. 함수 호출자를 유출하고 비표준이며 최적화하기 어렵고 잠재적으로 성능에 유해한 기능이므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3ea4e9343d838f1294b3b7ae8cc65f8857960e3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller&quot;&gt;&lt;code&gt;Function.caller&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/function/arguments&quot;&gt;&lt;code&gt;Function.arguments&lt;/code&gt;&lt;/a&gt; properties are used and shouldn't be. They are deprecated, because they leak the function caller, are non-standard, hard to optimize and potentially a performance-harmful feature.</source>
          <target state="translated">에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/caller&quot;&gt; &lt;code&gt;Function.caller&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/function/arguments&quot;&gt; &lt;code&gt;Function.arguments&lt;/code&gt; &lt;/a&gt; 속성은 사용이 아니어야합니다. 함수 호출자를 누설하고 비표준이며 최적화하기 어렵고 잠재적으로 성능에 유해한 기능이기 때문에 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ae11f4b28ed355c17fb2cf7b60c3de003e3a4a0" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, identifiers can contain only alphanumeric characters (or &quot;$&quot; or &quot;_&quot;), and may not start with a digit. An identifier differs from a &lt;strong&gt;string&lt;/strong&gt; in that a string is data, while an identifier is part of the code.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;자바 스크립트&lt;/a&gt; , 식별자는 숫자 (또는 &quot;$&quot;또는 &quot;_&quot;)를 포함 할 수 있으며 숫자로 시작되지 않을 수 있습니다. 식별자는 문자열이 데이터 인 반면 식별자는 코드의 일부라는 점에서 &lt;strong&gt;문자열&lt;/strong&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b1cf0c9af0f3437de670684af61db176a2e024d0" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, identifiers can contain only alphanumeric characters (or &quot;$&quot; or &quot;_&quot;), and may not start with a digit. An identifier differs from a &lt;strong&gt;string&lt;/strong&gt; in that a string is data, while an identifier is part of the code.</source>
          <target state="translated">에 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/JavaScript&quot;&gt; 자바 스크립트&lt;/a&gt; , 식별자는 숫자 (또는 &quot;$&quot;또는 &quot;_&quot;)를 포함 할 수 있으며 숫자로 시작되지 않을 수 있습니다. 식별자는 문자열이 데이터 인 반면 식별자는 코드의 일부라는 점에서 &lt;strong&gt;문자열&lt;/strong&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9ceac41023ca7e64457c2a69427be9598fb1653c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;strict_mode&quot;&gt;strict mode&lt;/a&gt;, all browsers that support ES2015 handle this the same way: &lt;code&gt;zero&lt;/code&gt; is defined only if &lt;code&gt;shouldDefineZero&lt;/code&gt; is true, and only in the scope of the &lt;code&gt;if&lt;/code&gt;-block.</source>
          <target state="translated">에서 &lt;a href=&quot;strict_mode&quot;&gt;엄격 모드&lt;/a&gt; , 지원 ES2015이 같은 방식으로 처리하는 모든 브라우저 : &lt;code&gt;zero&lt;/code&gt; 경우에만 정의 &lt;code&gt;shouldDefineZero&lt;/code&gt; 는 사실입니다 만의 범위에있는 &lt;code&gt;if&lt;/code&gt; - 블록.</target>
        </trans-unit>
        <trans-unit id="29666e4908ed732ae018d4d4721ff9754d3c167b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;strict_mode&quot;&gt;strict mode&lt;/a&gt;, starting with ES2015, functions inside blocks are now scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.</source>
          <target state="translated">&lt;a href=&quot;strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 에서는 ES2015부터 블록 내부의 기능이 해당 블록으로 범위가 지정됩니다. ES2015 이전에는 엄격 모드에서 블록 레벨 기능이 금지되었습니다.</target>
        </trans-unit>
        <trans-unit id="873415a6a8f203e4bdfe8b79a65ee0b40b608117" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentPromise,&lt;/code&gt;&lt;code&gt;Promise.all&lt;/code&gt; wires up the promise chain in one go, meaning that the operation will fail-fast regardless of the order of rejection of the promises, and the error will always occur within the configured promise chain, enabling it to be caught in the normal way.</source>
          <target state="translated">에서 &lt;code&gt;concurrentPromise,&lt;/code&gt; &lt;code&gt;Promise.all&lt;/code&gt; 의 한 가지의 약속 체인 최대 전선, 조작에 관계없이 약속의 거부의 순서의 빠른 실패하고 오류가 항상 잡힐 수 있도록, 구성된 약속 체인 내에서 발생하는 것을 의미 정상적인 방법으로.</target>
        </trans-unit>
        <trans-unit id="221555bbaf990eeb6c49e029c703b9faa3ef204e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, both timers are created and then &lt;code&gt;await&lt;/code&gt;ed. The timers are running concurrently but the &lt;code&gt;await&lt;/code&gt; calls are still running in series, meaning the second &lt;code&gt;await&lt;/code&gt; will wait for the first one to finish. This leads the code to finish in 2 rather than 3 seconds, which is the time the slowest timer needs. The same happens in &lt;code&gt;stillConcurrent&lt;/code&gt; using &lt;code&gt;Promise.all&lt;/code&gt; this time.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; 두 타이머는 다음 생성되는 &lt;code&gt;await&lt;/code&gt; 를 에드. 타이머는 동시에 실행되지만 &lt;code&gt;await&lt;/code&gt; 통화는 계속 직렬로 실행됩니다. 즉, 두 번째 &lt;code&gt;await&lt;/code&gt; 는 첫 번째 대기 가 완료 될 때까지 대기합니다. 이로 인해 코드가 3 초가 아닌 2 초 안에 완료됩니다. 이는 가장 느린 타이머에 필요한 시간입니다. &lt;code&gt;stillConcurrent&lt;/code&gt; 사용하는 &lt;code&gt;Promise.all&lt;/code&gt; 에서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="dca20ace845e482ba3a705f727cc3a8ad77cf9d7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, both timers are created and then &lt;code&gt;await&lt;/code&gt;ed. The timers run concurrently, which means the code finishes in 2 rather than 3 seconds, i.e. the slowest timer.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; 두 타이머는 다음 생성된다 &lt;code&gt;await&lt;/code&gt; 를 에드. 타이머는 동시에 실행됩니다. 이는 코드가 3 초가 아닌 2 초, 즉 가장 느린 타이머에 완료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4f97a7bbaeebe37b6849072c8d4d0a9f173528d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;concurrentStart&lt;/code&gt;, if promise &lt;code&gt;fast&lt;/code&gt; rejects before promise &lt;code&gt;slow&lt;/code&gt; is fulfilled, then an unhandled promise rejection error will be raised, regardless of whether the caller has configured a catch clause.</source>
          <target state="translated">에서 &lt;code&gt;concurrentStart&lt;/code&gt; , 만약 약속 &lt;code&gt;fast&lt;/code&gt; 약속하기 전에 거부 &lt;code&gt;slow&lt;/code&gt; 성취 된 다음 처리되지 않은 약속 거부에 관계없이 오류가 호출자가 캐치 절을 구성 여부, 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d7a6fe3cf2916c84be2ef5c18d5e7128c24c00e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;for...of&lt;/code&gt; loops, abrupt iteration termination can be caused by &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. In these cases, the iterator is closed.</source>
          <target state="translated">에서 &lt;code&gt;for...of&lt;/code&gt; 루프, 갑작스러운 반복 종료가 발생할 수 있습니다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; . 이 경우 반복자가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f24173b93852ae7003f7140596ebc37c863720d7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;for...of&lt;/code&gt; loops, abrupt iteration termination can be caused by &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. In these cases, the iterator is closed.</source>
          <target state="translated">에서 &lt;code&gt;for...of&lt;/code&gt; 루프, 갑작스러운 반복 종료가 발생할 수 있습니다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; . 이 경우 반복기가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4d6add7a612b365f8147b939f3c6f66bc22b629f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequentialStart&lt;/code&gt;, execution suspends 2 seconds for the first &lt;code&gt;await&lt;/code&gt;, and then again another 1 second for the second &lt;code&gt;await&lt;/code&gt;. The second timer is not created until the first has already fired.</source>
          <target state="translated">에서는 &lt;code&gt;sequentialStart&lt;/code&gt; 실행은 상기 제 2 초 중지 &lt;code&gt;await&lt;/code&gt; 후 다시 다른 제 1 초와 &lt;code&gt;await&lt;/code&gt; . 두 번째 타이머는 첫 번째 타이머가 이미 시작될 때까지 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ffa1771a0ac6f2ae699ccfcc00a18930b4b803c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequentialStart&lt;/code&gt;, execution suspends 2 seconds for the first &lt;code&gt;await&lt;/code&gt;, and then another second for the second &lt;code&gt;await&lt;/code&gt;. The second timer is not created until the first has already fired, so the code finishes after 3 seconds.</source>
          <target state="translated">에서는 &lt;code&gt;sequentialStart&lt;/code&gt; 실행은 상기 제 2 초 중지 &lt;code&gt;await&lt;/code&gt; 및 초 후 다른 제 &lt;code&gt;await&lt;/code&gt; . 두 번째 타이머는 첫 번째 타이머가 이미 실행될 때까지 생성되지 않으므로 코드는 3 초 후에 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="176a20a11517113033606aab1e61e3d4ca20c6ad" translate="yes" xml:space="preserve">
          <source>In C, the &lt;code&gt;strcmp()&lt;/code&gt; function is used for comparing strings. In JavaScript, you just use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;less-than and greater-than operators&lt;/a&gt;:</source>
          <target state="translated">C에서 &lt;code&gt;strcmp()&lt;/code&gt; 함수는 문자열을 비교하는 데 사용됩니다. JavaScript에서는&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt; 보다 작음 및보다 큼 연산자를 사용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="309d60f8743568aecbdf811d2d351da393f4b34d" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015 There is a way to concisely define properties whose values are generator functions:</source>
          <target state="translated">ECMAScript 2015에는 값이 생성기 함수 인 속성을 간결하게 정의하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ee30c3781491b37d2d91aa12c3f275c2e033a0" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, a shorthand notation is available, so that the keyword &quot;&lt;code&gt;function&lt;/code&gt;&quot; is no longer necessary.</source>
          <target state="translated">ECMAScript 2015에서는 축약 표기법을 사용할 수 있으므로 키워드 &quot; &lt;code&gt;function&lt;/code&gt; &quot;이 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7df1fd3d991e32f1320629672612245d3c92c0f7" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, a shorthand notation is available, so that the keyword &quot;function&quot; is no longer necessary.</source>
          <target state="translated">ECMAScript 2015에서는 약식 표기법을 사용할 수 있으므로 키워드 &quot;function&quot;이 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbe274850fe44af194eea5fda8294e245f5d4c8b" translate="yes" xml:space="preserve">
          <source>In ECMAScript 2015, there is a way to concisely define properties whose values are generator functions:</source>
          <target state="translated">ECMAScript 2015에는 값이 생성기 함수 인 속성을 간결하게 정의하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="948177c7ae9848dd8e493ddbacacd75cb5473d9a" translate="yes" xml:space="preserve">
          <source>In ECMAScript 3/5, the &lt;code&gt;this&lt;/code&gt; issue was fixable by assigning the value in &lt;code&gt;this&lt;/code&gt; to a variable that could be closed over.</source>
          <target state="translated">ECMAScript 3/5에서는 &lt;code&gt;this&lt;/code&gt; 문제를 해결할 수 있는 변수 &lt;code&gt;this&lt;/code&gt; 값을 할당 하여이 문제를 해결할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="4fd06900882a105e2510f94e9cdbf294840e46f9" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5 strict mode code, duplicate property names were considered a &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;. With the introduction of computed property names making duplication possible at runtime, ECMAScript 2015 has removed this restriction.</source>
          <target state="translated">ECMAScript 5 엄격 모드 코드에서 중복 특성 이름은 &lt;a href=&quot;../global_objects/syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 로 간주되었습니다 . ECMAScript 2015는 런타임시 중복을 가능하게하는 계산 된 속성 이름이 도입되면서이 제한을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="02e140d416437887a7872326dba6eed9437d2415" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5, this behavior was changed for &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;. Assignment to an unqualified identifier in strict mode will result in a &lt;code&gt;ReferenceError&lt;/code&gt;, to avoid the accidental creation of properties on the global object.</source>
          <target state="translated">ECMAScript 5에서이 동작은 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드에&lt;/a&gt; 대해 변경되었습니다 . 엄격 모드에서 규정되지 않은 식별자에 할당하면 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다. 가 발생하여 전역 개체에서 실수로 속성이 생성되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82de7fe847ca3c223f7295513a60c00f3cc6f251" translate="yes" xml:space="preserve">
          <source>In ES2015 with nested template literals:</source>
          <target state="translated">중첩 템플릿 리터럴이있는 ES2015에서 :</target>
        </trans-unit>
        <trans-unit id="2e28d1359b78caea73bd201eb664d9160434980d" translate="yes" xml:space="preserve">
          <source>In ES2015 with template literals and without nesting:</source>
          <target state="translated">템플릿 리터럴과 중첩없이 ES2015에서 :</target>
        </trans-unit>
        <trans-unit id="f3672427c7965f113f3fe4cb570beacc248c8428" translate="yes" xml:space="preserve">
          <source>In ES2015, the class syntax allows for sub-classing of both built-in and user defined classes; as a result, static methods such as &lt;code&gt;Array.from&lt;/code&gt; are &quot;inherited&quot; by subclasses of &lt;code&gt;Array&lt;/code&gt; and create new instances of the subclass, not &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">ES2015에서 클래스 구문을 사용하면 내장 클래스와 사용자 정의 클래스를 모두 서브 클래 싱 할 수 있습니다. 그 결과, 같은 정적 방법 &lt;code&gt;Array.from&lt;/code&gt; 는 서브 클래스가 &quot;상속&quot;되는 &lt;code&gt;Array&lt;/code&gt; 및 서브 아닌 새로운 인스턴스 생성 &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c41c52a21154ec2619b7bacc530a4f16cecd0dd3" translate="yes" xml:space="preserve">
          <source>In ES2015, the class syntax allows sub-classing of both built-in and user-defined classes. As a result, static methods such as &lt;code&gt;Array.from()&lt;/code&gt; are &quot;inherited&quot; by subclasses of &lt;code&gt;Array&lt;/code&gt;, and create new instances &lt;em&gt;of the subclass&lt;/em&gt;, not &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">ES2015에서 클래스 구문은 내장 및 사용자 정의 클래스 모두의 하위 분류를 허용합니다. 그 결과, 같은 정적 방법 &lt;code&gt;Array.from()&lt;/code&gt; 서브 클래스가 &quot;상속&quot;되어 &lt;code&gt;Array&lt;/code&gt; , 새로운 인스턴스 생성 &lt;em&gt;서브 클래스의이&lt;/em&gt; 아닌 &lt;code&gt;Array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef0e40b46bde57de45d710a8decfe4f424e88a4" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (기본)가 아니면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. .</target>
        </trans-unit>
        <trans-unit id="53864ec850c8528b35459bfdb64c830661afe252" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be coerced to an object.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서는 객체가 아닌 인수가 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="0030a6d3d27dbe9c4a6e9e4e06ecd6adb4308138" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a frozen ordinary object, simply return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 얼어 붙은 일반 객체 인 것처럼 취급되므로 단순히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ca534830639609923b78d052142ef445d9da986" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 확장 할 수없는 일반 객체 인 것처럼 취급되며 단순히 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9bcfc35ed6e7f198824d6e0b0dcb22d3b293ba28" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 확장 할 수없는 일반 객체 인 것처럼 처리되므로 간단히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="007cf956ed6956737327164237b3afece1b87b2b" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object by simply returning it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (기본)가 아니면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. . ES2015에서 객체가 아닌 인자는 단순히 반환함으로써 봉인 된 일반 객체 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d58ae111e6808420d9135fd6bfc1e632b51c47" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object, simply return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 봉인 된 일반 객체 인 것처럼 취급되므로 간단히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a25f137ee01cf4301c10ca6fc3d32a3d19298e37" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it was a sealed ordinary object, simply return it.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 봉인 된 일반 객체 인 것처럼 취급되므로 간단히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d0bff99dd5b84da47050253c2c62698a5c39a02" translate="yes" xml:space="preserve">
          <source>In ES5, if the argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object argument will be treated as if it were a frozen ordinary object, and be simply returned.</source>
          <target state="translated">ES5에서이 메소드에 대한 인수가 객체 (원시)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 인수는 마치 고정 된 일반 객체 인 것처럼 처리되고 간단히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8598ec4f16e006f73c4b98ace30ef3c88220ab1a" translate="yes" xml:space="preserve">
          <source>In ES5, if the first argument to this method is not an object (a primitive), then it will cause a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In ES2015, a non-object first argument will be coerced to an object at first.</source>
          <target state="translated">ES5에서이 메소드의 첫 번째 인수가 객체 (기본)가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . ES2015에서 객체가 아닌 첫 번째 인수는 처음에 객체에 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c167c36d97c1d699b099b1ec68b4a0acdf0879" translate="yes" xml:space="preserve">
          <source>In ES5, it will throw a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception if the &lt;var&gt;obj&lt;/var&gt; parameter isn't an object. In ES2015, the parameter will be coerced to an &lt;a href=&quot;../object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ES5에서는 &lt;var&gt;obj&lt;/var&gt; 매개 변수가 객체가 아닌 경우 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생 합니다. ES2015에서 매개 변수는 &lt;a href=&quot;../object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 로 강제 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6d38ce849906adde58d4d32cd183bb3cd5e181f" translate="yes" xml:space="preserve">
          <source>In ES5, you typically use the &lt;a href=&quot;../function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; method to call a function with a given &lt;code&gt;this&lt;/code&gt; value and &lt;code&gt;arguments&lt;/code&gt; provided as an array (or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;array-like object&lt;/a&gt;).</source>
          <target state="translated">ES5에서는 일반적으로 &lt;a href=&quot;../function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 주어진 &lt;code&gt;this&lt;/code&gt; 값과 배열 (또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;배열과 같은 객체&lt;/a&gt; ) 로 제공된 &lt;code&gt;arguments&lt;/code&gt; 사용하여 함수 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6653f25dc7136aed24c5070c600b114c374f9a" translate="yes" xml:space="preserve">
          <source>In ES5, you typically use the &lt;a href=&quot;../function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; method to call a function with a given &lt;code&gt;this&lt;/code&gt; value and &lt;code&gt;arguments&lt;/code&gt; provided as an array (or an &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;array-like object&lt;/a&gt;).</source>
          <target state="translated">ES5에서는 일반적으로 &lt;a href=&quot;../function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 주어진 &lt;code&gt;this&lt;/code&gt; 값과 배열 (또는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects&quot;&gt;배열과 같은 객체)&lt;/a&gt; 로 제공된 &lt;code&gt;arguments&lt;/code&gt; 로 함수를 호출 합니다. ) .</target>
        </trans-unit>
        <trans-unit id="cb9d84f212ebfd0b494629810bc4f123430adee3" translate="yes" xml:space="preserve">
          <source>In ES5:</source>
          <target state="translated">ES5에서 :</target>
        </trans-unit>
        <trans-unit id="4867ea47a940c21ea6c6af42152c706a4ec82ba3" translate="yes" xml:space="preserve">
          <source>In Edge 12 and 13, &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop initializer does not create a separate variable for each loop iteration as defined by ES2015. Instead, it behaves as though the loop were wrapped in a scoping block with the &lt;code&gt;let&lt;/code&gt; immediately before the loop.</source>
          <target state="translated">에지 (12, 13)에 &lt;code&gt;let&lt;/code&gt; 내에 &lt;code&gt;for&lt;/code&gt; ES2015에 의해 정의 된 각각의 루프 반복에 대해 별도의 변수를 생성하지 않는 초기화 루프. 대신 루프 바로 앞에 &lt;code&gt;let&lt;/code&gt; 이 있는 범위 지정 블록에 루프가 래핑 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="38f05042b00889b690877f9c1f38bccf3790a39b" translate="yes" xml:space="preserve">
          <source>In Firefox 18 - 39, the name of this method was &lt;code&gt;contains()&lt;/code&gt;. It was renamed to &lt;code&gt;includes()&lt;/code&gt; in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1102219&quot;&gt;bug 1102219&lt;/a&gt; due to the following reason:</source>
          <target state="translated">Firefox 18-39에서이 메소드의 이름은 &lt;code&gt;contains()&lt;/code&gt; 입니다. 다음과 같은 이유로 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1102219&quot;&gt;버그 1102219&lt;/a&gt; 에서 contains &lt;code&gt;includes()&lt;/code&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b3441497965bb64df9474736353a9248115e770e" translate="yes" xml:space="preserve">
          <source>In Firefox 42, the implementation got updated to reflect the final ES2015 specification: The result is now checked if it is an array and if the array elements are either of type string or of type symbol. Enumerating duplicate own property names is not a failure anymore.</source>
          <target state="translated">Firefox 42에서 구현은 최종 ES2015 사양을 반영하도록 업데이트되었습니다. 이제 배열인지 배열 요소가 문자열 유형 또는 기호 유형인지 확인합니다. 중복 된 고유 속성 이름을 열거해도 더 이상 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8d03fdcab501aecd669f36c6937ea8fde7271a" translate="yes" xml:space="preserve">
          <source>In Firefox 48, &lt;code&gt;String.prototype.contains()&lt;/code&gt; has been removed. Use &lt;code&gt;String.prototype.includes()&lt;/code&gt; only.</source>
          <target state="translated">Firefox 48에서 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 제거되었습니다. &lt;code&gt;String.prototype.includes()&lt;/code&gt; 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eab913afe11ef8c151060fcbf4894152ade8632" translate="yes" xml:space="preserve">
          <source>In Firefox 58, when the exception is unused, the identifier can be omitted, as in the code below. This is also &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html&quot;&gt;allowed in TypeScript 2.5&lt;/a&gt; and later. However, at the time of this writing (August 2018), &lt;a href=&quot;https://github.com/tc39/proposal-optional-catch-binding&quot;&gt;the proposal to support this&lt;/a&gt; has not yet been included into an ECMAScript standard, so this syntax may not work in other browsers.</source>
          <target state="translated">Firefox 58에서 예외가 사용되지 않는 경우 아래 코드와 같이 식별자를 생략 할 수 있습니다. 이것은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html&quot;&gt;TypeScript 2.5 이상&lt;/a&gt; 에서도 허용됩니다 . 그러나이 글을 쓰는 시점 (2018 년 8 월)에는 &lt;a href=&quot;https://github.com/tc39/proposal-optional-catch-binding&quot;&gt;이를 지원하기위한 제안이&lt;/a&gt; 아직 ECMAScript 표준에 포함되어 있지 않기 때문에이 구문은 다른 브라우저에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1730c0df30cd5ba97c5141ded4e91edebdb5d504" translate="yes" xml:space="preserve">
          <source>In Firefox, &lt;code&gt;handler&lt;/code&gt; is only called from assignments in script, not from native code. For example, &lt;code&gt;window.watch('location', myHandler)&lt;/code&gt; will not call &lt;code&gt;myHandler&lt;/code&gt; if the user clicks a link to an anchor within the current document. However, &lt;code&gt;window.location += '#myAnchor'&lt;/code&gt; will call &lt;code&gt;myHandler&lt;/code&gt;.</source>
          <target state="translated">Firefox에서 &lt;code&gt;handler&lt;/code&gt; 는 기본 코드가 아닌 스크립트의 지정에서만 호출됩니다. 예를 들어, 사용자가 현재 문서 내에서 앵커에 대한 링크를 클릭하면 &lt;code&gt;window.watch('location', myHandler)&lt;/code&gt; 는 &lt;code&gt;myHandler&lt;/code&gt; 를 호출하지 않습니다 . 그러나 &lt;code&gt;window.location += '#myAnchor'&lt;/code&gt; 는 &lt;code&gt;myHandler&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="20427e6f530262dedd1f66d1091224f92b38be66" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 20&amp;micro;s in Firefox 59; in 60 it will be 2ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 기본 설정이 기본적으로 활성화되어 있으며 Firefox 59에서는 기본값이 20&amp;micro;s입니다. 60 분에는 2ms가됩니다.</target>
        </trans-unit>
        <trans-unit id="0af97ad69484c392ea6d2c53e11669126d6b3def" translate="yes" xml:space="preserve">
          <source>In Firefox, the &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; preference is enabled by default and defaults to 20us in Firefox 59; in 60 it will be 2ms.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.reduceTimerPrecision&lt;/code&gt; 환경 설정이 기본적으로 사용되며 Firefox 59에서는 기본값이 20us입니다. 60에서는 2ms입니다.</target>
        </trans-unit>
        <trans-unit id="2760c20e75f06135284b55f675e6ca0ea87f3385" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enable &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;, the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수 있으며 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9c7ba06ca4f441cd2e83c2b7bd2b5b0d766466d1" translate="yes" xml:space="preserve">
          <source>In Firefox, you can also enabled &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt;, the precision will be 100ms or the value of &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt;, whichever is larger.</source>
          <target state="translated">Firefox에서는 &lt;code&gt;privacy.resistFingerprinting&lt;/code&gt; 을 활성화 할 수 있으며 정밀도는 100ms 또는 &lt;code&gt;privacy.resistFingerprinting.reduceTimerPrecision.microseconds&lt;/code&gt; 중 더 큰 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5b8bed5863664df70343acda1590937b7118915f" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 11, numbers are rounded to 15 decimal digits. For example, &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; returns &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 11에서 숫자는 십진수 15 자리로 반올림됩니다. 예를 들어 &lt;code&gt;(1000000000000005).toLocaleString('en-US')&lt;/code&gt; 는 &lt;code&gt;&quot;1,000,000,000,000,010&quot;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="16ae8ad7d0e4ba6962d4b6f17b97388cf31cdc72" translate="yes" xml:space="preserve">
          <source>In Internet Explorer 8, this was only supported on DOM objects and with some non-standard behaviors. This was later fixed in Internet Explorer 9.</source>
          <target state="translated">Internet Explorer 8에서는 DOM 개체와 일부 비표준 동작에서만 지원되었습니다. 이것은 나중에 Internet Explorer 9에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4db24d0846e3ba3185a867d8668c69a5571ec019" translate="yes" xml:space="preserve">
          <source>In Internet Explorer, &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;for&lt;/code&gt; loop initializer does not create a separate variable for each loop iteration as defined by ES2015. Instead, it behaves as though the loop were wrapped in a scoping block with the &lt;code&gt;let&lt;/code&gt; immediately before the loop.</source>
          <target state="translated">Internet Explorer에서 &lt;code&gt;for&lt;/code&gt; 루프 이니셜 라이저 내의 &lt;code&gt;let&lt;/code&gt; 은 ES2015에 정의 된대로 각 루프 반복에 대해 별도의 변수를 생성하지 않습니다. 대신 루프 바로 앞에 &lt;code&gt;let&lt;/code&gt; 이 있는 범위 지정 블록에 루프가 래핑 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a5615497b68ccaa1ea32d698e965d876cea2548f" translate="yes" xml:space="preserve">
          <source>In JSON the values can only be strings, numbers, arrays, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or another (JSON) object.</source>
          <target state="translated">JSON에서 값은 문자열, 숫자, 배열, &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 다른 (JSON) 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="668b19b6452d0e28e81f530219de59631b89f0c9" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;s are not iterable unless they implement the &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt;. Therefore, you cannot use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip;of &lt;/a&gt;to iterate over the properties of an object.</source>
          <target state="translated">JavaScript에서 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt; 을 구현하지 않으면 반복 할 수 없습니다 . 따라서 객체의 속성을 반복 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;하는&lt;/a&gt; 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="895cd1421cbf51353ea473367f38e162aabe3974" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;a href=&quot;../global_objects/object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;s are not iterable unless they implement the &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;iterable protocol&lt;/a&gt;. Therefore, you cannot use &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip;of &lt;/a&gt;to iterate over the properties of an object.</source>
          <target state="translated">JavaScript에서 &lt;a href=&quot;../global_objects/object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../iteration_protocols#The_iterable_protocol&quot;&gt;반복 가능한 프로토콜&lt;/a&gt; 을 구현하지 않는 한 반복 할 수 없습니다 . 따라서 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement&quot;&gt;for&amp;hellip; of&lt;/a&gt; 를 사용하여 개체의 속성을 반복 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2855ac845af4473bd3a6be21040f1c7e0ad7b25b" translate="yes" xml:space="preserve">
          <source>In JavaScript, a setter can be used to execute a function whenever a specified property is attempted to be changed. Setters are most often used in conjunction with getters to create a type of pseudo-property. It is not possible to simultaneously have a setter on a property that holds an actual value.</source>
          <target state="translated">JavaScript에서는 지정된 속성을 변경하려고 할 때마다 setter를 사용하여 함수를 실행할 수 있습니다. 세터는 의사 속성 유형을 생성하기 위해 게터와 함께 가장 자주 사용됩니다. 실제 값을 보유한 속성에 세터를 동시에 가질 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca543fb85472cc8f29fc43d21952496053e3fecd" translate="yes" xml:space="preserve">
          <source>In JavaScript, function parameters default to &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. However, it's often useful to set a different default value. This is where default parameters can help.</source>
          <target state="translated">JavaScript에서 함수 매개 변수는 기본적으로 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 그러나 다른 기본값을 설정하는 것이 유용한 경우가 많습니다. 여기에서 기본 매개 변수가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19c8d5903929df29ffd31d91bc12841578c097c" translate="yes" xml:space="preserve">
          <source>In JavaScript, function parameters default to &lt;code&gt;&lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;. However, it's often useful to set a different default value. This is where default parameters can help.</source>
          <target state="translated">JavaScript에서 함수 매개 변수의 기본값은 &lt;code&gt;&lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 입니다. 그러나 종종 다른 기본값을 설정하는 것이 유용합니다. 기본 매개 변수가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20f27b3f1c13809f77edbf8f97737045dcbcf21" translate="yes" xml:space="preserve">
          <source>In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. In brief, they are &lt;code&gt;&lt;a href=&quot;global_objects/function&quot;&gt;Function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">JavaScript에서 함수는 다른 개체와 마찬가지로 속성과 메서드를 가질 수 있기 때문에 일류 개체입니다. 다른 객체와 구별되는 것은 함수를 호출 할 수 있다는 것입니다. 간단히 말해서 그것들은 &lt;code&gt;&lt;a href=&quot;global_objects/function&quot;&gt;Function&lt;/a&gt;&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0482de27c3e98ed79056a4c8e3487f1d9c7e2eb4" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are several reduce functions:</source>
          <target state="translated">JavaScript에는 몇 가지 축소 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e500e271dd9c768e0229c1f8cd060c64d5a885f" translate="yes" xml:space="preserve">
          <source>In JavaScript, we can do this with the following:</source>
          <target state="translated">JavaScript에서는 다음과 같이이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67dd1e314b8d816c5d9c9ed86c33a7c3051041e8" translate="yes" xml:space="preserve">
          <source>In Promises</source>
          <target state="translated">약속에서</target>
        </trans-unit>
        <trans-unit id="8753023eb7cfee3b18013db421fe39f22ac9cfb7" translate="yes" xml:space="preserve">
          <source>In UTF-16, the most common characters can be represented by a single 16-bit value (i.e. a code unit). However, this set of characters, known as the Base Multilingual Plane (BMP), is only &lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;17&lt;/sub&gt;&lt;sup&gt;th&lt;/sup&gt; of the total addressable Unicode code points. The remaining code points, in the range of &lt;code&gt;65536&lt;/code&gt; (&lt;code&gt;0x010000&lt;/code&gt;) to &lt;code&gt;1114111&lt;/code&gt; (&lt;code&gt;0x10FFFF&lt;/code&gt;) are known as supplementary characters. In UTF-16, supplementary characters are represented by two 16-bit code units, known as surrogates, that were reserved for this purpose. A valid combination of two surrogates used to represent a supplementary character is known as a surrogate pair.</source>
          <target state="translated">UTF-16에서 가장 일반적인 문자는 단일 16 비트 값 (예 : 코드 단위)으로 표현 될 수 있습니다. 그러나, 언어 자료의 평면 (BMP)으로 알려진 문자 세트는, 단지 인 &lt;sup&gt;1&lt;/sup&gt; / &lt;sub&gt;17 &lt;/sub&gt;&lt;sup&gt;일&lt;/sup&gt; 총 드레서 유니 코드 코드 포인트. &lt;code&gt;65536&lt;/code&gt; ( &lt;code&gt;0x010000&lt;/code&gt; )에서 &lt;code&gt;1114111&lt;/code&gt; ( &lt;code&gt;0x10FFFF&lt;/code&gt; ) 범위의 나머지 코드 포인트 는 보충 문자로 알려져 있습니다. UTF-16에서 보조 문자는이 목적을 위해 예약 된 두 개의 16 비트 코드 단위 (대리자)로 표시됩니다. 보충 문자를 나타내는 데 사용되는 두 개의 서로 게이트의 유효한 조합을 서로 게이트 쌍이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3af0213442e56d88e4f08027d4396f1d413cc06e" translate="yes" xml:space="preserve">
          <source>In Unicode, two sequences of code points are compatible if they represent the same abstract characters, and should be treated alike in some &amp;mdash; but not necessarily all &amp;mdash; applications.</source>
          <target state="translated">유니 코드에서 코드 포인트의 두 시퀀스는 동일한 추상 문자를 나타내는 경우 호환되며 일부 (반드시 전부는 아님) 응용 프로그램에서 동일하게 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06fcf052ca7ee2994caca99f7c2a53bdfa453a22" translate="yes" xml:space="preserve">
          <source>In Unicode, two sequences of code points have canonical equivalence if they represent the same abstract characters, and should always have the same visual appearance and behavior (for example, they should always be sorted in the same way).</source>
          <target state="translated">유니 코드에서 코드 포인트의 두 시퀀스는 동일한 추상 문자를 나타내는 경우 표준 동등성을 가지며 항상 동일한 시각적 모양과 동작을 가져야합니다 (예 : 항상 동일한 방식으로 정렬되어야 함).</target>
        </trans-unit>
        <trans-unit id="30ccea940dd72f9de64442358a3ee98e6136515f" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop, it jumps to the update expression.</source>
          <target state="translated">A의 &lt;a href=&quot;for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프, 그것은 업데이트 표현으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f0090629de3eb7e932efc2299ea2b0e11274be76" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; loop, it jumps back to the condition.</source>
          <target state="translated">A의 &lt;a href=&quot;while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 루프, 그것은 다시 상태로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="802ad80650674fefbc5baab939de5d45ff49c037" translate="yes" xml:space="preserve">
          <source>In a case where you want to store an object created by your user and allowing it to be restored even after the browser has been closed, the following example is a model for the applicability of &lt;code&gt;JSON.stringify()&lt;/code&gt;:</source>
          <target state="translated">사용자가 만든 객체를 저장하고 브라우저를 닫은 후에도 객체를 복원 할 수 있도록하려는 경우 다음 예제는 &lt;code&gt;JSON.stringify()&lt;/code&gt; 의 적용 가능성에 대한 모델입니다 .</target>
        </trans-unit>
        <trans-unit id="b974b8e0c8cc3adb8992389d2d0a1cd08b75c03c" translate="yes" xml:space="preserve">
          <source>In a circular structure like the following</source>
          <target state="translated">다음과 같은 원형 구조에서</target>
        </trans-unit>
        <trans-unit id="9a9eae68242ed66a24716ccc35563a64f014c279" translate="yes" xml:space="preserve">
          <source>In a concise body, only an expression is specified, which becomes the implicit return value. In a block body, you must use an explicit &lt;code&gt;return&lt;/code&gt; statement.</source>
          <target state="translated">간결한 본문에는 식만 지정되어 암시 적 반환 값이됩니다. 블록 본문에서 명시적인 &lt;code&gt;return&lt;/code&gt; 문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4f1b8f09e11f544c05027c4ef2b7cb80ca9f74d" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom array &lt;code&gt;MyArray&lt;/code&gt;), the &lt;code&gt;MyArray&lt;/code&gt; species is the &lt;code&gt;MyArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Array&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 배열 &lt;code&gt;MyArray&lt;/code&gt; )에서 &lt;code&gt;MyArray&lt;/code&gt; 종은 &lt;code&gt;MyArray&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;Array&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6e2e091bde1b1e25306a26d58b0ccc4c15bee3" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom array buffer &lt;code&gt;MyArrayBuffer&lt;/code&gt;), the &lt;code&gt;MyArrayBuffer&lt;/code&gt; species is the &lt;code&gt;MyArrayBuffer&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;ArrayBuffer&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 배열 버퍼 &lt;code&gt;MyArrayBuffer&lt;/code&gt; )에서 &lt;code&gt;MyArrayBuffer&lt;/code&gt; 종은 &lt;code&gt;MyArrayBuffer&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;ArrayBuffer&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8676f845dcd23c9b49f4af2f5389c64e7e8218ba" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom map &lt;code&gt;MyMap&lt;/code&gt;), the &lt;code&gt;MyMap&lt;/code&gt; species is the &lt;code&gt;MyMap&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Map&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 객체 (예 : 사용자 지정 맵 &lt;code&gt;MyMap&lt;/code&gt; )에서 &lt;code&gt;MyMap&lt;/code&gt; 종은 &lt;code&gt;MyMap&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 상위 &lt;code&gt;Map&lt;/code&gt; 객체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a21922d4d45a039d44b74194264a3b6620d0aa9" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom regexp &lt;code&gt;MyRegExp&lt;/code&gt;), the &lt;code&gt;MyRegExp&lt;/code&gt; species is the &lt;code&gt;MyRegExp&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;RegExp&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 regexp &lt;code&gt;MyRegExp&lt;/code&gt; )에서 &lt;code&gt;MyRegExp&lt;/code&gt; 종은 &lt;code&gt;MyRegExp&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;RegExp&lt;/code&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1c37cca7fcf5c973f743b17eb0dd855d1eeaf6f" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom set &lt;code&gt;MySet&lt;/code&gt;), the &lt;code&gt;MySet&lt;/code&gt; species is the &lt;code&gt;MySet&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return parent &lt;code&gt;Set&lt;/code&gt; objects in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 집합 &lt;code&gt;MySet&lt;/code&gt; )에서 &lt;code&gt;MySet&lt;/code&gt; 종은 &lt;code&gt;MySet&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;code&gt;Set&lt;/code&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1133b3da65f4298a37b3e1fc081e7c925554e075" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom typed array &lt;code&gt;MyTypedArray&lt;/code&gt;), the &lt;code&gt;MyTypedArray&lt;/code&gt; species is the &lt;code&gt;MyTypedArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return a parent &lt;a href=&quot;../typedarray#TypedArray_objects&quot;&gt;typed array&lt;/a&gt; object in your derived class methods:</source>
          <target state="translated">파생 컬렉션 개체 (예 : 사용자 지정 형식 배열 &lt;code&gt;MyTypedArray&lt;/code&gt; )에서 &lt;code&gt;MyTypedArray&lt;/code&gt; 종은 &lt;code&gt;MyTypedArray&lt;/code&gt; 생성자입니다. 그러나 파생 클래스 메서드에서 부모 &lt;a href=&quot;../typedarray#TypedArray_objects&quot;&gt;형식의 배열&lt;/a&gt; 개체 를 반환하기 위해 이것을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ce247dad140e8fba2d68c52d0b5deed3560020a" translate="yes" xml:space="preserve">
          <source>In a derived collection object (e.g. your custom typed array &lt;code&gt;MyTypedArray&lt;/code&gt;), the &lt;code&gt;MyTypedArray&lt;/code&gt; species is the &lt;code&gt;MyTypedArray&lt;/code&gt; constructor. However, you might want to overwrite this, in order to return a parent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects&quot;&gt;typed array&lt;/a&gt; object in your derived class methods:</source>
          <target state="translated">파생 된 컬렉션 개체 (예 : 사용자 지정 형식 배열 &lt;code&gt;MyTypedArray&lt;/code&gt; )에서 &lt;code&gt;MyTypedArray&lt;/code&gt; 종은 &lt;code&gt;MyTypedArray&lt;/code&gt; 생성자입니다. 그러나 부모 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects&quot;&gt;유형 배열&lt;/a&gt; 을 반환하기 위해 이것을 덮어 쓸 수 있습니다. 파생 클래스 메서드에서 개체 .</target>
        </trans-unit>
        <trans-unit id="350adacc4d9e715c786318e8468e47b1e9d05e5a" translate="yes" xml:space="preserve">
          <source>In a module &lt;code&gt;my-module.js&lt;/code&gt;, we could include the following code:</source>
          <target state="translated">&lt;code&gt;my-module.js&lt;/code&gt; 모듈에서 에 다음 코드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="340c77fb144b30a4542ea8a0c0d5a2ac8c4b516d" translate="yes" xml:space="preserve">
          <source>In a non-constructor context (i.e., without the &lt;a href=&quot;../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator), &lt;code&gt;Number&lt;/code&gt; can be used to perform a type conversion.</source>
          <target state="translated">생성자가 아닌 컨텍스트에서 (즉, &lt;a href=&quot;../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자가 없는 경우 ) &lt;code&gt;Number&lt;/code&gt; 를 사용하여 유형 변환을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dda02a1acb072f90af69f2907af38348fc815a" translate="yes" xml:space="preserve">
          <source>In a related circumstance, what if you actually wanted your &lt;code&gt;Date()&lt;/code&gt; function to be able to be called from the code inside &lt;code&gt;Function()&lt;/code&gt;. Should you just take the easy way out and fall back to &lt;code&gt;eval()&lt;/code&gt;? No! Never. Instead try the approach below.</source>
          <target state="translated">관련 상황에서 실제로 &lt;code&gt;Date()&lt;/code&gt; 함수가 &lt;code&gt;Function()&lt;/code&gt; 내부의 코드에서 호출 될 수 있도록하려면 어떻게해야합니까 ? 쉬운 방법을 택하고 &lt;code&gt;eval()&lt;/code&gt; 돌아 가야 합니까? 아니! 못. 대신 아래 접근 방식을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="810fedbd7d3efd9acd82311336fa539410213dc0" translate="yes" xml:space="preserve">
          <source>In a related circumstance, what if you actually wanted your &lt;code&gt;Date&lt;/code&gt; function to be able to be called from the code inside &lt;code&gt;Function()&lt;/code&gt;. Should you just wimp out and fall back to &lt;code&gt;eval()&lt;/code&gt;? Absolutely not, never ever. Instead try the approach below.</source>
          <target state="translated">관련 상황에서 실제로 &lt;code&gt;Date&lt;/code&gt; 함수를 &lt;code&gt;Function()&lt;/code&gt; 내부의 코드에서 호출 할 수있게하려면 어떻게해야합니까 ? 그냥 겁 내고 &lt;code&gt;eval()&lt;/code&gt; 넘어 가야 합니까? 절대로 절대로 아닙니다. 대신 아래 방법을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b2fc3d6faac50dc84e09287729aea3901d7164ff" translate="yes" xml:space="preserve">
          <source>In a word: Don't.</source>
          <target state="translated">한마디로 :하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3a3bc3b6e0682977940132c5c77dc0be406db238" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;white space&lt;/a&gt; characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;automatic semicolon insertion&lt;/a&gt;. Line terminators are matched by the &lt;strong&gt;\s&lt;/strong&gt; class in &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;공백&lt;/a&gt; 문자 외에도 줄 종결 문자를 사용하여 소스 텍스트의 가독성을 향상시킵니다. 그러나 어떤 경우에는 금지 된 곳이 몇 군데 있기 때문에 줄 종결자가 JavaScript 코드 실행에 영향을 미칠 수 있습니다. 줄 종결자는 &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;자동 세미콜론 삽입&lt;/a&gt; 프로세스에도 영향을줍니다 . 줄 종결자는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;정규식&lt;/a&gt; 에서 &lt;strong&gt;\ s&lt;/strong&gt; 클래스 와 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="45902b9c216bd387d2fe70315207b8d21f3b38a8" translate="yes" xml:space="preserve">
          <source>In addition to methods to read and alter individual components of the local date and time (such as &lt;a href=&quot;date/getday&quot;&gt;&lt;code&gt;getDay()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/sethours&quot;&gt;&lt;code&gt;setHours()&lt;/code&gt;&lt;/a&gt;), there are also versions of the same methods that read and manipulate the date and time using UTC (such as &lt;a href=&quot;date/getutcday&quot;&gt;&lt;code&gt;getUTCDay()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/setutchours&quot;&gt;&lt;code&gt;setUTCHours()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">로컬 날짜 및 시간의 개별 구성 요소 (예 : &lt;a href=&quot;date/getday&quot;&gt; &lt;code&gt;getDay()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/sethours&quot;&gt; &lt;code&gt;setHours()&lt;/code&gt; &lt;/a&gt; ) 를 읽고 변경하는 메서드 외에도 UTC를 사용하여 날짜 및 시간을 읽고 조작하는 동일한 메서드 버전 (예 : &lt;a href=&quot;date/getutcday&quot;&gt; &lt;code&gt;getUTCDay()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/setutchours&quot;&gt; &lt;code&gt;setUTCHours()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eae3ca63d02d68155e6bfd686d4025760d2e921e" translate="yes" xml:space="preserve">
          <source>In addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;automatic semicolon insertion&lt;/a&gt;. Line terminators are matched by the &lt;strong&gt;\s&lt;/strong&gt; class in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;.</source>
          <target state="translated">공백 문자 외에도 줄 종결 자 문자를 사용하여 소스 텍스트의 가독성을 향상시킵니다. 그러나 일부 경우에는 라인 터미네이터가 JavaScript 코드 실행에 영향을 줄 수 있습니다. 라인 터미네이터는 &lt;a href=&quot;#Automatic_semicolon_insertion&quot;&gt;자동 세미콜론 삽입&lt;/a&gt; 프로세스에도 영향을줍니다 . 줄 종결자는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;정규식&lt;/a&gt; 에서 &lt;strong&gt;\ s&lt;/strong&gt; 클래스 와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="d1dbbf23ea13be77ce53036651bf06faa4f98b65" translate="yes" xml:space="preserve">
          <source>In addition to your own symbols, JavaScript has some built-in symbols which represent internal language behaviors which were not exposed to developers in ECMAScript 5 and before. These symbols can be accessed using the following properties:</source>
          <target state="translated">JavaScript에는 자체 심볼 외에도 ECMAScript 5 및 그 이전의 개발자에게 노출되지 않은 내부 언어 동작을 나타내는 일부 내장 심볼이 있습니다. 이러한 기호는 다음 속성을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="541fce84d020f8e809b1424cc43c2d8605b35d86" translate="yes" xml:space="preserve">
          <source>In addition, since true iterables cannot be polyfilled, this implementation does not support generic iterables as defined in the 6&lt;sup&gt;th&lt;/sup&gt; Edition of ECMA-262.</source>
          <target state="translated">또한 진정한 이터 러블은 폴리 필 할 수 없기 때문에이 구현은 ECMA-262 의 6 &lt;sup&gt;번째&lt;/sup&gt; 에디션에 정의 된 일반 이터 러블을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="772f53b7684325c70c59fb803ea949efc447df73" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;global_objects/string/raw&quot;&gt;&lt;code&gt;String.raw()&lt;/code&gt;&lt;/a&gt; method exists to create raw strings just like the default template function and string concatenation would create.</source>
          <target state="translated">또한 &lt;a href=&quot;global_objects/string/raw&quot;&gt; &lt;code&gt;String.raw()&lt;/code&gt; &lt;/a&gt; 메서드는 기본 템플릿 함수 및 문자열 연결과 같은 원시 문자열을 만들기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="afdac2e1c883f1486c41d87b72385f76020d0b90" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;global_objects/string/raw&quot;&gt;&lt;code&gt;String.raw()&lt;/code&gt;&lt;/a&gt; method exists to create raw strings&amp;mdash;just like the default template function and string concatenation would create.</source>
          <target state="translated">또한 &lt;a href=&quot;global_objects/string/raw&quot;&gt; &lt;code&gt;String.raw()&lt;/code&gt; &lt;/a&gt; 메서드는 기본 템플릿 함수 및 문자열 연결이 만드는 것처럼 원시 문자열을 만들기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="dc6c8d3bc5587fba3a2992288ddc497a933c9e1d" translate="yes" xml:space="preserve">
          <source>In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:</source>
          <target state="translated">또한 코드를 주석에 래핑하여 코드가 실행되지 않도록 코드를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3895a9d4c10daddb44b0baf3cea41b98e617fe5c" translate="yes" xml:space="preserve">
          <source>In all cases, the returned promise is fulfilled with an array containing &lt;strong&gt;all &lt;/strong&gt;the values of the &lt;var&gt;iterable&lt;/var&gt; passed as argument (also non-promise values).</source>
          <target state="translated">모든 경우에, 리턴 된 약속은 인수로 전달 된 &lt;var&gt;iterable&lt;/var&gt; 의 &lt;strong&gt;모든&lt;/strong&gt; 값을 포함하는 배열 (약속이 아닌 값)로 이행됩니다.</target>
        </trans-unit>
        <trans-unit id="c81b508fa4aa4f5e76e7a5fb07f3df97a3e6e267" translate="yes" xml:space="preserve">
          <source>In all other cases, a resolving Promise is returned. In the following example, the first &lt;code&gt;then()&lt;/code&gt; will return &lt;code&gt;42&lt;/code&gt; wrapped in a resolving Promise even though the previous Promise in the chain was rejected.</source>
          <target state="translated">다른 모든 경우에는 해결 약속이 반환됩니다. 다음 예제에서 첫 번째 &lt;code&gt;then()&lt;/code&gt; 은 체인의 이전 Promise가 거부 되었음에도 불구하고 해결 Promise에 래핑 된 &lt;code&gt;42&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8f2e12a377e763cd095116ed09fef665af7281bf" translate="yes" xml:space="preserve">
          <source>In all other cases, a resolving Promise is returned. In the following example, the first &lt;code&gt;then()&lt;/code&gt; will return &lt;code&gt;42&lt;/code&gt; wrapped resolving Promise even though the previous Promise in the chain was rejected.</source>
          <target state="translated">다른 모든 경우에는 해결 약속이 반환됩니다. 다음 예에서 첫 번째 &lt;code&gt;then()&lt;/code&gt; 은 체인의 이전 약속이 거부 된 경우에도 &lt;code&gt;42&lt;/code&gt; 개의 랩핑 된 약속을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4f386d0fd63e7041445027553d8387adba4f48a3" translate="yes" xml:space="preserve">
          <source>In an ECMAScript 2016 environment which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does increment for an incrementing variable automatically (if the character warrants it in being a surrogate pair).</source>
          <target state="translated">구조화되지 않은 할당을 허용하는 ECMAScript 2016 환경에서 다음은 증분 변수에 대해 자동으로 증가한다는 점에서보다 간결하고 다소 유연한 대안입니다 (캐릭터가 대리 쌍이라는 것을 보증하는 경우).</target>
        </trans-unit>
        <trans-unit id="b003a314ef1e4fb418bf66b8bc466ac14403b108" translate="yes" xml:space="preserve">
          <source>In an ECMAScript 2016 environment which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).</source>
          <target state="translated">비 구조적 할당을 허용하는 ECMAScript 2016 환경에서 다음은 증분 변수를 자동으로 증분한다는 점에서보다 간결하고 다소 유연한 대안입니다 (문자가 대리 쌍으로 보증하는 경우).</target>
        </trans-unit>
        <trans-unit id="6ae1d411c5185e7a3f1b56084729d3af21f20494" translate="yes" xml:space="preserve">
          <source>In an inline event handler</source>
          <target state="translated">인라인 이벤트 핸들러에서</target>
        </trans-unit>
        <trans-unit id="15a234979acf5c85ed72ab3a44cfa7cf0c039e37" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, &lt;code&gt;DateTimeFormat&lt;/code&gt; uses the default locale and default options.</source>
          <target state="translated">로캘을 지정하지 않고 기본적으로 사용하는 경우 &lt;code&gt;DateTimeFormat&lt;/code&gt; 은 기본 로캘 및 기본 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c8fca8d2d4d72fbc7ff12349b16baad5284d084" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, a formatted string in the default locale and with default options is returned.</source>
          <target state="translated">로케일을 지정하지 않고 기본적으로 사용하면 기본 로케일 및 기본 옵션이있는 형식화 된 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e30dc2f73ac6e65084e81c106ff21218b79a2446" translate="yes" xml:space="preserve">
          <source>In basic use without specifying a locale, a formatted string in the default locale and with default options is returned. This is useful to distinguish between singular and plural forms, e.g. &quot;dog&quot; and &quot;dogs&quot;.</source>
          <target state="translated">로케일을 지정하지 않고 기본적으로 사용하면 기본 로케일 및 기본 옵션이있는 형식화 된 문자열이 리턴됩니다. 이는 단수형과 복수형, 예를 들어 &quot;개&quot;와 &quot;개&quot;를 구별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4e6edcf1e99e27f4a3c003689651a55d0701af0f" translate="yes" xml:space="preserve">
          <source>In both, &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt; and sloppy mode, a call to &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; throws when adding a new property to a non-extensible object.</source>
          <target state="translated">&lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 와 조잡한 모드 모두에서 확장 할 수없는 객체에 새 속성을 추가하면 &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c5b208d6a1696deaa27e5631e305def887a5f0d" translate="yes" xml:space="preserve">
          <source>In browser versions supporting named capturing groups, will be an object whose keys are the used group names, and whose values are the matched portions (&lt;code&gt;undefined&lt;/code&gt; if not matched).</source>
          <target state="translated">명명 된 캡처 링 그룹을 지원하는 브라우저 버전에서는 키가 사용 된 그룹 이름이고 값이 일치하는 부분 ( 일치하지 않으면 &lt;code&gt;undefined&lt;/code&gt; 않음) 인 객체가됩니다 .</target>
        </trans-unit>
        <trans-unit id="212201f4cd8f19efb2a09bdffc69dc9cf7ec33b3" translate="yes" xml:space="preserve">
          <source>In browsers which support named capturing groups, the following code captures &quot;&lt;code&gt;fox&lt;/code&gt;&quot; or &quot;&lt;code&gt;cat&lt;/code&gt;&quot; into a group named &quot;&lt;code&gt;animal&lt;/code&gt;&quot;:</source>
          <target state="translated">명명 된 캡처 그룹을 지원하는 브라우저에서 다음 코드는 &quot; &lt;code&gt;fox&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;cat&lt;/code&gt; &quot;을 &quot; &lt;code&gt;animal&lt;/code&gt; &quot; 이라는 그룹으로 캡처합니다 .</target>
        </trans-unit>
        <trans-unit id="2fec9e70a7a8e5a0b462b870bc9aad4fb731e521" translate="yes" xml:space="preserve">
          <source>In case of an error, for example if a property is non-writable, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised, and the &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; object is changed if any properties are added before the error is raised.</source>
          <target state="translated">오류가 발생한 경우 (예 : 속성이 쓰기 불가능한 경우) &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 하고 오류가 발생하기 전에 속성이 추가되면 &lt;code&gt;&lt;var&gt;target&lt;/var&gt;&lt;/code&gt; 객체가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5c53b39ddf5eb1e541cbcb2fd25d92feed9aab69" translate="yes" xml:space="preserve">
          <source>In case of an error, for example if a property is non-writable, a &lt;a href=&quot;../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised, and the &lt;code&gt;target&lt;/code&gt; object can be changed if any properties are added before error is raised.</source>
          <target state="translated">예를 들어 속성을 쓸 수없는 경우와 같은 오류가 발생하면 &lt;a href=&quot;../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생하고 오류가 발생하기 전에 속성이 추가되면 &lt;code&gt;target&lt;/code&gt; 개체가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2715483284a25ba548ae565967fe75b81647c6bb" translate="yes" xml:space="preserve">
          <source>In certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backticked template, it is simple to allow inner backticks simply by using them inside a placeholder &lt;code&gt;${ }&lt;/code&gt; within the template.</source>
          <target state="translated">어떤 경우에는 템플릿을 중첩하는 것이 구성 가능한 문자열을 갖는 가장 쉬운 (그리고 아마도 더 읽기 쉬운) 방법입니다. 백틱이있는 템플릿 내에서 단순히 템플릿 내의 자리 표시 자 &lt;code&gt;${ }&lt;/code&gt; 내에서 내부 백틱을 사용하여 내부 백틱을 허용하는 것은 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="185b559f3c0aaf526e6b24fa70557e54bd43808c" translate="yes" xml:space="preserve">
          <source>In certain times, nesting a template is the easiest and perhaps more readable way to have configurable strings. Within a backticked template it is simple to allow inner backticks simply by using them inside a placeholder &lt;code&gt;${ }&lt;/code&gt; within the template. For instance, if condition a is true: then return this templated literal.</source>
          <target state="translated">어떤 경우에는 템플릿 중첩이 구성 가능한 문자열을 갖는 가장 쉽고 읽기 쉬운 방법입니다. 백틱 템플릿 내에서 템플릿 내의 자리 표시 자 &lt;code&gt;${ }&lt;/code&gt; 안에서 내부 백틱을 사용하여 간단하게 내부 백틱을 허용 할 수 있습니다. 예를 들어, 조건 a가 true 인 경우이 템플릿 리터럴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4db1a326096311ea6af1c3fb975c7c9930e3121d" translate="yes" xml:space="preserve">
          <source>In class constructors, &lt;code&gt;new.target&lt;/code&gt; refers to the constructor that was directly invoked by &lt;code&gt;new&lt;/code&gt;. This is also the case if the constructor is in a parent class and was delegated from a child constructor.</source>
          <target state="translated">클래스 생성자에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;code&gt;new&lt;/code&gt; 에서 직접 호출 한 생성자를 나타냅니다 . 생성자가 부모 클래스에 있고 자식 생성자로부터 위임 된 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6bdb1b0d5feb35f9fbe77dd15e2d3235928fcdf4" translate="yes" xml:space="preserve">
          <source>In class constructors, it refers to the constructed class.</source>
          <target state="translated">클래스 생성자에서는 생성 된 클래스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="94af82422eceede92c75ba324542543e93fcf1e0" translate="yes" xml:space="preserve">
          <source>In code using XPCOM &lt;code&gt;instanceof&lt;/code&gt; has special effect: &lt;code&gt;obj instanceof &lt;/code&gt;&lt;em&gt;&lt;code&gt;xpcomInterface&lt;/code&gt;&lt;/em&gt; (e.g. &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt;) calls &lt;code&gt;obj.QueryInterface(&lt;em&gt;xpcomInterface&lt;/em&gt;)&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt; if QueryInterface succeeded. A side effect of such call is that you can use &lt;em&gt;&lt;code&gt;xpcomInterface&lt;/code&gt;&lt;/em&gt;'s properties on &lt;code&gt;obj&lt;/code&gt; after a successful &lt;code&gt;instanceof&lt;/code&gt; test. Unlike standard JavaScript globals, the test &lt;code&gt;obj instanceof xpcomInterface&lt;/code&gt; works as expected even if &lt;code&gt;obj&lt;/code&gt; is from a different scope.</source>
          <target state="translated">XPCOM &lt;code&gt;instanceof&lt;/code&gt; 를 사용하는 코드에서 특별한 효과가 있습니다 : &lt;code&gt;obj instanceof &lt;/code&gt; &lt;em&gt; &lt;code&gt;xpcomInterface&lt;/code&gt; &lt;/em&gt; (예 : &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt; )는 &lt;code&gt;obj.QueryInterface(&lt;em&gt;xpcomInterface&lt;/em&gt;)&lt;/code&gt; 호출 하고 QueryInterface가 성공하면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 이러한 호출의 부작용은 테스트 의 성공적인 &lt;code&gt;instanceof&lt;/code&gt; 후에 &lt;code&gt;obj&lt;/code&gt; 에서 &lt;em&gt; &lt;code&gt;xpcomInterface&lt;/code&gt; &lt;/em&gt; 속성을 사용할 수 있다는 것 입니다. 표준 JavaScript 전역과 달리 &lt;code&gt;obj instanceof xpcomInterface&lt;/code&gt; 의 테스트 obj 인스턴스 는 &lt;code&gt;obj&lt;/code&gt; 가 다른 범위에 있더라도 예상대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="14cfe9e8018b79bf958a062759f1007e85f4498c" translate="yes" xml:space="preserve">
          <source>In code using XPCOM, &lt;code&gt;instanceof&lt;/code&gt; has special effect: &lt;code&gt;&lt;var&gt;obj&lt;/var&gt; instanceof &lt;var&gt;xpcomInterface&lt;/var&gt;&lt;/code&gt; (e.g. &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt;) calls &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;.QueryInterface(&lt;var&gt;xpcomInterface&lt;/var&gt;)&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;QueryInterface&lt;/code&gt; succeeded.</source>
          <target state="translated">XPCOM을 사용하는 코드에서 &lt;code&gt;instanceof&lt;/code&gt; 는 특별한 효과가 있습니다. &lt;code&gt;&lt;var&gt;obj&lt;/var&gt; instanceof &lt;var&gt;xpcomInterface&lt;/var&gt;&lt;/code&gt; (예 : &lt;code&gt;Components.interfaces.nsIFile&lt;/code&gt; )는 &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;.QueryInterface(&lt;var&gt;xpcomInterface&lt;/var&gt;)&lt;/code&gt; 호출 하고 &lt;code&gt;QueryInterface&lt;/code&gt; 가 성공 하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="992fc64c413d9c88cc713416bf184f970d9fbfac" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isfinite&quot;&gt;&lt;code&gt;isFinite()&lt;/code&gt;&lt;/a&gt; function, this method doesn't first convert the parameter to a number. This means only values of the type number &lt;em&gt;and&lt;/em&gt; are finite return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isfinite&quot;&gt; &lt;code&gt;isFinite()&lt;/code&gt; &lt;/a&gt; 함수와 비교 하여이 메서드는 먼저 매개 변수를 숫자로 변환하지 않습니다. 이 방법은 타입 번호의 값 &lt;em&gt;과&lt;/em&gt; 유한 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a613e3bd8d9172c0deeee7a9b7b65c63525ed0bb" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isfinite&quot;&gt;&lt;code&gt;isFinite()&lt;/code&gt;&lt;/a&gt; function, this method doesn't forcibly convert the parameter to a number. This means only values of the type number, that are also finite, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isfinite&quot;&gt; &lt;code&gt;isFinite()&lt;/code&gt; &lt;/a&gt; 함수와 비교 하여이 메소드는 매개 변수를 강제로 숫자로 변환하지 않습니다. 이는 유형 번호의 값만, 유한 한 값만 &lt;code&gt;true&lt;/code&gt; 를 리턴 함을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d244f5107598de168b205e3c43fd027e6571c188" translate="yes" xml:space="preserve">
          <source>In comparison to the global &lt;a href=&quot;../isnan&quot;&gt;&lt;code&gt;isNaN()&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;Number.isNaN()&lt;/code&gt; doesn't suffer the problem of forcefully converting the parameter to a number. This means it is now safe to pass values that would normally convert to &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;, but aren't actually the same value as &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;. This also means that only values of the type number, that are also &lt;a href=&quot;../nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">전역 &lt;a href=&quot;../isnan&quot;&gt; &lt;code&gt;isNaN()&lt;/code&gt; &lt;/a&gt; 함수와 비교하여 &lt;code&gt;Number.isNaN()&lt;/code&gt; 은 매개 변수를 숫자로 강제 변환하는 문제를 겪지 않습니다. 즉, 일반적으로 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 으로 변환되는 값을 전달하는 것이 안전 하지만 실제로 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 과 동일한 값은 아닙니다 . 이것은 또한 유형 번호의 값, 즉 &lt;a href=&quot;../nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; 인 값만 &lt;code&gt;true&lt;/code&gt; 를 반환 함을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="8217e6b58b2edad9f5a6741e352a92ad99a7c0e8" translate="yes" xml:space="preserve">
          <source>In constructors, &lt;code&gt;new.target&lt;/code&gt; refers to the constructor that was invoked by &lt;a href=&quot;operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 에서 호출 한 생성자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f621dfa4be91ca91418c57854499d4ee4a81c259" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Sets&lt;/code&gt;, &lt;code&gt;WeakSets&lt;/code&gt; are &lt;strong&gt;collections of objects only&lt;/strong&gt; and not of arbitrary values of any type.</source>
          <target state="translated">대조적 &lt;code&gt;Sets&lt;/code&gt; , &lt;code&gt;WeakSets&lt;/code&gt; 이 있는 &lt;strong&gt;개체 만 모음&lt;/strong&gt; 이 아닌 임의의 종류의 임의의 값이.</target>
        </trans-unit>
        <trans-unit id="29612058b2a37d96155ca6d8e8846e19f5383f8e" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Symbol()&lt;/code&gt;, the &lt;code&gt;Symbol.for()&lt;/code&gt; function creates a symbol available in a global symbol registry list. &lt;code&gt;Symbol.for()&lt;/code&gt; does also not necessarily create a new symbol on every call, but checks first if a symbol with the given &lt;code&gt;key&lt;/code&gt; is already present in the registry. In that case, that symbol is returned. If no symbol with the given key is found, &lt;code&gt;Symbol.for()&lt;/code&gt; will create a new global symbol.</source>
          <target state="translated">대조적으로 &lt;code&gt;Symbol()&lt;/code&gt; 는 &lt;code&gt;Symbol.for()&lt;/code&gt; 함수는 전역 심볼 레지스트리 목록에서 사용할 수있는 기호를 작성합니다. &lt;code&gt;Symbol.for()&lt;/code&gt; 는 모든 호출에서 반드시 새 심볼을 만들 필요는 없지만 주어진 &lt;code&gt;key&lt;/code&gt; 가 있는 심볼 이 레지스트리에 이미 있는지 먼저 확인합니다 . 이 경우 해당 기호가 반환됩니다. 주어진 키를 가진 심볼이 없으면 &lt;code&gt;Symbol.for()&lt;/code&gt; 는 새로운 전역 심볼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2ff9ea516bcf681c13dab78eda856670cc61010b" translate="yes" xml:space="preserve">
          <source>In contrast to the &lt;a href=&quot;break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt; statement, &lt;code&gt;continue&lt;/code&gt; does not terminate the execution of the loop entirely: instead,</source>
          <target state="translated">&lt;a href=&quot;break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; 문과 달리 &lt;code&gt;continue&lt;/code&gt; 는 루프 실행을 완전히 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abde0a67e7f66ee66240fa3ae208e8af08646767" translate="yes" xml:space="preserve">
          <source>In dealing with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Constructor&quot;&gt;constructors&lt;/a&gt; it is possible to use the &lt;code&gt;let&lt;/code&gt; bindings to share one or more private members without using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Constructor&quot;&gt;생성자를&lt;/a&gt; 처리 할 때 &lt;code&gt;let&lt;/code&gt; 바인딩을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;클로저&lt;/a&gt; 를 사용하지 않고 하나 이상의 개인 멤버를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="add9606929e73b3d9b2d5274b0b0c6a25af99476" translate="yes" xml:space="preserve">
          <source>In depth analysis on delete</source>
          <target state="translated">삭제에 대한 심층 분석</target>
        </trans-unit>
        <trans-unit id="1ee02026d6da5c79915a450ae4a367bd8161a9d5" translate="yes" xml:space="preserve">
          <source>In following code, values yielded by &lt;code&gt;g1()&lt;/code&gt; are returned from &lt;code&gt;next()&lt;/code&gt; calls just like those which are yielded by &lt;code&gt;g2()&lt;/code&gt;.</source>
          <target state="translated">다음 코드에서 &lt;code&gt;g1()&lt;/code&gt; 의해 생성 된 값은 &lt;code&gt;g2()&lt;/code&gt; 의해 생성 된 것과 마찬가지로 &lt;code&gt;next()&lt;/code&gt; 호출 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a15b0c2b14bd2c1fe2943c815c7efbf0fce1279" translate="yes" xml:space="preserve">
          <source>In function calls like &lt;code&gt;f()&lt;/code&gt;, the &lt;code&gt;this&lt;/code&gt; value was the global object. In strict mode, it is now &lt;code&gt;undefined&lt;/code&gt;. When a function was called with &lt;code&gt;&lt;a href=&quot;../global_objects/function/call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../global_objects/function/apply&quot;&gt;apply&lt;/a&gt;&lt;/code&gt;, if the value was a primitive value, this one was boxed into an object (or the global object for &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;). In strict mode, the value is passed directly without conversion or replacement.</source>
          <target state="translated">같은 함수 호출에서 &lt;code&gt;f()&lt;/code&gt; 는 &lt;code&gt;this&lt;/code&gt; 값은 글로벌 개체였다. 엄격 모드에서는 이제 &lt;code&gt;undefined&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;../global_objects/function/call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../global_objects/function/apply&quot;&gt;apply&lt;/a&gt;&lt;/code&gt; 로 함수를 호출 할 때 값이 기본 값인 경우이 값은 객체 (또는 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 의 경우 전역 객체)에 상자로 표시되었습니다 . 엄격 모드에서는 값이 변환이나 교체없이 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb456854f7e12a1b6d3067042522e245c1c473c" translate="yes" xml:space="preserve">
          <source>In general, it is best not to add, modify, or remove properties from the object during iteration, other than the property currently being visited. There is no guarantee whether an added property will be visited, whether a modified property (other than the current one) will be visited before or after it is modified, or whether a deleted property will be visited before it is deleted.</source>
          <target state="translated">일반적으로 현재 방문중인 속성 이외의 반복 중에 객체에서 속성을 추가, 수정 또는 제거하지 않는 것이 가장 좋습니다. 추가 된 속성을 방문할지, 수정 된 속성 (현재 속성 이외의 속성)을 수정하기 전후에 방문할지 또는 삭제 된 속성을 삭제하기 전에 방문할지 여부는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="469cf6b2ef6e68adf3f920541f214faf833cd651" translate="yes" xml:space="preserve">
          <source>In math, you can write 2 &amp;times; (3 + 5) as 2*(3 + 5) or just 2(3 + 5).</source>
          <target state="translated">수학에서는 2 &amp;times; (3 + 5)를 2 * (3 + 5) 또는 2 (3 + 5)로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd4e3c69a66abeb7081b617a2e513e6ed402c377" translate="yes" xml:space="preserve">
          <source>In math, you can write 2 x (3 + 5) as 2*(3 + 5) or just 2(3 + 5). Using the latter will throw an error:</source>
          <target state="translated">수학에서는 2 x (3 + 5)를 2 * (3 + 5) 또는 2 (3 + 5)로 쓸 수 있습니다. 후자를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15f72587f05206c7a8bbb329e12777545b394d35" translate="yes" xml:space="preserve">
          <source>In modern browsers (JavaScript 1.8.5 / Firefox 4+), &lt;code&gt;undefined&lt;/code&gt; is a non-configurable, non-writable property per the ECMAScript 5 specification. Even when this is not the case, avoid overriding it.</source>
          <target state="translated">최신 브라우저 (JavaScript 1.8.5 / Firefox 4+)에서 &lt;code&gt;undefined&lt;/code&gt; 는 ECMAScript 5 사양에 따라 구성 할 수없고 쓸 수없는 속성입니다. 그렇지 않은 경우에도 무시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4e0d4934fe476d8eb4009f64ddad5959ccf4aadb" translate="yes" xml:space="preserve">
          <source>In modern browsers (JavaScript 1.8.5 / Firefox 4+), &lt;code&gt;undefined&lt;/code&gt; is a non-configurable, non-writable property, per the ECMAScript 5 specification. (Even when this is not the case, avoid overriding it.)</source>
          <target state="translated">최신 브라우저 (JavaScript 1.8.5 / Firefox 4+)에서 &lt;code&gt;undefined&lt;/code&gt; 는 ECMAScript 5 사양에 따라 구성 할 수없고 쓸 수없는 속성입니다. (이 경우가 아니더라도 재정의하지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="c6effb59d91f10a30d514644f887cd90896f02d7" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;String.raw()&lt;/code&gt; is used with template strings. The first syntax mentioned above is only rarely used, because the JavaScript engine will call this with proper arguments for you, (just like with other &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;tag functions&lt;/a&gt;).</source>
          <target state="translated">대부분의 경우 &lt;code&gt;String.raw()&lt;/code&gt; 는 템플릿 문자열과 함께 사용됩니다. 위에서 언급 한 첫 번째 구문은 JavaScript 엔진이 적절한 인수를 사용하여이를 호출하기 때문에 거의 사용되지 않습니다 (다른 &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;태그 함수&lt;/a&gt; 와 마찬가지로 ).</target>
        </trans-unit>
        <trans-unit id="5a29654e172b7c9185515aad6d728b59b008dcd2" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;String.raw()&lt;/code&gt; is used with template strings. The first syntax mentioned above is only rarely used, because the JavaScript engine will call this with proper arguments for you, just like with other &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;tag functions&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;String.raw()&lt;/code&gt; 는 템플릿 문자열과 함께 사용됩니다. 위에서 언급 한 첫 번째 구문은 다른 &lt;a href=&quot;../../template_literals#Tagged_template_literals&quot;&gt;태그 함수&lt;/a&gt; 와 마찬가지로 JavaScript 엔진이이를 적절한 인수로 호출하기 때문에 거의 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eb884e7d7586dde23b9e701c398786a65a36db9b" translate="yes" xml:space="preserve">
          <source>In most cases, the value of &lt;code&gt;this&lt;/code&gt; is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the &lt;a href=&quot;../global_objects/function/bind&quot;&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/a&gt; method to &lt;a href=&quot;this#The_bind_method&quot;&gt;set the value of a function's &lt;code&gt;this&lt;/code&gt; regardless of how it's called&lt;/a&gt;, and ES2015 introduced &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt; which don't provide their own &lt;code&gt;this&lt;/code&gt; binding (it retains the &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical context).</source>
          <target state="translated">대부분의 &lt;code&gt;this&lt;/code&gt; 값은 함수가 호출되는 방식 (런타임 바인딩)에 의해 결정됩니다. 실행 중 할당으로 설정할 수 없으며 함수가 호출 될 때마다 다를 수 있습니다. ES5는 도입 &lt;a href=&quot;../global_objects/function/bind&quot;&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;/a&gt; 하는 방법에 &lt;a href=&quot;this#The_bind_method&quot;&gt;함수의 값의 설정 &lt;code&gt;this&lt;/code&gt; 없이이 호출 방법&lt;/a&gt; 및 ES2015 도입 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;기능 화살표를&lt;/a&gt; 자신이 제공하지 않는 &lt;code&gt;this&lt;/code&gt; (그것은 유지 바인딩 &lt;code&gt;this&lt;/code&gt; 클로징 어휘 문맥의 값).</target>
        </trans-unit>
        <trans-unit id="ac60cdf424b99dce62b5701d4d143d86d375a54d" translate="yes" xml:space="preserve">
          <source>In most cases, the value of &lt;code&gt;this&lt;/code&gt; is determined by how a function is called. It can't be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the &lt;a href=&quot;../global_objects/function/bind&quot;&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/a&gt; method to &lt;a href=&quot;#The_bind_method&quot;&gt;set the value of a function's &lt;code&gt;this&lt;/code&gt; regardless of how it's called&lt;/a&gt;, and ES2015 introduced &lt;a href=&quot;../functions/arrow_functions&quot;&gt;arrow functions&lt;/a&gt; which don't provide their own &lt;code&gt;this&lt;/code&gt; binding (it retains the &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical context).</source>
          <target state="translated">대부분의 &lt;code&gt;this&lt;/code&gt; 값은 함수 호출 방법에 따라 결정됩니다. 실행 중에 할당하여 설정할 수 없으며 함수가 호출 될 때마다 다를 수 있습니다. ES5는 도입 &lt;a href=&quot;../global_objects/function/bind&quot;&gt; &lt;code&gt;bind()&lt;/code&gt; &lt;/a&gt; 하는 방법에 &lt;a href=&quot;#The_bind_method&quot;&gt;함수의 값의 설정 &lt;code&gt;this&lt;/code&gt; 없이이 호출 방법&lt;/a&gt; 및 ES2015 도입 &lt;a href=&quot;../functions/arrow_functions&quot;&gt;기능 화살표를&lt;/a&gt; 자신이 제공하지 않는 &lt;code&gt;this&lt;/code&gt; (그것은 유지 바인딩 &lt;code&gt;this&lt;/code&gt; 클로징 어휘 문맥의 값).</target>
        </trans-unit>
        <trans-unit id="6d3bbd72aff7458ac96d23ca8ea12c673fb557f5" translate="yes" xml:space="preserve">
          <source>In most cases, using &lt;a href=&quot;rest_parameters&quot;&gt;rest parameters&lt;/a&gt; is a good alternative to using an &lt;code&gt;arguments&lt;/code&gt; object.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;rest_parameters&quot;&gt;나머지 매개 변수&lt;/a&gt; 를 사용하는 것이 &lt;code&gt;arguments&lt;/code&gt; 객체 를 사용하는 좋은 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="5fc6c6c77ddc6a5c73413e02d1078992067d9c03" translate="yes" xml:space="preserve">
          <source>In most languages like PHP and Python and others that have an exponentiation operator (**), the exponentiation operator is defined to have a higher precedence than unary operators such as unary + and unary -, but there are a few exceptions. For example, in Bash the ** operator is defined to have a lower precedence than unary operators. In JavaScript, it is impossible to write an ambiguous exponentiation expression, i.e. you cannot put a unary operator (&lt;code&gt;+/-/~/!/delete/void/typeof&lt;/code&gt;) immediately before the base number.</source>
          <target state="translated">PHP, Python 및 지수 연산자 (**)가있는 다른 언어의 경우, 지수 연산자는 unary + 및 unary-와 같은 단항 연산자보다 우선 순위가 높지만 몇 가지 예외가 있습니다. 예를 들어, Bash에서 ** 연산자는 단항 연산자보다 우선 순위가 낮도록 정의됩니다. JavaScript에서는 모호한 지수 표현식을 작성할 수 없습니다. 즉 , 기본 번호 바로 앞에 단항 연산자 ( &lt;code&gt;+/-/~/!/delete/void/typeof&lt;/code&gt; )를 넣을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="22a5793df1225a02f211cbab4dd35b2dfa4aa24a" translate="yes" xml:space="preserve">
          <source>In non-strict code, function declarations inside blocks behave strangely. Do not use them.</source>
          <target state="translated">엄격하지 않은 코드에서 블록 내부의 함수 선언은 이상하게 작동합니다. 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1874ca4c77d194ed9a187f427ff439010d26be13" translate="yes" xml:space="preserve">
          <source>In non-strict code, function declarations inside blocks behave strangely. For example:</source>
          <target state="translated">엄격하지 않은 코드에서 블록 내의 함수 선언은 이상하게 동작합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="860c9839372531fc54aae6d18e28914fe55a5604" translate="yes" xml:space="preserve">
          <source>In non-strict mode, modifying a value in the &lt;code&gt;arguments&lt;/code&gt; object modifies the corresponding named argument. This made optimizations complicated for JavaScript engine and made code harder to read/understand. In strict mode, the &lt;code&gt;arguments&lt;/code&gt; object is created and initialized with the same values than the named arguments, but changes to either the &lt;code&gt;arguments&lt;/code&gt; object or the named arguments aren't reflected in one another.</source>
          <target state="translated">엄격하지 않은 모드에서 &lt;code&gt;arguments&lt;/code&gt; 객체 의 값을 수정하면 해당하는 명명 된 인수가 수정됩니다. 이로 인해 JavaScript 엔진에 대한 최적화가 복잡해지고 코드를 읽고 이해하기가 더 어려워졌습니다. 엄격 모드에서는 &lt;code&gt;arguments&lt;/code&gt; 객체가 명명 된 인수와 동일한 값으로 만들어지고 초기화되지만 &lt;code&gt;arguments&lt;/code&gt; 객체 또는 명명 된 인수에 대한 변경 내용 은 서로 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95aa3b03b2032d638c1633fec4e82b00ad7a1890" translate="yes" xml:space="preserve">
          <source>In non-strict, this would silently fail, in contradiction with the user expectation.</source>
          <target state="translated">엄격하지 않은 경우, 이는 사용자의 기대와 모순되어 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="cb7ee7b5cd4eb0f5efd8c7fee9d564b5efb524f6" translate="yes" xml:space="preserve">
          <source>In normal function calls (as opposed to constructor function calls), &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. This lets you detect if a function was called with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; as a constructor.</source>
          <target state="translated">생성자 함수 호출과 달리 일반적인 함수 호출에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 이를 통해 생성자 가 &lt;a href=&quot;new&quot;&gt;new 인&lt;/a&gt; 함수가 호출되었는지 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="230572d6652702c77e4d55e58d676991394f1446" translate="yes" xml:space="preserve">
          <source>In normal function calls (as opposed to constructor function calls), &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;. This lets you detect whether a function was called with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; as a constructor.</source>
          <target state="translated">일반 함수 호출 (생성자 함수 호출과 반대)에서 &lt;code&gt;new.target&lt;/code&gt; 은 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 입니다. 이렇게하면 &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; 를 생성자로 사용하여 함수가 호출되었는지 여부를 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0a271923b767ecf71d00311996c399f935078d0" translate="yes" xml:space="preserve">
          <source>In older implementations, which ignore the &lt;code&gt;&lt;var&gt;locales&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;&lt;var&gt;options&lt;/var&gt;&lt;/code&gt; arguments, the locale used and the form of the string returned are entirely implementation-dependent.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;locales&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;var&gt;options&lt;/var&gt;&lt;/code&gt; 인수 를 무시하는 이전 구현에서는 사용 된 로케일 과 반환되는 문자열 형식이 전적으로 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a68eef8c5fb49c60634ed1d21df3a98ae0e0f974" translate="yes" xml:space="preserve">
          <source>In order to be &lt;strong&gt;iterable&lt;/strong&gt;, an object must implement the &lt;code&gt;@@iterator&lt;/code&gt; method, meaning that the object (or one of the objects up its &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;prototype chain&lt;/a&gt;) must have a property with a &lt;code&gt;@@iterator&lt;/code&gt; key which is available via constant &lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;반복&lt;/strong&gt; 할 수 있으 려면 객체가 &lt;code&gt;@@iterator&lt;/code&gt; 메서드를 구현해야합니다. 즉, 객체 (또는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;프로토 타입 체인&lt;/a&gt; 위의 객체 중 하나 )에는 상수 &lt;a href=&quot;global_objects/symbol/iterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; 를 통해 사용할 수 있는 &lt;code&gt;@@iterator&lt;/code&gt; 키 가있는 속성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e0eefb52bc8e7160456b7047e4f143d09203972a" translate="yes" xml:space="preserve">
          <source>In order to be &lt;strong&gt;iterable&lt;/strong&gt;, an object must implement the &lt;strong&gt;@@iterator&lt;/strong&gt; method, meaning that the object (or one of the objects up its &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;prototype chain&lt;/a&gt;) must have a property with a &lt;strong&gt;@@iterator &lt;/strong&gt;key which is available via constant &lt;code&gt;&lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;반복 가능&lt;/strong&gt; 하기 위해 객체는 &lt;strong&gt;@@ iterator&lt;/strong&gt; 메소드를 구현해야합니다. 즉, 객체 (또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain&quot;&gt;프로토 타입 체인&lt;/a&gt; 에있는 객체 중 하나 )에는 상수 &lt;code&gt;&lt;a href=&quot;global_objects/symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 를 통해 사용할 수 있는 &lt;strong&gt;@@ iterator&lt;/strong&gt; 키 가있는 특성이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9de074ed49182f2a1dc2aec280709fa9abad4868" translate="yes" xml:space="preserve">
          <source>In order to call a static method or property within another static method of the same class, you can use the &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">동일한 클래스의 다른 정적 메서드 내에서 정적 메서드 또는 속성을 호출하려면 &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="862bd58d82c44825625f345f8000cff5f3f26277" translate="yes" xml:space="preserve">
          <source>In order to call a static method within another static method of the same class, you can use the &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">같은 클래스의 다른 정적 메서드 내에서 정적 메서드를 호출하려면 &lt;code&gt;&lt;a href=&quot;../operators/this&quot;&gt;this&lt;/a&gt;&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e455045de218103473f428d3071d54854bd467dc" translate="yes" xml:space="preserve">
          <source>In order to create and get dates between the years 0 and 99 the &lt;a href=&quot;date/setfullyear&quot;&gt;&lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/getfullyear&quot;&gt;&lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt;&lt;/a&gt; methods should be used.</source>
          <target state="translated">0에서 99 년 사이의 날짜를 만들고 가져 오려면 &lt;a href=&quot;date/setfullyear&quot;&gt; &lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;date/getfullyear&quot;&gt; &lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt; &lt;/a&gt; 메서드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7bdbb65503f173efe6d93b336bcc3c56478167b" translate="yes" xml:space="preserve">
          <source>In order to create and get dates between the years &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;99&lt;/code&gt; the &lt;a href=&quot;date/setfullyear&quot;&gt;&lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;date/getfullyear&quot;&gt;&lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt;&lt;/a&gt; methods should be used.</source>
          <target state="translated">만들고 년 사이에 날짜를 얻기 위해 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;99&lt;/code&gt; &lt;a href=&quot;date/setfullyear&quot;&gt; &lt;code&gt;Date.prototype.setFullYear()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;date/getfullyear&quot;&gt; &lt;code&gt;Date.prototype.getFullYear()&lt;/code&gt; &lt;/a&gt; 방법이 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="a06ff19557c3cd24895157a5889dec3667d90b42" translate="yes" xml:space="preserve">
          <source>In order to embed expressions within normal strings, you would use the following syntax:</source>
          <target state="translated">일반 문자열 내에 표현식을 포함 시키려면 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="261c57c7b8631ce4358a48ec7330061dc4f99420" translate="yes" xml:space="preserve">
          <source>In ordinary functions, it refers to the function itself, assuming it was invoked via the &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; operator; otherwise &lt;code&gt;new.target&lt;/code&gt; is &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 함수에서는 &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; 연산자 를 통해 호출되었다고 가정하고 함수 자체를 참조합니다 . 그렇지 않으면 &lt;code&gt;new.target&lt;/code&gt; 이 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c30f8199b4dd458c0968198031c49f62bc167924" translate="yes" xml:space="preserve">
          <source>In our example above, the arrow function does not have its own &lt;code&gt;this&lt;/code&gt;. The &lt;code&gt;this&lt;/code&gt; value of the enclosing lexical &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt; is used; arrow functions follow the normal variable lookup rules. So while searching for &lt;code&gt;this&lt;/code&gt; which is not present in the current &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt;, an arrow function ends up finding the &lt;code&gt;this&lt;/code&gt; from its enclosing &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 화살표 함수에는 자체 &lt;code&gt;this&lt;/code&gt; 가 없습니다 . 둘러싼 어휘 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위&lt;/a&gt; 의 &lt;code&gt;this&lt;/code&gt; 값 이 사용됩니다. 화살표 함수는 일반 변수 조회 규칙을 따릅니다. 따라서 현재 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위&lt;/a&gt; 에없는 &lt;code&gt;this&lt;/code&gt; 검색하는 동안 화살표 함수는 둘러싸는 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/Scope&quot;&gt;범위 &lt;/a&gt; &lt;code&gt;this&lt;/code&gt; 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa11c5c2db715285eac1e1df98254200504f278" translate="yes" xml:space="preserve">
          <source>In practice, it is often desirable to catch rejected promises rather than use &lt;code&gt;then&lt;/code&gt;'s two case syntax, as demonstrated below.</source>
          <target state="translated">실제로, 거부 약속보다는 사용을 잡으려고하는 것이 바람직하다 &lt;code&gt;then&lt;/code&gt; 아래 있듯이,의 두 경우 구문.</target>
        </trans-unit>
        <trans-unit id="1fbd7dce6756453ed26553376d0427f3b5a41799" translate="yes" xml:space="preserve">
          <source>In some respects (such as sorting) they should be treated as equivalent&amp;mdash;and in some (such as visual appearance) they should not, so they are not canonically equivalent.</source>
          <target state="translated">일부 측면 (예 : 정렬)에서는 동등하게 취급되어야하고 일부 (예 : 시각적 모양)에서는 그렇지 않으므로 표준 적으로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7bd329bf1a6fca5cc1d9f8ca14653cea85fd687" translate="yes" xml:space="preserve">
          <source>In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case). When there are too many function calls, or a function is missing a base case, JavaScript will throw this error.</source>
          <target state="translated">어떤면에서 재귀는 루프와 유사합니다. 둘 다 동일한 코드를 여러 번 실행하며 둘 다 조건이 필요합니다 (이 경우 무한 루프 또는 오히려 무한 재귀를 방지하기 위해). 함수 호출이 너무 많거나 함수에 기본 케이스가 누락 된 경우 JavaScript에서이 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dcc3359fcfde967d3f070026eabf07f701112c4c" translate="yes" xml:space="preserve">
          <source>In strict mode code, &lt;code&gt;eval&lt;/code&gt; doesn't create a new variable in the scope from which it was called. Also, of course, in strict mode, the string is evaluated with strict mode rules. Thorough testing will need to be performed to make sure nothing breaks. Not using eval if you don't really need it may be another pragmatic solution.</source>
          <target state="translated">엄격 모드 코드에서 &lt;code&gt;eval&lt;/code&gt; 은 호출 된 범위에서 새 변수를 작성하지 않습니다. 또한 엄격 모드에서 문자열은 엄격 모드 규칙으로 평가됩니다. 파손되지 않도록 철저한 테스트를 수행해야합니다. 실제로 필요하지 않은 경우 eval을 사용하지 않으면 다른 실용적인 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c986ac9c061545ea61f73243c079a502c902273c" translate="yes" xml:space="preserve">
          <source>In strict mode code, more identifiers are reserved.</source>
          <target state="translated">엄격 모드 코드에서는 더 많은 식별자가 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0305e05ae84323bdcca0727b14cfc634f066fb00" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;defineProperty&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">엄격 모드 에서 &lt;code&gt;defineProperty&lt;/code&gt; 핸들러 의 &lt;code&gt;false&lt;/code&gt; 리턴 값은 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9d09582a0bc85e38ae88283afb2b5fcbd5053155" translate="yes" xml:space="preserve">
          <source>In strict mode, a &lt;code&gt;false&lt;/code&gt; return value from the &lt;code&gt;set&lt;/code&gt; handler will throw a &lt;a href=&quot;../../typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">엄격 모드에서는 &lt;code&gt;set&lt;/code&gt; 처리기 의 &lt;code&gt;false&lt;/code&gt; 반환 값으로 인해 &lt;a href=&quot;../../typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b6d02975bb8de9c2d2b0b5332c5792b28df3140" translate="yes" xml:space="preserve">
          <source>In strict mode, however, if the value of &lt;code&gt;this&lt;/code&gt; is not set when entering an execution context, it remains as &lt;code&gt;undefined&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">그러나 엄격 모드에서 실행 컨텍스트를 입력 할 때 &lt;code&gt;this&lt;/code&gt; 값 이 설정 &lt;code&gt;undefined&lt;/code&gt; 경우 다음 예제와 같이 undefined로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d4bd884970a79efd62e157b542fb73cb029e026" translate="yes" xml:space="preserve">
          <source>In strict mode, however, the value of &lt;code&gt;this&lt;/code&gt; remains at whatever it was set to when entering the execution context, so, in the following case, &lt;code&gt;this&lt;/code&gt;will default to &lt;code&gt;undefined&lt;/code&gt;&lt;strong&gt;:&lt;/strong&gt;</source>
          <target state="translated">엄격 모드에서는, 그러나,의 값 &lt;code&gt;this&lt;/code&gt; 유물은 무엇 이건이 다음과 같은 경우에, 그래서 실행 컨텍스트를 입력 할 때로 설정, &lt;code&gt;this&lt;/code&gt; 기본값으로 사용됩니다 &lt;code&gt;undefined&lt;/code&gt; &lt;strong&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5edd29a28bbd08562217025986be25352d683242" translate="yes" xml:space="preserve">
          <source>In strict mode, this would have raised an exception.</source>
          <target state="translated">엄격 모드에서는 예외가 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d019380674a16813ef94c54a0d343b4618bc0042" translate="yes" xml:space="preserve">
          <source>In strict-mode code, the &lt;code&gt;arguments&lt;/code&gt; object behaves the same whether or not a function is passed rest, default, or destructured parameters. That is, assigning new values to variables in the body of the function will not affect the &lt;code&gt;arguments&lt;/code&gt; object. Nor will assigning new variables to the &lt;code&gt;arguments&lt;/code&gt; object affect the value of variables.</source>
          <target state="translated">Strict 모드 코드에서 &lt;code&gt;arguments&lt;/code&gt; 객체는 함수에 rest, default 또는 destructured 매개 변수가 전달되었는지 여부에 관계없이 동일하게 작동합니다. 즉, 함수 본문의 변수에 새 값을 할당해도 &lt;code&gt;arguments&lt;/code&gt; 객체 에는 영향을주지 않습니다 . &lt;code&gt;arguments&lt;/code&gt; 개체에 새 변수를 할당하는 것도 변수 값에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95ba434dcfc26a308be81afbb8f480fb122aa093" translate="yes" xml:space="preserve">
          <source>In that very line, the &lt;u&gt;if block's &quot;foo&quot;&lt;/u&gt; has already been created in the lexical environment, but has not yet reached (and &lt;strong&gt;terminated&lt;/strong&gt;) its initialization (which is part of the statement itself): it's still in the temporal dead zone.</source>
          <target state="translated">바로 그 줄에서 &lt;u&gt;if 블록의 &quot;foo&quot;&lt;/u&gt; 는 어휘 환경에서 이미 생성되었지만 초기화 (문 자체의 일부 임)에 아직 도달하지 않았으며 아직 &lt;strong&gt;종료&lt;/strong&gt; 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="344dc469ad2fb516272004fea64179e2bc4964ae" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey&quot;&gt;SpiderMonkey&lt;/a&gt; JavaScript engine, this string would be &quot;&lt;code&gt;[object Object]&lt;/code&gt;&quot;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey&quot;&gt;의 SpiderMonkey&lt;/a&gt; 자바 스크립트 엔진이 문자열은 &quot;것 &lt;code&gt;[object Object]&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="fc766e1776bb917de6591132669602b3df9697de" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;3d&lt;/code&gt; example, &lt;code&gt;'3d'&lt;/code&gt;&lt;em&gt;had &lt;/em&gt;to be quoted (because it begins with a digit). But it's also possible to quote the array indexes as well (e.g., &lt;code&gt;years['2']&lt;/code&gt; instead of &lt;code&gt;years[2]&lt;/code&gt;), although it's not necessary.</source>
          <target state="translated">에서 &lt;code&gt;3d&lt;/code&gt; 예를 들어, &lt;code&gt;'3d'&lt;/code&gt; &lt;em&gt;했다&lt;/em&gt; (이 숫자로 시작하기 때문에) 인용 될 수 있습니다. 하지만 필요하지는 않지만 배열 인덱스를 인용 할 수도 있습니다 (예 : &lt;code&gt;years['2']&lt;/code&gt; 대신 years [ '2' &lt;code&gt;years[2]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfb123889f9c99fb835bcc26628fcbd3f7f67f01" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;var&gt;object.property&lt;/var&gt;&lt;/code&gt; syntax, the &lt;code&gt;property&lt;/code&gt; must be a valid JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/identifier&quot;&gt;identifier&lt;/a&gt;. (In the ECMAScript standard, the names of properties are technically &quot;IdentifierNames&quot;, not &quot;Identifiers&quot;, so reserved words can be used but are not recommended). For example, &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.$1&lt;/code&gt; is valid, while &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.1&lt;/code&gt; is not.</source>
          <target state="translated">에서 &lt;code&gt;&lt;var&gt;object.property&lt;/var&gt;&lt;/code&gt; 의 구문의 &lt;code&gt;property&lt;/code&gt; 유효한 자바 스크립트해야합니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/identifier&quot;&gt;식별자&lt;/a&gt; . (ECMAScript 표준에서 속성 이름은 기술적으로 &quot;Identifiers&quot;가 아니라 &quot;IdentifierNames&quot;이므로 예약어를 사용할 수 있지만 권장되지는 않습니다. 예를 들어 &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.$1&lt;/code&gt; 은 유효하지만 &lt;code&gt;&lt;var&gt;object&lt;/var&gt;.1&lt;/code&gt; 은 유효 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dc2a210be3838d3448081d22f4b72f5712e5f4a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;if&lt;/code&gt; statement, you want to use a comparison operator (&quot;==&quot;), and for the string concatenation, the plus (&quot;+&quot;) operator is needed.</source>
          <target state="translated">에서 &lt;code&gt;if&lt;/code&gt; 문, 당신은 ( &quot;==&quot;) 비교 연산자를 사용하려면, 그리고 문자열 연결, 더하기 ( &quot;+&quot;) 연산자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc49181d6c445c536525c61ec569330429a69827" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;object[property_name]&lt;/code&gt; syntax, the &lt;code&gt;&lt;var&gt;property_name&lt;/var&gt;&lt;/code&gt; is just a string or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Symbol&quot;&gt;Symbol&lt;/a&gt;. So, it can be any string, including &lt;code&gt;'1foo'&lt;/code&gt;, &lt;code&gt;'!bar!'&lt;/code&gt;, or even &lt;code&gt;' '&lt;/code&gt; (a space).</source>
          <target state="translated">에서 &lt;code&gt;object[property_name]&lt;/code&gt; 구문은 &lt;code&gt;&lt;var&gt;property_name&lt;/var&gt;&lt;/code&gt; 단순한 문자열이거나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Symbol&quot;&gt;기호&lt;/a&gt; . 따라서 &lt;code&gt;'1foo'&lt;/code&gt; , &lt;code&gt;'!bar!'&lt;/code&gt; 포함한 모든 문자열이 될 수 있습니다 . , 또는 &lt;code&gt;' '&lt;/code&gt; (공백).</target>
        </trans-unit>
        <trans-unit id="504e2effa4c01ce2afda7c35aaa16e32fcaa9400" translate="yes" xml:space="preserve">
          <source>In the JavaScript reference you can find the following chapters:</source>
          <target state="translated">JavaScript 참조에서 다음 장을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ebab3674334dea74506ab92354e81bf49a5348" translate="yes" xml:space="preserve">
          <source>In the above example, notice there is no &lt;code&gt;await&lt;/code&gt; statement after the &lt;code&gt;return&lt;/code&gt; keyword, although that would be valid too: The return value of an &lt;code&gt;async function&lt;/code&gt; is implicitly wrapped in &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;&lt;code&gt;Promise.resolve&lt;/code&gt;&lt;/a&gt; - if it's not already a promise itself (as in this example).</source>
          <target state="translated">위의 예 에서 &lt;code&gt;return&lt;/code&gt; 키워드 뒤에 &lt;code&gt;await&lt;/code&gt; 문 이 없다는 것을 알 수 있습니다.이 역시 유효합니다. &lt;code&gt;async function&lt;/code&gt; 의 반환 값은 &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt; &lt;code&gt;Promise.resolve&lt;/code&gt; 에&lt;/a&gt; 암시 적으로 래핑됩니다 -이미 약속 자체가 아닌 경우 (이 예에서와 같이) ).</target>
        </trans-unit>
        <trans-unit id="51b25d369879120965a73c97bd3bb3c4bc0dcba2" translate="yes" xml:space="preserve">
          <source>In the above example, the spread syntax does not work as one might expect: it spreads an &lt;em&gt;array&lt;/em&gt; of arguments into the object literal, due to the rest parameter.</source>
          <target state="translated">위의 예에서 스프레드 구문은 예상대로 작동하지 않습니다 . rest 매개 변수로 인해 인수 &lt;em&gt;배열&lt;/em&gt; 을 오브젝트 리터럴로 스프레드합니다 .</target>
        </trans-unit>
        <trans-unit id="639bc8814e61c3ad66222c2a753077d09d6095ed" translate="yes" xml:space="preserve">
          <source>In the above polyfill, no extra type-coercing is needed to make &lt;code&gt;(x &amp;gt; 0) or&amp;nbsp;(x &amp;lt; 0)&lt;/code&gt; numbers because subtracting them from each other forces a type conversion from boolean to numbers.</source>
          <target state="translated">위의 폴리 필에서 &lt;code&gt;(x &amp;gt; 0) or&amp;nbsp;(x &amp;lt; 0)&lt;/code&gt; 숫자를 빼기 위해 다른 유형의 강제 변환 이 필요하지 않습니다. 서로를 빼면 형식이 부울에서 숫자로 변환되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="97c92f0acdf5c43d4bf308a9791b1d873616af45" translate="yes" xml:space="preserve">
          <source>In the above polyfill, no extra type-coercing is needed to make &lt;code&gt;(x &amp;gt; 0)&lt;/code&gt; or &lt;code&gt;(x &amp;lt; 0)&lt;/code&gt; numbers because subtracting them from each other forces a type conversion from booleans to numbers.</source>
          <target state="translated">위의 폴리 필에서는 &lt;code&gt;(x &amp;gt; 0)&lt;/code&gt; 또는 &lt;code&gt;(x &amp;lt; 0)&lt;/code&gt; 숫자 를 만드는 데 추가 유형 강제가 필요하지 않습니다. 서로 빼면 부울에서 숫자로 유형 변환이 강제되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3320efd6ed4bd76923685057972479f17a63057a" translate="yes" xml:space="preserve">
          <source>In the above, the function (call it anonymous function A) assigned to &lt;code&gt;obj.bar&lt;/code&gt; returns another function (call it anonymous function B) that is created as an arrow function. As a result, function B's &lt;code&gt;this&lt;/code&gt; is permanently set to the &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;obj.bar&lt;/code&gt; (function A) when called. When the returned function (function B) is called, its &lt;code&gt;this&lt;/code&gt; will always be what it was set to initially. In the above code example, function B's &lt;code&gt;this&lt;/code&gt; is set to function A's &lt;code&gt;this&lt;/code&gt; which is &lt;code&gt;obj&lt;/code&gt;, so it remains set to &lt;code&gt;obj&lt;/code&gt; even when called in a manner that would normally set its &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or the global object (or any other method as in the previous example in the global execution context).</source>
          <target state="translated">위의 &lt;code&gt;obj.bar&lt;/code&gt; 에 할당 된 함수 (익명 함수 A라고 함)는 화살표 함수로 생성 된 다른 함수 (익명 함수 B라고 함)를 반환합니다. 그 결과, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 영구적으로 설정되고 &lt;code&gt;this&lt;/code&gt; 중 &lt;code&gt;obj.bar&lt;/code&gt; 호출하면 (함수 A). 반환 된 기능 (기능 B)가 호출되면, 그 &lt;code&gt;this&lt;/code&gt; 항상 처음에 설정 무슨 일 것이다. 위의 코드 예제에서 함수 B의 &lt;code&gt;this&lt;/code&gt; 는 함수 A의 &lt;code&gt;this&lt;/code&gt; 인 &lt;code&gt;obj&lt;/code&gt; 로 설정되어 있으므로 일반적으로 &lt;code&gt;this&lt;/code&gt; 를 &lt;code&gt;undefined&lt;/code&gt; 로 설정하는 방식으로 호출하더라도 &lt;code&gt;obj&lt;/code&gt; 로 설정된 상태로 유지됩니다. 또는 전역 개체 (또는 전역 실행 컨텍스트의 이전 예제에서와 같은 다른 메서드).</target>
        </trans-unit>
        <trans-unit id="62bdda2e0a21fb28a7f5675957c393b044577a67" translate="yes" xml:space="preserve">
          <source>In the above, the function(call it anonymous function A) assigned to &lt;code&gt;obj.bar&lt;/code&gt; returns another function(call it anonymous function B) that is created as an arrow function. As a result, function B's &lt;code&gt;this&lt;/code&gt; is permanently set to the &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;obj.bar&lt;/code&gt; (function A)when called. When the returned function(function B) is called, its &lt;code&gt;this&lt;/code&gt; will always be what it was set to initially. In the above code example, function B's &lt;code&gt;this&lt;/code&gt; is set to function A's &lt;code&gt;this&lt;/code&gt; which is obj, so it remains set to &lt;code&gt;obj&lt;/code&gt; even when called in a manner that would normally set its &lt;code&gt;this&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or the global object (or any other method as in the previous example in the global execution context).</source>
          <target state="translated">위에서 &lt;code&gt;obj.bar&lt;/code&gt; 에 할당 된 함수 (익명 함수 A라고 함)는 화살표 함수로 생성 된 다른 함수 (익명 함수 B라고 함)를 반환합니다. 그 결과, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 영구적으로 설정되고 &lt;code&gt;this&lt;/code&gt; 중 &lt;code&gt;obj.bar&lt;/code&gt; 호출하면 (함수 A). 반환 된 기능 (기능 B)가 호출되면, 그 &lt;code&gt;this&lt;/code&gt; 항상 처음에 설정 무슨 일 것이다. 상기 코드의 예에서, 함수 B이다 &lt;code&gt;this&lt;/code&gt; 기능 (A)에 설정되어있어 &lt;code&gt;this&lt;/code&gt; 그것을 위해 설정된 남아 있도록 OBJ 인 &lt;code&gt;obj&lt;/code&gt; 와 심지어 보통 그 설정하는 방식으로 호출 할 때 &lt;code&gt;this&lt;/code&gt; 로 &lt;code&gt;undefined&lt;/code&gt; 또는 전역 객체 (또는 전역 실행 컨텍스트의 이전 예와 같은 다른 방법).</target>
        </trans-unit>
        <trans-unit id="42d2f894ef11d503ede81ebcedd96f07d7f0fab6" translate="yes" xml:space="preserve">
          <source>In the case of recursion, i.e. if function &lt;code&gt;f&lt;/code&gt; appears several times on the call stack, the value of &lt;code&gt;f.arguments&lt;/code&gt; represents the arguments corresponding to the most recent invocation of the function.</source>
          <target state="translated">재귀의 경우, 즉 함수 &lt;code&gt;f&lt;/code&gt; 가 호출 스택에 여러 번 나타나는 경우 &lt;code&gt;f.arguments&lt;/code&gt; 값은 함수의 가장 최근 호출에 해당하는 인수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="661fd464b4a2050134037311daed90c57e20fd0a" translate="yes" xml:space="preserve">
          <source>In the current ECMAScript specification, &lt;code&gt;-0&lt;/code&gt; and &lt;code&gt;+0&lt;/code&gt; are considered equal, although this was not so in earlier drafts. See &lt;em&gt;&quot;Value equality for -0 and 0&quot;&lt;/em&gt; in the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility&lt;/a&gt; table for details.</source>
          <target state="translated">현재 ECMAScript 사양에서 &lt;code&gt;-0&lt;/code&gt; 과 &lt;code&gt;+0&lt;/code&gt; 은 동일한 것으로 간주되지만 이전 초안에서는 그렇지 않습니다. 자세한 내용 은 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성&lt;/a&gt; 표 에서 &lt;em&gt;&quot;-0 및 0의 값 같음&quot;&lt;/em&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de188306b04f104700fac924cdd1e9567febef02" translate="yes" xml:space="preserve">
          <source>In the example above the exception will be shown since constructor links to Parent.</source>
          <target state="translated">위 예제에서는 생성자가 Parent에 연결되어 있으므로 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="acef3bf46acb0ba10cb256e32b5f0d0bb458c455" translate="yes" xml:space="preserve">
          <source>In the example above the exception will be shown since the constructor links to Parent.</source>
          <target state="translated">위의 예에서는 생성자가 Parent에 링크하기 때문에 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad8390434acf6607f1bb47c24b30e5f18f5b3f46" translate="yes" xml:space="preserve">
          <source>In the example below, we invoke the &lt;code&gt;display&lt;/code&gt; function without passing the first argument. If the first argument is not passed, the value of &lt;code&gt;this&lt;/code&gt; is bound to the global object.</source>
          <target state="translated">아래 예제 에서 첫 번째 인수를 전달하지 않고 &lt;code&gt;display&lt;/code&gt; 함수를 호출합니다 . 첫 번째 인수가 전달되지 않으면 &lt;code&gt;this&lt;/code&gt; 값 이 전역 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4da435fcb2e56dfca1fdbb66425c53d9f93888" translate="yes" xml:space="preserve">
          <source>In the example below, when we call &lt;code&gt;greet&lt;/code&gt;, the value of &lt;code&gt;this&lt;/code&gt; will be bound to object &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;greet&lt;/code&gt; 을 호출하면 &lt;code&gt;this&lt;/code&gt; 의 값 이 &lt;code&gt;obj&lt;/code&gt; 객체에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="c878dda71bd4d57212f4760d1a5d6612fffe1a77" translate="yes" xml:space="preserve">
          <source>In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was 0. &lt;code&gt;null&lt;/code&gt; was represented as the NULL pointer (0x00 in most platforms). Consequently, null had 0 as type tag, hence the bogus &lt;code&gt;typeof&lt;/code&gt; return value. (&lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;reference&lt;/a&gt;)</source>
          <target state="translated">JavaScript의 첫 번째 구현에서 JavaScript 값은 유형 태그와 값으로 표시되었습니다. 객체의 유형 태그는 0입니다. &lt;code&gt;null&lt;/code&gt; 은 NULL 포인터 (대부분의 플랫폼에서 0x00)로 표시되었습니다. 따라서, 널 타입 태그, 따라서 위조 0 있었다 &lt;code&gt;typeof&lt;/code&gt; 리턴 값. ( &lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;참고&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="857eee85d465027bf36c77ed510b6ca131138764" translate="yes" xml:space="preserve">
          <source>In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;null&lt;/code&gt; was represented as the NULL pointer (&lt;code&gt;0x00&lt;/code&gt; in most platforms). Consequently, &lt;code&gt;null&lt;/code&gt; had &lt;code&gt;0&lt;/code&gt; as type tag, hence the &lt;code&gt;&quot;object&quot;&lt;/code&gt;&lt;code&gt;typeof&lt;/code&gt; return value. (&lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;reference&lt;/a&gt;)</source>
          <target state="translated">JavaScript의 첫 번째 구현에서 JavaScript 값은 유형 태그와 값으로 표시되었습니다. 객체의 유형 태그는 &lt;code&gt;0&lt;/code&gt; 입니다. &lt;code&gt;null&lt;/code&gt; 은 NULL 포인터 ( 대부분의 플랫폼에서 &lt;code&gt;0x00&lt;/code&gt; )로 표시되었습니다. 결과적으로 &lt;code&gt;null&lt;/code&gt; 은 유형 태그로 &lt;code&gt;0&lt;/code&gt; 이 있으므로 &lt;code&gt;&quot;object&quot;&lt;/code&gt; &lt;code&gt;typeof&lt;/code&gt; 반환 값이됩니다. ( &lt;a href=&quot;http://www.2ality.com/2013/10/typeof-null.html&quot;&gt;참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c4c1b2e168bd2c3f0960e008564fab4afcfb0149" translate="yes" xml:space="preserve">
          <source>In the following code, &lt;code&gt;flag.toString()&lt;/code&gt; returns &quot;&lt;code&gt;true&lt;/code&gt;&quot;:</source>
          <target state="translated">다음 코드에서 &lt;code&gt;flag.toString()&lt;/code&gt; 은 &quot; &lt;code&gt;true&lt;/code&gt; &quot;를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="326dc4a22d6e5d66e05e913ed076ab8871545c67" translate="yes" xml:space="preserve">
          <source>In the following code, both of the statements containing &lt;code&gt;eval()&lt;/code&gt; return 42. The first evaluates the string &quot;&lt;code&gt;x + y + 1&lt;/code&gt;&quot;; the second evaluates the string &quot;&lt;code&gt;42&lt;/code&gt;&quot;.</source>
          <target state="translated">다음 코드에서 &lt;code&gt;eval()&lt;/code&gt; 포함하는 두 명령문은 모두 42를 리턴합니다. 첫 번째는 문자열 &quot; &lt;code&gt;x + y + 1&lt;/code&gt; &quot;을 평가합니다 . 두 번째는 문자열 &quot; &lt;code&gt;42&lt;/code&gt; &quot;를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="7227f231dba8b388ff90697deb637f835c642754" translate="yes" xml:space="preserve">
          <source>In the following example we will create a global &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; method called &lt;code&gt;construct&lt;/code&gt;, which will enable you to use an array-like object with a constructor instead of an arguments list.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;construct&lt;/code&gt; 라는 전역 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; 메서드를 생성 하여 인수 목록 대신 생성자와 함께 배열과 같은 객체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccaa53cc09c2b150a701f3de632d7c64e3076c6" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;match()&lt;/code&gt; is used to find '&lt;code&gt;Chapter&lt;/code&gt;' followed by 1 or more numeric characters followed by a decimal point and numeric character 0 or more times.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;match()&lt;/code&gt; 를 사용하여 ' &lt;code&gt;Chapter&lt;/code&gt; '뒤에 1 개 이상의 숫자와 소수점, 숫자 0 개 이상을 차례로 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="551908074dab38737ca378f22dc2a0152b483db4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;match()&lt;/code&gt; is used to find &lt;code&gt;'Chapter'&lt;/code&gt; followed by 1 or more numeric characters followed by a decimal point and numeric character 0 or more times. The regular expression includes the &lt;code&gt;i&lt;/code&gt; flag so that upper/lower case differences will be ignored.</source>
          <target state="translated">다음 예에서 &lt;code&gt;match()&lt;/code&gt; 는 &lt;code&gt;'Chapter'&lt;/code&gt; 다음에 1 개 이상의 숫자와 소수점 및 0 개 이상의 숫자 를 찾는 데 사용됩니다 . 정규식에는 &lt;code&gt;i&lt;/code&gt; 플래그가 포함되므로 대 / 소문자의 차이는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1da1e1b8bfab54b105a4ada0152c93b74660c6" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;slice&lt;/code&gt; creates a new array, &lt;code&gt;newCar&lt;/code&gt;, from &lt;code&gt;myCar&lt;/code&gt;. Both include a reference to the object &lt;code&gt;myHonda&lt;/code&gt;. When the color of &lt;code&gt;myHonda&lt;/code&gt; is changed to purple, both arrays reflect the change.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;slice&lt;/code&gt; 는 &lt;code&gt;myCar&lt;/code&gt; 에서 새 배열 &lt;code&gt;newCar&lt;/code&gt; 를 만듭니다 . 둘 다 &lt;code&gt;myHonda&lt;/code&gt; 객체에 대한 참조를 포함합니다 . &lt;code&gt;myHonda&lt;/code&gt; 의 색상이 자주색 으로 변경되면 두 배열 모두 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="b027578ad80c9e8c2b2c3dd35b71ae535a33dd33" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for 0 or more spaces followed by a semicolon followed by 0 or more spaces and, when found, removes the spaces and the semicolon from the string. &lt;code&gt;nameList&lt;/code&gt; is the array returned as a result of &lt;code&gt;split()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 0 개 이상의 공백과 세미콜론, 0 개 이상의 공백을 찾은 후 문자열에서 공백과 세미콜론을 제거합니다. &lt;code&gt;nameList&lt;/code&gt; 는 &lt;code&gt;split()&lt;/code&gt; 의 결과로 반환 된 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="5c2e6d8d45fd169d7a77ecae81e085840f806133" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for spaces in a string and returns the first 3 splits that it finds.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 문자열에서 공백을 찾고 찾은 처음 3 개의 분할을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2489eb3658fe2037e9cdda5effddf0b3a84f250d" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;split()&lt;/code&gt; looks for zero or more spaces, followed by a semicolon, followed by zero or more spaces&amp;mdash;and, when found, removes the spaces and the semicolon from the string. &lt;code&gt;nameList&lt;/code&gt; is the array returned as a result of &lt;code&gt;split()&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;split()&lt;/code&gt; 은 0 개 이상의 공백, 뒤에 세미콜론, 0 개 이상의 공백을 찾습니다. 찾은 경우 문자열에서 공백과 세미콜론을 제거합니다. &lt;code&gt;nameList&lt;/code&gt; 는 &lt;code&gt;split()&lt;/code&gt; 의 결과로 반환되는 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="ccb536da7c5287e832a975ca6e887bf6be2e7026" translate="yes" xml:space="preserve">
          <source>In the following example, a statement labeled &lt;code&gt;checkiandj&lt;/code&gt; contains a statement labeled &lt;code&gt;checkj&lt;/code&gt;. If &lt;code&gt;continue&lt;/code&gt; is encountered, the program continues at the top of the &lt;code&gt;checkj&lt;/code&gt; statement. Each time &lt;code&gt;continue&lt;/code&gt; is encountered, &lt;code&gt;checkj&lt;/code&gt; reiterates until its condition returns false. When false is returned, the remainder of the &lt;code&gt;checkiandj&lt;/code&gt; statement is completed.</source>
          <target state="translated">다음 예에서 표시된 문 &lt;code&gt;checkiandj&lt;/code&gt; 은 성명 표시가 포함되어 &lt;code&gt;checkj&lt;/code&gt; 을 . 경우 &lt;code&gt;continue&lt;/code&gt; 발생, 프로그램은 상단에 계속 &lt;code&gt;checkj&lt;/code&gt; 의 문. 때마다 &lt;code&gt;continue&lt;/code&gt; , 발생 &lt;code&gt;checkj&lt;/code&gt; 의 의 상태를 반환 거짓 때까지 되풀이한다. false가 리턴되면 &lt;code&gt;checkiandj&lt;/code&gt; 문의 나머지 가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="0b489dc35a2ac4c8c478d127272578dceb8f8cdb" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &quot;Bananas&quot;, the program matches the value with case &quot;Bananas&quot; and executes the associated statement. When &lt;code&gt;break&lt;/code&gt; is encountered, the program breaks out of &lt;code&gt;switch&lt;/code&gt; and executes the statement following &lt;code&gt;switch&lt;/code&gt;. If &lt;code&gt;break&lt;/code&gt; were omitted, the statement for case &quot;Cherries&quot; would also be executed.</source>
          <target state="translated">다음 예에서 &lt;code&gt;expr&lt;/code&gt; 이 &quot;Bananas&quot;로 평가되면 프로그램은 값을 대소 문자 &quot;Bananas&quot;와 일치시키고 연관된 명령문을 실행합니다. 때 &lt;code&gt;break&lt;/code&gt; 중, 프로그램 나누기 발생 &lt;code&gt;switch&lt;/code&gt; 하고 다음 문 실행 &lt;code&gt;switch&lt;/code&gt; . 경우 &lt;code&gt;break&lt;/code&gt; 생략 된, 경우 &quot;체리&quot;에 대한 문은 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="96f6335874bf336b7e951fdce7655cff74fd7933" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &quot;Oranges&quot; or &quot;Apples&quot;, the program matches the values with either the case &quot;Oranges&quot; or &quot;Apples&quot; and executes the corresponding statement. The &lt;code&gt;default&lt;/code&gt; keyword will help in any other case and executes the associated statement.</source>
          <target state="translated">다음 예에서 &lt;code&gt;expr&lt;/code&gt; 이 &quot;Oranges&quot;또는 &quot;Apples&quot;로 평가되면 프로그램은 값을 &quot;Oranges&quot;또는 &quot;Apples&quot;와 일치시키고 해당 명령문을 실행합니다. &lt;code&gt;default&lt;/code&gt; 키워드는 다른 경우에 도움이 및 관련 문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8237fe8e3542597e9f1b9aab949f95c7735fe5b9" translate="yes" xml:space="preserve">
          <source>In the following example, if &lt;code&gt;expr&lt;/code&gt; evaluates to &lt;code&gt;Bananas&lt;/code&gt;, the program matches the value with case &lt;code&gt;case 'Bananas'&lt;/code&gt; and executes the associated statement. When &lt;code&gt;break&lt;/code&gt; is encountered, the program breaks out of &lt;code&gt;switch&lt;/code&gt; and executes the statement following &lt;code&gt;switch&lt;/code&gt;. If &lt;code&gt;break&lt;/code&gt; were omitted, the statement for the &lt;code&gt;case 'Cherries'&lt;/code&gt; would also be executed.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;expr&lt;/code&gt; 이 &lt;code&gt;Bananas&lt;/code&gt; 로 평가 되면 프로그램은 case &lt;code&gt;case 'Bananas'&lt;/code&gt; 가 있는 값을 일치 시키고 연관된 명령문을 실행합니다. 때 &lt;code&gt;break&lt;/code&gt; 중, 프로그램 나누기 발생 &lt;code&gt;switch&lt;/code&gt; 하고 다음 문 실행 &lt;code&gt;switch&lt;/code&gt; . 경우 &lt;code&gt;break&lt;/code&gt; 생략 된의의 문 &lt;code&gt;case 'Cherries'&lt;/code&gt; 또한 실행된다.</target>
        </trans-unit>
        <trans-unit id="6f90002f54cb6c6ac4fe50fef20e7a2668d7f3de" translate="yes" xml:space="preserve">
          <source>In the following example, if no value is provided for &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; when &lt;code&gt;multiply&lt;/code&gt; is called, &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt;'s value would be &lt;code&gt;undefined&lt;/code&gt; when evaluating &lt;code&gt;&lt;var&gt;a&lt;/var&gt; * &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; would return &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;multiply&lt;/code&gt; 가 호출 될 때 &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; 에 대한 값이 제공되지 않으면 &lt;code&gt;&lt;var&gt;a&lt;/var&gt; * &lt;var&gt;b&lt;/var&gt;&lt;/code&gt; * &lt;var&gt;b&lt;/var&gt; 를 평가할 때 &lt;code&gt;&lt;var&gt;b&lt;/var&gt;&lt;/code&gt; 의 값이 &lt;code&gt;undefined&lt;/code&gt; 않고 &lt;code&gt;multiply&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="16ddded5321b57a0d866951feace6e4cea99bc3c" translate="yes" xml:space="preserve">
          <source>In the following example, if no value is provided for &lt;code&gt;b&lt;/code&gt; when &lt;code&gt;multiply&lt;/code&gt; is called, &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s value would be &lt;code&gt;undefined&lt;/code&gt; when evaluating &lt;code&gt;a * b&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; would return &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;multiply&lt;/code&gt; 가 호출 될 때 &lt;code&gt;b&lt;/code&gt; 에 값이 제공되지 않으면 &lt;code&gt;a * b&lt;/code&gt; 평가할 때 &lt;code&gt;b&lt;/code&gt; 값이 &lt;code&gt;undefined&lt;/code&gt; 않고 &lt;code&gt;multiply&lt;/code&gt; &lt;code&gt;NaN&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="9742f1b1d9915daea9f896ab1adc27f1b391e232" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;do...while&lt;/code&gt; loop iterates at least once and reiterates until &lt;code&gt;i&lt;/code&gt; is no longer less than 5.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;do...while&lt;/code&gt; 루프는 적어도 한 번 반복하고 &lt;code&gt;i&lt;/code&gt; 가 5보다 작을 때까지 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="290da318e59120487518c92d769cd84cc341a64b" translate="yes" xml:space="preserve">
          <source>In the following example, the array &lt;code&gt;numbers&lt;/code&gt; is iterated through by looking at the &lt;code&gt;length&lt;/code&gt; property. The value in each element is then doubled.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;length&lt;/code&gt; 속성을 확인 하여 배열 &lt;code&gt;numbers&lt;/code&gt; 를 반복 합니다. 그런 다음 각 요소의 값이 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="3e970986a7e8da7faf5f169eb8ef1a860c621631" translate="yes" xml:space="preserve">
          <source>In the following example, the constructor for the &lt;code&gt;Product&lt;/code&gt; object is defined with two parameters: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;price&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;Product&lt;/code&gt; 개체 의 생성자 는 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;price&lt;/code&gt; 의 두 매개 변수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c716507b55f4e7d36a7bf5bbf5705d645b4cfbd" translate="yes" xml:space="preserve">
          <source>In the following example, the object has a getter as its own property. On getting the property, the property is removed from the object and re-added, but implicitly as a data property this time. Finally the value gets returned.</source>
          <target state="translated">다음 예제에서 객체에는 자체 속성으로 getter가 있습니다. 속성을 가져 오면 속성이 개체에서 제거되고 다시 추가되지만 이번에는 데이터 속성으로 암시 적으로 지정됩니다. 마지막으로 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="948e31f9a2ae361570277883f29ebf342acf68b5" translate="yes" xml:space="preserve">
          <source>In the following example, the object has a getter as its own property. On getting the property, the property is removed from the object and re-added, but implicitly as a data property this time. Finally, the value gets returned.</source>
          <target state="translated">다음 예제에서 객체에는 자체 속성으로 getter가 있습니다. 속성을 가져 오면 속성이 개체에서 제거되고 다시 추가되지만 이번에는 암시 적으로 데이터 속성으로 추가됩니다. 마지막으로 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63491fcad57234202d5746abce8c2f912c702dac" translate="yes" xml:space="preserve">
          <source>In the following example, the regular expression is defined in &lt;code&gt;replace()&lt;/code&gt; and includes the ignore case flag.</source>
          <target state="translated">다음 예제에서 정규식은 &lt;code&gt;replace()&lt;/code&gt; 정의되며 대소 문자 무시 플래그를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e10c0f043f02b2123d978ede8da98693e4584598" translate="yes" xml:space="preserve">
          <source>In the following example, the usage is probably not intentional:</source>
          <target state="translated">다음 예에서 사용은 의도적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3a594f9a72b0094faccc4763da19747b8d1679" translate="yes" xml:space="preserve">
          <source>In the following example, the variable &lt;code&gt;bigNumber&lt;/code&gt; is assigned a value that is larger than the maximum value. When the &lt;a href=&quot;../../statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; statement executes, &lt;code&gt;bigNumber&lt;/code&gt; has the value &lt;code&gt;Infinity&lt;/code&gt;, so &lt;code&gt;bigNumber&lt;/code&gt; is set to a more manageable value before continuing.</source>
          <target state="translated">다음 예에서 변수 &lt;code&gt;bigNumber&lt;/code&gt; 에는 최대 값보다 큰 값이 지정됩니다. &lt;a href=&quot;../../statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 문이 실행될 때 &lt;code&gt;bigNumber&lt;/code&gt; 의 값은 &lt;code&gt;Infinity&lt;/code&gt; 이므로 계속하기 전에 &lt;code&gt;bigNumber&lt;/code&gt; 가 관리하기 쉬운 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0d991c308ff8ad2345c76fb15afab7a3798cf66" translate="yes" xml:space="preserve">
          <source>In the following example, the variable &lt;code&gt;smallNumber&lt;/code&gt; is assigned a value that is smaller than the minimum value. When the &lt;a href=&quot;../../statements/if...else&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; statement executes, &lt;code&gt;smallNumber&lt;/code&gt; has the value &lt;code&gt;-Infinity&lt;/code&gt;, so &lt;code&gt;smallNumber&lt;/code&gt; is set to a more manageable value before continuing.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;smallNumber&lt;/code&gt; 변수 에는 최소값보다 작은 값이 할당됩니다. &lt;a href=&quot;../../statements/if...else&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 문이 실행될 때 &lt;code&gt;smallNumber&lt;/code&gt; 의 값은 &lt;code&gt;-Infinity&lt;/code&gt; 이므로 &lt;code&gt;smallNumber&lt;/code&gt; 는 계속하기 전에 관리하기 쉬운 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bdf3814229a99d3d55903e9dbbccafa691e79d" translate="yes" xml:space="preserve">
          <source>In the following example, we delete an own property of an object while a property with the same name is available on the prototype chain:</source>
          <target state="translated">다음 예에서는 이름이 같은 속성을 프로토 타입 체인에서 사용할 수있는 동안 객체의 고유 속성을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d1688dd1bc4311871facdb22d215ac29f4cfd269" translate="yes" xml:space="preserve">
          <source>In the following example, we first define a class named &lt;code&gt;Polygon&lt;/code&gt;, then extend it to create a class named &lt;code&gt;Square&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 먼저 &lt;code&gt;Polygon&lt;/code&gt; 이라는 클래스를 정의한 다음이를 확장하여 &lt;code&gt;Square&lt;/code&gt; 라는 클래스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3915fb85a203c34c4701029950bb8a9c14f92f1b" translate="yes" xml:space="preserve">
          <source>In the following example, we first define a class named Polygon, then extend it to create a class named Square. Note that super(), used in the constructor, can only be used in constructors and must be called before the &lt;code&gt;this&lt;/code&gt; keyword can be used.</source>
          <target state="translated">다음 예제에서는 먼저 Polygon이라는 클래스를 정의한 다음 확장하여 Square라는 클래스를 만듭니다. 생성자에서 사용되는 super ()는 생성자에서만 사용할 수 있으며 &lt;code&gt;this&lt;/code&gt; 키워드를 사용 하기 전에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="382dd03774580bb2f9d04acd67e5dab59c412528" translate="yes" xml:space="preserve">
          <source>In the following example, we successively await two promises. Progress moves through function &lt;code&gt;foo&lt;/code&gt; in three stages.</source>
          <target state="translated">다음 예에서는 두 가지 약속을 연속적으로 기다립니다. 진행률은 함수 &lt;code&gt;foo&lt;/code&gt; 를 통해 3 단계로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0ec0333973c02fd58485ca1aa0e462c7548eff95" translate="yes" xml:space="preserve">
          <source>In the following example, when &lt;code&gt;o.f()&lt;/code&gt; is invoked, inside the function &lt;code&gt;this&lt;/code&gt; is bound to the &lt;code&gt;o&lt;/code&gt; object.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;o.f()&lt;/code&gt; 가 호출되면 함수 내에서 &lt;code&gt;this&lt;/code&gt; &lt;code&gt;o&lt;/code&gt; 오브젝트에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="04bcd5d96a4ccd8139ff398132b2d5a23f10fbfa" translate="yes" xml:space="preserve">
          <source>In the following piece of code, &lt;code&gt;slice()&lt;/code&gt; is a bound function to the &lt;a href=&quot;apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;Function.prototype&lt;/code&gt;&lt;/a&gt;, with the &lt;code&gt;this&lt;/code&gt; value set to the &lt;a href=&quot;../array/slice&quot;&gt;&lt;code&gt;slice()&lt;/code&gt;&lt;/a&gt; function of &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt;&lt;code&gt;Array.prototype&lt;/code&gt;&lt;/a&gt;. This means that additional &lt;code&gt;apply()&lt;/code&gt; calls can be eliminated:</source>
          <target state="translated">코드의 다음 부분에서, &lt;code&gt;slice()&lt;/code&gt; 받는 바운드 함수 &lt;a href=&quot;apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 의 함수 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;Function.prototype&lt;/code&gt; &lt;/a&gt; 와, &lt;code&gt;this&lt;/code&gt; 받는 값 세트 &lt;a href=&quot;../array/slice&quot;&gt; &lt;code&gt;slice()&lt;/code&gt; &lt;/a&gt; 의 함수 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype&quot;&gt; &lt;code&gt;Array.prototype&lt;/code&gt; 으로&lt;/a&gt; . 이는 추가 &lt;code&gt;apply()&lt;/code&gt; 호출을 제거 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="910701d472ecd5b702fc4b46aec86e952f4bac39" translate="yes" xml:space="preserve">
          <source>In the former instance, JS seems to find an empty string just after the specified index value. In the latter instance, JS seems to be finding an empty string at the end of the searched string.</source>
          <target state="translated">전자의 경우 JS는 지정된 인덱스 값 바로 뒤에 빈 문자열을 찾는 것 같습니다. 후자의 경우 JS는 검색된 문자열의 끝에서 빈 문자열을 찾는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e95ef1758d9879398c7d717728553d776121d64a" translate="yes" xml:space="preserve">
          <source>In the function signature for &lt;code&gt;drawChart&lt;/code&gt; above, the destructured left-hand side is assigned to an empty object literal on the right-hand side: &lt;code&gt;{size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt;. You could have also written the function without the right-hand side assignment. However, if you leave out the right-hand side assignment, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can simply call &lt;code&gt;&lt;strong&gt;drawChart()&lt;/strong&gt;&lt;/code&gt; without supplying any parameters. The current design is useful if you want to be able to call the function without supplying any parameters, the other can be useful when you want to ensure an object is passed to the function.</source>
          <target state="translated">위의 &lt;code&gt;drawChart&lt;/code&gt; 에 대한 함수 시그니처에서 구조화 해제 된 왼쪽은 오른쪽의 빈 개체 리터럴에 할당됩니다. &lt;code&gt;{size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt; . 오른쪽 할당없이 함수를 작성할 수도 있습니다. 그러나 오른쪽 할당을 생략하면 함수가 호출 될 때 제공 할 인수를 하나 이상 찾는 반면 현재 형식에서는 매개 변수를 제공하지 않고 간단히 &lt;code&gt;&lt;strong&gt;drawChart()&lt;/strong&gt;&lt;/code&gt; 를 호출 할 수 있습니다 . 현재 디자인은 매개 변수를 제공하지 않고 함수를 호출하려는 경우 유용하고 다른 하나는 객체가 함수에 전달되는지 확인하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320ac0eafa6debb7dcd8b9758ef8cfe6b6f8db61" translate="yes" xml:space="preserve">
          <source>In the function signature for &lt;code&gt;drawES2015Chart&lt;/code&gt; above, the destructured left-hand side is assigned to an empty object literal on the right-hand side: &lt;code&gt;{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt;. You could have also written the function without the right-hand side assignment. However, if you leave out the right-hand side assignment, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can simply call &lt;code&gt;&lt;strong&gt;drawES2015Chart()&lt;/strong&gt;&lt;/code&gt; without supplying any parameters. The current design is useful if you want to be able to call the function without supplying any parameters, the other can be useful when you want to ensure an object is passed to the function.</source>
          <target state="translated">위의 &lt;code&gt;drawES2015Chart&lt;/code&gt; 에 대한 함수 시그니처에서, 비 구조화 된 왼쪽은 오른쪽의 빈 객체 리터럴에 할당됩니다 : &lt;code&gt;{size = 'big', cords = {x: 0, y: 0}, radius = 25} = {}&lt;/code&gt; . 오른쪽 할당없이 함수를 작성할 수도 있습니다. 그러나 오른쪽 할당을 생략하면 함수는 호출 될 때 제공 할 인수를 하나 이상 찾습니다. 현재 형식에서는 매개 변수를 제공하지 않고 &lt;code&gt;&lt;strong&gt;drawES2015Chart()&lt;/strong&gt;&lt;/code&gt; 를 호출 할 수 있습니다 . 현재 디자인은 매개 변수를 제공하지 않고 함수를 호출 할 수있는 경우에 유용하며, 다른 하나는 객체가 함수에 전달되도록 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384cd9fe2f63891e05c6315f490a0fe09b2696a0" translate="yes" xml:space="preserve">
          <source>In the global context, a variable declared using &lt;code&gt;var&lt;/code&gt; is added as a non-configurable property of the global object. This means its property descriptor cannot be changed and it cannot be deleted using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;. The corresponding name is also added to a list on the internal &lt;code&gt;[[VarNames]]&lt;/code&gt; slot on the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-global-environment-records&quot;&gt;global environment record&lt;/a&gt; (which forms part of the global lexical environment). The list of names in &lt;code&gt;[[VarNames]]&lt;/code&gt; enables the runtime to distinguish between global variables and straightforward properties on the global object.</source>
          <target state="translated">전역 컨텍스트에서 &lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 변수는 전역 개체의 구성 할 수없는 속성으로 추가됩니다. 이는 속성 설명자를 변경할 수 없으며 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; 를&lt;/a&gt; 사용하여 삭제할 수 없음을 의미합니다 . 해당 이름은 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-global-environment-records&quot;&gt;전역 환경 레코드&lt;/a&gt; (전역 어휘 환경의 일부를 형성) 의 내부 &lt;code&gt;[[VarNames]]&lt;/code&gt; 슬롯에 있는 목록에도 추가됩니다 . &lt;code&gt;[[VarNames]]&lt;/code&gt; 의 이름 목록을 사용하면 런타임에서 전역 변수와 전역 개체의 간단한 속성을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec2ed1a49c59897eb318170d9b6bd3065461b6d" translate="yes" xml:space="preserve">
          <source>In the global execution context (outside of any function), &lt;code&gt;this&lt;/code&gt; refers to the global object whether in strict mode or not.</source>
          <target state="translated">전역 실행 컨텍스트 (함수 외부)에서 &lt;code&gt;this&lt;/code&gt; 엄격 모드에 있든 없든 전역 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4323cb3e94dbb71c6dea4adf5e31307a360729a9" translate="yes" xml:space="preserve">
          <source>In the last example (&lt;code&gt;C2&lt;/code&gt;), because an object was returned during construction, the new object that &lt;code&gt;this&lt;/code&gt; was bound to simply gets discarded. (This essentially makes the statement &quot;&lt;code&gt;this.a = 37;&lt;/code&gt;&quot; dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)</source>
          <target state="translated">마지막 예 (에서는 &lt;code&gt;C2&lt;/code&gt; 개체 생성 중에 되돌려 때문에), 그 새로운 오브젝트 &lt;code&gt;this&lt;/code&gt; 묶여 단순히 폐기 도착한다. (이것은 본질적으로 &quot; &lt;code&gt;this.a = 37;&lt;/code&gt; &quot;죽은 코드입니다. 실행되기 때문에 정확히 죽지는 않았지만 외부 효과없이 제거 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="00e90f9a8f3cbcb6e3ee4661127d9871d59bd623" translate="yes" xml:space="preserve">
          <source>In the module, we could use the following code:</source>
          <target state="translated">모듈에서 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a9e58aa43466c9b9026972ff36cb4dd102c297" translate="yes" xml:space="preserve">
          <source>In the next example, a rest parameter is used to collect all arguments after the first one in an array. Each one of them is then multiplied by the first parameter and the array is returned:</source>
          <target state="translated">다음 예제에서 rest 매개 변수는 배열에서 첫 번째 인수 이후의 모든 인수를 수집하는 데 사용됩니다. 그런 다음 각 매개 변수에 첫 번째 매개 변수를 곱하면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d0de29c2467a1bcda0bcf6cead5586e0aa1d34" translate="yes" xml:space="preserve">
          <source>In the next example, a rest parameter is used to collect all parameters after the first into an array. Each one of them is then multiplied by the first parameter, and the array is returned:</source>
          <target state="translated">다음 예에서 나머지 매개 변수는 첫 번째 매개 변수 이후의 모든 매개 변수를 배열로 수집하는 데 사용됩니다. 그런 다음 각각에 첫 번째 매개 변수를 곱하고 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb91bb9b2b1254cf0c448c27969519e3a92034" translate="yes" xml:space="preserve">
          <source>In the next example, an &lt;a href=&quot;if...else&quot;&gt;&lt;code&gt;if...else&lt;/code&gt;&lt;/a&gt; statement without curly braces (&lt;code&gt;{}&lt;/code&gt;) is used.</source>
          <target state="translated">다음 예에서는 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )가 없는 &lt;a href=&quot;if...else&quot;&gt; &lt;code&gt;if...else&lt;/code&gt; &lt;/a&gt; 문 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e204d4b72625c73764da0600a44e35ab5711b4a" translate="yes" xml:space="preserve">
          <source>In the past, the general strategy for setting defaults was to test parameter values in the function body and assign a value if they are &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">과거에는 기본값을 설정하는 일반적인 전략이 함수 본문에서 매개 변수 값을 테스트하고 &lt;code&gt;undefined&lt;/code&gt; 경우 값을 지정하는 것이 었습니다 .</target>
        </trans-unit>
        <trans-unit id="118743fe11f8aa51b1246d6b929e4cf6c2a3a3c4" translate="yes" xml:space="preserve">
          <source>In the replacement text, the script uses &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; to indicate the results of the corresponding matching parentheses in the regular expression pattern.</source>
          <target state="translated">대체 텍스트에서 스크립트는 &lt;code&gt;$1&lt;/code&gt; 및 &lt;code&gt;$2&lt;/code&gt; 를 사용하여 정규식 패턴에서 일치하는 괄호의 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="18901524c393bd6c9d4140d7173cf206ad8f759d" translate="yes" xml:space="preserve">
          <source>In the same line, the &lt;code&gt;if&lt;/code&gt; block's &lt;code&gt;foo&lt;/code&gt; has already been created in the lexical environment, but has not yet reached (and terminated) its initialization (which is part of the statement itself).</source>
          <target state="translated">같은 줄에서 &lt;code&gt;if&lt;/code&gt; 블록의 &lt;code&gt;foo&lt;/code&gt; 는 어휘 환경에서 이미 생성되었지만 아직 초기화 (문 자체의 일부)에 도달 (및 종료)되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6f67384bff317df6dc3f3c5721272dbec196a342" translate="yes" xml:space="preserve">
          <source>In the second call in this example, even if the first argument is set explicitly to &lt;code&gt;undefined&lt;/code&gt; (though not &lt;code&gt;null&lt;/code&gt; or other &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;falsy&lt;/a&gt; values), the value of the &lt;code&gt;&lt;var&gt;num&lt;/var&gt;&lt;/code&gt; argument is still the default.</source>
          <target state="translated">이 예제의 두 번째 호출에서 첫 번째 인수가 명시 적으로 &lt;code&gt;undefined&lt;/code&gt; ( &lt;code&gt;null&lt;/code&gt; 또는 다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/falsy&quot;&gt;잘못된&lt;/a&gt; 값은 아님)로 설정되어 있어도 &lt;code&gt;&lt;var&gt;num&lt;/var&gt;&lt;/code&gt; 인수 의 값 은 여전히 ​​기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c8b8cef8365495d74b0b650d8145880b109b506c" translate="yes" xml:space="preserve">
          <source>In the second call in this example, even if the first argument is set explicitly to &lt;code&gt;undefined&lt;/code&gt; (though not &lt;code&gt;null&lt;/code&gt; or other &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;falsy&lt;/a&gt; values&lt;/em&gt;), the value of the &lt;code&gt;num&lt;/code&gt; argument is still the default.</source>
          <target state="translated">이 예제의 두 번째 호출에서 첫 번째 인수가 명시 적으로 &lt;code&gt;undefined&lt;/code&gt; ( &lt;code&gt;null&lt;/code&gt; 또는 기타 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;잘못된&lt;/a&gt; 값은&lt;/em&gt; 아니지만 ) 설정되어 &lt;em&gt;있어도&lt;/em&gt; &lt;code&gt;num&lt;/code&gt; 인수 의 값 은 여전히 ​​기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7b79ff68d3fff0dd724c0e66e2c8369970388f4e" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;this&lt;/code&gt; should be &lt;a href=&quot;../global_objects/undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, because &lt;code&gt;f2&lt;/code&gt; was called directly and not as a method or property of an object (e.g. &lt;code&gt;window.f2()&lt;/code&gt;). This feature wasn't implemented in some browsers when they first started to support &lt;a href=&quot;../strict_mode&quot;&gt;strict mode&lt;/a&gt;. As a result, they incorrectly returned the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">두 번째 예에서는 &lt;code&gt;this&lt;/code&gt; 되어야 &lt;a href=&quot;../global_objects/undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; 때문에, &lt;code&gt;f2&lt;/code&gt; 객체의 메소드 또는 속성으로 직접 호출하지 하였다 (예 &lt;code&gt;window.f2()&lt;/code&gt; ). 이 기능은 일부 브라우저에서 &lt;a href=&quot;../strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 지원을 처음 시작했을 때 구현되지 않았습니다 . 결과적으로 &lt;code&gt;window&lt;/code&gt; 개체 를 잘못 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="0cd33ef758331369d99dcee31aeb7e6ca215fa7f" translate="yes" xml:space="preserve">
          <source>In the syntax, the text string represents the literal text that you want the user to see. The &lt;code&gt;name&lt;/code&gt; parameter string represents the &lt;code&gt;name&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">구문에서 텍스트 문자열은 사용자에게 표시 할 리터럴 텍스트를 나타냅니다. &lt;code&gt;name&lt;/code&gt; 매개 변수 문자열이 나타내는 &lt;code&gt;name&lt;/code&gt; 의 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를.</target>
        </trans-unit>
        <trans-unit id="eae556c3be7f945436b5d6044a42766b280d5e47" translate="yes" xml:space="preserve">
          <source>In the table below, &lt;strong&gt;Grouping&lt;/strong&gt; is listed as having the highest precedence. However, that does not always mean the expression within the grouping symbols &lt;code&gt;( &amp;hellip; )&lt;/code&gt; is evaluated first, especially when it comes to short-circuiting.</source>
          <target state="translated">아래 표에서 &lt;strong&gt;그룹화&lt;/strong&gt; 는 우선 순위가 가장 높은 것으로 나열됩니다. 그러나 이것이 항상 그룹화 기호 &lt;code&gt;( &amp;hellip; )&lt;/code&gt; 내의 표현식 이 먼저 평가 된다는 것을 의미하지는 않습니다 . 특히 단락과 관련하여 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="53bb1c4268b088f014ea5a9a7d9ea551816d49cc" translate="yes" xml:space="preserve">
          <source>In the uncompressed version, the program runs into the truthy-branch and logs &quot;&lt;code&gt;'foo' is an instance of 'Foo'&lt;/code&gt;&quot;. Whereas, in the compressed version it behaves differently, and runs into the else-branch. If you rely on &lt;code&gt;Function.name&lt;/code&gt;, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function to have a particular name.</source>
          <target state="translated">압축되지 않은 버전에서 프로그램은 truthy-branch로 실행되고 &quot; &lt;code&gt;'foo' is an instance of 'Foo'&lt;/code&gt; foo'is an instance of 'Foo' &quot;를 기록합니다. 반면 압축 된 버전에서는 다르게 동작하고 else-branch로 실행됩니다. 위의 예와 같이 &lt;code&gt;Function.name&lt;/code&gt; 에 의존하는 경우 빌드 파이프 라인이 함수 이름을 변경하지 않도록하거나 함수에 특정 이름이 있다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="79bb87933d62241b361f74acb67f3e98a281c829" translate="yes" xml:space="preserve">
          <source>In the uncompressed version, the program runs into the truthy-branch and logs &lt;em&gt;'foo' is an instance of 'Foo'&lt;/em&gt;. Whereas, in the compressed version it behaves differently, and runs into the else-branch. If you rely on &lt;code&gt;Function.name&lt;/code&gt;, like in the example above, make sure your build pipeline doesn't change function names, or don't assume a function to have a particular name.</source>
          <target state="translated">압축되지 않은 버전에서 프로그램은 진리 지점으로 실행되며 &lt;em&gt;'foo'는 'Foo'의 인스턴스입니다&lt;/em&gt; . 반면 압축 버전에서는 다르게 동작하고 else-branch로 실행됩니다. 위의 예와 같이 &lt;code&gt;Function.name&lt;/code&gt; 에 의존하는 경우 빌드 파이프 라인이 함수 이름을 변경하지 않거나 특정 이름을 가진 함수를 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a6045774c4491fab11ca343b8a71fe9f28294720" translate="yes" xml:space="preserve">
          <source>In the worker (see &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt;) we define an import object for the module to use, then set up an event handler to receive the module from the main thread. When the module is received, we create an instance from it using the &lt;a href=&quot;instantiate&quot;&gt;&lt;code&gt;WebAssembly.instantiate()&lt;/code&gt;&lt;/a&gt; method and invoke an exported function from inside it.</source>
          <target state="translated">워커 ( &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt; 참조 )에서 모듈이 사용할 가져 오기 오브젝트를 정의한 후 기본 스레드에서 모듈을 수신하도록 이벤트 핸들러를 설정하십시오. 모듈이 수신되면 &lt;a href=&quot;instantiate&quot;&gt; &lt;code&gt;WebAssembly.instantiate()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 모듈에서 인스턴스를 작성하고 내부에서 내 보낸 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="012ee32c213d819cb9d3fb7476f49f1095628ce9" translate="yes" xml:space="preserve">
          <source>In the worker (see &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt;) we define an import object for the module to use, then set up an event handler to receive the module from the main thread. when the module is received, we create an instance from it using the &lt;a href=&quot;../instantiate&quot;&gt;&lt;code&gt;WebAssembly.Instantiate()&lt;/code&gt;&lt;/a&gt; method, invoke an exported function from inside it, then show how we can return information on the available exports on a module using &lt;code&gt;WebAssembly.Module.exports&lt;/code&gt;.</source>
          <target state="translated">워커 ( &lt;code&gt;&lt;a href=&quot;https://github.com/mdn/webassembly-examples/blob/master/js-api-examples/wasm_worker.js&quot;&gt;wasm_worker.js&lt;/a&gt;&lt;/code&gt; 참조 )에서 모듈이 사용할 가져 오기 오브젝트를 정의한 후 기본 스레드에서 모듈을 수신하도록 이벤트 핸들러를 설정하십시오. 모듈이 수신되면 &lt;a href=&quot;../instantiate&quot;&gt; &lt;code&gt;WebAssembly.Instantiate()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 인스턴스를 작성하고 그 안에서 내 보낸 함수를 호출 한 다음 &lt;code&gt;WebAssembly.Module.exports&lt;/code&gt; 를 사용하여 모듈에서 사용 가능한 내보내기에 대한 정보를 리턴하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="70bec1ed815f54f78684ae17e4732e9e7306cdd6" translate="yes" xml:space="preserve">
          <source>In this case it's important to return only an integer (so a simple division won't do), and also to only return actually elapsed seconds (that's why this code uses &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt; and not &lt;a href=&quot;math/round&quot;&gt;&lt;code&gt;Math.round()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 경우 정수만 반환하므로 간단한 나누기가 수행되지 않고 실제로 경과 한 초만 반환하는 것이 중요합니다 (이 코드는 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;math/round&quot;&gt; &lt;code&gt;Math.round()&lt;/code&gt; &lt;/a&gt; 는 사용 하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="8c9f7d01af5e1fce725fc980e3a1487d78434b0a" translate="yes" xml:space="preserve">
          <source>In this case, it's important to return only an integer&amp;mdash;so a simple division won't do. It's also important to only return actually elapsed seconds. (That's why this code uses &lt;a href=&quot;math/floor&quot;&gt;&lt;code&gt;Math.floor()&lt;/code&gt;&lt;/a&gt;, and &lt;em&gt;not&lt;/em&gt;&lt;a href=&quot;math/round&quot;&gt;&lt;code&gt;Math.round()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">이 경우 정수만 반환하는 것이 중요하므로 간단한 나눗셈은 수행하지 않습니다. 실제로 경과 한 초만 반환하는 것도 중요합니다. (이 코드가 사용하는 이유입니다 &lt;a href=&quot;math/floor&quot;&gt; &lt;code&gt;Math.floor()&lt;/code&gt; &lt;/a&gt; 하고 &lt;em&gt;있지 &lt;/em&gt;&lt;a href=&quot;math/round&quot;&gt; &lt;code&gt;Math.round()&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="186a0d96b6bdd1c3792c513064740ed74358e3ab" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;console.log()&lt;/code&gt; call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.</source>
          <target state="translated">이 경우 &lt;code&gt;console.log()&lt;/code&gt; 호출은 주석 안에 있으므로 실행되지 않습니다. 이 방법으로 여러 줄의 코드를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c6fb8b542b497eb35334ab759b3e7f836b4e4a" translate="yes" xml:space="preserve">
          <source>In this case, the function &lt;code&gt;sum&lt;/code&gt; has default parameters &lt;code&gt;a=1&lt;/code&gt; and &lt;code&gt;b=2&lt;/code&gt;:</source>
          <target state="translated">이 경우 함수 &lt;code&gt;sum&lt;/code&gt; 에는 기본 매개 변수 &lt;code&gt;a=1&lt;/code&gt; 및 &lt;code&gt;b=2&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c25e00d5dc533083c80281b6cb39e68fc1bfd2" translate="yes" xml:space="preserve">
          <source>In this case, the inner function's &lt;code&gt;this&lt;/code&gt; isn't set so it returns the global/window object (i.e. the default object in non&amp;ndash;strict mode where &lt;code&gt;this&lt;/code&gt; isn't set by the call).</source>
          <target state="translated">이 경우, 내부 기능의 &lt;code&gt;this&lt;/code&gt; 는 글로벌 / 창 개체를 반환 있도록 설정되지 않은 (즉, 비 엄격 모드의 기본 목적 &lt;code&gt;this&lt;/code&gt; 호출에 의해 설정되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="ee090e37a02dcb4f76244ca9578ebc7366ff2c73" translate="yes" xml:space="preserve">
          <source>In this case, the property &lt;code&gt;bar&lt;/code&gt; is an undefined property, so a &lt;code&gt;ReferenceError&lt;/code&gt; will occur.</source>
          <target state="translated">이 경우 속성 &lt;code&gt;bar&lt;/code&gt; 은 정의되지 않은 속성이므로 &lt;code&gt;ReferenceError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ba12f762c8080d1368efbc5da9ff771dc86bdae" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;arg&quot; redeclares the argument.</source>
          <target state="translated">이 경우 변수 &quot;arg&quot;는 인수를 다시 선언합니다.</target>
        </trans-unit>
        <trans-unit id="37c152d2215becaac46c7389493a06f938d3439c" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;bar&quot; is an undeclared variable.</source>
          <target state="translated">이 경우 변수 &quot;bar&quot;는 선언되지 않은 변수입니다.</target>
        </trans-unit>
        <trans-unit id="1089c3880315f3e567e584d5eccf757d257bcc7e" translate="yes" xml:space="preserve">
          <source>In this case, the variable &quot;foo&quot; is redeclared in the block statement using &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;let&lt;/code&gt; 을 사용하여 &quot;foo&quot;변수를 블록 명령문에서 다시 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="607fad50d33fb3b355e7cc4cdeae47a48846941f" translate="yes" xml:space="preserve">
          <source>In this case, we return all the selected &lt;code&gt;option&lt;/code&gt;s' values on the screen:</source>
          <target state="translated">이 경우 선택한 모든 &lt;code&gt;option&lt;/code&gt; 값을 화면에 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5233ec322e51b52c87cb640dd6c9fe7a2b2a7d5" translate="yes" xml:space="preserve">
          <source>In this case, which happens way too often, there is a typo in the method name:</source>
          <target state="translated">이 경우 너무 자주 발생하는 메서드 이름에 오타가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce98cc8bdab5c6d18ec608646a8a392ecc6990dc" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;property&lt;/code&gt; must be a valid JavaScript identifier, i.e. a sequence of alphanumerical characters, also including the underscore (&quot;&lt;code&gt;_&lt;/code&gt;&quot;) and dollar sign (&quot;&lt;code&gt;$&lt;/code&gt;&quot;), that cannot start with a number. For example, &lt;code&gt;object.$1&lt;/code&gt; is valid, while &lt;code&gt;object.1&lt;/code&gt; is not.</source>
          <target state="translated">이 코드에서 &lt;code&gt;property&lt;/code&gt; 는 유효한 JavaScript 식별자, 즉 밑줄 ( &quot; &lt;code&gt;_&lt;/code&gt; &quot;)과 달러 기호 ( &quot; &lt;code&gt;$&lt;/code&gt; &quot;)를 포함하여 숫자로 시작할 수없는 일련의 영숫자 문자 여야합니다 . 예를 들어 &lt;code&gt;object.$1&lt;/code&gt; 은 유효하지만 &lt;code&gt;object.1&lt;/code&gt; 은 유효 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcac0f21dd62d88cc1fc1d7c5edc9c0b7b37a5fd" translate="yes" xml:space="preserve">
          <source>In this example we define a function that can add two or more numbers together.</source>
          <target state="translated">이 예에서는 둘 이상의 숫자를 더할 수있는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="44ecc52fcc1dd532a59d37d9c27852cb4e6632c6" translate="yes" xml:space="preserve">
          <source>In this example when the setter is triggered, it is told to do the same thing again: &lt;em&gt;to set the same property that it is meant to handle.&lt;/em&gt; This causes the function to call itself, again and again, making it infinitely recursive.</source>
          <target state="translated">이 예제에서는 setter가 트리거 될 때 동일한 작업을 다시 수행하도록 지시합니다 &lt;em&gt;. 처리 할 동일한 속성을 설정합니다. &lt;/em&gt;이로 인해 함수가 계속해서 자신을 호출하여 무한 재귀 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bfda2fb9a04305f886bcd0e49716e0ef48179b89" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;f()&lt;/code&gt; returns the values &lt;code&gt;[1, 2]&lt;/code&gt; as its output, which can be parsed in a single line with destructuring.</source>
          <target state="translated">이 예에서 &lt;code&gt;f()&lt;/code&gt; 는 &lt;code&gt;[1, 2]&lt;/code&gt; 값을 출력으로 반환하며,이 값 은 한 줄로 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec37b22188853fa195e1eb0a40dd6fc5647d4b0" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;next&lt;/code&gt; is called with a value.</source>
          <target state="translated">이 예에서 &lt;code&gt;next&lt;/code&gt; 는 값으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a73078322457f6e2a4f76866f7f2bd2d296423" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;next&lt;/code&gt; is called with a value. Note that the first call did not log anything, because the generator was not yielding anything initially.</source>
          <target state="translated">이 예에서 &lt;code&gt;next&lt;/code&gt; 는 값으로 호출됩니다. 생성기가 처음에 아무것도 생성하지 않았기 때문에 첫 번째 호출은 아무것도 기록하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="563d6171046b28102d99d569274b89bdabeb1e27" translate="yes" xml:space="preserve">
          <source>In this example, a getter always returns the same value.</source>
          <target state="translated">이 예제에서 getter는 항상 같은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d925e67a635ae1e3d2c5b8950ddc3283286c2d1" translate="yes" xml:space="preserve">
          <source>In this example, all occurrences of capital letters in the string are converted to lower case, and a hyphen is inserted just before the match location. The important thing here is that additional operations are needed on the matched item before it is given back as a replacement.</source>
          <target state="translated">이 예에서 문자열에서 모든 대문자는 소문자로 변환되며 일치 위치 바로 앞에 하이픈이 삽입됩니다. 여기서 중요한 것은 일치 항목에 대한 추가 작업이 교체품으로 다시 제공되기 전에 필요하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f33012959cef3631ac1b179a71cdf251a2d34c8f" translate="yes" xml:space="preserve">
          <source>In this example, the first argument is mapped to &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the second to &lt;code&gt;&quot;b&quot;&lt;/code&gt;, so these named arguments are used like normal. However the third argument &lt;code&gt;&quot;manyMoreArgs&quot;&lt;/code&gt; will be an array that contains the 3rd, 4th, 5th, 6th ... nth -- as many arguments that the user includes.</source>
          <target state="translated">이 예에서 첫 번째 인수는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 에 매핑되고 두 번째 인수는 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 에 매핑 되므로 이러한 명명 된 인수는 일반처럼 사용됩니다. 그러나 세 번째 인수 &lt;code&gt;&quot;manyMoreArgs&quot;&lt;/code&gt; 는 사용자가 포함하는 많은 인수 인 3 번째, 4 번째, 5 번째, 6 번째 ... n 번째를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b5ba9ccc89fc1604d1696a6f06c45a0e15818a82" translate="yes" xml:space="preserve">
          <source>In this example, the first argument is mapped to &lt;code&gt;a&lt;/code&gt; and the second to &lt;code&gt;b&lt;/code&gt;, so these named arguments are used as normal.</source>
          <target state="translated">이 예에서 첫 번째 인수는 &lt;code&gt;a&lt;/code&gt; 에 매핑되고 두 번째 인수는 &lt;code&gt;b&lt;/code&gt; 에 되므로 이러한 명명 된 인수가 정상적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="694ce76b4ee53e67741df07c604b0136305f4feb" translate="yes" xml:space="preserve">
          <source>In this example, the object assigned to the variable &lt;code&gt;p&lt;/code&gt; doesn't have its own &lt;code&gt;f&lt;/code&gt; property, it inherits it from its prototype. But it doesn't matter that the lookup for &lt;code&gt;f&lt;/code&gt; eventually finds a member with that name on &lt;code&gt;o&lt;/code&gt;; the lookup began as a reference to &lt;code&gt;p.f&lt;/code&gt;, so &lt;code&gt;this&lt;/code&gt; inside the function takes the value of the object referred to as &lt;code&gt;p&lt;/code&gt;. That is, since &lt;code&gt;f&lt;/code&gt; is called as a method of &lt;code&gt;p&lt;/code&gt;, its &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;p&lt;/code&gt;. This is an interesting feature of JavaScript's prototype inheritance.</source>
          <target state="translated">이 예에서 변수 &lt;code&gt;p&lt;/code&gt; 에 지정된 객체 에는 고유 한 &lt;code&gt;f&lt;/code&gt; 속성 이 없으며 프로토 타입에서 상속됩니다. 그러나 &lt;code&gt;f&lt;/code&gt; 에 대한 조회가 결국 &lt;code&gt;o&lt;/code&gt; 에서 해당 이름을 가진 멤버를 찾는 것은 중요하지 않습니다 . 룩업은 참조로 시작 &lt;code&gt;p.f&lt;/code&gt; 있으므로, &lt;code&gt;this&lt;/code&gt; 함수라고 대상물의 내부 값 걸리는 &lt;code&gt;p&lt;/code&gt; . 이후, 즉 &lt;code&gt;f&lt;/code&gt; 방법으로 불린다 &lt;code&gt;p&lt;/code&gt; 그 &lt;code&gt;this&lt;/code&gt; 지칭 &lt;code&gt;p&lt;/code&gt; . 이것은 JavaScript 프로토 타입 상속의 흥미로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="66ff041dbef1cfc7f06522a5a35ef052cd6ff39d" translate="yes" xml:space="preserve">
          <source>In this example, we are using a native JavaScript object to which our proxy will forward all operations that are applied to it.</source>
          <target state="translated">이 예에서는 프록시가 적용되는 모든 작업을 프록시가 전달할 기본 JavaScript 객체를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f8bcdd4576e052baef77d87b035aec5006ad25" translate="yes" xml:space="preserve">
          <source>In this example, we create a 8-byte buffer with a &lt;a href=&quot;int32array&quot;&gt;&lt;code&gt;Int32Array&lt;/code&gt;&lt;/a&gt; view referring to the buffer:</source>
          <target state="translated">이 예제에서는 버퍼를 참조 하는 &lt;a href=&quot;int32array&quot;&gt; &lt;code&gt;Int32Array&lt;/code&gt; &lt;/a&gt; 보기를 사용하여 8 바이트 버퍼를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="87a870c20fd5c4ac21e8e1fefbf9420b0799bf46" translate="yes" xml:space="preserve">
          <source>In this example, we create an anonymous function and use &lt;code&gt;call&lt;/code&gt; to invoke it on every object in an array.</source>
          <target state="translated">이 예에서는 익명 함수를 만들고 &lt;code&gt;call&lt;/code&gt; 을 하여 배열의 모든 개체에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="02d622e8d0d99304a0a0a4b1c302b418fb7d05cf" translate="yes" xml:space="preserve">
          <source>In this example, we create an anonymous function and use &lt;code&gt;call&lt;/code&gt; to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as &lt;code&gt;this&lt;/code&gt; value was not strictly necessary, but is done for explanatory purpose.</source>
          <target state="translated">이 예제에서는 익명 함수를 만들고 &lt;code&gt;call&lt;/code&gt; 을 사용 하여 배열의 모든 객체에서 호출합니다. 여기서 익명 함수의 주요 목적은 모든 객체에 인쇄 기능을 추가하여 배열에서 객체의 올바른 색인을 인쇄 할 수 있도록하는 것입니다. &lt;code&gt;this&lt;/code&gt; 값을 객체로 전달하는 것이 꼭 필요한 것은 아니지만 설명 목적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d35974a3e7587dcc087e5970b5717fe14b1ffcde" translate="yes" xml:space="preserve">
          <source>In this list, each page is listed by name (the type of error) and message (a more detailed human-readable error message). Together, these two properties provide a starting point toward understanding and resolving the error. For more information, follow the links below!</source>
          <target state="translated">이 목록에서 각 페이지는 이름 (오류 유형) 및 메시지 (보다 자세한 사람이 읽을 수있는 오류 메시지)로 나열됩니다. 이 두 가지 특성은 함께 오류를 이해하고 해결하는 출발점을 제공합니다. 자세한 내용은 아래 링크를 참조하십시오!</target>
        </trans-unit>
        <trans-unit id="84cc35eeca38031ad4f482983b4a69f835b760cf" translate="yes" xml:space="preserve">
          <source>In this simple example the number &lt;code&gt;37&lt;/code&gt; gets returned as the default value when the property name is not in the object. It is using the &lt;a href=&quot;proxy/handler/get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 간단한 예제에서 속성 이름이 객체에 없으면 숫자 &lt;code&gt;37&lt;/code&gt; 이 기본값으로 반환됩니다. &lt;a href=&quot;proxy/handler/get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 핸들러를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9f63da3eb0045c2357f1cdb851b284fdcaffc13" translate="yes" xml:space="preserve">
          <source>In this simple example, the number &lt;code&gt;37&lt;/code&gt; gets returned as the default value when the property name is not in the object. It is using the &lt;a href=&quot;proxy/proxy/get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 간단한 예 에서 속성 이름이 개체에 없으면 숫자 &lt;code&gt;37&lt;/code&gt; 이 기본값으로 반환됩니다. 그것은 사용하고 있습니다&lt;a href=&quot;proxy/proxy/get&quot;&gt; &lt;code&gt;get&lt;/code&gt; &lt;/a&gt; 핸들러를있습니다.</target>
        </trans-unit>
        <trans-unit id="590403612835e59c245f0cdab1e404168d22e494" translate="yes" xml:space="preserve">
          <source>In unusual situations, the assignment operator (e.g.&lt;code&gt; x += y&lt;/code&gt;) is not identical to the meaning expression (here &lt;code&gt;x = x + y&lt;/code&gt;). When the left operand of an assignment operator itself contains an assignment operator, the left operand is evaluated only once. For example:</source>
          <target state="translated">비정상적인 상황에서 대입 연산자 (예 : &lt;code&gt; x += y&lt;/code&gt; )는 의미 표현식 (여기서 &lt;code&gt;x = x + y&lt;/code&gt; ) 과 동일하지 않습니다 . 대입 연산자 자체의 왼쪽 피연산자에 대입 연산자가 있으면 왼쪽 피연산자가 한 번만 평가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a131dacbe54fb64553702d39cdf6558030b34fb8" translate="yes" xml:space="preserve">
          <source>Included in the (normative) annex for additional ECMAScript legacy features for Web browsers (note that the specification codifies what is already in implementations).</source>
          <target state="translated">웹 브라우저에 대한 추가 ECMAScript 레거시 기능에 대한 (표준) 부록에 포함되어 있습니다 (사양에는 이미 구현중인 내용이 나와 있습니다).</target>
        </trans-unit>
        <trans-unit id="4041f4126b0351dfe2e79c79a3f6557e3c70b29b" translate="yes" xml:space="preserve">
          <source>Incomplete array initializer</source>
          <target state="translated">불완전한 배열 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="4c69aeda2103b6e78518bbb410b414f8da34036f" translate="yes" xml:space="preserve">
          <source>Increases the size of the Table instance by a specified number of elements.</source>
          <target state="translated">지정된 수의 요소만큼 Table 인스턴스의 크기를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="1ad7f4e9bdfd8b6afc5185d816fa7e2287a97748" translate="yes" xml:space="preserve">
          <source>Increases the size of the Table instance by a specified number of references.</source>
          <target state="translated">지정된 수의 참조만큼 Table 인스턴스의 크기를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c99f880b72799cc04c963d4317c186789a75c6d6" translate="yes" xml:space="preserve">
          <source>Increases the size of the memory instance by a specified number of WebAssembly pages (each one is 64KB in size).</source>
          <target state="translated">지정된 수의 웹 어셈블리 페이지 수만큼 메모리 인스턴스 크기를 증가시킵니다 (각 페이지는 64KB입니다).</target>
        </trans-unit>
        <trans-unit id="401d8f49917326f6d322f2dadc2fa0c24677d373" translate="yes" xml:space="preserve">
          <source>Increasing the &lt;a href=&quot;array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="65bc9ccd743dd3dce9047eb75c52a48c168f2c7a" translate="yes" xml:space="preserve">
          <source>Increment &amp;amp; decrement</source>
          <target state="translated">증가 및 감소</target>
        </trans-unit>
        <trans-unit id="f6baea39d0ecb0d64a9c1b43f7ae26c1991070ca" translate="yes" xml:space="preserve">
          <source>Increment (++)</source>
          <target state="translated">증분 (++)</target>
        </trans-unit>
        <trans-unit id="7137b97519cd5a3352b194f1a47ef7b8d00c0803" translate="yes" xml:space="preserve">
          <source>Increment (&lt;code&gt;++&lt;/code&gt;)</source>
          <target state="translated">증가 ( &lt;code&gt;++&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="6ffb5e37a0de256063704a907edfe0ba275b1cf7" translate="yes" xml:space="preserve">
          <source>Indeterminate form (e.g. &lt;code&gt;0 * Infinity&lt;/code&gt;, or &lt;code&gt;undefined + undefined&lt;/code&gt;)</source>
          <target state="translated">불확실한 형태 (예 : &lt;code&gt;0 * Infinity&lt;/code&gt; 또는 &lt;code&gt;undefined + undefined&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e37f91419162687bd95af5bf7c6d8af3c0b436e1" translate="yes" xml:space="preserve">
          <source>Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.</source>
          <target state="translated">배열 변경을 시작하는 인덱스 (원점 0). 배열의 길이보다 큰 경우 실제 시작 색인은 배열의 길이로 설정됩니다. 음수 인 경우, 배열의 끝에서부터 시작하여 많은 요소 (원점 -1 사용)를 시작하고 절대 값이 배열의 길이보다 큰 경우 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="45e917d5246c9f80b81acc22465ce7ef8dada20f" translate="yes" xml:space="preserve">
          <source>Indexed Collections</source>
          <target state="translated">인덱싱 된 컬렉션</target>
        </trans-unit>
        <trans-unit id="0a5a3ab920950c8b210b9bac77077845cb8eefef" translate="yes" xml:space="preserve">
          <source>Indexed collections</source>
          <target state="translated">인덱싱 된 컬렉션</target>
        </trans-unit>
        <trans-unit id="ad269f38c4b63f8bfa0ecb35d25d42a1aaead76a" translate="yes" xml:space="preserve">
          <source>Indexed properties not consulting prototype</source>
          <target state="translated">프로토 타입을 참조하지 않는 인덱싱 된 속성</target>
        </trans-unit>
        <trans-unit id="7600e0fb90c939a2d9f2134c598b9b3ebcc27ac1" translate="yes" xml:space="preserve">
          <source>Indicates an error during WebAssembly decoding or validation.</source>
          <target state="translated">WebAssembly 디코딩 또는 유효성 검사 중 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="018b8e5d38f9e27fad5f584feea16ea2dc658705" translate="yes" xml:space="preserve">
          <source>Indicates an error during module instantiation (besides &lt;a href=&quot;http://webassembly.org/docs/semantics/#traps&quot;&gt;traps&lt;/a&gt; from the start function).</source>
          <target state="translated">모듈 인스턴스화 중 오류를 나타냅니다 ( &lt;a href=&quot;http://webassembly.org/docs/semantics/#traps&quot;&gt;트랩&lt;/a&gt; 외에 시작 함수의 ).</target>
        </trans-unit>
        <trans-unit id="20c0a83d7993f36b5134ae07826c8ecfe2d53d68" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;g&lt;/code&gt; flag was used for a global match.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 플래그가 전역 일치에 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7dceb2034a666f7087defcc0f1f7e6314d0528af" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;i&lt;/code&gt; flag was used to ignore case.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 플래그가 대소 문자를 무시하는 데 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8b87a4dc659a01a5ec6a2bb79eda040056bd8bfe" translate="yes" xml:space="preserve">
          <source>Indicates if the &lt;code&gt;m&lt;/code&gt; flag was used to search across multiple lines.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 플래그가 여러 행을 검색하는 데 사용 되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="5c3c699849bd9690ce57a8e4f7dfc1232fdafc22" translate="yes" xml:space="preserve">
          <source>Individual flag values can be extracted by ANDing them with a bitmask, where each bit with the value of one will &quot;extract&quot; the corresponding flag. The bitmask &lt;em&gt;masks&lt;/em&gt; out the non-relevant flags by ANDing with zeroes (hence the term &quot;bitmask&quot;). For example, the bitmask 0100 can be used to see if flag C is set:</source>
          <target state="translated">비트 마스크로 AND를 AND하여 각 플래그 값을 추출 할 수 있습니다. 여기서 값이 1 인 각 비트는 해당 플래그를 &quot;추출&quot;합니다. 비트 &lt;em&gt;마스크&lt;/em&gt; 는 0으로 AND를 지정하여 관련이없는 플래그를 마스크합니다 (따라서 &quot;비트 마스크&quot;라는 용어). 예를 들어 비트 마스크 0100을 사용하여 플래그 C가 설정되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e2bf39c1e2a07161681d68dede8a4a0984febe" translate="yes" xml:space="preserve">
          <source>Individual operators</source>
          <target state="translated">개별 사업자</target>
        </trans-unit>
        <trans-unit id="8d4cadd23dc0f47618e0017475e1b69c0cbc8e21" translate="yes" xml:space="preserve">
          <source>Inequality</source>
          <target state="translated">Inequality</target>
        </trans-unit>
        <trans-unit id="e6cec31e8a65681ae7ec444c7f456b4cab73fee8" translate="yes" xml:space="preserve">
          <source>Inequality (!=)</source>
          <target state="translated">불평등 (! =)</target>
        </trans-unit>
        <trans-unit id="68eb52167d8b6624a0b93dc5831d7c86c5135093" translate="yes" xml:space="preserve">
          <source>Inequality (&lt;code&gt;a != b&lt;/code&gt;)</source>
          <target state="translated">불평등 ( &lt;code&gt;a != b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d488f35d25db0196ffb7b0d1ffbbaed095958c24" translate="yes" xml:space="preserve">
          <source>Inequality operator.</source>
          <target state="translated">불평등 연산자.</target>
        </trans-unit>
        <trans-unit id="a79dc3d005cf68005384e3b181f0842a749aefcd" translate="yes" xml:space="preserve">
          <source>Inferred function names</source>
          <target state="translated">유추 된 함수 이름</target>
        </trans-unit>
        <trans-unit id="ae29dd030af2c6013a342baa4496df5423ffebe1" translate="yes" xml:space="preserve">
          <source>Inferred names on anonymous functions</source>
          <target state="translated">익명 함수에 대한 유추 된 이름</target>
        </trans-unit>
        <trans-unit id="f6c883b54018ef7a4cdbcff87341648a7e230e30" translate="yes" xml:space="preserve">
          <source>Infinite iterator</source>
          <target state="translated">무한 반복자</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="59e354f06c04e0eb393e460ca726f509ae4ece3e" translate="yes" xml:space="preserve">
          <source>Inheritance of properties</source>
          <target state="translated">속성의 상속</target>
        </trans-unit>
        <trans-unit id="7951150c36a5b0078509be63ec158d0a10f3f90a" translate="yes" xml:space="preserve">
          <source>Inherited properties</source>
          <target state="translated">상속 된 속성</target>
        </trans-unit>
        <trans-unit id="df616f44e2c500bdaf1406df4828fd9ed5d52f72" translate="yes" xml:space="preserve">
          <source>Inherited property access: &lt;code&gt;Object.create(proxy)[foo]&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 액세스 : &lt;code&gt;Object.create(proxy)[foo]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2150882f012dfc772b92621683506749d96ecd3" translate="yes" xml:space="preserve">
          <source>Inherited property assignment: &lt;code&gt;Object.create(proxy)[foo] = bar&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 할당 : &lt;code&gt;Object.create(proxy)[foo] = bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a75868d63eb79c862251acc96e281c4c93b846e2" translate="yes" xml:space="preserve">
          <source>Inherited property query: &lt;code&gt;foo in Object.create(proxy)&lt;/code&gt;</source>
          <target state="translated">상속 된 속성 쿼리 : &lt;code&gt;foo in Object.create(proxy)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd7f16fa284794d2ca981389668e28d3cd48524" translate="yes" xml:space="preserve">
          <source>Initial WebAssembly draft definition.</source>
          <target state="translated">초기 웹 어셈블리 초안 정의.</target>
        </trans-unit>
        <trans-unit id="9e915d7086e42ba7ad8fb470ce6fd37be732353b" translate="yes" xml:space="preserve">
          <source>Initial definition</source>
          <target state="translated">초기 정의</target>
        </trans-unit>
        <trans-unit id="a37acae44fb32c850ce995533205c3c2eb69f53c" translate="yes" xml:space="preserve">
          <source>Initial definition in ECMA standard.</source>
          <target state="translated">ECMA 표준의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="35e9e36e8328392208cdb962c3a79bddae0d63a2" translate="yes" xml:space="preserve">
          <source>Initial definition in ECMAScript 2017.</source>
          <target state="translated">ECMAScript 2017의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="f7d55f8d05c9e8c07926850628936b042dbed3d6" translate="yes" xml:space="preserve">
          <source>Initial definition in ES2017.</source>
          <target state="translated">ES2017의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="6b379dfab4923f85c6fe72c56d94f6fd30cd942c" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard</source>
          <target state="translated">ECMA 표준의 초기 정의</target>
        </trans-unit>
        <trans-unit id="bee4945b5c9770ada5b145f4f6bd2f1332eb9f3f" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard.</source>
          <target state="translated">ECMA 표준의 초기 정의.</target>
        </trans-unit>
        <trans-unit id="e29784b04e2a292b41764fd796f01398698302ab" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard. Specified behaviour for indexed and named properties. Specified that &lt;code&gt;new&lt;/code&gt; is required.</source>
          <target state="translated">ECMA 표준의 초기 정의. 인덱스 및 명명 된 속성에 대해 지정된 동작 &lt;code&gt;new&lt;/code&gt; 것이 필요함을 명시했다 .</target>
        </trans-unit>
        <trans-unit id="82c35f70e5937c8e4260b39081fd9fc366d7bedb" translate="yes" xml:space="preserve">
          <source>Initial definition in an ECMA standard. Specified that &lt;code&gt;new&lt;/code&gt; is required.</source>
          <target state="translated">ECMA 표준의 초기 정의. &lt;code&gt;new&lt;/code&gt; 것이 필요함을 명시했다 .</target>
        </trans-unit>
        <trans-unit id="804103ada9286a91818a9c6f943e1357a3cee5f3" translate="yes" xml:space="preserve">
          <source>Initial definition was in ECMAScript 3.</source>
          <target state="translated">초기 정의는 ECMAScript 3에있었습니다.</target>
        </trans-unit>
        <trans-unit id="1996078361460df53a1d2f9e9930c7c26d7f873c" translate="yes" xml:space="preserve">
          <source>Initial definition.</source>
          <target state="translated">초기 정의.</target>
        </trans-unit>
        <trans-unit id="c74d3aa9086119cde5be85b65c88465515b8ab05" translate="yes" xml:space="preserve">
          <source>Initial definition. Defined in several section of the specification: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-template-literals&quot;&gt;Template Literals&lt;/a&gt;, &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-tagged-templates&quot;&gt;Tagged Templates&lt;/a&gt;</source>
          <target state="translated">초기 정의. 사양의 여러 섹션에 정의되어 있습니다 : &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-template-literals&quot;&gt;템플릿 리터럴&lt;/a&gt; , &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-tagged-templates&quot;&gt;태그가 지정된 템플릿&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d8b74490582a852fffa70f4fc964c8e54beb501" translate="yes" xml:space="preserve">
          <source>Initial definition. Defined in the (normative) Annex B for Additional ECMAScript Features for Web Browsers.</source>
          <target state="translated">초기 정의. 웹 브라우저에 대한 추가 ECMAScript 기능에 대해서는 (표준) 부록 B에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf63efa5c0322f19ea7d903fb16ba743a12e456d" translate="yes" xml:space="preserve">
          <source>Initial definition. Does not specify let expressions or let blocks.</source>
          <target state="translated">초기 정의. let 식 또는 let 블록을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40263062f582b9167e63d837c485ac319158cdd4" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현</target>
        </trans-unit>
        <trans-unit id="4ce05f6ce50ee64e9b4ab5c56bb413d0aef9cda2" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef9ece1071525c79ebc962c49979dc6140499d8b" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0. Defined in the (normative) Annex B for Additional ECMAScript Features for Web Browsers.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다. 웹 브라우저에 대한 추가 ECMAScript 기능에 대해서는 (표준) 부록 B에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3477ed16aca83fcc6cb881f80d7e09ec7c62282" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.0. Deprecated in favor of &lt;a href=&quot;../../functions/arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; in ES3.</source>
          <target state="translated">초기 정의. JavaScript 1.0에서 구현되었습니다. ES3 에서는 &lt;a href=&quot;../../functions/arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 에 찬성하여 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed464ab05f4b7a4db1b22334a85ff353174c997" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.1</source>
          <target state="translated">초기 정의. JavaScript 1.1에서 구현</target>
        </trans-unit>
        <trans-unit id="ac3e55bf74a2e48b37e9ce44c0f80517a3bec394" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.1.</source>
          <target state="translated">초기 정의. JavaScript 1.1에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb8e116565952c369a0e33d04e78e8cfdb7d6847" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현</target>
        </trans-unit>
        <trans-unit id="941a5c7ff7cd2d2d4aa695b24556fd6f3bfb1a20" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc7ad3d394c062cdaa8069fe5fd888ffa41f60f1" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;global&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;global&lt;/code&gt; 은 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="c66c9736512070345f9e9afd89f67fb870b37654" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;ignoreCase&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;ignoreCase&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="bbd4b92992b6ccec49a23065c54399ff4c99f8d4" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;lastIndex&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;lastIndex&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="fad0be06a8ade79e3f7b0862a68a4d8db5a2420c" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;multiline&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. 자바 스크립트 1.5 : &lt;code&gt;multiline&lt;/code&gt; (A)의 속성입니다 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cbac5462a80516b70d45fe45a2fbbd5e4d6ceb8d" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.2. JavaScript 1.5: &lt;code&gt;source&lt;/code&gt; is a property of a &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; instance, not the &lt;a href=&quot;../regexp&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">초기 정의. JavaScript 1.2에서 구현되었습니다. JavaScript 1.5 : &lt;code&gt;source&lt;/code&gt; 는 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 객체가 아닌 &lt;a href=&quot;../regexp&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 인스턴스 의 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="a85f7a92d71856d124832fd97d098db448fd811d" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3</source>
          <target state="translated">초기 정의. 자바 스크립트 1.3에서 구현</target>
        </trans-unit>
        <trans-unit id="b38e7ce9b5cf83a8b1f0b1490a6268e2b973a0a3" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3.</source>
          <target state="translated">초기 정의. JavaScript 1.3으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae0b462c8892ec0161d3febb8a3272c7c02d863f" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.3. Format is implementation dependent.</source>
          <target state="translated">초기 정의. JavaScript 1.3으로 구현되었습니다. 형식은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="059285ca9aa0072aad8a001d0290031512394a78" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.4</source>
          <target state="translated">초기 정의. 자바 스크립트 1.4에서 구현</target>
        </trans-unit>
        <trans-unit id="c1808274911cabdf7ca684c1f1735365f7772fde" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.4.</source>
          <target state="translated">초기 정의. JavaScript 1.4로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="a40791e2d6b8b660293bab3f511003e62d469c50" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.5.</source>
          <target state="translated">초기 정의. JavaScript 1.5에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="b912d0e0846319e918d16802811ba094f6f47499" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.6.</source>
          <target state="translated">초기 정의. JavaScript 1.6으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="26a478c8236e6faa48a87a57bc5275286f41b4d7" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.7.</source>
          <target state="translated">초기 정의. JavaScript 1.7에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="078ca5ed2fd128eff8b0b9a2d46b4238264e128c" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.</source>
          <target state="translated">초기 정의. JavaScript 1.8에서 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a4d24fd7dd67bd64acdeb068c2c167ada819f10" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.1.</source>
          <target state="translated">초기 정의. JavaScript로 구현 1.8.1.</target>
        </trans-unit>
        <trans-unit id="58d49a89bac6a7dedf8b042873e15e72e65f0ebb" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.5</source>
          <target state="translated">초기 정의. JavaScript 1.8.5에서 구현</target>
        </trans-unit>
        <trans-unit id="cad1ad3e2afcf629593f6eb50d4bac93cd34486b" translate="yes" xml:space="preserve">
          <source>Initial definition. Implemented in JavaScript 1.8.5.</source>
          <target state="translated">초기 정의. 자바 스크립트로 구현 1.8.5.</target>
        </trans-unit>
        <trans-unit id="2018c675b7f3b4f89b1656e50a4ae4c9277685f2" translate="yes" xml:space="preserve">
          <source>Initial definition. JavaScript 1.0 (UNIX Only) / JavaScript 1.1 (All platforms).</source>
          <target state="translated">초기 정의. JavaScript 1.0 (UNIX 만 해당) / JavaScript 1.1 (모든 플랫폼).</target>
        </trans-unit>
        <trans-unit id="7173bef762ccdf92ab23687cfc1d5be4a9ad804d" translate="yes" xml:space="preserve">
          <source>Initial definition. See also: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-C&quot;&gt;Strict mode restriction and exceptions&lt;/a&gt;</source>
          <target state="translated">초기 정의. &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-C&quot;&gt;엄격한 모드 제한 및 예외&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57325d451f55171c368ce61331d89e6d3d0aeaf6" translate="yes" xml:space="preserve">
          <source>Initial definition. Unlabeled version.</source>
          <target state="translated">초기 정의. 라벨이없는 버전.</target>
        </trans-unit>
        <trans-unit id="022515f406a57864f40cd1203eb4dcb41febf436" translate="yes" xml:space="preserve">
          <source>Initial defintion.</source>
          <target state="translated">초기 정의.</target>
        </trans-unit>
        <trans-unit id="69a9e0de842d8ae55591da42504603cd7e7262df" translate="yes" xml:space="preserve">
          <source>Initial draft definition.</source>
          <target state="translated">초기 초안 정의.</target>
        </trans-unit>
        <trans-unit id="b975dbb1192b113cadea247a55fa22b519dfca4d" translate="yes" xml:space="preserve">
          <source>Initial publication</source>
          <target state="translated">최초 발행</target>
        </trans-unit>
        <trans-unit id="c02800d28cb9343126029438b218e44c2370a6a7" translate="yes" xml:space="preserve">
          <source>Initial value of the variable. It can be any legal expression. Default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">변수의 초기 값. 모든 법적 표현이 될 수 있습니다. 기본값은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e1b224617736038fb54e6a25aa285ec6283eba9" translate="yes" xml:space="preserve">
          <source>Initial value of the variable. It can be any legal expression. Default value is &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">변수의 초기 값. 어떤 법적 표현이라도 가능합니다. 기본값은 &lt;em&gt;undefined&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c5eae6e8ad5c7eff82b70392594bd4874c1a340" translate="yes" xml:space="preserve">
          <source>Initialization of several variables</source>
          <target state="translated">여러 변수의 초기화</target>
        </trans-unit>
        <trans-unit id="9f8693a57ce3d9a432b19813a82043b25a29e309" translate="yes" xml:space="preserve">
          <source>Initially, the &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; function is called with an empty string as key representing the object being stringified. It is then called for each property on the object or array being stringified.</source>
          <target state="translated">처음에 &lt;code&gt;&lt;var&gt;replacer&lt;/var&gt;&lt;/code&gt; 함수는 문자열 화되는 객체를 나타내는 키로 빈 문자열로 호출됩니다. 그런 다음 문자열 화되는 객체 또는 배열의 각 속성에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d858124bcdda6ccdc66224e0325d22439387781d" translate="yes" xml:space="preserve">
          <source>Initially, the &lt;code&gt;replacer&lt;/code&gt; function is called with an empty string as key representing the object being stringified. It is then called for each property on the object or array being stringified.</source>
          <target state="translated">처음에, &lt;code&gt;replacer&lt;/code&gt; 기능은 문자열 화 될 객체를 나타내는 키로 빈 문자열로 호출됩니다. 그런 다음 문자열 화되는 객체 또는 배열의 각 속성에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="08711e711134e579523d56126b09874d8022e4b2" translate="yes" xml:space="preserve">
          <source>Inserts</source>
          <target state="translated">Inserts</target>
        </trans-unit>
        <trans-unit id="2b48e8876ecb78ba7e1968f36e0fd6a0717b2571" translate="yes" xml:space="preserve">
          <source>Inserts a &quot;$&quot;.</source>
          <target state="translated">&quot;$&quot;를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="40864899bf9e01467baa3d38448be2a7cdcbcb11" translate="yes" xml:space="preserve">
          <source>Inserts a &lt;code&gt;&quot;$&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;$&quot;&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="3ce7b5d4c8da12992edd7415b06c863f63baa582" translate="yes" xml:space="preserve">
          <source>Inserts the matched substring.</source>
          <target state="translated">일치하는 부분 문자열을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="e58f47bb0ef2776a10dd15f573a06a8e5d0afde5" translate="yes" xml:space="preserve">
          <source>Inserts the portion of the string that follows the matched substring.</source>
          <target state="translated">일치하는 부분 문자열 뒤에 오는 문자열 부분을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="4fed5693b7d1971ffd7cacdb16b81e94032e1511" translate="yes" xml:space="preserve">
          <source>Inserts the portion of the string that precedes the matched substring.</source>
          <target state="translated">일치하는 부분 문자열 앞에 오는 문자열 부분을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ca5c1c3094ae7abe52cdce1ab07a6ed84f2ed2aa" translate="yes" xml:space="preserve">
          <source>Inside a character set, the dot loses its special meaning and matches a literal dot.</source>
          <target state="translated">문자 집합 내에서 점은 특별한 의미를 잃고 리터럴 점과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="362024d61ebb70536bd9394b65dd78d5aad24d05" translate="yes" xml:space="preserve">
          <source>Inside a function, the value of &lt;code&gt;this&lt;/code&gt; depends on how the function is called.</source>
          <target state="translated">함수 내 &lt;code&gt;this&lt;/code&gt; 값은 함수 호출 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d0721f17dea6dcfcdf19c0b198b3112c883bdb01" translate="yes" xml:space="preserve">
          <source>Inside array comprehensions, these two kinds of components are allowed:</source>
          <target state="translated">배열 이해 내에서 다음 두 종류의 구성 요소가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="29e60640aa891200ac53331b0be76d088bf2cff8" translate="yes" xml:space="preserve">
          <source>Insignificant &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/whitespace&quot;&gt;whitespace&lt;/a&gt; may be present anywhere except within a &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (numbers must contain no whitespace) or &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (where it is interpreted as the corresponding character in the string, or would cause an error). The tab character (&lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U+0009&lt;/a&gt;), carriage return (&lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U+000D&lt;/a&gt;), line feed (&lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U+000A&lt;/a&gt;), and space (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U+0020&lt;/a&gt;) characters are the only valid whitespace characters.</source>
          <target state="translated">중요하지 않은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/whitespace&quot;&gt;공백&lt;/a&gt; 은 &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (숫자에 공백이 없어야 함) 또는 &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (문자열의 해당 문자로 해석되거나 오류가 발생하는 경우)을 제외하고 어디에나 존재할 수 있습니다 . 탭 문자 ( &lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U + 0009&lt;/a&gt; ), 캐리지 리턴 ( &lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U + 000D&lt;/a&gt; ), 줄 바꿈 ( &lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U + 000A&lt;/a&gt; ) 및 공백 (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt; U + 0020&lt;/a&gt; ) 문자는 유일하게 유효한 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2f3b9e6560de73eb8bc85eb42a04c1141865b37d" translate="yes" xml:space="preserve">
          <source>Insignificant whitespace may be present anywhere except within a &lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (numbers must contain no whitespace) or &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (where it is interpreted as the corresponding character in the string, or would cause an error). The tab character (&lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U+0009&lt;/a&gt;), carriage return (&lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U+000D&lt;/a&gt;), line feed (&lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U+000A&lt;/a&gt;), and space (&lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U+0020&lt;/a&gt;) characters are the only valid whitespace characters.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;JSONNumber&lt;/var&gt;&lt;/code&gt; (숫자에는 공백이 없어야 함) 또는 &lt;code&gt;&lt;var&gt;JSONString&lt;/var&gt;&lt;/code&gt; (문자열에서 해당 문자로 해석되거나 오류가 발생 함)을 제외하고는 중요 하지 않은 공백 이있을 수 있습니다. 탭 문자 ( &lt;a href=&quot;http://unicode-table.com/en/0009/&quot;&gt;U + 0009&lt;/a&gt; ), 캐리지 리턴 ( &lt;a href=&quot;http://unicode-table.com/en/000D/&quot;&gt;U + 000D&lt;/a&gt; ), 줄 바꿈 ( &lt;a href=&quot;http://unicode-table.com/en/000A/&quot;&gt;U + 000A&lt;/a&gt; ) 및 공백 ( &lt;a href=&quot;http://unicode-table.com/en/0020/&quot;&gt;U + 0020&lt;/a&gt; ) 문자 만 유효한 공백 문자입니다.</target>
        </trans-unit>
        <trans-unit id="6ab7d1d49dd26afc2c53ee28fa81799fd390b0a3" translate="yes" xml:space="preserve">
          <source>Instance methods</source>
          <target state="translated">인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="c1f424042c7e8bee2655a6672ddd3752109cc8d7" translate="yes" xml:space="preserve">
          <source>Instance properties</source>
          <target state="translated">인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="755387148de4cd392d1630cb598a8c5176cd9afc" translate="yes" xml:space="preserve">
          <source>Instance properties must be defined inside of class methods:</source>
          <target state="translated">인스턴스 속성은 클래스 메서드 내에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="f3a70c71d702bb70b2b487042ba6e7c30d331112" translate="yes" xml:space="preserve">
          <source>Instantiating streaming</source>
          <target state="translated">스트리밍 인스턴스화</target>
        </trans-unit>
        <trans-unit id="581ba3673a3337b2762fb544acd4152c49002ae6" translate="yes" xml:space="preserve">
          <source>Instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects &lt;code&gt;rand&lt;/code&gt; and &lt;code&gt;ken&lt;/code&gt; as the parameters for the owners. To find out the name of the owner of &lt;code&gt;car2&lt;/code&gt;, you can access the following property:</source>
          <target state="translated">새 오브젝트를 작성할 때 리터럴 문자열 또는 정수 값을 전달하는 대신 위의 명령문은 오브젝트 &lt;code&gt;rand&lt;/code&gt; 및 &lt;code&gt;ken&lt;/code&gt; 을 소유자의 매개 변수로 전달합니다 . &lt;code&gt;car2&lt;/code&gt; 소유자의 이름을 찾으려면 다음 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75193ab1f417d6c56a3655429671908b8e061a5" translate="yes" xml:space="preserve">
          <source>Instead of using regular expressions for parsing URLs, it is usually better to use the browsers built-in URL parser by using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL_API&quot;&gt;URL API&lt;/a&gt;.</source>
          <target state="translated">URL 구문 분석에 정규식을 사용하는 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/URL_API&quot;&gt;URL API&lt;/a&gt; 를 사용하여 브라우저에 내장 된 URL 구문 분석기를 사용하는 것이 일반적으로 더 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="31e05bde158595118d55e0ce91c002d27d730c1f" translate="yes" xml:space="preserve">
          <source>Instead write &quot;foo&quot;:</source>
          <target state="translated">대신 &quot;foo&quot;를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c2466dca884b77085cade35f77be32e5976572af" translate="yes" xml:space="preserve">
          <source>Instead write just 1 without a zero and use at least one digit after a decimal point:</source>
          <target state="translated">대신 0없이 1을 쓰고 소수점 뒤에 적어도 하나의 숫자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5b2d66e7682b0dcb605d4bd8661e57ecd97726ab" translate="yes" xml:space="preserve">
          <source>Instead you have to use &lt;a href=&quot;../global_objects/object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../global_objects/object/entries&quot;&gt;&lt;code&gt;Object.entries&lt;/code&gt;&lt;/a&gt;, to iterate over the properties or entries of an object.</source>
          <target state="translated">대신 객체의 속성 또는 항목을 반복 하려면 &lt;a href=&quot;../global_objects/object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/object/entries&quot;&gt; &lt;code&gt;Object.entries&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e0dc4bb2296425f8a0793107a400c064a277518e" translate="yes" xml:space="preserve">
          <source>Instead you need to use a correct &lt;a href=&quot;../operators/comparison_operators&quot;&gt;comparison operator&lt;/a&gt;. For example:</source>
          <target state="translated">대신 올바른 &lt;a href=&quot;../operators/comparison_operators&quot;&gt;비교 연산자&lt;/a&gt; 를 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7532357558d58b8bad52cc03601e93e8920a39f9" translate="yes" xml:space="preserve">
          <source>Instead you need to use a correct &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;comparison operator&lt;/a&gt;. For example:</source>
          <target state="translated">대신 올바른 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;비교 연산자&lt;/a&gt; 를 사용해야합니다. . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="26ecae46cb3e3f193194f48e69fb49562b84b075" translate="yes" xml:space="preserve">
          <source>Instead you need to use a plus sign for concatenation:</source>
          <target state="translated">대신 연결에 더하기 부호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="76292350e40ad23d7d412256c27e38fdaf0dd3a1" translate="yes" xml:space="preserve">
          <source>Instead you will need to use &lt;a href=&quot;../global_objects/string/indexof&quot;&gt;&lt;code&gt;String.prototype.indexOf()&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">대신 예를 들어 &lt;a href=&quot;../global_objects/string/indexof&quot;&gt; &lt;code&gt;String.prototype.indexOf()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e718841d850e49aba103de513cdaa93d90232f63" translate="yes" xml:space="preserve">
          <source>Instead, omit the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">대신 &lt;code&gt;var&lt;/code&gt; 키워드를 생략하십시오 .</target>
        </trans-unit>
        <trans-unit id="1757078b656e7c52f58307e98a78b7315354f37c" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;function&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;:</source>
          <target state="translated">대신 &lt;code&gt;def&lt;/code&gt; 대신 &lt;code&gt;function&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="599aca68c4dc962e7acfb73fd721311eb7302ad6" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;../operators/arithmetic_operators#Addition&quot;&gt;+ operator&lt;/a&gt;, a backslash, or &lt;a href=&quot;../template_literals&quot;&gt;template literals&lt;/a&gt;. The &lt;code&gt;+&lt;/code&gt; operator variant looks like this:</source>
          <target state="translated">대신 &lt;a href=&quot;../operators/arithmetic_operators#Addition&quot;&gt;+ 연산자&lt;/a&gt; , 백 슬래시 또는 &lt;a href=&quot;../template_literals&quot;&gt;템플릿 리터럴을 사용하십시오&lt;/a&gt; . &lt;code&gt;+&lt;/code&gt; 의 이 같은 운영자 변형 외모 :</target>
        </trans-unit>
        <trans-unit id="4feb09025f8ee92644b05f5d28aa4adb7bc126b7" translate="yes" xml:space="preserve">
          <source>Instead, use the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Addition&quot;&gt;+ operator&lt;/a&gt;, a backslash, or &lt;a href=&quot;../template_literals&quot;&gt;template literals&lt;/a&gt;. The &lt;code&gt;+&lt;/code&gt; operator variant looks like this:</source>
          <target state="translated">대신 &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Addition&quot;&gt;+ 연산자&lt;/a&gt; , 백 슬래시 또는 &lt;a href=&quot;../template_literals&quot;&gt;템플릿 리터럴을 사용&lt;/a&gt; 하세요. &lt;code&gt;+&lt;/code&gt; 이 같은 운영자 변형 외모 :</target>
        </trans-unit>
        <trans-unit id="9fbc895f8d9aa2582102b700c1698001202a6907" translate="yes" xml:space="preserve">
          <source>Instead, use the&lt;a href=&quot;../global_objects/promise/resolve&quot;&gt; Promise.resolve()&lt;/a&gt; or &lt;a href=&quot;../global_objects/promise/reject&quot;&gt;Promise.reject()&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods&quot;&gt;static methods&lt;/a&gt;:</source>
          <target state="translated">대신 &lt;a href=&quot;../global_objects/promise/resolve&quot;&gt;Promise.resolve ()&lt;/a&gt; 또는 &lt;a href=&quot;../global_objects/promise/reject&quot;&gt;Promise.reject () &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Method_(computer_programming)#Static_methods&quot;&gt;정적 메서드를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="0c9c8691e93fc3ce025dc71a355d7393d4850061" translate="yes" xml:space="preserve">
          <source>Int16Array.length</source>
          <target state="translated">Int16Array.length</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="f26c93914721585282e868e1c2ebee5732099508" translate="yes" xml:space="preserve">
          <source>Int32Array.length</source>
          <target state="translated">Int32Array.length</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="10b20c86b339c682e7d8ffa6aba23f3f2f096672" translate="yes" xml:space="preserve">
          <source>Int8Array.length</source>
          <target state="translated">Int8Array.length</target>
        </trans-unit>
        <trans-unit id="1105090c6c0a2edf92fa65478c36a65f5ad15cbc" translate="yes" xml:space="preserve">
          <source>Integer range for &lt;code&gt;Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; 정수 범위</target>
        </trans-unit>
        <trans-unit id="1d12bfc6efb01cb013ad7062520bad116239a06a" translate="yes" xml:space="preserve">
          <source>Integer range for Number</source>
          <target state="translated">숫자의 정수 범위</target>
        </trans-unit>
        <trans-unit id="c73bb4b5b8345a476d2718ae49ba14176bceb702" translate="yes" xml:space="preserve">
          <source>Integer specifying a limit on the number of splits to be found. The &lt;code&gt;[@@split]()&lt;/code&gt; method still splits on every match of &lt;code&gt;this&lt;/code&gt; RegExp pattern (or, in the Syntax above, &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt;), until the number of split items match the &lt;code&gt;&lt;var&gt;limit&lt;/var&gt;&lt;/code&gt; or the string falls short of &lt;code&gt;this&lt;/code&gt; pattern.</source>
          <target state="translated">찾을 분할 수에 대한 제한을 지정하는 정수입니다. &lt;code&gt;[@@split]()&lt;/code&gt; 메소드는 여전히 모든 매치에 분할 &lt;code&gt;this&lt;/code&gt; (위의 구문 또는 정규식 패턴 &lt;code&gt;&lt;var&gt;regexp&lt;/var&gt;&lt;/code&gt; 분할 아이템의 개수가 일치 할 때까지) &lt;code&gt;&lt;var&gt;limit&lt;/var&gt;&lt;/code&gt; 또는 문자열 단락의 하강 &lt;code&gt;this&lt;/code&gt; 패턴.</target>
        </trans-unit>
        <trans-unit id="7c58c51c392fd6e958ce0e7867611f13bdeb40ff" translate="yes" xml:space="preserve">
          <source>Integer specifying a limit on the number of splits to be found. When this parameter is provided, the &lt;code&gt;split()&lt;/code&gt; method splits the string at each occurrence of the specified &lt;code&gt;separator&lt;/code&gt; but stops when &lt;code&gt;limit&lt;/code&gt; entries have been placed into the array. It may still contain fewer entries than &lt;code&gt;limit&lt;/code&gt; if the end of the string is reached before the specified limit is reached. The left-over text is not returned in the new array.</source>
          <target state="translated">찾을 분할 수에 대한 제한을 지정하는 정수입니다. 이 매개 변수가 제공되면 &lt;code&gt;split()&lt;/code&gt; 메소드는 지정된 &lt;code&gt;separator&lt;/code&gt; 가 나타날 때 마다 문자열을 분할 하지만 &lt;code&gt;limit&lt;/code&gt; 항목이 배열에 배치 되면 중지됩니다 . 지정된 한계에 도달하기 전에 문자열의 끝에 &lt;code&gt;limit&lt;/code&gt; 하면 여전히 한계 보다 적은 수의 항목을 포함 할 수 있습니다 . 남은 텍스트는 새 배열에 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f9b7d1768a1e02150ecacea6dc02e42357f890" translate="yes" xml:space="preserve">
          <source>Integer value representing the day of the month.</source>
          <target state="translated">월의 일을 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="9bcbe074de1314a8090bd96f91252df74c70b0e7" translate="yes" xml:space="preserve">
          <source>Integer value representing the hour of the day.</source>
          <target state="translated">하루 중 시간을 나타내는 정수 값.</target>
        </trans-unit>
        <trans-unit id="34cf13846246cef5d1c62df7a0b15451169bda90" translate="yes" xml:space="preserve">
          <source>Integer value representing the millisecond segment of a time.</source>
          <target state="translated">시간의 밀리 초 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="241a7a4eb2efe8cc61b6dd45dbfef2428df56460" translate="yes" xml:space="preserve">
          <source>Integer value representing the minute segment of a time.</source>
          <target state="translated">시간의 분 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="be02731127495b3b13396f2468f942ddd732796e" translate="yes" xml:space="preserve">
          <source>Integer value representing the month, beginning with 0 for January to 11 for December.</source>
          <target state="translated">월을 나타내는 정수 값으로, 1 월은 0부터 12 월까지는 11로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dbce99ca6771dbb1b8cb6588d10e62f7b1e9d10d" translate="yes" xml:space="preserve">
          <source>Integer value representing the number of milliseconds since January 1, 1970, 00:00:00 UTC, with leap seconds ignored (Unix Epoch; but consider that most Unix timestamp functions count in seconds).</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC 이후 윤초를 무시하고 밀리 초 수를 나타내는 정수 값 (Unix Epoch; 대부분의 Unix 타임 스탬프 함수는 초 단위로 간주 됨).</target>
        </trans-unit>
        <trans-unit id="83e39e42a0a037d33ecb1c8a3c5eea08f0b99cf3" translate="yes" xml:space="preserve">
          <source>Integer value representing the second segment of a time.</source>
          <target state="translated">시간의 두 번째 세그먼트를 나타내는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="5db4d14c7dc17afe340582090d55b7545c1b3eb0" translate="yes" xml:space="preserve">
          <source>Integer value representing the year. Values from 0 to 99 map to the years 1900 to 1999. See the &lt;a href=&quot;#Two_digit_years_map_to_1900_-_1999&quot;&gt;example below&lt;/a&gt;.</source>
          <target state="translated">연도를 나타내는 정수 값. 0에서 99 사이의 값은 1900에서 1999 년으로 매핑 &lt;a href=&quot;#Two_digit_years_map_to_1900_-_1999&quot;&gt;됩니다&lt;/a&gt; . 아래 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f71c075259752a2939bdd6faa004b91f60e192a1" translate="yes" xml:space="preserve">
          <source>Integers with arbitrary precision: &lt;a href=&quot;bigint&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">임의 정밀도의 정수 : &lt;a href=&quot;bigint&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a04591ed8cd35a609e53970d909ddd65bdd9925c" translate="yes" xml:space="preserve">
          <source>Interceptions</source>
          <target state="translated">Interceptions</target>
        </trans-unit>
        <trans-unit id="d68324d2f9cb7da0deed981cf558925381f4aba7" translate="yes" xml:space="preserve">
          <source>InternalError: too much recursion</source>
          <target state="translated">InternalError : 너무 많은 재귀</target>
        </trans-unit>
        <trans-unit id="6e5a8eb19bb596773f3a9570412498f21d3b1c30" translate="yes" xml:space="preserve">
          <source>Internally calls &lt;code&gt;Promise.prototype.then&lt;/code&gt; on the object upon which is called, passing the parameters &lt;code&gt;undefined&lt;/code&gt; and the &lt;code&gt;onRejected&lt;/code&gt; handler received; then returns the value of that call (which is a &lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">내부적으로 호출 되는 객체에서 &lt;code&gt;Promise.prototype.then&lt;/code&gt; 을 호출 하여 매개 변수가 &lt;code&gt;undefined&lt;/code&gt; 않고 수신 된 &lt;code&gt;onRejected&lt;/code&gt; 핸들러를 전달합니다. 그런 다음 해당 호출의 값을 반환합니다 ( &lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a01e8a33df41e96537ebd6e4fa7dbce634312754" translate="yes" xml:space="preserve">
          <source>Internally calls &lt;code&gt;Promise.prototype.then&lt;/code&gt; on the object upon which it was called, passing the parameters &lt;code&gt;undefined&lt;/code&gt; and the received &lt;code&gt;&lt;var&gt;onRejected&lt;/var&gt;&lt;/code&gt; handler. Returns the value of that call, which is a &lt;a href=&quot;../promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;Promise.prototype.then&lt;/code&gt; 을 호출 된 객체에서 호출하여 &lt;code&gt;undefined&lt;/code&gt; 매개 변수 와 수신 된 &lt;code&gt;&lt;var&gt;onRejected&lt;/var&gt;&lt;/code&gt; 핸들러 를 전달 합니다. &lt;a href=&quot;../promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 인 해당 호출의 값을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="76d5733b82b9b85e7c7c9538c8b1cbf395dc743e" translate="yes" xml:space="preserve">
          <source>Internet Explorer</source>
          <target state="translated">인터넷 익스플로러</target>
        </trans-unit>
        <trans-unit id="28e5441a7bdfedada4425bf69cae741f24bb602b" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 implemented a &lt;code&gt;Object.defineProperty()&lt;/code&gt; method that could &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx&quot;&gt;only be used on DOM objects&lt;/a&gt;. A few things need to be noted:</source>
          <target state="translated">Internet Explorer 8 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx&quot;&gt;은 DOM 객체에서만 사용할&lt;/a&gt; 수 있는 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 메소드를 구현했습니다 . 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5790aa85105b2f707aa89140c69ddea48c4d6e3e" translate="yes" xml:space="preserve">
          <source>Internet Explorer 8 specific notes</source>
          <target state="translated">Internet Explorer 8 관련 참고 사항</target>
        </trans-unit>
        <trans-unit id="4138084098c5ad0c43aa900db4e2093e03cbf674" translate="yes" xml:space="preserve">
          <source>Interrupt a function</source>
          <target state="translated">기능 중단</target>
        </trans-unit>
        <trans-unit id="148008a6c97111d9a4baac98fac041378bd84ebd" translate="yes" xml:space="preserve">
          <source>Intl</source>
          <target state="translated">Intl</target>
        </trans-unit>
        <trans-unit id="9fec477cb4348073d98179a98fcd20fd16c1b51a" translate="yes" xml:space="preserve">
          <source>Intl Plural Rules Draft</source>
          <target state="translated">국제 복수 규칙 초안</target>
        </trans-unit>
        <trans-unit id="691a439705b6454b10075bcadfd1eba82e0809bf" translate="yes" xml:space="preserve">
          <source>Intl.Collator</source>
          <target state="translated">Intl.Collator</target>
        </trans-unit>
        <trans-unit id="94effe562809ae6b476c47a05969b7d808a1b064" translate="yes" xml:space="preserve">
          <source>Intl.Collator.prototype</source>
          <target state="translated">Intl.Collator.prototype</target>
        </trans-unit>
        <trans-unit id="0b377b74eeb9851f1e25bb146f28a1f051d72446" translate="yes" xml:space="preserve">
          <source>Intl.Collator.supportedLocalesOf</source>
          <target state="translated">Intl.Collator.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="91770c02e353a04997b7e8198eb99e13c00635b2" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat</source>
          <target state="translated">Intl.DateTimeFormat</target>
        </trans-unit>
        <trans-unit id="6f720195e10d50c2f6666c80ded510eb7e91ee56" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.prototype</source>
          <target state="translated">Intl.DateTimeFormat.prototype</target>
        </trans-unit>
        <trans-unit id="8c35054313946594df544a441084c18f481dc900" translate="yes" xml:space="preserve">
          <source>Intl.DateTimeFormat.supportedLocalesOf</source>
          <target state="translated">Intl.DateTimeFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="7267adddab78d6c517f39c7fbcf74e8abc940038" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat</source>
          <target state="translated">Intl.NumberFormat</target>
        </trans-unit>
        <trans-unit id="3d26a08d98ebcd5d28de6ddf3c2bd9cb829194a0" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat.prototype</source>
          <target state="translated">Intl.NumberFormat.prototype</target>
        </trans-unit>
        <trans-unit id="607ba4bc780b223d3fd5127334576ba2f8e0667c" translate="yes" xml:space="preserve">
          <source>Intl.NumberFormat.supportedLocalesOf</source>
          <target state="translated">Intl.NumberFormat.supportedLocalesOf</target>
        </trans-unit>
        <trans-unit id="66c7f57d39868752ebca01af0acb783a59f9ca74" translate="yes" xml:space="preserve">
          <source>Intl.collator.compare</source>
          <target state="translated">Intl.collator.compare</target>
        </trans-unit>
        <trans-unit id="9236ad9d72ffabd8ab8b1fdd93b3ae2fe0889b2d" translate="yes" xml:space="preserve">
          <source>Intl.collator.resolvedOptions</source>
          <target state="translated">Intl.collator.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="ac6e598b10bdd85f1d5e69697d5f02158893d3a3" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.format</source>
          <target state="translated">Intl.dateTimeFormat.format</target>
        </trans-unit>
        <trans-unit id="79234597f72df02f1a94d543bde865a99bd7d684" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.formatToParts</source>
          <target state="translated">Intl.dateTimeFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="904c6383f067aec078a7b1768309a99adb54dfca" translate="yes" xml:space="preserve">
          <source>Intl.dateTimeFormat.resolvedOptions</source>
          <target state="translated">Intl.dateTimeFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="091fff844313d48a74de1aab92c22d59e6263ad4" translate="yes" xml:space="preserve">
          <source>Intl.getCanonicalLocales</source>
          <target state="translated">Intl.getCanonicalLocales</target>
        </trans-unit>
        <trans-unit id="461a6cbec9e5f4d76bf0dcce35f41b5fae08133d" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.format</source>
          <target state="translated">Intl.numberFormat.format</target>
        </trans-unit>
        <trans-unit id="0244be6b0c3a6a82ba4428fb87fd56189351f3d2" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.formatToParts</source>
          <target state="translated">Intl.numberFormat.formatToParts</target>
        </trans-unit>
        <trans-unit id="e2d465b50d59450e9d5c5b8344aa05c1fd17b8ed" translate="yes" xml:space="preserve">
          <source>Intl.numberFormat.resolvedOptions</source>
          <target state="translated">Intl.numberFormat.resolvedOptions</target>
        </trans-unit>
        <trans-unit id="0f821397d0f52bfe785a3b5ae0994d5665808b0d" translate="yes" xml:space="preserve">
          <source>Introduced in Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30). Functions declared in the function body cannot be referred to inside the outer function]s default parameters. If attempted, a &lt;a href=&quot;../global_objects/referenceerror&quot;&gt;&lt;code&gt;ReferenceError&lt;/code&gt;&lt;/a&gt; is thrown. Default parameters are always executed first, so function declarations inside the function body evaluate afterwards.</source>
          <target state="translated">Gecko 33 (Firefox 33 / Thunderbird 33 / SeaMonkey 2.30)에 도입되었습니다. 함수 본문에 선언 된 함수는 외부 함수의 기본 매개 변수 내부에서 참조 할 수 없습니다. 시도하면 &lt;a href=&quot;../global_objects/referenceerror&quot;&gt; &lt;code&gt;ReferenceError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 기본 매개 변수는 항상 먼저 실행되므로 함수 본문 내부의 함수 선언은 나중에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3fbd2398c4e535f509ed566c2214525cbf5078" translate="yes" xml:space="preserve">
          <source>Introduction to Object-Oriented JavaScript</source>
          <target state="translated">객체 지향 JavaScript 소개</target>
        </trans-unit>
        <trans-unit id="8e006f5d6c51e5f500e63738a7a4e5ab708ef28b" translate="yes" xml:space="preserve">
          <source>Introduction to source maps &amp;ndash; HTML5 rocks</source>
          <target state="translated">소스 맵 소개 &amp;ndash; HTML5 rock</target>
        </trans-unit>
        <trans-unit id="685d8b8a451d5c25429cf00e02a70396ec23ea94" translate="yes" xml:space="preserve">
          <source>Introduction: &lt;a href=&quot;http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;The ECMAScript Internationalization API&lt;/a&gt;</source>
          <target state="translated">소개 : &lt;a href=&quot;http://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;ECMAScript 국제화 API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43c9754a8861b7fd0f8dd51ab243bdb722045151" translate="yes" xml:space="preserve">
          <source>Introduction: &lt;a href=&quot;https://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;The ECMAScript Internationalization API&lt;/a&gt;</source>
          <target state="translated">소개 : &lt;a href=&quot;https://norbertlindenberg.com/2012/12/ecmascript-internationalization-api/index.html&quot;&gt;ECMAScript 국제화 API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d94a1b20a86da8d8ef52d86140d5faa7244a1b37" translate="yes" xml:space="preserve">
          <source>Invalid &lt;code&gt;for-of&lt;/code&gt; loop</source>
          <target state="translated">잘못된 &lt;code&gt;for-of&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="660272f83ac71948bccc6b24478abcb5e8309a01" translate="yes" xml:space="preserve">
          <source>Invalid JavaScript identifier as a property name</source>
          <target state="translated">속성 이름으로 잘못된 JavaScript 식별자</target>
        </trans-unit>
        <trans-unit id="6cb64cdbd8ca48ac355e5ba934792e50b7b643a3" translate="yes" xml:space="preserve">
          <source>Invalid array length</source>
          <target state="translated">유효하지 않은 배열 길이</target>
        </trans-unit>
        <trans-unit id="2bb5db0093030ed959d9e116d255a162895d06b8" translate="yes" xml:space="preserve">
          <source>Invalid assignment left-hand side</source>
          <target state="translated">왼쪽의 잘못된 할당</target>
        </trans-unit>
        <trans-unit id="b7aa12cebc342348149a588c562fbe64f3283163" translate="yes" xml:space="preserve">
          <source>Invalid cases</source>
          <target state="translated">잘못된 경우</target>
        </trans-unit>
        <trans-unit id="9e0f593040b832479d554e779693995956176e29" translate="yes" xml:space="preserve">
          <source>Invalid const assignment</source>
          <target state="translated">잘못된 const 할당</target>
        </trans-unit>
        <trans-unit id="3f45d8ccffe75e10e46696189989b5121bdc235b" translate="yes" xml:space="preserve">
          <source>Invalid date</source>
          <target state="translated">잘못된 날짜</target>
        </trans-unit>
        <trans-unit id="1ee4d92944915ed61af938fd4b4fb38eb5ca730a" translate="yes" xml:space="preserve">
          <source>Invalid for-in initializer</source>
          <target state="translated">잘못된 초기화 프로그램</target>
        </trans-unit>
        <trans-unit id="a1afb0a15ce516af40f158e64da36cf6e02266c4" translate="yes" xml:space="preserve">
          <source>Invalid for-of initializer</source>
          <target state="translated">잘못된 초기화 프로그램</target>
        </trans-unit>
        <trans-unit id="a0a196b58c85a10ea9cf485d0b56fe28ac2f61a4" translate="yes" xml:space="preserve">
          <source>Invalid input:</source>
          <target state="translated">잘못된 입력:</target>
        </trans-unit>
        <trans-unit id="3a4b82ac678593606aa369204a68abe42e54f0ff" translate="yes" xml:space="preserve">
          <source>Invalid octal numbers</source>
          <target state="translated">잘못된 8 진수</target>
        </trans-unit>
        <trans-unit id="d6e64d0ec42180ad42843b3147e19fa8b02da721" translate="yes" xml:space="preserve">
          <source>Invalid redeclaration</source>
          <target state="translated">잘못된 재 선언</target>
        </trans-unit>
        <trans-unit id="3390616cafac7ff314d6aadaf20e48034cbb3314" translate="yes" xml:space="preserve">
          <source>Invariants</source>
          <target state="translated">Invariants</target>
        </trans-unit>
        <trans-unit id="4e1321c7e45e4c40761381b9b683387d488bf32f" translate="yes" xml:space="preserve">
          <source>Inverts the bits of its operand.</source>
          <target state="translated">피연산자의 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fd458722c8cfcbb53c39ea1f3c5645c09338076" translate="yes" xml:space="preserve">
          <source>Invoked through call or apply</source>
          <target state="translated">전화 또는 신청을 통해 호출</target>
        </trans-unit>
        <trans-unit id="32a22853078d6023f226d27e51d0b2a6e5b9ae81" translate="yes" xml:space="preserve">
          <source>Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.</source>
          <target state="translated">사용 가능한 디버깅 기능을 호출합니다. 디버깅 기능을 사용할 수 없으면이 명령문은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="546fbb50ff089e3855d79b13d86e4a369e5a842d" translate="yes" xml:space="preserve">
          <source>Invoking JavaScript &lt;code&gt;Date&lt;/code&gt; as a function (i.e., without the &lt;a href=&quot;../operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; operator) will return a string representing the current date and time.</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; 를 함수로 호출하면 (즉, &lt;a href=&quot;../operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 연산자 없이 ) 현재 날짜와 시간을 나타내는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bc5e46ab780fcbc7794152fa6c4870b7d727aa2" translate="yes" xml:space="preserve">
          <source>Invoking strict mode</source>
          <target state="translated">엄격 모드 호출</target>
        </trans-unit>
        <trans-unit id="208ae9750e5d18010716a63f7a64c8864b8720b3" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;AsyncFunction&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;AsyncFunction&lt;/code&gt; 의 하십시오 (사용하지 않고 함수 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="1f49636aa3cddb53862e739e488ae9fb9c6c0139" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;Function&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;Function&lt;/code&gt; (없이 함수로서 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="a09fdf87d82db4d13b9fdd5d76e4b7e7f19d7fac" translate="yes" xml:space="preserve">
          <source>Invoking the &lt;code&gt;GeneratorFunction&lt;/code&gt; constructor as a function (without using the &lt;code&gt;new&lt;/code&gt; operator) has the same effect as invoking it as a constructor.</source>
          <target state="translated">호출 &lt;code&gt;GeneratorFunction&lt;/code&gt; 의 하십시오 (사용하지 않고 함수 생성자 &lt;code&gt;new&lt;/code&gt; 조작하면) 생성자로서 호출하는 것과 같은 효과를 갖는다.</target>
        </trans-unit>
        <trans-unit id="b4cd7f60b4d184101c2a6bf4b757b7b2b30bac77" translate="yes" xml:space="preserve">
          <source>Is a generator object an iterator or an iterable?</source>
          <target state="translated">생성기 객체는 반복자입니까, 반복 가능한가요?</target>
        </trans-unit>
        <trans-unit id="0b0d56ef77469a2f756007c6a62fa7926b600b31" translate="yes" xml:space="preserve">
          <source>Is a stateful, executable instance of a &lt;a href=&quot;webassembly/module&quot;&gt;WebAssembly.Module&lt;/a&gt;</source>
          <target state="translated">Is a stateful, executable instance of a &lt;a href=&quot;webassembly/module&quot;&gt;WebAssembly.Module&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="690a13704ccda7c99a1f2a9585cf62a8ecc1ef9e" translate="yes" xml:space="preserve">
          <source>Is the same function as the &lt;code&gt;values()&lt;/code&gt; function and returns a new &lt;code&gt;Iterator&lt;/code&gt; object that contains the values for each element in the &lt;code&gt;Set&lt;/code&gt; object in insertion order.</source>
          <target state="translated">&lt;code&gt;values()&lt;/code&gt; 함수와 동일한 함수 이며 &lt;code&gt;Set&lt;/code&gt; 객체의 각 요소에 대한 값을 삽입 순서대로 포함 하는 새 &lt;code&gt;Iterator&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="237c366b14d4ac2c7ac8dcc981e25cf07610f224" translate="yes" xml:space="preserve">
          <source>Issue with &lt;code&gt;JSON.stringify()&lt;/code&gt; when serializing circular references</source>
          <target state="translated">순환 참조를 직렬화 할 때 &lt;code&gt;JSON.stringify()&lt;/code&gt; 문제</target>
        </trans-unit>
        <trans-unit id="0fe883a4a2cebd3337cac0b6f63f321bc9cfbcf4" translate="yes" xml:space="preserve">
          <source>Issue with JSON.stringify() when serializing circular references</source>
          <target state="translated">Issue with JSON.stringify() when serializing circular references</target>
        </trans-unit>
        <trans-unit id="5600fcf5422fc9dfe3b3d78fa586442113fe282e" translate="yes" xml:space="preserve">
          <source>Issue with plain &lt;code&gt;JSON.stringify&lt;/code&gt; for use as JavaScript</source>
          <target state="translated">JavaScript로 사용하기 위해 일반 &lt;code&gt;JSON.stringify&lt;/code&gt; 관련 문제</target>
        </trans-unit>
        <trans-unit id="cfecb0665bc38a3d23f86eec2febbf45d4496177" translate="yes" xml:space="preserve">
          <source>Issue with plain JSON.stringify for use as JavaScript</source>
          <target state="translated">Issue with plain JSON.stringify for use as JavaScript</target>
        </trans-unit>
        <trans-unit id="b5f064f8234fa60048c058abe8b49b99a3a6d87a" translate="yes" xml:space="preserve">
          <source>It accepts three arguments:</source>
          <target state="translated">It accepts three arguments:</target>
        </trans-unit>
        <trans-unit id="41203c0da0da22d05561ac067143a1455ee0fac2" translate="yes" xml:space="preserve">
          <source>It allows the code in the string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; to be minified.</source>
          <target state="translated">It allows the code in the string passed to &lt;code&gt;runCodeWithDateFunction()&lt;/code&gt; to be minified.</target>
        </trans-unit>
        <trans-unit id="00081e6a2ee8da25b0c2fa487f2293a0e3a9300f" translate="yes" xml:space="preserve">
          <source>It also avoids a problem if the magnitude of your numbers is huge. The largest number you can represent in JS's double floats is &lt;code&gt;Number.MAX_VALUE =&amp;nbsp;1.797...e+308&lt;/code&gt; . If your numbers are larger than about 1e154, taking the square of them will result in Infinity, demolishing your results. For example, &lt;code&gt;Math.sqrt(1e200*1e200 + 1e200*1e200) =&amp;nbsp;Infinity&lt;/code&gt; . If you use &lt;code&gt;hypot()&lt;/code&gt; instead, you get a good answer &lt;code&gt;Math.hypot(1e200, 1e200) =&amp;nbsp;1.4142...e+200&lt;/code&gt; . This is also true with very small numbers. &lt;code&gt;Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) =&amp;nbsp;0&lt;/code&gt;, but &lt;code&gt;Math.hypot(1e-200, 1e-200) =&lt;/code&gt;&lt;code&gt;1.4142...e-200&lt;/code&gt;, a good answer.</source>
          <target state="translated">또한 숫자의 크기가 크면 문제를 피할 수 있습니다. JS의 double float에서 나타낼 수있는 가장 큰 숫자는 &lt;code&gt;Number.MAX_VALUE =&amp;nbsp;1.797...e+308&lt;/code&gt; 입니다. 숫자가 약 1e154보다 큰 경우, 제곱을 취하면 무한대가되고 결과가 철거됩니다. 예를 들어 &lt;code&gt;Math.sqrt(1e200*1e200 + 1e200*1e200) =&amp;nbsp;Infinity&lt;/code&gt; 입니다. &lt;code&gt;hypot()&lt;/code&gt; 대신 사용 하면 &lt;code&gt;Math.hypot(1e200, 1e200) =&amp;nbsp;1.4142...e+200&lt;/code&gt; 좋은 대답을 얻습니다 . 이것은 매우 작은 숫자에서도 마찬가지입니다. &lt;code&gt;Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) =&amp;nbsp;0&lt;/code&gt; 이지만 &lt;code&gt;Math.hypot(1e-200, 1e-200) =&lt;/code&gt; &lt;code&gt;1.4142...e-200&lt;/code&gt; , 좋은 대답입니다.</target>
        </trans-unit>
        <trans-unit id="e475453a8d4616b44db70ed2898a74507d1d08d9" translate="yes" xml:space="preserve">
          <source>It also means that variables declared inside the function body using &lt;code&gt;var&lt;/code&gt; will mask parameters of the same name, instead of the usual behavior of duplicate &lt;code&gt;var&lt;/code&gt; declarations having no effect.</source>
          <target state="translated">It also means that variables declared inside the function body using &lt;code&gt;var&lt;/code&gt; will mask parameters of the same name, instead of the usual behavior of duplicate &lt;code&gt;var&lt;/code&gt; declarations having no effect.</target>
        </trans-unit>
        <trans-unit id="046a89c09b8e69d7519433ee5f4799dde2a0f2f5" translate="yes" xml:space="preserve">
          <source>It also works when you put &lt;code&gt;default&lt;/code&gt; before all other &lt;code&gt;case&lt;/code&gt;s.</source>
          <target state="translated">It also works when you put &lt;code&gt;default&lt;/code&gt; before all other &lt;code&gt;case&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="5c1ebb7ab8937cf2664e8c849a22e22823d62684" translate="yes" xml:space="preserve">
          <source>It also works when you put default before all other cases.</source>
          <target state="translated">다른 모든 경우보다 기본값을 설정하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="898d6cff7f0d4ac02e7c8c72fea0f382f5f1a39e" translate="yes" xml:space="preserve">
          <source>It attempted to call a value from a function, but the value is not actually a function. Some code expects you to provide a function, but that didn't happen.</source>
          <target state="translated">함수에서 값을 호출하려고 시도했지만 실제로는 함수가 아닙니다. 일부 코드에서는 함수를 제공 할 것으로 예상하지만 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2adb77288fe8601577f558b0c9e3989d99e0757" translate="yes" xml:space="preserve">
          <source>It can be a Function or other non-primitive value.</source>
          <target state="translated">함수 또는 다른 기본이 아닌 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48068ce741966c4d12a0279fea298e01c807447" translate="yes" xml:space="preserve">
          <source>It can be more obscure when using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt; 또는 다른 괄호와 중괄호를 사용하는 다른 구문을 사용할 때는 더 모호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaf4352228b453b336e8eafbf659e9e48282c4b5" translate="yes" xml:space="preserve">
          <source>It can be more obscure when using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</source>
          <target state="translated">It can be more obscure when using &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE&lt;/a&gt;, &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&quot;&gt;Closures&lt;/a&gt;, or other constructs that use a lot of different parenthesis and curly brackets, for example.</target>
        </trans-unit>
        <trans-unit id="637735e5f525f257cdcfa7d7c573a1134e3b31c0" translate="yes" xml:space="preserve">
          <source>It can have an identifier which is either a number or a string;</source>
          <target state="translated">숫자 또는 문자열 인 식별자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee2b94ebdffc711d03534a6c9c32859543eb863" translate="yes" xml:space="preserve">
          <source>It doesn't work if the string contains grapheme clusters, even when using a unicode aware split (use for example &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead).</source>
          <target state="translated">유니 코드 인식 분할을 사용하는 경우에도 문자열에 grapheme 클러스터가 포함되어 있으면 작동하지 않습니다 (예 &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;:&lt;/a&gt; 대신 esrever 사용).</target>
        </trans-unit>
        <trans-unit id="f947e606472d4347ad32397429bfe2112731e5ac" translate="yes" xml:space="preserve">
          <source>It doesn't work if the string contains grapheme clusters, even when using a unicode-aware split. (Use, for example, &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead.)</source>
          <target state="translated">It doesn't work if the string contains grapheme clusters, even when using a unicode-aware split. (Use, for example, &lt;a href=&quot;https://github.com/mathiasbynens/esrever&quot;&gt;esrever&lt;/a&gt; instead.)</target>
        </trans-unit>
        <trans-unit id="a4fafc92e6281926700d4d162cec8f063e6ae134" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;not&lt;/em&gt; called for missing elements of the array; that is:</source>
          <target state="translated">It is &lt;em&gt;not&lt;/em&gt; called for missing elements of the array; that is:</target>
        </trans-unit>
        <trans-unit id="adef4106e76e6addc70a8d2ae997c1248d91d94f" translate="yes" xml:space="preserve">
          <source>It is a good idea to comment &lt;em&gt;intentional&lt;/em&gt; use of the empty statement, as it is not really obvious to distinguish from a normal semicolon.</source>
          <target state="translated">It is a good idea to comment &lt;em&gt;intentional&lt;/em&gt; use of the empty statement, as it is not really obvious to distinguish from a normal semicolon.</target>
        </trans-unit>
        <trans-unit id="10eb0a5f9478db379a0c234799a056177e982243" translate="yes" xml:space="preserve">
          <source>It is advisable to not use simple assignments in a conditional expression (such as &lt;code&gt;&lt;a href=&quot;../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt;), because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</source>
          <target state="translated">조건식 (예 : &lt;code&gt;&lt;a href=&quot;../statements/if...else&quot;&gt;if...else&lt;/a&gt;&lt;/code&gt; 등)에 간단한 대입을 사용하지 않는 것이 좋습니다 . 코드를 살펴볼 때 대입이 동일하게 혼동 될 수 있기 때문입니다. 예를 들어 다음 코드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b1f5b1660aed98af62b5049d964d12af0b3a267c" translate="yes" xml:space="preserve">
          <source>It is advisable to not use simple assignments in a conditional expression, because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</source>
          <target state="translated">코드를 살펴볼 때 할당이 동일하게 혼동 될 수 있으므로 조건식에 간단한 할당을 사용하지 않는 것이 좋습니다. 예를 들어 다음 코드를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="24d3facbde01a9ba1b0055ecd1c1d62977eb59f1" translate="yes" xml:space="preserve">
          <source>It is almost always safer to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt;, because there can be up to &lt;em&gt;four&lt;/em&gt; possible output types without &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">It is almost always safer to provide an &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; , because there can be up to &lt;em&gt;four&lt;/em&gt; possible output types without &lt;code&gt;&lt;var&gt;initialValue&lt;/var&gt;&lt;/code&gt; , as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="8e0b595c50396c3cdbc92c5f6b750e905ed42003" translate="yes" xml:space="preserve">
          <source>It is also possible to &quot;import/export&quot; from different modules in a parent module so that they are available to import from that module. In other words, one can create a single module concentrating various exports from various modules.</source>
          <target state="translated">It is also possible to &quot;import/export&quot; from different modules in a parent module so that they are available to import from that module. In other words, one can create a single module concentrating various exports from various modules.</target>
        </trans-unit>
        <trans-unit id="bb4cc67af098b1db09d7c4c8d6064bf4903ec064" translate="yes" xml:space="preserve">
          <source>It is also possible to provide a name inside the definition in order to create a &lt;strong&gt;named&lt;/strong&gt; function expression:</source>
          <target state="translated">&lt;strong&gt;명명 된&lt;/strong&gt; 함수 표현식 을 작성하기 위해 정의 내에 이름을 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d15511bc331dcf794b253aed11d5d6bc426cf771" translate="yes" xml:space="preserve">
          <source>It is also possible to use the default syntax with the ones seen above (namespace imports or named imports). In such cases, the default import will have to be declared first. For instance:</source>
          <target state="translated">위에서 본 구문 (네임 스페이스 가져 오기 또는 명명 된 가져 오기)과 함께 기본 구문을 사용할 수도 있습니다. 이 경우 기본 가져 오기를 먼저 선언해야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="af4edb990c5fdf727cafe82fdb0540d797482226" translate="yes" xml:space="preserve">
          <source>It is an array of bytes, often referred to in other languages as a &quot;byte array&quot;.You cannot directly manipulate the contents of an &lt;code&gt;ArrayBuffer&lt;/code&gt;; instead, you create one of the &lt;a href=&quot;typedarray&quot;&gt;typed array objects&lt;/a&gt; or a &lt;a href=&quot;dataview&quot;&gt;&lt;code&gt;DataView&lt;/code&gt;&lt;/a&gt; object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.</source>
          <target state="translated">It is an array of bytes, often referred to in other languages as a &quot;byte array&quot;.You cannot directly manipulate the contents of an &lt;code&gt;ArrayBuffer&lt;/code&gt; ; instead, you create one of the &lt;a href=&quot;typedarray&quot;&gt;typed array objects&lt;/a&gt; or a &lt;a href=&quot;dataview&quot;&gt; &lt;code&gt;DataView&lt;/code&gt; &lt;/a&gt; object which represents the buffer in a specific format, and use that to read and write the contents of the buffer.</target>
        </trans-unit>
        <trans-unit id="e582cadd5e2af8a250319887c5b15dd0b445e4ca" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply()&lt;/code&gt;&lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</source>
          <target state="translated">It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply()&lt;/code&gt; &lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</target>
        </trans-unit>
        <trans-unit id="ccb9df029f10f1c4b5a120be3422d4cce76c0172" translate="yes" xml:space="preserve">
          <source>It is common to use &lt;a href=&quot;../global_objects/function/apply&quot;&gt;&lt;code&gt;Function.prototype.apply&lt;/code&gt;&lt;/a&gt; in cases where you want to use the elements of an array as arguments to a function.</source>
          <target state="translated">배열의 요소를 함수의 인수로 사용하려는 경우 &lt;a href=&quot;../global_objects/function/apply&quot;&gt; &lt;code&gt;Function.prototype.apply&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="e47762cbcbb8539a041b86f5911c627bfe43782a" translate="yes" xml:space="preserve">
          <source>It is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors.</source>
          <target state="translated">하나의 인수 (트래버스되는 요소)와 함께 콜백을 사용하는 것이 일반적입니다. 특정 함수는 추가 선택적 인수를 사용하더라도 일반적으로 하나의 인수와 함께 사용됩니다. 이러한 습관은 혼란스러운 행동으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85416cea4b3eddb14fb95e0c0cb8577b27c9847a" translate="yes" xml:space="preserve">
          <source>It is important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using &lt;code&gt;Object.defineProperty()&lt;/code&gt;, as shown in the example below.</source>
          <target state="translated">속성의 기본값이 적용되는 방식을 고려해야합니다. 아래 예제와 같이 단순히 점 표기법을 사용하여 값을 할당하는 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 를 사용하는 것 사이에는 종종 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1db1351f7a897a851f490253a603fa473ce35df" translate="yes" xml:space="preserve">
          <source>It is important to note the following:</source>
          <target state="translated">It is important to note the following:</target>
        </trans-unit>
        <trans-unit id="d8dda9f554abc422ea39aabc120a7ac0d13f88f6" translate="yes" xml:space="preserve">
          <source>It is not possible to know reflectively whether a particular object implements the iterator protocol, however it is easy to create an object that satisfies both the iterator and iterable protocols (as shown in the example below). Doing so allows an iterator to be consumed by the various syntaxes expecting iterables. Thus it is rarely desireable to implement the iterator protocol without also implementing iterable.</source>
          <target state="translated">특정 객체가 반복자 프로토콜을 구현하는지 여부를 반사적으로 알 수는 없지만 반복자와 반복 가능한 프로토콜을 모두 만족하는 객체를 쉽게 만들 수 있습니다 (아래 예 참조). 그렇게하면 반복자를 기대하는 다양한 구문에 의해 반복자를 사용할 수 있습니다. 따라서 iterable을 구현하지 않고 iterator 프로토콜을 구현하는 것은 거의 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbba11b1cf2f60a0f1e56080fd83cc82be1fb642" translate="yes" xml:space="preserve">
          <source>It is not possible to simultaneously have a getter bound to a property and have that property actually hold a value, although it &lt;em&gt;is&lt;/em&gt; possible to use a getter and a setter in conjunction to create a type of pseudo-property.</source>
          <target state="translated">It is not possible to simultaneously have a getter bound to a property and have that property actually hold a value, although it &lt;em&gt;is&lt;/em&gt; possible to use a getter and a setter in conjunction to create a type of pseudo-property.</target>
        </trans-unit>
        <trans-unit id="34110370fd48f5a59887b0bd5220e344fd6f9b8c" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;Date.parse&lt;/code&gt; as until ES5, parsing of strings was entirely implementation dependent. There are still many differences in how different hosts parse date strings, therefore date strings should be manually parsed (a library can help if many different formats are to be accommodated).</source>
          <target state="translated">ES5까지 문자열 구문 분석이 구현에 전적으로 의존 하기 때문에 &lt;code&gt;Date.parse&lt;/code&gt; 를 사용하지 않는 것이 좋습니다 . 다른 호스트가 날짜 문자열을 구문 분석하는 방법에는 여전히 많은 차이가 있으므로 날짜 문자열을 수동으로 구문 분석해야합니다 (다양한 형식을 수용해야하는 경우 라이브러리가 도움이 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="73dcdfa951545bec950ab075835e1130523dd188" translate="yes" xml:space="preserve">
          <source>It is possible to change this behaviour by handling possible rejections:</source>
          <target state="translated">가능한 거부를 처리하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc88e3e25b3ab537eecc21b53f748a8be78bdb7" translate="yes" xml:space="preserve">
          <source>It is possible to have a default &lt;a href=&quot;export&quot;&gt;&lt;code&gt;export&lt;/code&gt;&lt;/a&gt; (whether it is an object, a function, a class, etc.). The &lt;code&gt;import&lt;/code&gt; statement may then be used to import such defaults.</source>
          <target state="translated">기본 &lt;a href=&quot;export&quot;&gt; &lt;code&gt;export&lt;/code&gt; &lt;/a&gt; (객체, 함수, 클래스 등) 를 가질 수 있습니다 . &lt;code&gt;import&lt;/code&gt; 문은 다음과 같은 기본 설정을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bd6a46ab029adb771c2868831032b213e42613" translate="yes" xml:space="preserve">
          <source>It is possible to redefine the &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property of arrays, subject to the usual redefinition restrictions. (The &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property is initially non-configurable, non-enumerable, and writable. Thus on an unaltered array, it's possible to change the &lt;a href=&quot;../array/length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt; property's value or to make it non-writable. It is not allowed to change its enumerability or configurability, or if it is non-writable to change its value or writability.) However, not all browsers permit this redefinition.</source>
          <target state="translated">일반적인 재정의 제한에 따라 배열 의 &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성 을 재정의 할 수 있습니다 . ( &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성은 초기에 구성 불가능, 열거 불가능 및 쓰기 가능하므로 변경되지 않은 배열에서는 &lt;a href=&quot;../array/length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 속성 값 을 변경 하거나 쓰기 불가능하게 만들 수 있습니다. 열거 성 또는 구성 가능성을 변경할 수 없습니다. 또는 값이나 쓰기 가능성을 변경하기 위해 쓰기가 불가능한 경우.) 그러나 모든 브라우저가이 재정의를 허용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="aba7c66856ef3424f32c864a39cb61a9c7d5f9b7" translate="yes" xml:space="preserve">
          <source>It is rather rare to use &lt;code&gt;NaN&lt;/code&gt; in a program. It is the returned value when &lt;a href=&quot;math&quot;&gt;&lt;code&gt;Math&lt;/code&gt;&lt;/a&gt; functions fail (&lt;code&gt;Math.sqrt(-1)&lt;/code&gt;) or when a function trying to parse a number fails (&lt;code&gt;parseInt(&quot;blabla&quot;)&lt;/code&gt;).</source>
          <target state="translated">프로그램에서 &lt;code&gt;NaN&lt;/code&gt; 을 사용하는 것은 다소 드 rare니다 . &lt;a href=&quot;math&quot;&gt; &lt;code&gt;Math&lt;/code&gt; &lt;/a&gt; 함수가 실패 하거나 ( &lt;code&gt;Math.sqrt(-1)&lt;/code&gt; ) 숫자를 구문 분석하려는 함수가 실패하면 ( &lt;code&gt;parseInt(&quot;blabla&quot;)&lt;/code&gt; ) 반환되는 값 입니다.</target>
        </trans-unit>
        <trans-unit id="8d807a334bdce03af9753e48784800ecd42f96a6" translate="yes" xml:space="preserve">
          <source>It is sometime useful to have a stricter way to parse float values, regular expressions can help :</source>
          <target state="translated">float 값을 구문 분석하는 더 엄격한 방법을 사용하는 것이 유용 할 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9028e6cb1ea88953f0056159fb43c778bc96771" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have a stricter way to parse int values. Regular expressions can help:</source>
          <target state="translated">int 값을 구문 분석하는보다 엄격한 방법을 사용하는 것이 유용한 경우가 있습니다. 정규식이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbdea303761b144c9595974be207942a85ce77f9" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to have a stricter way to parse integers.</source>
          <target state="translated">It is sometimes useful to have a stricter way to parse integers.</target>
        </trans-unit>
        <trans-unit id="788331654327003b9a3e20533f1dd22dd0adf40e" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the &lt;a href=&quot;../../operators/assignment_operators&quot;&gt;assignment operators&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;concat()&lt;/code&gt; 메서드 대신 &lt;a href=&quot;../../operators/assignment_operators&quot;&gt;할당 연산자&lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; )를 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a1c18ba9110166bc671d87e12d9f825477f805" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;assignment operators&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</source>
          <target state="translated">It is strongly recommended that the &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators&quot;&gt;assignment operators&lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; ) are used instead of the &lt;code&gt;concat()&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="f64ce9678fde9b6ccb870d85fc1f1595c83b8450" translate="yes" xml:space="preserve">
          <source>It is usually safer to provide an initial value because there are three possible outputs without &lt;code&gt;initialValue&lt;/code&gt;, as shown in the following example.</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;initialValue&lt;/code&gt; 없이 가능한 세 개의 출력이 있으므로 일반적으로 초기 값을 제공하는 것이 더 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="f39e377b324a5c9f08b33569e89ef7d1ecc19a5e" translate="yes" xml:space="preserve">
          <source>It may be most practically used for debugging purposes, being an easy way to check the properties of an object (by outputting to the console or otherwise). Although arrays are often more practical for storing data, in situations where a key-value pair is preferred for working with data (with properties acting as the &quot;key&quot;), there may be instances where you want to check if any of those keys hold a particular value.</source>
          <target state="translated">It may be most practically used for debugging purposes, being an easy way to check the properties of an object (by outputting to the console or otherwise). Although arrays are often more practical for storing data, in situations where a key-value pair is preferred for working with data (with properties acting as the &quot;key&quot;), there may be instances where you want to check if any of those keys hold a particular value.</target>
        </trans-unit>
        <trans-unit id="dae584578a863d7bff34ff1b67e5fef9249f60d6" translate="yes" xml:space="preserve">
          <source>It may seem strange to have a special exception-related clause that executes &lt;strong&gt;regardless&lt;/strong&gt; of whether there is an exception, but this construct actually does serve a purpose. The important point is not that the &lt;code&gt;finally&lt;/code&gt;-clause always executes, but rather that ordinary code following a &lt;code&gt;try..catch&lt;/code&gt; does not.</source>
          <target state="translated">예외 가 있는지 여부에 &lt;strong&gt;관계없이&lt;/strong&gt; 실행되는 특수 예외 관련 절이있는 것은 이상하게 보일 수 있지만이 구조는 실제로 목적을 제공합니다. 중요한 점은 &lt;code&gt;finally&lt;/code&gt; -clause가 항상 실행되는 것이 아니라 &lt;code&gt;try..catch&lt;/code&gt; 를 따르는 일반 코드가 항상 실행 되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="641a1f1bfb9cdea9572c9f6c64ca77cd267d097a" translate="yes" xml:space="preserve">
          <source>It might be tempting to use &lt;code&gt;Math.round()&lt;/code&gt; to accomplish that, but doing so would cause your random numbers to follow a non-uniform distribution, which may not be acceptable for your needs.</source>
          <target state="translated">그것을 달성 하기 위해 &lt;code&gt;Math.round()&lt;/code&gt; 를 사용 하고 싶을 수도 있지만, 그렇게하면 임의의 숫자가 비 균일 분포를 따르게되어 필요에 맞지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9d68bf98ccf8c0937c95ad24485ddb23a78f60f" translate="yes" xml:space="preserve">
          <source>It might just be an oversight, carefully check all you parenthesis in your code.</source>
          <target state="translated">그것은 단지 감독 일 수 있습니다. 코드에서 모든 괄호를주의 깊게 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="09d6a7960d6344daf110a07aa0f46e23fd7619dd" translate="yes" xml:space="preserve">
          <source>It must have exactly one parameter (see &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;Incompatible &lt;abbr&gt;ES5&lt;/abbr&gt; change: literal getter and setter functions must now have exactly zero or one arguments&lt;/a&gt; for more information);</source>
          <target state="translated">정확히 하나의 매개 변수를 가져야합니다 ( &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;호환되지 않는 &lt;abbr&gt;ES5&lt;/abbr&gt; 변경&lt;/a&gt; 참조 : 리터럴 getter 및 setter 함수는 이제 자세한 정보를 위해 정확히 0 또는 하나의 인수 를 가져야 함 ).</target>
        </trans-unit>
        <trans-unit id="e0d34231d840869638e3aa9002ecd024ffbeb1d0" translate="yes" xml:space="preserve">
          <source>It must have exactly zero parameters (see &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;Incompatible &lt;abbr&gt;ES5&lt;/abbr&gt; change: literal getter and setter functions must now have exactly zero or one arguments&lt;/a&gt; for more information);</source>
          <target state="translated">매개 변수는 정확히 0이어야합니다 ( &lt;a href=&quot;http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/&quot;&gt;호환되지 않는 &lt;abbr&gt;ES5&lt;/abbr&gt; 변경&lt;/a&gt; 참조 : 리터럴 게터 및 설정자 함수는 이제 정확히 0 개 또는 1 개의 인수 를 가져야합니다 ).</target>
        </trans-unit>
        <trans-unit id="657ebce6cc38bce8085a97e3ff70384ec64422e5" translate="yes" xml:space="preserve">
          <source>It must not appear in an object literal with another &lt;code&gt;get&lt;/code&gt; or with a data entry for the same property (&lt;code&gt;{ get x() { }, get x() { } }&lt;/code&gt; and &lt;code&gt;{ x: ..., get x() { } }&lt;/code&gt; are forbidden).</source>
          <target state="translated">동일한 속성 ( &lt;code&gt;{ get x() { }, get x() { } }&lt;/code&gt; 및 &lt;code&gt;{ x: ..., get x() { } }&lt;/code&gt; 대한 다른 &lt;code&gt;get&lt;/code&gt; 또는 데이터 항목이 있는 객체 리터럴에 표시되지 않아야합니다 . } 금지되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="05463fbb4aaf21f08a3ab5f26554235003d67ae9" translate="yes" xml:space="preserve">
          <source>It must not appear in an object literal with another &lt;code&gt;set&lt;/code&gt; or with a data entry for the same property.</source>
          <target state="translated">다른 &lt;code&gt;set&lt;/code&gt; 또는 동일한 특성에 대한 데이터 항목이 있는 오브젝트 리터럴에 표시되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="de37cc0fc3c6bed823b6d0ee0f3b91c3251ed188" translate="yes" xml:space="preserve">
          <source>It returns an object with a &lt;code&gt;url&lt;/code&gt; property indicating the base URL of the module. This will either be the URL from which the script was obtained, for external scripts, or the document base URL of the containing document, for inline scripts.</source>
          <target state="translated">모듈의 기본 URL을 나타내는 &lt;code&gt;url&lt;/code&gt; 속성을 가진 객체를 반환합니다 . 외부 스크립트의 경우 스크립트를 가져온 URL이거나 인라인 스크립트의 경우 포함 문서의 문서 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="bb2fc09f8688c1fd395eb3e9195d969486229a89" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;a href=&quot;operator_precedence&quot;&gt;the precedence&lt;/a&gt; of the &lt;code&gt;void&lt;/code&gt; operator should be taken into account and that parentheses can help clarify the resolution of the expression following the &lt;code&gt;void&lt;/code&gt; operator:</source>
          <target state="translated">It should be noted that &lt;a href=&quot;operator_precedence&quot;&gt;the precedence&lt;/a&gt; of the &lt;code&gt;void&lt;/code&gt; operator should be taken into account and that parentheses can help clarify the resolution of the expression following the &lt;code&gt;void&lt;/code&gt; operator:</target>
        </trans-unit>
        <trans-unit id="0ea4eb774c6833ffc646efd58e60903a08815e06" translate="yes" xml:space="preserve">
          <source>It should be noted that the maximum &lt;code&gt;Date&lt;/code&gt; is not of the same value as the maximum safe integer (&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; is 9,007,199,254,740,991). Instead, it is defined in ECMA-262 that a maximum of &amp;plusmn;100,000,000 (one hundred million) days relative to January 1, 1970 UTC (that is, April 20, 271821 BCE ~ September 13, 275760 CE) can be represented by the standard &lt;code&gt;Date&lt;/code&gt; object (equivalent to &amp;plusmn;8,640,000,000,000,000 milliseconds).</source>
          <target state="translated">It should be noted that the maximum &lt;code&gt;Date&lt;/code&gt; is not of the same value as the maximum safe integer ( &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; is 9,007,199,254,740,991). Instead, it is defined in ECMA-262 that a maximum of &amp;plusmn;100,000,000 (one hundred million) days relative to January 1, 1970 UTC (that is, April 20, 271821 BCE ~ September 13, 275760 CE) can be represented by the standard &lt;code&gt;Date&lt;/code&gt; object (equivalent to &amp;plusmn;8,640,000,000,000,000 milliseconds).</target>
        </trans-unit>
        <trans-unit id="954e387ac20208cc03c4f242e0c768abc0226976" translate="yes" xml:space="preserve">
          <source>It should be noted, however, that function expressions and function declarations nested within the function generated by parsing a &lt;code&gt;Function constructor&lt;/code&gt; 's string aren't parsed repeatedly. For example:</source>
          <target state="translated">그러나 &lt;code&gt;Function constructor&lt;/code&gt; 의 문자열 을 구문 분석하여 생성 된 함수 내에 중첩 된 함수 표현식 및 함수 선언 은 반복적으로 구문 분석되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5add076469b11cb8d7fb6364d8cdde585210a41c" translate="yes" xml:space="preserve">
          <source>It should return the value that should be added to the JSON string, as follows:</source>
          <target state="translated">JSON 문자열에 추가해야하는 값을 다음과 같이 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8133026fa0d9fb510eaf9a781595de1b0f3fe04" translate="yes" xml:space="preserve">
          <source>It takes four arguments:</source>
          <target state="translated">It takes four arguments:</target>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">세 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49a4eb485bbd793345a88879a66885954804a585" translate="yes" xml:space="preserve">
          <source>It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</source>
          <target state="translated">배열 &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;의 길이&lt;/a&gt; 를 줄이려고 시도했지만 배열의 요소 중 하나를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . 배열을 단축하면 새 배열 길이를 초과하는 요소가 삭제되어이 상황에서 실패합니다.</target>
        </trans-unit>
        <trans-unit id="02e2c9120f5b81da0f3dc90fab1cb8d051a5e07e" translate="yes" xml:space="preserve">
          <source>It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</source>
          <target state="translated">It was attempted to &lt;a href=&quot;../global_objects/array/length#Shortening_an_array&quot;&gt;shorten the length&lt;/a&gt; of an array, but one of the array's elements is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. When shortening an array, the elements beyond the new array length will be deleted, which failed in this situation.</target>
        </trans-unit>
        <trans-unit id="3b01aa32def2c0fe928809ced8d9324a50887fe5" translate="yes" xml:space="preserve">
          <source>It was attempted to delete a property, but that property is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed.</source>
          <target state="translated">특성을 삭제하려고 시도했지만 해당 특성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . &lt;code&gt;configurable&lt;/code&gt; 속성이 (이외의 속성 객체에서 여부 삭제 될 수 있는지 여부를 속성 컨트롤을 &lt;code&gt;writable&lt;/code&gt; ) 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef26e246ba549e7961e66ec8bd877f8126498a0" translate="yes" xml:space="preserve">
          <source>It was attempted to delete a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed.</source>
          <target state="translated">It was attempted to delete a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt; ) can be changed.</target>
        </trans-unit>
        <trans-unit id="ccad8caf638b4903b95cc599d522675b3d9021ba" translate="yes" xml:space="preserve">
          <source>It was attempted to redefine a property, but that property is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt;, the property isn't configurable by default.</source>
          <target state="translated">속성을 재정의하려고 시도했지만 해당 속성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;구성 할 수 없습니다&lt;/a&gt; . &lt;code&gt;configurable&lt;/code&gt; 속성이 (이외의 속성 객체에서 여부 삭제 될 수 있는지 여부를 속성 컨트롤을 &lt;code&gt;writable&lt;/code&gt; ) 변경할 수 있습니다. 일반적으로 &lt;a href=&quot;../operators/object_initializer&quot;&gt;객체 이니셜 라이저에&lt;/a&gt; 의해 생성 된 객체의 속성을 구성 할 수 있습니다. 그러나 예를 들어 &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 사용하는 경우 기본적으로이 속성을 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec1f1b3574980048baf67633369823cce4b51a22" translate="yes" xml:space="preserve">
          <source>It was attempted to redefine a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt;) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt;, the property isn't configurable by default.</source>
          <target state="translated">It was attempted to redefine a property, but that property is &lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Properties&quot;&gt;non-configurable&lt;/a&gt;. The &lt;code&gt;configurable&lt;/code&gt; attribute controls whether the property can be deleted from the object and whether its attributes (other than &lt;code&gt;writable&lt;/code&gt; ) can be changed. Usually, properties in an object created by an &lt;a href=&quot;../operators/object_initializer&quot;&gt;object initializer&lt;/a&gt; are configurable. However, for example, when using &lt;a href=&quot;../global_objects/object/defineproperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt;, the property isn't configurable by default.</target>
        </trans-unit>
        <trans-unit id="bab397dbab28fef0eebb4b36ff8f4cad76612d87" translate="yes" xml:space="preserve">
          <source>It will create an infinite loop if there is a match, due to the &lt;a href=&quot;lastindex&quot;&gt;&lt;code&gt;lastIndex&lt;/code&gt;&lt;/a&gt; property being reset upon each iteration.</source>
          <target state="translated">It will create an infinite loop if there is a match, due to the &lt;a href=&quot;lastindex&quot;&gt; &lt;code&gt;lastIndex&lt;/code&gt; &lt;/a&gt; property being reset upon each iteration.</target>
        </trans-unit>
        <trans-unit id="1d60210731c923bbd8d426ee1b331915626a35b0" translate="yes" xml:space="preserve">
          <source>It will return &lt;code&gt;0&lt;/code&gt; on non-shared &lt;code&gt;ArrayBuffer&lt;/code&gt; objects.</source>
          <target state="translated">It will return &lt;code&gt;0&lt;/code&gt; on non-shared &lt;code&gt;ArrayBuffer&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="4c6ba868b0d358d7be2e94d5d913452de49af160" translate="yes" xml:space="preserve">
          <source>It's also possible to explicitly get the string representation of a function using the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">It's also possible to explicitly get the string representation of a function using the &lt;code&gt;+&lt;/code&gt; operator:</target>
        </trans-unit>
        <trans-unit id="d0ae4f0160efc5dbbcb8104a8d363de06b4efe61" translate="yes" xml:space="preserve">
          <source>It's always been possible to return an array from a function. Destructuring can make working with an array return value more concise.</source>
          <target state="translated">항상 함수에서 배열을 반환 할 수있었습니다. 해체는 배열 반환 값을 사용하여보다 간결하게 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab096b013facf5171fb20f7a5008433704a6c33" translate="yes" xml:space="preserve">
          <source>It's an error to reference private fields from outside of the class; they can only be read or written within the class body. By defining things which are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change version to version.</source>
          <target state="translated">클래스 외부에서 개인 필드를 참조하는 것은 오류입니다. 수업 본문 내에서만 읽거나 쓸 수 있습니다. 클래스 외부에서 볼 수없는 것을 정의함으로써 클래스 사용자가 내부에 의존 할 수 없도록하여 버전을 버전으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03716457a38dd613fb146f492439c6694b559017" translate="yes" xml:space="preserve">
          <source>It's been &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036&quot;&gt;reported&lt;/a&gt; that some websites using MooTools 1.2 broke on Firefox 17. This version of MooTools checks whether &lt;code&gt;String.prototype.contains()&lt;/code&gt; exists and, if it doesn't, MooTools adds its own function. With the introduction of this function in Firefox 17, the behavior of that check changed in a way that causes code based on MooTools' &lt;code&gt;String.prototype.contains()&lt;/code&gt; implementation to break. As a result, the implementation was &lt;a href=&quot;https://hg.mozilla.org/releases/mozilla-aurora/rev/086db97198a8&quot;&gt;disabled&lt;/a&gt; in Firefox 17 and &lt;code&gt;String.prototype.contains()&lt;/code&gt; was available one version later, in Firefox 18, when &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036#c32&quot;&gt;outreach to MooTools &lt;/a&gt;was leading to the &lt;a href=&quot;http://mootools.net/blog/2013/02/19/mootools-1-2-6-released&quot;&gt;release of MooTools version 1.2.6&lt;/a&gt;.</source>
          <target state="translated">MooTools 1.2를 사용하는 일부 웹 사이트가 Firefox 17에서 중단 된 것으로 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036&quot;&gt;보고&lt;/a&gt; 되었습니다 .이 MooTools 버전은 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 존재 하는지 여부를 확인 하고 존재하지 않는 경우 MooTools는 자체 기능을 추가합니다. Firefox 17에이 함수가 도입되면서 MooTools의 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 구현을 기반으로하는 코드 가 중단 되는 방식으로 검사 기능이 변경되었습니다 . 결과적으로 Firefox 17에서 구현이 &lt;a href=&quot;https://hg.mozilla.org/releases/mozilla-aurora/rev/086db97198a8&quot;&gt;비활성화&lt;/a&gt; 되었으며 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=789036#c32&quot;&gt;MooTools&lt;/a&gt; 에 대한 지원 &lt;a href=&quot;http://mootools.net/blog/2013/02/19/mootools-1-2-6-released&quot;&gt;이 MooTools 버전 1.2.6&lt;/a&gt; 의 출시 로 이어질 때 Firefox 18에서 &lt;code&gt;String.prototype.contains()&lt;/code&gt; 가 한 버전 이후에 사용 가능했습니다 .</target>
        </trans-unit>
        <trans-unit id="ad42705853bcc5b13365e9dd36fbcbb6ceb6b2bb" translate="yes" xml:space="preserve">
          <source>It's easy to forget a character here or there.</source>
          <target state="translated">여기 저기 문자를 잊어 버리기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="aa341c3ae049b775c45f18a031d679d3313fdb7e" translate="yes" xml:space="preserve">
          <source>It's important to note the nature of block scoping.</source>
          <target state="translated">It's important to note the nature of block scoping.</target>
        </trans-unit>
        <trans-unit id="b7e9905f65f341e990222d4ff317bc808ce28e95" translate="yes" xml:space="preserve">
          <source>It's important to point out that the hoisting will affect the variable declaration, but not its value's initialization. The value will be indeed assigned when the assignment statement is reached:</source>
          <target state="translated">호이 스팅은 변수 선언에 영향을 미치지 만 값의 초기화에는 영향을 미치지 않습니다. 대 입문에 도달하면 값이 실제로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4bec33562b92cfeb84dad9aaca2fd74a7fdf2830" translate="yes" xml:space="preserve">
          <source>It's possible to use &lt;code&gt;String&lt;/code&gt; as a more reliable &lt;a href=&quot;string/tostring&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; alternative, as it works when used on &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;undefined&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/a&gt;, and on &lt;a href=&quot;symbol&quot;&gt;&lt;code&gt;symbols&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">그것은 사용하는 것이 가능 &lt;code&gt;String&lt;/code&gt; 더 신뢰할으로 &lt;a href=&quot;string/tostring&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 가 사용 때 작동하기 때문에, 다른 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;undefined&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/a&gt; , 그리고에 &lt;a href=&quot;symbol&quot;&gt; &lt;code&gt;symbols&lt;/code&gt; &lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b848ab2fb08e43e529543c6e2fab3e9726bc663" translate="yes" xml:space="preserve">
          <source>It's tough coming up with good variable names. We all have been there.</source>
          <target state="translated">좋은 변수 이름을 찾기가 어렵습니다. 우리 모두 거기에 왔습니다.</target>
        </trans-unit>
        <trans-unit id="9386f043281c3ea26d3f1bdde2724658066699bc" translate="yes" xml:space="preserve">
          <source>It's typical when speaking of an object's properties to make a distinction between properties and methods. However, the property/method distinction is little more than a convention. A method is simply a property that can be called (for example, if it has a reference to a &lt;a href=&quot;../global_objects/function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt; instance as its value).</source>
          <target state="translated">It's typical when speaking of an object's properties to make a distinction between properties and methods. However, the property/method distinction is little more than a convention. A method is simply a property that can be called (for example, if it has a reference to a &lt;a href=&quot;../global_objects/function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; instance as its value).</target>
        </trans-unit>
        <trans-unit id="5feb4718af1649655101d14d39d1577ed4fe6db2" translate="yes" xml:space="preserve">
          <source>Items on the prototype chain are not listed:</source>
          <target state="translated">프로토 타입 체인의 항목이 나열되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b526c83f0fbd860687a229f7de46226cbf3f2a" translate="yes" xml:space="preserve">
          <source>Iterable examples</source>
          <target state="translated">반복 가능한 예제</target>
        </trans-unit>
        <trans-unit id="303add622a0aab032fae6819c4ebe6b995c08abd" translate="yes" xml:space="preserve">
          <source>Iterable in constructor</source>
          <target state="translated">생성자에서 반복 가능</target>
        </trans-unit>
        <trans-unit id="12279667aeedad166b3a644b34522ec0663e7e6b" translate="yes" xml:space="preserve">
          <source>Iterable is an Array or other iterable object whose elements are key-value pairs (2-element Arrays). Each key-value pair will be added to the new WeakMap. null is treated as undefined.</source>
          <target state="translated">Iterable은 요소가 키-값 쌍 (2 요소 배열) 인 Array 또는 기타 반복 가능한 객체입니다. 각 키-값 쌍이 새 WeakMap에 추가됩니다. null은 정의되지 않은 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="2b023afbe3bb8465459d650343ef64c1ac087ed9" translate="yes" xml:space="preserve">
          <source>Iterates a specified variable over all values of object's properties. For each distinct property, a specified statement is executed.</source>
          <target state="translated">객체 속성의 모든 값에 대해 지정된 변수를 반복합니다. 각 고유 속성에 대해 지정된 명령문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="21fbe6e5ed65189e6f03abfbf39cf77716f2b19a" translate="yes" xml:space="preserve">
          <source>Iterates over async iterable objects, array-like objects, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;iterators and generators&lt;/a&gt;, invoking a custom iteration hook with statements to be executed for the value of each distinct property.</source>
          <target state="translated">비동기 반복 가능 객체, 배열과 유사한 객체, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;반복자 및 생성기&lt;/a&gt; 를 반복하여 각 고유 특성의 값에 대해 실행될 명령문으로 사용자 정의 반복 후크를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7fee0e8392755185b42e899080e03939cef85638" translate="yes" xml:space="preserve">
          <source>Iterates over iterable objects (including &lt;a href=&quot;global_objects/array&quot;&gt;arrays&lt;/a&gt;, array-like objects, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;iterators and generators&lt;/a&gt;), invoking a custom iteration hook with statements to be executed for the value of each distinct property.</source>
          <target state="translated">반복 가능한 객체 ( &lt;a href=&quot;global_objects/array&quot;&gt;배열&lt;/a&gt; , 배열과 유사한 객체, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators&quot;&gt;반복자 및 생성기 포함&lt;/a&gt; )를 반복하여 각 고유 특성의 값에 대해 실행될 명령문으로 사용자 정의 반복 후크를 호출합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
