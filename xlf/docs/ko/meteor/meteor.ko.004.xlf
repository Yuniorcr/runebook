<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="meteor">
    <body>
      <group id="meteor">
        <trans-unit id="c2245af3bb92516236d9d1a660cffb3a958845a5" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve identified which template you need to replace, define a new template. In this case, we want to modify the class on the button to work with the CSS for the rest of the app. There are a few things to keep in mind when overriding a template:</source>
          <target state="translated">어떤 템플릿을 교체해야하는지 확인한 후에 새 템플릿을 정의하십시오. 이 경우 나머지 앱의 CSS에서 작동하도록 버튼의 클래스를 수정하려고합니다. 템플릿을 재정의 할 때 명심해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07efbff30db87de8792d19052d5b4969fe7b2327" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve installed Meteor, create a project:</source>
          <target state="translated">Meteor를 설치 한 후 프로젝트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ee1b302d4495249d5c1da36f025f44bf60439b3b" translate="yes" xml:space="preserve">
          <source>One Method per action</source>
          <target state="translated">액션 당 하나의 방법</target>
        </trans-unit>
        <trans-unit id="c04f6ddb98dfa183e1fc6dbeb56f4edf30b31471" translate="yes" xml:space="preserve">
          <source>One easy way to do this is with the &lt;a href=&quot;https://atmospherejs.com/gadicc/blaze-react-component&quot;&gt;&lt;code&gt;gadicc:blaze-react-component&lt;/code&gt;&lt;/a&gt; package. First run &lt;code&gt;meteor add gadicc:blaze-react-component&lt;/code&gt;, then import and use it in your components as follows:</source>
          <target state="translated">가장 쉬운 방법은 &lt;a href=&quot;https://atmospherejs.com/gadicc/blaze-react-component&quot;&gt; &lt;code&gt;gadicc:blaze-react-component&lt;/code&gt; &lt;/a&gt; 패키지를 사용하는 것입니다. 먼저 실행 &lt;code&gt;meteor add gadicc:blaze-react-component&lt;/code&gt; 를 실행 한 후 다음과 같이 컴포넌트에서 가져 와서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4e643759a6bb30e66b05248d66eedbe8cd16600" translate="yes" xml:space="preserve">
          <source>One important feature of the Atmosphere package system is that it is single-loading: no two packages in the same app can have dependencies on conflicting versions of a single package. Read more about that in the section about version constraints below.</source>
          <target state="translated">Atmosphere 패키지 시스템의 중요한 기능 중 하나는 단일로드라는 점입니다. 동일한 앱의 두 패키지는 충돌하는 단일 패키지 버전에 종속 될 수 없습니다. 아래 버전 제약 조건 섹션에서 이에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="a385a8c56b13d68d8d80acee5e67db57b806032a" translate="yes" xml:space="preserve">
          <source>One nice UX pattern which Meteor makes much easier than other frameworks is Optimistic UI. Optimistic UI is the process of showing user-generated changes in the UI without waiting for the server to acknowledge that the change has succeeded, resulting in a user experience that seems faster than is physically possible, since you don&amp;rsquo;t need to wait for any server roundtrips. Since most user actions in a well-designed app will be successful, it makes sense for almost all parts of an app to be optimistic in this way.</source>
          <target state="translated">Meteor가 다른 프레임 워크보다 훨씬 쉽게 만드는 멋진 UX 패턴은 낙관적 UI입니다. 낙관적 UI는 서버가 변경 성공을 인식 할 때까지 기다리지 않고 UI에서 사용자 생성 변경 사항을 표시하는 프로세스로, 사용자가 기다릴 필요가 없기 때문에 물리적으로 가능한 것보다 더 빠른 사용자 경험을 제공합니다. 서버 왕복. 잘 설계된 앱에서 대부분의 사용자 작업이 성공하기 때문에 앱의 거의 모든 부분이 이런 방식으로 낙관적입니다.</target>
        </trans-unit>
        <trans-unit id="e937530a73456e4947fbe9e89b792149c17ae25f" translate="yes" xml:space="preserve">
          <source>One of the main reasons you might want to add a login system to your app is to have permissions for your data. For example, if you were running a forum, you would want administrators or moderators to be able to delete any post, but normal users can only delete their own. This uncovers two different types of permissions:</source>
          <target state="translated">앱에 로그인 시스템을 추가하려는 주된 이유 중 하나는 데이터에 대한 권한이 있기 때문입니다. 예를 들어 포럼을 실행중인 경우 관리자 나 중재자가 게시물을 삭제할 수 있지만 일반 사용자는 자신의 게시물 만 삭제할 수 있습니다. 이를 통해 두 가지 유형의 권한이 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="06a8f7a0da4f4e262df831f068c68fbacedbde0d" translate="yes" xml:space="preserve">
          <source>One of the most core concepts in Blaze is the &amp;ldquo;view&amp;rdquo;, which is a building block that represents a reactively rendering area of a template. The view is the machinery that works behind the scenes to track reactivity, do lookups, and re-render appropriately when data changes. The view is the unit of re-rendering in Blaze. You can even use the view tree to walk the rendered component hierarchy, but it&amp;rsquo;s better to avoid this in favor of communicating between components using callbacks, template arguments, or global data stores.</source>
          <target state="translated">Blaze의 가장 핵심적인 개념 중 하나는 템플릿의 반응 렌더링 영역을 나타내는 빌딩 블록 인 &quot;보기&quot;입니다. 뷰는 장면 뒤에서 작동하여 데이터를 변경할 때 반응성을 추적하고 조회를 수행하고 적절하게 다시 렌더링하는 메커니즘입니다. 뷰는 Blaze에서 다시 렌더링하는 단위입니다. 뷰 트리를 사용하여 렌더링 된 구성 요소 계층 구조를 따라갈 수도 있지만 콜백, 템플릿 인수 또는 전역 데이터 저장소를 사용하여 구성 요소 간 통신을 선호하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef78943e212ce2b6432240b049e5ec156d119ce3" translate="yes" xml:space="preserve">
          <source>One option would be to provide a Method that simply proxies through to the endpoint, for which it&amp;rsquo;s the client&amp;rsquo;s responsibility to poll and deal with the changing data as it comes in. So then it&amp;rsquo;s the clients problem to deal with keeping a local data cache of the data, updating the UI when changes happen, etc. Although this is possible (you could use a Local Collection to store the polled data, for instance), it&amp;rsquo;s simpler, and more natural to create a publication that does this polling for the client.</source>
          <target state="translated">한 가지 옵션은 엔드 포인트로 프록시하는 방법을 제공하는 것입니다. 엔드 포인트를 통해 프록시는 변경되는 데이터를 폴링하고 처리하는 것은 고객의 책임입니다. 따라서 로컬 데이터 캐시를 유지하는 것은 클라이언트 문제입니다. 데이터가 발생하고 변경이 발생할 때 UI를 업데이트하는 등의 작업이 가능하지만 (예 : 로컬 컬렉션을 사용하여 폴링 된 데이터를 저장할 수 있음) 클라이언트에 대해이 폴링을 수행하는 게시를 만드는 것이 더 간단하고 더 자연 스럽습니다. .</target>
        </trans-unit>
        <trans-unit id="13ade0ae6464b55152b92afe05db99bf707f6c21" translate="yes" xml:space="preserve">
          <source>One piece of information that&amp;rsquo;s very useful to know when paginating data is the &lt;em&gt;total number of items&lt;/em&gt; that you could see. The &lt;a href=&quot;https://atmospherejs.com/tmeasday/publish-counts&quot;&gt;&lt;code&gt;tmeasday:publish-counts&lt;/code&gt;&lt;/a&gt; package can be useful to publish this. We could add a &lt;code&gt;Lists.todoCount&lt;/code&gt; publication like so</source>
          <target state="translated">페이지 매김 데이터를 알 때 매우 유용한 정보 는 볼 &lt;em&gt;수&lt;/em&gt; 있는 &lt;em&gt;총 항목 수입니다&lt;/em&gt; . &lt;a href=&quot;https://atmospherejs.com/tmeasday/publish-counts&quot;&gt; &lt;code&gt;tmeasday:publish-counts&lt;/code&gt; &lt;/a&gt; 패키지는이를 게시하는 것이 유용 할 수 있습니다. &lt;code&gt;Lists.todoCount&lt;/code&gt; 게시를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9155e7b13809f3145b26bd096ae4b49da222b840" translate="yes" xml:space="preserve">
          <source>One place where you might be tempted to not subscribe inside a component is when it accesses data that you know you &lt;em&gt;always&lt;/em&gt; need. For instance, a subscription to extra fields on the user object (see the &lt;a href=&quot;accounts&quot;&gt;Accounts Article&lt;/a&gt;) that you need on every screen of your app.</source>
          <target state="translated">구성 요소 내에서 구독하지 않으려는 유혹이있는 곳은 &lt;em&gt;항상&lt;/em&gt; 필요한 데이터에 액세스 할 때 입니다. 예를 들어, 앱의 모든 화면에서 필요한 사용자 개체 ( &lt;a href=&quot;accounts&quot;&gt;계정 기사&lt;/a&gt; 참조)의 추가 필드 구독 .</target>
        </trans-unit>
        <trans-unit id="608d93788c7134f13b44e6cff596ee22398405ab" translate="yes" xml:space="preserve">
          <source>One point to be aware of is that if you allow the user to &lt;em&gt;modify&lt;/em&gt; data in the &amp;ldquo;pseudo-collection&amp;rdquo; you are publishing in this fashion, you&amp;rsquo;ll want to be sure to re-publish the modifications to them via the publication, to achieve an optimistic user experience.</source>
          <target state="translated">한 가지 알아야 할 점은 사용자가 이러한 방식으로 게시하는 &quot;의사 수집&quot;에서 데이터 를 &lt;em&gt;수정&lt;/em&gt; 하도록 허용하는 경우 게시를 통해 수정 사항을 다시 게시해야한다는 것입니다. 낙관적 인 사용자 경험을 달성하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6ae0797bb8ef145fb858f43b8362540c55b435" translate="yes" xml:space="preserve">
          <source>One situation where it is sensible to access the global &lt;code&gt;FlowRouter&lt;/code&gt; singleton to access the current route&amp;rsquo;s information deeper in the component hierarchy is when rendering links via a navigation component. It&amp;rsquo;s often required to highlight the &amp;ldquo;active&amp;rdquo; route in some way (this is the route or section of the site that the user is currently looking at).</source>
          <target state="translated">구성 요소 계층에서 더 깊은 현재 경로 정보 에 액세스하기 위해 전역 &lt;code&gt;FlowRouter&lt;/code&gt; 싱글 톤에 액세스 할 수있는 상황 은 탐색 구성 요소를 통해 링크를 렌더링하는 경우입니다. 어떤 방식 으로든 '활성'경로를 강조 표시해야하는 경우가 종종 있습니다 (사용자가 현재보고있는 사이트의 경로 또는 섹션 임).</target>
        </trans-unit>
        <trans-unit id="562214d843f76fb2b35cadaeefc26055b679ded2" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to &lt;em&gt;animate&lt;/em&gt; list changes (which we&amp;rsquo;ll look at in the &lt;a href=&quot;#animation&quot;&gt;animation section&lt;/a&gt;), but this isn&amp;rsquo;t always the best approach. For instance, if a user is reading a list of comments, they may not want to see any changes until they are done with the current comment thread.</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 목록 변경 ( &lt;a href=&quot;#animation&quot;&gt;애니메이션 섹션&lt;/a&gt; 에서 살펴볼 것 )에 &lt;em&gt;애니메이션&lt;/em&gt; 을 &lt;em&gt;적용&lt;/em&gt; 하는 것이지만 이것이 항상 최선의 방법은 아닙니다. 예를 들어, 사용자가 주석 목록을 읽고있는 경우 현재 주석 스레드로 완료 될 때까지 변경 사항을보고 싶지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693bec8c10a316807a838ab0ff97f378c6c16e6e" translate="yes" xml:space="preserve">
          <source>One thing that Collection2 does is &lt;a href=&quot;https://github.com/aldeed/meteor-simple-schema#cleaning-data&quot;&gt;&amp;ldquo;clean&amp;rdquo; the data&lt;/a&gt; before sending it to the database. This includes but is not limited to:</source>
          <target state="translated">Collection2가하는 한 가지 일은 &lt;a href=&quot;https://github.com/aldeed/meteor-simple-schema#cleaning-data&quot;&gt;데이터&lt;/a&gt; 를 데이터베이스로 보내기 전에 데이터 를 &quot;정리&quot;하는 것입니다 . 여기에는 다음이 포함되지만 이에 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0485d121b4175432f75b9f140338ecf12c31adb" translate="yes" xml:space="preserve">
          <source>One useful thing to add for your app can be the concept of a &amp;ldquo;primary&amp;rdquo; email address. This way, if the user has added multiple emails, you know where to send confirmation emails and similar.</source>
          <target state="translated">앱에 추가해야 할 유용한 것 중 하나는 &quot;기본&quot;전자 메일 주소의 개념 일 수 있습니다. 이렇게하면 사용자가 여러 개의 전자 메일을 추가 한 경우 확인 전자 메일을 보낼 위치와 이와 유사한 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1519b8207491f20e999cd392260925e037f7ea50" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is simply to not run old migrations on your database. This is a little bit limiting but can be made to work.</source>
          <target state="translated">이 문제를 피하는 한 가지 방법은 단순히 데이터베이스에서 이전 마이그레이션을 실행하지 않는 것입니다. 이것은 약간 제한적이지만 작동하도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b863f5ac47796b55bc346cc4d5f3111291eb7ea" translate="yes" xml:space="preserve">
          <source>One way you might do this is to return more than one cursor from your publication function:</source>
          <target state="translated">이를 수행 할 수있는 한 가지 방법은 공개 함수에서 둘 이상의 커서를 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c486be9ae16a7ac67b0f4a4441bf70865ffc185f" translate="yes" xml:space="preserve">
          <source>Ongoing Meteor Guide development takes place &lt;strong&gt;in the open&lt;/strong&gt;&lt;a href=&quot;https://github.com/meteor/guide&quot;&gt;on GitHub&lt;/a&gt;. We encourage pull requests and issues to discuss problems with any changes that could be made to the content. We hope that keeping our process open and honest will make it clear what we plan to include in the guide and what changes will be coming in future Meteor versions.</source>
          <target state="translated">지속적인 Meteor Guide 개발은 &lt;a href=&quot;https://github.com/meteor/guide&quot;&gt;GitHub &lt;/a&gt;&lt;strong&gt;에서 공개적 &lt;/strong&gt;으로 진행 &lt;strong&gt;됩니다&lt;/strong&gt; . 콘텐츠를 변경할 수있는 변경 사항에 대한 문제를 논의하기 위해 풀 요청 및 문제를 권장합니다. 프로세스를 공개적이고 정직하게 유지하면 가이드에 포함 할 계획과 향후 Meteor 버전에서 어떤 변경 사항이 있을지 명확하게 알 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="e739463e4e362c55895faf2e10c7086bf5a233fa" translate="yes" xml:space="preserve">
          <source>Only Mongo modifiers are supported (operations like &lt;code&gt;$set&lt;/code&gt; and &lt;code&gt;$push&lt;/code&gt;). If the user tries to replace the entire document rather than use $-modifiers, the request will be denied without checking the &lt;code&gt;allow&lt;/code&gt; functions.</source>
          <target state="translated">Mongo 수정 자만 지원됩니다 ( &lt;code&gt;$set&lt;/code&gt; 및 &lt;code&gt;$push&lt;/code&gt; 와 같은 작업 ). 사용자가 $ 수정자를 사용하지 않고 전체 문서를 바꾸려고하면 &lt;code&gt;allow&lt;/code&gt; 기능 을 확인하지 않고 요청이 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc7b6ef21aca15c9c2763c827121f349454d3c6" translate="yes" xml:space="preserve">
          <source>Open a MongoDB shell on your local development database, so that you can view or manipulate it directly.</source>
          <target state="translated">로컬 개발 데이터베이스에서 MongoDB 쉘을 열어서 직접 보거나 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a24a835f884e2a5d3c2192aa79cd616a0545d748" translate="yes" xml:space="preserve">
          <source>Open the &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle Java website&lt;/a&gt;, and select the Java Platform (JDK)</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle Java 웹 사이트를&lt;/a&gt; 열고 Java 플랫폼 (JDK)을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e5dada9f07f167d018202682b7db0a7675413f41" translate="yes" xml:space="preserve">
          <source>Optimistic UI</source>
          <target state="translated">낙관적 UI</target>
        </trans-unit>
        <trans-unit id="643ad30923efda6edaefd043c0ed2f56f3f2df12" translate="yes" xml:space="preserve">
          <source>Optional - whether the new email address should be marked as verified. Defaults to false.</source>
          <target state="translated">선택 사항-새 이메일 주소를 확인 된 것으로 표시해야하는지 여부 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="3ce1177dc30f77e6f0fbc70f020c8ae44e2e9689" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;this&lt;/code&gt; object against which the original function will be invoked</source>
          <target state="translated">선택적으로 원래 함수가 호출 될 &lt;code&gt;this&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="f2b502fca25acb3346f68d51a3ad71866861a590" translate="yes" xml:space="preserve">
          <source>Optional DDP connection to reuse.</source>
          <target state="translated">재사용 할 수있는 선택적 DDP 연결.</target>
        </trans-unit>
        <trans-unit id="2b1ca519d2c3b87735efeacac429adc8fee78d73" translate="yes" xml:space="preserve">
          <source>Optional Filepath to documentation. Set to 'README.md' by default. Set this to null to submit no documentation.</source>
          <target state="translated">문서에 대한 선택적 파일 경로. 기본적으로 'README.md'로 설정하십시오. 문서를 제출하지 않으려면이 값을 null로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2062de28015111b04b8268cd932fc2b20032e827" translate="yes" xml:space="preserve">
          <source>Optional Git URL to the source repository.</source>
          <target state="translated">소스 리포지토리에 대한 선택적 Git URL.</target>
        </trans-unit>
        <trans-unit id="94c373a3c0ac95938eb633d1206fa0279edf48a4" translate="yes" xml:space="preserve">
          <source>Optional URL for creating a new DDP connection.</source>
          <target state="translated">새 DDP 연결을 만들기위한 선택적 URL입니다.</target>
        </trans-unit>
        <trans-unit id="8d5edf0beffc1c25094d5e082f632e8205f48854" translate="yes" xml:space="preserve">
          <source>Optional additional data to be added into the token record.</source>
          <target state="translated">토큰 레코드에 추가 할 선택적 추가 데이터.</target>
        </trans-unit>
        <trans-unit id="1a356eac4559527a400d214412af5f40ab962e26" translate="yes" xml:space="preserve">
          <source>Optional arguments passed to publisher function on server.</source>
          <target state="translated">서버에서 게시자 함수에 전달 된 선택적 인수입니다.</target>
        </trans-unit>
        <trans-unit id="a5da6453042ca4b5635c452fd01e6b699d109668" translate="yes" xml:space="preserve">
          <source>Optional callback, which is called asynchronously with the error or result after the function is complete. If not provided, the function runs synchronously.</source>
          <target state="translated">선택적 콜백. 함수가 완료된 후 오류 또는 결과와 함께 비동기 적으로 호출됩니다. 제공되지 않으면 기능이 동 기적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb4007f4f60af4f689bc9f284f5276d1931420ba" translate="yes" xml:space="preserve">
          <source>Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).</source>
          <target state="translated">메소드가 완료된 후 오류 또는 결과와 함께 비동기 적으로 호출되는 선택적 콜백입니다. 제공되지 않은 경우, 방법은 가능하면 동기식으로 실행됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2e976b73a75d7017485e073a00b9d1e522a65217" translate="yes" xml:space="preserve">
          <source>Optional callback. Called with no arguments on success, or with a single &lt;code&gt;Error&lt;/code&gt; argument on failure.</source>
          <target state="translated">선택적 콜백. 성공시 인수가 없거나 실패시 단일 &lt;code&gt;Error&lt;/code&gt; 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="866264afd4838ebd59331c1a9808fb598b6a278e" translate="yes" xml:space="preserve">
          <source>Optional callback. Called with no arguments on success, or with a single &lt;code&gt;Error&lt;/code&gt; argument on failure. The callback cannot be called if you are using the &quot;redirect&quot; &lt;code&gt;loginStyle&lt;/code&gt;, because the app will have reloaded in the meantime; try using &lt;a href=&quot;#accounts_onlogin&quot;&gt;client-side login hooks&lt;/a&gt; instead.</source>
          <target state="translated">선택적 콜백. 성공시 인수가 없거나 실패시 단일 &lt;code&gt;Error&lt;/code&gt; 인수로 호출됩니다. &quot;redirect&quot; &lt;code&gt;loginStyle&lt;/code&gt; 을 사용하는 경우 콜백을 호출 할 수 없습니다 . 그 동안 앱이 다시로드되기 때문입니다. 대신 &lt;a href=&quot;#accounts_onlogin&quot;&gt;클라이언트 측 로그인 후크&lt;/a&gt; 를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="7aaafbc93ce519b4d7800e3dccb2592a79af8b49" translate="yes" xml:space="preserve">
          <source>Optional callback. If passed, the method runs asynchronously, instead of synchronously, and calls asyncCallback. On the client, this callback is required.</source>
          <target state="translated">선택적 콜백. 전달되면 메서드는 동기식이 아닌 비동기식으로 실행되며 asyncCallback을 호출합니다. 클라이언트에서는이 콜백이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16014bc07737a03deb25e654724ccf83b20f299f" translate="yes" xml:space="preserve">
          <source>Optional callback; same semantics as in &lt;a href=&quot;#meteor_call&quot;&gt;&lt;code&gt;Meteor.call&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 콜백; &lt;a href=&quot;#meteor_call&quot;&gt; &lt;code&gt;Meteor.call&lt;/code&gt; &lt;/a&gt; 과 동일한 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="b0ea2a35fd3e3fe5a82e1460dcc3c6da40f9714a" translate="yes" xml:space="preserve">
          <source>Optional length of the identifier in characters (defaults to 17)</source>
          <target state="translated">문자로 된 식별자의 선택적 길이 (기본값은 17)</target>
        </trans-unit>
        <trans-unit id="6aa5d2cb894ed9a13e151cce0449c21df87ddb15" translate="yes" xml:space="preserve">
          <source>Optional length of the secret string (defaults to 43 characters, or 256 bits of entropy)</source>
          <target state="translated">비밀 문자열의 선택적 길이 (기본값은 43 자 또는 256 비트 엔트로피)</target>
        </trans-unit>
        <trans-unit id="3ce46e8cfee821a0da260af67de15dd1a98939eb" translate="yes" xml:space="preserve">
          <source>Optional method arguments</source>
          <target state="translated">선택적 메소드 인수</target>
        </trans-unit>
        <trans-unit id="5748f7150e5050a60bbf656d8939815142e707b6" translate="yes" xml:space="preserve">
          <source>Optional name override. By default, the package name comes from the name of its directory.</source>
          <target state="translated">선택적 이름 재정의. 기본적으로 패키지 이름은 디렉토리 이름에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0089fb8b63f95d6ef7ec9a543e2b97dfe94b3e11" translate="yes" xml:space="preserve">
          <source>Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;remove&lt;/code&gt; functions.</source>
          <target state="translated">선택적 성능 향상. &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 기능으로 검사하기 위해 데이터베이스에서 가져올 필드를 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="abed5a45d77ee470c604514993b668b923e8ccf7" translate="yes" xml:space="preserve">
          <source>Optional. A Function that returns &lt;a href=&quot;#Renderable-Content&quot;&gt;&lt;em&gt;renderable content&lt;/em&gt;&lt;/a&gt;. If no &lt;code&gt;elseFunc&lt;/code&gt; is supplied, no content is shown in the &quot;else&quot; case.</source>
          <target state="translated">선택 과목. &lt;a href=&quot;#Renderable-Content&quot;&gt;&lt;em&gt;렌더링 가능한 내용&lt;/em&gt;&lt;/a&gt; 을 반환하는 함수입니다 . 어떤 경우 &lt;code&gt;elseFunc&lt;/code&gt; 가 제공되지 않는, 어떤 내용이 &quot;다른&quot;경우에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e65194d6f58a86bd97335b088d3295ee7b2c5d0" translate="yes" xml:space="preserve">
          <source>Optional. A function of two arguments, called on the old value and the new value whenever the ReactiveVar is set. If it returns true, no set is performed. If omitted, the default &lt;code&gt;equalsFunc&lt;/code&gt; returns true if its arguments are &lt;code&gt;===&lt;/code&gt; and are of type number, boolean, string, undefined, or null.</source>
          <target state="translated">선택 과목. ReactiveVar가 설정 될 때마다 이전 값과 새 값에서 호출되는 두 개의 인수 함수입니다. true를 리턴하면 세트가 수행되지 않습니다. 생략하면, 기본값 &lt;code&gt;equalsFunc&lt;/code&gt; 는 인수가 &lt;code&gt;===&lt;/code&gt; 이고 number, boolean, string, undefined 또는 null 인 경우 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8fa18ab3197cd6b44e01abc99d3e338d8cdab003" translate="yes" xml:space="preserve">
          <source>Optional. A name for Views constructed by this Template. See &lt;a href=&quot;#view_name&quot;&gt;&lt;code&gt;view.name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택 과목. 이 템플릿으로 생성 된 뷰의 이름입니다. &lt;a href=&quot;#view_name&quot;&gt; &lt;code&gt;view.name&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b14192f51827ea632949522f7e65b43830aba77" translate="yes" xml:space="preserve">
          <source>Optional. A name for this type of View. See &lt;a href=&quot;#view_name&quot;&gt;&lt;code&gt;view.name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택 과목. 이 유형의보기 이름입니다. &lt;a href=&quot;#view_name&quot;&gt; &lt;code&gt;view.name&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78797f45c0309eca53361a2860d6297bcb89d13f" translate="yes" xml:space="preserve">
          <source>Optional. A platform name (either &lt;code&gt;ios&lt;/code&gt; or &lt;code&gt;android&lt;/code&gt;) to add a platform-specific preference.</source>
          <target state="translated">선택 과목. 플랫폼 별 환경 설정을 추가하는 플랫폼 이름 ( &lt;code&gt;ios&lt;/code&gt; 또는 &lt;code&gt;android&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="db38daefcfbd47ee3e35bf4b8e14484d90c60442" translate="yes" xml:space="preserve">
          <source>Optional. A short human-readable summary of the error, like 'Not Found'.</source>
          <target state="translated">선택 과목. '찾을 수 없음'과 같이 사람이 읽을 수있는 짧은 요약입니다.</target>
        </trans-unit>
        <trans-unit id="7d0d07563690955a9a423f8fc1188c501de82f77" translate="yes" xml:space="preserve">
          <source>Optional. Additional information about the error, like a textual stack trace.</source>
          <target state="translated">선택 과목. 텍스트 스택 추적과 같은 오류에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="7acf3396eb1b8186caf2ebe0eeef32302661403e" translate="yes" xml:space="preserve">
          <source>Optional. An element that was rendered by a Meteor, or a View.</source>
          <target state="translated">선택 과목. Meteor 또는 View에 의해 렌더링 된 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a83c6bb1fbdcd2e8fa8e4d899334bcbf154dc31d" translate="yes" xml:space="preserve">
          <source>Optional. If present, called with an error object as its argument.</source>
          <target state="translated">선택 과목. 존재하는 경우, 오류 오브젝트를 인수로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7172808148a20fcb88bff0c5e39babf6d4769434" translate="yes" xml:space="preserve">
          <source>Optional. If present, called with an error object as the first argument and, if no error, the _id as the second.</source>
          <target state="translated">선택 과목. 존재하는 경우 첫 번째 인수로 오류 객체와 함께 호출되고 오류가 없으면 두 번째로 _id입니다.</target>
        </trans-unit>
        <trans-unit id="81bfa19cc56a07bea98ef9029a4496e78315b142" translate="yes" xml:space="preserve">
          <source>Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</source>
          <target state="translated">선택 과목. 존재하는 경우 첫 번째 인수로 오류 개체와 함께 호출되고 오류가 없으면 두 번째로 영향을받는 문서 수입니다.</target>
        </trans-unit>
        <trans-unit id="9551349951d3883395f5adc34d7af4c4ca072ab8" translate="yes" xml:space="preserve">
          <source>Optional. If provided, it will be set as the rendered View's &lt;a href=&quot;#view_parentview&quot;&gt;&lt;code&gt;parentView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택 과목. 제공하면 렌더링 된 뷰의 &lt;a href=&quot;#view_parentview&quot;&gt; &lt;code&gt;parentView&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fed3559474c572fc3c65b6053a86dcb9792e630" translate="yes" xml:space="preserve">
          <source>Optional. If provided, must be a child of &lt;em&gt;parentNode&lt;/em&gt;; the template will be inserted before this node. If not provided, the template will be inserted as the last child of parentNode.</source>
          <target state="translated">선택 과목. 제공되는 경우 &lt;em&gt;parentNode&lt;/em&gt; 의 하위 여야합니다 . 이 노드 앞에 템플릿이 삽입됩니다. 제공하지 않으면 템플릿은 parentNode의 마지막 자식으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="279b4fdca8d8a5b52a5ec4979dc3c86f0eb24a69" translate="yes" xml:space="preserve">
          <source>Optional. If specified, the View enclosing &lt;code&gt;element&lt;/code&gt; is returned.</source>
          <target state="translated">선택 과목. 지정된 경우 View 엔 클로징 &lt;code&gt;element&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="651bd945d835785fe36f575684104c0a9a9871e7" translate="yes" xml:space="preserve">
          <source>Optional. May include &lt;code&gt;onStop&lt;/code&gt; and &lt;code&gt;onReady&lt;/code&gt; callbacks. If there is an error, it is passed as an argument to &lt;code&gt;onStop&lt;/code&gt;. If a function is passed instead of an object, it is interpreted as an &lt;code&gt;onReady&lt;/code&gt; callback.</source>
          <target state="translated">선택 과목. 포함 &lt;code&gt;onStop&lt;/code&gt; 와 &lt;code&gt;onReady&lt;/code&gt; 콜백. 오류가 있으면 &lt;code&gt;onStop&lt;/code&gt; 에 인수로 전달됩니다 . 객체 대신 함수가 전달되면 &lt;code&gt;onReady&lt;/code&gt; 콜백으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="278619d19810441639858f0bd82c7df83403f531" translate="yes" xml:space="preserve">
          <source>Optional. The 24-character hexadecimal contents of the ObjectID to create</source>
          <target state="translated">선택 과목. 작성할 ObjectID의 24 자 16 진 컨텐츠</target>
        </trans-unit>
        <trans-unit id="40b318f18ba6c3dc352b80788058488f3361d8aa" translate="yes" xml:space="preserve">
          <source>Optional. The data context in which to include the template.</source>
          <target state="translated">선택 과목. 템플릿을 포함 할 데이터 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="eebf8c88808ac3a633db6dd38f739b626cb7d94d" translate="yes" xml:space="preserve">
          <source>Optional. The function to run when an error happens in the Computation. The only argument it receives is the Error thrown. Defaults to the error being logged to the console.</source>
          <target state="translated">선택 과목. 계산에서 오류가 발생할 때 실행할 기능입니다. 수신되는 유일한 인수는 오류 발생입니다. 콘솔에 기록되는 오류가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c83372ac3b89f75804252c05606d98ef60ec719c" translate="yes" xml:space="preserve">
          <source>Optional. Which address of the user's to send the email to. This address must be in the user's &lt;code&gt;emails&lt;/code&gt; list. Defaults to the first email in the list.</source>
          <target state="translated">선택 과목. 이메일을 보낼 사용자의 주소입니다. 이 주소는 사용자의 &lt;code&gt;emails&lt;/code&gt; 목록 에 있어야 합니다. 목록의 첫 번째 이메일이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="33ada2561149e7d23b2d350f77413b812aeee38e" translate="yes" xml:space="preserve">
          <source>Optional. Which address of the user's to send the email to. This address must be in the user's &lt;code&gt;emails&lt;/code&gt; list. Defaults to the first unverified email in the list.</source>
          <target state="translated">선택 과목. 이메일을 보낼 사용자의 주소입니다. 이 주소는 사용자의 &lt;code&gt;emails&lt;/code&gt; 목록 에 있어야 합니다. 목록에서 확인되지 않은 첫 번째 이메일이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2f56f5aa4cbe7513bc2d9a6bdd47cc2223ce6aca" translate="yes" xml:space="preserve">
          <source>Optionally, adds version constraints. Running &lt;code&gt;meteor add package@1.1.0&lt;/code&gt; will add the package at version &lt;code&gt;1.1.0&lt;/code&gt; or higher (but not &lt;code&gt;2.0.0&lt;/code&gt; or higher). If you want to use version &lt;code&gt;1.1.0&lt;/code&gt; exactly, use &lt;code&gt;meteor add package@=1.1.0&lt;/code&gt;. You can also &amp;lsquo;or&amp;rsquo; constraints together: for example, &lt;code&gt;meteor add 'package@=1.0.0 || =2.0.1'&lt;/code&gt; means either 1.0.0 (exactly) or 2.0.1 (exactly).</source>
          <target state="translated">선택적으로 버전 제약 조건을 추가합니다. &lt;code&gt;meteor add package@1.1.0&lt;/code&gt; 을 실행 하면 버전 &lt;code&gt;1.1.0&lt;/code&gt; 이상 ( &lt;code&gt;2.0.0&lt;/code&gt; 이상) 에서 패키지가 추가됩니다 . 버전 &lt;code&gt;1.1.0&lt;/code&gt; 을 정확하게 사용하려면 &lt;code&gt;meteor add package@=1.1.0&lt;/code&gt; 을 사용 하십시오 . 예를 들어 &lt;code&gt;meteor add 'package@=1.0.0 || =2.0.1'&lt;/code&gt; 은 1.0.0 (정확) 또는 2.0.1 (정확)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4e349444562c4e622ed3b666533b3b816ba0ada" translate="yes" xml:space="preserve">
          <source>Optionally, you can specify &lt;code&gt;--keystore&lt;/code&gt; to use a different keystore. Don&amp;rsquo;t forget to specify the same keystore when signing the APK.</source>
          <target state="translated">선택적으로 &lt;code&gt;--keystore&lt;/code&gt; 를 지정 하여 다른 키 저장소를 사용할 수 있습니다 . APK에 서명 할 때 동일한 키 저장소를 지정하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e6706c19aec47d4686c9813cdbd6ac4ed3a000bb" translate="yes" xml:space="preserve">
          <source>Optionally: Create an Android Virtual Device to run apps on an emulator</source>
          <target state="translated">선택적으로 : 에뮬레이터에서 앱을 실행하는 Android 가상 장치 생성</target>
        </trans-unit>
        <trans-unit id="5364fd6be6783cb880d7c0a1a5a2295f6323d8f4" translate="yes" xml:space="preserve">
          <source>Optionally: Creating an Android Virtual Device (AVD) to run apps on an emulator</source>
          <target state="translated">선택적으로 : 에뮬레이터에서 앱을 실행하기위한 Android 가상 장치 (AVD) 생성</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="3f8bdb1a6725318bd675ab83c4c58b43596fef29" translate="yes" xml:space="preserve">
          <source>Options passed on to &lt;a href=&quot;#http_call&quot;&gt;&lt;code&gt;HTTP.call&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵션이 &lt;a href=&quot;#http_call&quot;&gt; &lt;code&gt;HTTP.call&lt;/code&gt; &lt;/a&gt; 에 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="296f90d0078ca72b5d7373a674a7f47df0948861" translate="yes" xml:space="preserve">
          <source>Options to customize emails sent from the Accounts system.</source>
          <target state="translated">계정 시스템에서 전송 된 이메일을 사용자 정의하는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="198374d30341e432a4012d344f967bf53449e96f" translate="yes" xml:space="preserve">
          <source>Or you can wait for a session variable to have a certain value, and do something the first time it does, calling &lt;code&gt;stop&lt;/code&gt; on the computation to prevent further rerunning:</source>
          <target state="translated">또는 세션 변수가 특정 값을 가질 때까지 기다렸다가 처음에 무언가를 수행하여 추가 재실행을 방지하기 위해 계산에서 &lt;code&gt;stop&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b895a822fda3ad31b9fc8dd367ab3a20f6e47e5" translate="yes" xml:space="preserve">
          <source>Organizing publications</source>
          <target state="translated">출판물 정리</target>
        </trans-unit>
        <trans-unit id="639034643937477923c42c76a4bd0f53194aeaa0" translate="yes" xml:space="preserve">
          <source>Original &lt;a href=&quot;https://github.com/arunoda/meteor-up&quot;&gt;Meteor Up&lt;/a&gt; (not generally recommended any longer)</source>
          <target state="translated">Original &lt;a href=&quot;https://github.com/arunoda/meteor-up&quot;&gt;Meteor Up&lt;/a&gt; (일반적으로 더 이상 권장되지 않음)</target>
        </trans-unit>
        <trans-unit id="5df772b1313681645dfd60212b4ec8ee6fb9b4b1" translate="yes" xml:space="preserve">
          <source>Other DOM events are available as well, but for the events above, Meteor has taken some care to ensure that they work uniformly in all browsers.</source>
          <target state="translated">다른 DOM 이벤트도 사용할 수 있지만 위의 이벤트에서 Meteor는 모든 브라우저에서 균일하게 작동하도록주의를 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="67ea52f1a7ae74f014909d25b0bddf410e9fbbb3" translate="yes" xml:space="preserve">
          <source>Other considerations</source>
          <target state="translated">다른 고려 사항</target>
        </trans-unit>
        <trans-unit id="a3634dabd3bfa7d228620cba5159e1dbf8a66c93" translate="yes" xml:space="preserve">
          <source>Other deployments &lt;em&gt;may&lt;/em&gt; have control panel options or may need to be manually configured on the the proxy server (e.g. HAProxy, nginx, etc.). The articles linked above provide some assistance on this.</source>
          <target state="translated">기타 배포 &lt;em&gt;할 수있다&lt;/em&gt; 제어판 옵션을 사용할 수 있습니다 또는 수동으로 (예를 들어, HAProxy,의 nginx 등)에 프록시 서버를 구성해야합니다. 위에 링크 된 기사는 이에 대한 도움을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1b37a5b9b8e1acc3fca24b207aed275166d10ade" translate="yes" xml:space="preserve">
          <source>Other developers will also need to run the &lt;code&gt;npm link&lt;/code&gt; command.</source>
          <target state="translated">다른 개발자들도 &lt;code&gt;npm link&lt;/code&gt; 명령 을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="164e07c655074e1b2ae5980c4f633a5d76cf5e09" translate="yes" xml:space="preserve">
          <source>Other options for React</source>
          <target state="translated">반응에 대한 다른 옵션</target>
        </trans-unit>
        <trans-unit id="70635cabe306913f063e2fcd7298d84a798bcc05" translate="yes" xml:space="preserve">
          <source>Our main server entry point &lt;code&gt;server/main.js&lt;/code&gt; then imports this startup module. You can see that here we don&amp;rsquo;t actually import any variables from these files - we just import them so that they execute in this order.</source>
          <target state="translated">그런 다음 기본 서버 진입 점 &lt;code&gt;server/main.js&lt;/code&gt; 가이 시작 모듈을 가져옵니다. 여기서 우리는 실제로 이러한 파일에서 변수를 가져 오지 않는다는 것을 알 수 있습니다. 우리는 변수를 가져 와서 순서대로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="37b702ca6bad6eaff621f2553351bebfbf853710" translate="yes" xml:space="preserve">
          <source>Our reusable components were a natural fit for a unit test; similarly our smart components tend to require an integration test to really be exercised properly, as the job of a smart component is to bring data together and supply it to a reusable component.</source>
          <target state="translated">우리의 재사용 가능한 구성 요소는 단위 테스트에 자연스럽게 적합했습니다. 마찬가지로 스마트 구성 요소의 역할은 데이터를 함께 가져 와서 재사용 가능한 구성 요소에 제공하는 것이므로 스마트 구성 요소가 실제로 제대로 작동하려면 통합 테스트가 필요한 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="87ae6abb901f61c0109d4a4133ce7187ec9ab693" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;allow&lt;/code&gt; rules.</source>
          <target state="translated">&lt;code&gt;allow&lt;/code&gt; 규칙을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="fce211bc2d7c6f0b086778b048b5ae2383dee5f6" translate="yes" xml:space="preserve">
          <source>Override the default ROOT_URL from the server environment. For example: &quot;&lt;code&gt;http://foo.example.com&lt;/code&gt;&quot;</source>
          <target state="translated">서버 환경에서 기본 ROOT_URL을 대체하십시오. 예 : &quot; &lt;code&gt;http://foo.example.com&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="d4d7fd77ff2c8adb1ca651c2a32212de473f3a13" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;transform&lt;/code&gt; on the &lt;a href=&quot;#collections&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; for this cursor. Pass &lt;code&gt;null&lt;/code&gt; to disable transformation.</source>
          <target state="translated">이 커서 에 대한 &lt;a href=&quot;#collections&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;transform&lt;/code&gt; 을 재정의합니다 . 패스 &lt;code&gt;null&lt;/code&gt; 해제 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00758d523153346459585439cafa8a44ae7e9c5" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;transform&lt;/code&gt; on the &lt;a href=&quot;#collections&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt;. Pass &lt;code&gt;null&lt;/code&gt; to disable transformation.</source>
          <target state="translated">&lt;a href=&quot;#collections&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;transform&lt;/code&gt; 을 재정의 합니다 . 패스 &lt;code&gt;null&lt;/code&gt; 해제 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de89f3f877451fb0093f6e83b2ed4cf84c19913a" translate="yes" xml:space="preserve">
          <source>Overriding packages with a local version</source>
          <target state="translated">로컬 버전으로 패키지 재정의</target>
        </trans-unit>
        <trans-unit id="a52e338d221104d419ade7367598cf8aeedb21c6" translate="yes" xml:space="preserve">
          <source>Overriding published packages with a local version</source>
          <target state="translated">로컬 버전으로 게시 된 패키지 재정의</target>
        </trans-unit>
        <trans-unit id="70fdee66e5d3c3ea7620b52d6faeac128a5a13ed" translate="yes" xml:space="preserve">
          <source>Own server</source>
          <target state="translated">자신의 서버</target>
        </trans-unit>
        <trans-unit id="124a65c4b69218e19c3c3a7964d9775dc6b18e3d" translate="yes" xml:space="preserve">
          <source>PORT</source>
          <target state="translated">PORT</target>
        </trans-unit>
        <trans-unit id="b3f9e003d846ea5821f7feac5cede2f4649277b7" translate="yes" xml:space="preserve">
          <source>Package naming</source>
          <target state="translated">패키지 이름</target>
        </trans-unit>
        <trans-unit id="992d908f46a352a8ea2d55fd17eac4884a01442d" translate="yes" xml:space="preserve">
          <source>Package source code in directories indicated by setting a &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; environment variable before running any &lt;code&gt;meteor&lt;/code&gt; command. You can add multiple directories by separating the paths with a &lt;code&gt;:&lt;/code&gt; on OSX or Linux, or a &lt;code&gt;;&lt;/code&gt; on Windows. For example: &lt;code&gt;METEOR_PACKAGE_DIRS=../first/directory:../second/directory&lt;/code&gt;, or on Windows: &lt;code&gt;set PACKAGE_DIRS=..\first\directory;..\second\directory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;meteor&lt;/code&gt; 명령을 실행하기 전에 &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; 환경 변수를 설정하여 표시된 디렉토리의 패키지 소스 코드 . 당신은 함께 경로를 분리하여 여러 디렉토리를 추가 할 수 있습니다 &lt;code&gt;:&lt;/code&gt; OSX 나 리눅스, 또는에를 &lt;code&gt;;&lt;/code&gt; Windows에서. 예를 들면 다음과 같습니다 &lt;code&gt;METEOR_PACKAGE_DIRS=../first/directory:../second/directory&lt;/code&gt; , 또는 Windows : &lt;code&gt;set PACKAGE_DIRS=..\first\directory;..\second\directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff4ded7d2d80dbbe9dba28169810d901d192738a" translate="yes" xml:space="preserve">
          <source>Package source code in the &lt;code&gt;packages/&lt;/code&gt; directory inside your app.</source>
          <target state="translated">앱 내부 의 &lt;code&gt;packages/&lt;/code&gt; 디렉토리 에있는 패키지 소스 코드</target>
        </trans-unit>
        <trans-unit id="38dcedf5b8b3e820deb4726844567d15bda96f48" translate="yes" xml:space="preserve">
          <source>Package this project up for deployment. The output is a directory with several build artifacts:</source>
          <target state="translated">배포 할 수 있도록이 프로젝트를 패키지하십시오. 출력은 여러 빌드 아티팩트가있는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="a0fefd67a387acb4b67fc7ba1d449b65c7ef1ac4" translate="yes" xml:space="preserve">
          <source>Package-scope variables declared in &lt;code&gt;.js&lt;/code&gt; files are visible in any &lt;code&gt;.coffee&lt;/code&gt; files in the same app or project.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일에 선언 된 패키지 범위 변수는 동일한 앱 또는 프로젝트의 모든 &lt;code&gt;.coffee&lt;/code&gt; 파일에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80bde04107a079b0607142294524a55d82fd02b5" translate="yes" xml:space="preserve">
          <source>Package.describe()</source>
          <target state="translated">Package.describe()</target>
        </trans-unit>
        <trans-unit id="40d3196613f4d36bcf4702009d05dca099daef2c" translate="yes" xml:space="preserve">
          <source>Package.js</source>
          <target state="translated">Package.js</target>
        </trans-unit>
        <trans-unit id="46b4924e5f7b4c743a8b72a4bb853eded12359d2" translate="yes" xml:space="preserve">
          <source>Package.onTest()</source>
          <target state="translated">Package.onTest()</target>
        </trans-unit>
        <trans-unit id="81a69db763dd8a26b5ad050f5c8512ef444d4068" translate="yes" xml:space="preserve">
          <source>Package.onUse()</source>
          <target state="translated">Package.onUse()</target>
        </trans-unit>
        <trans-unit id="6478fd5c20ceaba1753c1e0c0afe60eb2307fafc" translate="yes" xml:space="preserve">
          <source>Package.registerBuildPlugin()</source>
          <target state="translated">Package.registerBuildPlugin()</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="3559066107681241b25756133ad42bd620942809" translate="yes" xml:space="preserve">
          <source>Packages being depended on. Package names may be suffixed with an @version tag.</source>
          <target state="translated">의존하는 패키지. 패키지 이름에는 @version 태그가 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d183b52b19943da11c4170d725cf78bbea93f62" translate="yes" xml:space="preserve">
          <source>Packages can also specify a &lt;em&gt;lazy&lt;/em&gt; main module:</source>
          <target state="translated">패키지는 또한 &lt;em&gt;게으른&lt;/em&gt; 메인 모듈을 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b6e8f00c5476d774092fd6a8ccc8664d08515763" translate="yes" xml:space="preserve">
          <source>Paginating subscriptions</source>
          <target state="translated">페이지 매김 구독</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="b69c4398784057ef536416738bdcae23d20b3bbd" translate="yes" xml:space="preserve">
          <source>Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.</source>
          <target state="translated">문자열을 EJSON 값으로 구문 분석하십시오. 문자열이 유효하지 않은 경우 오류가 발생합니다. EJSON</target>
        </trans-unit>
        <trans-unit id="08867752f8690d85f84a6d22987bd22c41a05fbe" translate="yes" xml:space="preserve">
          <source>Particularly useful to assert that arguments to a function have the right types and structure.</source>
          <target state="translated">함수에 대한 인수가 올바른 유형과 구조를 가지고 있다고 주장하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7891c2d0da86a3f1f310af54f03e3780c047c67a" translate="yes" xml:space="preserve">
          <source>Pass callbacks</source>
          <target state="translated">콜백 전달</target>
        </trans-unit>
        <trans-unit id="36442a8d8a3c36e2ebf4aab70c62b7f1ddde30b9" translate="yes" xml:space="preserve">
          <source>Pass data into helpers</source>
          <target state="translated">헬퍼에게 데이터 전달</target>
        </trans-unit>
        <trans-unit id="cc69b17cb479e5950ec98c31f0c519a94ea149b8" translate="yes" xml:space="preserve">
          <source>Pass that data into a sub-component.</source>
          <target state="translated">해당 데이터를 하위 구성 요소로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b8005a5cc62aef397b14d280f28e46b700ec684f" translate="yes" xml:space="preserve">
          <source>Passed to &lt;a href=&quot;https://docs.meteor.com/api/pubsub.html#Meteor-subscribe&quot;&gt;&lt;code&gt;Meteor.subscribe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.meteor.com/api/pubsub.html#Meteor-subscribe&quot;&gt; &lt;code&gt;Meteor.subscribe&lt;/code&gt; 로&lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d722643138fd0d0458a3ebed2b3bcd0d8f537e78" translate="yes" xml:space="preserve">
          <source>Passing HTML content as a template argument</source>
          <target state="translated">HTML 내용을 템플릿 인수로 전달</target>
        </trans-unit>
        <trans-unit id="157af5b91dc8ffc21bf2ad00775dc3df896e8e9f" translate="yes" xml:space="preserve">
          <source>Passing callbacks to a React component</source>
          <target state="translated">콜백을 React 컴포넌트로 전달</target>
        </trans-unit>
        <trans-unit id="4f68ed21fc56c7f5b451bd1d1d2f4f3db03f183a" translate="yes" xml:space="preserve">
          <source>Passing options</source>
          <target state="translated">전달 옵션</target>
        </trans-unit>
        <trans-unit id="3d3f2741fe36bd01f082ca434bfece2676c035e4" translate="yes" xml:space="preserve">
          <source>Password login</source>
          <target state="translated">비밀번호 로그인</target>
        </trans-unit>
        <trans-unit id="02c8304104610b987415dc656a1a2308b1ca7be0" translate="yes" xml:space="preserve">
          <source>Passwords</source>
          <target state="translated">Passwords</target>
        </trans-unit>
        <trans-unit id="2b55f9458e3b539989f93bf5de2466011102d449" translate="yes" xml:space="preserve">
          <source>Paste &lt;code&gt;ext install vscode-eslint&lt;/code&gt; in the command window and press &lt;code&gt;Enter&lt;/code&gt;</source>
          <target state="translated">명령 창에 &lt;code&gt;ext install vscode-eslint&lt;/code&gt; 를 붙여 넣고 &lt;code&gt;Enter&lt;/code&gt; 키 를 누릅니다</target>
        </trans-unit>
        <trans-unit id="96823d127a0a2757a51b79120bccf6794fd59de8" translate="yes" xml:space="preserve">
          <source>Path Evaluation</source>
          <target state="translated">경로 평가</target>
        </trans-unit>
        <trans-unit id="3288936e66f01aaff1d38efc36d523c466c42db3" translate="yes" xml:space="preserve">
          <source>Paths to the asset files.</source>
          <target state="translated">자산 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9baec68cbb2e5a72591c94aa0a227d154c229135" translate="yes" xml:space="preserve">
          <source>Paths to the source files.</source>
          <target state="translated">소스 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="232cf18164f45c3e223a7b945aa9a257060582e2" translate="yes" xml:space="preserve">
          <source>Patterns for building front end components in a performant way in Meteor.</source>
          <target state="translated">Meteor에서 프론트 엔드 구성 요소를 성능있는 방식으로 빌드하기위한 패턴.</target>
        </trans-unit>
        <trans-unit id="d804ab55cc86bf1b710df0bbe6aa6c5ac254ad4b" translate="yes" xml:space="preserve">
          <source>Patterns for data loading</source>
          <target state="translated">데이터 로딩을위한 패턴</target>
        </trans-unit>
        <trans-unit id="98de53a371d648152a678ae4f111b5738a9daa69" translate="yes" xml:space="preserve">
          <source>Peer npm dependencies</source>
          <target state="translated">피어 npm 종속성</target>
        </trans-unit>
        <trans-unit id="f02d80342fe6db607b38a6b0ddab4a497d829b81" translate="yes" xml:space="preserve">
          <source>Per the usual CoffeeScript convention, CoffeeScript variables are file-scoped by default (visible only in the &lt;code&gt;.coffee&lt;/code&gt; file where they are defined.)</source>
          <target state="translated">일반적인 CoffeeScript 규칙에 따라 CoffeeScript 변수는 기본적으로 파일 범위가 지정됩니다 ( 정의 된 &lt;code&gt;.coffee&lt;/code&gt; 파일 에서만 볼 수 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="590b9cacaaf73049eda1be3a16cce0ac36d396f2" translate="yes" xml:space="preserve">
          <source>Per-component loading state</source>
          <target state="translated">구성 요소 별 로딩 상태</target>
        </trans-unit>
        <trans-unit id="e7510d7974e57faa2d28ee023244b247ee02f995" translate="yes" xml:space="preserve">
          <source>Per-document permissions</source>
          <target state="translated">문서 별 권한</target>
        </trans-unit>
        <trans-unit id="2a88f3290f242252e3664464a4e41627ddef5894" translate="yes" xml:space="preserve">
          <source>Perform an outbound HTTP request.</source>
          <target state="translated">아웃 바운드 HTTP 요청을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="5bfe7b2a634812bc1553d4395081586562f43e90" translate="yes" xml:space="preserve">
          <source>Permits the use of &lt;a href=&quot;http://flowtype.org/&quot;&gt;Flow&lt;/a&gt; type annotations. These annotations are simply stripped from the code, so they have no effect on the code&amp;rsquo;s behavior, but you can run the &lt;code&gt;flow&lt;/code&gt; tool over your code to check the types if desired.</source>
          <target state="translated">&lt;a href=&quot;http://flowtype.org/&quot;&gt;플로우&lt;/a&gt; 유형 어노테이션 사용을 허용합니다 . 이러한 주석은 코드에서 간단히 제거되므로 코드의 동작에 영향을 미치지 않지만 원하는 경우 &lt;code&gt;flow&lt;/code&gt; 도구를 코드 위에 실행 하여 유형을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0f934580e35c80e3730498184ab70cc4e4b77d" translate="yes" xml:space="preserve">
          <source>Places to translate</source>
          <target state="translated">번역 할 장소</target>
        </trans-unit>
        <trans-unit id="a9e7f1e55e3a73081cc8e3b64ff6abda3bd53bfe" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;http://developer.android.com/sdk/installing/index.html?pkg=studio&quot;&gt;the Android Studio installation instructions&lt;/a&gt; for more details on the exact steps to follow.</source>
          <target state="translated">를 참조하십시오 &lt;a href=&quot;http://developer.android.com/sdk/installing/index.html?pkg=studio&quot;&gt;안드로이드 스튜디오 설치 지침을&lt;/a&gt; 따르지 정확한 단계에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="69bc4e390bac12339695ea46249ff6a8a9b6de8e" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;https://developer.android.com/sdk/installing/index.html?pkg=studio&quot;&gt;the Android Studio installation instructions&lt;/a&gt; for more details on the exact steps to follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6620c8bfa2ab84e1a169c0014399408aff658292" translate="yes" xml:space="preserve">
          <source>Plugin.registerSourceHandler()</source>
          <target state="translated">Plugin.registerSourceHandler()</target>
        </trans-unit>
        <trans-unit id="335abfa9c587852e79cfcc36d36e3e67d55e4219" translate="yes" xml:space="preserve">
          <source>Plugins are identified by a name, which is generally the same as their npm package name. The current convention is for plugin names to start with &lt;code&gt;cordova-plugin-&lt;/code&gt;, but not all third-party plugins adhere to this.</source>
          <target state="translated">플러그인은 이름으로 식별되며 일반적으로 npm 패키지 이름과 동일합니다. 현재 규칙은 플러그인 이름이 &lt;code&gt;cordova-plugin-&lt;/code&gt; 로 시작하는 것이지만 모든 타사 플러그인이이를 준수하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="86fbb32f1e8ef65605e5487472c87df7855842f5" translate="yes" xml:space="preserve">
          <source>Plugins are installed from &lt;a href=&quot;http://plugins.cordova.io/&quot;&gt;plugins.cordova.io&lt;/a&gt;, so the plugins and versions specified must exist there. Alternatively, the version can be replaced with a GitHub tarball URL as described in the &lt;a href=&quot;https://guide.meteor.com/mobile.html#cordova-plugins&quot;&gt;Cordova&lt;/a&gt; page of the Meteor wiki on GitHub.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;http://plugins.cordova.io/&quot;&gt;plugins.cordova.io&lt;/a&gt; 에서 설치 되므로 지정된 플러그인 및 버전이 존재해야합니다. 또는 GitHub 의 Meteor 위키 의 &lt;a href=&quot;https://guide.meteor.com/mobile.html#cordova-plugins&quot;&gt;Cordova&lt;/a&gt; 페이지에 설명 된대로 버전을 GitHub tarball URL로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="228a070d3b65ddcff5b58359e120b5be974221c3" translate="yes" xml:space="preserve">
          <source>Point 3. can usually be resolved by placing the hook in the &lt;em&gt;Method&lt;/em&gt; that calls the mutator, rather than the hook itself. Although this is an imperfect compromise (as we need to be careful if we ever add another Method that calls that mutator in the future), it is better than writing a bunch of code that is never actually called (which is guaranteed to not work!), or giving the impression that your hook is more general that it actually is.</source>
          <target state="translated">포인트 3은 일반적으로 후크 자체가 아니라 뮤 테이터를 호출하는 &lt;em&gt;메소드에&lt;/em&gt; 후크를 배치하여 해결할 수 있습니다 . 비록 이것이 불완전한 타협이지만 (미래에 해당 뮤 테이터를 호출하는 다른 메소드를 추가하는 경우 조심해야하므로) 실제로 호출되지 않은 코드를 작성하는 것보다 낫습니다 (작동하지 않는 것이 보장됩니다! ) 또는 후크가 실제보다 더 일반적이라는 인상을줍니다.</target>
        </trans-unit>
        <trans-unit id="c65de7239130b2221dc156af1c9b5fa8125b9bf3" translate="yes" xml:space="preserve">
          <source>Polyfills</source>
          <target state="translated">Polyfills</target>
        </trans-unit>
        <trans-unit id="34bc8e7aa201f66589b1ba0065873cfcd166e05f" translate="yes" xml:space="preserve">
          <source>Polyfills for the following &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;-related methods:</source>
          <target state="translated">다음 &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 관련 방법에 대한 폴리 필 :</target>
        </trans-unit>
        <trans-unit id="07755feac4fba33effd2d9d90f40e3faa73ea252" translate="yes" xml:space="preserve">
          <source>Polyfills for the following &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-function&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/a&gt;-related properties:</source>
          <target state="translated">다음 &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-function&quot;&gt; &lt;code&gt;Function&lt;/code&gt; &lt;/a&gt; 관련 속성에 대한 폴리 필 :</target>
        </trans-unit>
        <trans-unit id="58c7d8dbbfcc23cf7005b3d896385973b16c9c22" translate="yes" xml:space="preserve">
          <source>Polyfills for the following &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-object&quot;&gt;&lt;code&gt;Object&lt;/code&gt;&lt;/a&gt;-related methods:</source>
          <target state="translated">다음 &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-object&quot;&gt; &lt;code&gt;Object&lt;/code&gt; &lt;/a&gt; 관련 방법에 대한 폴리 필 :</target>
        </trans-unit>
        <trans-unit id="de56c0b4c6e6e868bb32a426e3de2b6687260ddc" translate="yes" xml:space="preserve">
          <source>Polyfills for the following &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;-related methods:</source>
          <target state="translated">다음 &lt;a href=&quot;https://github.com/zloirock/core-js#ecmascript-6-string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 관련 메소드에 대한 폴리 필 :</target>
        </trans-unit>
        <trans-unit id="9e7ba4d9e9da383d37b24f34e030a3b9d520ba8c" translate="yes" xml:space="preserve">
          <source>Popup versus redirect flow</source>
          <target state="translated">팝업 대 리디렉션 흐름</target>
        </trans-unit>
        <trans-unit id="b2ef221e3193ecc713338eb88d02a0cab9694e2a" translate="yes" xml:space="preserve">
          <source>Possible values:</source>
          <target state="translated">가능한 값 :</target>
        </trans-unit>
        <trans-unit id="f6ffee1f7d5964009b84b8169b1742ea48e1ff76" translate="yes" xml:space="preserve">
          <source>PostCSS and Autoprefixer</source>
          <target state="translated">PostCSS 및 자동 접두사</target>
        </trans-unit>
        <trans-unit id="8f5aa2ea35759e808ce8b0f3efaca68a7e8a756c" translate="yes" xml:space="preserve">
          <source>Pre-built package from Atmosphere. The package is cached in &lt;code&gt;~/.meteor/packages&lt;/code&gt; on Mac/Linux or &lt;code&gt;%LOCALAPPDATA%\.meteor\packages&lt;/code&gt; on Windows, and only loaded into your app as it is built.</source>
          <target state="translated">분위기에서 사전 빌드 된 패키지. 패키지는 Mac / Linux의 &lt;code&gt;~/.meteor/packages&lt;/code&gt; 또는 Windows의 &lt;code&gt;%LOCALAPPDATA%\.meteor\packages&lt;/code&gt; 에 캐시되며 빌드 된 앱에만로드됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef61c9b31cf9ea723f28d7ca56b472545610744" translate="yes" xml:space="preserve">
          <source>Pre-built templates for &lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md#available-versions&quot;&gt;Bootstrap, Semantic UI, Materialize, and more&lt;/a&gt;. These templates don&amp;rsquo;t come with the actual CSS framework, so you can pick your favorite Bootstrap package, for example.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md#available-versions&quot;&gt;부트 스트랩, 시맨틱 UI, Materialise 등을&lt;/a&gt; 위한 사전 빌드 템플릿 . 이러한 템플릿은 실제 CSS 프레임 워크와 함께 제공되지 않으므로 선호하는 부트 스트랩 패키지를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c433f05ddcb133d3d51b09313cede630ce86da8e" translate="yes" xml:space="preserve">
          <source>Prefer &lt;code&gt;{{#each .. in}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{{#each .. in}}&lt;/code&gt; 선호</target>
        </trans-unit>
        <trans-unit id="9dfd349ebee555eb8d652be20dad971cae439eca" translate="yes" xml:space="preserve">
          <source>Preferences</source>
          <target state="translated">Preferences</target>
        </trans-unit>
        <trans-unit id="0e98bb6276bc127f65da256ec5b9c547611366a7" translate="yes" xml:space="preserve">
          <source>Prevent all additional event handlers from being run on this event, including other handlers in this event map, handlers reached by bubbling, and handlers in other event maps.</source>
          <target state="translated">이 이벤트 맵의 다른 핸들러, 버블 링으로 도달 한 핸들러 및 다른 이벤트 맵의 핸들러를 포함하여이 이벤트에서 모든 추가 이벤트 핸들러가 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="faf8b6ecf533db929aead9c23c1f9f63c398027f" translate="yes" xml:space="preserve">
          <source>Prevent the event from propagating (bubbling) up to other elements. Other event handlers matching the same element are still fired, in this and other event maps.</source>
          <target state="translated">이벤트가 다른 요소로 전파 (버블 링)되지 않도록합니다. 이 요소와 다른 이벤트 맵에서 동일한 요소와 일치하는 다른 이벤트 핸들러는 여전히 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="83f18522da7a41cf571abe704c5847d66c561af4" translate="yes" xml:space="preserve">
          <source>Preventing re-renders</source>
          <target state="translated">다시 렌더링 방지</target>
        </trans-unit>
        <trans-unit id="c93ae87b516695a9e5a6eb0423c6d99e44056720" translate="yes" xml:space="preserve">
          <source>Prevents the action the browser would normally take in response to this event, such as following a link or submitting a form. Further handlers are still called, but cannot reverse the effect.</source>
          <target state="translated">링크를 따르거나 양식을 제출하는 등 브라우저가이 이벤트에 응답하여 일반적으로 취하는 조치를 방지합니다. 추가 핸들러는 여전히 호출되지만 효과를 되돌릴 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f54ff853ebbb4676d89beaa9d06a21eb19aff79d" translate="yes" xml:space="preserve">
          <source>Prevents this computation from rerunning.</source>
          <target state="translated">이 계산이 다시 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="883267ed51228e6612dfdea9fdcd4c4f6b23711e" translate="yes" xml:space="preserve">
          <source>Previously, Meteor would automatically assume that any &lt;code&gt;MAIL_URL&lt;/code&gt; using port 465 was to be encrypted and automatically changed &lt;code&gt;smtp://&lt;/code&gt; to &lt;code&gt;smtps://&lt;/code&gt;. However, this is not always desired, and not always a safe assumption for Meteor.</source>
          <target state="translated">이전에는 Meteor는 포트 465를 사용 하는 모든 &lt;code&gt;MAIL_URL&lt;/code&gt; 이 암호화되고 자동으로 &lt;code&gt;smtp://&lt;/code&gt; 를 &lt;code&gt;smtps://&lt;/code&gt; 로 변경 했다고 가정했습니다 . 그러나 이것이 항상 바람직한 것은 아니며 항상 Meteor에 대한 안전한 가정이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9d885f783900e6c78128ccb66893a263d295ba0f" translate="yes" xml:space="preserve">
          <source>Probably the most fundamental type of UI change that requires animation is when items appear or disappear. In Blaze, we can use the &lt;a href=&quot;https://atmospherejs.com/percolate/momentum&quot;&gt;&lt;code&gt;percolate:momentum&lt;/code&gt; package&lt;/a&gt; to plug a standard set of animations from the &lt;a href=&quot;http://julian.com/research/velocity/&quot;&gt;&lt;code&gt;velocity animation library&lt;/code&gt;&lt;/a&gt; into such state changes.</source>
          <target state="translated">아마도 애니메이션이 필요한 가장 기본적인 UI 변경 유형은 항목이 나타나거나 사라질 때입니다. Blaze에서는 &lt;a href=&quot;https://atmospherejs.com/percolate/momentum&quot;&gt; &lt;code&gt;percolate:momentum&lt;/code&gt; 패키지&lt;/a&gt; 를 사용 하여 &lt;a href=&quot;http://julian.com/research/velocity/&quot;&gt; &lt;code&gt;velocity animation library&lt;/code&gt; &lt;/a&gt; 의 표준 애니메이션 세트 를 이러한 상태 변경 에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23559a789f2928b712b9afdd123e384e78bd7406" translate="yes" xml:space="preserve">
          <source>Process all reactive updates immediately and ensure that all invalidated computations are rerun.</source>
          <target state="translated">모든 반응성 업데이트를 즉시 처리하고 무효화 된 모든 계산이 다시 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="2de846e277b8bd927a270771b3af25c725c98b4a" translate="yes" xml:space="preserve">
          <source>Property Name</source>
          <target state="translated">부동산 이름</target>
        </trans-unit>
        <trans-unit id="1e685dbb842b631f007fd297b7933ec922f28e1c" translate="yes" xml:space="preserve">
          <source>Provide additional parameters to the authentication URI. Currently only supported with Google. See &lt;a href=&quot;https://developers.google.com/identity/protocols/OpenIDConnect#authenticationuriparameters&quot;&gt;Google Identity Platform documentation&lt;/a&gt;.</source>
          <target state="translated">인증 URI에 추가 매개 변수를 제공하십시오. 현재 Google에서만 지원됩니다. &lt;a href=&quot;https://developers.google.com/identity/protocols/OpenIDConnect#authenticationuriparameters&quot;&gt;Google Identity Platform 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86f6211035ce87a4dd69dcd91d66589fe045fe00" translate="yes" xml:space="preserve">
          <source>Provide basic package information with &lt;code&gt;Package.describe(options)&lt;/code&gt;. To publish a package, you must define &lt;code&gt;summary&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Package.describe(options)&lt;/code&gt; 기본 패키지 정보를 제공하십시오 . 패키지를 게시하려면 &lt;code&gt;summary&lt;/code&gt; 및 &lt;code&gt;version&lt;/code&gt; 을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5719954a5742f2f63e294accbcce7945375bf98" translate="yes" xml:space="preserve">
          <source>Provide basic package information.</source>
          <target state="translated">기본 패키지 정보를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b71bcd75aa59c4d7b3709bf728682072e335ae50" translate="yes" xml:space="preserve">
          <source>Provides a shorthand for function expressions. For example, &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x + 1)&lt;/code&gt; evaluates to &lt;code&gt;[2, 3, 4]&lt;/code&gt;. If &lt;code&gt;this&lt;/code&gt; is used in the body of the arrow function, it will be automatically bound to the value of &lt;code&gt;this&lt;/code&gt; in the enclosing scope.</source>
          <target state="translated">함수 표현식의 약어를 제공합니다. 예를 들어 &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x + 1)&lt;/code&gt; 은 &lt;code&gt;[2, 3, 4]&lt;/code&gt; 평가됩니다 . 하면 &lt;code&gt;this&lt;/code&gt; 화살표 함수 본문에서 사용되는, 자동의 값으로 결합한다 &lt;code&gt;this&lt;/code&gt; 클로징 범위이다.</target>
        </trans-unit>
        <trans-unit id="9e50c06617663f961c6d0d4fb3cea248fbbbdf53" translate="yes" xml:space="preserve">
          <source>Provides an easy way to iterate over the elements of a collection:</source>
          <target state="translated">컬렉션의 요소를 쉽게 반복 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d69cc6df12ee1e81bdf2f06b4195121fe9873d3b" translate="yes" xml:space="preserve">
          <source>Publication behavior when arguments change</source>
          <target state="translated">인수가 변경 될 때 게시 동작</target>
        </trans-unit>
        <trans-unit id="0855684c1444ece44c79b3612a7f4cfac9ae6e2a" translate="yes" xml:space="preserve">
          <source>Publications</source>
          <target state="translated">Publications</target>
        </trans-unit>
        <trans-unit id="1f1c22386ac3b78a59d85c050f8295515b9ddb38" translate="yes" xml:space="preserve">
          <source>Publications and Data Loading</source>
          <target state="translated">출판물 및 데이터 로딩</target>
        </trans-unit>
        <trans-unit id="7e546e644f955582ccca26ae2ed17b1ee720db7b" translate="yes" xml:space="preserve">
          <source>Publications and subscriptions</source>
          <target state="translated">간행물 및 구독</target>
        </trans-unit>
        <trans-unit id="616838de7576d6bafe8c82d1dfffa07bf76660ed" translate="yes" xml:space="preserve">
          <source>Publications and subscriptions are the primary way of dealing with data in Meteor&amp;rsquo;s DDP protocol, but lots of data sources use the popular REST protocol for their API. It&amp;rsquo;s useful to be able to convert between the two.</source>
          <target state="translated">발행물 및 구독은 Meteor의 DDP 프로토콜에서 데이터를 처리하는 기본 방법이지만 많은 데이터 소스가 API에 널리 사용되는 REST 프로토콜을 사용합니다. 둘 사이를 변환하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="44953c8c16399990df12c0e6808a11d0ef886924" translate="yes" xml:space="preserve">
          <source>Publications and userId</source>
          <target state="translated">간행물 및 userId</target>
        </trans-unit>
        <trans-unit id="87c0348b446f1563f9b6f94095d33c09573cdbf7" translate="yes" xml:space="preserve">
          <source>Publications are not reactive, and they only re-run when the currently logged in &lt;code&gt;userId&lt;/code&gt; changes, which can be accessed through &lt;code&gt;this.userId&lt;/code&gt;. Because of this, it&amp;rsquo;s easy to accidentally write a publication that is secure when it first runs, but doesn&amp;rsquo;t respond to changes in the app environment. Let&amp;rsquo;s look at an example:</source>
          <target state="translated">게시는 반응 형이 아니며 현재 로그인 한 &lt;code&gt;userId&lt;/code&gt; 가 변경 될 때만 다시 실행되며 , 이는 &lt;code&gt;this.userId&lt;/code&gt; 를 통해 액세스 할 수 있습니다 . 이로 인해 처음 실행될 때 안전하지만 앱 환경의 변경에 응답하지 않는 게시를 실수로 쉽게 작성할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="1da23a61b8eb53858580daf8d166a724341d993a" translate="yes" xml:space="preserve">
          <source>Publications are not the only place the client gets data from the server. The set of source code files and static assets that are served by your application server could also potentially contain sensitive data:</source>
          <target state="translated">클라이언트가 서버에서 데이터를 얻는 유일한 장소는 출판물이 아닙니다. 애플리케이션 서버가 제공하는 소스 코드 파일 및 정적 자산 세트는 잠재적으로 중요한 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1158921c3af55d6ea4b5c57c99d9d4837b8606d6" translate="yes" xml:space="preserve">
          <source>Publications are the primary way a Meteor server can make data available to a client. While with Methods the primary concern was making sure users can&amp;rsquo;t modify the database in unexpected ways, with publications the main issue is filtering the data being returned so that a malicious user can&amp;rsquo;t get access to data they aren&amp;rsquo;t supposed to see.</source>
          <target state="translated">발행물은 Meteor 서버가 클라이언트가 데이터를 사용할 수있게하는 기본 방법입니다. Methods의 주요 관심사는 사용자가 예기치 않은 방식으로 데이터베이스를 수정할 수 없도록하는 것이었지만, 간행물을 통해 주요 문제는 반환되는 데이터를 필터링하여 악의적 인 사용자가 볼 수없는 데이터에 액세스 할 수 없도록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fe963bdf7fb16fbc6ecc5e0bdcdcb4f31fc3bc0a" translate="yes" xml:space="preserve">
          <source>Publish a record set.</source>
          <target state="translated">레코드 세트를 게시하십시오.</target>
        </trans-unit>
        <trans-unit id="0ecab94e8396634ea220582c8c290d482a5057ef" translate="yes" xml:space="preserve">
          <source>Publish and subscribe</source>
          <target state="translated">게시 및 구독</target>
        </trans-unit>
        <trans-unit id="8a7727674e3f1ce41f843f4991b95a53deb41f11" translate="yes" xml:space="preserve">
          <source>Publish functions can return a &lt;a href=&quot;#mongo_cursor&quot;&gt;&lt;code&gt;Collection.Cursor&lt;/code&gt;&lt;/a&gt;, in which case Meteor will publish that cursor&amp;rsquo;s documents to each subscribed client. You can also return an array of &lt;code&gt;Collection.Cursor&lt;/code&gt;s, in which case Meteor will publish all of the cursors.</source>
          <target state="translated">게시 함수는 &lt;a href=&quot;#mongo_cursor&quot;&gt; &lt;code&gt;Collection.Cursor&lt;/code&gt; &lt;/a&gt; 를 반환 할 수 있으며 ,이 경우 Meteor는 해당 커서의 문서를 구독 한 각 클라이언트에 게시합니다. &lt;code&gt;Collection.Cursor&lt;/code&gt; 배열을 반환 할 수도 있습니다 .이 경우 Meteor는 모든 커서를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="d7d6e9da660fdddc77ee12d9b9b9e4c85445d654" translate="yes" xml:space="preserve">
          <source>Publishes a build of an existing package version from a different architecture.</source>
          <target state="translated">다른 아키텍처에서 기존 패키지 버전의 빌드를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="2c21a1f6e7f7e1fb7e8ac96e291eb5de4f5f147f" translate="yes" xml:space="preserve">
          <source>Publishes a release of Meteor. Takes in a JSON configuration file.</source>
          <target state="translated">Meteor 릴리스를 게시합니다. JSON 구성 파일을받습니다.</target>
        </trans-unit>
        <trans-unit id="aad9c0a458a08cfd4f5e8f1d16e0ad848af395b7" translate="yes" xml:space="preserve">
          <source>Publishes your package. To publish, you must &lt;code&gt;cd&lt;/code&gt; into the package directory, log in with your Meteor Developer Account and run &lt;code&gt;meteor publish&lt;/code&gt;. By convention, published package names must begin with the maintainer&amp;rsquo;s Meteor Developer Account username and a colon, like so: &lt;code&gt;iron:router&lt;/code&gt;.</source>
          <target state="translated">패키지를 게시합니다. 게시하려면 패키지 디렉토리에 &lt;code&gt;cd&lt;/code&gt; 하고 Meteor 개발자 계정으로 로그인 한 후 &lt;code&gt;meteor publish&lt;/code&gt; 를 실행 해야 합니다. 일반적으로 게시 된 패키지 이름은 관리자의 Meteor 개발자 계정 사용자 이름과 콜론으로 시작해야합니다 (예 : &lt;code&gt;iron:router&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d1ae649c77fbe74454ae984c4567ee92eaf7e62a" translate="yes" xml:space="preserve">
          <source>Publishing custom data</source>
          <target state="translated">사용자 정의 데이터 공개</target>
        </trans-unit>
        <trans-unit id="cf072ddc78088bd17cc6fbb56f69b9c147eed725" translate="yes" xml:space="preserve">
          <source>Publishing relational data</source>
          <target state="translated">관계형 데이터 공개</target>
        </trans-unit>
        <trans-unit id="ec5a5c4535a32a0f51364b08a7b62982d5da8cd1" translate="yes" xml:space="preserve">
          <source>Publishing your package</source>
          <target state="translated">패키지 게시</target>
        </trans-unit>
        <trans-unit id="8cf28850d801a770993108c5c98eaf31759d0270" translate="yes" xml:space="preserve">
          <source>QA the application on the staging server.</source>
          <target state="translated">스테이징 서버에서 애플리케이션을 QA하십시오.</target>
        </trans-unit>
        <trans-unit id="70fce46ec46c599814c13e8d42f1d5b7a21134b6" translate="yes" xml:space="preserve">
          <source>Queries can specify a particular set of fields to include or exclude from the result object.</source>
          <target state="translated">쿼리는 결과 개체에서 포함하거나 제외 할 특정 필드 집합을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb02e04d4ffb26f0e1039c0ef20570656f8f128" translate="yes" xml:space="preserve">
          <source>Query string to go in the URL. Overwrites any query string in &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">URL에 들어갈 쿼리 문자열입니다. &lt;code&gt;url&lt;/code&gt; 의 모든 쿼리 문자열을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b342f020314b26a7fba16949f44e287503b5ee8f" translate="yes" xml:space="preserve">
          <source>Quick start</source>
          <target state="translated">빠른 시작</target>
        </trans-unit>
        <trans-unit id="970323b6af000949a28f21a657b8fb9c7c025e01" translate="yes" xml:space="preserve">
          <source>ROOT_URL</source>
          <target state="translated">ROOT_URL</target>
        </trans-unit>
        <trans-unit id="c5a205ec66ee47186f2a312c8c46890626de2077" translate="yes" xml:space="preserve">
          <source>Random.choice</source>
          <target state="translated">Random.choice</target>
        </trans-unit>
        <trans-unit id="65c230ed7fe6f7a31a8f0f91fd95d6a948ad893b" translate="yes" xml:space="preserve">
          <source>Random.fraction</source>
          <target state="translated">Random.fraction</target>
        </trans-unit>
        <trans-unit id="27fc9bd71a4531953e5ed0a544bd5ac559a9ebdf" translate="yes" xml:space="preserve">
          <source>Random.hexString</source>
          <target state="translated">Random.hexString</target>
        </trans-unit>
        <trans-unit id="3fc8d6ef3c559f953730d5982bf468051bebc6cd" translate="yes" xml:space="preserve">
          <source>Random.id</source>
          <target state="translated">Random.id</target>
        </trans-unit>
        <trans-unit id="82444551ce40ed8d6ca4dccf672ab6cf6a199dac" translate="yes" xml:space="preserve">
          <source>Random.secret</source>
          <target state="translated">Random.secret</target>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="translated">속도 제한</target>
        </trans-unit>
        <trans-unit id="e663f74edb9d15a14c0184e9940248e5e0ce4a56" translate="yes" xml:space="preserve">
          <source>Rate limiting</source>
          <target state="translated">속도 제한</target>
        </trans-unit>
        <trans-unit id="b7589558b832752969324a2eca6730f29c3b81cd" translate="yes" xml:space="preserve">
          <source>Rather than accessing data in helpers via &lt;code&gt;this&lt;/code&gt;, it&amp;rsquo;s better to pass the arguments in directly from the template. So our &lt;code&gt;checkedClass&lt;/code&gt; helper takes the &lt;code&gt;todo&lt;/code&gt; as an argument and inspects it directly, rather than implicitly using &lt;code&gt;this.todo&lt;/code&gt;. We do this for similar reasons to why we always pass arguments to template inclusions, and because &amp;ldquo;template variables&amp;rdquo; (such as the iteratee of the &lt;code&gt;{{#each .. in}}&lt;/code&gt; helper) are not available on &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 를 통해 도우미의 데이터에 액세스하는 대신 템플릿에서 직접 인수를 전달하는 것이 좋습니다. 따라서 &lt;code&gt;checkedClass&lt;/code&gt; 헬퍼는 &lt;code&gt;todo&lt;/code&gt; 을 인수로 &lt;code&gt;this.todo&lt;/code&gt; 암시 적으로 this.todo 사용하지 않고 직접 검사합니다 . 우리는 항상 템플릿 포함에 인수를 전달하는 이유와 유사한 이유로 &quot;템플릿 변수&quot;(예 : &lt;code&gt;{{#each .. in}}&lt;/code&gt; 도우미의 반복자 )를 사용할 수 없기 &lt;code&gt;this&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="573337c1079c60c541c96b8dc447bb8f314bb4d9" translate="yes" xml:space="preserve">
          <source>Rather than dealing with the specifics of this field, it can be helpful to just ignore its existence entirely. You can safely do that as long as you deny all writes from the client:</source>
          <target state="translated">이 분야의 세부 사항을 다루기보다는 그 존재를 완전히 무시하는 것이 도움이 될 수 있습니다. 클라이언트의 모든 쓰기를 거부하는 한 안전하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3375581da7c02fdd84432ad6135794c4116cb6da" translate="yes" xml:space="preserve">
          <source>Re-rendering</source>
          <target state="translated">Re-rendering</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="49c1cb79114912416ad2b3bd24b66eabadd2acd4" translate="yes" xml:space="preserve">
          <source>React Components in Blaze</source>
          <target state="translated">Blaze에서 반응 성분</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">반응 라우터</target>
        </trans-unit>
        <trans-unit id="6e5b7376e594b7899814b8447d6979037e782702" translate="yes" xml:space="preserve">
          <source>React Router embraces React-specific functionality like the use of &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;context&lt;/a&gt;, although you can also explicitly pass your FlowRouter instance around in context if you&amp;rsquo;d like (in fact this is probably the best thing to do).</source>
          <target state="translated">React Router는 &lt;a href=&quot;https://facebook.github.io/react/docs/context.html&quot;&gt;context&lt;/a&gt; 사용과 같은 React 특정 기능을 수용 하지만 원하는 경우 컨텍스트에서 FlowRouter 인스턴스를 명시 적으로 전달할 수도 있습니다 (사실 이것이 최선의 방법 일 것입니다).</target>
        </trans-unit>
        <trans-unit id="7d607092da7544267a7a387340cf2521827e93ca" translate="yes" xml:space="preserve">
          <source>React Router encourages you to couple your URL design and layout hierarchy in the route definition. Flow Router is more flexible, although it can involve much more boilerplate as a result.</source>
          <target state="translated">React Router는 라우트 정의에서 URL 디자인과 레이아웃 계층을 결합하도록 권장합니다. Flow Router는 더 유연하지만 결과적으로 훨씬 많은 상용구를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8e9031349410a44129beb2570274771652ace2" translate="yes" xml:space="preserve">
          <source>React and Angular enforce a better component structure, which makes developing larger apps easier. (Although you can add component structure to Blaze by &lt;a href=&quot;http://blazejs.org/guide/reusable-components.html&quot;&gt;following conventions&lt;/a&gt; or using the &lt;a href=&quot;http://components.meteorapp.com/&quot;&gt;Blaze Components&lt;/a&gt; or &lt;a href=&quot;https://viewmodel.org/&quot;&gt;ViewModel&lt;/a&gt; packages.)</source>
          <target state="translated">React와 Angular는 더 나은 구성 요소 구조를 적용하여 더 큰 앱을 쉽게 개발할 수 있습니다. 그러나 &lt;a href=&quot;http://blazejs.org/guide/reusable-components.html&quot;&gt;규칙&lt;/a&gt; 을 따르 거나 &lt;a href=&quot;http://components.meteorapp.com/&quot;&gt;Blaze 구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;https://viewmodel.org/&quot;&gt;ViewModel&lt;/a&gt; 패키지를 사용하여 Blaze에 구성 요소 구조를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00be0cc0e386d74ecb800b0b7256bb644a8571da" translate="yes" xml:space="preserve">
          <source>React components must be the only thing in the wrapper element. Due to a limitation of React (see facebook/react &lt;a href=&quot;https://github.com/facebook/react/issues/1970&quot;&gt;#1970&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/react/issues/2484&quot;&gt;#2484&lt;/a&gt;), a React component must be rendered as the only child of its parent node, meaning it cannot have any siblings.</source>
          <target state="translated">랩퍼 요소에는 리 액트 컴포넌트 만 있어야합니다. React의 제한으로 인해 (facebook / react &lt;a href=&quot;https://github.com/facebook/react/issues/1970&quot;&gt;# 1970&lt;/a&gt; , &lt;a href=&quot;https://github.com/facebook/react/issues/2484&quot;&gt;# 2484 참조&lt;/a&gt; ) React 컴포넌트는 상위 노드의 유일한 자식으로 렌더링되어야합니다. 즉, 형제를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e560460603038656fa1d4787e66b57875466247f" translate="yes" xml:space="preserve">
          <source>React has 42k stars on Github and 13k npm libraries.</source>
          <target state="translated">React는 Github 및 13k npm 라이브러리에 42k 개의 별이 있습니다.</target>
        </trans-unit>
        <trans-unit id="842ea8549385fb281357570ba515c722367cd388" translate="yes" xml:space="preserve">
          <source>React has a vibrant and growing ecosystem and is used widely in production in a variety of combinations with different frameworks.</source>
          <target state="translated">React는 활기차고 성장하는 생태계를 가지고 있으며 다양한 프레임 워크와 다양한 조합으로 프로덕션 환경에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ace93fb63cc0d2401fa8c866126498bfc5822265" translate="yes" xml:space="preserve">
          <source>React is a front-end rendering library and as such doesn&amp;rsquo;t concern itself with how data gets into and out of components. On the other hand, Meteor has strong opinions about data! Meteor operates in terms of &lt;a href=&quot;data-loading&quot;&gt;publications&lt;/a&gt; and &lt;a href=&quot;methods&quot;&gt;methods&lt;/a&gt;, used to subscribe to and modify the data in your application.</source>
          <target state="translated">React는 프론트 엔드 렌더링 라이브러리이므로 데이터가 구성 요소로 들어오고 나가는 방식과 관련이 없습니다. 반면, Meteor는 데이터에 대한 강력한 의견을 가지고 있습니다! Meteor는 응용 프로그램의 데이터를 구독하고 수정하는 데 사용되는 &lt;a href=&quot;data-loading&quot;&gt;출판물&lt;/a&gt; 및 &lt;a href=&quot;methods&quot;&gt;방법으로&lt;/a&gt; 운영됩니다 .</target>
        </trans-unit>
        <trans-unit id="2dd03e5a8480bd16de936ec04566d0a92275af08" translate="yes" xml:space="preserve">
          <source>React uses &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;, with which you write your HTML in JavaScript. While it doesn&amp;rsquo;t have the logic-view separation most libraries have, it also has the most flexibility. Template functions and event handlers are defined in the same file as the HTML part of the component, which usually makes it easier to understand how they are tied together.</source>
          <target state="translated">React는 JavaScript로 HTML을 작성하는 &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX를&lt;/a&gt; 사용합니다 . 대부분의 라이브러리에서 논리 뷰 분리 기능은 없지만 유연성도 가장 뛰어납니다. 템플릿 함수와 이벤트 처리기는 구성 요소의 HTML 부분과 동일한 파일에 정의되므로 일반적으로 서로 연결되는 방식을 쉽게 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2081c8b6e011d41b489cdba5c5210d3aee8fa611" translate="yes" xml:space="preserve">
          <source>ReactiveVar</source>
          <target state="translated">ReactiveVar</target>
        </trans-unit>
        <trans-unit id="8697a43862309b716782d78796f2102dbcf2397e" translate="yes" xml:space="preserve">
          <source>ReactiveVar()</source>
          <target state="translated">ReactiveVar()</target>
        </trans-unit>
        <trans-unit id="c1db1d64f2798b54cabab0f08a21fe75f49cd445" translate="yes" xml:space="preserve">
          <source>ReactiveVars are not automatically migrated across hot code pushes, whereas Session state is.</source>
          <target state="translated">ReactiveVar는 핫 코드 푸시를 통해 자동으로 마이그레이션되지 않지만 세션 상태는 자동으로 마이그레이션됩니다.</target>
        </trans-unit>
        <trans-unit id="df8032fe5a56ae94cce3f53b0d3f9bf2e5085c03" translate="yes" xml:space="preserve">
          <source>ReactiveVars can hold any value, while Session variables are limited to JSON or EJSON.</source>
          <target state="translated">ReactiveVar는 모든 값을 보유 할 수 있지만 세션 변수는 JSON 또는 EJSON으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="63b549c6f13b260a95aeae59802286b6eb3dac69" translate="yes" xml:space="preserve">
          <source>ReactiveVars don&amp;rsquo;t have global names, like the &amp;ldquo;foo&amp;rdquo; in &lt;code&gt;Session.get('foo')&lt;/code&gt;. Instead, they may be created and used locally, for example attached to a template instance, as in: &lt;code&gt;this.foo.get()&lt;/code&gt;.</source>
          <target state="translated">ReactiveVar는 &lt;code&gt;Session.get('foo')&lt;/code&gt; 의&amp;ldquo;foo&amp;rdquo;와 같은 전역 이름이 없습니다 . 대신, &lt;code&gt;this.foo.get()&lt;/code&gt; 과 같이 템플릿 인스턴스에 연결된 것과 같이 로컬에서 만들어서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09edc430ee465cd900e16ef710a79298da6a4c99" translate="yes" xml:space="preserve">
          <source>Reactively changing subscription arguments</source>
          <target state="translated">적극적으로 구독 인수 변경</target>
        </trans-unit>
        <trans-unit id="0c2e9a29a2b3becda37d55df31e770964ce58e84" translate="yes" xml:space="preserve">
          <source>Reactivity Model</source>
          <target state="translated">반응성 모델</target>
        </trans-unit>
        <trans-unit id="25d4d8b557171bf685d27eb70aa2a678497d5577" translate="yes" xml:space="preserve">
          <source>Reactivity Model for Each</source>
          <target state="translated">각각의 반응성 모델</target>
        </trans-unit>
        <trans-unit id="402182cbd1637abec9fe8435165c8a049bba7abb" translate="yes" xml:space="preserve">
          <source>Read about how to use Blaze and Spacebars in the Blaze article.</source>
          <target state="translated">Blaze 기사에서 Blaze 및 Spacebar를 사용하는 방법에 대해 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="71149d867186a5f2f5f8e067b366c8485ffeb50c" translate="yes" xml:space="preserve">
          <source>Read more about Blaze subscriptions in the &lt;a href=&quot;http://blazejs.org/api/templates.html#Blaze-TemplateInstance-subscribe&quot;&gt;Blaze article&lt;/a&gt;, and about tracking loading state inside UI components in the &lt;a href=&quot;ui-ux#subscription-readiness&quot;&gt;UI article&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://blazejs.org/api/templates.html#Blaze-TemplateInstance-subscribe&quot;&gt;Blaze 기사의&lt;/a&gt; Blaze 구독 및 &lt;a href=&quot;ui-ux#subscription-readiness&quot;&gt;UI 기사의&lt;/a&gt; UI 구성 요소 내에서로드 상태 추적 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="4b0019568f61881e296b5b633e27dad46cd5e8be" translate="yes" xml:space="preserve">
          <source>Read more about collections and how to use them in the &lt;a href=&quot;http://guide.meteor.com/collections.html&quot;&gt;Collections&lt;/a&gt; article in the Meteor Guide.</source>
          <target state="translated">Meteor Guide 의 &lt;a href=&quot;http://guide.meteor.com/collections.html&quot;&gt;Collections&lt;/a&gt; 기사에서 컬렉션과 사용 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="28041b3fd7b74372933d95f95d7bbf35797b461e" translate="yes" xml:space="preserve">
          <source>Read more about customizing user accounts in the &lt;a href=&quot;http://guide.meteor.com/accounts.html&quot;&gt;Accounts&lt;/a&gt; article in the Meteor Guide.</source>
          <target state="translated">Meteor 안내서 의 &lt;a href=&quot;http://guide.meteor.com/accounts.html&quot;&gt;계정&lt;/a&gt; 기사에서 사용자 계정 사용자 정의에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="88823fa3dc67965acb81c27d919ad7838ba60aac" translate="yes" xml:space="preserve">
          <source>Read more about domain patterns in &lt;a href=&quot;http://cordova.apache.org/docs/en/6.0.0/guide_appdev_whitelist_index.md.html&quot;&gt;Cordova docs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://cordova.apache.org/docs/en/6.0.0/guide_appdev_whitelist_index.md.html&quot;&gt;Cordova docs의&lt;/a&gt; 도메인 패턴에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="a92450db1fddf0be82933c7e0c7fe183b9a666db" translate="yes" xml:space="preserve">
          <source>Read more about domain patterns in &lt;a href=&quot;https://cordova.apache.org/docs/en/6.0.0/guide_appdev_whitelist_index.md.html&quot;&gt;Cordova docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a603d46e6808c855984c8bc19955f92373fdb87" translate="yes" xml:space="preserve">
          <source>Read more about managing keys and settings in the Deployment article.</source>
          <target state="translated">배포 기사에서 키 및 설정 관리에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="3292e698700557811666ba69379855299a42fbb1" translate="yes" xml:space="preserve">
          <source>Read more about methods and how to use them in the &lt;a href=&quot;http://guide.meteor.com/methods.html&quot;&gt;Methods&lt;/a&gt; article in the Meteor Guide.</source>
          <target state="translated">Meteor Guide 의 &lt;a href=&quot;http://guide.meteor.com/methods.html&quot;&gt;Methods&lt;/a&gt; 기사에서 방법 및 사용 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="c902f2f8fe71262c6666db8c4219fd4365b8930b" translate="yes" xml:space="preserve">
          <source>Read more about publications and how to use them in the &lt;a href=&quot;http://guide.meteor.com/data-loading.html&quot;&gt;Data Loading&lt;/a&gt; article in the Meteor Guide.</source>
          <target state="translated">Meteor 안내서 의 &lt;a href=&quot;http://guide.meteor.com/data-loading.html&quot;&gt;데이터로드&lt;/a&gt; 기사에서 발행물 및 사용 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="7827930c24e781b89efc57a127790c78417bd52b" translate="yes" xml:space="preserve">
          <source>Read more about templates and how to use them in the &lt;a href=&quot;spacebars&quot;&gt;Spacebars&lt;/a&gt; and &lt;a href=&quot;../guide/introduction&quot;&gt;Blaze&lt;/a&gt; article in the Guide.</source>
          <target state="translated">가이드 에있는 &lt;a href=&quot;spacebars&quot;&gt;스페이스 바&lt;/a&gt; 및 &lt;a href=&quot;../guide/introduction&quot;&gt;Blaze&lt;/a&gt; 기사에서 템플릿 및 사용 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2fbf991af4665cfc10aa8b85ee0ea5b2388e0e34" translate="yes" xml:space="preserve">
          <source>Read more about the error format in the &lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt;&lt;code&gt;mdg:validation-error&lt;/code&gt; docs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt; &lt;code&gt;mdg:validation-error&lt;/code&gt; docs&lt;/a&gt; 에서 오류 형식에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2ede26eeb61932173032ed2aaa87e5c3e8a58ef4" translate="yes" xml:space="preserve">
          <source>Read more about using Cordova in the &lt;a href=&quot;mobile&quot;&gt;mobile guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mobile&quot;&gt;모바일 가이드&lt;/a&gt; 에서 Cordova 사용에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="fdc5d0a73ed6e5754beb78140673dc58ba17d0dc" translate="yes" xml:space="preserve">
          <source>Read more in the &lt;a href=&quot;https://atmospherejs.com/alanning/roles&quot;&gt;&lt;code&gt;alanning:roles&lt;/code&gt; package documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/alanning/roles&quot;&gt; &lt;code&gt;alanning:roles&lt;/code&gt; 패키지 설명서&lt;/a&gt; 에서 자세한 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="08498c5c362d894ecbf197db25bd23776045d783" translate="yes" xml:space="preserve">
          <source>Read the documentation about build plugins.</source>
          <target state="translated">빌드 플러그인에 대한 문서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7695db2d5ac227a2dfd986509c3fcc74ca165470" translate="yes" xml:space="preserve">
          <source>Read the documentation for each package listed below to see how to indicate which files are source files vs. imports.</source>
          <target state="translated">소스 파일과 가져 오기 중 어느 파일인지 표시하는 방법을 보려면 아래 나열된 각 패키지의 설명서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="3c219f4cfcba1bccfa614469cdb62b68c0a1beb3" translate="yes" xml:space="preserve">
          <source>Recently, a lot of npm packages have been moving to Promises instead of callbacks for their API. This means you actually get a return value from the asynchronous function, but it&amp;rsquo;s just an empty shell where the real value is filled in later.</source>
          <target state="translated">최근 많은 npm 패키지가 API에 대한 콜백 대신 약속으로 이동했습니다. 이것은 실제로 비동기 함수에서 반환 값을 얻지 만 실제 값이 나중에 채워지는 빈 쉘 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="54022bc6f2f9b999e1a4ce0c9f340f99d42a72f1" translate="yes" xml:space="preserve">
          <source>Recommended: Mocha</source>
          <target state="translated">추천 : 모카</target>
        </trans-unit>
        <trans-unit id="17a8cce91d565b284d3d1168a8f686bda872db99" translate="yes" xml:space="preserve">
          <source>Recovering from faulty versions</source>
          <target state="translated">결함이있는 버전에서 복구</target>
        </trans-unit>
        <trans-unit id="60e22121bdd0bc71cdb2bae2a3aa577006b2eae9" translate="yes" xml:space="preserve">
          <source>Redirecting</source>
          <target state="translated">Redirecting</target>
        </trans-unit>
        <trans-unit id="8b7fc268a6ac78cab9d0a46d12ca44738f41a78c" translate="yes" xml:space="preserve">
          <source>Redirecting after a user&amp;rsquo;s action</source>
          <target state="translated">사용자의 행동 후 리디렉션</target>
        </trans-unit>
        <trans-unit id="40a4d23a8dafd58a95661084ed2f34c6b35573cc" translate="yes" xml:space="preserve">
          <source>Redirecting dynamically</source>
          <target state="translated">동적으로 리디렉션</target>
        </trans-unit>
        <trans-unit id="65d26c11f1b25c89fcdf6ae8498fa376d710ec34" translate="yes" xml:space="preserve">
          <source>Refactoring to reuse security rules</source>
          <target state="translated">보안 규칙을 재사용하기위한 리팩토링</target>
        </trans-unit>
        <trans-unit id="3a4c8dcbb74393067916a368021f02effedc575d" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html#preference&quot;&gt;preferences section&lt;/a&gt; of the Cordova documentation for more information about supported options.</source>
          <target state="translated">지원되는 옵션에 대한 자세한 정보는 Cordova 문서 의 &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html#preference&quot;&gt;환경 설정 섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c25cd66a82531c77ed01fb1c26ba430584018b76" translate="yes" xml:space="preserve">
          <source>Refer to the Method via JS module rather than a magic string.</source>
          <target state="translated">매직 문자열이 아닌 JS 모듈을 통한 메소드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b01d33f6c7b508ee0fe9eca5942ab2d8b9bcbb77" translate="yes" xml:space="preserve">
          <source>Regardless of how you add the package to your app, its actual version will be tracked in the file at &lt;code&gt;.meteor/versions&lt;/code&gt;. This means that anybody collaborating with you on the same app is guaranteed to have the same package versions as you. If you want to update to a newer version of a package after installing it, use &lt;code&gt;meteor update&lt;/code&gt;. You can run &lt;code&gt;meteor update&lt;/code&gt; without any arguments to update all packages and Meteor itself to their latest versions, or pass a specific package to update just that one, for example &lt;code&gt;meteor update kadira:flow-router&lt;/code&gt;.</source>
          <target state="translated">앱에 패키지를 추가하는 방법에 관계없이 실제 버전은 &lt;code&gt;.meteor/versions&lt;/code&gt; 파일에서 추적 됩니다 . 즉, 동일한 앱에서 나와 협력하는 사람은 모두 동일한 패키지 버전을 사용해야합니다. 설치 후 최신 버전의 패키지로 &lt;code&gt;meteor update&lt;/code&gt; 하려면 meteor update를 사용하십시오 . 인수없이 &lt;code&gt;meteor update&lt;/code&gt; 를 실행 하여 모든 패키지와 Meteor 자체를 최신 버전으로 업데이트하거나 특정 패키지를 전달하여 &lt;code&gt;meteor update kadira:flow-router&lt;/code&gt; 와 같은 패키지 만 업데이트 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="df0b0ae6dab5a8da38f1c82f15d73aca42eb5c9f" translate="yes" xml:space="preserve">
          <source>Regardless of the view layer that you are using, there are some patterns in how you build your User Interface (UI) that will help make your app&amp;rsquo;s code easier to understand, test, and maintain. These patterns, much like general patterns of modularity, revolve around making the interfaces to your UI elements very clear and avoiding using techniques that bypass these known interfaces.</source>
          <target state="translated">사용중인 뷰 계층에 관계없이 UI (사용자 인터페이스)를 구축하는 방법에는 앱의 코드를보다 쉽게 ​​이해, 테스트 및 유지 관리하는 데 도움이되는 몇 가지 패턴이 있습니다. 일반적인 모듈성 패턴과 마찬가지로 이러한 패턴은 UI 요소에 대한 인터페이스를 매우 명확하게 만들고 알려진 인터페이스를 우회하는 기술을 사용하지 않는 것을 중심으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="8a41fadc048efbfbcd4464f67267f15bbc047043" translate="yes" xml:space="preserve">
          <source>Register a callback to be called after a login attempt fails.</source>
          <target state="translated">로그인 시도가 실패한 후 호출 할 콜백을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="3bbb5b6615ebbc2a8d067ada3d8a180da644c5c0" translate="yes" xml:space="preserve">
          <source>Register a callback to be called after a login attempt succeeds.</source>
          <target state="translated">로그인 시도 후 호출 할 콜백을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="1a7372e8d4e1031596740ef57c21d3017751113c" translate="yes" xml:space="preserve">
          <source>Register a callback to be called after a logout attempt succeeds.</source>
          <target state="translated">로그 아웃 시도 후 호출 할 콜백을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="822b3f5ff4b7fef4902d2c7846ff9e00c5e09db2" translate="yes" xml:space="preserve">
          <source>Register a callback to be called when a new DDP connection is made to the server.</source>
          <target state="translated">서버에 새로운 DDP 연결이 이루어질 때 호출 할 콜백을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="f619d019b63a99f44e3850ba418fd92a0277cc81" translate="yes" xml:space="preserve">
          <source>Register a callback to be called when the connection is closed. If the connection is already closed, the callback will be called immediately.</source>
          <target state="translated">연결이 닫힐 때 호출 할 콜백을 등록하십시오. 연결이 이미 종료 된 경우 콜백이 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ebdbe5e38fd8c714e314eb749b76766f7d74a2" translate="yes" xml:space="preserve">
          <source>Register a function to be called when an instance of this template is created.</source>
          <target state="translated">이 템플릿의 인스턴스가 생성 될 때 호출 할 함수를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="9efe8ac33a0511d6d129b62d882344a2bb35eb17" translate="yes" xml:space="preserve">
          <source>Register a function to be called when an instance of this template is inserted into the DOM.</source>
          <target state="translated">이 템플릿의 인스턴스가 DOM에 삽입 될 때 호출 할 함수를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="ce80fdc783593d32a60cbe706fb72a6253eac64a" translate="yes" xml:space="preserve">
          <source>Register a function to be called when an instance of this template is removed from the DOM and destroyed.</source>
          <target state="translated">이 템플릿의 인스턴스가 DOM에서 제거되어 소멸 될 때 호출 할 함수를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="b8da5312c0c7036207f2751af104356905dd47d3" translate="yes" xml:space="preserve">
          <source>Register a function to call as the first step of reconnecting. This function can call methods which will be executed before any other outstanding methods. For example, this can be used to re-establish the appropriate authentication context on the connection.</source>
          <target state="translated">다시 연결하는 첫 번째 단계로 호출 할 함수를 등록하십시오. 이 함수는 다른 미해결 메서드보다 먼저 실행될 메서드를 호출 할 수 있습니다. 예를 들어, 연결에서 적절한 인증 컨텍스트를 다시 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a64cbdba5142f513eb30038d00b0e8cb4775d21" translate="yes" xml:space="preserve">
          <source>Register a function to call when a reset password link is clicked in an email sent by &lt;a href=&quot;#accounts_sendresetpasswordemail&quot;&gt;&lt;code&gt;Accounts.sendResetPasswordEmail&lt;/code&gt;&lt;/a&gt;. This function should be called in top-level code, not inside &lt;code&gt;Meteor.startup()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#accounts_sendresetpasswordemail&quot;&gt; &lt;code&gt;Accounts.sendResetPasswordEmail&lt;/code&gt; 에서&lt;/a&gt; 보낸 이메일에서 비밀번호 재설정 링크를 클릭 할 때 호출 할 기능을 등록하십시오 . 이 함수는 &lt;code&gt;Meteor.startup()&lt;/code&gt; 내부가 아닌 최상위 코드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8373983b247f7d43bc88705df46f72cf5ceb386" translate="yes" xml:space="preserve">
          <source>Register a function to call when an account enrollment link is clicked in an email sent by &lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt;&lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt;&lt;/a&gt;. This function should be called in top-level code, not inside &lt;code&gt;Meteor.startup()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt; &lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt; 이&lt;/a&gt; 보낸 이메일에서 계정 등록 링크를 클릭 할 때 호출 할 기능을 등록하십시오 . 이 함수는 &lt;code&gt;Meteor.startup()&lt;/code&gt; 내부가 아닌 최상위 코드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="54a21feb97deddc34afaf44b4d5e96b246c20326" translate="yes" xml:space="preserve">
          <source>Register a function to call when an email verification link is clicked in an email sent by &lt;a href=&quot;#accounts_sendverificationemail&quot;&gt;&lt;code&gt;Accounts.sendVerificationEmail&lt;/code&gt;&lt;/a&gt;. This function should be called in top-level code, not inside &lt;code&gt;Meteor.startup()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#accounts_sendverificationemail&quot;&gt; &lt;code&gt;Accounts.sendVerificationEmail&lt;/code&gt; 이&lt;/a&gt; 보낸 이메일에서 이메일 확인 링크를 클릭 할 때 호출 할 기능을 등록하십시오 . 이 함수는 &lt;code&gt;Meteor.startup()&lt;/code&gt; 내부가 아닌 최상위 코드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e8c49fac1d08550fd31ce1d4297976aa28b7f1f6" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;callback&lt;/code&gt; to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated. The callback is run exactly once and not upon future invalidations unless &lt;code&gt;onInvalidate&lt;/code&gt; is called again after the computation becomes valid again.</source>
          <target state="translated">이 계산이 다음에 무효화 될 때 실행할 &lt;code&gt;callback&lt;/code&gt; 을 등록 하거나 계산이 이미 무효화 된 경우 즉시 실행합니다. 계산이 다시 유효한 후에 &lt;code&gt;onInvalidate&lt;/code&gt; 가 다시 호출 되지 않으면 콜백은 정확히 한 번만 실행되고 이후 무효화시에는 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f544d3333c38572f5001db3033b4d656d02e45d0" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;callback&lt;/code&gt; to run when this computation is stopped, or runs it immediately if the computation is already stopped. The callback is run after any &lt;code&gt;onInvalidate&lt;/code&gt; callbacks.</source>
          <target state="translated">이 계산이 중지 될 때 실행할 &lt;code&gt;callback&lt;/code&gt; 을 등록 하거나 계산이 이미 중지 된 경우 즉시 실행합니다. 콜백은 &lt;code&gt;onInvalidate&lt;/code&gt; 콜백 후에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="a729e924b9f0527e5edc8a765fd827d48e828e71" translate="yes" xml:space="preserve">
          <source>Registers a new &lt;a href=&quot;#computation_oninvalidate&quot;&gt;&lt;code&gt;onInvalidate&lt;/code&gt;&lt;/a&gt; callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.</source>
          <target state="translated">현재 계산이 무효화되거나 중지 될 때 즉시 호출되도록 현재 계산 (존재해야 함)에 새로운 &lt;a href=&quot;#computation_oninvalidate&quot;&gt; &lt;code&gt;onInvalidate&lt;/code&gt; &lt;/a&gt; 콜백을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cb94729d19fa00aad07bfad30cd327bba18eba" translate="yes" xml:space="preserve">
          <source>Regular &lt;code&gt;Error&lt;/code&gt; for internal server errors</source>
          <target state="translated">내부 서버 &lt;code&gt;Error&lt;/code&gt; 대한 일반 오류</target>
        </trans-unit>
        <trans-unit id="7324bbce403ec626639c4d45e6ed9a157091e4e1" translate="yes" xml:space="preserve">
          <source>Reloads app on file change</source>
          <target state="translated">파일 변경시 앱 재로드</target>
        </trans-unit>
        <trans-unit id="c4e88f19388c890b10a1d60bb0e45227065ee77c" translate="yes" xml:space="preserve">
          <source>Remove an email address for a user. Use this instead of updating the database directly.</source>
          <target state="translated">사용자의 이메일 주소를 제거하십시오. 데이터베이스를 직접 업데이트하는 대신 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57a85bff63e30d2cc749be81fcb72d9abea4b29b" translate="yes" xml:space="preserve">
          <source>Remove documents from the collection</source>
          <target state="translated">컬렉션에서 문서 제거</target>
        </trans-unit>
        <trans-unit id="201b0de1f3280854197b5a3292b805835203a0ba" translate="yes" xml:space="preserve">
          <source>Removes a package previously added to your Meteor project. For a list of the packages that your application is currently using, run &lt;code&gt;meteor list&lt;/code&gt;.</source>
          <target state="translated">이전에 Meteor 프로젝트에 추가 된 패키지를 제거합니다. 애플리케이션이 현재 사용중인 패키지 &lt;code&gt;meteor list&lt;/code&gt; 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="66beb793c61909cbbdffd9fd1645cbf7ef1a3047" translate="yes" xml:space="preserve">
          <source>Removes a platform previously added to your Meteor project. For a list of the platforms that your application is currently using, see &lt;code&gt;meteor list-platforms&lt;/code&gt;.</source>
          <target state="translated">이전에 Meteor 프로젝트에 추가 된 플랫폼을 제거합니다. 애플리케이션이 현재 사용중인 &lt;code&gt;meteor list-platforms&lt;/code&gt; 은 meteor list-platforms를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34103f69fe0d4d71b74d991911320628162be9a6" translate="yes" xml:space="preserve">
          <source>Removes a rendered View from the DOM, stopping all reactive updates and event listeners on it. Also destroys the Blaze.Template instance associated with the view.</source>
          <target state="translated">DOM에서 렌더링 된 뷰를 제거하여 반응 형 업데이트와 이벤트 리스너를 모두 중지합니다. 또한 뷰와 관련된 Blaze.Template 인스턴스를 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="ef5418ac2674abc862503242059562ef3208bf5a" translate="yes" xml:space="preserve">
          <source>Removes the specified rule from the rate limiter. If rule had hit a rate limit, that limit is removed as well.</source>
          <target state="translated">속도 제한 기에서 지정된 규칙을 제거합니다. 규칙이 속도 제한에 도달 한 경우 해당 제한도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="806f62597efaa40fe7c07758bf9078e343e283f1" translate="yes" xml:space="preserve">
          <source>Removing attributes not in the schema</source>
          <target state="translated">스키마에없는 속성 제거</target>
        </trans-unit>
        <trans-unit id="937938f90c18610fb2311b51587797149b2dd30f" translate="yes" xml:space="preserve">
          <source>Removing directly installed plugins</source>
          <target state="translated">직접 설치된 플러그인 제거</target>
        </trans-unit>
        <trans-unit id="071197509cb7c8cff19d8bac27e7440048edd880" translate="yes" xml:space="preserve">
          <source>Render performance varies a lot depending on the situation. All three libraries are very quick at rendering simple apps, but can take a noticeable amount of time with more complex apps.</source>
          <target state="translated">렌더링 성능은 상황에 따라 크게 다릅니다. 세 라이브러리는 모두 간단한 앱을 렌더링하는 데 매우 빠르지 만 더 복잡한 앱을 사용하면 상당한 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="941faaeb7a5f68be1162d99baa90cc9160f50e1e" translate="yes" xml:space="preserve">
          <source>Render the helpers in the same way the previous template did. In this case we are using &lt;code&gt;buttonText&lt;/code&gt;.</source>
          <target state="translated">이전 템플릿과 같은 방식으로 도우미를 렌더링합니다. 이 경우 &lt;code&gt;buttonText&lt;/code&gt; 사용 하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="29350daccbab00f57e738178ebefb89531e492bb" translate="yes" xml:space="preserve">
          <source>Renderable Content</source>
          <target state="translated">렌더링 가능한 컨텐츠</target>
        </trans-unit>
        <trans-unit id="bb334a622f026b92bb650f9085e2b28dac310a35" translate="yes" xml:space="preserve">
          <source>Rendering a template to HTML loses all fine-grained reactivity. The normal way to render a template is to either include it from another template (&lt;code&gt;{{&amp;gt; myTemplate}}&lt;/code&gt;) or render and insert it programmatically using &lt;code&gt;Blaze.render&lt;/code&gt;. Only occasionally is generating HTML useful.</source>
          <target state="translated">템플릿을 HTML로 렌더링하면 세분화 된 반응성이 모두 사라집니다. 템플릿을 렌더링하는 일반적인 방법은 다른 템플릿 ( &lt;code&gt;{{&amp;gt; myTemplate}}&lt;/code&gt; ) 에서 템플릿을 포함 하거나 &lt;code&gt;Blaze.render&lt;/code&gt; 를 사용하여 프로그래밍 방식으로 템플릿을 렌더링 및 삽입하는 것 입니다. 때때로 유용한 HTML을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="02208207bc68e791a4d1db92b0ae89e131daef08" translate="yes" xml:space="preserve">
          <source>Rendering an updated UI when a user reaches a new route is not that useful without giving the user some way to reach a new route! The simplest way is with the trusty &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag and a URL. You can generate the URLs yourself using &lt;code&gt;FlowRouter.pathFor&lt;/code&gt;, but it is more convenient to use the &lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt;&lt;code&gt;arillo:flow-router-helpers&lt;/code&gt;&lt;/a&gt; package that defines some helpers for you:</source>
          <target state="translated">사용자가 새로운 경로에 도달했을 때 업데이트 된 UI를 렌더링하는 것은 사용자에게 새로운 경로에 도달 할 수있는 방법을 제공하지 않으면 유용하지 않습니다! 가장 간단한 방법은 신뢰할 수있는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그와 URL을 사용하는 것입니다. &lt;code&gt;FlowRouter.pathFor&lt;/code&gt; 를 사용하여 직접 URL을 생성 할 수 있지만 일부 헬퍼를 정의 하는 &lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt; &lt;code&gt;arillo:flow-router-helpers&lt;/code&gt; &lt;/a&gt; 패키지 를 사용하는 것이 더 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="1ba514b1cc3ecab339360b3b5959fbf5ae8b45ac" translate="yes" xml:space="preserve">
          <source>Rendering based on the route</source>
          <target state="translated">경로를 기반으로 렌더링</target>
        </trans-unit>
        <trans-unit id="6f2b248a41f9e64e230a755be8da77faeb619ed3" translate="yes" xml:space="preserve">
          <source>Rendering raw HTML</source>
          <target state="translated">원시 HTML 렌더링</target>
        </trans-unit>
        <trans-unit id="cea9fce3d9e0a0226d1009eabc5f8aae1e69a3bf" translate="yes" xml:space="preserve">
          <source>Renders a template or View to DOM nodes and inserts it into the DOM, returning a rendered &lt;a href=&quot;#Blaze-View&quot;&gt;View&lt;/a&gt; which can be passed to &lt;a href=&quot;#Blaze-remove&quot;&gt;&lt;code&gt;Blaze.remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">템플릿 또는 뷰를 DOM 노드로 렌더링하고 DOM에 삽입 하여 &lt;a href=&quot;#Blaze-remove&quot;&gt; &lt;code&gt;Blaze.remove&lt;/code&gt; &lt;/a&gt; 로 전달할 수 있는 렌더링 된 &lt;a href=&quot;#Blaze-View&quot;&gt;뷰&lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3719e8da641de28a1a7578fba81d635d71cfeed9" translate="yes" xml:space="preserve">
          <source>Renders a template or View to DOM nodes with a data context. Otherwise identical to &lt;code&gt;Blaze.render&lt;/code&gt;.</source>
          <target state="translated">데이터 컨텍스트를 사용하여 템플릿 또는 View to DOM 노드를 렌더링합니다. 그렇지 않으면 &lt;code&gt;Blaze.render&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d66f25799c3dce91c45de1fd4bd0f7f5e10013e6" translate="yes" xml:space="preserve">
          <source>Renders a template or View to HTML with a data context. Otherwise identical to &lt;code&gt;Blaze.toHTML&lt;/code&gt;.</source>
          <target state="translated">데이터 컨텍스트를 사용하여 템플릿 또는보기를 HTML로 렌더링합니다. 그렇지 않으면 &lt;code&gt;Blaze.toHTML&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2adbf6d8c3b324405f9c4279b460777eb7bedd3e" translate="yes" xml:space="preserve">
          <source>Renders a template or View to a string of HTML.</source>
          <target state="translated">템플릿 또는보기를 HTML 문자열로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="6f1cb9bcb8fdf346bdb04d0d0f22e728ed79b8d3" translate="yes" xml:space="preserve">
          <source>Replace localhost with 127.0.0.1. Useful for services that don't recognize localhost as a domain name.</source>
          <target state="translated">localhost를 127.0.0.1로 바꾸십시오. localhost를 도메인 이름으로 인식하지 않는 서비스에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="00c672c70f58ab89a00f7fdd4c7a2662714c6740" translate="yes" xml:space="preserve">
          <source>Replace the &lt;code&gt;tools/&lt;/code&gt; folder in &lt;code&gt;~/Library/Android/sdk/&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~/Library/Android/sdk/&lt;/code&gt; 의 &lt;code&gt;tools/&lt;/code&gt; 폴더를 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="a242ade3ef6daa3baaaebe0ef02919fd067b76d2" translate="yes" xml:space="preserve">
          <source>Request a forgot password email.</source>
          <target state="translated">비밀번호를 잊어 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="f38a27d2d3cd986f4dc6c899aa795773f3ed09c4" translate="yes" xml:space="preserve">
          <source>Requesting Permissions</source>
          <target state="translated">권한 요청</target>
        </trans-unit>
        <trans-unit id="35d17a1d71b863c03c95ab7196d118a86b489da7" translate="yes" xml:space="preserve">
          <source>Require a package that was specified using &lt;code&gt;Npm.depends()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Npm.depends()&lt;/code&gt; 사용하여 지정된 패키지가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="8f4a692fc113a9fbf96e7b6db5f6b023297a1613" translate="yes" xml:space="preserve">
          <source>Requiring username or email</source>
          <target state="translated">사용자 이름 또는 이메일 필요</target>
        </trans-unit>
        <trans-unit id="9d79ba10cf1beedefcd5cb2cd8d4276c9f901a5f" translate="yes" xml:space="preserve">
          <source>Reset the current project to a fresh state. Removes the local mongo database.</source>
          <target state="translated">현재 프로젝트를 새로운 상태로 재설정하십시오. 로컬 몽고 데이터베이스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="10f6872970910165d253bbd2066c87f811053ba5" translate="yes" xml:space="preserve">
          <source>Reset the password for a user using a token received in email. Logs the user in afterwards.</source>
          <target state="translated">이메일로받은 토큰을 사용하여 사용자의 비밀번호를 재설정하십시오. 나중에 사용자를 로그인합니다.</target>
        </trans-unit>
        <trans-unit id="3e946a4115352d8257a590891238fa19e328931a" translate="yes" xml:space="preserve">
          <source>Restart VS Code</source>
          <target state="translated">VS 코드 재시작</target>
        </trans-unit>
        <trans-unit id="419415c9ab764255e58576751f5ab56204362267" translate="yes" xml:space="preserve">
          <source>Retrieve the contents of the static server asset as a UTF8-encoded string.</source>
          <target state="translated">정적 서버 자산의 컨텐츠를 UTF8 인코딩 문자열로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="ed9a0b9e0dc4c5e3e7821777e532e6413b3a5e33" translate="yes" xml:space="preserve">
          <source>Retrieve the contents of the static server asset as an &lt;a href=&quot;#ejson_new_binary&quot;&gt;EJSON Binary&lt;/a&gt;.</source>
          <target state="translated">정적 서버 자산의 컨텐츠를 &lt;a href=&quot;#ejson_new_binary&quot;&gt;EJSON Binary&lt;/a&gt; 로 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb8a04210e616dde8062a58c4d4b0a16d33b2099" translate="yes" xml:space="preserve">
          <source>Retrieves the user record for the current user from the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">&lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt; 컬렉션 에서 현재 사용자의 사용자 레코드를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="dd9192270a9006bdbb0d60dda0d9dfbfe3e13042" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; has a value equal to &lt;code&gt;this&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;other&lt;/code&gt; 같은 값이 &lt;code&gt;this&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="1d84f91f90db6d7078683bbbadd4142507dfbaab" translate="yes" xml:space="preserve">
          <source>Return a deep copy of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 의 딥 카피를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="405b952918d3cc6f9e583417d6e2d50947a568b1" translate="yes" xml:space="preserve">
          <source>Return a number between 0 and 1, like &lt;code&gt;Math.random&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Math.random&lt;/code&gt; 과 같이 0과 1 사이의 숫자를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc816941f1f652a68c6a352399448afc74d82649" translate="yes" xml:space="preserve">
          <source>Return a random element of the given array or string.</source>
          <target state="translated">지정된 배열 또는 문자열의 임의 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="656adc591e1a65872f8010699af86800ba3d68a2" translate="yes" xml:space="preserve">
          <source>Return a random string of &lt;code&gt;n&lt;/code&gt; hexadecimal digits.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 16 진수 로 된 임의의 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="49c85b45e1a520a5f92de401f0e1539d9c8458c8" translate="yes" xml:space="preserve">
          <source>Return a random string of printable characters with 6 bits of entropy per character. Use &lt;code&gt;Random.secret&lt;/code&gt; for security-critical secrets that are intended for machine, rather than human, consumption.</source>
          <target state="translated">문자 당 6 비트의 엔트로피를 가진 임의의 인쇄 가능한 문자 문자열을 반환합니다. 사람이 아닌 컴퓨터를위한 보안에 중요한 비밀 에는 &lt;code&gt;Random.secret&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="604eeddfc7d81023a5928056882b40bec6c7ec91" translate="yes" xml:space="preserve">
          <source>Return a unique identifier, such as &lt;code&gt;&quot;Jjwjg6gouWLXhMGKW&quot;&lt;/code&gt;, that is likely to be unique in the whole world.</source>
          <target state="translated">전 세계에서 고유 한 &lt;code&gt;&quot;Jjwjg6gouWLXhMGKW&quot;&lt;/code&gt; 와 같은 고유 식별자를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="189ad33766f6c44a17d20b0b33c90284241520dd" translate="yes" xml:space="preserve">
          <source>Return a value &lt;code&gt;r&lt;/code&gt; such that &lt;code&gt;this.equals(r)&lt;/code&gt; is true, and modifications to &lt;code&gt;r&lt;/code&gt; do not affect &lt;code&gt;this&lt;/code&gt; and vice versa.</source>
          <target state="translated">값 반환 &lt;code&gt;r&lt;/code&gt; 있도록 &lt;code&gt;this.equals(r)&lt;/code&gt; 사실을, 그리고 수정 &lt;code&gt;r&lt;/code&gt; 은 영향을주지 않습니다 &lt;code&gt;this&lt;/code&gt; 반대 및 부사장을.</target>
        </trans-unit>
        <trans-unit id="b511b08db5b0274d0477a6bd83c0aa6ab2aa164a" translate="yes" xml:space="preserve">
          <source>Return all matching documents as an Array.</source>
          <target state="translated">일치하는 모든 문서를 배열로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="5c2f97184bfe0759afaa52e3dea61a8fbdcd5299" translate="yes" xml:space="preserve">
          <source>Return ambiguous error messages from login failures to prevent user enumeration. Defaults to false.</source>
          <target state="translated">사용자 열거를 방지하기 위해 로그인 실패에서 모호한 오류 메시지를 반환합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8bfabaed6a4d2b54f0d351ade5e9d5493fe15fad" translate="yes" xml:space="preserve">
          <source>Return the tag used to identify this type. This must match the tag used to register this type with &lt;a href=&quot;#ejson_add_type&quot;&gt;&lt;code&gt;EJSON.addType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형을 식별하는 데 사용되는 태그를 반환하십시오. 이 유형을 &lt;a href=&quot;#ejson_add_type&quot;&gt; &lt;code&gt;EJSON.addType&lt;/code&gt; &lt;/a&gt; 에 등록하는 데 사용 된 태그와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e2e744ca0060a036477398b68411bd8ae9d1116" translate="yes" xml:space="preserve">
          <source>Return true if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal to each other. Return false otherwise. Uses the &lt;code&gt;equals&lt;/code&gt; method on &lt;code&gt;a&lt;/code&gt; if present, otherwise performs a deep comparison.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 서로 같으면 true를 반환합니다 . 그렇지 않으면 false를 반환합니다. (가) 사용 &lt;code&gt;equals&lt;/code&gt; 에 방법을 달리 깊은 비교를 수행, 존재하는 경우. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cc9f197562b8a00d58d67cf96d00f3ab99d1809" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;false&lt;/code&gt; from a handler is the same as calling both &lt;code&gt;stopImmediatePropagation&lt;/code&gt; and &lt;code&gt;preventDefault&lt;/code&gt; on the event.</source>
          <target state="translated">핸들러에서 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 것은 &lt;code&gt;preventDefault&lt;/code&gt; 에서 &lt;code&gt;stopImmediatePropagation&lt;/code&gt; 및 preventDefault 를 모두 호출 하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ac586d0086a4b73af4ea1bee5996773b14a33252" translate="yes" xml:space="preserve">
          <source>Returns a handle that can be used by &lt;code&gt;Meteor.clearInterval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Meteor.clearInterval&lt;/code&gt; 에서 사용할 수있는 핸들을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="155c5721ad3c0a1fbb025b1b78038151d3169fa2" translate="yes" xml:space="preserve">
          <source>Returns a handle that can be used by &lt;code&gt;Meteor.clearTimeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Meteor.clearTimeout&lt;/code&gt; 에서 사용할 수있는 핸들을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8efd7f051658876e46e7afadb7a76b5146c894ce" translate="yes" xml:space="preserve">
          <source>Returns an unrendered View object you can pass to &lt;code&gt;Blaze.render&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Blaze.render&lt;/code&gt; 에 전달할 수있는 렌더링되지 않은 View 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="467c1bfcc17eb57521a52be12cc51c067a7a8479" translate="yes" xml:space="preserve">
          <source>Returns one DOM element matching &lt;code&gt;selector&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there are no such elements.</source>
          <target state="translated">하나의 DOM 요소와 일치하는 &lt;code&gt;selector&lt;/code&gt; 를 반환 하거나 해당 요소가없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3658376ed7bd64aa1ba58fe02497c57690938574" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; object corresponding to this collection from the &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;code&gt;mongodb&lt;/code&gt; driver module&lt;/a&gt; which is wrapped by &lt;code&gt;Mongo.Collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mongo.Collection&lt;/code&gt; 에 의해 랩핑 된 &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;/a&gt; &lt;code&gt;mongodb&lt;/code&gt; 드라이버 모듈 에서이 콜렉션에 해당하는 &lt;a href=&quot;http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aefa5150f7bb6cb18f1e527c2d933cadbd58a69c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html&quot;&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/a&gt; object corresponding to this collection's database connection from the &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;code&gt;mongodb&lt;/code&gt; driver module&lt;/a&gt; which is wrapped by &lt;code&gt;Mongo.Collection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mongo.Collection&lt;/code&gt; 에 의해 랩핑 된 &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;/a&gt; &lt;code&gt;mongodb&lt;/code&gt; 드라이버 모듈 에서이 콜렉션의 데이터베이스 연결에 해당하는 &lt;a href=&quot;http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html&quot;&gt; &lt;code&gt;Db&lt;/code&gt; &lt;/a&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="072e5a34d93ade06b1f313f822be383ae32337a5" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; object corresponding to this collection from the &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;code&gt;mongodb&lt;/code&gt; driver module&lt;/a&gt; which is wrapped by &lt;code&gt;Mongo.Collection&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61ff92836db884cb9b0719775cc5397fd640189" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://mongodb.github.io/node-mongodb-native/2.2/api/Db.html&quot;&gt;&lt;code&gt;Db&lt;/code&gt;&lt;/a&gt; object corresponding to this collection's database connection from the &lt;a href=&quot;https://www.npmjs.com/package/mongodb&quot;&gt;npm &lt;code&gt;mongodb&lt;/code&gt; driver module&lt;/a&gt; which is wrapped by &lt;code&gt;Mongo.Collection&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dd3c9a52b119bdedec2c6de623abcdac5540b9" translate="yes" xml:space="preserve">
          <source>Returns the current data context, or the data context that was used when rendering a particular DOM element or View from a Meteor template.</source>
          <target state="translated">현재 데이터 컨텍스트 또는 Meteor 템플릿에서 특정 DOM 요소 또는 뷰를 렌더링 할 때 사용 된 데이터 컨텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d4bfb60ebedff68f5fd65f0ad9563137cd80a7f" translate="yes" xml:space="preserve">
          <source>Returns the current value of the ReactiveVar, establishing a reactive dependency.</source>
          <target state="translated">반응성 종속성을 설정하여 ReactiveVar의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfa1f3ec85911f5a0d5bacc052fdac9c074b652f" translate="yes" xml:space="preserve">
          <source>Returns the number of documents that match a query.</source>
          <target state="translated">쿼리와 일치하는 문서 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2200acbce72c1d4789bad815509ce1f619efbd90" translate="yes" xml:space="preserve">
          <source>Returns true if &lt;code&gt;value&lt;/code&gt; is a template object like &lt;code&gt;Template.myTemplate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;Template.myTemplate&lt;/code&gt; 과 같은 템플릿 객체 이면 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b8568caba404619a3400ef9f8cc92de6614b59f" translate="yes" xml:space="preserve">
          <source>Returns true if &lt;code&gt;x&lt;/code&gt; is a buffer of binary data, as returned from &lt;a href=&quot;#ejson_new_binary&quot;&gt;&lt;code&gt;EJSON.newBinary&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ejson_new_binary&quot;&gt; &lt;code&gt;EJSON.newBinary&lt;/code&gt; &lt;/a&gt; 에서 반환 된대로 &lt;code&gt;x&lt;/code&gt; 가 이진 데이터 버퍼 인 경우 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="99f2d994469715424e279fadff7f71bac8d585d6" translate="yes" xml:space="preserve">
          <source>Returns true if the computation is a new dependent of &lt;code&gt;dependency&lt;/code&gt; rather than an existing one.</source>
          <target state="translated">계산이 기존 &lt;code&gt;dependency&lt;/code&gt; 아닌 새로운 종속성에 종속 된 경우 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5caf1d79a7ade37b7c0b9481f3c08ce86c735415" translate="yes" xml:space="preserve">
          <source>Returns true if the value matches the pattern.</source>
          <target state="translated">값이 패턴과 일치하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="113c300fa95ddf1f0ecb1d78a180e2136a125575" translate="yes" xml:space="preserve">
          <source>Returns unique &lt;code&gt;ruleId&lt;/code&gt; that can be passed to &lt;code&gt;removeRule&lt;/code&gt;.</source>
          <target state="translated">반환 독특한 &lt;code&gt;ruleId&lt;/code&gt; 에 전달 될 수 &lt;code&gt;removeRule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14c00cc40cb9a802986228a425de9dca8530c3a8" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;preventDefault()&lt;/code&gt; has been called for this event.</source>
          <target state="translated">이 이벤트에 대해 &lt;code&gt;preventDefault()&lt;/code&gt; 가 호출 되었는지 여부 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="711ff3cae769ddd78110829049c42edcd37953bb" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;stopImmediatePropagation()&lt;/code&gt; has been called for this event.</source>
          <target state="translated">이 이벤트에 대해 &lt;code&gt;stopImmediatePropagation()&lt;/code&gt; 이 호출 되었는지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a63df53ef5e942ba64b3bd9f4eaba3b6329ab3bd" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;stopPropagation()&lt;/code&gt; has been called for this event.</source>
          <target state="translated">이 이벤트에 대해 &lt;code&gt;stopPropagation()&lt;/code&gt; 이 호출 되었는지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cd5579e438b8d514ebfa3afdac6844eacf576a7c" translate="yes" xml:space="preserve">
          <source>Reusable components</source>
          <target state="translated">재사용 가능한 구성 요소</target>
        </trans-unit>
        <trans-unit id="15d90af326f16531c4e8b8a49e7be3def862ae59" translate="yes" xml:space="preserve">
          <source>Reusable components have many advantages:</source>
          <target state="translated">재사용 가능한 구성 요소에는 많은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a284c65c1493f84a3127263ac51fc681656485e0" translate="yes" xml:space="preserve">
          <source>Reusable components in Blaze</source>
          <target state="translated">Blaze의 재사용 가능한 구성 요소</target>
        </trans-unit>
        <trans-unit id="b158e06f1216200c9f60198c61501480351d7aa9" translate="yes" xml:space="preserve">
          <source>Reusing code in Blaze</source>
          <target state="translated">Blaze에서 코드 재사용</target>
        </trans-unit>
        <trans-unit id="ad6771cea1733cf8422062ac744cc6f183bf894e" translate="yes" xml:space="preserve">
          <source>Right now, Meteor Core ships with the &lt;code&gt;standard-minifiers&lt;/code&gt; package that can be replaced with a custom one. The &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/standard-minifiers&quot;&gt;source&lt;/a&gt; of the package is a good example how to build your own minification plugin.</source>
          <target state="translated">현재 Meteor Core에는 &lt;code&gt;standard-minifiers&lt;/code&gt; 패키지가 포함되어 있으며이 패키지는 맞춤형 패키지로 교체 할 수 있습니다. &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/standard-minifiers&quot;&gt;소스&lt;/a&gt; 패키지는 자신의 축소를 플러그인을 구축하는 방법 좋은 예이다.</target>
        </trans-unit>
        <trans-unit id="34e619ef5ba1e8b27ec55296e3c36612a379d293" translate="yes" xml:space="preserve">
          <source>Role-based permissions</source>
          <target state="translated">역할 기반 권한</target>
        </trans-unit>
        <trans-unit id="5fa35a440181e8d55bd7cfc037441858edbc805a" translate="yes" xml:space="preserve">
          <source>Roles and permissions</source>
          <target state="translated">역할 및 권한</target>
        </trans-unit>
        <trans-unit id="7184d0f9f8e70d4b632c63288609269b59279541" translate="yes" xml:space="preserve">
          <source>Rolling deployments and data versions</source>
          <target state="translated">롤링 배포 및 데이터 버전</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="8128c69c4470f8e138f6e62cde8d3b6df781896c" translate="yes" xml:space="preserve">
          <source>Routing programmatically</source>
          <target state="translated">프로그래밍 방식으로 라우팅</target>
        </trans-unit>
        <trans-unit id="2208d34eec2992b6566c52dcfd489d0151e7bcf7" translate="yes" xml:space="preserve">
          <source>Rules about Methods still apply</source>
          <target state="translated">방법에 대한 규칙은 여전히 ​​적용됩니다</target>
        </trans-unit>
        <trans-unit id="28855377de3988a49c39152cac5435a613258928" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;meteor help run&lt;/code&gt; to see the full list of options.</source>
          <target state="translated">실행 &lt;code&gt;meteor help run&lt;/code&gt; 옵션의 전체 목록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf37a9ace3b319dd43e644e0069110adc29efad2" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;meteor run android-device&lt;/code&gt; to build the app, install it on the device, and launch it.</source>
          <target state="translated">실행 &lt;code&gt;meteor run android-device&lt;/code&gt; 하여, 응용 프로그램을 구축 장치에 설치하고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8ce1a6c4101c765e9d163cdc55c8efaa87b15c12" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;meteor run ios-device&lt;/code&gt; to open your project in Xcode.</source>
          <target state="translated">실행 &lt;code&gt;meteor run ios-device&lt;/code&gt; 엑스 코드에서 프로젝트를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a5e874e32b2a8152f44d7a06bb3f4ef57a55973" translate="yes" xml:space="preserve">
          <source>Run a function now and rerun it later whenever its dependencies change. Returns a Computation object that can be used to stop or observe the rerunning.</source>
          <target state="translated">지금 함수를 실행하고 종속성이 변경 될 때마다 나중에 다시 실행하십시오. 재실행을 중지하거나 관찰하는 데 사용할 수있는 Computation 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c83e98edf2a0c6f2a6d8b5aaee71e43c0a4d8bb7" translate="yes" xml:space="preserve">
          <source>Run a function without tracking dependencies.</source>
          <target state="translated">종속성을 추적하지 않고 함수를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="65b067f65c51a168a109d43f726c4b2063b59f95" translate="yes" xml:space="preserve">
          <source>Run a meteor development server in the current project. Searches upward from the current directory for the root directory of a Meteor project. Whenever you change any of the application&amp;rsquo;s source files, the changes are automatically detected and applied to the running application.</source>
          <target state="translated">현재 프로젝트에서 유성 개발 서버를 실행하십시오. 현재 디렉토리에서 위쪽으로 Meteor 프로젝트의 루트 디렉토리를 검색합니다. 응용 프로그램의 소스 파일을 변경할 때마다 변경 사항이 자동으로 감지되어 실행중인 응용 프로그램에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d16665f3fa7fc9d2d48dcd43ef512ef439b97a2e" translate="yes" xml:space="preserve">
          <source>Run code when a client or a server starts.</source>
          <target state="translated">클라이언트 또는 서버가 시작될 때 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="73b32ee93c68dbdff0bd27afe11ed32743ed737d" translate="yes" xml:space="preserve">
          <source>Run final QA on production.</source>
          <target state="translated">프로덕션에서 최종 QA를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="99fc272b99a46928ca8a062919bdec3479b91a79" translate="yes" xml:space="preserve">
          <source>Run it locally:</source>
          <target state="translated">로컬로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef120974061babfe981ce6b8225d9b4158ce035" translate="yes" xml:space="preserve">
          <source>Run the migration. At this point you should be confident that all lists have a &lt;code&gt;todoCount&lt;/code&gt;.</source>
          <target state="translated">마이그레이션을 실행하십시오. 이 시점에서 모든 목록에 &lt;code&gt;todoCount&lt;/code&gt; 가 있음을 확신해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ec862c1409feb5710432e9181beaa3c5a1b459b" translate="yes" xml:space="preserve">
          <source>Run the project, but suspend the server process for debugging.</source>
          <target state="translated">프로젝트를 실행하되 디버깅을 위해 서버 프로세스를 일시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="ac8382ae9e657d66704f1e57b71d2d1a66df25a6" translate="yes" xml:space="preserve">
          <source>Run through the whole build process for the app and run all linters the app uses. Outputs all build errors or linting warnings to the standard output.</source>
          <target state="translated">앱의 전체 빌드 프로세스를 실행하고 앱이 사용하는 모든 린터를 실행하십시오. 모든 빌드 오류 또는 보푸라기 경고를 표준 출력으로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="e54fe58d90d3960424f2350d297d1a7a4c2eb497" translate="yes" xml:space="preserve">
          <source>Run validation code by itself without running the Method body.</source>
          <target state="translated">메소드 본문을 실행하지 않고 자체적으로 유효성 검증 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="62db9434a4168267a8eb92aa401e37cf9d8b60e6" translate="yes" xml:space="preserve">
          <source>Running acceptance tests</source>
          <target state="translated">수락 테스트 실행</target>
        </trans-unit>
        <trans-unit id="b5f2135517ec110eedee484c49324fd5f9892be7" translate="yes" xml:space="preserve">
          <source>Running an app in development is all about fast iteration time. All kinds of different parts of your app are handled differently and instrumented to enable better reloads and debugging. In production, the app is reduced to just the necessary code, and functions like a regular Node.js app. Therefore, you shouldn&amp;rsquo;t run your app in production by running the &lt;code&gt;meteor&lt;/code&gt; command. Instead, follow the directions in the &lt;a href=&quot;deployment#custom-deployment&quot;&gt;production deployment article&lt;/a&gt;.</source>
          <target state="translated">개발에서 앱을 실행하는 것은 빠른 반복 시간입니다. 앱의 모든 종류의 부분이 다르게 처리되고 더 나은 재로드 및 디버깅을 가능하게하도록 계측됩니다. 프로덕션 환경에서 앱은 필요한 코드로 축소되고 일반 Node.js 앱처럼 작동합니다. 따라서 &lt;code&gt;meteor&lt;/code&gt; 명령 을 실행하여 프로덕션 환경에서 앱을 실행해서는 안됩니다 . 대신 &lt;a href=&quot;deployment#custom-deployment&quot;&gt;프로덕션 배포 문서&lt;/a&gt; 의 지침을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="4be095ccdd94d2b1e7c85b3c5e697631860d90fc" translate="yes" xml:space="preserve">
          <source>Running full-app tests</source>
          <target state="translated">전체 앱 테스트 실행</target>
        </trans-unit>
        <trans-unit id="1120d67d5254aa21f97d7819ef49052320a610d2" translate="yes" xml:space="preserve">
          <source>Running migrations</source>
          <target state="translated">마이그레이션 실행</target>
        </trans-unit>
        <trans-unit id="2b388b314c3fd06ed5eeb23647f7534ab8c4ec2e" translate="yes" xml:space="preserve">
          <source>Running on iOS will not show client-side logs in the terminal, but Xcode will show native logs as usual in the &lt;a href=&quot;https://developer.apple.com/library/tvos/documentation/DeveloperTools/Conceptual/debugging_with_xcode/chapters/debugging_tools.html&quot;&gt;debug console&lt;/a&gt;. You can add &lt;a href=&quot;https://github.com/apache/cordova-plugin-console&quot;&gt;cordova-plugin-console&lt;/a&gt; to your project to output &lt;code&gt;console&lt;/code&gt; logging calls to the native logs (which Android does by default), but this isn&amp;rsquo;t recommended because it has a substantial performance impact, and remote debugging gives you much nicer and more complete console output.</source>
          <target state="translated">iOS에서 실행하면 터미널에 클라이언트 측 로그가 표시되지 않지만 Xcode는 &lt;a href=&quot;https://developer.apple.com/library/tvos/documentation/DeveloperTools/Conceptual/debugging_with_xcode/chapters/debugging_tools.html&quot;&gt;디버그 콘솔&lt;/a&gt; 에서 평소와 같이 기본 로그를 표시 합니다. 프로젝트 에 &lt;a href=&quot;https://github.com/apache/cordova-plugin-console&quot;&gt;cordova-plugin-console&lt;/a&gt; 을 추가 하여 &lt;code&gt;console&lt;/code&gt; 로그 호출을 기본 로그 (Android에서 기본적으로 수행)에 출력 할 수 있지만 성능에 상당한 영향을 미치므로 원격 디버깅이 훨씬 우수하고 보다 완전한 콘솔 출력.</target>
        </trans-unit>
        <trans-unit id="27522f8a49676d7ac99a9375ec6596bf175fb25f" translate="yes" xml:space="preserve">
          <source>Running the migration on your local machine will probably make it take a lot longer as your machine isn&amp;rsquo;t as close to the production database as it could be.</source>
          <target state="translated">로컬 컴퓨터에서 마이그레이션을 실행하면 컴퓨터가 프로덕션 데이터베이스에 가깝지 않기 때문에 시간이 훨씬 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10d439482778e2a2049898cc331c501cc436a6e6" translate="yes" xml:space="preserve">
          <source>Running unit tests</source>
          <target state="translated">실행 단위 테스트</target>
        </trans-unit>
        <trans-unit id="78bb8826fcc2504583e625386c238563e6207595" translate="yes" xml:space="preserve">
          <source>SSL</source>
          <target state="translated">SSL</target>
        </trans-unit>
        <trans-unit id="e195c53109047004a9cc210c6b5a3caf52332575" translate="yes" xml:space="preserve">
          <source>SSL Certificate</source>
          <target state="translated">SSL 인증서</target>
        </trans-unit>
        <trans-unit id="5d8e270a3b478909d95ca7c40279e9043d659c52" translate="yes" xml:space="preserve">
          <source>SafeString</source>
          <target state="translated">SafeString</target>
        </trans-unit>
        <trans-unit id="f71dc05e071d088a9c780f2b1a6d694a3fb6befe" translate="yes" xml:space="preserve">
          <source>Same as the constructor argument.</source>
          <target state="translated">생성자 인수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b6eeeb3abd2a7bc179a6b6d5c56488b5f8c903a7" translate="yes" xml:space="preserve">
          <source>Sass</source>
          <target state="translated">Sass</target>
        </trans-unit>
        <trans-unit id="9f70cfec1604b298dcfbaec9575e55ba48ba5dbc" translate="yes" xml:space="preserve">
          <source>Sass, Less, or Stylus?</source>
          <target state="translated">Sass, Less 또는 Stylus?</target>
        </trans-unit>
        <trans-unit id="32e6e0b94d6167fe9b7fe89e42d7f5044ab699ac" translate="yes" xml:space="preserve">
          <source>Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun. The function will be run once and not on subsequent flushes unless &lt;code&gt;afterFlush&lt;/code&gt; is called again.</source>
          <target state="translated">무효화 된 모든 계산이 재실행 된 후 다음 플러시 중에 또는 현재 플러시 중에 함수가 호출되도록 예약합니다. &lt;code&gt;afterFlush&lt;/code&gt; 가 다시 호출 되지 않으면 함수는 한 번 실행되고 후속 플러시에서는 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d309def7c9266580fb73e9d47d1961225a2a23b7" translate="yes" xml:space="preserve">
          <source>Scope DOM lookups to the template instance</source>
          <target state="translated">템플릿 인스턴스에 대한 범위 DOM 조회</target>
        </trans-unit>
        <trans-unit id="883d1c30464c5133deb4650b36e619a4392cff51" translate="yes" xml:space="preserve">
          <source>Search on the &lt;a href=&quot;https://atmospherejs.com/&quot;&gt;Atmosphere website&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/&quot;&gt;Atmosphere 웹 사이트&lt;/a&gt; 에서 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3475e2db0d019565d1ca87758eec7edd62085a1" translate="yes" xml:space="preserve">
          <source>Searches for Meteor packages and releases, whose names contain the specified regular expression.</source>
          <target state="translated">이름에 지정된 정규식이 포함 된 Meteor 패키지 및 릴리스를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8ad30bba4b18ac4df7ce3a4a23bbaa04acebf666" translate="yes" xml:space="preserve">
          <source>Searching for packages</source>
          <target state="translated">패키지 검색</target>
        </trans-unit>
        <trans-unit id="3987f0061ea29708554b30785525952aebaf74a8" translate="yes" xml:space="preserve">
          <source>Secret API keys should never be stored in your source code at all, the next section will talk about how to handle them.</source>
          <target state="translated">비밀 API 키는 소스 코드에 전혀 저장하지 않아야합니다. 다음 섹션에서는이를 처리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="be0139dda44d098daa31eb14ef4dc6b673dec78e" translate="yes" xml:space="preserve">
          <source>Secret API keys.</source>
          <target state="translated">비밀 API 키.</target>
        </trans-unit>
        <trans-unit id="04c0eefaa17d751a2cf4b34f4c893ee8801f7ed7" translate="yes" xml:space="preserve">
          <source>Secret algorithms that a competitor could steal.</source>
          <target state="translated">경쟁자가 훔칠 수있는 비밀 알고리즘.</target>
        </trans-unit>
        <trans-unit id="d6cd8be97888a56174d431bff061bea19025c1b4" translate="yes" xml:space="preserve">
          <source>Secret business logic in your app should be located in code that is only loaded on the server. This means it is in a &lt;code&gt;server/&lt;/code&gt; directory of your app, in a package that is only included on the server, or in a file inside a package that was loaded only on the server.</source>
          <target state="translated">앱의 비밀 비즈니스 로직은 서버에만로드되는 코드에 있어야합니다. 이는 앱 의 &lt;code&gt;server/&lt;/code&gt; 디렉토리 , 서버 에만 포함 된 패키지 또는 서버에만로드 된 패키지 내부 파일에 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b3fc3b91ad7369046ee5d271ab3be72365042098" translate="yes" xml:space="preserve">
          <source>Secret server code</source>
          <target state="translated">비밀 서버 코드</target>
        </trans-unit>
        <trans-unit id="038f44881a0c82e1dacea7ffa6fa04b95a2574f3" translate="yes" xml:space="preserve">
          <source>Secure the data, not the UI - redirecting away from a client-side route does nothing for security, it&amp;rsquo;s just a nice UX feature.</source>
          <target state="translated">UI가 아닌 데이터 보안-클라이언트 측 경로에서 리디렉션하면 보안에 아무런 영향을 미치지 않으며 훌륭한 UX 기능입니다.</target>
        </trans-unit>
        <trans-unit id="7fc5094a6a529a06cf4de0f2c90b013709424e66" translate="yes" xml:space="preserve">
          <source>Securing API keys</source>
          <target state="translated">API 키 보안</target>
        </trans-unit>
        <trans-unit id="2d9658effc7c6ea9a9f1ccbf39d37f944b00b628" translate="yes" xml:space="preserve">
          <source>Securing a web application is all about understanding security domains and understanding the attack surface between these domains. In a Meteor app, things are pretty simple:</source>
          <target state="translated">웹 응용 프로그램 보안은 보안 도메인을 이해하고 이러한 도메인 간의 공격 영역을 이해하는 것입니다. Meteor 앱에서는 상황이 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="6c40431cdd5d0303effab46224badb7d49a79307" translate="yes" xml:space="preserve">
          <source>Security checklist</source>
          <target state="translated">보안 점검표</target>
        </trans-unit>
        <trans-unit id="d8b13bc4a3d44d1b0ed58cddefc6791d5719e4f0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Event-Maps&quot;&gt;Event Maps&lt;/a&gt; for a detailed description of the event map format and how event handling works in Meteor.</source>
          <target state="translated">이벤트 맵 형식에 대한 자세한 설명 및 Meteor에서 이벤트 처리 작동 방식에 대해서는 &lt;a href=&quot;#Event-Maps&quot;&gt;이벤트 맵&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fca69e387dff42155aded59f486ef2124f4d801b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#computation_oninvalidate&quot;&gt;&lt;em&gt;&lt;code&gt;computation&lt;/code&gt;&lt;/em&gt;&lt;code&gt;.onInvalidate&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">참조 &lt;a href=&quot;#computation_oninvalidate&quot;&gt;&lt;em&gt; &lt;code&gt;computation&lt;/code&gt; &lt;/em&gt; &lt;code&gt;.onInvalidate&lt;/code&gt; 을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="8237c3552d75dbb4739021a6a85deba2109fba55" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#view_firstnode&quot;&gt;&lt;code&gt;firstNode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#view_firstnode&quot;&gt; &lt;code&gt;firstNode()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37e7115ecc5bfc84b5f89c8fb51a441fa07bea44" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection&quot;&gt; the MongoDB docs&lt;/a&gt; for details of the nested field rules and array behavior.</source>
          <target state="translated">중첩 된 필드 규칙 및 배열 동작에 대한 자세한 내용 &lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection&quot;&gt;은 MongoDB 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbc90c39de6c7d8a216aa50ed76e78f5280cef8d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging#remote-debugging-on-android-with-chrome-devtools&quot;&gt;this article&lt;/a&gt; for instructions on how to remote debug your Android app with the Chrome DevTools.</source>
          <target state="translated">Chrome 개발자 도구를 사용하여 Android 앱을 원격으로 디버깅하는 방법에 대한 지침 은 &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/debug/remote-debugging/remote-debugging#remote-debugging-on-android-with-chrome-devtools&quot;&gt;이 도움말&lt;/a&gt; 을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="3126d8f08b9016ef673b8b2f6298400df86ef819" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;modules#CoffeeScript&quot;&gt;Modules &amp;raquo; Syntax &amp;raquo; CoffeeScript&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;modules#CoffeeScript&quot;&gt;모듈&amp;raquo;구문&amp;raquo;CoffeeScript를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b2ed8790ccbf6708fcfd498fc66ed11a6130c32" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#BIND-IP&quot;&gt;&lt;code&gt;BIND_IP&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#BIND-IP&quot;&gt; &lt;code&gt;BIND_IP&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e0bf2b379fb150ea19626531e11018fc722f6b5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#PORT&quot;&gt;&lt;code&gt;PORT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#PORT&quot;&gt; &lt;code&gt;PORT&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e770d141e06088557ee2818eb57a13235efb46d" translate="yes" xml:space="preserve">
          <source>See an example of a linting plugin implemented in Core: &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/jshint&quot;&gt;jshint&lt;/a&gt;.</source>
          <target state="translated">Core : &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/jshint&quot;&gt;jshint&lt;/a&gt; 에서 구현 된 linting 플러그인의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28919346ab02e0a8e42e01b3f12218f2a79d986b" translate="yes" xml:space="preserve">
          <source>See description of &lt;a href=&quot;#accounts_onloginfailure&quot;&gt;AccountsCommon#onLoginFailure&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#accounts_onloginfailure&quot;&gt;AccountsCommon # onLoginFailure에&lt;/a&gt; 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f3b5f3d2e6eefc9bf0b79711aa4f32bb7060bb4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/&quot;&gt;전체 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca39bd511ac60dac08f0cb572980df4db83fb9bd" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/update/&quot;&gt;full list of modifiers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/update/&quot;&gt;수정 자의 전체 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9faed082e8248ab5f20c14fb4ed9379f5f85806d" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#creating-a-reactive-value-using-trackerdependency&quot;&gt;Tracker manual&lt;/a&gt; to learn how to create a reactive data source using &lt;code&gt;Tracker.Dependency&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tracker.Dependency&lt;/code&gt; 를 사용하여 반응 형 데이터 소스를 만드는 방법을 알아 보려면 &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#creating-a-reactive-value-using-trackerdependency&quot;&gt;Tracker 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35731614430df115b1c5334503360571cdaa7378" translate="yes" xml:space="preserve">
          <source>See the Docs: &lt;a href=&quot;https://docs.meteor.com/packages/modules.html#CoffeeScript&quot;&gt;Modules &amp;raquo; Syntax &amp;raquo; CoffeeScript&lt;/a&gt;</source>
          <target state="translated">문서 : &lt;a href=&quot;https://docs.meteor.com/packages/modules.html#CoffeeScript&quot;&gt;모듈&amp;raquo;구문&amp;raquo;CoffeeScript를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4faf6de68d5021fd48da0a9f0aaf239dabb4e520" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;https://atmospherejs.com/universe/i18n&quot;&gt;&lt;code&gt;universe:i18n&lt;/code&gt;&lt;/a&gt; for additional options and configuration.</source>
          <target state="translated">추가 옵션 및 구성 은 &lt;a href=&quot;https://atmospherejs.com/universe/i18n&quot;&gt; &lt;code&gt;universe:i18n&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c20b774264ddb1550c65438747330633d99bbf5" translate="yes" xml:space="preserve">
          <source>Select your app origin</source>
          <target state="translated">앱 출처를 선택하십시오</target>
        </trans-unit>
        <trans-unit id="cfb0ea17037b0734a233d08579e75e88ef495131" translate="yes" xml:space="preserve">
          <source>Select your distribution</source>
          <target state="translated">배포판을 선택하십시오</target>
        </trans-unit>
        <trans-unit id="16919af682dae2171fb05bf9148f48ba20650209" translate="yes" xml:space="preserve">
          <source>Semantic versioning and version constraints</source>
          <target state="translated">시맨틱 버전 관리 및 버전 제약</target>
        </trans-unit>
        <trans-unit id="08414b570a795cc81b6907f83b267ef3f81cf7ec" translate="yes" xml:space="preserve">
          <source>Send an HTTP &lt;code&gt;DELETE&lt;/code&gt; request. Equivalent to calling &lt;a href=&quot;#http_call&quot;&gt;&lt;code&gt;HTTP.call&lt;/code&gt;&lt;/a&gt; with &quot;DELETE&quot; as the first argument. (Named &lt;code&gt;del&lt;/code&gt; to avoid conflict with the Javascript keyword &lt;code&gt;delete&lt;/code&gt;)</source>
          <target state="translated">HTTP &lt;code&gt;DELETE&lt;/code&gt; 요청을 보냅니다 . 첫 번째 인수로 &quot;DELETE&quot;를 사용하여 &lt;a href=&quot;#http_call&quot;&gt; &lt;code&gt;HTTP.call&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 . ( Javascript 키워드 &lt;code&gt;delete&lt;/code&gt; 와의 충돌을 피하기 위해 &lt;code&gt;del&lt;/code&gt; 으로 명명 됨 )</target>
        </trans-unit>
        <trans-unit id="20153162231adf87b39564be97298b927720da54" translate="yes" xml:space="preserve">
          <source>Send an HTTP &lt;code&gt;GET&lt;/code&gt; request. Equivalent to calling &lt;a href=&quot;#http_call&quot;&gt;&lt;code&gt;HTTP.call&lt;/code&gt;&lt;/a&gt; with &quot;GET&quot; as the first argument.</source>
          <target state="translated">HTTP &lt;code&gt;GET&lt;/code&gt; 요청을 보냅니다 . 첫 번째 인수로 &quot;GET&quot;을 사용하여 &lt;a href=&quot;#http_call&quot;&gt; &lt;code&gt;HTTP.call&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="17d83a070e4a780970e424a16209aa6d3faf03e9" translate="yes" xml:space="preserve">
          <source>Send an HTTP &lt;code&gt;POST&lt;/code&gt; request. Equivalent to calling &lt;a href=&quot;#http_call&quot;&gt;&lt;code&gt;HTTP.call&lt;/code&gt;&lt;/a&gt; with &quot;POST&quot; as the first argument.</source>
          <target state="translated">HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 보냅니다 . 첫 번째 인수로 &quot;POST&quot;를 사용하여 &lt;a href=&quot;#http_call&quot;&gt; &lt;code&gt;HTTP.call&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="31a0c499286858733a515b188759317d59e133a8" translate="yes" xml:space="preserve">
          <source>Send an HTTP &lt;code&gt;PUT&lt;/code&gt; request. Equivalent to calling &lt;a href=&quot;#http_call&quot;&gt;&lt;code&gt;HTTP.call&lt;/code&gt;&lt;/a&gt; with &quot;PUT&quot; as the first argument.</source>
          <target state="translated">HTTP &lt;code&gt;PUT&lt;/code&gt; 요청을 보냅니다 . 첫 번째 인수로 &quot;PUT&quot;을 사용하여 &lt;a href=&quot;#http_call&quot;&gt; &lt;code&gt;HTTP.call&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dc516ab03aa311272837ca65647302297044506e" translate="yes" xml:space="preserve">
          <source>Send an email with a link the user can use to reset their password.</source>
          <target state="translated">사용자가 비밀번호를 재설정하는 데 사용할 수있는 링크가 포함 된 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="6bcd556d8c1771306a449dbaf461c27e109b3f81" translate="yes" xml:space="preserve">
          <source>Send an email with a link the user can use to set their initial password.</source>
          <target state="translated">사용자가 초기 비밀번호를 설정하는 데 사용할 수있는 링크가 포함 된 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="f7312b1839069ebf1c7630d998a4c33491b9ee51" translate="yes" xml:space="preserve">
          <source>Send an email with a link the user can use verify their email address.</source>
          <target state="translated">사용자가 이메일 주소 확인에 사용할 수있는 링크가 포함 된 이메일을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6a6d723fe408c120cda7b79a89b0b18e53bb7c16" translate="yes" xml:space="preserve">
          <source>Send an email. Throws an &lt;code&gt;Error&lt;/code&gt; on failure to contact mail server or if mail server returns an error. All fields should match &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; specification.</source>
          <target state="translated">이메일을 보내다. 오류 &lt;code&gt;Error&lt;/code&gt; 오류 접촉 메일 서버 나 메일 서버가 반환하면 실패합니다. 모든 필드는 &lt;a href=&quot;http://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; 사양 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="39cdfdfe98a38bb647c25a88e3a7042ce30db8ce" translate="yes" xml:space="preserve">
          <source>Send an email. Throws an &lt;code&gt;Error&lt;/code&gt; on failure to contact mail server or if mail server returns an error. All fields should match &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a524f10d294b2eb2df21525271e4188dac7d8a" translate="yes" xml:space="preserve">
          <source>Sending the email</source>
          <target state="translated">이메일 보내기</target>
        </trans-unit>
        <trans-unit id="52c38c5fd40d268aa487131b6f119ffd702edd4a" translate="yes" xml:space="preserve">
          <source>Serialize a value to a string. For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as &lt;code&gt;JSON.stringify&lt;/code&gt;.</source>
          <target state="translated">값을 문자열로 직렬화하십시오. EJSON 값의 경우 직렬화는 값을 완전히 나타냅니다. EJB가 아닌 값의 경우 &lt;code&gt;JSON.stringify&lt;/code&gt; 와 동일한 방식으로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bb054eb9fa646925ae3ecd1baba7a3b511c9efa" translate="yes" xml:space="preserve">
          <source>Serialize an EJSON-compatible value into its plain JSON representation.</source>
          <target state="translated">EJSON 호환 값을 일반 JSON 표현으로 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="c429afcde389802f396daaa661ab40e4cdc0ee78" translate="yes" xml:space="preserve">
          <source>Serialize this instance into a JSON-compatible value.</source>
          <target state="translated">이 인스턴스를 JSON 호환 값으로 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="7dcf6c8feacbe81988ca71309fcb7379ae28c4fa" translate="yes" xml:space="preserve">
          <source>Served files</source>
          <target state="translated">파일 제공</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="cb46f37fe9212a9315e731389dcec2de84112a2e" translate="yes" xml:space="preserve">
          <source>Server Connections</source>
          <target state="translated">서버 연결</target>
        </trans-unit>
        <trans-unit id="4ff6540c25bde7085cf0d2d1e9575cb74d3e0915" translate="yes" xml:space="preserve">
          <source>Server Rendering</source>
          <target state="translated">서버 렌더링</target>
        </trans-unit>
        <trans-unit id="63eebe3062d457aa6c6d748fdc54a598dd71bd88" translate="yes" xml:space="preserve">
          <source>Server Routing for API access</source>
          <target state="translated">API 액세스를위한 서버 라우팅</target>
        </trans-unit>
        <trans-unit id="6844d311dc2e8f093fdbeca96aeed32c5fc7bfa8" translate="yes" xml:space="preserve">
          <source>Server Side Routing</source>
          <target state="translated">서버 측 라우팅</target>
        </trans-unit>
        <trans-unit id="d95d51e76282fecac3f98c5d1b83a1688ac7db86" translate="yes" xml:space="preserve">
          <source>Server [Not in build plugins]</source>
          <target state="translated">서버 [빌드 플러그인에 없음]</target>
        </trans-unit>
        <trans-unit id="f79ff6c35a336ad293fb67e335b11e74f356ca6e" translate="yes" xml:space="preserve">
          <source>Server example:</source>
          <target state="translated">서버 예 :</target>
        </trans-unit>
        <trans-unit id="5c6b62c1e86c6ed24f03c3db81c390e5eae031f2" translate="yes" xml:space="preserve">
          <source>Server-side collections</source>
          <target state="translated">서버 측 컬렉션</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="f7f1997c6cd1aa051279675742272a956e7db628" translate="yes" xml:space="preserve">
          <source>Session</source>
          <target state="translated">Session</target>
        </trans-unit>
        <trans-unit id="a9fb80e899597e03753ba9424e22c41fd1dd96d9" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;ANDROID_HOME&lt;/code&gt; and add the tools directories to your &lt;code&gt;PATH&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ANDROID_HOME&lt;/code&gt; 을 설정 하고 도구 디렉토리를 &lt;code&gt;PATH&lt;/code&gt; 에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a466d1f1e10272a5fcd913e3964147f01a33bccc" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; to an integer representing the number of proxies in front of your server. For example, you&amp;rsquo;d set it to &lt;code&gt;1&lt;/code&gt; when your server was behind one proxy.</source>
          <target state="translated">&lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; 를 서버 앞의 프록시 수를 나타내는 정수로 설정 하십시오. 예를 들어, 서버가 하나의 프록시 뒤에 있으면 &lt;code&gt;1&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a94ff804efb8542bacaad0421a8624ae76e6115f" translate="yes" xml:space="preserve">
          <source>Set a new access rule based on origin domain for your app. By default your application has a limited list of servers it can contact. Use this method to extend this list.</source>
          <target state="translated">앱의 오리진 도메인을 기반으로 새 액세스 규칙을 설정하십시오. 기본적으로 응용 프로그램은 연결할 수있는 서버 목록이 제한되어 있습니다. 이 방법을 사용하여이 목록을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="474a8790c6be462a53b787ddbebe6482f08ceb9c" translate="yes" xml:space="preserve">
          <source>Set a variable in the session if it hasn't been set before. Otherwise works exactly the same as &lt;a href=&quot;#session_set&quot;&gt;&lt;code&gt;Session.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전에 설정하지 않은 경우 세션에서 변수를 설정하십시오. 그렇지 않으면 &lt;a href=&quot;#session_set&quot;&gt; &lt;code&gt;Session.set&lt;/code&gt; &lt;/a&gt; 과 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="dd6a0ab02ea3becfa235cb520e3d0093728b5d68" translate="yes" xml:space="preserve">
          <source>Set a variable in the session. Notify any listeners that the value has changed (eg: redraw templates, and rerun any &lt;a href=&quot;#tracker_autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt; computations, that called &lt;a href=&quot;#session_get&quot;&gt;&lt;code&gt;Session.get&lt;/code&gt;&lt;/a&gt; on this &lt;code&gt;key&lt;/code&gt;.)</source>
          <target state="translated">세션에서 변수를 설정하십시오. 리스너에게 값이 변경되었음을 알립니다 (예 : 템플릿 다시 그리기 및 이 &lt;code&gt;key&lt;/code&gt; &lt;a href=&quot;#session_get&quot;&gt; &lt;code&gt;Session.get&lt;/code&gt; &lt;/a&gt; 이라는 &lt;a href=&quot;#tracker_autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; &lt;/a&gt; 계산을 다시 실행 ).</target>
        </trans-unit>
        <trans-unit id="0868a117b5fa798b2b6a975c7fb0b0668e990d9f" translate="yes" xml:space="preserve">
          <source>Set error message text when method or subscription rate limit exceeded.</source>
          <target state="translated">방법 또는 구독 비율 제한을 초과 한 경우 오류 메시지 텍스트를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2100d34444fb4ce91c64431d0bbe6e89bc8d4f9d" translate="yes" xml:space="preserve">
          <source>Set global accounts options.</source>
          <target state="translated">글로벌 계정 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f8a11d8df4e203ebab3704f29dceced5634e310c" translate="yes" xml:space="preserve">
          <source>Set restrictions on new user creation.</source>
          <target state="translated">새로운 사용자 생성에 대한 제한을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c097141f5e58fd69e73071834b48a00b9076cff2" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;ANDROID_HOME&lt;/code&gt; environment variable to the location of the Android SDK. If you&amp;rsquo;ve used the Android Studio setup wizard, it should be installed in &lt;code&gt;~/Library/Android/sdk&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;ANDROID_HOME&lt;/code&gt; 환경 변수를 Android SDK의 위치로 설정하십시오 . Android Studio 설정 마법사를 사용한 경우 기본적으로 &lt;code&gt;~/Library/Android/sdk&lt;/code&gt; 에 설치되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab0539029a8206c3046c0b94b0c2e688628bf02d" translate="yes" xml:space="preserve">
          <source>Set the build-time configuration for a Cordova plugin.</source>
          <target state="translated">Cordova 플러그인의 빌드 시간 구성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8efa0fb25a7b782d6829b81e27ae9b298fdd4e27" translate="yes" xml:space="preserve">
          <source>Set the fields of the object by assigning to them:</source>
          <target state="translated">객체를 할당하여 객체의 필드를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a880a6457ca5972ffde0f57dd7c9655711778c7a" translate="yes" xml:space="preserve">
          <source>Set the icons for your mobile app.</source>
          <target state="translated">모바일 앱의 아이콘을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="84e76ad2c58d1d3ab8eb13bf39c7f285bbd71643" translate="yes" xml:space="preserve">
          <source>Set the launch screen images for your mobile app.</source>
          <target state="translated">모바일 앱의 시작 화면 이미지를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="aeec94c0f0217937f531870de6304f3bb88a90c4" translate="yes" xml:space="preserve">
          <source>Set the logged in user.</source>
          <target state="translated">로그인 한 사용자를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7d9aa1392649cd956c7be97715dd43ddd9af3c48" translate="yes" xml:space="preserve">
          <source>Set this to however many number of proxies you have running before your Meteor application. For example, if have an NGINX server acting as a proxy before your Meteor application, you would set &lt;code&gt;HTTP_FORWARDED_COUNT=1&lt;/code&gt;. If you have a load balancer in front of that NGINX server, the count is 2.</source>
          <target state="translated">그러나 Meteor 응용 프로그램 이전에 실행중인 많은 프록시 수로 설정하십시오. 예를 들어, Meteor 애플리케이션 이전에 NGINX 서버가 프록시 역할을하는 경우 &lt;code&gt;HTTP_FORWARDED_COUNT=1&lt;/code&gt; 을 설정 합니다. 해당 NGINX 서버 앞에로드 밸런서가있는 경우 개수는 2입니다.</target>
        </trans-unit>
        <trans-unit id="8f1151de0b066675a643bc513935ade939a649f1" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;false&lt;/code&gt; to skip setting up the mutation methods that enable insert/update/remove from client code. Default &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">클라이언트 코드에서 삽입 / 업데이트 / 제거를 활성화하는 변이 방법 설정을 건너 뛰 려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="84277186a7e44add9f6ed1de93310c155b55fad6" translate="yes" xml:space="preserve">
          <source>Set up &lt;a href=&quot;https://atmospherejs.com/meteor/browser-policy&quot;&gt;browser policy&lt;/a&gt;, but know that not all browsers support it so it just provides an extra layer of security to users with modern browsers.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/meteor/browser-policy&quot;&gt;브라우저 정책을&lt;/a&gt; 설정 하되 모든 브라우저가이를 지원하는 것은 아니므로 최신 브라우저를 사용하는 사용자에게 추가 보안 계층을 제공 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="26059f78b231dd38e5f8a1611adee67997509f14" translate="yes" xml:space="preserve">
          <source>Set up Sublime Text for ES2015</source>
          <target state="translated">ES2015에 대한 숭고한 텍스트 설정</target>
        </trans-unit>
        <trans-unit id="052877a075af7b6c59cc675a1ae15a112a6a8b82" translate="yes" xml:space="preserve">
          <source>Set up your tests with the &lt;code&gt;Package.onTest&lt;/code&gt; handler, which has an interface that&amp;rsquo;s parallel to that of the &lt;code&gt;onUse&lt;/code&gt; handler. The tests will need to depend on the package that you have just created. For example, if your package is the &lt;code&gt;email&lt;/code&gt; package, you have to call &lt;code&gt;api.use('email')&lt;/code&gt; in order to test the package.</source>
          <target state="translated">&lt;code&gt;onUse&lt;/code&gt; 핸들러 와 유사한 인터페이스를 가진 &lt;code&gt;Package.onTest&lt;/code&gt; 핸들러로 테스트를 설정하십시오 . 테스트는 방금 생성 한 패키지에 따라 달라집니다. 예를 들어 패키지가 &lt;code&gt;email&lt;/code&gt; 패키지 인 경우 패키지를 테스트하려면 &lt;code&gt;api.use('email')&lt;/code&gt; 을 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec2afb77e48cf64faaeca8638039bd986cf1c758" translate="yes" xml:space="preserve">
          <source>Set your mobile app's core configuration information.</source>
          <target state="translated">모바일 앱의 핵심 구성 정보를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="9dcf84601ce28ccf34d61e589b76264b91256c79" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;Meteor.isAppTest&lt;/code&gt; flag to be true (instead of the &lt;code&gt;Meteor.isTest&lt;/code&gt; flag).</source>
          <target state="translated">세트 &lt;code&gt;Meteor.isAppTest&lt;/code&gt; (대신의 플래그가 true로 &lt;code&gt;Meteor.isTest&lt;/code&gt; 플래그).</target>
        </trans-unit>
        <trans-unit id="f8080b657ede4e6b55bfd342fc170a0915f7f41c" translate="yes" xml:space="preserve">
          <source>Sets the &lt;code&gt;Meteor.isTest&lt;/code&gt; flag to be true.</source>
          <target state="translated">&lt;code&gt;Meteor.isTest&lt;/code&gt; 플래그를 true로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="904bbba587b1c8ad2dad8846ac67f52887a20931" translate="yes" xml:space="preserve">
          <source>Sets the current value of the ReactiveVar, invalidating the Computations that called &lt;code&gt;get&lt;/code&gt; if &lt;code&gt;newValue&lt;/code&gt; is different from the old value.</source>
          <target state="translated">&lt;code&gt;newValue&lt;/code&gt; 가 이전 값과 다른 경우 &lt;code&gt;get&lt;/code&gt; 을 호출 한 계산을 무효화하여 ReactiveVar의 현재 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="54a7c68e20d4d835028e20600b87f45d77872794" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;ANDROID_HOME&lt;/code&gt; and adding the tools directories to your &lt;code&gt;PATH&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ANDROID_HOME&lt;/code&gt; 설정 및 &lt;code&gt;PATH&lt;/code&gt; 에 도구 디렉토리 추가</target>
        </trans-unit>
        <trans-unit id="eed34e908902076e9264e4ad7813b5025e3853c8" translate="yes" xml:space="preserve">
          <source>Setting plugin parameters</source>
          <target state="translated">플러그인 매개 변수 설정</target>
        </trans-unit>
        <trans-unit id="1ad1f5bffa09f930716cc3b1a1176a7dc0396b01" translate="yes" xml:space="preserve">
          <source>Setting tag attributes via helpers (e.g. &lt;code&gt;&amp;lt;div {{attributes}}&amp;gt;&lt;/code&gt;) is a neat tool and has some precedence rules that make it more useful. Specifically, when you use it more than once on a given element, the attributes are composed (rather than the second set of attributes simply replacing the first). So you can use one helper to set one set of attributes and a second to set another. For instance:</source>
          <target state="translated">도우미 (예 : &lt;code&gt;&amp;lt;div {{attributes}}&amp;gt;&lt;/code&gt; ) 를 통해 태그 속성을 설정 하는 것은 깔끔한 도구이며 더 유용한 우선 순위 규칙이 있습니다. 특히, 주어진 요소에서 두 번 이상 사용하면 속성이 구성됩니다 (두 번째 속성 세트 대신 단순히 첫 번째 속성을 대체 함). 따라서 하나의 도우미를 사용하여 하나의 속성 세트를 설정하고 다른 하나는 다른 속성 세트를 설정할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="37223c70fe20a90e7164defe75b8d260faeb9932" translate="yes" xml:space="preserve">
          <source>Setting up SSL</source>
          <target state="translated">SSL 설정</target>
        </trans-unit>
        <trans-unit id="6d18d6bf5a6d7f360ff22f5759b370e85005149d" translate="yes" xml:space="preserve">
          <source>Settings are persistent. When you redeploy your app, the old value will be preserved unless you explicitly pass new settings using the &lt;code&gt;--settings&lt;/code&gt; option. To unset &lt;code&gt;Meteor.settings&lt;/code&gt;, pass an empty settings file.</source>
          <target state="translated">설정은 영구적입니다. 앱을 재배치 할 때 &lt;code&gt;--settings&lt;/code&gt; 옵션을 사용하여 새 설정을 명시 적으로 전달하지 않으면 이전 값이 유지됩니다 . &lt;code&gt;Meteor.settings&lt;/code&gt; 설정을 해제하려면 빈 설정 파일을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="695213abc06fa197ed4a73c115863be4ecf6d1de" translate="yes" xml:space="preserve">
          <source>Settings on the client</source>
          <target state="translated">클라이언트 설정</target>
        </trans-unit>
        <trans-unit id="09a30596256b09bb9b3c7a1dc78e226ec4815ab1" translate="yes" xml:space="preserve">
          <source>Settings should be used to set environment (i.e. staging vs production) specific things, like the access token and secret used to connect to Google. These settings will not change between any given process running your application in the given environment.</source>
          <target state="translated">설정은 액세스 토큰 및 Google에 연결하는 데 사용되는 비밀과 같은 환경 (예 : 준비 대 프로덕션) 관련 사항을 설정하는 데 사용해야합니다. 이러한 설정은 지정된 환경에서 응용 프로그램을 실행하는 지정된 프로세스간에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f4c87116412e85e367eab789b17b3511b068718" translate="yes" xml:space="preserve">
          <source>Sharing accounts</source>
          <target state="translated">계정 공유</target>
        </trans-unit>
        <trans-unit id="9f91705fe5b54d824df8460bb342771f79b84b37" translate="yes" xml:space="preserve">
          <source>Sharing code</source>
          <target state="translated">코드 공유</target>
        </trans-unit>
        <trans-unit id="a3d520b6d95896465f450679cdf0a1cc5a9d6830" translate="yes" xml:space="preserve">
          <source>Sharing data</source>
          <target state="translated">데이터 공유</target>
        </trans-unit>
        <trans-unit id="82bae8b29285c471dbf7aad0461857bd5f5609fe" translate="yes" xml:space="preserve">
          <source>Showing &lt;em&gt;all&lt;/em&gt; the items - no more available.</source>
          <target state="translated">더 이상 사용할 수없는 &lt;em&gt;모든&lt;/em&gt; 항목 표시</target>
        </trans-unit>
        <trans-unit id="5b07095fbfec182b98868bfa467c9c53e773d170" translate="yes" xml:space="preserve">
          <source>Showing &lt;em&gt;no&lt;/em&gt; items because none exist.</source>
          <target state="translated">존재 &lt;em&gt;하지&lt;/em&gt; 않기 때문에 항목이 표시 &lt;em&gt;되지&lt;/em&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f5912d5929b0363365aadb1d03bdaa4bebbc472" translate="yes" xml:space="preserve">
          <source>Showing a subset of the items with more available.</source>
          <target state="translated">더 많은 항목이있는 항목의 하위 집합을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee89e4636392433cb94e5d06ba98ed9577491d32" translate="yes" xml:space="preserve">
          <source>Showing a subset of the items with more loading.</source>
          <target state="translated">로드가 많은 항목의 하위 집합을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="22a285b02a4fdc67c5be75eace7e654455038f4a" translate="yes" xml:space="preserve">
          <source>Showing placeholders</source>
          <target state="translated">자리 표시 자 표시</target>
        </trans-unit>
        <trans-unit id="fd0a4616d2b74eb5364b45519c2bae5d3a547e97" translate="yes" xml:space="preserve">
          <source>Shows more information about a specific package or release: name, summary, the usernames of its maintainers, and, if specified, its homepage and git URL.</source>
          <target state="translated">특정 패키지 또는 릴리스에 대한 자세한 정보 (이름, 요약, 관리자의 사용자 이름 및 지정된 경우 홈페이지 및 자식 URL)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="95480b4946cf0f4acacff6221f3354c159cae878" translate="yes" xml:space="preserve">
          <source>Shrinkpack</source>
          <target state="translated">Shrinkpack</target>
        </trans-unit>
        <trans-unit id="a1ca0f23b735dfbb9ffbf04aed8e726e817b949d" translate="yes" xml:space="preserve">
          <source>Similar to the way we cleared the database using a method in the &lt;code&gt;beforeEach&lt;/code&gt; in the &lt;a href=&quot;#test-data&quot;&gt;test data&lt;/a&gt; section above, we can call a method to do that before running our tests. In the case of our routing tests, we&amp;rsquo;ve used a file called &lt;a href=&quot;https://github.com/meteor/todos/blob/master/imports/api/generate-data.app-tests.js&quot;&gt;&lt;code&gt;imports/api/generate-data.app-tests.js&lt;/code&gt;&lt;/a&gt; which defines this method (and will only be loaded in full app test mode, so is not available in general!):</source>
          <target state="translated">위 의 &lt;a href=&quot;#test-data&quot;&gt;테스트 데이터&lt;/a&gt; 섹션 에있는 &lt;code&gt;beforeEach&lt;/code&gt; 의 메소드를 사용하여 데이터베이스를 지우는 방식과 유사하게 테스트 를 실행하기 전에 메소드를 호출하여이를 수행 할 수 있습니다. 라우팅 테스트의 경우이 메소드를 정의하는 &lt;a href=&quot;https://github.com/meteor/todos/blob/master/imports/api/generate-data.app-tests.js&quot;&gt; &lt;code&gt;imports/api/generate-data.app-tests.js&lt;/code&gt; &lt;/a&gt; 라는 파일을 사용 했으며 전체 앱 테스트 모드에서만로드되므로 일반적으로 사용할 수 없습니다 !) :</target>
        </trans-unit>
        <trans-unit id="ff77663843c2e4f0390094118d8381f2acb6aecb" translate="yes" xml:space="preserve">
          <source>Similarly, gaps in the platform highlighted by the guide can often be plugged by &lt;strong&gt;community packages&lt;/strong&gt;; we hope that if you see an opportunity to improve the Meteor workflow by writing a package, that you take it! If you&amp;rsquo;re not sure how best to design or architect your package, reach out on the forums and start a discussion.</source>
          <target state="translated">마찬가지로, 가이드에 의해 강조된 플랫폼의 갭은 종종 &lt;strong&gt;커뮤니티 패키지에&lt;/strong&gt; 의해 막힐 수 있습니다 . 패키지를 작성하여 Meteor 워크 플로우를 개선 할 수있는 기회가 있다면이를 활용하시기 바랍니다. 패키지를 디자인하거나 설계하는 가장 좋은 방법을 모르는 경우 포럼에 문의하여 토론을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="abf9deaee8187b606eb185f33cf375f31c4e5d42" translate="yes" xml:space="preserve">
          <source>Simple integration test</source>
          <target state="translated">간단한 통합 테스트</target>
        </trans-unit>
        <trans-unit id="8ee5ce85efcdb07beb3331674001255221f6b6d8" translate="yes" xml:space="preserve">
          <source>Since Meteor apps are often written in a style that puts client and server code together, it&amp;rsquo;s extra important to be aware what is running on the client, what is running on the server, and what the boundaries are. Here&amp;rsquo;s a complete list of places security checks need to be done in a Meteor app:</source>
          <target state="translated">Meteor 앱은 종종 클라이언트와 서버 코드를 결합하는 스타일로 작성되기 때문에 클라이언트에서 실행중인 항목, 서버에서 실행중인 대상 및 경계가 무엇인지 알고 있어야합니다. 다음은 Meteor 앱에서 보안 검사를 수행해야하는 전체 장소 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8f539db13811192386c80432d7a15e0bd1abffdc" translate="yes" xml:space="preserve">
          <source>Since Meteor uses client-side rendering for your app&amp;rsquo;s UI, all of your HTML code, UI components, and templates need to be compiled to JavaScript. There are a few options at your disposal to write your UI code.</source>
          <target state="translated">Meteor는 앱 UI에 클라이언트 측 렌더링을 사용하므로 모든 HTML 코드, UI 구성 요소 및 템플릿을 JavaScript로 컴파일해야합니다. UI 코드를 작성할 수있는 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e66afc4878e945e4c4e6fda186ef65128d9a743e" translate="yes" xml:space="preserve">
          <source>Since Methods can work as general purpose RPCs, they can also be used to fetch data instead of publications. There are some advantages and some disadvantages to this approach compared with loading data through publications, and at the end of the day we recommend always using publications to load data.</source>
          <target state="translated">메서드는 범용 RPC로 작동 할 수 있으므로 게시 대신 데이터를 가져 오는 데 사용할 수도 있습니다. 게시를 통해 데이터를로드하는 것과 비교할 때이 방법에는 몇 가지 장점과 단점이 있으며 하루 종일 데이터를로드하는 데 항상 게시를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6baeb3784a3d4fed12ee64f5f10e864703c707c" translate="yes" xml:space="preserve">
          <source>Since Spacebars templates are always global, can&amp;rsquo;t be imported and exported as modules, and need to have names that are completely unique across the whole app, we recommend naming your Blaze templates with the full path to the namespace, separated by underscores. Underscores are a great choice in this case because then you can easily type the name of the template as one symbol in JavaScript.</source>
          <target state="translated">스페이스 바 템플릿은 항상 전역 적이며 모듈로 가져오고 내보낼 수 없으며 전체 앱에서 완전히 고유 한 이름이 필요하므로 네임 스페이스에 대한 전체 경로를 밑줄로 구분하여 Blaze 템플릿의 이름을 지정하는 것이 좋습니다. 이 경우 밑줄은 큰 선택입니다. 그러면 JavaScript에서 템플릿 이름을 하나의 심볼로 쉽게 입력 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bfe3aa227f534fa3a585127756ec38d283cd1583" translate="yes" xml:space="preserve">
          <source>Since bundle analysis is only truly accurate on a minified bundle and minification does not take place during development (as it is a complex and CPU-intensive process which would substantially slow down normal development) this package must be used in conjunction with the &lt;code&gt;--production&lt;/code&gt; flag to the &lt;code&gt;meteor&lt;/code&gt; tool to simulate production bundling and enable minification.</source>
          <target state="translated">번들 분석은 축소 된 번들에서만 실제로 정확하고 개발 중에 최소화가 발생하지 않기 때문에 (정상적인 개발을 상당히 느리게하는 복잡하고 CPU 집약적 인 프로세스이므로)이 패키지는 &lt;code&gt;--production&lt;/code&gt; 과 함께 사용해야합니다. &lt;code&gt;meteor&lt;/code&gt; 도구에 플래그를 지정하여 생산 번들링을 시뮬레이션하고 축소를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8a6d6cf77b1b1598e37271bd0e760bb53273f4c3" translate="yes" xml:space="preserve">
          <source>Since the API allows build plugins to process multiple files at once, we encourage package authors to implement at least some in-memory caching for their plugins. Using the &lt;code&gt;getSourceHash&lt;/code&gt; function for linters and compilers will allow quick incremental recompilations if the file is not reprocessed even when the contents didn&amp;rsquo;t change.</source>
          <target state="translated">API를 사용하면 빌드 플러그인이 여러 파일을 한 번에 처리 할 수 ​​있으므로 패키지 작성자는 플러그인에 대해 적어도 일부 메모리 내 캐싱을 구현하는 것이 좋습니다. linter 및 컴파일러에 &lt;code&gt;getSourceHash&lt;/code&gt; 함수를 사용하면 내용이 변경되지 않은 경우에도 파일이 재 처리되지 않으면 빠른 증분 재 컴파일이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f7b527a0552c1cb5ce2704935c37a29309653c8c" translate="yes" xml:space="preserve">
          <source>Since the build plugins run as part of the Meteor tool, they follow the same file-system access convention - all file system paths always look like a Unix path: using forward slashes and having a root at &amp;lsquo;/&amp;lsquo;, even on Windows. For example: paths &lt;code&gt;/usr/bin/program&lt;/code&gt; and &lt;code&gt;/C/Program Files/Program/program.exe&lt;/code&gt; are valid paths, and &lt;code&gt;C:\Program Files\Program\program.exe&lt;/code&gt; is not.</source>
          <target state="translated">빌드 플러그인은 Meteor 도구의 일부로 실행되므로 동일한 파일 시스템 액세스 규칙을 따릅니다. 모든 파일 시스템 경로는 항상 유닉스 경로처럼 보입니다 : Windows에서도 슬래시를 사용하고 '/'에 루트가 있습니다. 예를 들면 다음과 같습니다. 경로 &lt;code&gt;/usr/bin/program&lt;/code&gt; 및 &lt;code&gt;/C/Program Files/Program/program.exe&lt;/code&gt; 는 유효한 경로이고 &lt;code&gt;C:\Program Files\Program\program.exe&lt;/code&gt; 는 유효 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7092d3e5fdb4d89bd9a552d42476f77488b8063" translate="yes" xml:space="preserve">
          <source>Since this is a new feature introduced in Meteor 1.3, you will find a lot of code online that uses the older, more centralized conventions built around packages and apps declaring global symbols. This old system still works, so to opt-in to the new module system, code must be placed inside the &lt;code&gt;imports/&lt;/code&gt; directory in your application. We expect a future release of Meteor will turn on modules by default for all code, because this is more aligned with how developers in the wider JavaScript community write their code.</source>
          <target state="translated">이 기능은 Meteor 1.3에 도입 된 새로운 기능이므로 글로벌 심볼을 선언하는 패키지 및 앱을 중심으로 구축 된 이전의 중앙 집중식 규칙을 사용하는 많은 코드를 온라인에서 찾을 수 있습니다. 이 오래된 시스템은 여전히 ​​작동하므로 새 모듈 시스템을 선택하려면 응용 프로그램 의 &lt;code&gt;imports/&lt;/code&gt; 디렉토리 안에 코드를 배치해야합니다 . 향후 Meteor 릴리스는 모든 코드에 대해 기본적으로 모듈을 켤 것으로 예상됩니다. 이는 더 넓은 JavaScript 커뮤니티의 개발자가 코드를 작성하는 방법과 더 일치하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dbb4f7251d1ad0c7469904a610a47e90fb808811" translate="yes" xml:space="preserve">
          <source>Smart components</source>
          <target state="translated">스마트 컴포넌트</target>
        </trans-unit>
        <trans-unit id="39c9dbb5b98a8e8fd343b869bae6f0ed09e4ad60" translate="yes" xml:space="preserve">
          <source>So a subscription can be thought of as a set of data that changes over time. Typically, the result of this is that a subscription &amp;ldquo;bridges&amp;rdquo; a &lt;a href=&quot;collections#server-collections&quot;&gt;server-side MongoDB collection&lt;/a&gt;, and the &lt;a href=&quot;collections#client-collections&quot;&gt;client side Minimongo cache&lt;/a&gt; of that collection. You can think of a subscription as a pipe that connects a subset of the &amp;ldquo;real&amp;rdquo; collection with the client&amp;rsquo;s version, and constantly keeps it up to date with the latest information on the server.</source>
          <target state="translated">따라서 구독은 시간이 지남에 따라 변경되는 데이터 집합으로 생각할 수 있습니다. 일반적으로이 결과는 서브 스크립 션이 &lt;a href=&quot;collections#server-collections&quot;&gt;서버 측 MongoDB 콜렉션&lt;/a&gt; 과 해당 콜렉션 의 &lt;a href=&quot;collections#client-collections&quot;&gt;클라이언트 측 Minimongo 캐시&lt;/a&gt; 를 &quot;브리지&quot;합니다 . 구독은 &quot;실제&quot;컬렉션의 하위 집합을 클라이언트 버전과 연결하고 서버의 최신 정보로 지속적으로 최신 상태로 유지하는 파이프로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478f1f92ef92b6d2c9b1cd21b4fd6204094c90a7" translate="yes" xml:space="preserve">
          <source>So if we wanted to reverse our migration above, we&amp;rsquo;d run</source>
          <target state="translated">따라서 위의 마이그레이션을 취소하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="98aa39ecd1b7e86893f4675d679ab3aef45170f3" translate="yes" xml:space="preserve">
          <source>So in the case above, if a user subscribes to a list that is later made private by another user, although the &lt;code&gt;list.userId&lt;/code&gt; will change to a value that no longer passes the condition, the body of the publication will not re-run, and so the query to the &lt;code&gt;Todos&lt;/code&gt; collection (&lt;code&gt;{listId}&lt;/code&gt;) will not change. So the first user will continue to see items they shouldn&amp;rsquo;t.</source>
          <target state="translated">따라서 위의 경우 사용자가 나중에 다른 사용자가 비공개로 만든 목록에 가입하면 &lt;code&gt;list.userId&lt;/code&gt; 가 더 이상 조건을 통과하지 않는 값으로 변경 되지만 게시 본문이 다시 실행되지 않습니다. 따라서 &lt;code&gt;Todos&lt;/code&gt; 콜렉션 ( &lt;code&gt;{listId}&lt;/code&gt; )에 대한 조회 는 변경되지 않습니다. 따라서 첫 번째 사용자는 계속하지 말아야 할 항목을 계속 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="9c62a259503606443fa8426b9c59cd0a4e4c47ca" translate="yes" xml:space="preserve">
          <source>So when should you wait for the server and when not? It basically comes down to how optimistic you are; how likely it is that something will go wrong. In the case of a password, you really can&amp;rsquo;t tell on the client, so you need to be conservative. In other cases, you can be pretty confident that the Method call will succeed, and so you can move on.</source>
          <target state="translated">그렇다면 언제 서버를 기다려야합니까? 그것은 기본적으로 당신이 얼마나 낙관적인가에 달려 있습니다. 무언가 잘못 될 가능성이 얼마나됩니까? 암호의 경우 실제로 클라이언트에 대해 말할 수 없으므로 보수적이어야합니다. 다른 경우에는 Method 호출이 성공할 것이라고 확신 할 수 있으므로 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e187e39e8a003f11f5518446bd48cc4885f8af1e" translate="yes" xml:space="preserve">
          <source>So whenever you get a path in your build plugin implementation, via &lt;code&gt;getPathInPackage&lt;/code&gt; or in an argument of the &lt;code&gt;setDiskCacheDirectory&lt;/code&gt; method, the path will be a Unix path.</source>
          <target state="translated">따라서 빌드 플러그인 구현, &lt;code&gt;getPathInPackage&lt;/code&gt; 또는 &lt;code&gt;setDiskCacheDirectory&lt;/code&gt; 메소드 의 인수를 통해 경로를 얻을 때마다 경로는 Unix 경로가됩니다.</target>
        </trans-unit>
        <trans-unit id="95c804dda762ed369a9896eefc2804517d971bd9" translate="yes" xml:space="preserve">
          <source>So which are the global data stores that you should be avoiding in reusable components? There are a few. Meteor is built to optimize speed of development, which means you can access a lot of things globally. Although this is convenient when building &amp;ldquo;smart&amp;rdquo; components (see below), you&amp;rsquo;ll need to avoid these data sources in reusable components:</source>
          <target state="translated">재사용 가능한 구성 요소에서 피해야 할 글로벌 데이터 저장소는 무엇입니까? 몇 가지가 있습니다. Meteor는 개발 속도를 최적화하도록 설계되었으므로 전 세계의 많은 정보에 액세스 할 수 있습니다. &quot;스마트 한&quot;구성 요소를 구축 할 때 편리하지만 (아래 참조) 재사용 가능한 구성 요소에서 이러한 데이터 소스를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="9627182a4fe072bfbec05f6a749d3b6a0cdcb29e" translate="yes" xml:space="preserve">
          <source>Some Cordova plugins require certain parameters to be set as part of the build process. For example, &lt;code&gt;com-phonegap-plugins-facebookconnect&lt;/code&gt; requires you to specify an &lt;code&gt;APP_ID&lt;/code&gt; and &lt;code&gt;APP_NAME&lt;/code&gt;. You can set these using &lt;code&gt;App.configurePlugin&lt;/code&gt; in your &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;mobile-config.js&lt;/a&gt;.</source>
          <target state="translated">일부 Cordova 플러그인은 빌드 프로세스의 일부로 특정 매개 변수를 설정해야합니다. 예를 들어, &lt;code&gt;com-phonegap-plugins-facebookconnect&lt;/code&gt; 를 사용하려면 &lt;code&gt;APP_ID&lt;/code&gt; 및 &lt;code&gt;APP_NAME&lt;/code&gt; 을 지정해야합니다 . &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;mobile-config.js&lt;/a&gt; 에서 &lt;code&gt;App.configurePlugin&lt;/code&gt; 을 사용하여이를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="288805ed360b5c9b94ce45ecff66330cd5e15bc4" translate="yes" xml:space="preserve">
          <source>Some Meteor apps contain local Meteor packages (packages defined in the &lt;code&gt;packages/&lt;/code&gt; directory of your app tree); this was an older recommendation from before Meteor had full ECMAScript support. If your app is laid out this way, you can also &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; npm packages installed in your app from within your local Meteor packages.</source>
          <target state="translated">일부 Meteor 앱에는 로컬 Meteor 패키지 ( 앱 트리 의 &lt;code&gt;packages/&lt;/code&gt; 디렉토리에 정의 된 패키지)가 포함되어 있습니다 . 이는 Meteor가 ECMAScript를 완전히 지원하기 전의 권장 사항입니다. 앱이 이런 식으로 배치 된 경우 로컬 Meteor 패키지 내에서 앱에 설치된 npm 패키지를 &lt;code&gt;require&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5583d20bd00ddad1e3ebd55dd768207a1576d120" translate="yes" xml:space="preserve">
          <source>Some aspects of the migration strategy outlined above are possibly not the most ideal way to do things (although perhaps appropriate in many situations). Here are some other things to be aware of:</source>
          <target state="translated">위에서 설명한 마이그레이션 전략의 일부 측면은 아마도 가장 이상적인 방법은 아닙니다 (아마도 많은 상황에서 적절할 수 있음). 다음은 알아 두어야 할 사항입니다.</target>
        </trans-unit>
        <trans-unit id="072e10b4145d1db5429e8b26ba3ce40d482fe400" translate="yes" xml:space="preserve">
          <source>Some example uses of &lt;code&gt;meteor admin&lt;/code&gt; include adding and removing package maintainers and setting a homepage for a package. It also includes various helpful functions for managing a Meteor release. Run &lt;code&gt;meteor help admin&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;code&gt;meteor admin&lt;/code&gt; 사용의 예로는 패키지 관리자 추가 및 제거, 패키지 홈페이지 설정 등이 있습니다. 또한 Meteor 릴리스 관리에 유용한 다양한 기능이 포함되어 있습니다. 자세한 내용 &lt;code&gt;meteor help admin&lt;/code&gt; 을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="fd89b46d604ef486a28a5ca580a3855bb5c0ce96" translate="yes" xml:space="preserve">
          <source>Some of your code isn&amp;rsquo;t going to be a unit of business logic or UI, it&amp;rsquo;s just some setup or configuration code that needs to run in the context of the app when it starts up. In the Todos example app, the &lt;code&gt;imports/startup/client/useraccounts-configuration.js&lt;/code&gt; file configures the &lt;code&gt;useraccounts&lt;/code&gt; login templates (see the &lt;a href=&quot;accounts&quot;&gt;Accounts&lt;/a&gt; article for more information about &lt;code&gt;useraccounts&lt;/code&gt;). The &lt;code&gt;imports/startup/client/routes.js&lt;/code&gt; configures all of the routes and then imports &lt;em&gt;all&lt;/em&gt; other code that is required on the client:</source>
          <target state="translated">일부 코드는 비즈니스 논리 또는 UI의 단위가 아니며 시작시 앱의 컨텍스트에서 실행해야하는 설정 또는 구성 코드 일뿐입니다. 왜 그렇게 예제 응용 프로그램에서는 &lt;code&gt;imports/startup/client/useraccounts-configuration.js&lt;/code&gt; 파일 구성하는 &lt;code&gt;useraccounts&lt;/code&gt; 는 합니다 (참조 템플릿을 로그인 &lt;a href=&quot;accounts&quot;&gt;계정&lt;/a&gt; 에 대한 자세한 내용은 기술 자료 문서 &lt;code&gt;useraccounts&lt;/code&gt; 을 ). &lt;code&gt;imports/startup/client/routes.js&lt;/code&gt; 경로의 모든 구성하고 수입 &lt;em&gt;하는 모든&lt;/em&gt; 클라이언트에 요구되는 다른 코드를 :</target>
        </trans-unit>
        <trans-unit id="cfcfd4524c6a19a0376d9dec412accbb0994f32b" translate="yes" xml:space="preserve">
          <source>Some of your components will need to access state outside of their data context&amp;mdash;for instance, data from the server via subscriptions or the contents of client-side store. As discussed in the &lt;a href=&quot;https://guide.meteor.com/data-loading.html#patterns&quot;&gt;data loading&lt;/a&gt; and &lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI&lt;/a&gt; articles, you should be careful and considered in how you use such smart components.</source>
          <target state="translated">일부 구성 요소는 데이터 컨텍스트 외부의 상태 (예 : 구독을 통한 서버의 데이터 또는 클라이언트 측 저장소의 내용)에 액세스해야합니다. &lt;a href=&quot;https://guide.meteor.com/data-loading.html#patterns&quot;&gt;데이터로드&lt;/a&gt; 및 &lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI&lt;/a&gt; 기사 에서 설명한대로 이러한 스마트 구성 요소를 사용하는 방법에주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="a2bafd3349aa60e6d14644ba436b4cff4cb20b9b" translate="yes" xml:space="preserve">
          <source>Some packages contain code specific to an architecture. Running &lt;code&gt;publish&lt;/code&gt; by itself, will upload the build to the architecture that you were using to publish. You need to run &lt;code&gt;publish-for-arch&lt;/code&gt; from a different architecture to upload a different build.</source>
          <target state="translated">일부 패키지에는 아키텍처 별 코드가 포함되어 있습니다. 자체적으로 &lt;code&gt;publish&lt;/code&gt; 를 실행하면 게시 에 사용했던 아키텍처에 빌드가 업로드됩니다. 다른 빌드를 업로드하려면 다른 아키텍처에서 &lt;code&gt;publish-for-arch&lt;/code&gt; 를 위해 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e128406895c90cb74e42012b3024d0405c7c877b" translate="yes" xml:space="preserve">
          <source>Something else to keep in mind is that your server-side code should be prepared to handle requests from older client versions, which may not yet have been updated. As you make changes to your data schema or publication functions for example, you may want to reflect on how this will impact backwards compatibility.</source>
          <target state="translated">명심해야 할 점은 아직 업데이트되지 않은 이전 클라이언트 버전의 요청을 처리 할 수 ​​있도록 서버 측 코드를 준비해야한다는 것입니다. 예를 들어 데이터 스키마 또는 게시 기능을 변경하면이 기능이 이전 버전과의 호환성에 어떤 영향을 미치는지 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e30b57358aece3044dff3a76d13060e868ae4d" translate="yes" xml:space="preserve">
          <source>Sometimes a module doesn&amp;rsquo;t actually need to import anything from another module, but you still want to be sure the other module gets evaluated first. In such situations, you can use an even simpler &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">때로는 모듈이 실제로 다른 모듈에서 무언가를 가져올 필요는 없지만 다른 모듈이 먼저 평가되도록해야합니다. 이러한 상황에서는 더 간단한 &lt;code&gt;import&lt;/code&gt; 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2775ccc0da8ca41da6274f811302c8fd1fecccdc" translate="yes" xml:space="preserve">
          <source>Sometimes a package will have no exports and simply have side effects when included in your app. In such cases you don&amp;rsquo;t need to import the package at all after installing.</source>
          <target state="translated">때로는 패키지에 내보내기가없고 앱에 포함될 때 부작용이있을 수 있습니다. 이러한 경우 설치 후 패키지를 전혀 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7fb941f27793448af5e3a89674fc1adfce343aa" translate="yes" xml:space="preserve">
          <source>Sometimes a single piece of functionality can be spread over multiple mutators.</source>
          <target state="translated">때로는 단일 기능이 여러 뮤 테이터에 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37177908e7d657fd13b1bf5bc5412ed34a490301" translate="yes" xml:space="preserve">
          <source>Sometimes an argument to a helper call is best expressed as a return value of some other expression. For this and other cases, one can use parentheses to express the evaluation order of nested expressions.</source>
          <target state="translated">때때로 헬퍼 호출에 대한 인수는 다른 표현식의 리턴 값으로 가장 잘 표현됩니다. 이 경우와 다른 경우에는 괄호를 사용하여 중첩 식의 평가 순서를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="967fcd8347c649fe963cca11b07dfe2fa067d406" translate="yes" xml:space="preserve">
          <source>Sometimes changes in your data can trigger re-computations which you know won&amp;rsquo;t affect your UI. Although React is in general quite efficient in the face of unnecessary re-renders, if you need to control re-rendering, the above pattern allows you to easily use React&amp;rsquo;s &lt;a href=&quot;https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt; on the presentational component to avoid re-renders.</source>
          <target state="translated">때때로 데이터가 변경되면 UI에 영향을 미치지 않는 재 계산이 트리거 될 수 있습니다. React는 일반적으로 불필요한 재 렌더링에 대해 매우 효율적이지만 재 렌더링을 제어해야하는 경우 위의 패턴을 사용하면 프리젠 테이션 컴포넌트에서 React의 &lt;a href=&quot;https://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; &lt;/a&gt; 를 쉽게 사용 하여 재 렌더링을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30eed3363beda5dc6cb6645d4304aa8921b0f07a" translate="yes" xml:space="preserve">
          <source>Sometimes packages may contain binary code specific to an architecture (for example, they may use an npm package). In that case, running publish will only upload the build to the architecture that you were using to publish it. You can use &lt;code&gt;publish-for-arch&lt;/code&gt; to upload a build to a different architecture from a different machine.</source>
          <target state="translated">때때로 패키지에는 아키텍처 고유의 이진 코드가 포함될 수 있습니다 (예 : npm 패키지를 사용할 수 있음). 이 경우 게시를 실행하면 빌드하는 데 사용한 아키텍처에만 빌드가 업로드됩니다. &lt;code&gt;publish-for-arch&lt;/code&gt; 를 위해 게시 를 사용 하여 다른 컴퓨터에서 다른 아키텍처로 빌드를 업로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2b83c8b42b23568b24e56afda2dd3f27e1497e1" translate="yes" xml:space="preserve">
          <source>Sometimes the user may be interested in knowing when the update has hit the server. For instance, in a chat application, it&amp;rsquo;s a typical pattern to optimistically display the message in the chat log, but indicate that it is &amp;ldquo;pending&amp;rdquo; until the server has acknowledged the write. We can do this easily in Meteor by simply modifying the Method to act differently on the client:</source>
          <target state="translated">때때로 사용자는 업데이트가 서버에 도달 한 시점을 알고 싶어 할 수 있습니다. 예를 들어 채팅 응용 프로그램에서는 채팅 로그에 메시지를 낙관적으로 표시하는 것이 일반적인 패턴이지만 서버가 쓰기를 승인 할 때까지 &quot;보류 중&quot;임을 나타냅니다. 클라이언트에서 다르게 작동하도록 Method를 수정하면 Meteor에서이 작업을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e78f363b35581ec725cb46401ef8bbcf2b9978b" translate="yes" xml:space="preserve">
          <source>Sometimes when we change the schema of an application, we do so in a breaking way &amp;ndash; so that the old schema doesn&amp;rsquo;t work properly with the new code base. For instance, if we had some UI code that heavily relied on all lists having a &lt;code&gt;todoCount&lt;/code&gt; set, there would be a period, before the migration runs, in which the UI of our app would be broken after we deployed.</source>
          <target state="translated">때로는 애플리케이션의 스키마를 변경할 때 기존 스키마가 새로운 코드 기반에서 제대로 작동하지 않도록 변경하는 방식으로 변경됩니다. 예를 들어, &lt;code&gt;todoCount&lt;/code&gt; 가 설정된 모든 목록에 크게 의존하는 UI 코드 가있는 경우 마이그레이션이 실행되기 전에 배포 후 앱의 UI가 손상되는 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9541b8d1475268ea7ff1a13eaa81f4a1fc3d282" translate="yes" xml:space="preserve">
          <source>Sometimes, Meteor will ask you to run &lt;code&gt;meteor update --patch&lt;/code&gt;. Patch releases are special releases that contain only very minor changes (usually crucial bug fixes) from previous releases. We highly recommend that you always run &lt;code&gt;update
--patch&lt;/code&gt; when prompted.</source>
          <target state="translated">때때로 Meteor는 &lt;code&gt;meteor update --patch&lt;/code&gt; 를 실행하도록 요청할 것 입니다. 패치 릴리스는 이전 릴리스의 사소한 변경 사항 (일반적으로 중요한 버그 수정) 만 포함 된 특수 릴리스입니다. 프롬프트가 표시되면 항상 &lt;code&gt;update --patch&lt;/code&gt; 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f9b65b97d3759923631106558124cc0679d385d" translate="yes" xml:space="preserve">
          <source>Sometimes, it doesn&amp;rsquo;t make sense to abstract permissions into &amp;ldquo;groups&amp;rdquo; - you just want documents to have owners and that&amp;rsquo;s it. In this case, you can use a simpler strategy using collection helpers.</source>
          <target state="translated">때로는 권한을 &quot;그룹&quot;으로 추상화하는 것이 이치에 맞지 않습니다. 문서에 소유자 만 있으면됩니다. 이 경우 수집 도우미를 사용하여보다 간단한 전략을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="587ed289fb5162efc495a4470606aae244c5a266" translate="yes" xml:space="preserve">
          <source>Sometimes, the simple mechanism of returning a query from a publication function won&amp;rsquo;t cover your needs. In those situations, there are some more powerful publication patterns that you can use.</source>
          <target state="translated">간혹 게시 함수에서 쿼리를 반환하는 간단한 메커니즘으로 요구 사항을 충족하지 못할 수도 있습니다. 이러한 상황에서는 사용할 수있는보다 강력한 게시 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ea56ed3ad462396bdd97fc31754c69092c333ef" translate="yes" xml:space="preserve">
          <source>Sometimes, you&amp;rsquo;ll want to call a Method from another Method. Perhaps you already have some functionality implemented and you want to add a wrapper that fills in some of the arguments automatically. This is a totally fine pattern, and Meteor does some nice things for you:</source>
          <target state="translated">때로는 다른 메소드에서 메소드를 호출하려고 할 수도 있습니다. 아마도 이미 일부 기능이 구현되어 있고 일부 인수를 자동으로 채우는 래퍼를 추가하려고합니다. 이것은 완전히 훌륭한 패턴이며 Meteor는 당신을 위해 좋은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="42494b26bf1ad21b3ef7f5e960a7620440551809" translate="yes" xml:space="preserve">
          <source>Sometimes, your users will end up on a page that isn&amp;rsquo;t a good place for them to be. Maybe the data they were looking for has moved, maybe they were on an admin panel page and logged out, or maybe they just created a new object and you want them to end up on the page for the thing they just created.</source>
          <target state="translated">때로는 사용자가보기에 좋지 않은 페이지가 될 수도 있습니다. 찾고 있던 데이터가 이동했거나, 관리자 패널 페이지에서 로그 아웃했거나, 방금 새 개체를 생성하여 방금 만든 항목에 대해 페이지에 표시하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1770eb1256a559743e31eac20e1799f90efee3ab" translate="yes" xml:space="preserve">
          <source>Sort Specifiers</source>
          <target state="translated">정렬 지정자</target>
        </trans-unit>
        <trans-unit id="bc64afe5eb57c9154a448e2c6f8cd508b88f154e" translate="yes" xml:space="preserve">
          <source>Sort order (default: natural order)</source>
          <target state="translated">정렬 순서 (기본값 : 자연 순서)</target>
        </trans-unit>
        <trans-unit id="afa7db30001b249bae428d0da7857c46b13ab1e8" translate="yes" xml:space="preserve">
          <source>Sorts may be specified using your choice of several syntaxes:</source>
          <target state="translated">여러 구문을 선택하여 정렬을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="843558854e90b07b4e553cf25b2db7e4fbf89149" translate="yes" xml:space="preserve">
          <source>Source vs. import files</source>
          <target state="translated">소스 대 가져 오기 파일</target>
        </trans-unit>
        <trans-unit id="ecc504d5bcdaffc6ef5d66689b319535cea8c706" translate="yes" xml:space="preserve">
          <source>Spacebars</source>
          <target state="translated">Spacebars</target>
        </trans-unit>
        <trans-unit id="ac129336f9c18f31db88e4217a928ed28f2cf3f0" translate="yes" xml:space="preserve">
          <source>Spacebars has a very strict HTML parser. For instance, you can&amp;rsquo;t self-close a &lt;code&gt;div&lt;/code&gt; (&lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt;) in Spacebars, and you need to close some tags that a browser might not require you to (such as a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tag). Thankfully, the parser will warn you when it can&amp;rsquo;t understand your code with an exact line number for the error.</source>
          <target state="translated">스페이스 바에는 매우 엄격한 HTML 파서가 있습니다. 예를 들어 스페이스 바에서 &lt;code&gt;div&lt;/code&gt; ( &lt;code&gt;&amp;lt;div/&amp;gt;&lt;/code&gt; )를 자동으로 닫을 수 없으며 브라우저에서 필요하지 않은 일부 태그 (예 : &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 태그) 를 닫아야 합니다. 고맙게도 파서는 오류에 대한 정확한 줄 번호로 코드를 이해할 수 없을 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="dd5c7cca91ad8702873343ecf92904d4da9e6381" translate="yes" xml:space="preserve">
          <source>Spacebars is a Meteor template language inspired by &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;Handlebars&lt;/a&gt;. It shares some of the spirit and syntax of Handlebars, but it has been tailored to produce reactive Meteor templates when compiled.</source>
          <target state="translated">스페이스 &lt;a href=&quot;http://handlebarsjs.com/&quot;&gt;바&lt;/a&gt; 는 핸들 바에서 영감을 얻은 Meteor 템플릿 언어 입니다. 핸들 바의 정신과 구문 중 일부를 공유하지만 컴파일 할 때 반응 형 Meteor 템플릿을 생성하도록 조정되었습니다.</target>
        </trans-unit>
        <trans-unit id="db589873b07c45de7de4a5f6847d245903bd7460" translate="yes" xml:space="preserve">
          <source>Spacebars is a handlebars-like templating language, built on the concept of rendering a reactively changing &lt;em&gt;data context&lt;/em&gt;. Spacebars templates look like simple HTML with special &amp;ldquo;mustache&amp;rdquo; tags delimited by curly braces: &lt;code&gt;{{ }}&lt;/code&gt;.</source>
          <target state="translated">스페이스 바는 반응 적으로 변화하는 &lt;em&gt;데이터 컨텍스트&lt;/em&gt; 를 렌더링하는 개념을 기반으로하는 핸들 바와 같은 템플릿 언어 입니다. 스페이스 바 템플릿은 중괄호 ( &lt;code&gt;{{ }}&lt;/code&gt; 구분 된 특수한 &quot;콧수염&quot;태그가있는 간단한 HTML처럼 보입니다 .</target>
        </trans-unit>
        <trans-unit id="186a93d0f0a006ebfdb539f8e5276f79d80c2a44" translate="yes" xml:space="preserve">
          <source>Spacebars is not lenient about malformed markup the way a web browser is. While the latest HTML spec standardizes how browsers should recover from parse errors, these cases are still not valid HTML. For example, a browser may recover from a bare &lt;code&gt;&amp;lt;&lt;/code&gt; that does not begin a well-formed HTML tag, while Spacebars will not. However, gone are the restrictions of the XHTML days; attribute values do not have to quoted, and tags are not case-sensitive, for example.</source>
          <target state="translated">스페이스 바는 웹 브라우저와 같은 잘못된 마크 업에 관대하지 않습니다. 최신 HTML 사양은 브라우저가 구문 분석 오류를 복구하는 방법을 표준화하지만 이러한 경우는 여전히 유효한 HTML이 아닙니다. 예를 들어, 브라우저는 올바른 형식의 HTML 태그를 시작하지 않는 베어 &lt;code&gt;&amp;lt;&lt;/code&gt; 에서 복구 할 수 있지만 스페이스 바는 그렇지 않습니다. 그러나 XHTML 시대의 제한은 사라졌습니다. 예를 들어 속성 ​​값은 따옴표로 묶을 필요가 없으며 태그는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="659d70786d24c24a73453589dbc84ee62f997914" translate="yes" xml:space="preserve">
          <source>Spacebars templates</source>
          <target state="translated">스페이스 바 템플릿</target>
        </trans-unit>
        <trans-unit id="6ebb68ffd6433e4817d1350a43c68460aa95a9fc" translate="yes" xml:space="preserve">
          <source>Spacebars templates are written in &lt;a href=&quot;http://developers.whatwg.org/syntax.html&quot;&gt;standard HTML&lt;/a&gt; extended with additional syntax (i.e. template tags).</source>
          <target state="translated">스페이스 바 템플릿은 추가 구문 (예 : 템플릿 태그)으로 확장 된 &lt;a href=&quot;http://developers.whatwg.org/syntax.html&quot;&gt;표준 HTML&lt;/a&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac7aae1864ada3ccce9c264d4c98642728400843" translate="yes" xml:space="preserve">
          <source>Spacebars templates are written in &lt;a href=&quot;https://developers.whatwg.org/syntax.html&quot;&gt;standard HTML&lt;/a&gt; extended with additional syntax (i.e. template tags).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c87867f5dccf179d8c4ef9d9cbdc625c600629" translate="yes" xml:space="preserve">
          <source>Spacebars templates update reactively at a fine-grained level in response to changing data.</source>
          <target state="translated">스페이스 바 템플릿은 데이터 변경에 따라 세분화 된 수준으로 반응 적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7f2cbe4d1a91009df73ec6f7396b39440b15a070" translate="yes" xml:space="preserve">
          <source>Spacebars validates your HTML as it goes and will throw a compile-time error if you violate basic HTML syntax in a way that prevents it from determining the structure of your code.</source>
          <target state="translated">스페이스 바는 HTML의 유효성을 검사하고 코드 구조를 결정하지 못하게하는 방식으로 기본 HTML 구문을 위반하면 컴파일 타임 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f7218259ff5cece22f9f49760d5ec4b6c7ba7b3a" translate="yes" xml:space="preserve">
          <source>Special directories</source>
          <target state="translated">특수 디렉토리</target>
        </trans-unit>
        <trans-unit id="1e908a5ad4bfd8c4d66dcf036244665b5746aa4c" translate="yes" xml:space="preserve">
          <source>Specifically, when you pass a &lt;code&gt;name&lt;/code&gt;, here&amp;rsquo;s what happens:</source>
          <target state="translated">특히 &lt;code&gt;name&lt;/code&gt; 을 전달하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92a47ebb69242937b16a0aad20f259c584179d12" translate="yes" xml:space="preserve">
          <source>Specification of a release: track@version. Just 'version' (e.g. &lt;code&gt;&quot;0.9.0&quot;&lt;/code&gt;) is sufficient if using the default release track &lt;code&gt;METEOR&lt;/code&gt;. Can be an array of specifications.</source>
          <target state="translated">릴리스 사양 : track @ version. 기본 릴리스 트랙 &lt;code&gt;METEOR&lt;/code&gt; 를 사용하는 경우 'version'(예 : &lt;code&gt;&quot;0.9.0&quot;&lt;/code&gt; )이면 충분합니다 . 사양의 배열이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eacbeb05feca92e3ce66260defc9b4f765e6dab" translate="yes" xml:space="preserve">
          <source>Specifies how to modify the documents</source>
          <target state="translated">문서를 수정하는 방법을 지정합니다</target>
        </trans-unit>
        <trans-unit id="d6e01d68e936bf6f610d7cd227db050e0ddef24b" translate="yes" xml:space="preserve">
          <source>Specifies which documents to modify</source>
          <target state="translated">수정할 문서를 지정합니다</target>
        </trans-unit>
        <trans-unit id="9d0b7c3c37091ca0a32493119a8818e748a0cff5" translate="yes" xml:space="preserve">
          <source>Specifies which documents to remove</source>
          <target state="translated">제거 할 문서를 지정합니다</target>
        </trans-unit>
        <trans-unit id="e6f7a19aa0bff6b0065b239546903ba4890712b6" translate="yes" xml:space="preserve">
          <source>Specify asset files for your package. They can be accessed via the &lt;a href=&quot;#assets&quot;&gt;Assets API&lt;/a&gt; from the server, or at the URL &lt;code&gt;/packages/username_package-name/file-name&lt;/code&gt; from the client, depending on the architecture passed.</source>
          <target state="translated">패키지의 자산 파일을 지정하십시오. 전달 된 아키텍처에 따라 서버에서 &lt;a href=&quot;#assets&quot;&gt;자산 API&lt;/a&gt; 를 통해 또는 클라이언트에서 URL &lt;code&gt;/packages/username_package-name/file-name&lt;/code&gt; 을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5a2d0605b608d23cd66764f3cdf1e853afb9118" translate="yes" xml:space="preserve">
          <source>Specify event handlers for this template.</source>
          <target state="translated">이 템플리트에 대한 이벤트 핸들러를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="4c80894f7fe63793c42766af04601259f84c4102" translate="yes" xml:space="preserve">
          <source>Specify source code files for your package.</source>
          <target state="translated">패키지의 소스 코드 파일을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="dcf0eb8c6102fc69f1c9fd19043bed6b784a902a" translate="yes" xml:space="preserve">
          <source>Specify template helpers available to this template.</source>
          <target state="translated">이 템플릿에 사용 가능한 템플릿 도우미를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="301f34b1d2335841250ebe63ac55db926657a828" translate="yes" xml:space="preserve">
          <source>Specify where this asset should be available (e.g., 'server', 'client', 'web.browser', 'web.cordova'). You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt;.</source>
          <target state="translated">이 자산을 사용할 수있는 위치를 지정하십시오 (예 : 'server', 'client', 'web.browser', 'web.cordova'). 배열을 전달하여 여러 아키텍처를 지정할 수 있습니다 (예 : &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0979000f814be6a0b456fe96612343c6e571858a" translate="yes" xml:space="preserve">
          <source>Specify which &lt;a href=&quot;http://cordova.apache.org/&quot;&gt;Cordova / PhoneGap&lt;/a&gt; plugins your Meteor package depends on.</source>
          <target state="translated">Meteor 패키지가 의존 하는 &lt;a href=&quot;http://cordova.apache.org/&quot;&gt;Cordova / PhoneGap&lt;/a&gt; 플러그인을 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="4f8177877a4b8052da1d692cbb915dad31e6a33a" translate="yes" xml:space="preserve">
          <source>Specify which &lt;a href=&quot;https://cordova.apache.org/&quot;&gt;Cordova / PhoneGap&lt;/a&gt; plugins your Meteor package depends on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396a0d4158b8d9f6c74552eaa6d645e6fe9a3875" translate="yes" xml:space="preserve">
          <source>Specify which &lt;a href=&quot;https://www.npmjs.org/&quot;&gt;NPM&lt;/a&gt; packages your Meteor package depends on.</source>
          <target state="translated">Meteor 패키지가 의존 하는 &lt;a href=&quot;https://www.npmjs.org/&quot;&gt;NPM&lt;/a&gt; 패키지를 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="da21c85d61d2f38d5c1da617547cfc07e9ba39b5" translate="yes" xml:space="preserve">
          <source>Splitting into multiple apps</source>
          <target state="translated">여러 앱으로 분할</target>
        </trans-unit>
        <trans-unit id="baa01701f1fa1790c7ef5ce421dcd21608fe6fcf" translate="yes" xml:space="preserve">
          <source>Starting with Meteor 1.0.4 access rule for all domains and protocols (&lt;code&gt;&amp;lt;access origin=&quot;*&quot;/&amp;gt;&lt;/code&gt;) is no longer set by default due to &lt;a href=&quot;http://cordova.apache.org/announcements/2014/08/04/android-351.html&quot;&gt;certain kind of possible attacks&lt;/a&gt;.</source>
          <target state="translated">모든 종류의 도메인 및 프로토콜 ( &lt;code&gt;&amp;lt;access origin=&quot;*&quot;/&amp;gt;&lt;/code&gt; )에 대한 Meteor 1.0.4 액세스 규칙부터는 &lt;a href=&quot;http://cordova.apache.org/announcements/2014/08/04/android-351.html&quot;&gt;특정 종류의 가능한 공격&lt;/a&gt; 으로 인해 더 이상 기본적으로 설정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7c80eb33a04e957e6ae9881742e7922fa9fe44af" translate="yes" xml:space="preserve">
          <source>Starting with Meteor 1.0.4 access rule for all domains and protocols (&lt;code&gt;&amp;lt;access origin=&quot;*&quot;/&amp;gt;&lt;/code&gt;) is no longer set by default due to &lt;a href=&quot;https://cordova.apache.org/announcements/2014/08/04/android-351.html&quot;&gt;certain kind of possible attacks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae08a2af0a6cfee2acf7b5acbd2499fe1841275" translate="yes" xml:space="preserve">
          <source>Starting with Meteor 1.2, packages can declare that they need a version of the Meteor tool whose Isobuild build system supports a certain feature. For example, packages must write &lt;code&gt;api.use('isobuild:compiler-plugin@1.0.0')&lt;/code&gt; in order to call &lt;code&gt;Plugin.registerCompiler&lt;/code&gt;. This means that a package can transition from the old &lt;code&gt;registerSourceHandler&lt;/code&gt; API to &lt;code&gt;registerCompiler&lt;/code&gt; and Version Solver will properly prevent the &lt;code&gt;registerCompiler&lt;/code&gt; version from being chosen by older tools that don&amp;rsquo;t know how to handle it.</source>
          <target state="translated">Meteor 1.2부터 패키지는 Isobuild 빌드 시스템이 특정 기능을 지원하는 Meteor 도구 버전이 필요하다고 선언 할 수 있습니다. 예를 들어, 패키지를 작성해야합니다 &lt;code&gt;api.use('isobuild:compiler-plugin@1.0.0')&lt;/code&gt; 호출하기 위해 &lt;code&gt;Plugin.registerCompiler&lt;/code&gt; 을 . 즉, 패키지가 이전 &lt;code&gt;registerSourceHandler&lt;/code&gt; API에서 &lt;code&gt;registerCompiler&lt;/code&gt; 로 전환 할 수 있으며 Version Solver는 &lt;code&gt;registerCompiler&lt;/code&gt; 버전이 처리 방법을 모르는 이전 도구에 의해 선택되는 것을 제대로 방지 하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="ee8c8ebe2a3a93d4ad4b379dcedd3e3826bc907e" translate="yes" xml:space="preserve">
          <source>Starting with Meteor 1.2, the API used to plug into the build process is called &amp;ldquo;Build Plugins&amp;rdquo;. There are 3 phases when a package&amp;rsquo;s plugin can run: linting, compilation and minification. Here is an overview of operations Isobuild performs on the application and packages source:</source>
          <target state="translated">Meteor 1.2부터 빌드 프로세스에 연결하는 데 사용되는 API를 &quot;빌드 플러그인&quot;이라고합니다. 패키지 플러그인을 실행할 수있는 단계는 린트, 컴파일 및 축소의 3 단계입니다. 다음은 Isobuild가 응용 프로그램 및 패키지 소스에서 수행하는 작업에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="2c53b0cdb260d1d53a18026e667ce6fb85645c7f" translate="yes" xml:space="preserve">
          <source>Starts up the test driver package (&lt;a href=&quot;#driver-packages&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">테스트 드라이버 패키지를 시작합니다 ( &lt;a href=&quot;#driver-packages&quot;&gt;아래 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4dc274cbfb723d7fa7d47c8a8ebbb3affafbe000" translate="yes" xml:space="preserve">
          <source>Startup files</source>
          <target state="translated">시작 파일</target>
        </trans-unit>
        <trans-unit id="488a095631c8c195522d289cd71abe333949c403" translate="yes" xml:space="preserve">
          <source>Static server assets are included by placing them in the application&amp;rsquo;s &lt;code&gt;private&lt;/code&gt; subdirectory. For example, if an application&amp;rsquo;s &lt;code&gt;private&lt;/code&gt; subdirectory includes a directory called &lt;code&gt;nested&lt;/code&gt; with a file called &lt;code&gt;data.txt&lt;/code&gt; inside it, then server code can read &lt;code&gt;data.txt&lt;/code&gt; by running:</source>
          <target state="translated">정적 서버 자산은 응용 프로그램의 &lt;code&gt;private&lt;/code&gt; 하위 디렉토리 에 배치하여 포함됩니다 . 예를 들어, 응용 프로그램의 &lt;code&gt;private&lt;/code&gt; 서브 디렉토리에 &lt;code&gt;data.txt&lt;/code&gt; 라는 파일이 &lt;code&gt;nested&lt;/code&gt; 디렉토리 가 있으면, 서버 코드는 다음 을 실행하여 &lt;code&gt;data.txt&lt;/code&gt; 를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22ede57d426a7020d719e3e2e0dfd9587f9dbb1b" translate="yes" xml:space="preserve">
          <source>Step 4 above is an important detail&amp;mdash;that the system cleverly knows not to re-subscribe if the autorun re-runs and subscribes with the exact same arguments. This holds true even if the new subscription is set up somewhere else in the template hierarchy. For example, if a user navigates between two pages that both subscribe to the exact same subscription, the same mechanism will kick in and no unnecessary subscribing will happen.</source>
          <target state="translated">위의 4 단계는 중요한 세부 사항입니다. 즉, 자동 실행이 다시 실행되고 정확히 동일한 인수로 구독하는 경우 시스템이 영리하게 다시 구독하지 않는 것을 알고 있습니다. 새 구독이 템플릿 계층의 다른 곳에 설정된 경우에도 마찬가지입니다. 예를 들어, 사용자가 정확히 동일한 구독을 구독하는 두 페이지를 탐색하는 경우 동일한 메커니즘이 시작되고 불필요한 구독이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c43b7a588c840bc119129d373529cd1eb91feb1f" translate="yes" xml:space="preserve">
          <source>Steps 2. and 5. can be quite time-consuming, especially if you are aiming to maintain a high level of quality in your application. That&amp;rsquo;s why it&amp;rsquo;s a great idea to develop a suite of acceptance tests (see our &lt;a href=&quot;testing&quot;&gt;Testing Article&lt;/a&gt; for more on this). To take things even further, you could run a load/stress test against your staging server on every release.</source>
          <target state="translated">2 단계와 5 단계는 특히 응용 프로그램에서 높은 수준의 품질을 유지하려는 경우 시간이 많이 걸릴 수 있습니다. 그렇기 때문에 수용 테스트 스위트를 개발하는 것이 좋은 생각입니다 (자세한 내용은 &lt;a href=&quot;testing&quot;&gt;테스트 기사&lt;/a&gt; 참조 ). 더 나아가려면 모든 릴리스에서 스테이징 서버에 대해로드 / 스트레스 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86f651249f4e19c9cd5df8e90e6bd2420b53217" translate="yes" xml:space="preserve">
          <source>Stopping Subscriptions</source>
          <target state="translated">구독 중지</target>
        </trans-unit>
        <trans-unit id="7fd14e8fcb39146c3c2b3f490ed48f627d66e4f6" translate="yes" xml:space="preserve">
          <source>Stopping a computation causes its &lt;code&gt;onInvalidate&lt;/code&gt; callbacks to run immediately if it is not currently invalidated, as well as its &lt;code&gt;stop&lt;/code&gt; callbacks.</source>
          <target state="translated">계산을 중지하면 &lt;code&gt;onInvalidate&lt;/code&gt; 콜백이 현재 무효화되지 않은 경우 즉시 콜백 이 &lt;code&gt;stop&lt;/code&gt; 콜백 이 중지 됩니다.</target>
        </trans-unit>
        <trans-unit id="38238c8459154491b33e937ae104aad658d3268d" translate="yes" xml:space="preserve">
          <source>Stopping a computation invalidates it (if it is valid) for the purpose of calling callbacks, but ensures that it will never be rerun.</source>
          <target state="translated">계산을 중지하면 콜백을 호출 할 목적으로 계산이 유효하지만 유효하지 않은 경우에는 다시 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d0f00fed7f257417a56fde30da357fb9e97cce9" translate="yes" xml:space="preserve">
          <source>Stopping a computation is irreversible and guarantees that it will never be rerun. You can stop a computation at any time, including from the computation&amp;rsquo;s own run function. Stopping a computation that is already stopped has no effect.</source>
          <target state="translated">계산을 중지하면 되돌릴 수 없으며 다시 실행되지 않습니다. 계산 자체 실행 기능을 포함하여 언제든지 계산을 중지 할 수 있습니다. 이미 중지 된 계산을 중지해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="84cd0876723c908e36df076d6b7be48a4fdbf71d" translate="yes" xml:space="preserve">
          <source>Storage Engine Support (MMAPv1 or WiredTiger) &amp;ndash; Since Meteor 1.4 WiredTiger is the default storage engine</source>
          <target state="translated">스토리지 엔진 지원 (MMAPv1 또는 WiredTiger) &amp;ndash; Meteor 1.4 WiredTiger가 기본 스토리지 엔진이므로</target>
        </trans-unit>
        <trans-unit id="cfd5cb5c2a301919f6af30860bff0837ba03e2e8" translate="yes" xml:space="preserve">
          <source>Storing data in the URL</source>
          <target state="translated">URL에 데이터 저장</target>
        </trans-unit>
        <trans-unit id="ea178a9a9bd02024d63a2e33e3d1c06a8b763aa9" translate="yes" xml:space="preserve">
          <source>Strictness</source>
          <target state="translated">Strictness</target>
        </trans-unit>
        <trans-unit id="cf849e3b6bb69e78ff1f65f9b1a600f0969b064d" translate="yes" xml:space="preserve">
          <source>String to use as the HTTP request body.</source>
          <target state="translated">HTTP 요청 본문으로 사용할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c83169d252f6be6e356582bc842a48fd5186ffc4" translate="yes" xml:space="preserve">
          <source>Structuring imports</source>
          <target state="translated">수입 구조</target>
        </trans-unit>
        <trans-unit id="532626609e018b03feb0f8b6873e8b52009d95ad" translate="yes" xml:space="preserve">
          <source>Stubbing</source>
          <target state="translated">Stubbing</target>
        </trans-unit>
        <trans-unit id="a0d160aba89c286bf5f12775644159a426602778" translate="yes" xml:space="preserve">
          <source>Style suggestions for Meteor-specific patterns, such as Methods, publications, and more</source>
          <target state="translated">분석법, 출판물 등과 같은 유성 별 패턴에 대한 스타일 제안</target>
        </trans-unit>
        <trans-unit id="957400ac1d92f82a856a3f939ce5438d5096957c" translate="yes" xml:space="preserve">
          <source>Stylus</source>
          <target state="translated">Stylus</target>
        </trans-unit>
        <trans-unit id="edcc462ffa5e5dab415de6afbc1d092aa1a02087" translate="yes" xml:space="preserve">
          <source>Stylus is maintained as a &lt;a href=&quot;https://atmospherejs.com/meteor/stylus&quot;&gt;Meteor core package called &lt;code&gt;stylus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스타일러스는 &lt;a href=&quot;https://atmospherejs.com/meteor/stylus&quot;&gt; &lt;code&gt;stylus&lt;/code&gt; &lt;/a&gt; 라는 Meteor 핵심 패키지 로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f53221ba50d4176a02810b2f92fffc05193e7ea6" translate="yes" xml:space="preserve">
          <source>Sub-expressions can be used to calculate key-word arguments, too:</source>
          <target state="translated">하위 표현식을 사용하여 키워드 인수를 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">숭고한 텍스트</target>
        </trans-unit>
        <trans-unit id="a3c1d0c35e3de98dca3e0b0bf5b1b0497fcf9e6a" translate="yes" xml:space="preserve">
          <source>SublimeLinter (&lt;a href=&quot;http://sublimelinter.readthedocs.org/en/latest/installation.html&quot;&gt;full instructions&lt;/a&gt;)</source>
          <target state="translated">SublimeLinter ( &lt;a href=&quot;http://sublimelinter.readthedocs.org/en/latest/installation.html&quot;&gt;전체 지침&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="96b54eac529b3dea9ad99c6cf6d59eed0955141c" translate="yes" xml:space="preserve">
          <source>SublimeLinter (&lt;a href=&quot;https://sublimelinter.readthedocs.org/en/latest/installation.html&quot;&gt;full instructions&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e45d7eb374f7f57043eaa5fbea25fc5e84adc47" translate="yes" xml:space="preserve">
          <source>SublimeLinter-contrib-eslint (&lt;a href=&quot;https://github.com/roadhump/SublimeLinter-eslint#plugin-installation&quot;&gt;full instructions&lt;/a&gt;)</source>
          <target state="translated">SublimeLinter-contrib-eslint ( &lt;a href=&quot;https://github.com/roadhump/SublimeLinter-eslint#plugin-installation&quot;&gt;전체 지침&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="087e97c4e3b69f78bd885dea1594496aaa4ea3ff" translate="yes" xml:space="preserve">
          <source>Submitting an app using Crosswalk to to Play Store</source>
          <target state="translated">Crosswalk를 사용하여 Play 스토어에 앱 제출</target>
        </trans-unit>
        <trans-unit id="c0f95cd7594695fc860e5e6020241d55c06b1dba" translate="yes" xml:space="preserve">
          <source>Subscribe from &lt;code&gt;onCreated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;onCreated&lt;/code&gt; 에서 구독</target>
        </trans-unit>
        <trans-unit id="1af8e1144fceed9ec58f1b52645250164f66f7c3" translate="yes" xml:space="preserve">
          <source>Subscribe in UI components</source>
          <target state="translated">UI 구성 요소 구독</target>
        </trans-unit>
        <trans-unit id="019d920e4312cdd5d847ca57afbc59c99b40bad0" translate="yes" xml:space="preserve">
          <source>Subscribe to a record set. Returns a handle that provides &lt;code&gt;stop()&lt;/code&gt; and &lt;code&gt;ready()&lt;/code&gt; methods.</source>
          <target state="translated">레코드 세트를 구독하십시오. &lt;code&gt;stop()&lt;/code&gt; 및 &lt;code&gt;ready()&lt;/code&gt; 메소드 를 제공하는 핸들을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="eb0493455a7518a21bcd6a8fcfa3e2c2b4562802" translate="yes" xml:space="preserve">
          <source>Subscribe to data</source>
          <target state="translated">데이터 구독</target>
        </trans-unit>
        <trans-unit id="ba401ec98dec72f17b10dca519bc070ad9595e82" translate="yes" xml:space="preserve">
          <source>Subscribe to relevant subscriptions,</source>
          <target state="translated">관련 구독을 구독하고</target>
        </trans-unit>
        <trans-unit id="c9ceca33bbb824f322c70060ce390e0b0ed09aa7" translate="yes" xml:space="preserve">
          <source>Subscribing to data</source>
          <target state="translated">데이터 구독</target>
        </trans-unit>
        <trans-unit id="037af573831ad1ba19f11905a227ae0a1a33d609" translate="yes" xml:space="preserve">
          <source>Subscribing to data puts it in your client-side collection. To use the data in your user interface, you need to query your client-side collection. There are a couple of important rules to follow when doing this.</source>
          <target state="translated">데이터를 구독하면 클라이언트 측 컬렉션에 데이터가 저장됩니다. 사용자 인터페이스에서 데이터를 사용하려면 클라이언트 측 콜렉션을 조회해야합니다. 이 작업을 수행 할 때 따라야 할 몇 가지 중요한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a8c988386beefb5a99ca1920f24f0083d2ed89" translate="yes" xml:space="preserve">
          <source>Subscription lifecycle</source>
          <target state="translated">구독 수명주기</target>
        </trans-unit>
        <trans-unit id="84b90a00a876707d164f85089ad4f2273e36aec1" translate="yes" xml:space="preserve">
          <source>Subscription readiness</source>
          <target state="translated">가입 준비</target>
        </trans-unit>
        <trans-unit id="40b8e3a739c94ae31c2d2611ccebf4ce458f9807" translate="yes" xml:space="preserve">
          <source>Suggested style guidelines for your code.</source>
          <target state="translated">코드에 권장되는 스타일 지침.</target>
        </trans-unit>
        <trans-unit id="481bc2ff1e299fbca3651cb1d9053d8888501cf3" translate="yes" xml:space="preserve">
          <source>Super-constructor for AccountsClient and AccountsServer.</source>
          <target state="translated">AccountsClient 및 AccountsServer의 수퍼 생성자</target>
        </trans-unit>
        <trans-unit id="f0bab6d94ac2aea3829cd9120fff59574f733d0d" translate="yes" xml:space="preserve">
          <source>Support for Replica Sets &amp;amp; Oplog tailing</source>
          <target state="translated">복제 세트 및 Oplog 테일링 지원</target>
        </trans-unit>
        <trans-unit id="ae06bea331f28eb01f40396f0e9966f2a64c7de1" translate="yes" xml:space="preserve">
          <source>Supported ES2015 Features</source>
          <target state="translated">지원되는 ES2015 기능</target>
        </trans-unit>
        <trans-unit id="a60b6274ab94fd571786c35b02d0730b279a2fe4" translate="yes" xml:space="preserve">
          <source>Supports catch-all &lt;code&gt;...rest&lt;/code&gt; properties in object literal declarations and assignments:</source>
          <target state="translated">객체 리터럴 선언 및 할당에서 catch-all &lt;code&gt;...rest&lt;/code&gt; 속성을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="22feaffa039be8678f90f340543de7a34015bcf5" translate="yes" xml:space="preserve">
          <source>Supports the MongoDB version you wish to run</source>
          <target state="translated">실행하려는 MongoDB 버전을 지원합니다</target>
        </trans-unit>
        <trans-unit id="bfa160301d799b28c48a451782aa085c37930e88" translate="yes" xml:space="preserve">
          <source>Suppose you have a simple publication of the following form:</source>
          <target state="translated">다음과 같은 형식의 간행물이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cd0531ce8fef7fd864d536517837a08ea81ab48d" translate="yes" xml:space="preserve">
          <source>Suppose, as an example, that we wanted to add a &lt;code&gt;list.todoCount&lt;/code&gt; field, and ensure that it was set for all existing lists. Then we might write the following in server-only code (e.g. &lt;code&gt;/server/migrations.js&lt;/code&gt;):</source>
          <target state="translated">예를 들어 &lt;code&gt;list.todoCount&lt;/code&gt; 필드 를 추가하고 모든 기존 목록에 대해 설정되어 있는지 확인한다고 가정하십시오. 그런 다음 서버 전용 코드로 다음을 작성할 수 있습니다 (예 : &lt;code&gt;/server/migrations.js&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="567b2656bb53fc60c79cd830a3253b6b487b0699" translate="yes" xml:space="preserve">
          <source>System Permissions</source>
          <target state="translated">시스템 권한</target>
        </trans-unit>
        <trans-unit id="f32de3e71f149d81905d2c0f8c9944150c3e4e29" translate="yes" xml:space="preserve">
          <source>Take advantage of Meteor&amp;rsquo;s &lt;a href=&quot;build-tool&quot;&gt;build system&lt;/a&gt; to be automatically transpiled from languages like CoffeeScript</source>
          <target state="translated">CoffeeScript와 같은 언어에서 Meteor의 &lt;a href=&quot;build-tool&quot;&gt;빌드 시스템&lt;/a&gt; 을 자동으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dc30076646c7eb425a83b84c83e4c9fb7d03bf9" translate="yes" xml:space="preserve">
          <source>Target audience</source>
          <target state="translated">잠재 고객 타겟팅</target>
        </trans-unit>
        <trans-unit id="17e2637b16a5eba0cef89d8c454e94401594e14f" translate="yes" xml:space="preserve">
          <source>Technically speaking, the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element is not part of the Spacebars language. A &lt;code&gt;foo.html&lt;/code&gt; template file in Meteor consists of one or more of the following elements:</source>
          <target state="translated">기술적으로 말해서 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소는 스페이스 바 언어의 일부가 아닙니다. Meteor 의 &lt;code&gt;foo.html&lt;/code&gt; 템플릿 파일은 다음 요소 중 하나 이상으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="903e0de531f14fb0495c42169017eaca7c92edf3" translate="yes" xml:space="preserve">
          <source>Technically, what happens when one of these reactive sources changes is the following:</source>
          <target state="translated">기술적으로 이러한 반응 소스 중 하나가 변경되면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0fe6042703610dfdfd08cfa5771de503b563a878" translate="yes" xml:space="preserve">
          <source>Template Declarations</source>
          <target state="translated">템플릿 선언</target>
        </trans-unit>
        <trans-unit id="bdd364054e55324d98012f718e9b3d48a89df69d" translate="yes" xml:space="preserve">
          <source>Template Tag Placement Limitations</source>
          <target state="translated">템플릿 태그 배치 제한</target>
        </trans-unit>
        <trans-unit id="29f6f10ddc19829caadc10be7999e311791dd631" translate="yes" xml:space="preserve">
          <source>Template data contexts (which you can access reactively with &lt;code&gt;Template.currentData()&lt;/code&gt;).</source>
          <target state="translated">템플릿 데이터 컨텍스트 ( &lt;code&gt;Template.currentData()&lt;/code&gt; 하여 반응 적으로 액세스 할 수 있음 )</target>
        </trans-unit>
        <trans-unit id="dd84b79aa495bebccabc7f154f254f161ffd3c0c" translate="yes" xml:space="preserve">
          <source>Template helpers take priority over properties of the data context.</source>
          <target state="translated">템플릿 도우미는 데이터 컨텍스트의 속성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="55b7201637ff0afa51b88637d8ad020d809e0a83" translate="yes" xml:space="preserve">
          <source>Template inclusion</source>
          <target state="translated">템플릿 포함</target>
        </trans-unit>
        <trans-unit id="035d8506a3bee285b7a1a3417b22da1baebec672" translate="yes" xml:space="preserve">
          <source>Template instance objects are &lt;code&gt;instanceof Blaze.TemplateInstance&lt;/code&gt;.</source>
          <target state="translated">템플릿 인스턴스 객체는 &lt;code&gt;instanceof Blaze.TemplateInstance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e84bc56fbad42cb89bb821c78b86f8d554517f7f" translate="yes" xml:space="preserve">
          <source>Template instance objects are found as the value of &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;onCreated&lt;/code&gt;, &lt;code&gt;onRendered&lt;/code&gt;, and &lt;code&gt;onDestroyed&lt;/code&gt; template callbacks, and as an argument to event handlers. You can access the current template instance from helpers using &lt;a href=&quot;templates#Template-instance&quot;&gt;&lt;code&gt;Template.instance()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">템플릿 인스턴스 객체의 값으로 발견 &lt;code&gt;this&lt;/code&gt; 에서 &lt;code&gt;onCreated&lt;/code&gt; , &lt;code&gt;onRendered&lt;/code&gt; 및 &lt;code&gt;onDestroyed&lt;/code&gt; 템플릿 콜백 및 이벤트 핸들러에 인수로. &lt;a href=&quot;templates#Template-instance&quot;&gt; &lt;code&gt;Template.instance()&lt;/code&gt; &lt;/a&gt; 사용하여 헬퍼에서 현재 템플릿 인스턴스에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8644d7693f62b77833e7c88bd58cdcce8f9918be" translate="yes" xml:space="preserve">
          <source>Template instance objects have fields like &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;firstNode&lt;/code&gt;, and &lt;code&gt;lastNode&lt;/code&gt; which are not reactive and which are also not automatically kept up to date. Calling &lt;code&gt;templateInstance()&lt;/code&gt; causes these fields to be updated.</source>
          <target state="translated">템플릿 인스턴스 객체에는 &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;firstNode&lt;/code&gt; 및 &lt;code&gt;lastNode&lt;/code&gt; 와 같은 필드 가 있으며 반응하지 않으며 자동으로 최신 상태로 유지되지 않습니다. &lt;code&gt;templateInstance()&lt;/code&gt; 호출 하면 이러한 필드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="de6fa8e33e81f97df83046b1c5ecafc0cc146810" translate="yes" xml:space="preserve">
          <source>Template instances</source>
          <target state="translated">템플릿 인스턴스</target>
        </trans-unit>
        <trans-unit id="954ab955f2a4e981e2a42027ac3b702c33779a3e" translate="yes" xml:space="preserve">
          <source>Template name</source>
          <target state="translated">템플릿 이름</target>
        </trans-unit>
        <trans-unit id="bcb645303efc3c8f462d217bc353c2b8b48088e0" translate="yes" xml:space="preserve">
          <source>Template#events()</source>
          <target state="translated">Template#events()</target>
        </trans-unit>
        <trans-unit id="d9fe9712b1b136c60046d954d784963ff129062c" translate="yes" xml:space="preserve">
          <source>Template#helpers()</source>
          <target state="translated">Template#helpers()</target>
        </trans-unit>
        <trans-unit id="94d18a58f4d1c36790911a050f2b383247c749c9" translate="yes" xml:space="preserve">
          <source>Template#onCreated</source>
          <target state="translated">Template#onCreated</target>
        </trans-unit>
        <trans-unit id="5fc234b06b339f13553e21c57fe129c6b3870c7d" translate="yes" xml:space="preserve">
          <source>Template#onDestroyed</source>
          <target state="translated">Template#onDestroyed</target>
        </trans-unit>
        <trans-unit id="f70cfeefd66c6d59a23695f76f055c20c08a8ab5" translate="yes" xml:space="preserve">
          <source>Template#onRendered</source>
          <target state="translated">Template#onRendered</target>
        </trans-unit>
        <trans-unit id="ee4905bfe20e62ceb883b0dd1c895d6c08b79498" translate="yes" xml:space="preserve">
          <source>Template.body</source>
          <target state="translated">Template.body</target>
        </trans-unit>
        <trans-unit id="cf6122bfebfbe04ad334163b6cdbae804dc4629c" translate="yes" xml:space="preserve">
          <source>Template.currentData()</source>
          <target state="translated">Template.currentData()</target>
        </trans-unit>
        <trans-unit id="30ef925fcbd26103b22179b021ac812bcf7b2a82" translate="yes" xml:space="preserve">
          <source>Template.instance()</source>
          <target state="translated">Template.instance()</target>
        </trans-unit>
        <trans-unit id="0a5041bb7a0ef0a391ef9a428d41bde65e2b974e" translate="yes" xml:space="preserve">
          <source>Template.parentData()</source>
          <target state="translated">Template.parentData()</target>
        </trans-unit>
        <trans-unit id="b856e3cccd43f16d4b078a0b3968edfeb4ebf4ca" translate="yes" xml:space="preserve">
          <source>Template.registerHelper()</source>
          <target state="translated">Template.registerHelper()</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="241156fe7b111b0119698d0ac0de8840677acb6f" translate="yes" xml:space="preserve">
          <source>Templates and HTML</source>
          <target state="translated">템플릿 및 HTML</target>
        </trans-unit>
        <trans-unit id="5a679dbcb04acbd729bc2083a60a2f2f653eb626" translate="yes" xml:space="preserve">
          <source>Templates and components</source>
          <target state="translated">템플릿 및 구성 요소</target>
        </trans-unit>
        <trans-unit id="29e93519e88967304d1daa33b2822c504b9680b1" translate="yes" xml:space="preserve">
          <source>Templates defined by the template compiler, such as &lt;code&gt;Template.myTemplate&lt;/code&gt;, are objects of type &lt;code&gt;Blaze.Template&lt;/code&gt; (aliased as &lt;code&gt;Template&lt;/code&gt;).</source>
          <target state="translated">Template.myTemplate과 같은 템플릿 컴파일러로 정의 된 &lt;code&gt;Template.myTemplate&lt;/code&gt; 은 &lt;code&gt;Blaze.Template&lt;/code&gt; 유형의 객체입니다 ( &lt;code&gt;Template&lt;/code&gt; 로 별칭 지정 ).</target>
        </trans-unit>
        <trans-unit id="c025d2ae33754d4bfe4d335c9cb82163f641d492" translate="yes" xml:space="preserve">
          <source>Test Files</source>
          <target state="translated">테스트 파일</target>
        </trans-unit>
        <trans-unit id="87a1d1d44fb17167a54fb7c79b121ad07f74c815" translate="yes" xml:space="preserve">
          <source>Test Meteor packages, either by name, or by directory. Not specifying an argument will run tests for all local packages. The results are displayed in an app that runs at &lt;code&gt;localhost:3000&lt;/code&gt; by default. If you need to, you can pass the &lt;code&gt;--settings&lt;/code&gt; and &lt;code&gt;--port&lt;/code&gt; arguments.</source>
          <target state="translated">이름 또는 디렉토리로 Meteor 패키지를 테스트하십시오. 인수를 지정하지 않으면 모든 로컬 패키지에 대한 테스트가 실행됩니다. 결과는 기본적으로 &lt;code&gt;localhost:3000&lt;/code&gt; 에서 실행되는 앱에 표시됩니다 . 필요한 경우 &lt;code&gt;--settings&lt;/code&gt; 및 &lt;code&gt;--port&lt;/code&gt; 인수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87514101785630549e54861e7e3b772a0e86078e" translate="yes" xml:space="preserve">
          <source>Test data</source>
          <target state="translated">테스트 데이터</target>
        </trans-unit>
        <trans-unit id="4a06fef6a0fa977984162a2767d7bc80aae40286" translate="yes" xml:space="preserve">
          <source>Test files themselves (for example a file named &lt;code&gt;todos-item.test.js&lt;/code&gt; or &lt;code&gt;routing.app-specs.coffee&lt;/code&gt;) can register themselves to be run by the test driver in the usual way for that testing library. For Mocha, that&amp;rsquo;s by using &lt;code&gt;describe&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt;:</source>
          <target state="translated">테스트 파일 자체 (예 : &lt;code&gt;todos-item.test.js&lt;/code&gt; 또는 &lt;code&gt;routing.app-specs.coffee&lt;/code&gt; 파일 )는 해당 테스트 라이브러리에 대해 일반적인 방식으로 테스트 드라이버가 실행하도록 등록 할 수 있습니다. Mocha의 경우 &lt;code&gt;describe&lt;/code&gt; 와 &lt;code&gt;it&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="0fa762720da1f7c5efd2ed8b5502936147a15cdc" translate="yes" xml:space="preserve">
          <source>Test if a session variable is equal to a value. If inside a &lt;a href=&quot;#reactivity&quot;&gt;reactive computation&lt;/a&gt;, invalidate the computation the next time the variable changes to or from the value.</source>
          <target state="translated">세션 변수가 값과 같은지 테스트하십시오. &lt;a href=&quot;#reactivity&quot;&gt;반응 계산&lt;/a&gt; 내부에 있으면 다음에 변수가 값에서 변경되거나 값이 변경 될 때 계산이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="a8d9f1a6657856f2287a9e4d4457163b88c30e0c" translate="yes" xml:space="preserve">
          <source>Testing allows you to ensure your application works the way you think it does, especially as your codebase changes over time. If you have good tests, you can refactor and rewrite code with confidence. Tests are also the most concrete form of documentation of expected behavior, since other developers can figure out how to use your code by reading the tests.</source>
          <target state="translated">테스트를 통해 특히 코드베이스가 시간이 지남에 따라 변경 될 때 응용 프로그램이 생각한대로 작동하는지 확인할 수 있습니다. 테스트가 양호하면 자신있게 코드를 리팩터링하고 다시 작성할 수 있습니다. 다른 개발자가 테스트를 읽고 코드를 사용하는 방법을 알 수 있기 때문에 테스트는 예상되는 동작에 대한 가장 구체적인 형태의 문서입니다.</target>
        </trans-unit>
        <trans-unit id="dddc3f861194f3b4a52169865358ab5cf7cb5272" translate="yes" xml:space="preserve">
          <source>Testing packages</source>
          <target state="translated">테스트 패키지</target>
        </trans-unit>
        <trans-unit id="2687e96cfa9d1d8d9233168af944ddc7ab3ff1f7" translate="yes" xml:space="preserve">
          <source>Testing publications</source>
          <target state="translated">출판물 테스트</target>
        </trans-unit>
        <trans-unit id="b629a403b8cdc9e9bfb8978fd80ebef4c680151f" translate="yes" xml:space="preserve">
          <source>Thanks to Meteor&amp;rsquo;s automatic handling of optimistic UI, if a method unexpectedly fails the optimistic changes will roll back and the Minimongo database will end up in a consistent state. If you are rendering directly from Minimongo, the user will see something that is consistent, even if it&amp;rsquo;s not what they anticipated of course. In some cases when you have state you are keeping outside of Minimongo, you may need to make changes to it manually to reflect this. You can see this in the example above where we had to update the router manually after an operation failed.</source>
          <target state="translated">Meteor의 낙관적 UI 자동 처리 덕분에 방법이 예기치 않게 실패하면 낙관적 변경이 롤백되고 Minimongo 데이터베이스가 일관된 상태가됩니다. Minimongo에서 직접 렌더링하는 경우 사용자는 물론 예상치 못한 것이라도 일관된 내용을 보게됩니다. 경우에 따라 Minimongo 외부에 보관하고있는 상태 인 경우이를 반영하기 위해 수동으로 변경해야 할 수도 있습니다. 작업이 실패한 후 라우터를 수동으로 업데이트해야하는 위의 예에서이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74debe8633cb830359b907ee833bcb0786e3cdda" translate="yes" xml:space="preserve">
          <source>Thanks to modules, any load-order dependency you might imagine can be resolved by adding an &lt;code&gt;import&lt;/code&gt; statement. So if &lt;code&gt;a.js&lt;/code&gt; loads before &lt;code&gt;b.js&lt;/code&gt; because of their file names, but &lt;code&gt;a.js&lt;/code&gt; needs something defined by &lt;code&gt;b.js&lt;/code&gt;, then &lt;code&gt;a.js&lt;/code&gt; can simply &lt;code&gt;import&lt;/code&gt; that value from &lt;code&gt;b.js&lt;/code&gt;:</source>
          <target state="translated">모듈 덕분에 &lt;code&gt;import&lt;/code&gt; 문 을 추가하여 상상할 수있는로드 순서 종속성을 해결할 수 있습니다 . 경우에 따라서 &lt;code&gt;a.js&lt;/code&gt; 의 전 부하 &lt;code&gt;b.js&lt;/code&gt; 때문에 파일 이름 만 &lt;code&gt;a.js&lt;/code&gt; 가 에 의해 정의 된 것을 필요로 &lt;code&gt;b.js&lt;/code&gt; 을 다음 &lt;code&gt;a.js&lt;/code&gt; 은 간단하게 할 수 있습니다 &lt;code&gt;import&lt;/code&gt; 에서 그 값 &lt;code&gt;b.js&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="34a8b6200074d30b9b2b9a0aee58401c6db6f443" translate="yes" xml:space="preserve">
          <source>Thanks to the guarantees provided by DDP and Meteor&amp;rsquo;s accounts system, the above publication can be confident that it will only ever publish private lists to the user that they belong to. Note that the publication will re-run if the user logs out (or back in again), which means that the published set of private lists will change as the active user changes.</source>
          <target state="translated">DDP와 Meteor의 계정 시스템이 제공하는 보증 덕분에 위의 출판물은 자신이 속한 사용자에게 개인 목록 만 게시 할 것이라고 확신 할 수 있습니다. 사용자가 로그 아웃하거나 다시 로그인하면 게시가 다시 실행되므로 게시 된 개인 목록 세트는 활성 사용자가 변경됨에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="37bc1757280417ab2e024852d14ee4b639696c3d" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;current View&amp;rdquo; is kept in &lt;a href=&quot;#Blaze-currentView&quot;&gt;&lt;code&gt;Blaze.currentView&lt;/code&gt;&lt;/a&gt; and is set during View rendering, callbacks, autoruns, and template event handlers. It affects calls such as &lt;a href=&quot;templates#Template-currentData&quot;&gt;&lt;code&gt;Template.currentData()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;현재 뷰&quot;는 &lt;a href=&quot;#Blaze-currentView&quot;&gt; &lt;code&gt;Blaze.currentView&lt;/code&gt; 에&lt;/a&gt; 유지되며 뷰 렌더링, 콜백, 자동 실행 및 템플릿 이벤트 처리기 중에 설정됩니다. &lt;a href=&quot;templates#Template-currentData&quot;&gt; &lt;code&gt;Template.currentData()&lt;/code&gt; &lt;/a&gt; 와 같은 호출에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="edc291428b27f7f9fba068db1d70b436d6781473" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;current view&amp;rdquo; is used by &lt;a href=&quot;templates#Template-currentData&quot;&gt;&lt;code&gt;Template.currentData()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates#Template-instance&quot;&gt;&lt;code&gt;Template.instance()&lt;/code&gt;&lt;/a&gt; to determine the contextually relevant data context and template instance.</source>
          <target state="translated">&quot;현재보기&quot;는 &lt;a href=&quot;templates#Template-currentData&quot;&gt; &lt;code&gt;Template.currentData()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;templates#Template-instance&quot;&gt; &lt;code&gt;Template.instance()&lt;/code&gt; &lt;/a&gt; 에서 컨텍스트 관련 데이터 컨텍스트 및 템플릿 인스턴스를 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="498a8e5e30464099d72aae3e631f20d81add1e57" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;meteor test&amp;rsquo; command</source>
          <target state="translated">'유성 테스트'명령</target>
        </trans-unit>
        <trans-unit id="1f077f0cd8f98b1c7830ad41c879a0bebb4706a8" translate="yes" xml:space="preserve">
          <source>The (extended) &lt;a href=&quot;http://www.semver.org&quot;&gt;semver&lt;/a&gt; version for your package. Additionally, Meteor allows a wrap number: a positive integer that follows the version number. If you are porting another package that uses semver versioning, you may want to use the original version, postfixed with &lt;code&gt;_wrapnumber&lt;/code&gt;. For example, &lt;code&gt;1.2.3_1&lt;/code&gt; or &lt;code&gt;2.4.5-rc1_4&lt;/code&gt;. Wrap numbers sort after the original numbers: &lt;code&gt;1.2.3&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.3_1&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.3_2&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.4-rc.0&lt;/code&gt;. If no version is specified, this field defaults to &lt;code&gt;0.0.0&lt;/code&gt;. If you want to publish your package to the package server, you must specify a version.</source>
          <target state="translated">패키지 의 (확장 된) &lt;a href=&quot;http://www.semver.org&quot;&gt;semver&lt;/a&gt; 버전. 또한 Meteor는 랩 번호를 허용합니다. 버전 번호 뒤에 오는 양의 정수입니다. semver 버전 관리를 사용하는 다른 패키지를 포팅하는 경우 _wrapnumber 접미사가 &lt;code&gt;_wrapnumber&lt;/code&gt; 원래 버전을 사용할 수 있습니다 . 예를 들어 &lt;code&gt;1.2.3_1&lt;/code&gt; 또는 &lt;code&gt;2.4.5-rc1_4&lt;/code&gt; 입니다. 랩 번호는 원래 번호 다음에 정렬됩니다 : &lt;code&gt;1.2.3&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.3_1&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.3_2&lt;/code&gt; &amp;lt; &lt;code&gt;1.2.4-rc.0&lt;/code&gt; . 버전을 지정하지 않으면이 필드의 기본값은 &lt;code&gt;0.0.0&lt;/code&gt; 입니다. 패키지를 패키지 서버에 게시하려면 버전을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="720f7a15f8ef4cd75bf1890491a0834595f0f4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Template-Declarations&quot;&gt;template object&lt;/a&gt; representing your &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;a href=&quot;#Template-Declarations&quot;&gt;템플릿 객체&lt;/a&gt; 당신의 표현 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그를.</target>
        </trans-unit>
        <trans-unit id="37f50de62554904500225788d9479d70a34287db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Template-instances&quot;&gt;template instance&lt;/a&gt; corresponding to the current template helper, event handler, callback, or autorun. If there isn't one, &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Template-instances&quot;&gt;템플릿 인스턴스&lt;/a&gt; 현재 템플릿 도우미, 이벤트 핸들러, 콜백, 또는 자동 실행에 해당. 하나가없는 경우 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9502dc40a988bfb0e7a3108ed20e41444d9ba8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;blaze#Blaze-View&quot;&gt;View&lt;/a&gt; object for this invocation of the template.</source>
          <target state="translated">이 템플릿 호출에 대한 &lt;a href=&quot;blaze#Blaze-View&quot;&gt;View&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e1f87f80f657b3c027fa8cbb0c85ddd64f63a257" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;build-tool#what-it-does&quot;&gt;Meteor build tool&lt;/a&gt; and the &lt;code&gt;meteor test&lt;/code&gt; command ignore any files located in any &lt;code&gt;tests/&lt;/code&gt; directory. This allows you to put tests in this directory that you can run using a test runner outside of Meteor&amp;rsquo;s built-in test tools and still not have those files loaded in your application. See Meteor&amp;rsquo;s &lt;a href=&quot;structure#load-order&quot;&gt;default file load order&lt;/a&gt; rules.</source>
          <target state="translated">&lt;a href=&quot;build-tool#what-it-does&quot;&gt;유성 빌드 도구&lt;/a&gt; 와 &lt;code&gt;meteor test&lt;/code&gt; 명령은에있는 모든 파일 무시 &lt;code&gt;tests/&lt;/code&gt; 디렉토리. 이를 통해 Meteor의 내장 테스트 도구 외부에서 테스트 러너를 사용하여 실행할 수있는 테스트를이 디렉토리에 넣을 수 있으며 해당 파일을 애플리케이션에로드하지 않아도됩니다. Meteor의 &lt;a href=&quot;structure#load-order&quot;&gt;기본 파일로드 순서&lt;/a&gt; 규칙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a450a62817802ec8fe740cfbc4a152496bfb81c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_method&quot;&gt;HTTP method&lt;/a&gt; to use, such as &quot;&lt;code&gt;GET&lt;/code&gt;&quot;, &quot;&lt;code&gt;POST&lt;/code&gt;&quot;, or &quot;&lt;code&gt;HEAD&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_method&quot;&gt;HTTP 방법&lt;/a&gt; 예 : &quot;로 사용, &lt;code&gt;GET&lt;/code&gt; &quot;, &quot; &lt;code&gt;POST&lt;/code&gt; &quot;, 또는 &quot; &lt;code&gt;HEAD&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="0a53aebbf6d34463a81d54cae71dfb3f69c070c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://atmospherejs.com/hwillson/stub-collections&quot;&gt;&lt;code&gt;hwillson:stub-collections&lt;/code&gt;&lt;/a&gt; package we mentioned &lt;a href=&quot;#mocking-the-database&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/hwillson/stub-collections&quot;&gt; &lt;code&gt;hwillson:stub-collections&lt;/code&gt; &lt;/a&gt; 패키지는 우리가 언급 &lt;a href=&quot;#mocking-the-database&quot;&gt;위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="534b26dee33fb34fe43c5f25213cbfa079600bb3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://atmospherejs.com/meteor/apollo&quot;&gt;&lt;code&gt;apollo&lt;/code&gt; Atmosphere package&lt;/a&gt; for Meteor provides integration with &lt;a href=&quot;http://www.apollodata.com/&quot;&gt;Apollo&lt;/a&gt; (and thus GraphQL).</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/meteor/apollo&quot;&gt; &lt;code&gt;apollo&lt;/code&gt; 분위기 패키지&lt;/a&gt; 유성에 대한이 통합 제공 &lt;a href=&quot;http://www.apollodata.com/&quot;&gt;아폴로&lt;/a&gt; (따라서 및 GraphQL을).</target>
        </trans-unit>
        <trans-unit id="5d407bf8eea58896a623c449771f8cdd09fa8ad2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt;&lt;code&gt;reactive-dict&lt;/code&gt;&lt;/a&gt; package lets you define a simple reactive key-value dictionary. It&amp;rsquo;s a convenient way to attach internal state to a component. We create the &lt;code&gt;state&lt;/code&gt; dictionary in the &lt;code&gt;onCreated&lt;/code&gt; callback, and attach it to the template instance:</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt; &lt;code&gt;reactive-dict&lt;/code&gt; &lt;/a&gt; 패키지는 간단한 반응 키와 값의 사전을 정의 할 수 있습니다. 내부 상태를 구성 요소에 연결하는 편리한 방법입니다. &lt;code&gt;onCreated&lt;/code&gt; 콜백 에서 &lt;code&gt;state&lt;/code&gt; 사전을 생성하여 템플릿 인스턴스에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="a2991e0bd23b6c144c6722ea0d60f802e82e6550" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://atmospherejs.com/velocity/meteor-stubs&quot;&gt;&lt;code&gt;velocity:meteor-stubs&lt;/code&gt;&lt;/a&gt; package, which creates simple stubs for most Meteor core objects.</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/velocity/meteor-stubs&quot;&gt; &lt;code&gt;velocity:meteor-stubs&lt;/code&gt; &lt;/a&gt; 대부분의 유성 코어 개체에 대한 간단한 스텁을 생성 패키지.</target>
        </trans-unit>
        <trans-unit id="2daed1b94fd1329afc419eba63cb003c11445519" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.meteor.com&quot;&gt;Meteor docs&lt;/a&gt; is the best place to find the core API documentation of the platform.</source>
          <target state="translated">&lt;a href=&quot;https://docs.meteor.com&quot;&gt;유성 문서는&lt;/a&gt; 플랫폼의 핵심 API 문서를 찾을 수있는 최고의 장소입니다.</target>
        </trans-unit>
        <trans-unit id="16bf8aecfdbb8e5e6599a19bb132dc1524af78de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_method&quot;&gt;HTTP method&lt;/a&gt; to use, such as &quot;&lt;code&gt;GET&lt;/code&gt;&quot;, &quot;&lt;code&gt;POST&lt;/code&gt;&quot;, or &quot;&lt;code&gt;HEAD&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f719fe6d54eb82f96f7e043931f576ef99fe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/arunoda/meteor-up/tree/mupx&quot;&gt;&lt;code&gt;mupx&lt;/code&gt;&lt;/a&gt; branch (best for pre-Meteor 1.4)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/arunoda/meteor-up/tree/mupx&quot;&gt; &lt;code&gt;mupx&lt;/code&gt; 의&lt;/a&gt; 지점 (가장 사전 유성 1.4)</target>
        </trans-unit>
        <trans-unit id="119e0391fd90d30f59076159266e695da881da09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/kadirahq/meteor-up&quot;&gt;&lt;code&gt;kadirahq/mup&lt;/code&gt;&lt;/a&gt; fork &lt;em&gt;(best for Meteor 1.4 or higher)&lt;/em&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/kadirahq/meteor-up&quot;&gt; &lt;code&gt;kadirahq/mup&lt;/code&gt; &lt;/a&gt; 포크 &lt;em&gt;(최고 유성 1.4 이상 사용)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c54f06d8d72feecced755a2d90987a690cc30863" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#the-flush-cycle&quot;&gt;Tracker manual&lt;/a&gt; describes the motivation for the flush cycle and the guarantees made by &lt;code&gt;Tracker.flush&lt;/code&gt; and &lt;code&gt;Tracker.afterFlush&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#the-flush-cycle&quot;&gt;추적기 설명서는&lt;/a&gt; 플러시주기에 대한 동기를 부여하고 의해 만들어진 보장에 대해 설명 &lt;code&gt;Tracker.flush&lt;/code&gt; 및 &lt;code&gt;Tracker.afterFlush&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="9544209b8e2b457db7d1752161262706c02f8312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#let&lt;/code&gt; tag creates a new alias variable for a given expression. While it doesn&amp;rsquo;t change the data context, it allows to refer to an expression (helper, data context, another variable) with a short-hand within the template:</source>
          <target state="translated">&lt;code&gt;#let&lt;/code&gt; 태그는 주어진 표현을위한 새로운 별칭 변수를 만듭니다. 데이터 컨텍스트를 변경하지는 않지만 템플릿 내에서 축약 형이있는 표현식 (헬퍼, 데이터 컨텍스트, 다른 변수)을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1199bf2ca9bb11d0c1723650cd941df651e77b90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;Blaze template=&quot;itemsList&quot; items={items} /&amp;gt;&lt;/code&gt; line is the same as if you had written &lt;code&gt;{{&amp;gt; itemsList items=items}}&lt;/code&gt; inside of a Blaze template. For other options and further information, see the package&amp;rsquo;s &lt;a href=&quot;https://github.com/gadicc/meteor-blaze-react-component&quot;&gt;project page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Blaze template=&quot;itemsList&quot; items={items} /&amp;gt;&lt;/code&gt; 당신이 쓴 것처럼 라인이 동일 &lt;code&gt;{{&amp;gt; itemsList items=items}}&lt;/code&gt; 불꽃 템플릿의 내부. 다른 옵션 및 자세한 내용은 패키지 &lt;a href=&quot;https://github.com/gadicc/meteor-blaze-react-component&quot;&gt;프로젝트 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1f18f57a33f5eef39686bbd60f04a3b2695e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt; should be the address of the server you want your app to connect to.</source>
          <target state="translated">&lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;port&amp;gt;&lt;/code&gt; 앱 연결하려는 서버의 주소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a358091c0c7f33df251b91e5f3e17c14b17d6fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then()&lt;/code&gt; method of the &lt;code&gt;Promise&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 의 &lt;code&gt;.then()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="168a5c0ab7b1c62cceb14ec134b59285f9a47039" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AccountsClient&lt;/code&gt; and &lt;code&gt;AccountsServer&lt;/code&gt; classes share a common superclass, &lt;code&gt;AccountsCommon&lt;/code&gt;. Methods defined on &lt;code&gt;AccountsCommon.prototype&lt;/code&gt; will be available on both the client and the server, via the predefined &lt;code&gt;Accounts&lt;/code&gt; object (most common) or any custom &lt;code&gt;accountsClientOrServer&lt;/code&gt; object created using the &lt;code&gt;AccountsClient&lt;/code&gt; or &lt;code&gt;AccountsServer&lt;/code&gt; constructors (less common).</source>
          <target state="translated">&lt;code&gt;AccountsClient&lt;/code&gt; 및 &lt;code&gt;AccountsServer&lt;/code&gt; 클래스는 공통의 슈퍼 클래스, 공유 &lt;code&gt;AccountsCommon&lt;/code&gt; 을 . &lt;code&gt;AccountsCommon.prototype&lt;/code&gt; 에 정의 된 메소드 는 사전 정의 된 &lt;code&gt;Accounts&lt;/code&gt; 오브젝트 (가장 흔함) 또는 &lt;code&gt;AccountsClient&lt;/code&gt; 또는 &lt;code&gt;AccountsServer&lt;/code&gt; 생성자를 사용하여 작성된 사용자 정의 &lt;code&gt;accountsClientOrServer&lt;/code&gt; 오브젝트 (보다 흔하지 않음) 를 통해 클라이언트와 서버 모두에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53d896014c69bd5f40201df6b83c6bce629451f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;App_rootRedirector&lt;/code&gt; component is rendered inside the &lt;code&gt;App_body&lt;/code&gt; layout, which takes care of subscribing to the set of lists the user knows about &lt;em&gt;before&lt;/em&gt; rendering its sub-component, and we are guaranteed there is at least one such list. This means that if the &lt;code&gt;App_rootRedirector&lt;/code&gt; ends up being created, there&amp;rsquo;ll be a list loaded, so we can simply do:</source>
          <target state="translated">&lt;code&gt;App_rootRedirector&lt;/code&gt; 의 구성 요소는 내부 렌더링 &lt;code&gt;App_body&lt;/code&gt; 사용자가 알고있는리스트의 집합에 가입을 담당 레이아웃, &lt;em&gt;전에&lt;/em&gt; 하위 구성 요소를 렌더링, 우리는 적어도 하나 개의 목록이 보장됩니다. 즉, &lt;code&gt;App_rootRedirector&lt;/code&gt; 가 생성되면 목록이로드되므로 다음과 같이 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10a4d76dba5aaaeec68ecfe67b4f107ae4fd4de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lists_show_page&lt;/code&gt; template renders &lt;em&gt;without&lt;/em&gt; arguments&amp;mdash;it is this template&amp;rsquo;s responsibility to collect information from the current route, and then pass this information down into its child templates. Correspondingly the &lt;code&gt;Lists_show_page&lt;/code&gt; template is very tied to the route that rendered it, and so it needs to be a smart component. See the article on &lt;a href=&quot;ui-ux&quot;&gt;UI/UX&lt;/a&gt; for more about smart and reusable components.</source>
          <target state="translated">&lt;code&gt;Lists_show_page&lt;/code&gt; 의 템플릿을 렌더링 &lt;em&gt;없이&lt;/em&gt; 인수-는 현재 경로로부터 수집 한 정보에이 템플릿의 책임이며, 다음 하위 템플릿에이 정보를 전달합니다. 이에 따라 &lt;code&gt;Lists_show_page&lt;/code&gt; 템플릿은 렌더링 한 경로와 매우 밀접하게 연결되어 있으므로 스마트 구성 요소 여야합니다. 스마트하고 재사용 가능한 구성 요소에 대한 자세한 내용은 &lt;a href=&quot;ui-ux&quot;&gt;UI / UX 관련&lt;/a&gt; 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4747eae57c26b0d41ece7eda66ca67d658307501" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;METEOR_CORDOVA_COMPAT_VERSION_*&lt;/code&gt; env vars must be present &lt;strong&gt;while building&lt;/strong&gt; your app through &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;build&lt;/code&gt; or &lt;code&gt;deploy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;METEOR_CORDOVA_COMPAT_VERSION_*&lt;/code&gt; ENV가 있어야 바르 &lt;strong&gt;구축하는 동안&lt;/strong&gt; 을 통해 응용 프로그램을 &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;build&lt;/code&gt; 또는 &lt;code&gt;deploy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dc9bf0e45b3728817f53fc34f51837a4a4698da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyLinter&lt;/code&gt; class should now implement the &lt;code&gt;processFilesForPackage&lt;/code&gt; method. The method should accept two arguments: a list of files and an options object.</source>
          <target state="translated">&lt;code&gt;MyLinter&lt;/code&gt; 의 클래스는 현재 구현해야 &lt;code&gt;processFilesForPackage&lt;/code&gt; 의 방법을. 이 메소드는 파일 목록과 옵션 객체라는 두 가지 인수를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="52a56cc43a7528c5c6111b04f0f4d05397745f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ValidationError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ValidationError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28f41a1cb4d3fde6c4ca3b32167b118bb5ec716d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accounts-base&lt;/code&gt; package exports two constructors, called &lt;code&gt;AccountsClient&lt;/code&gt; and &lt;code&gt;AccountsServer&lt;/code&gt;, which are used to create the &lt;code&gt;Accounts&lt;/code&gt; object that is available on the client and the server, respectively.</source>
          <target state="translated">&lt;code&gt;accounts-base&lt;/code&gt; 라는 패키지 수출이 생성자, &lt;code&gt;AccountsClient&lt;/code&gt; 및 &lt;code&gt;AccountsServer&lt;/code&gt; 작성하는 데 사용됩니다, &lt;code&gt;Accounts&lt;/code&gt; 각각 클라이언트와 서버에서 사용할 개체를.</target>
        </trans-unit>
        <trans-unit id="5338034bb1c6ea18b1d533a77f342fbc45cde4c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accounts-password&lt;/code&gt; package contains a full system for password-based authentication. In addition to the basic username and password-based sign-in process, it also supports email-based sign-in including address verification and password recovery emails.</source>
          <target state="translated">&lt;code&gt;accounts-password&lt;/code&gt; 패키지는 암호 기반 인증에 대한 전체 시스템이 포함되어 있습니다. 기본 사용자 이름 및 비밀번호 기반 로그인 프로세스 외에도 주소 확인 및 비밀번호 복구 이메일을 포함한 이메일 기반 로그인도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="873e5e9c45468e38dffc64d1d31b2927218a4c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;appcache&lt;/code&gt; package stores the static parts of a Meteor application (the client side Javascript, HTML, CSS, and images) in the browser&amp;rsquo;s &lt;a href=&quot;https://en.wikipedia.org/wiki/AppCache&quot;&gt;application cache&lt;/a&gt;. To enable caching simply add the &lt;code&gt;appcache&lt;/code&gt; package to your project.</source>
          <target state="translated">&lt;code&gt;appcache&lt;/code&gt; 패키지 저장 브라우저에서 유성 응용 프로그램 (클라이언트 측 자바 스크립트, HTML, CSS, 이미지)의 정적 인 부분 &lt;a href=&quot;https://en.wikipedia.org/wiki/AppCache&quot;&gt;응용 프로그램 캐시&lt;/a&gt; . 캐싱을 활성화하려면 간단히 프로젝트에 &lt;code&gt;appcache&lt;/code&gt; 패키지를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="620306c025cce35a68c4384e5e838f125d384040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bundle-visualizer&lt;/code&gt; package is an analysis tool which provides a visual representation within the web browser showing what is included in the initial client bundle. The initial client bundle is the primary package of code downloaded and executed by the browser to run a Meteor application and includes packages which have been added via &lt;code&gt;meteor add &amp;lt;package&amp;gt;&lt;/code&gt; or Node modules included in the &lt;code&gt;node_modules&lt;/code&gt; directory and used in an application.</source>
          <target state="translated">&lt;code&gt;bundle-visualizer&lt;/code&gt; 패키지는 초기 클라이언트 번들에 포함 된 항목 보여주는 웹 브라우저에서 시각적 표현을 제공하는 분석 도구이다. 초기 클라이언트 번들은 Meteor 애플리케이션을 실행하기 위해 브라우저에서 다운로드하여 실행하는 기본 코드 패키지이며 &lt;code&gt;node_modules&lt;/code&gt; 디렉토리에 포함 된 &lt;code&gt;meteor add &amp;lt;package&amp;gt;&lt;/code&gt; 또는 Node 모듈을 통해 추가 되어 애플리케이션에 사용 된 패키지를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="649991da5abd40f8b85d1656bc4a777e7eff8a60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;check&lt;/code&gt; package includes pattern checking functions useful for checking the types and structure of variables and an &lt;a href=&quot;#matchpatterns&quot;&gt;extensible library of patterns&lt;/a&gt; to specify which types you are expecting.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 패키지는 유형과 변수의 구조와 확인하는 데 유용 패턴 검사 기능이 포함 &lt;a href=&quot;#matchpatterns&quot;&gt;패턴의 확장 라이브러리를&lt;/a&gt; 당신이 기대하는 유형 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c20025be87cd004083251793aaf578fbf14abd94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chimp-test&lt;/code&gt; command will run all of the tests &lt;em&gt;once only&lt;/em&gt; and is good for testing that our suite passes, either as a manual step, or as part of a &lt;a href=&quot;#ci&quot;&gt;continuous integration&lt;/a&gt; process.</source>
          <target state="translated">&lt;code&gt;chimp-test&lt;/code&gt; 명령은 모든 테스트 실행 &lt;em&gt;한 번만를&lt;/em&gt; 우리의 제품군을 전달하는 테스트를위한 좋은 것입니다, 중 수동 단계로, 또는의 일환으로 &lt;a href=&quot;#ci&quot;&gt;지속적인 통합&lt;/a&gt; 과정.</target>
        </trans-unit>
        <trans-unit id="0c414fba55f12b2f37dd8193c89aaf75bd858a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chimp-watch&lt;/code&gt; command will then run the test in a browser, and continue to re-run it as we change the test or the application. (Note that the test assumes we are running the app on port &lt;code&gt;3000&lt;/code&gt;).</source>
          <target state="translated">그런 다음 &lt;code&gt;chimp-watch&lt;/code&gt; 명령은 브라우저에서 테스트를 실행하고 테스트 또는 응용 프로그램을 변경하면 계속해서 다시 실행합니다. (테스트는 포트 &lt;code&gt;3000&lt;/code&gt; 에서 앱을 실행한다고 가정합니다 ).</target>
        </trans-unit>
        <trans-unit id="3d9c3a6c6c53efb4fbaf6614bb10cec10d9acea8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component&lt;/code&gt; argument is the React component to include, which should be passed in with a helper.</source>
          <target state="translated">&lt;code&gt;component&lt;/code&gt; 인수는이 도우미로 전달되어야하는, 포함 요소 반작용이다.</target>
        </trans-unit>
        <trans-unit id="b423c736a072ef8990b145a544ae078062f0d84f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;connection&lt;/code&gt; object the request came in on. See &lt;a href=&quot;#meteor_onconnection&quot;&gt;&lt;code&gt;Meteor.onConnection&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;connection&lt;/code&gt; 개체는 요청에 들어왔다. 자세한 내용은 &lt;a href=&quot;#meteor_onconnection&quot;&gt; &lt;code&gt;Meteor.onConnection&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec9e7db73c437f025e26d37ecb522f73570bee85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cordovaCompatibilityVersions.*&lt;/code&gt; attributes can be read from the manifest file with &lt;code&gt;cordova-plugin-file&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cordovaCompatibilityVersions.*&lt;/code&gt; 속성과 매니페스트 파일에서 읽을 수 있습니다 &lt;code&gt;cordova-plugin-file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47e3f54f4885264c768a38124d100596fda29c7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynamic-import&lt;/code&gt; package provides an implementation of &lt;code&gt;Module.prototype.dynamicImport&lt;/code&gt;, an extension of the module runtime which powers the &lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;dynamic &lt;code&gt;import(...)&lt;/code&gt;&lt;/a&gt; statement, an up-and-coming (currently stage 3 out of 4) addition to the ECMAScript standard.</source>
          <target state="translated">&lt;code&gt;dynamic-import&lt;/code&gt; 패키지의 구현 제공 &lt;code&gt;Module.prototype.dynamicImport&lt;/code&gt; , 모듈 런타임의 확장에 전력을 &lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;동적 &lt;code&gt;import(...)&lt;/code&gt; &lt;/a&gt; 받는 문, 떠오르는 (4 현재 3 단계 아웃) 추가 ECMAScript 표준.</target>
        </trans-unit>
        <trans-unit id="7dff7e7da16368cdf28699bd824354b0c058dc04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmascript&lt;/code&gt; package (which is installed into all new apps and packages by default, but can be removed), allows support for many ES2015 features. We recommend using it. You can read more about it in the &lt;a href=&quot;code-style#ecmascript&quot;&gt;Code Style&lt;/a&gt; article.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; (기본적으로 모든 새로운 응용 프로그램과 패키지로 설치되어 있지만 제거 할 수 있습니다) 패키지는 많은 ES2015의 기능에 대한 지원을 할 수 있습니다. 사용하는 것이 좋습니다. &lt;a href=&quot;code-style#ecmascript&quot;&gt;코드 스타일&lt;/a&gt; 기사 에서 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd3dd0ace8907b5e0479ac6313b096f0e060ae8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmascript&lt;/code&gt; package is included in all new apps and packages by default, and compiles all files with the &lt;code&gt;.js&lt;/code&gt; file extension automatically. See the &lt;a href=&quot;https://docs.meteor.com/packages/ecmascript.html#Supported-ES2015-Features&quot;&gt;list of all ES2015 features supported by the ecmascript package&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지는 기본적으로 모든 새로운 응용 프로그램과 패키지에 포함하고, 모든 파일을 컴파일한다 &lt;code&gt;.js&lt;/code&gt; 자동으로 파일 확장자. &lt;a href=&quot;https://docs.meteor.com/packages/ecmascript.html#Supported-ES2015-Features&quot;&gt;ecmascript 패키지가 지원하는 모든 ES2015 기능 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17cf20872264d949bdcef3d3c2033fc5760145bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmascript&lt;/code&gt; package registers a compiler plugin that transpiles ECMAScript 2015+ to ECMAScript 5 (standard JS) in all &lt;code&gt;.js&lt;/code&gt; files. By default, this package is pre-installed for all new apps and packages.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지 레지스터 컴파일러 플러그인이 transpiles ECMAScript를 2015+ 모두 인 ECMAScript 5 (표준 JS)에 &lt;code&gt;.js&lt;/code&gt; 파일. 기본적으로이 패키지는 모든 새 앱 및 패키지에 사전 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a8b3c8262fc2252136036f013c160d56dd5d188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmascript&lt;/code&gt; package uses &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to compile ES2015 syntax to ES5 syntax. Many but not all ES2015 features can be simulated by Babel, and &lt;code&gt;ecmascript&lt;/code&gt; enables most of the features supported by Babel.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지는 사용 &lt;a href=&quot;http://babeljs.io/&quot;&gt;바벨을&lt;/a&gt; ES5 구문 ES2015 구문을 컴파일 할 수 있습니다. 모든 ES2015 기능은 아니지만 많은 기능을 Babel에서 시뮬레이션 할 수 있으며 &lt;code&gt;ecmascript&lt;/code&gt; 를 사용하면 Babel에서 지원하는 대부분의 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa499fef53c6f371c6fc1f7134efb2ace66bc2a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ecmascript&lt;/code&gt; package uses &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; to compile ES2015 syntax to ES5 syntax. Many but not all ES2015 features can be simulated by Babel, and &lt;code&gt;ecmascript&lt;/code&gt; enables most of the features supported by Babel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5709c3ce0d4f5eef2bb3e6d0197894dd845160e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;email&lt;/code&gt; package allows sending email from a Meteor app. To use it, add the package to your project by running in your terminal:</source>
          <target state="translated">&lt;code&gt;email&lt;/code&gt; 패키지는 유성 응용 프로그램에서 이메일을 보낼 수 있습니다. 이를 사용하려면 터미널에서 실행하여 패키지를 프로젝트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="75bc434fedd5db364cee84da82e3b7ea6a7fd722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals&lt;/code&gt; method should define an &lt;a href=&quot;http://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;. It should have the following properties:</source>
          <target state="translated">&lt;code&gt;equals&lt;/code&gt; 방법은 정의해야합니다 &lt;a href=&quot;http://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;동치 관계를&lt;/a&gt; . 다음과 같은 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c97b9869e8a631eb69ee2892b1b514232798800d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals&lt;/code&gt; method should define an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;. It should have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74205a7f7f7a0987b134f5ba577095d5ea14713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error.error&lt;/code&gt; field is the first argument to the &lt;code&gt;Meteor.Error&lt;/code&gt; constructor, and we use it to uniquely name and namespace all the errors we use in the application. We then define the English text of those errors in &lt;code&gt;i18n/en.i18n.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;error.error&lt;/code&gt; 의 필드에 첫 번째 인수 인 &lt;code&gt;Meteor.Error&lt;/code&gt; 의 생성자, 우리는 고유의 이름을 우리는 응용 프로그램에서 사용하는 모든 오류를 네임 스페이스에 사용합니다. 그런 다음 &lt;code&gt;i18n/en.i18n.json&lt;/code&gt; 에서 해당 오류의 영어 텍스트를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ca086329fccf9cd22eb4788c377fe3c33f7a9dbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the subscription this handle is for. When you run &lt;code&gt;Meteor.subscribe&lt;/code&gt; inside of &lt;code&gt;Tracker.autorun&lt;/code&gt;, the handles you get will always have the same &lt;code&gt;subscriptionId&lt;/code&gt; field. You can use this to deduplicate subscription handles if you are storing them in some data structure.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 이 핸들을위한 구독. &lt;code&gt;Tracker.autorun&lt;/code&gt; 내부에서 &lt;code&gt;Meteor.subscribe&lt;/code&gt; 를 실행할 때 얻는 핸들은 항상 &lt;code&gt;subscriptionId&lt;/code&gt; 필드 가 동일 합니다. 서브 스크립 션 핸들을 일부 데이터 구조에 저장하는 경우이를 사용하여 서브 스크립 션 핸들을 중복 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5533700215f55e478dcf036532d058d9ba5928f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import(...)&lt;/code&gt; statement returns a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; which is resolved with the &lt;code&gt;exports&lt;/code&gt; of the module when it has been successfully fetched from the server and is ready to be used.</source>
          <target state="translated">&lt;code&gt;import(...)&lt;/code&gt; 문은 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 으로 해결 &lt;code&gt;exports&lt;/code&gt; 이 서버에서 성공적으로 가져온 왔으며 사용할 준비가되었을 때 모듈을.</target>
        </trans-unit>
        <trans-unit id="f69950a9d9335d0328166b365b89658c24724adb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import(...)&lt;/code&gt;&lt;code&gt;Promise&lt;/code&gt; is resolved with the &lt;code&gt;exports&lt;/code&gt; of the module. If it&amp;rsquo;s necessary to use the &amp;ldquo;default&amp;rdquo; export from a module, it will be available on the &lt;code&gt;default&lt;/code&gt; property of the resulting object. In the above examples, this means it will be available as &lt;code&gt;tool.default&lt;/code&gt;. It can be helpful to use parameter de-structuring to provide additional clarity:</source>
          <target state="translated">&lt;code&gt;import(...)&lt;/code&gt; &lt;code&gt;Promise&lt;/code&gt; 으로 해결 &lt;code&gt;exports&lt;/code&gt; 모듈. 모듈에서 &quot;기본&quot;내보내기를 사용해야하는 경우 결과 객체 의 &lt;code&gt;default&lt;/code&gt; 속성에서 사용할 수 있습니다 . 위의 예에서 이는 &lt;code&gt;tool.default&lt;/code&gt; 로 사용할 수 있음을 의미합니다 . 추가 명확성을 제공하기 위해 매개 변수 디스트 럭처링을 사용하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49b9d90d524e7531884ed5070717dcfe9ed8dedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jquery&lt;/code&gt; package adds the jQuery library to the client JavaScript bundle. It has no effect on the server.</source>
          <target state="translated">&lt;code&gt;jquery&lt;/code&gt; 패키지는 클라이언트 자바 스크립트 번들에 jQuery 라이브러리를 추가합니다. 서버에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56ef08d8ffe8d750b112d8e3cda83e2c49782b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;listArgs&lt;/code&gt; helper fetches the data that we&amp;rsquo;ve subscribed to above:</source>
          <target state="translated">&lt;code&gt;listArgs&lt;/code&gt; 우리가 위에서 구독하는 데이터를 가져 오는 도우미 :</target>
        </trans-unit>
        <trans-unit id="d30242fb7d69b0d01aec1c035c65e0c64fb15cfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;meteor node&lt;/code&gt; command calls the &lt;a href=&quot;https://nodejs.org&quot;&gt;&lt;code&gt;node&lt;/code&gt;&lt;/a&gt; version bundled with Meteor itself.</source>
          <target state="translated">&lt;code&gt;meteor node&lt;/code&gt; 명령은 호출 &lt;a href=&quot;https://nodejs.org&quot;&gt; &lt;code&gt;node&lt;/code&gt; &lt;/a&gt; 유성 자체 번들 버전을.</target>
        </trans-unit>
        <trans-unit id="67aa668aa1e8b11cdf1da77e1cd0c84391e04842" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;meteor npm&lt;/code&gt; command calls the &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt; version bundled with Meteor itself.</source>
          <target state="translated">&lt;code&gt;meteor npm&lt;/code&gt; 명령은 호출 &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt; 유성 자체 번들 버전을.</target>
        </trans-unit>
        <trans-unit id="aff6c0d72c1aacb5b168bcc54dc23b3c04efe5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nosub&lt;/code&gt; message is sent to the client to indicate that the subscription has stopped.</source>
          <target state="translated">&lt;code&gt;nosub&lt;/code&gt; 의 메시지는 가입이 정지 한 것을 나타 내기 위해서 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="685b0c395254c54b684f6dba1e1b538a25426f19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onReady&lt;/code&gt; callback is called with no arguments when the server &lt;a href=&quot;#publish_ready&quot;&gt;marks the subscription as ready&lt;/a&gt;. The &lt;code&gt;onStop&lt;/code&gt; callback is called with a &lt;a href=&quot;#meteor_error&quot;&gt;&lt;code&gt;Meteor.Error&lt;/code&gt;&lt;/a&gt; if the subscription fails or is terminated by the server. If the subscription is stopped by calling &lt;code&gt;stop&lt;/code&gt; on the subscription handle or inside the publication, &lt;code&gt;onStop&lt;/code&gt; is called with no arguments.</source>
          <target state="translated">&lt;code&gt;onReady&lt;/code&gt; 콜백은 서버 인수없이 호출 &lt;a href=&quot;#publish_ready&quot;&gt;부호 가입 준비로&lt;/a&gt; . &lt;code&gt;onStop&lt;/code&gt; 콜백이 불려 &lt;a href=&quot;#meteor_error&quot;&gt; &lt;code&gt;Meteor.Error&lt;/code&gt; &lt;/a&gt; 구독이 실패하거나 서버가 종료되면. 구독 핸들 또는 게시 내부에서 &lt;code&gt;stop&lt;/code&gt; 을 호출하여 구독이 중지되면 인수없이 &lt;code&gt;onStop&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="06063c608a0d91190bd33e44295416981f321ca6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;package.js&lt;/code&gt; file below is an example of how to use the packaging API. The rest of this section will explain the specific API commands in greater detail.</source>
          <target state="translated">&lt;code&gt;package.js&lt;/code&gt; 의 아래 파일은 패키징 API를 사용하는 방법에 대한 예입니다. 이 섹션의 나머지 부분에서는 특정 API 명령에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="23ddc8e0699779292ae53e0921717129af567080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;package.js&lt;/code&gt; file is the main file in every Meteor package. This is a JavaScript file that defines the metadata, files loaded, architectures, npm packages, and Cordova packages for your Meteor package.</source>
          <target state="translated">&lt;code&gt;package.js&lt;/code&gt; 의 파일은 모든 유성 패키지의 주요 파일입니다. 이 파일은 Meteor 패키지의 메타 데이터,로드 된 파일, 아키텍처, npm 패키지 및 Cordova 패키지를 정의하는 JavaScript 파일입니다.</target>
        </trans-unit>
        <trans-unit id="248b78f21981a15968dce8d0503b944a0b658881" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; are put in the URL or the request body, depending on the type of request. In the case of request with no bodies, like GET and HEAD, the parameters will always go in the URL. For a POST or other type of request, the parameters will be encoded into the body with a standard &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; content type, unless the &lt;code&gt;content&lt;/code&gt; or &lt;code&gt;data&lt;/code&gt; option is used to specify a body, in which case the parameters will be appended to the URL instead.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 요청의 유형에 따라 URL 또는 요청 본문에 배치됩니다. GET 및 HEAD와 같이 본문이없는 요청의 경우 매개 변수는 항상 URL로 이동합니다. POST 또는 다른 유형의 요청의 경우 &lt;code&gt;content&lt;/code&gt; 또는 &lt;code&gt;data&lt;/code&gt; 옵션을 사용하여 본문을 지정 하지 않는 한 매개 변수는 표준 &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; 콘텐츠 형식으로 본문에 인코딩 됩니다. 대신 URL에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ce8bf2a2383be6737acd880628c392cd595ded" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;random&lt;/code&gt; package provides several functions for generating random numbers. It uses a cryptographically strong pseudorandom number generator when possible, but falls back to a weaker random number generator when cryptographically strong randomness is not available (on older browsers or on servers that don&amp;rsquo;t have enough entropy to seed the cryptographically strong generator).</source>
          <target state="translated">&lt;code&gt;random&lt;/code&gt; 패키지는 난수를 생성하기위한 여러 가지 기능을 제공합니다. 가능한 경우 암호화 적으로 강력한 의사 난수 생성기를 사용하지만 암호화 적으로 강력한 임의성을 사용할 수없는 경우 (이전 브라우저 나 암호화 엔트로피가 충분하지 않은 서버에서 암호화 강력한 생성기를 시드 할 수있는 경우) 약한 난수 생성기로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fb3f59f9cd1616175104ad5ee272702a6b7aa74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sink&lt;/code&gt; object may also expose additional properties depending on the environment. For example, on the server, &lt;code&gt;sink.request&lt;/code&gt; provides access to the current &lt;code&gt;request&lt;/code&gt; object, and &lt;code&gt;sink.arch&lt;/code&gt; identifies the target architecture of the pending HTTP response (e.g. &amp;ldquo;web.browser&amp;rdquo;).</source>
          <target state="translated">&lt;code&gt;sink&lt;/code&gt; 객체는 환경에 따라 추가 속성을 노출 될 수 있습니다. 예를 들어, 서버에서 &lt;code&gt;sink.request&lt;/code&gt; 는 현재 &lt;code&gt;request&lt;/code&gt; 객체에 대한 액세스를 제공 하고 &lt;code&gt;sink.arch&lt;/code&gt; 는 보류중인 HTTP 응답의 대상 아키텍처 (예 : &quot;web.browser&quot;)를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="6aca730cc311d99b56dad16da66c4fa82bcd1973" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smtp://&lt;/code&gt; form is for mail servers which support encryption via &lt;code&gt;STARTTLS&lt;/code&gt; or those that do not use encryption at all and is most common for servers on port 587 and &lt;em&gt;sometimes&lt;/em&gt; port 25. On the other hand, the &lt;code&gt;smtps://&lt;/code&gt; form (the &lt;code&gt;s&lt;/code&gt; stands for &amp;ldquo;secure&amp;rdquo;) should be used if the server only supports TLS/SSL (and does not support connection upgrade with &lt;code&gt;STARTTLS&lt;/code&gt;) and is most common for servers on port 465.</source>
          <target state="translated">&lt;code&gt;smtp://&lt;/code&gt; 형태를 통해 어떤 지원 암호화 메일 서버입니다 &lt;code&gt;STARTTLS&lt;/code&gt; 또는 전혀 암호화를 사용하여 포트 587 및에 서버에 대해 가장 일반적입니다하지 않는 사람들 &lt;em&gt;때때로&lt;/em&gt; 다른 한편으로 포트 25의 &lt;code&gt;smtps://&lt;/code&gt; (양식 &lt;code&gt;s&lt;/code&gt; 서버는 TLS / SSL을 지원 (그리고하지 지원 연결 업그레이드를 수행하는 경우) &quot;보안&quot;이 사용되어야 의미 &lt;code&gt;STARTTLS&lt;/code&gt; ) 및 포트 465 서버에 대한 가장 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="5f7c6c42397a628deabc6eaab3b3fd6c56bb09c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;startup&lt;/code&gt; callbacks are called in the same order as the calls to &lt;code&gt;Meteor.startup&lt;/code&gt; were made.</source>
          <target state="translated">&lt;code&gt;startup&lt;/code&gt; 에 대한 호출로 콜백은 동일한 순서로 호출 &lt;code&gt;Meteor.startup&lt;/code&gt; 이 만들어졌다.</target>
        </trans-unit>
        <trans-unit id="629e4c135033f354044ddb958337d95ca14c5b02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; context inside every Meteor Method has some useful information about the current connection, and the most useful is &lt;a href=&quot;http://docs.meteor.com/#/full/method_userId&quot;&gt;&lt;code&gt;this.userId&lt;/code&gt;&lt;/a&gt;. This property is managed by the DDP login system, and is guaranteed by the framework itself to be secure following widely-used best practices.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 모든 유성 방법 내부 컨텍스트는 현재 연결에 대한 유용한 정보를 가지고 있으며, 가장 유용한입니다 &lt;a href=&quot;http://docs.meteor.com/#/full/method_userId&quot;&gt; &lt;code&gt;this.userId&lt;/code&gt; &lt;/a&gt; . 이 속성은 DDP 로그인 시스템에서 관리하며 널리 사용되는 모범 사례에 따라 프레임 워크 자체에서 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="5010655ccc962a72b2bb890e25818d687ab3c8b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; context, which has information about the current DDP connection. For example, you can access the current user&amp;rsquo;s &lt;code&gt;_id&lt;/code&gt; with &lt;code&gt;this.userId&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 현재 DDP 연결에 대한 정보를 가지고 상황. 예를 들어, 현재 사용자의 액세스 할 수 있습니다 &lt;code&gt;_id&lt;/code&gt; 와 &lt;code&gt;this.userId&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="348b72e75d1bfbcc4619c7e7089246acca7f7bca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;underscore&lt;/code&gt; package defines the &lt;code&gt;_&lt;/code&gt; namespace on both the client and the server.</source>
          <target state="translated">&lt;code&gt;underscore&lt;/code&gt; 패키지는 정의 &lt;code&gt;_&lt;/code&gt; 클라이언트와 서버 모두에서 네임 스페이스를.</target>
        </trans-unit>
        <trans-unit id="108fa09909ea0db4cd0b31057151dfc73205dccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; attribute of &lt;code&gt;manifest.json&lt;/code&gt;, which reflects the version of only your JS bundle, is accessible from JS at &lt;code&gt;__meteor_runtime_config__.autoupdateVersionCordova&lt;/code&gt;.</source>
          <target state="translated">JS 번들의 버전 만 반영하는 &lt;code&gt;manifest.json&lt;/code&gt; 의 &lt;code&gt;version&lt;/code&gt; 속성은 &lt;code&gt;__meteor_runtime_config__.autoupdateVersionCordova&lt;/code&gt; JS에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd597517d0aef89433282b961f7f7b2f564b73c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;webapp&lt;/code&gt; package is what lets your Meteor app serve content to a web browser. It is included in the &lt;code&gt;meteor-base&lt;/code&gt; set of packages that is automatically added when you run &lt;code&gt;meteor create&lt;/code&gt;. You can easily build a Meteor app without it - for example if you wanted to make a command-line tool that still used the Meteor package system and DDP.</source>
          <target state="translated">&lt;code&gt;webapp&lt;/code&gt; 패키지는 유성 응용 프로그램은 웹 브라우저에 콘텐츠를 제공 무엇을 할 수 있습니다. 그것은 &lt;code&gt;meteor create&lt;/code&gt; 를 실행할 때 자동으로 추가 되는 &lt;code&gt;meteor-base&lt;/code&gt; 패키지 세트에 포함되어 있습니다 . 예를 들어 Meteor 패키지 시스템과 DDP를 계속 사용하는 명령 줄 도구를 만들려는 경우를 제외하고 Meteor 앱없이 쉽게 Meteor 앱을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff1bfcf06bc990a1acd192431fddc86a77d7b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;withTracker&lt;/code&gt; function now replaces the previous function &lt;code&gt;createContainer&lt;/code&gt;, however it remains as part of the package for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;withTracker&lt;/code&gt; 의 기능은 이제 이전 기능을 대체 &lt;code&gt;createContainer&lt;/code&gt; 를 이 이전 버전과의 호환성을 위해 패키지의 한 부분으로 남아 있지만,.</target>
        </trans-unit>
        <trans-unit id="5d18fd722b156605aee23e2d51ab48e8026fb854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each .. in}}&lt;/code&gt; block helper which repeats a block of HTML for each element in an array or cursor, or renders the contents of the &lt;code&gt;{{else}}&lt;/code&gt; block if no items exist.</source>
          <target state="translated">&lt;code&gt;{{#each .. in}}&lt;/code&gt; 배열 또는 커서의 각 요소에 대하여 HTML 블록을 반복하거나, 내용 렌더링 블록 헬퍼 &lt;code&gt;{{else}}&lt;/code&gt; 아이템이 존재하지 않는 경우 블록.</target>
        </trans-unit>
        <trans-unit id="40e6f9fd001ca29ba2c0959765d298fc1feba3fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each .. in}}&lt;/code&gt; helper is a convenient way to step over a list while retaining the outer data context.</source>
          <target state="translated">&lt;code&gt;{{#each .. in}}&lt;/code&gt; 외부 데이터 컨텍스트를 유지하면서리스트를 공정하기위한 편리한 방법이다 헬퍼.</target>
        </trans-unit>
        <trans-unit id="951988f2796603e0ca615d94cf5a8ae40d36b133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#if}}&lt;/code&gt; and &lt;code&gt;{{#unless}}&lt;/code&gt; helpers are fairly straightforward but invaluable for controlling the control flow of a template. Both operate by evaluating and checking their single argument for truthiness. In JS &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; are considered &amp;ldquo;falsy&amp;rdquo;, and all other values are &amp;ldquo;truthy&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;{{#if}}&lt;/code&gt; 과 &lt;code&gt;{{#unless}}&lt;/code&gt; 헬퍼 템플릿의 제어 흐름을 제어하기위한 매우 간단하지만 매우 중요하다. 두 가지 모두 진실성에 대한 단일 주장을 평가하고 점검함으로써 작동합니다. JS &lt;code&gt;null&lt;/code&gt; 에서는 &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 는 &quot; 거짓 &quot;으로 간주되고 다른 모든 값은 &quot;거짓&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="432be6064abd05ef0974fb6122780115d4027147" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#let}}&lt;/code&gt; helper is useful to capture the output of a helper or document subproperty within a template. Think of it just like defining a variable using JavaScript &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{{#let}}&lt;/code&gt; 도우미 템플릿 내에서 도우미 또는 문서, 하위의 출력을 포착하는 데 유용합니다. JavaScript &lt;code&gt;let&lt;/code&gt; 을 사용하여 변수를 정의하는 것처럼 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="57e19d9fa3d174ce03bb09a59e268660ed187208" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;current computation&lt;/em&gt; (&lt;a href=&quot;#tracker_currentcomputation&quot;&gt;&lt;code&gt;Tracker.currentComputation&lt;/code&gt;&lt;/a&gt;) is the computation that is currently being run or rerun (computed), and the one that gains a dependency when a reactive data source is accessed. Data sources are responsible for tracking these dependencies using &lt;a href=&quot;#tracker_dependency&quot;&gt;&lt;code&gt;Tracker.Dependency&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;em&gt;전류 계산&lt;/em&gt; ( &lt;a href=&quot;#tracker_currentcomputation&quot;&gt; &lt;code&gt;Tracker.currentComputation&lt;/code&gt; 는&lt;/a&gt; ) 현재 실행되는 연산 또는 재방송 (계산)하고 이득 의존하는 반응성 데이터 소스에 액세스하는 것입니다. 데이터 소스는 &lt;a href=&quot;#tracker_dependency&quot;&gt; &lt;code&gt;Tracker.Dependency&lt;/code&gt; &lt;/a&gt; 객체를 사용하여 이러한 종속성을 추적 합니다.</target>
        </trans-unit>
        <trans-unit id="36e9cba0731478ef9a24a5659c52fb87f430f688" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;only&lt;/em&gt; times you should be passing any user ID as an argument are the following:</source>
          <target state="translated">&lt;em&gt;유일한&lt;/em&gt; 인수로 사용자의 ID를 전달해야한다 시간은 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="ee47cb84572091905bf3cf695a48504f47d43686" translate="yes" xml:space="preserve">
          <source>The APIs of the Meteor platform are available at the &lt;a href=&quot;https://docs.meteor.com&quot;&gt;docs site&lt;/a&gt;, and you can browse community packages on &lt;a href=&quot;https://atmospherejs.com&quot;&gt;atmosphere&lt;/a&gt;.</source>
          <target state="translated">Meteor 플랫폼의 API는 &lt;a href=&quot;https://docs.meteor.com&quot;&gt;문서 사이트&lt;/a&gt; 에서 제공되며 &lt;a href=&quot;https://atmospherejs.com&quot;&gt;대기 환경에서&lt;/a&gt; 커뮤니티 패키지를 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a1e2ec9dc86b52fd744a37fd93a245876a08e0f" translate="yes" xml:space="preserve">
          <source>The Apache Cordova project maintains a set of &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/guide/support/index.html#core-plugin-apis&quot;&gt;core plugins&lt;/a&gt; that provide access to various native device features such as the camera, contacts, or access to the file system. But anyone can write a Cordova plugin to do basically anything that can be done from native code, and many third-party plugins are available. You can &lt;a href=&quot;https://cordova.apache.org/plugins/&quot;&gt;search for plugins on the Cordova website&lt;/a&gt; or directly on &lt;a href=&quot;https://www.npmjs.com/search?q=ecosystem%3Acordova&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Apache Cordova 프로젝트 는 카메라, 연락처 또는 파일 시스템 액세스와 같은 다양한 기본 장치 기능에 액세스 할 수있는 &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/guide/support/index.html#core-plugin-apis&quot;&gt;핵심 플러그인&lt;/a&gt; 세트를 유지 관리 합니다. 그러나 누구나 기본 코드에서 수행 할 수있는 모든 작업을 수행하기 위해 Cordova 플러그인을 작성할 수 있으며 많은 타사 플러그인을 사용할 수 있습니다. &lt;a href=&quot;https://cordova.apache.org/plugins/&quot;&gt;Cordova 웹 사이트&lt;/a&gt; 또는 &lt;a href=&quot;https://www.npmjs.com/search?q=ecosystem%3Acordova&quot;&gt;npm에서&lt;/a&gt; 직접 플러그인을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0d870593e89d028d2a1392c4feacb18ac93722a" translate="yes" xml:space="preserve">
          <source>The Blaze UI library does not have support for server-side rendering, so it&amp;rsquo;s not possible to render your pages on the server if you use Blaze. However, the React UI library does. This means it is possible to render HTML on the server if you use React as your rendering framework.</source>
          <target state="translated">Blaze UI 라이브러리는 서버 측 렌더링을 지원하지 않으므로 Blaze를 사용하는 경우 서버에서 페이지를 렌더링 할 수 없습니다. 그러나 React UI 라이브러리는 수행합니다. 이는 React를 렌더링 프레임 워크로 사용하는 경우 서버에서 HTML을 렌더링 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4b7125cdc8a6c1fbdb7389e8cb4b1420970f893c" translate="yes" xml:space="preserve">
          <source>The CSS file will be automatically loaded into any app that uses your package.</source>
          <target state="translated">CSS 파일은 패키지를 사용하는 모든 앱에 자동으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="60d2375b52348d88de9d73704db5b25e9a5de633" translate="yes" xml:space="preserve">
          <source>The CSS selector to match, scoped to the template contents.</source>
          <target state="translated">템플릿 내용에 맞게 CSS 선택기가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a2caadf5248ad21df8b29c644ef4ca41a7cca080" translate="yes" xml:space="preserve">
          <source>The ECMAScript 2015 standard library has grown to include new APIs and data structures, some of which can be implemented (&amp;ldquo;polyfilled&amp;rdquo;) using JavaScript that runs in all engines and browsers today. Here are three new constructors that are guaranteed to be available when the &lt;code&gt;ecmascript&lt;/code&gt; package is installed:</source>
          <target state="translated">ECMAScript 2015 표준 라이브러리는 새로운 API 및 데이터 구조를 포함하도록 성장했으며 그 중 일부는 오늘날 모든 엔진과 브라우저에서 실행되는 JavaScript를 사용하여 구현 ( &quot;폴리 필&quot;) 될 수 있습니다. 다음은 &lt;code&gt;ecmascript&lt;/code&gt; 패키지가 설치 될 때 사용 가능한 세 가지 새로운 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="5176dbd6067707ebf2e564a7a6e32ea28b3ac27a" translate="yes" xml:space="preserve">
          <source>The HTML spec allows omitting some additional end tags, such as P and LI, but Spacebars doesn&amp;rsquo;t currently support this.</source>
          <target state="translated">HTML 사양에서는 P 및 LI와 같은 일부 추가 종료 태그를 생략 할 수 있지만 스페이스 바는 현재이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd982a7651c8a24ab8959f9743bdb11cf637028a" translate="yes" xml:space="preserve">
          <source>The ID of the document that has been removed.</source>
          <target state="translated">제거 된 문서의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="71da2be50954fcfb4db9e1f5c191df2c926698c5" translate="yes" xml:space="preserve">
          <source>The ID of the user to update.</source>
          <target state="translated">업데이트 할 사용자의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7be813706e2c284379f84a2e5f76a39023c8f3ac" translate="yes" xml:space="preserve">
          <source>The IP address of the client in dotted form (such as &lt;code&gt;127.0.0.1&lt;/code&gt;).</source>
          <target state="translated">점으로 구분 된 클라이언트의 IP 주소 (예 : &lt;code&gt;127.0.0.1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a2869296ae0d1dd0e2b8e6637e01d12e05512d8f" translate="yes" xml:space="preserve">
          <source>The JSON configuration file must contain the name of the release track (&lt;code&gt;track&lt;/code&gt;), the release version (&lt;code&gt;version&lt;/code&gt;), various metadata, the packages specified by the release as mapped to versions (&lt;code&gt;packages&lt;/code&gt;), and the package &amp;amp; version of the Meteor command-line tool (&lt;code&gt;tool&lt;/code&gt;). Note that this means that forks of the meteor tool can be published as packages and people can use them by switching to a corresponding release. For more information, run &lt;code&gt;meteor help publish-release&lt;/code&gt;.</source>
          <target state="translated">JSON 구성 파일에는 릴리스 트랙 이름 ( &lt;code&gt;track&lt;/code&gt; ), 릴리스 버전 ( &lt;code&gt;version&lt;/code&gt; ), 다양한 메타 데이터, 릴리스에 지정된 버전 ( &lt;code&gt;packages&lt;/code&gt; ) 으로 지정된 패키지 및 Meteor 명령의 패키지 및 버전이 포함되어야합니다. 선 도구 ( &lt;code&gt;tool&lt;/code&gt; ). 이는 유성 도구의 포크를 패키지로 게시 할 수 있고 사람들이 해당 릴리스로 전환하여 사용할 수 있음을 의미합니다. 자세한 내용을 보려면 &lt;code&gt;meteor help publish-release&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="16fae4e58587b4f662e36443fea8a7705d76af81" translate="yes" xml:space="preserve">
          <source>The JavaScript of this component is responsible for subscribing and fetching the data that&amp;rsquo;s used by the &lt;code&gt;Lists_show&lt;/code&gt; template itself:</source>
          <target state="translated">이 컴포넌트의 JavaScript는 &lt;code&gt;Lists_show&lt;/code&gt; 템플리트 자체 에서 사용하는 데이터를 구독하고 가져 오는 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="896c78fd661960f4bb6e666fa9925e5acfde5022" translate="yes" xml:space="preserve">
          <source>The Meteor Accounts system builds on top of the &lt;code&gt;userId&lt;/code&gt; support in &lt;a href=&quot;#publish_userId&quot;&gt;&lt;code&gt;publish&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method_userId&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt;. The core packages add the concept of user documents stored in the database, and additional packages add &lt;a href=&quot;#accounts_passwords&quot;&gt;secure password authentication&lt;/a&gt;, &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;integration with third party login services&lt;/a&gt;, and a &lt;a href=&quot;../packages/accounts-ui&quot;&gt;pre-built user interface&lt;/a&gt;.</source>
          <target state="translated">Meteor Accounts 시스템은 &lt;a href=&quot;#publish_userId&quot;&gt; &lt;code&gt;publish&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method_userId&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;userId&lt;/code&gt; 지원 위에 구축됩니다 . 핵심 패키지는 데이터베이스에 저장된 사용자 문서 개념을 추가하고 추가 패키지는 &lt;a href=&quot;#accounts_passwords&quot;&gt;보안 암호 인증&lt;/a&gt; , &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;타사 로그인 서비스와의 통합&lt;/a&gt; 및 &lt;a href=&quot;../packages/accounts-ui&quot;&gt;사전 구축 된 사용자 인터페이스를 추가&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bd0182c35a86a0426613c6baf254b37b7d849428" translate="yes" xml:space="preserve">
          <source>The Meteor build system is the actual command line tool that you get when you install Meteor. You run it by typing the &lt;code&gt;meteor&lt;/code&gt; command in your terminal, possibly followed by a set of arguments. Read the &lt;a href=&quot;http://docs.meteor.com/#/full/commandline&quot;&gt;docs about the command line tool&lt;/a&gt; or type &lt;code&gt;meteor help&lt;/code&gt; in your terminal to learn about all of the commands.</source>
          <target state="translated">Meteor 빌드 시스템은 Meteor를 설치할 때 얻을 수있는 실제 명령 줄 도구입니다. 터미널에 &lt;code&gt;meteor&lt;/code&gt; 명령 을 입력하고 인수 세트를 입력하여 실행할 수 있습니다 . 모든 명령에 대해 배우려면 &lt;a href=&quot;http://docs.meteor.com/#/full/commandline&quot;&gt;명령 줄 도구에 대한 문서를&lt;/a&gt; 읽 거나 터미널에서 &lt;code&gt;meteor help&lt;/code&gt; 을 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed6998a9b60024706c64d6971252a8a138a0b20" translate="yes" xml:space="preserve">
          <source>The Meteor build tool is what compiles, runs, deploys, and publishes all of your Meteor apps and packages. It&amp;rsquo;s Meteor&amp;rsquo;s built-in solution to the problems also solved by tools like Grunt, Gulp, Webpack, Browserify, Nodemon, and many others, and uses many popular Node.js tools like Babel and UglifyJS internally to enable a seamless experience.</source>
          <target state="translated">Meteor 빌드 도구는 모든 Meteor 앱 및 패키지를 컴파일, 실행, 배포 및 게시하는 도구입니다. Grunt, Gulp, Webpack, Browserify, Nodemon 등의 도구로 해결 된 문제에 대한 Meteor의 기본 제공 솔루션이며, 내부적으로 Babel 및 UglifyJS와 같은 인기있는 Node.js 도구를 사용하여 원활한 경험을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c3942dc6449d48ea19d6d829b64b40c1f044cde" translate="yes" xml:space="preserve">
          <source>The Meteor client constructs a DDP message to send to the server. This includes the Method name, arguments, and an automatically generated Method ID that represents this particular Method invocation.</source>
          <target state="translated">Meteor 클라이언트는 DDP 메시지를 구성하여 서버로 보냅니다. 여기에는 메소드 이름, 인수 및이 특정 메소드 호출을 나타내는 자동으로 생성 된 메소드 ID가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="772414e93dcd743e1995ad040a68593ac8c97547" translate="yes" xml:space="preserve">
          <source>The Meteor core API includes an alternative to Methods for manipulating data from the client. Instead of explicitly defining Methods with specific arguments, you can instead call &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; directly from the client and specify security rules with &lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt;. In the Meteor Guide, we are taking a strong position that this feature should be avoided and Methods used instead. Read more about the problems with allow/deny in the &lt;a href=&quot;security#allow-deny&quot;&gt;Security article&lt;/a&gt;.</source>
          <target state="translated">Meteor 코어 API에는 클라이언트에서 데이터를 조작하는 방법에 대한 대안이 포함되어 있습니다. 특정 인수로 메소드를 명시 적으로 정의하는 대신 클라이언트에서 직접 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 를 호출 하고 &lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; &lt;/a&gt; 를 사용 하여 보안 규칙을 지정할 수 있습니다. Meteor Guide에서 우리는이 기능을 피하고 방법을 대신 사용해야한다는 강력한 입장을 취하고 있습니다. &lt;a href=&quot;security#allow-deny&quot;&gt;보안 기사&lt;/a&gt; 에서 허용 / 거부 문제에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="9f2a7f5fade585b5ec9cf23d72e35fb42ed6eebf" translate="yes" xml:space="preserve">
          <source>The Meteor server stores passwords using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bcrypt&quot;&gt;bcrypt&lt;/a&gt; algorithm. This helps protect against embarrassing password leaks if the server&amp;rsquo;s database is compromised.</source>
          <target state="translated">Meteor 서버는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bcrypt&quot;&gt;bcrypt&lt;/a&gt; 알고리즘을 사용하여 비밀번호를 저장합니다 . 이는 서버의 데이터베이스가 손상된 경우 난처한 암호 유출로부터 보호합니다.</target>
        </trans-unit>
        <trans-unit id="d1beed38bb75b24d60a57334517dcef2c57173c6" translate="yes" xml:space="preserve">
          <source>The Meteor server stores passwords using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bcrypt&quot;&gt;bcrypt&lt;/a&gt; algorithm. This helps protect against embarrassing password leaks if the server&amp;rsquo;s database is compromised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cfb47bd98dc99b089b399b09ea9dbbb669e91f" translate="yes" xml:space="preserve">
          <source>The Meteor user object of the user which just logged out.</source>
          <target state="translated">방금 로그 아웃 한 사용자의 Meteor 사용자 개체.</target>
        </trans-unit>
        <trans-unit id="fbc3037dc5cc9631ba635a73341cae811bc345e3" translate="yes" xml:space="preserve">
          <source>The Meteor.users collection</source>
          <target state="translated">Meteor.users 컬렉션</target>
        </trans-unit>
        <trans-unit id="8476c53edf67af47f0940d90ac62a022739b4a45" translate="yes" xml:space="preserve">
          <source>The OAuth login service packages populate &lt;code&gt;profile.name&lt;/code&gt;. We don&amp;rsquo;t recommend using this but, if you plan to, make sure to deny client-side writes to &lt;code&gt;profile&lt;/code&gt;. See the section about the &lt;a href=&quot;#dont-use-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt; field on users&lt;/a&gt;.</source>
          <target state="translated">OAuth 로그인 서비스 패키지는 &lt;code&gt;profile.name&lt;/code&gt; 을 채 웁니다 . 이 방법을 사용하지 않는 것이 좋지만, 계획 한 경우 클라이언트 쪽 쓰기를 &lt;code&gt;profile&lt;/code&gt; 에 거부하십시오 . &lt;a href=&quot;#dont-use-profile&quot;&gt;사용자&lt;/a&gt; 의 &lt;code&gt;profile&lt;/code&gt; 필드에 대한 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27a9526d01d31d63df8dc685846e968574c8a7dd" translate="yes" xml:space="preserve">
          <source>The URL of another Meteor application.</source>
          <target state="translated">다른 Meteor 애플리케이션의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="6f2102292919866718ad50a3acbcee97c59c4026" translate="yes" xml:space="preserve">
          <source>The URL to retrieve.</source>
          <target state="translated">검색 할 URL입니다.</target>
        </trans-unit>
        <trans-unit id="a64bf122abe1d10cd0e701c4cd4d818e2d9c1879" translate="yes" xml:space="preserve">
          <source>The URL to which the request should be sent.</source>
          <target state="translated">요청을 보낼 URL입니다.</target>
        </trans-unit>
        <trans-unit id="56d822254ab772c06ebd2fd3c858ebf94a0e9989" translate="yes" xml:space="preserve">
          <source>The View corresponding to the current template helper, event handler, callback, or autorun. If there isn't one, &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">현재 템플릿 헬퍼, 이벤트 핸들러, 콜백 또는 자동 실행에 해당하는보기입니다. 하나가없는 경우 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26c9c1b1b044e6756fecbd38c1acab1d71c26389" translate="yes" xml:space="preserve">
          <source>The Windows installer supports Windows 7, Windows 8.1, Windows Server</source>
          <target state="translated">Windows 설치 프로그램은 Windows 7, Windows 8.1, Windows Server를 지원합니다</target>
        </trans-unit>
        <trans-unit id="c64291755dfda03d5c11847e2b97871a861bda67" translate="yes" xml:space="preserve">
          <source>The XML you want to include</source>
          <target state="translated">포함하려는 XML</target>
        </trans-unit>
        <trans-unit id="79575e6b77ee45e1605aec94bfac3aef87c607d8" translate="yes" xml:space="preserve">
          <source>The above Method is great because you can have the flexibility of having some optional fields and only passing the ones you want to change. In particular, what makes it possible for this Method is that the security considerations of setting one&amp;rsquo;s full name and date of birth are the same - we don&amp;rsquo;t have to do different security checks for different fields being set. Note that it&amp;rsquo;s very important that the &lt;code&gt;$set&lt;/code&gt; query on MongoDB is generated on the server - we should never take MongoDB operators as-is from the client, since they are hard to validate and could result in unexpected side effects.</source>
          <target state="translated">위의 방법은 일부 선택적 필드가 있고 변경하려는 필드 만 전달할 수있는 유연성을 가질 수 있기 때문에 좋습니다. 특히,이 방법을 가능하게하는 것은 이름과 생년월일을 설정하는 보안 고려 사항이 동일하다는 것입니다. 설정되는 필드마다 다른 보안 검사를 수행 할 필요가 없습니다. MongoDB 의 &lt;code&gt;$set&lt;/code&gt; 쿼리가 서버에서 생성되는 것이 매우 중요합니다. MongoDB 연산자를 클라이언트에서 그대로 가져 와서는 안됩니다. 유효성 검사가 어렵고 예기치 않은 부작용이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cb437ccdc6b45a78a5085edffe767a9c98bac6da" translate="yes" xml:space="preserve">
          <source>The above approach will only work for static redirects. However, sometimes you need to load some data to figure out where to redirect to. In this case you&amp;rsquo;ll need to render part of the component hierarchy to subscribe to the data you need. For example, in the Todos example app, we want to make the root (&lt;code&gt;/&lt;/code&gt;) route redirect to the first known list. To achieve this, we need to render a special &lt;code&gt;App_rootRedirector&lt;/code&gt; route:</source>
          <target state="translated">위의 접근 방식은 정적 리디렉션에만 작동합니다. 그러나 때로는 리디렉션 할 위치를 파악하기 위해 일부 데이터를로드해야합니다. 이 경우 필요한 데이터를 구독하기 위해 구성 요소 계층의 일부를 렌더링해야합니다. 예를 들어, Todos 예제 앱에서 루트 ( &lt;code&gt;/&lt;/code&gt; ) 경로를 알려진 첫 번째 목록으로 리디렉션하려고합니다. 이를 위해 특별한 &lt;code&gt;App_rootRedirector&lt;/code&gt; 경로 를 렌더링해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bfad329861bd98d88106bb84cc8f2f7f65837040" translate="yes" xml:space="preserve">
          <source>The above code snippet is equivalent to the code below, which specifies all of the version numbers individually:</source>
          <target state="translated">위의 코드 스 니펫은 아래의 코드와 동일하며 모든 버전 번호를 개별적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="466d4f6004ff5de137195f0531fa0eda84ec3ecf" translate="yes" xml:space="preserve">
          <source>The above pattern will match certain URLs. You may notice that one segment of the URL is prefixed by &lt;code&gt;:&lt;/code&gt; - this means that it is a &lt;em&gt;url parameter&lt;/em&gt;, and will match any string that is present in that segment of the path. Flow Router will make that part of the URL available on the &lt;code&gt;params&lt;/code&gt; property of the current route.</source>
          <target state="translated">위 패턴은 특정 URL과 일치합니다. 당신은 URL의 한 세그먼트가 접두어 것을 알 수 있습니다 &lt;code&gt;:&lt;/code&gt; - 그것은 것을이 수단 &lt;em&gt;url 매개 변수&lt;/em&gt; 및 경로의 세그먼트에 존재하는 모든 문자열과 일치합니다. Flow Router는 URL의 해당 부분을 현재 경로 의 &lt;code&gt;params&lt;/code&gt; 속성에서 사용할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="6dc89bafb35f98d9c1b284e5384f0fe9a6c6947e" translate="yes" xml:space="preserve">
          <source>The actual files for a given version of an Atmosphere package are stored in your local &lt;code&gt;~/.meteor/packages&lt;/code&gt; directory.</source>
          <target state="translated">지정된 버전의 Atmosphere 패키지에 대한 실제 파일은 로컬 &lt;code&gt;~/.meteor/packages&lt;/code&gt; 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="99efcfc477dfd202bf0863401bee84cc1b5a57ca" translate="yes" xml:space="preserve">
          <source>The advantage of a &lt;code&gt;ReactiveDict&lt;/code&gt; is you can access each property individually (&lt;code&gt;WindowSize.get('width')&lt;/code&gt;), and the dict will diff the field and track changes on it individually (so your template will re-render less often for instance).</source>
          <target state="translated">&lt;code&gt;ReactiveDict&lt;/code&gt; 의 장점은 각 속성에 개별적으로 액세스 할 수 있다는 것 ( &lt;code&gt;WindowSize.get('width')&lt;/code&gt; )이며, dict은 필드를 비교하여 개별적으로 변경 사항을 추적하므로 템플릿이 덜 자주 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="735022e06f9cbcc8bc7022957bf5278567f9761f" translate="yes" xml:space="preserve">
          <source>The advantage of a bulk operation is that it only requires a single round trip to MongoDB for the write, which usually means it is a &lt;em&gt;lot&lt;/em&gt; faster. The downside is that if your migration is complex (which it usually is if you can&amp;rsquo;t just do an &lt;code&gt;.update(.., .., {multi: true})&lt;/code&gt;), it can take a significant amount of time to prepare the bulk update.</source>
          <target state="translated">대량 작업의 장점은 쓰기를 위해 MongoDB로 한 번만 왕복하면된다는 것입니다. 이는 일반적으로 &lt;em&gt;훨씬&lt;/em&gt; 빠릅니다. 단점은 마이그레이션이 복잡한 경우 (일반적으로 &lt;code&gt;.update(.., .., {multi: true})&lt;/code&gt; 할 수없는 경우 ) 준비하는 데 상당한 시간이 걸릴 수 있다는 것입니다. 대량 업데이트.</target>
        </trans-unit>
        <trans-unit id="b41fa29cf2394497f8ecf0c8f8d7b3d55f132222" translate="yes" xml:space="preserve">
          <source>The advantage of running our acceptance test suite pointed at an app that runs in full app test mode is that all of the &lt;a href=&quot;#creating-integration-test-data&quot;&gt;data generating methods&lt;/a&gt; that we&amp;rsquo;ve created remain available. Otherwise the &lt;code&gt;acceptance-test-driver&lt;/code&gt; does nothing.</source>
          <target state="translated">전체 앱 테스트 모드에서 실행되는 앱을 대상으로 승인 테스트 스위트를 실행 하면 우리가 만든 모든 &lt;a href=&quot;#creating-integration-test-data&quot;&gt;데이터 생성 방법&lt;/a&gt; 을 계속 사용할 수 있다는 장점 이 있습니다. 그렇지 않으면 &lt;code&gt;acceptance-test-driver&lt;/code&gt; 는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f75ceab42894aed4b40dab12aeb1654d82b99873" translate="yes" xml:space="preserve">
          <source>The amount of foresight you bake into your schema design will depend on your app&amp;rsquo;s individual constraints, and will need to be a judgement call on your part.</source>
          <target state="translated">스키마 디자인에 대한 예측의 정도는 앱의 개별 제약 조건에 따라 다르며 사용자가 판단해야합니다.</target>
        </trans-unit>
        <trans-unit id="917a6e6c95af21315a342385f340790e5dbe696b" translate="yes" xml:space="preserve">
          <source>The analytics package hooks into Flow Router (see the &lt;a href=&quot;routing&quot;&gt;routing article&lt;/a&gt; for more) and records all of the page events for you.</source>
          <target state="translated">분석 패키지는 Flow Router에 연결하고 (자세한 내용은 &lt;a href=&quot;routing&quot;&gt;라우팅 기사&lt;/a&gt; 참조) 모든 페이지 이벤트를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9ead835d6621c4694bc551de3b9a3fe58e8906c8" translate="yes" xml:space="preserve">
          <source>The application cache allows the application to be loaded even when the browser doesn&amp;rsquo;t have an Internet connection, and so enables using the app offline.</source>
          <target state="translated">응용 프로그램 캐시를 사용하면 브라우저가 인터넷에 연결되어 있지 않아도 응용 프로그램을로드 할 수 있으므로 앱을 오프라인으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a1a1290d8eae6c9de3ee266f9ff663701f1338" translate="yes" xml:space="preserve">
          <source>The aptly named &lt;code&gt;blaze-html-templates&lt;/code&gt; package that comes with every new Meteor app by default compiles your &lt;code&gt;.html&lt;/code&gt; files written using &lt;a href=&quot;http://blazejs.org/api/spacebars.html&quot;&gt;Spacebars&lt;/a&gt; into Blaze-compatible JavaScript code. You can also add &lt;code&gt;blaze-html-templates&lt;/code&gt; to any of your packages to compile template files located in the package.</source>
          <target state="translated">기본적으로 모든 새로운 Meteor 앱과 함께 제공 되는 적절한 이름의 &lt;code&gt;blaze-html-templates&lt;/code&gt; 패키지는 &lt;a href=&quot;http://blazejs.org/api/spacebars.html&quot;&gt;스페이스 바를&lt;/a&gt; 사용하여 작성된 &lt;code&gt;.html&lt;/code&gt; 파일 을 Blaze 호환 JavaScript 코드로 컴파일합니다 . 패키지에 &lt;code&gt;blaze-html-templates&lt;/code&gt; 를 추가 하여 패키지에있는 템플릿 파일을 컴파일 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="378952f0189a81fedc0741d76c3e99d79a1e9e13" translate="yes" xml:space="preserve">
          <source>The argument is typically a Meteor cursor (the result of &lt;code&gt;collection.find()&lt;/code&gt;, for example), but it may also be a plain JavaScript array, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">인수는 일반적으로 Meteor 커서 ( 예 : &lt;code&gt;collection.find()&lt;/code&gt; 의 결과 )이지만 일반 JavaScript 배열, &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d77aee2e87699b6eaa98b53d0d180a23f17a1dd1" translate="yes" xml:space="preserve">
          <source>The arguments to the publication, which can be passed in when calling &lt;code&gt;Meteor.subscribe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Meteor.subscribe&lt;/code&gt; 를 호출 할 때 전달 될 수있는 발행에 대한 인수 .</target>
        </trans-unit>
        <trans-unit id="9e23e8e89c294bdac4801e34e624b2364ad13030" translate="yes" xml:space="preserve">
          <source>The available callbacks are:</source>
          <target state="translated">사용 가능한 콜백은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0333a3e94b3b1df990028a4ef4fe4675fc5be85" translate="yes" xml:space="preserve">
          <source>The basic Accounts system is in the &lt;code&gt;accounts-base&lt;/code&gt; package, but applications typically include this automatically by adding one of the login provider packages: &lt;code&gt;accounts-password&lt;/code&gt;, &lt;code&gt;accounts-facebook&lt;/code&gt;, &lt;code&gt;accounts-github&lt;/code&gt;, &lt;code&gt;accounts-google&lt;/code&gt;, &lt;code&gt;accounts-meetup&lt;/code&gt;, &lt;code&gt;accounts-twitter&lt;/code&gt;, or &lt;code&gt;accounts-weibo&lt;/code&gt;.</source>
          <target state="translated">기본 계정 시스템은 &lt;code&gt;accounts-base&lt;/code&gt; 패키지에 있지만 응용 프로그램은 일반적으로 &lt;code&gt;accounts-password&lt;/code&gt; , &lt;code&gt;accounts-facebook&lt;/code&gt; , &lt;code&gt;accounts-github&lt;/code&gt; , &lt;code&gt;accounts-google&lt;/code&gt; , &lt;code&gt;accounts-meetup&lt;/code&gt; , &lt;code&gt;accounts-twitter&lt;/code&gt; 등 의 로그인 공급자 패키지 중 하나를 추가하여이를 자동으로 포함합니다. 또는 &lt;code&gt;accounts-weibo&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db89f434d35c86142d8a42b1b42997d85c19a412" translate="yes" xml:space="preserve">
          <source>The basic purpose of a router is to match certain URLs and perform actions as a result. This all happens on the client side, in the app user&amp;rsquo;s browser or mobile app container. Let&amp;rsquo;s take an example from the Todos example app:</source>
          <target state="translated">라우터의 기본 목적은 특정 URL을 일치시키고 결과적으로 조치를 수행하는 것입니다. 이 모든 것은 클라이언트 측, 앱 사용자의 브라우저 또는 모바일 앱 컨테이너에서 발생합니다. Todos 예제 앱에서 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="1d73760033c1a6738267e7589ae09097a86ac374" translate="yes" xml:space="preserve">
          <source>The basic way to use a CDN is to upload your files to the CDN and change your URLs to point at the CDN (for instance if your Meteor app is at &lt;code&gt;http://myapp.com&lt;/code&gt;, changing your image URL from &lt;code&gt;&amp;lt;img src=&quot;http://myapp.com/cats.gif&quot;&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;img src=&quot;http://mycdn.com/cats.gif&quot;&amp;gt;&lt;/code&gt;). However, this would be hard to do with Meteor, since the largest file &amp;ndash; your Javascript bundle &amp;ndash; changes every time you edit your app.</source>
          <target state="translated">CDN을 사용하는 기본 방법은 파일을 CDN에 업로드하고 URL이 CDN을 가리 키도록 URL을 변경하는 것입니다 (예 : Meteor 앱이 &lt;code&gt;http://myapp.com&lt;/code&gt; 인 경우 이미지 URL을 &lt;code&gt;&amp;lt;img src=&quot;http://myapp.com/cats.gif&quot;&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;img src=&quot;http://mycdn.com/cats.gif&quot;&amp;gt;&lt;/code&gt; ) 그러나 앱을 편집 할 때마다 가장 큰 파일 (자바 스크립트 번들)이 변경되므로 Meteor와는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="29f995b6b0f1a832c48648ecfe840224eda5a62e" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;remove&lt;/code&gt; differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser&amp;rsquo;s JavaScript console.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 동작은 신뢰할 수있는 코드에 의해 호출되는지 또는 신뢰할 수없는 코드에 의해 호출되는지에 따라 다릅니다. 신뢰할 수있는 코드에는 서버 코드 및 메소드 코드가 포함됩니다. 신뢰할 수없는 코드에는 이벤트 처리기 및 브라우저의 JavaScript 콘솔과 같은 클라이언트 측 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b540c601572a90a3ef7beb0c14f57bd732901e8e" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;update&lt;/code&gt; differs depending on whether it is called by trusted or untrusted code. Trusted code includes server code and method code. Untrusted code includes client-side code such as event handlers and a browser&amp;rsquo;s JavaScript console.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 동작은 신뢰할 수있는 코드에 의해 호출되는지 또는 신뢰할 수없는 코드에 의해 호출되는지에 따라 다릅니다. 신뢰할 수있는 코드에는 서버 코드 및 메소드 코드가 포함됩니다. 신뢰할 수없는 코드에는 이벤트 처리기 및 브라우저의 JavaScript 콘솔과 같은 클라이언트 측 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6cf6d1d0942b648d69e4f2334c33febbb5409993" translate="yes" xml:space="preserve">
          <source>The behavior of a template tag is affected by where it is located in the HTML, and not all tags are allowed at all locations.</source>
          <target state="translated">템플릿 태그의 동작은 HTML에서 위치하는 위치에 영향을받으며 모든 태그가 모든 위치에서 허용되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fe2a22351167c169483478713aad4321355fb500" translate="yes" xml:space="preserve">
          <source>The best Sass build plugin for Meteor is &lt;a href=&quot;https://atmospherejs.com/fourseven/scss&quot;&gt;&lt;code&gt;fourseven:scss&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Meteor를위한 최고의 Sass 빌드 플러그인은 &lt;a href=&quot;https://atmospherejs.com/fourseven/scss&quot;&gt; &lt;code&gt;fourseven:scss&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d21b94fc2f7728c9c4647013748274a56eeb6353" translate="yes" xml:space="preserve">
          <source>The best way to make your app secure is to understand all of the possible inputs that could come from an untrusted source, and make sure that they are all handled correctly. The easiest way to understand what inputs can come from the client is to restrict them to as small of a space as possible. This means your Methods should all be specific actions, and shouldn&amp;rsquo;t take a multitude of options that change the behavior in significant ways. The end goal is that you can easily look at each Method in your app and validate or test that it is secure. Here&amp;rsquo;s a secure example Method from the Todos example app:</source>
          <target state="translated">앱을 안전하게 만드는 가장 좋은 방법은 신뢰할 수없는 출처에서 올 수있는 모든 입력을 이해하고 올바르게 처리되도록하는 것입니다. 어떤 입력이 클라이언트로부터 올 수 있는지 이해하는 가장 쉬운 방법은 입력을 가능한 한 작은 공간으로 제한하는 것입니다. 즉, 분석법은 모두 특정 행동이어야하며 행동을 중요한 방식으로 변화시키는 다양한 옵션을 취해서는 안됩니다. 최종 목표는 앱에서 각 방법을 쉽게보고 안전한지 확인하거나 테스트 할 수 있다는 것입니다. 다음은 Todos 예제 앱의 안전한 예제 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="315bee23c0ee544bbb296894b6d09e4a6f9b08ad" translate="yes" xml:space="preserve">
          <source>The best way to make your build plugin fast is to use caching anywhere you can - the best way to save time is to do less work! Check out the &lt;a href=&quot;https://docs.meteor.com/api/packagejs.html#build-plugin-caching&quot;&gt;documentation about CachingCompiler&lt;/a&gt; to learn more. It&amp;rsquo;s used in all of the above examples, so you can see how to use it by looking at them.</source>
          <target state="translated">빌드 플러그인을 빠르게 만드는 가장 좋은 방법은 어디서나 캐싱을 사용하는 것입니다. 시간을 절약하는 가장 좋은 방법은 작업을 줄이는 것입니다! 자세한 내용 &lt;a href=&quot;https://docs.meteor.com/api/packagejs.html#build-plugin-caching&quot;&gt;은 CachingCompiler&lt;/a&gt; 에 대한 설명서를 확인하십시오 . 위의 모든 예제에서 사용되므로 사용 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb953f8026acbebd8fe0df9cc112316bc284e8a" translate="yes" xml:space="preserve">
          <source>The best way to store your custom data onto the &lt;code&gt;Meteor.users&lt;/code&gt; collection is to add a new uniquely-named top-level field on the user document. For example, if you wanted to add a mailing address to a user, you could do it like this:</source>
          <target state="translated">사용자 정의 데이터를 &lt;code&gt;Meteor.users&lt;/code&gt; 컬렉션 에 저장하는 가장 좋은 방법 은 사용자 문서에 고유 한 새로운 최상위 필드를 추가하는 것입니다. 예를 들어, 메일 주소를 사용자에게 추가하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="4bb7afad9811d34a0799f9eec42c9d511a448357" translate="yes" xml:space="preserve">
          <source>The body of the HTTP response as a string.</source>
          <target state="translated">HTTP 응답의 본문은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="520d93bbeeff05e26e6e839c0804d7f12bb8dd44" translate="yes" xml:space="preserve">
          <source>The browser on iOS is Safari, which is based on the open source WebKit project, but tends to be somewhat slow in enabling new features. Because they use the same underlying framework, the features available to a web view match the features supported by Safari on the iOS release you&amp;rsquo;re running on.</source>
          <target state="translated">iOS의 브라우저는 Safari이며 공개 소스 WebKit 프로젝트를 기반으로하지만 새로운 기능을 사용하는 데 다소 느려집니다. 동일한 기본 프레임 워크를 사용하기 때문에 웹보기에 사용할 수있는 기능은 실행중인 iOS 릴리스의 Safari에서 지원하는 기능과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d8708bfa23fa52e22c67b7fb716a9c92a7fff5da" translate="yes" xml:space="preserve">
          <source>The callback function</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="c2dcaabbaa2752b243256533c88d4a7087ea2035" translate="yes" xml:space="preserve">
          <source>The callback is called with a single argument, the server-side &lt;code&gt;connection&lt;/code&gt; representing the connection from the client. This object contains the following fields:</source>
          <target state="translated">콜백은 단일 인수 인 클라이언트 측 &lt;code&gt;connection&lt;/code&gt; 나타내는 서버 측 연결 로 호출 됩니다. 이 개체는 다음 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c8b1c1450b6dfa3f5d9ee8ad7aade6a7f06f3c2f" translate="yes" xml:space="preserve">
          <source>The callback receives a &lt;code&gt;sink&lt;/code&gt; object, which is an instance of either &lt;code&gt;ClientSink&lt;/code&gt; or &lt;code&gt;ServerSink&lt;/code&gt; depending on the environment. Both types of &lt;code&gt;sink&lt;/code&gt; have the same methods, though the server version accepts only HTML strings as content, whereas the client version also accepts DOM nodes.</source>
          <target state="translated">콜백은 &lt;code&gt;sink&lt;/code&gt; 객체를 수신합니다. 싱크 객체 는 환경에 따라 &lt;code&gt;ClientSink&lt;/code&gt; 또는 &lt;code&gt;ServerSink&lt;/code&gt; 의 인스턴스입니다 . 서버 버전은 HTML 문자열 만 내용으로 허용하지만 클라이언트 버전은 DOM 노드를 허용하지만 두 유형의 &lt;code&gt;sink&lt;/code&gt; 는 동일한 방법을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8b9f6f162907e02a0ea9ed02c3076f4dfd5e9784" translate="yes" xml:space="preserve">
          <source>The callback to be called after the login has failed.</source>
          <target state="translated">로그인이 실패한 후 호출 할 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="4e1136b97efaeea6628f872cffb0094c5fa313ee" translate="yes" xml:space="preserve">
          <source>The callback to be called when login is successful.</source>
          <target state="translated">로그인이 성공했을 때 호출되는 콜백</target>
        </trans-unit>
        <trans-unit id="e8601dc28796ec40c6dd1873bf26178e037f01a8" translate="yes" xml:space="preserve">
          <source>The callback to be called when logout is successful.</source>
          <target state="translated">로그 아웃에 성공한 콜백</target>
        </trans-unit>
        <trans-unit id="2d537507e9f0e48a9d318103c9b844df71ab1a7f" translate="yes" xml:space="preserve">
          <source>The changed document's ID.</source>
          <target state="translated">변경된 문서의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="cdda8d0b2e57b8d445498c884280ef4906776319" translate="yes" xml:space="preserve">
          <source>The client enters a special mode where it tracks all changes made to client-side collections, so that they can be rolled back later. When this step is complete, the user of your app sees their UI update instantly with the new content of the client-side database, but the server hasn&amp;rsquo;t received any data yet.</source>
          <target state="translated">클라이언트는 클라이언트 측 콜렉션에 대한 모든 변경 사항을 추적하는 특수 모드로 들어가서 나중에 롤백 할 수 있습니다. 이 단계가 완료되면 앱 사용자는 클라이언트 측 데이터베이스의 새 콘텐츠로 UI 업데이트를 즉시 볼 수 있지만 서버가 아직 데이터를받지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f82adb248be9dcec9419a93f949feec9a3ecef57" translate="yes" xml:space="preserve">
          <source>The client sends a &lt;code&gt;sub&lt;/code&gt; message with the name of the subscription over DDP.</source>
          <target state="translated">클라이언트는 DDP를 통해 구독 이름이 포함 된 &lt;code&gt;sub&lt;/code&gt; 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="4d7269b8f4de7c21284ee91d7b146c64cca37422" translate="yes" xml:space="preserve">
          <source>The client sends the &lt;code&gt;unsub&lt;/code&gt; DDP message.</source>
          <target state="translated">클라이언트는 &lt;code&gt;unsub&lt;/code&gt; DDP 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="f4eee4395cb424192df043a4634d70610e3360df" translate="yes" xml:space="preserve">
          <source>The client will see a document if the document is currently in the published record set of any of its subscriptions. If multiple publications publish a document with the same &lt;code&gt;_id&lt;/code&gt; for the same collection the documents are merged for the client. If the values of any of the top level fields conflict, the resulting value will be one of the published values, chosen arbitrarily.</source>
          <target state="translated">문서가 현재 구독의 공개 레코드 세트에있는 경우 클라이언트는 문서를 보게됩니다. 여러 발행물 이 동일한 컬렉션에 대해 동일한 &lt;code&gt;_id&lt;/code&gt; 를 가진 문서를 게시 하면 클라이언트에 대해 문서가 병합됩니다. 최상위 수준 필드의 값이 충돌하면 결과 값은 임의로 선택된 게시 된 값 중 하나가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3edc6b86aaba4a10db03ed3bf65c1feeea7e3ce" translate="yes" xml:space="preserve">
          <source>The code above is just code that you could run on the server inside a Meteor Method to set someone&amp;rsquo;s mailing address. Sometimes, you want to set a field when the user first creates their account, for example to initialize a default value or compute something from their social data. You can do this using &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_oncreateuser&quot;&gt;&lt;code&gt;Accounts.onCreateUser&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위의 코드는 Meteor Method 내의 서버에서 누군가의 메일 주소를 설정하기 위해 실행할 수있는 코드입니다. 때로는 사용자가 처음으로 계정을 만들 때 필드를 설정하려고합니다 (예 : 기본값을 초기화하거나 소셜 데이터에서 무언가를 계산). &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_oncreateuser&quot;&gt; &lt;code&gt;Accounts.onCreateUser&lt;/code&gt; 를&lt;/a&gt; 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2089f8d3a5cab974d960c79146921cccd7ae5c3" translate="yes" xml:space="preserve">
          <source>The code snippet below is an example &lt;code&gt;mobile-config.js&lt;/code&gt; file. The rest of this section will explain the specific API commands in greater detail.</source>
          <target state="translated">아래 코드 스 니펫은 예제 &lt;code&gt;mobile-config.js&lt;/code&gt; 파일입니다. 이 섹션의 나머지 부분에서는 특정 API 명령에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1eb7ae9f8a9bc2920efe4766f0b593b1505daa82" translate="yes" xml:space="preserve">
          <source>The compatibility version can be found in the &lt;code&gt;cordovaCompatibilityVersions&lt;/code&gt; attribute of the JSON file served at &lt;code&gt;ROOT_URL/__cordova/manifest.json&lt;/code&gt; during &lt;code&gt;meteor run [ios/android]&lt;/code&gt;.</source>
          <target state="translated">호환성 버전은 &lt;code&gt;meteor run [ios/android]&lt;/code&gt; 동안 &lt;code&gt;ROOT_URL/__cordova/manifest.json&lt;/code&gt; 에 제공된 JSON 파일 의 &lt;code&gt;cordovaCompatibilityVersions&lt;/code&gt; 속성 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a46b7120798be4c7bb1b75ec9bb4782f83b13e93" translate="yes" xml:space="preserve">
          <source>The compiler class must implement the &lt;code&gt;processFilesForTarget&lt;/code&gt; method that is given the source files for a target (server or client part of the package/app).</source>
          <target state="translated">컴파일러 클래스는 대상 (패키지 / 앱의 서버 또는 클라이언트 부분)에 대한 소스 파일이 제공된 &lt;code&gt;processFilesForTarget&lt;/code&gt; 메소드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c330f9e1e6edcaea05a56dd5ac7fc6db6980110" translate="yes" xml:space="preserve">
          <source>The computation re-runs, with &lt;code&gt;.subscribe()&lt;/code&gt; being re-called either with the same or different arguments.</source>
          <target state="translated">&lt;code&gt;.subscribe()&lt;/code&gt; 가 같거나 다른 인수로 다시 호출되면서 계산이 다시 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="99af7eab5138d62d319c8d32d956df1c850801eb" translate="yes" xml:space="preserve">
          <source>The connection on which to make the subscription.</source>
          <target state="translated">구독 할 연결입니다.</target>
        </trans-unit>
        <trans-unit id="740a87853b05ceafa44f1bc4728a3d9ee2d2be80" translate="yes" xml:space="preserve">
          <source>The constraint solver is necessary because Meteor&amp;rsquo;s package system is &lt;strong&gt;single-loading&lt;/strong&gt; - that is, you can never have two different versions of the same package loaded side-by-side in the same app. This is particularly useful for packages that include a lot of client-side code, or packages that expect to be singletons.</source>
          <target state="translated">Meteor의 패키지 시스템은 &lt;strong&gt;단일 로딩&lt;/strong&gt; 이기 때문에 제약 조건 솔버가 필요 합니다. 즉, 동일한 앱에서 동일한 패키지의 서로 다른 두 가지 버전을 나란히로드 할 수 없습니다. 이것은 많은 클라이언트 측 코드가 포함 된 패키지 또는 싱글 톤이 필요한 패키지에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cc108241281fb051b81b727df9560c00f149908c" translate="yes" xml:space="preserve">
          <source>The container component created by &lt;code&gt;withTracker&lt;/code&gt; will reactively re-render the wrapped component in response to any changes to &lt;a href=&quot;https://atmospherejs.com/meteor/tracker&quot;&gt;reactive data sources&lt;/a&gt; accessed from inside the function provided to it.</source>
          <target state="translated">&lt;code&gt;withTracker&lt;/code&gt; 로 생성 된 컨테이너 구성 요소는 제공된 기능 내부에서 액세스 하는 &lt;a href=&quot;https://atmospherejs.com/meteor/tracker&quot;&gt;반응 데이터 소스&lt;/a&gt; 에 대한 변경 사항에 따라 래핑 된 구성 요소를 반응 적으로 다시 렌더링 합니다.</target>
        </trans-unit>
        <trans-unit id="6e0e7cbaa70b9d07d863354905feeffad0bc332f" translate="yes" xml:space="preserve">
          <source>The contents of a document were previously &lt;code&gt;oldDocument&lt;/code&gt; and are now &lt;code&gt;newDocument&lt;/code&gt;. The position of the changed document is &lt;code&gt;atIndex&lt;/code&gt;.</source>
          <target state="translated">문서의 내용은 이전에 &lt;code&gt;oldDocument&lt;/code&gt; 였으며 이제는 &lt;code&gt;newDocument&lt;/code&gt; 입니다. 변경된 문서의 위치는 &lt;code&gt;atIndex&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2625b821f53748eb1164c8ce720f3d6dd2c500b0" translate="yes" xml:space="preserve">
          <source>The contents of other application specific client data stores.</source>
          <target state="translated">다른 애플리케이션 특정 클라이언트 데이터 저장소의 컨텐츠</target>
        </trans-unit>
        <trans-unit id="ee514a1a330652bd01870bca4f0ea104e8b15fb4" translate="yes" xml:space="preserve">
          <source>The correct place to find details about using Angular with Meteor</source>
          <target state="translated">Meteor와 함께 Angular를 사용하는 방법에 대한 자세한 정보를 찾을 수있는 올바른 장소</target>
        </trans-unit>
        <trans-unit id="f718d72ed150836467e7680a94abb5d448ed0e72" translate="yes" xml:space="preserve">
          <source>The correct property name to use for the API identifier (i.e. &lt;code&gt;clientId&lt;/code&gt; in the above example) depends on the the login service being used, so be sure to use the correct one:</source>
          <target state="translated">API 식별자 ( 위의 예에서 &lt;code&gt;clientId&lt;/code&gt; ) 에 사용할 올바른 속성 이름은 사용 중인 로그인 서비스에 따라 다르므로 올바른 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="038413d4a88fc127061a29ec58fdae244cf1f95b" translate="yes" xml:space="preserve">
          <source>The current Android emulator tends to be rather slow and can be unstable, so our recommendation is to run your app on a physical device instead.</source>
          <target state="translated">현재 Android 에뮬레이터는 속도가 느리고 불안정 할 수 있으므로 실제 기기에서 앱을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3e07947643b580155cf6f80848ebd8e192d5a105" translate="yes" xml:space="preserve">
          <source>The current Android emulator tends to be rather slow and can be unstable. Our recommendation is to run on a physical device or to use an alternative emulator like &lt;a href=&quot;https://www.genymotion.com&quot;&gt;Genymotion&lt;/a&gt;.</source>
          <target state="translated">현재 Android 에뮬레이터는 속도가 느리고 불안정 할 수 있습니다. 물리적 장치에서 실행하거나 &lt;a href=&quot;https://www.genymotion.com&quot;&gt;Genymotion&lt;/a&gt; 과 같은 대체 에뮬레이터를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2131933246f6214698b657819a789a6448ec567b" translate="yes" xml:space="preserve">
          <source>The current best practice for deploying web production applications is to concatenate and minify all of your app assets. This lets you add all of the comments and whitespace you want to your source code, and split it into as many files as is necessary without worrying about app performance.</source>
          <target state="translated">웹 프로덕션 응용 프로그램 배포에 대한 현재 모범 사례는 모든 앱 자산을 연결하고 최소화하는 것입니다. 이를 통해 원하는 모든 주석과 공백을 소스 코드에 추가하고 앱 성능에 대한 걱정없이 필요한만큼 많은 파일로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21cc63df53564e2881a4fcb1f79cabb884731cbc" translate="yes" xml:space="preserve">
          <source>The current computation, or &lt;code&gt;null&lt;/code&gt; if there isn't one. The current computation is the &lt;a href=&quot;#tracker_computation&quot;&gt;&lt;code&gt;Tracker.Computation&lt;/code&gt;&lt;/a&gt; object created by the innermost active call to &lt;code&gt;Tracker.autorun&lt;/code&gt;, and it's the computation that gains dependencies when reactive data sources are accessed.</source>
          <target state="translated">현재 계산이거나 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다. 현재 연산은이다 &lt;a href=&quot;#tracker_computation&quot;&gt; &lt;code&gt;Tracker.Computation&lt;/code&gt; 의&lt;/a&gt; 최내 액티브 호출이 생성 된 객체 &lt;code&gt;Tracker.autorun&lt;/code&gt; , 그것은 이득 의존성 반응성 데이터 소스를 액세스하는 연산이다.</target>
        </trans-unit>
        <trans-unit id="7993fea7c04218147a82f11b44d87d091661eb83" translate="yes" xml:space="preserve">
          <source>The current interface of &lt;code&gt;{Client,Server}Sink&lt;/code&gt; objects is as follows:</source>
          <target state="translated">&lt;code&gt;{Client,Server}Sink&lt;/code&gt; 오브젝트 의 현재 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="159bf321dd10d2506790f13dc152068cf32723e4" translate="yes" xml:space="preserve">
          <source>The current route</source>
          <target state="translated">현재 경로</target>
        </trans-unit>
        <trans-unit id="b8daad2b57bb95ce4e96d0430123ddaf6601bace" translate="yes" xml:space="preserve">
          <source>The current user status (&lt;code&gt;Meteor.user()&lt;/code&gt; and &lt;code&gt;Meteor.loggingIn()&lt;/code&gt;).</source>
          <target state="translated">현재 사용자 상태 ( &lt;code&gt;Meteor.user()&lt;/code&gt; 및 &lt;code&gt;Meteor.loggingIn()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="35e8eb02090a8e4baa59367c7ab5ef3d91ad8b02" translate="yes" xml:space="preserve">
          <source>The data context of this instance's latest invocation.</source>
          <target state="translated">이 인스턴스의 최신 호출의 데이터 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="9c9be1129e2a2dca40064429c01c92c34a444d2b" translate="yes" xml:space="preserve">
          <source>The data context to use, or a function returning a data context.</source>
          <target state="translated">사용할 데이터 컨텍스트 또는 데이터 컨텍스트를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="edc2b40c85ef4f8f1ca8337a54cb2a5ffbca0e8a" translate="yes" xml:space="preserve">
          <source>The data context to use, or a function returning a data context. If a function is provided, it will be reactively re-run.</source>
          <target state="translated">사용할 데이터 컨텍스트 또는 데이터 컨텍스트를 반환하는 함수입니다. 기능이 제공되면 사후에 재실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c791d4cf7c01b8051fca1ec022bd56ffb37e3e85" translate="yes" xml:space="preserve">
          <source>The data returned from publications will often be dependent on the currently logged in user, and perhaps some properties about that user - whether they are an admin, whether they own a certain document, etc.</source>
          <target state="translated">발행물에서 반환 된 데이터는 종종 현재 로그인 한 사용자 및 해당 사용자에 대한 일부 속성 (관리자인지, 특정 문서를 소유하는지 여부 등)에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0c03db688e73505c62ded0a799de175fe32c90" translate="yes" xml:space="preserve">
          <source>The decisions made and practices outlined in the guide must necessarily be &lt;strong&gt;opinionated&lt;/strong&gt;. Certain best practices will be highlighted and other valid approaches ignored. We aim to reach community consensus around major decisions but there will always be other ways to solve problems when developing your application. We believe it&amp;rsquo;s important to know what the &amp;ldquo;standard&amp;rdquo; way to solve a problem is before branching out to other options. If an alternate approach proves itself superior, then it should make its way into a future version of the guide.</source>
          <target state="translated">가이드에 요약 된 결정과 관행은 반드시 &lt;strong&gt;의견이&lt;/strong&gt; 있어야합니다 . 특정 모범 사례가 강조 표시되고 다른 유효한 접근 방식은 무시됩니다. 우리는 주요 결정에 대해 커뮤니티 합의에 도달하는 것을 목표로하지만 애플리케이션 개발시 문제를 해결하는 다른 방법이 항상 있습니다. 다른 옵션으로 분기하기 전에 문제를 해결하는 &quot;표준&quot;방법이 무엇인지 아는 것이 중요하다고 생각합니다. 대체 접근법이 그 자체로 우수하다고 판명되면 향후 버전의 가이드로 나아가 야합니다.</target>
        </trans-unit>
        <trans-unit id="7d4f7d958407c1a06736784ae1695c00701ac37c" translate="yes" xml:space="preserve">
          <source>The default create user function simply copies &lt;code&gt;options.profile&lt;/code&gt; into the new user document. Calling &lt;code&gt;onCreateUser&lt;/code&gt; overrides the default hook. This can only be called once.</source>
          <target state="translated">기본 사용자 작성 기능은 단순히 &lt;code&gt;options.profile&lt;/code&gt; 을 새 사용자 문서에 복사 합니다. &lt;code&gt;onCreateUser&lt;/code&gt; 를 호출 하면 기본 후크가 무시됩니다. 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c5cfa48990a96b48af53f2fc3024bbc22eed8a" translate="yes" xml:space="preserve">
          <source>The default id generation technique is &lt;code&gt;'STRING'&lt;/code&gt;.</source>
          <target state="translated">기본 아이디 생성 기술은 &lt;code&gt;'STRING'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8008a9a87d839dbf55ce84f54c0459067f8855a" translate="yes" xml:space="preserve">
          <source>The different types of MongoDB collections in Meteor, and how to use them.</source>
          <target state="translated">Meteor의 다양한 유형의 MongoDB 모음 및 사용 방법</target>
        </trans-unit>
        <trans-unit id="247b0b2ab6a208b9a4bb279c595c176c2523532c" translate="yes" xml:space="preserve">
          <source>The document &lt;code&gt;oldDocument&lt;/code&gt; is no longer in the result set. It used to be at position &lt;code&gt;atIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;oldDocument&lt;/code&gt; 문서 가 더 이상 결과 세트에 없습니다. 예전에는 &lt;code&gt;atIndex&lt;/code&gt; 위치에 있었습니다.</target>
        </trans-unit>
        <trans-unit id="3f0e90b6931b50def96a79f404db488a08193c82" translate="yes" xml:space="preserve">
          <source>The document identified by &lt;code&gt;id&lt;/code&gt; changed its position in the ordered result set, and now appears before the document identified by &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">에 의해 확인 된 문서 &lt;code&gt;id&lt;/code&gt; 정렬 된 결과 집합에서의 위치를 변경하고, 지금까지 확인 된 문서 전에 나타나는 &lt;code&gt;before&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd89a7a2b537dfcdd001e0d4bd5f90e6ea11ef4" translate="yes" xml:space="preserve">
          <source>The document identified by &lt;code&gt;id&lt;/code&gt; has changed. &lt;code&gt;fields&lt;/code&gt; contains the changed fields with their new values. If a field was removed from the document then it will be present in &lt;code&gt;fields&lt;/code&gt; with a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 식별 된 문서 가 변경되었습니다. &lt;code&gt;fields&lt;/code&gt; 에는 새로운 값으로 변경된 필드가 포함됩니다. 필드가 문서에서 제거 된 경우 값이 &lt;code&gt;undefined&lt;/code&gt; 인 &lt;code&gt;fields&lt;/code&gt; 에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="a624fb59fe57070dc297d97890126e9ee977185d" translate="yes" xml:space="preserve">
          <source>The document identified by &lt;code&gt;id&lt;/code&gt; was removed from the result set.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 로 식별 된 문서 가 결과 세트에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="45589e64c975888c317277bc78ee35890c7019c5" translate="yes" xml:space="preserve">
          <source>The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.</source>
          <target state="translated">삽입 할 문서입니다. 아직 _id 속성이 없을 수 있습니다.이 경우 Meteor가이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="517b6c99561135b8cbfdab91517658497ea8d515" translate="yes" xml:space="preserve">
          <source>The documentation, usage instructions, and a starter application can be found in the &lt;a href=&quot;http://dev.apollodata.com/core/meteor.html&quot;&gt;&lt;code&gt;apollo&lt;/code&gt; section&lt;/a&gt; of the &lt;a href=&quot;http://dev.apollodata.com/&quot;&gt;Apollo Developer docs&lt;/a&gt;.</source>
          <target state="translated">문서, 사용 방법 및 스타터 응용 프로그램은에서 찾을 수 있습니다 &lt;a href=&quot;http://dev.apollodata.com/core/meteor.html&quot;&gt; &lt;code&gt;apollo&lt;/code&gt; 섹션&lt;/a&gt; 의 &lt;a href=&quot;http://dev.apollodata.com/&quot;&gt;아폴로 개발자 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aecd209e0c60f336e8759e3bfcf604328d1467f9" translate="yes" xml:space="preserve">
          <source>The domain or address of the Meteor server to connect to for DDP and hot code push of new versions.</source>
          <target state="translated">새 버전의 DDP 및 핫 코드 푸시를 위해 연결할 Meteor 서버의 도메인 또는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="9a28cb88919fcb07c997e5e68538f81d1f539252" translate="yes" xml:space="preserve">
          <source>The dynamic &lt;code&gt;import(...)&lt;/code&gt; statement is a complimentary method to the static &lt;code&gt;import&lt;/code&gt; technique of requiring a module. While a statically</source>
          <target state="translated">dynamic &lt;code&gt;import(...)&lt;/code&gt; 문은 모듈이 필요한 정적 &lt;code&gt;import&lt;/code&gt; 기술에 대한 무료 메소드 입니다. 정적으로</target>
        </trans-unit>
        <trans-unit id="6658088a6e39e457724f921b9b53571618b0a1a3" translate="yes" xml:space="preserve">
          <source>The easiest way to get a working Android development environment is by installing &lt;a href=&quot;http://developer.android.com/sdk/index.html&quot;&gt;Android Studio&lt;/a&gt;, which offers a setup wizard on first launch that installs the Android SDK for you, and downloads a default set of tools, platforms, and other components that you will need to start developing.</source>
          <target state="translated">작동하는 Android 개발 환경을 얻는 가장 쉬운 방법은 &lt;a href=&quot;http://developer.android.com/sdk/index.html&quot;&gt;Android Studio&lt;/a&gt; 를 설치하는 것입니다. Android Studio 는 첫 실행시 Android SDK를 설치하고 필요한 기본 도구, 플랫폼 및 기타 구성 요소 세트를 다운로드하는 설정 마법사를 제공합니다. 개발을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="fbc1b9fea28d9910514c0baa971432c63c1771f5" translate="yes" xml:space="preserve">
          <source>The easiest way to get a working Android development environment is by installing &lt;a href=&quot;https://developer.android.com/sdk/index.html&quot;&gt;Android Studio&lt;/a&gt;, which offers a setup wizard on first launch that installs the Android SDK for you, and downloads a default set of tools, platforms, and other components that you will need to start developing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e46780139e2e7cbdd276acdef814c73f6776661" translate="yes" xml:space="preserve">
          <source>The easiest way to operate your app with confidence is to use Galaxy, the service built by Meteor Development Group specifically to run Meteor apps.</source>
          <target state="translated">자신있게 앱을 운영하는 가장 쉬운 방법은 Meteor Development Group에서 개발 한 서비스 인 Galaxy를 사용하여 Meteor 앱을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="654fba81e3a9c2aa1c5bf9b6a56018ac01de8f0c" translate="yes" xml:space="preserve">
          <source>The element currently handling the event. This is the element that matched the selector in the event map. For events that bubble, it may be &lt;code&gt;target&lt;/code&gt; or an ancestor of &lt;code&gt;target&lt;/code&gt;, and its value changes as the event bubbles.</source>
          <target state="translated">현재 이벤트를 처리하는 요소입니다. 이벤트 맵에서 선택기와 일치하는 요소입니다. 거품이 이벤트를 들면, 일 수있다 &lt;code&gt;target&lt;/code&gt; 또는 상위 &lt;code&gt;target&lt;/code&gt; , 그 값은 이벤트 방울로 변경한다.</target>
        </trans-unit>
        <trans-unit id="07d9edbe44b8b93d5155bab0d32f17818f6f99b4" translate="yes" xml:space="preserve">
          <source>The element that originated the event.</source>
          <target state="translated">이벤트를 시작한 요소입니다.</target>
        </trans-unit>
        <trans-unit id="6be9d3326749416c1be6ea1db2002aad21872641" translate="yes" xml:space="preserve">
          <source>The email address to look for</source>
          <target state="translated">찾을 이메일 주소</target>
        </trans-unit>
        <trans-unit id="3743afb81fcad8ac1416b9103eed387633f80c05" translate="yes" xml:space="preserve">
          <source>The email address to remove.</source>
          <target state="translated">제거 할 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="9eda1a7cbc691a218c11f872db26c1738104cfe2" translate="yes" xml:space="preserve">
          <source>The email address to send a password reset link.</source>
          <target state="translated">비밀번호 재설정 링크를 보낼 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="7ac844ecc62bf24b7a12b30517f37c5a73fd2756" translate="yes" xml:space="preserve">
          <source>The email is generated using the email templates from &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_emailtemplates&quot;&gt;Accounts.emailTemplates&lt;/a&gt;, and include links generated with &lt;code&gt;Accounts.urls&lt;/code&gt;. We&amp;rsquo;ll go into more detail about customizing the email content and URL later.</source>
          <target state="translated">이메일은 &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_emailtemplates&quot;&gt;Accounts.emailTemplates&lt;/a&gt; 의 이메일 템플리트를 사용하여 생성되며 &lt;code&gt;Accounts.urls&lt;/code&gt; 로 생성 된 링크를 포함합니다 . 이메일 내용 및 URL 사용자 정의에 대해서는 나중에 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="567d93adeeb375b1b5fad532439a099741568237" translate="yes" xml:space="preserve">
          <source>The enclosing View that caused this View to be rendered, if any.</source>
          <target state="translated">이 뷰를 렌더링하게 한 둘러싸는 뷰입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a39bb6a8c9c2bfc0c4251979c3ae716828e4f6d0" translate="yes" xml:space="preserve">
          <source>The encryption key is 16 bytes, encoded in Base64.</source>
          <target state="translated">암호화 키는 16 바이트이며 Base64로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7a139e0d0e150d967403ab83e938806c4dce6822" translate="yes" xml:space="preserve">
          <source>The error to pass to the client.</source>
          <target state="translated">클라이언트에 전달하는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="12cd803332783618763b1137bc79bb163ecafb8d" translate="yes" xml:space="preserve">
          <source>The estimated time of the next reconnection attempt. To turn this into an interval until the next reconnection, use &lt;code&gt;retryTime - (new Date()).getTime()&lt;/code&gt;. This key will be set only when &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;waiting&lt;/code&gt;.</source>
          <target state="translated">다음 재 연결 시도의 예상 시간입니다. 다음에 다시 연결할 때까지이를 간격으로 바꾸려면 &lt;code&gt;retryTime - (new Date()).getTime()&lt;/code&gt; . 이 키는 &lt;code&gt;status&lt;/code&gt; 가 &lt;code&gt;waiting&lt;/code&gt; 경우에만 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6eb6952418b5ed3ce89f3c1265f9e982a83f1479" translate="yes" xml:space="preserve">
          <source>The event&amp;rsquo;s type, such as &amp;ldquo;click&amp;rdquo;, &amp;ldquo;blur&amp;rdquo; or &amp;ldquo;keypress&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;클릭&amp;rdquo;,&amp;ldquo;흐림&amp;rdquo;또는&amp;ldquo;키 누르기&amp;rdquo;와 같은 이벤트 유형.</target>
        </trans-unit>
        <trans-unit id="dacbc84d4f22d4a66057c29a4639052e47783b20" translate="yes" xml:space="preserve">
          <source>The factory function passed to the &lt;code&gt;EJSON.addType&lt;/code&gt; method should create an instance of our custom type and initialize it with values from an object passed as the first argument of the factory function. Here is an example:</source>
          <target state="translated">&lt;code&gt;EJSON.addType&lt;/code&gt; 메소드에 전달 된 팩토리 함수는 사용자 정의 유형의 인스턴스를 작성하고 팩토리 함수의 첫 번째 인수로 전달 된 오브젝트의 값으로 초기화해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92ba2c3871355e6bdd10259faea23c325aea857a" translate="yes" xml:space="preserve">
          <source>The fields in the document that have changed, together with their new values. If a field is not present in &lt;code&gt;fields&lt;/code&gt; it was left unchanged; if it is present in &lt;code&gt;fields&lt;/code&gt; and has a value of &lt;code&gt;undefined&lt;/code&gt; it was removed from the document. If &lt;code&gt;_id&lt;/code&gt; is present it is ignored.</source>
          <target state="translated">새 값과 함께 변경된 문서의 필드입니다. 필드가 존재하지 않으면 &lt;code&gt;fields&lt;/code&gt; 는 그대로 방치 하였다; 이 존재할 경우 &lt;code&gt;fields&lt;/code&gt; 및 값 갖는다 &lt;code&gt;undefined&lt;/code&gt; 그것은 문서로부터 제거 하였다. 경우 &lt;code&gt;_id&lt;/code&gt; 는 존재는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1439fc236a1522eefd719270b3de11c81f763fdc" translate="yes" xml:space="preserve">
          <source>The fields in the new document. If &lt;code&gt;_id&lt;/code&gt; is present it is ignored.</source>
          <target state="translated">새 문서의 필드 경우 &lt;code&gt;_id&lt;/code&gt; 는 존재는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="daf7b75d0ac7c5652e53090e2da5ea8c9d128776" translate="yes" xml:space="preserve">
          <source>The file extension that this plugin should handle, without the first dot. Examples: &lt;code&gt;&quot;coffee&quot;&lt;/code&gt;, &lt;code&gt;&quot;coffee.md&quot;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 점없이이 플러그인이 처리해야하는 파일 확장자입니다. 예 : &lt;code&gt;&quot;coffee&quot;&lt;/code&gt; , &lt;code&gt;&quot;coffee.md&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d994f1d29813d3ea3225942ca3ca1433446e74" translate="yes" xml:space="preserve">
          <source>The file serving mechanism used in Meteor allows for local file access through URLs of the form &lt;code&gt;http://localhost:&amp;lt;port&amp;gt;/local-filesystem/&amp;lt;path&amp;gt;&lt;/code&gt;) however. You can construct these file system URLs manually, or use &lt;code&gt;WebAppLocalServer.localFileSystemUrl()&lt;/code&gt; to convert &lt;code&gt;file://&lt;/code&gt; URLs. You can use this to convert URLs received from plugins like &lt;code&gt;cordova-plugin-file&lt;/code&gt; and &lt;code&gt;cordova-plugin-camera&lt;/code&gt; for example.</source>
          <target state="translated">그러나 Meteor에서 사용되는 파일 제공 메커니즘은 &lt;code&gt;http://localhost:&amp;lt;port&amp;gt;/local-filesystem/&amp;lt;path&amp;gt;&lt;/code&gt; 형식의 URL을 통한 로컬 파일 액세스를 허용합니다 . 이러한 파일 시스템 URL을 수동으로 구성하거나 &lt;code&gt;WebAppLocalServer.localFileSystemUrl()&lt;/code&gt; 을 사용 하여 &lt;code&gt;file://&lt;/code&gt; URL 을 변환 할 수 있습니다 . 이를 사용 하여 예를 들어 &lt;code&gt;cordova-plugin-file&lt;/code&gt; 및 &lt;code&gt;cordova-plugin-camera&lt;/code&gt; 와 같은 플러그인에서 수신 한 URL을 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fc2a53e18d567493a7dab3e0e1c62a5ab75f9af" translate="yes" xml:space="preserve">
          <source>The first identifier in a path is resolved in one of two ways:</source>
          <target state="translated">경로의 첫 번째 식별자는 다음 두 가지 방법 중 하나로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="fc45df8317aed71cc42c885955e9514593eba5f6" translate="yes" xml:space="preserve">
          <source>The first node of the View&amp;rsquo;s rendered content. Note that this may be a text node. Requires that the View be rendered. If the View rendered to zero DOM nodes, it may be a placeholder node (comment or text node). The DOM extent of a View consists of the nodes between &lt;code&gt;view.firstNode()&lt;/code&gt; and &lt;code&gt;view.lastNode()&lt;/code&gt;, inclusive.</source>
          <target state="translated">뷰의 렌더링 된 컨텐츠의 첫 번째 노드입니다. 이것은 텍스트 노드 일 수 있습니다. 뷰를 렌더링해야합니다. 뷰가 DOM 노드를 0으로 렌더링하지 않으면 자리 표시 자 노드 (설명 또는 텍스트 노드) 일 수 있습니다. View의 DOM 범위는 &lt;code&gt;view.firstNode()&lt;/code&gt; 와 &lt;code&gt;view.lastNode()&lt;/code&gt; 사이의 노드로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9593cc38f7d0efced546ec7c49927969fdd40020" translate="yes" xml:space="preserve">
          <source>The first thing to consider here is if you actually need to care about your component re-rendering. Blaze is optimized so that it typically doesn&amp;rsquo;t matter if a component is re-rendered even if it strictly shouldn&amp;rsquo;t. If you make sure that your helpers are cheap to run and consequently rendering is not expensive, then you probably don&amp;rsquo;t need to worry about this.</source>
          <target state="translated">여기서 고려해야 할 첫 번째 사항은 실제로 컴포넌트를 다시 렌더링해야하는 경우입니다. Blaze는 구성 요소가 엄격하게 렌더링되어서는 안 되더라도 다시 렌더링하는 것이 중요하지 않도록 최적화되어 있습니다. 도우미가 실행하기에 저렴하고 결과적으로 렌더링 비용이 비싸지 않은 경우이를 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="584ecaca2c8bcc54e95a7d1cdec2c8b572958b24" translate="yes" xml:space="preserve">
          <source>The first thing to understand about &lt;code&gt;useraccounts&lt;/code&gt; is that the core accounts management logic is independent of the HTML templates and routing packages. This means you can use &lt;a href=&quot;https://atmospherejs.com/useraccounts/core&quot;&gt;&lt;code&gt;useraccounts:core&lt;/code&gt;&lt;/a&gt; to build your own set of login templates. Generally, you&amp;rsquo;ll want to pick one login template package and one login routing package. The options for templates include:</source>
          <target state="translated">에 대해 이해하는 첫 번째 일은 &lt;code&gt;useraccounts&lt;/code&gt; 는 핵심 계정 관리 로직이 HTML 템플릿과 라우팅 패키지의 독립적 인 것입니다. 즉, &lt;a href=&quot;https://atmospherejs.com/useraccounts/core&quot;&gt; &lt;code&gt;useraccounts:core&lt;/code&gt; &lt;/a&gt; 를 사용하여 고유 한 로그인 템플릿 세트를 구축 할 수 있습니다 . 일반적으로 하나의 로그인 템플릿 패키지와 하나의 로그인 라우팅 패키지를 선택하려고합니다. 템플릿 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7faa87860bf4abfc4c966f5fc83a212ecb9abb9" translate="yes" xml:space="preserve">
          <source>The first top-level DOM node in this template instance.</source>
          <target state="translated">이 템플릿 인스턴스의 첫 번째 최상위 DOM 노드입니다.</target>
        </trans-unit>
        <trans-unit id="f1ed35800128020fe247eb673ce130f63b49ace7" translate="yes" xml:space="preserve">
          <source>The following are some of the more commonly used commands in the &lt;code&gt;meteor&lt;/code&gt; command-line tool. This is just an overview and does not mention every command or every option to every command; for more details, use the &lt;code&gt;meteor help&lt;/code&gt; command.</source>
          <target state="translated">다음은 &lt;code&gt;meteor&lt;/code&gt; 명령 줄 도구 에서 가장 일반적으로 사용되는 명령 중 일부입니다 . 이것은 단지 개요 일 뿐이며 모든 명령 또는 모든 명령에 대한 모든 옵션을 언급하지는 않습니다. 자세한 내용은 &lt;code&gt;meteor help&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8f068eb49d38bd41b15412d2114fd69d1623795" translate="yes" xml:space="preserve">
          <source>The following directories are also not loaded as part of your app code:</source>
          <target state="translated">다음 디렉토리도 앱 코드의 일부로로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f458bb9e4e3f205db3d2788a44adc0955a225cb2" translate="yes" xml:space="preserve">
          <source>The following patterns can be used as pattern arguments to &lt;a href=&quot;#check&quot;&gt;&lt;code&gt;check&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Match.test&lt;/code&gt;:</source>
          <target state="translated">다음 패턴을 &lt;a href=&quot;#check&quot;&gt; &lt;code&gt;check&lt;/code&gt; &lt;/a&gt; 하고 &lt;code&gt;Match.test&lt;/code&gt; 하는 패턴 인수로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01b079166094902f236986e058597d9c5b4c6829" translate="yes" xml:space="preserve">
          <source>The following properties and methods are available on Blaze.View:</source>
          <target state="translated">Blaze.View에서 다음 속성 및 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc25416eed36dd3efad8f9cdadf6ef42aab4bbd1" translate="yes" xml:space="preserve">
          <source>The following properties and methods are available on the event object passed to handlers:</source>
          <target state="translated">핸들러에 전달 된 이벤트 오브젝트에서 다음 특성 및 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02444ac0e947a21897753e15438db3b2b3a71f9" translate="yes" xml:space="preserve">
          <source>The function is invoked immediately, at which point it may alert and stop right away if &lt;code&gt;shouldAlert&lt;/code&gt; is already true. If not, the function is run again when &lt;code&gt;shouldAlert&lt;/code&gt; becomes true.</source>
          <target state="translated">&lt;code&gt;shouldAlert&lt;/code&gt; 가 이미 true 인 경우 함수가 즉시 호출되어 즉시 경고하고 중지 할 수 있습니다 . 그렇지 않은 경우 &lt;code&gt;shouldAlert&lt;/code&gt; 가 true가 되면 함수가 다시 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5fc97ab72920fe5fa5a9a758c687e1ae9ce53c0" translate="yes" xml:space="preserve">
          <source>The function returns an object with methods to &lt;a href=&quot;#insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; documents in the collection, &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt; their properties, and &lt;a href=&quot;#remove&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; them, and to &lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; the documents in the collection that match arbitrary criteria. The way these methods work is compatible with the popular Mongo database API. The same database API works on both the client and the server (see below).</source>
          <target state="translated">이 함수는 컬렉션에 문서 를 &lt;a href=&quot;#insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; 하고 속성을 &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt; 한 다음 &lt;a href=&quot;#remove&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 하고 컬렉션에서 임의의 기준과 일치하는 문서 를 &lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 메서드가있는 객체를 반환 합니다. 이러한 메소드의 작동 방식은 널리 사용되는 Mongo 데이터베이스 API와 호환됩니다. 동일한 데이터베이스 API가 클라이언트와 서버 모두에서 작동합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="00960f5c749ac85fa276f4981b76cea9b5cf20e7" translate="yes" xml:space="preserve">
          <source>The function should return the user document (either the one passed in or a newly-created object) with whatever modifications are desired. The returned document is inserted directly into the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">이 함수는 원하는대로 수정하여 사용자 문서 (전달 된 문서 또는 새로 만든 객체)를 반환해야합니다. 반환 된 문서는 &lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt; 컬렉션에 직접 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="25f8f1273d5558936c16f7f636b59e3500409771" translate="yes" xml:space="preserve">
          <source>The function to call when a new DDP connection is established.</source>
          <target state="translated">새로운 DDP 연결이 설정 될 때 호출하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a381d8d1cd22b68668676a7e01122fcafe1c6552" translate="yes" xml:space="preserve">
          <source>The function to call. It is given two arguments:</source>
          <target state="translated">호출 할 함수입니다. 두 가지 주장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4137a187bc9d506f095cd90f857f7ad1d0d546d3" translate="yes" xml:space="preserve">
          <source>The function to call. It will be called with a single argument, the &lt;a href=&quot;#ddp_connect&quot;&gt;connection object&lt;/a&gt; that is reconnecting.</source>
          <target state="translated">호출 할 함수입니다. 다시 &lt;a href=&quot;#ddp_connect&quot;&gt;연결&lt;/a&gt; 되는 연결 개체 인 단일 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4536fc32a9148981dd5404f4b2e238b1332cdacf" translate="yes" xml:space="preserve">
          <source>The function to run</source>
          <target state="translated">실행할 기능</target>
        </trans-unit>
        <trans-unit id="6a6c8ac9b40bb186fd447ca19470ac35f142a0c8" translate="yes" xml:space="preserve">
          <source>The function to run. It receives one argument: a Tracker.Computation object.</source>
          <target state="translated">실행할 함수입니다. 하나의 인수 인 Tracker.Computation 객체를받습니다.</target>
        </trans-unit>
        <trans-unit id="ea0d21bc45812b570af7457f46863740e4deaeee" translate="yes" xml:space="preserve">
          <source>The function to run. It receives one argument: the Computation object that will be returned.</source>
          <target state="translated">실행할 함수입니다. 하나의 인수, 즉 반환 될 Computation 객체를받습니다.</target>
        </trans-unit>
        <trans-unit id="faffbe39cd94e8cfe5c69f1c6e0a9a8ffb6d19db" translate="yes" xml:space="preserve">
          <source>The function you pass will be called with two arguments: &lt;code&gt;options&lt;/code&gt; and &lt;code&gt;user&lt;/code&gt;. The &lt;code&gt;options&lt;/code&gt; argument comes from &lt;a href=&quot;#accounts_createuser&quot;&gt;&lt;code&gt;Accounts.createUser&lt;/code&gt;&lt;/a&gt; for password-based users or from an external service login flow. &lt;code&gt;options&lt;/code&gt; may come from an untrusted client so make sure to validate any values you read from it. The &lt;code&gt;user&lt;/code&gt; argument is created on the server and contains a proposed user object with all the automatically generated fields required for the user to log in, including the &lt;code&gt;_id&lt;/code&gt;.</source>
          <target state="translated">전달하는 함수는 &lt;code&gt;options&lt;/code&gt; 와 &lt;code&gt;user&lt;/code&gt; 의 두 인수로 호출됩니다 . &lt;code&gt;options&lt;/code&gt; 인수에서 오는 &lt;a href=&quot;#accounts_createuser&quot;&gt; &lt;code&gt;Accounts.createUser&lt;/code&gt; &lt;/a&gt; 암호를 기반으로 사용자 또는 외부 서비스 로그인 흐름에서. &lt;code&gt;options&lt;/code&gt; 은 신뢰할 수없는 클라이언트에서 제공 될 수 있으므로 읽은 값을 확인하십시오. &lt;code&gt;user&lt;/code&gt; 인수는 서버에서 작성을 포함하여 사용자가 로그인 할 때 필요한 모든 자동으로 생성 된 필드와 제안 된 사용자 개체를 포함합니다 &lt;code&gt;_id&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="fd446fbeb8bacd739ba69b7eae72ca032e711e1b" translate="yes" xml:space="preserve">
          <source>The global Meteor server context and every method and publication initialize a new fiber so that they can run concurrently. Many Meteor APIs, for example collections, rely on running inside a fiber. They also rely on an internal Meteor mechanism that tracks server &amp;ldquo;environment&amp;rdquo; state, like the currently executing method. This means you need to initialize your own fiber and environment to use asynchronous Node code inside a Meteor app. Let&amp;rsquo;s look at an example of some code that won&amp;rsquo;t work, using the code example from the &lt;a href=&quot;https://github.com/mikedeboer/node-github&quot;&gt;node-github repository&lt;/a&gt;:</source>
          <target state="translated">글로벌 Meteor 서버 컨텍스트와 모든 방법 및 발행물은 동시에 실행될 수 있도록 새 파이버를 초기화합니다. 컬렉션과 같은 많은 Meteor API는 파이버 내부에서 실행하는 데 의존합니다. 또한 현재 실행중인 방법과 같이 서버 &quot;환경&quot;상태를 추적하는 내부 Meteor 메커니즘을 사용합니다. 즉, Meteor 앱 내에서 비동기 노드 코드를 사용하려면 자체 파이버 및 환경을 초기화해야합니다. &lt;a href=&quot;https://github.com/mikedeboer/node-github&quot;&gt;node-github 리포지토리&lt;/a&gt; 의 코드 예제를 사용하여 작동하지 않는 일부 코드의 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b53a8d04298b3864946e232b02e320f299d1060f" translate="yes" xml:space="preserve">
          <source>The globals are passed in the options object so that the linters can omit the warnings about the package imports that look like global variables.</source>
          <target state="translated">글로벌은 옵션 객체에 전달되므로 린 터는 글로벌 변수처럼 보이는 패키지 가져 오기에 대한 경고를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a7132664b40248286c2cf32b5fb7c2748ae238" translate="yes" xml:space="preserve">
          <source>The good news is that Promises can be used with the new ES2015 &lt;code&gt;async/await&lt;/code&gt; syntax (available in the &lt;code&gt;ecmascript&lt;/code&gt; package since Meteor 1.3) in a natural and synchronous-looking style on both the client and the server.</source>
          <target state="translated">좋은 소식은 클라이언트와 서버 모두에서 자연스럽고 동기적인 스타일로 Promises를 새로운 ES2015 &lt;code&gt;async/await&lt;/code&gt; 구문 ( Meteor 1.3부터 &lt;code&gt;ecmascript&lt;/code&gt; 패키지 에서 사용 가능)과 함께 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="dca7a84b25430a74537ddd3adccb73d27ffe3d55" translate="yes" xml:space="preserve">
          <source>The guide also includes sample applications created with Angular, React, Vue, and Blaze&amp;mdash;all written in TypeScript. See the code &lt;a href=&quot;https://github.com/birkskyum/meteor-typescript-samples&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 안내서에는 TypeScript로 작성된 Angular, React, Vue 및 Blaze로 만든 샘플 응용 프로그램도 포함되어 있습니다. &lt;a href=&quot;https://github.com/birkskyum/meteor-typescript-samples&quot;&gt;여기&lt;/a&gt; 코드를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="637199bf494276120c5fbbfac4671918711cf1b1" translate="yes" xml:space="preserve">
          <source>The guide is targeted towards intermediate developers that have some familiarity with JavaScript, the Meteor platform, and web development in general. If you are just getting started with Meteor, we recommend starting with the &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/creating-an-app&quot;&gt;official tutorial&lt;/a&gt;.</source>
          <target state="translated">이 가이드는 JavaScript, Meteor 플랫폼 및 일반적으로 웹 개발에 익숙한 중급 개발자를 대상으로합니다. Meteor를 막 시작한 경우 &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/creating-an-app&quot;&gt;공식 자습서로&lt;/a&gt; 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="02872d00bba492451f9d7a01ba71c7f54ca30435" translate="yes" xml:space="preserve">
          <source>The handle returned by &lt;code&gt;Meteor.setInterval&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Meteor.setInterval&lt;/code&gt; 에 의해 리턴 된 핸들</target>
        </trans-unit>
        <trans-unit id="b73edf919779af977d5b21d29da5337b539a99f7" translate="yes" xml:space="preserve">
          <source>The handle returned by &lt;code&gt;Meteor.setTimeout&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Meteor.setTimeout&lt;/code&gt; 에 의해 리턴 된 핸들</target>
        </trans-unit>
        <trans-unit id="32dd1bcb0d7fab3d53fcd4d7bf060d5dd00ba3e5" translate="yes" xml:space="preserve">
          <source>The handler function receives two arguments: &lt;code&gt;event&lt;/code&gt;, an object with information about the event, and &lt;code&gt;template&lt;/code&gt;, a &lt;a href=&quot;#Template-instances&quot;&gt;template instance&lt;/a&gt; for the template where the handler is defined. The handler also receives some additional context data in &lt;code&gt;this&lt;/code&gt;, depending on the context of the current element handling the event. In a template, an element&amp;rsquo;s context is the data context where that element occurs, which is set by block helpers such as &lt;code&gt;#with&lt;/code&gt; and &lt;code&gt;#each&lt;/code&gt;.</source>
          <target state="translated">핸들러 함수는 &lt;code&gt;event&lt;/code&gt; 에 대한 정보가있는 객체 인 event와 핸들러가 정의 된 템플리트 의 &lt;a href=&quot;#Template-instances&quot;&gt;템플리트 인스턴스 인 &lt;/a&gt; &lt;code&gt;template&lt;/code&gt; 의 두 가지 인수를 수신 합니다 . 처리기는 또한 몇 가지 추가적인 컨텍스트 데이터를 수신하여 &lt;code&gt;this&lt;/code&gt; 이벤트를 처리하는 현재의 소자의 상황에 따라. 템플릿에서 요소의 컨텍스트는 해당 요소가 발생하는 데이터 컨텍스트이며 &lt;code&gt;#with&lt;/code&gt; 및 &lt;code&gt;#each&lt;/code&gt; 와 같은 블록 도우미에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6e0376def06813eb38f25196ebac8ff4d53d7e8" translate="yes" xml:space="preserve">
          <source>The helper function itself.</source>
          <target state="translated">도우미 기능 자체.</target>
        </trans-unit>
        <trans-unit id="893f4536b2fef4324989d08558e5e7b6b4f3a8f6" translate="yes" xml:space="preserve">
          <source>The helper&amp;rsquo;s implementation can access the current data context as &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">도우미의 구현은 &lt;code&gt;this&lt;/code&gt; 로 현재 데이터 컨텍스트에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7beb40c5f9b25a82388e468937e0480879ed1acc" translate="yes" xml:space="preserve">
          <source>The id of the user that made this method call, or &lt;code&gt;null&lt;/code&gt; if no user was logged in.</source>
          <target state="translated">이 메소드를 호출 한 사용자의 ID 또는 사용자가 로그인하지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c3d6519aed2e24a46dcc82ff3d5453e2efa97ed" translate="yes" xml:space="preserve">
          <source>The id of the user to send email to.</source>
          <target state="translated">이메일을 보낼 사용자의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="c984f1a5985da0663c84dd201c8b9bd65398c096" translate="yes" xml:space="preserve">
          <source>The id of the user to update.</source>
          <target state="translated">업데이트 할 사용자의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="22bb0cd5e6ef4498df5368ed05bad68ba985f028" translate="yes" xml:space="preserve">
          <source>The idea of the staging environment is to provide a non-user-visible test environment that is as close as possible to production in terms of infrastructure. It&amp;rsquo;s common for issues to appear with new code on the production infrastructure that just don&amp;rsquo;t happen in a development environment. A very simple example is issues that involve latency between the client and server&amp;mdash;connecting to a local development server with tiny latencies, you just may never see such an issue.</source>
          <target state="translated">준비 환경의 개념은 인프라와 관련하여 프로덕션에 최대한 가까운 사용자가 볼 수없는 테스트 환경을 제공하는 것입니다. 개발 환경에서는 발생하지 않는 프로덕션 인프라에 새로운 코드로 문제가 나타나는 것이 일반적입니다. 아주 간단한 예는 클라이언트와 서버 간의 대기 시간과 관련된 문제입니다. 지연 시간이 짧은 로컬 개발 서버에 연결하면 이러한 문제가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="001061d23a95f7611790e74787aacc1f359fe589" translate="yes" xml:space="preserve">
          <source>The identifier of the plugin you want to configure.</source>
          <target state="translated">구성하려는 플러그인의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="df92b794d4b888ef989636e3e383472a156d5358" translate="yes" xml:space="preserve">
          <source>The implication of the above is that we need to create more collections to contain sub-documents. In the case of the Todos application, we need both a &lt;code&gt;Lists&lt;/code&gt; collection and a &lt;code&gt;Todos&lt;/code&gt; collection to contain each list&amp;rsquo;s todo items. Consequently we need to do some things that you&amp;rsquo;d typically associate with a SQL database, like using foreign keys (&lt;code&gt;todo.listId&lt;/code&gt;) to associate one document with another.</source>
          <target state="translated">위의 의미는 하위 문서를 포함하기 위해 더 많은 컬렉션을 만들어야한다는 것입니다. Todos 애플리케이션의 경우, 각 목록의 할 일 항목을 포함하려면 &lt;code&gt;Lists&lt;/code&gt; 컬렉션과 &lt;code&gt;Todos&lt;/code&gt; 컬렉션이 모두 필요 합니다. 따라서 외래 키 ( &lt;code&gt;todo.listId&lt;/code&gt; )를 사용하여 한 문서를 다른 문서와 연결하는 것과 같이 일반적으로 SQL 데이터베이스와 연결하는 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="39615301fcd77be1815bf649443edd765568538f" translate="yes" xml:space="preserve">
          <source>The initial value to set. &lt;code&gt;equalsFunc&lt;/code&gt; is ignored when setting the initial value.</source>
          <target state="translated">설정할 초기 값입니다. 초기 값을 설정할 때는 &lt;code&gt;equalsFunc&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="631bf9914cea7c7ce5a67604f6dd1f72c8e049d4" translate="yes" xml:space="preserve">
          <source>The inserted HTML must consist of balanced HTML tags. You can&amp;rsquo;t, for example, insert &lt;code&gt;&quot;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&quot;&lt;/code&gt; to close an existing div and open a new one.</source>
          <target state="translated">삽입 된 HTML은 균형 HTML 태그로 구성되어야합니다. 예를 들어 &lt;code&gt;&quot;&amp;lt;/div&amp;gt;&amp;lt;div&amp;gt;&quot;&lt;/code&gt; 를 삽입 하여 기존 div를 닫고 새 div를 열 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf59184c506e87f22cd7c9a7c19cf83ce4599ecd" translate="yes" xml:space="preserve">
          <source>The issue with this schema is that due to the DDP behavior just mentioned, each change to &lt;em&gt;any&lt;/em&gt; todo item in a list will require sending the &lt;em&gt;entire&lt;/em&gt; set of todos for that list over the network. This is because DDP has no concept of &amp;ldquo;change the &lt;code&gt;text&lt;/code&gt; field of the 3rd item in the field called &lt;code&gt;todos&lt;/code&gt;&amp;ldquo;, simply &amp;ldquo;change the field called &lt;code&gt;todos&lt;/code&gt; to a totally new array&amp;rdquo;.</source>
          <target state="translated">이 스키마의 문제는 방금 언급 한 DDP 동작으로 인해 목록의 &lt;em&gt;모든 할&lt;/em&gt; 일 항목을 변경할 때마다 해당 목록에 대한 &lt;em&gt;전체&lt;/em&gt; 할 일 모음을 네트워크를 통해 보내야한다는 것 입니다. 이 DDP가의 개념이 없기 때문에 &quot;변경 인 &lt;code&gt;text&lt;/code&gt; 필드라고에 3 항목의 필드를 &lt;code&gt;todos&lt;/code&gt; 간단하게&quot;라는 필드 변경 &quot; &lt;code&gt;todos&lt;/code&gt; 완전히 새로운 배열에&quot;.</target>
        </trans-unit>
        <trans-unit id="cc3dcc2b6eba9612cc0ca947cb6f916d99764552" translate="yes" xml:space="preserve">
          <source>The key to set, eg, &lt;code&gt;selectedItem&lt;/code&gt;</source>
          <target state="translated">설정하는 키, 예를 들어 &lt;code&gt;selectedItem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf355afc6c3e8f73ec33c2201c210bc589768e4f" translate="yes" xml:space="preserve">
          <source>The last command creates a &lt;code&gt;package.json&lt;/code&gt; file and prompts you for the package information. You may skip everything but &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt;, and &lt;code&gt;entry point&lt;/code&gt;. You can use the default &lt;code&gt;index.js&lt;/code&gt; for &lt;code&gt;entry point&lt;/code&gt;. This file is where you set your package&amp;rsquo;s exports:</source>
          <target state="translated">마지막 명령은 &lt;code&gt;package.json&lt;/code&gt; 파일을 작성 하고 패키지 정보를 묻는 프롬프트를 표시합니다. &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;version&lt;/code&gt; 및 &lt;code&gt;entry point&lt;/code&gt; 제외한 모든 것을 건너 뛸 수 있습니다 . &lt;code&gt;entry point&lt;/code&gt; 기본 &lt;code&gt;index.js&lt;/code&gt; 를 사용할 수 있습니다 . 이 파일은 패키지 내보내기를 설정하는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="58ecbf3dede503a58bde3e045a3df89887a049a3" translate="yes" xml:space="preserve">
          <source>The last form will only work if your JavaScript implementation preserves the order of keys in objects. Most do, most of the time, but it&amp;rsquo;s up to you to be sure.</source>
          <target state="translated">마지막 양식은 JavaScript 구현이 객체의 키 순서를 유지하는 경우에만 작동합니다. 대부분의 경우 대부분의 시간을 할애하지만 확실하게 귀하에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="62face76ea24a25e14ec88678cac33ee4e338c66" translate="yes" xml:space="preserve">
          <source>The last node of the View&amp;rsquo;s rendered content.</source>
          <target state="translated">뷰의 렌더링 된 컨텐츠의 마지막 노드입니다.</target>
        </trans-unit>
        <trans-unit id="27a18372e353012f1d14dab0863f5525adbb9bb5" translate="yes" xml:space="preserve">
          <source>The last top-level DOM node in this template instance.</source>
          <target state="translated">이 템플릿 인스턴스의 마지막 최상위 DOM 노드.</target>
        </trans-unit>
        <trans-unit id="02279ad83eb1b692260d7d9cde7b2b5d2ae56e80" translate="yes" xml:space="preserve">
          <source>The main Atmosphere website provides additional curation features like trending packages, package stars, and flags, but some of the other options can be faster if you&amp;rsquo;re trying to find a specific package. For example, you can use &lt;code&gt;meteor show kadira:flow-router&lt;/code&gt; from the command line to see the description of that package and different available versions.</source>
          <target state="translated">기본 Atmosphere 웹 사이트는 트렌드 패키지, 패키지 스타 및 플래그와 같은 추가 큐 레이션 기능을 제공하지만 특정 패키지를 찾으려면 다른 옵션 중 일부가 더 빠를 수 있습니다. 예를 들어 명령 줄에서 &lt;code&gt;meteor show kadira:flow-router&lt;/code&gt; 를 사용하여 해당 패키지 및 사용 가능한 다른 버전에 대한 설명을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad940316714a3ab0e6572294a28c9b8ae5f1015" translate="yes" xml:space="preserve">
          <source>The main advantage of this approach is that it is immediately clear when viewing the &lt;code&gt;Lists_show_page&lt;/code&gt; what behavior will occur when a user visits the page.</source>
          <target state="translated">이 방법의 주요 장점은 &lt;code&gt;Lists_show_page&lt;/code&gt; 를 볼 때 사용자가 페이지를 방문 할 때 어떤 동작이 발생하는지 즉시 알 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="087cec891935cf1e492b59ed52df2b8bf65da3fe" translate="yes" xml:space="preserve">
          <source>The main function of an Atmosphere package is to contain source code (JS, CSS, and any transpiled languages) and assets (images, fonts, and more) that will be shared across different applications.</source>
          <target state="translated">Atmosphere 패키지의 주요 기능은 소스 코드 (JS, CSS 및 변환 된 언어)와 다른 응용 프로그램간에 공유 될 자산 (이미지, 글꼴 등)을 포함하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac594fc5f09adad9be18a02fcebc34665789af54" translate="yes" xml:space="preserve">
          <source>The main function of the Meteor build tool is to run &amp;ldquo;build plugins&amp;rdquo;. These plugins define different parts of your app build process. Meteor puts heavy emphasis on reducing or removing build configuration files, so you won&amp;rsquo;t see any large build process config files like you would in Gulp or Webpack. The Meteor build process, and &lt;a href=&quot;structure#load-order&quot;&gt;file load order&lt;/a&gt;, is configured almost entirely through adding and removing packages to your app and putting files in specially named directories. For example, to get all of the newest stable ES2015 JavaScript features in your app, you just add the &lt;a href=&quot;http://docs.meteor.com/#/full/ecmascript&quot;&gt;&lt;code&gt;ecmascript&lt;/code&gt; package&lt;/a&gt;. This package provides support for ES2015 modules, which gives you even more fine grained control over file load order using ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;. As new Meteor releases add new features to this package you just get them for free.</source>
          <target state="translated">Meteor 빌드 도구의 주요 기능은 &quot;빌드 플러그인&quot;을 실행하는 것입니다. 이 플러그인은 앱 빌드 프로세스의 다른 부분을 정의합니다. Meteor는 빌드 구성 파일을 줄이거 나 제거하는 데 중점을 두므로 Gulp 또는 Webpack에서와 같이 큰 빌드 프로세스 구성 파일이 표시되지 않습니다. Meteor 빌드 프로세스 및 &lt;a href=&quot;structure#load-order&quot;&gt;파일로드 순서&lt;/a&gt; 는 거의 완전히 앱에 패키지를 추가 및 제거하고 파일을 특별히 명명 된 디렉토리에 배치하여 구성됩니다. 예를 들어 앱에서 최신의 안정적인 ES2015 JavaScript 기능을 모두 얻으려면 &lt;a href=&quot;http://docs.meteor.com/#/full/ecmascript&quot;&gt; &lt;code&gt;ecmascript&lt;/code&gt; 패키지&lt;/a&gt; 만 추가하면 됩니다 . 이 패키지는 ES2015 사용하면 파일로드 순서를 통해보다 세밀하게 제어 할 수있는 ES2015 모듈에 대한 지원을 제공 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; . 새로운 Meteor 릴리스가이 패키지에 새로운 기능을 추가함에 따라 무료로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9030d33310ed67928fe084c9847e6d27b43c18fe" translate="yes" xml:space="preserve">
          <source>The main thing enabled by the &lt;code&gt;ValidationError&lt;/code&gt; convention is simple integration between Methods and the forms that call them. In general, your app is likely to have a one-to-one mapping of forms in the UI to Methods. First, let&amp;rsquo;s define a Method for our business logic:</source>
          <target state="translated">&lt;code&gt;ValidationError&lt;/code&gt; 규칙에 의해 가능한 주요한 것은 메소드와 메소드를 호출하는 양식 사이의 간단한 통합입니다. 일반적으로 앱은 UI의 양식을 메소드에 일대일로 매핑 할 가능성이 높습니다. 먼저 비즈니스 로직을위한 방법을 정의 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c67aa737041c3f3797cf0aa256ed25cba5132582" translate="yes" xml:space="preserve">
          <source>The main thing to understand about how Blaze re-renders is that re-rendering happens at the level of helpers and template inclusions. Whenever the &lt;em&gt;data context&lt;/em&gt; of a component changes, it necessarily must re-run &lt;em&gt;all&lt;/em&gt; helpers and data accessors (as &lt;code&gt;this&lt;/code&gt; within the helper is the data context and thus will have changed).</source>
          <target state="translated">Blaze가 다시 렌더링하는 방법에 대해 이해해야 할 주요 사항은 다시 렌더링이 도우미 및 템플릿 포함 수준에서 발생한다는 것입니다. 때마다 &lt;em&gt;데이터 컨텍스트&lt;/em&gt; 구성 요소의 변경, 그것은 반드시 다시 실행해야합니다 &lt;em&gt;모든&lt;/em&gt; 헬퍼 및 데이터 접근을 (같이 &lt;code&gt;this&lt;/code&gt; 도우미 내에서 데이터 컨텍스트이며, 따라서 변경됩니다).</target>
        </trans-unit>
        <trans-unit id="05dafcc9b089b13ad60b26fd4f9f8201fac9c7c9" translate="yes" xml:space="preserve">
          <source>The mental model here is:</source>
          <target state="translated">여기서 정신 모델은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="9fe40d9ebf86fd4ddce617c1b48fd4df787dd561" translate="yes" xml:space="preserve">
          <source>The method of generating the &lt;code&gt;_id&lt;/code&gt; fields of new documents in this collection. Possible values:</source>
          <target state="translated">이 컬렉션에서 새 문서 의 &lt;code&gt;_id&lt;/code&gt; 필드 를 생성하는 방법입니다 . 가능한 값 :</target>
        </trans-unit>
        <trans-unit id="4fd01fd0a1b0b9f41b2613c6143a80de785d255a" translate="yes" xml:space="preserve">
          <source>The minifier class must implement the method &lt;code&gt;processFilesForBundle&lt;/code&gt;. The first argument is a list of processed files and the options object specifies if the minifier is ran in production mode or development mode.</source>
          <target state="translated">축소 기 클래스는 &lt;code&gt;processFilesForBundle&lt;/code&gt; 메소드를 구현해야합니다 . 첫 번째 인수는 처리 된 파일의 목록이며 옵션 오브젝트는 축소 기가 프로덕션 모드 또는 개발 모드에서 실행되는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6a944b35af3e4fbd8d5302f9527e421b0768f5c0" translate="yes" xml:space="preserve">
          <source>The most advanced mobile web framework is &lt;a href=&quot;http://ionicframework.com/docs/v2/&quot;&gt;Ionic 2&lt;/a&gt;, which uses Angular 2.</source>
          <target state="translated">가장 발전된 모바일 웹 프레임 워크는 Angular 2를 사용하는 &lt;a href=&quot;http://ionicframework.com/docs/v2/&quot;&gt;Ionic&lt;/a&gt; 2입니다.</target>
        </trans-unit>
        <trans-unit id="9115d281d003ae224fc86b9fcc1cba5320c86e60" translate="yes" xml:space="preserve">
          <source>The most advanced mobile web framework is &lt;a href=&quot;https://ionicframework.com/docs/v2/&quot;&gt;Ionic 2&lt;/a&gt;, which uses Angular 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2d88cbe5690b733be86f60121bc107d1acb1dd" translate="yes" xml:space="preserve">
          <source>The most important consideration is related to the way DDP, Meteor&amp;rsquo;s data loading protocol, communicates documents over the wire. The key thing to realize is that DDP sends changes to documents at the level of top-level document &lt;em&gt;fields&lt;/em&gt;. What this means is that if you have large and complex subfields on document that change often, DDP can send unnecessary changes over the wire.</source>
          <target state="translated">가장 중요한 고려 사항은 Meteor의 데이터 로딩 프로토콜 인 DDP가 유선으로 문서를 통신하는 방식과 관련이 있습니다. 알아야 할 핵심 사항은 DDP가 최상위 문서 &lt;em&gt;필드&lt;/em&gt; 수준에서 문서에 변경 사항을 전송한다는 것입니다 . 이것이 의미하는 바는 문서에서 자주 변경되는 크고 복잡한 서브 필드가있는 경우 DDP가 와이어를 통해 불필요한 변경을 보낼 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="041bbfac67b8faad4b90349044927ca9c48e25c4" translate="yes" xml:space="preserve">
          <source>The most important thing to keep in mind is that user documents are certain to contain private data about your users. In particular, the user document includes hashed password data and access keys for external APIs. This means it&amp;rsquo;s critically important to &lt;a href=&quot;http://guide.meteor.com/security.html#fields&quot;&gt;filter the fields&lt;/a&gt; of the user document that you send to any client.</source>
          <target state="translated">명심해야 할 가장 중요한 것은 사용자 문서에는 사용자에 대한 개인 데이터가 포함되어 있어야한다는 것입니다. 특히, 사용자 문서에는 해시 된 비밀번호 데이터 및 외부 API에 대한 액세스 키가 포함됩니다. 즉, 클라이언트에게 보내는 사용자 문서 &lt;a href=&quot;http://guide.meteor.com/security.html#fields&quot;&gt;의 필드&lt;/a&gt; 를 필터링하는 것이 매우 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="29635c76fe31daf9bef9734f9375360e554deb6e" translate="yes" xml:space="preserve">
          <source>The most popular CSS post-processor right now is &lt;a href=&quot;https://github.com/postcss/postcss&quot;&gt;PostCSS&lt;/a&gt;, which supports a variety of plugins. &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;Autoprefixer&lt;/a&gt; is perhaps the most useful plugin, since it enables you to stop worrying about browser prefixes and compatibility and write standards-compliant CSS. No more copying 5 different statements every time you want a CSS gradient - you can just write a standard gradient without any prefixes and Autoprefixer handles it for you.</source>
          <target state="translated">현재 가장 널리 사용되는 CSS 포스트 프로세서 는 다양한 플러그인을 지원하는 &lt;a href=&quot;https://github.com/postcss/postcss&quot;&gt;PostCSS&lt;/a&gt; 입니다. &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;Autoprefixer&lt;/a&gt; 는 아마도 가장 유용한 플러그인 일 것입니다. 브라우저 접두사와 호환성에 대한 걱정을 멈추고 표준 호환 CSS를 작성할 수 있기 때문입니다. CSS 그라디언트를 원할 때마다 더 이상 5 개의 다른 문장을 복사 할 필요가 없습니다. 접두사없이 표준 그라디언트를 작성하기 만하면 Autoprefixer가 처리합니다.</target>
        </trans-unit>
        <trans-unit id="41100d8581602da5152d964141f9e1cb7c4ee177" translate="yes" xml:space="preserve">
          <source>The most popular package for role-based permissions in Meteor is &lt;a href=&quot;https://atmospherejs.com/alanning/roles&quot;&gt;&lt;code&gt;alanning:roles&lt;/code&gt;&lt;/a&gt;. For example, here is how you would make a user into an administrator, or a moderator:</source>
          <target state="translated">Meteor에서 역할 기반 권한에 가장 많이 사용되는 패키지는 &lt;a href=&quot;https://atmospherejs.com/alanning/roles&quot;&gt; &lt;code&gt;alanning:roles&lt;/code&gt; &lt;/a&gt; 입니다. 예를 들어, 다음은 사용자를 관리자 또는 중재자로 만드는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="33f95663bdb44f0e22fe580aa85febeeebebb1f8" translate="yes" xml:space="preserve">
          <source>The most powerful feature of Meteor&amp;rsquo;s build system is the ability to define custom build plugins. If you find yourself writing scripts that mangle one type of file into another, merge multiple files, or something else, it&amp;rsquo;s likely that these scripts would be better implemented as a build plugin. The &lt;code&gt;ecmascript&lt;/code&gt;, &lt;code&gt;templating&lt;/code&gt;, and &lt;code&gt;coffeescript&lt;/code&gt; packages are all implemented as build plugins, so you can replace them with your own versions if you want to!</source>
          <target state="translated">Meteor 빌드 시스템의 가장 강력한 기능은 사용자 정의 빌드 플러그인을 정의하는 기능입니다. 한 유형의 파일을 다른 유형의 파일로 엉망으로 만드는 여러 개의 파일을 병합하는 스크립트를 작성하는 경우 이러한 스크립트가 빌드 플러그인으로 더 잘 구현 될 수 있습니다. &lt;code&gt;ecmascript&lt;/code&gt; , &lt;code&gt;templating&lt;/code&gt; 및 &lt;code&gt;coffeescript&lt;/code&gt; 당신이 원하는 경우에 당신이 당신의 자신의 버전으로 교체 할 수 있도록 패키지는 모두 빌드 플러그인으로 구현됩니다!</target>
        </trans-unit>
        <trans-unit id="1ee41d922eff780ecaff3ef99605a3b9119cf5c7" translate="yes" xml:space="preserve">
          <source>The mouse button is newly down or up.</source>
          <target state="translated">마우스 버튼이 새로 눌렸거나 위입니다.</target>
        </trans-unit>
        <trans-unit id="8fbb5613850e679b2f68299f9baa31ac98b9b2ef" translate="yes" xml:space="preserve">
          <source>The name of the Meteor method being used to login.</source>
          <target state="translated">로그인에 사용되는 Meteor 메소드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b8becb5b6c6f747f4f4fcec5d5ba0b95c3d5d6c" translate="yes" xml:space="preserve">
          <source>The name of the collection that contains the changed document.</source>
          <target state="translated">변경된 문서가 포함 된 컬렉션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a110db700050ed25131d869b59bbbee4b90483fa" translate="yes" xml:space="preserve">
          <source>The name of the collection that contains the new document.</source>
          <target state="translated">새 문서가 포함 된 컬렉션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="12890a4496f8bd405aef15e465058d6e53f8670c" translate="yes" xml:space="preserve">
          <source>The name of the collection that the document has been removed from.</source>
          <target state="translated">문서가 제거 된 콜렉션의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="aededf02ab8585133ad16566be90bc597b461caa" translate="yes" xml:space="preserve">
          <source>The name of the collection. If null, creates an unmanaged (unsynchronized) local collection.</source>
          <target state="translated">컬렉션의 이름입니다. null의 경우, 관리되지 않는 (동기화되지 않은) 로컬 컬렉션을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cee22e1cf3b1b10904d1573dfc4e5f31b03e98e4" translate="yes" xml:space="preserve">
          <source>The name of the helper function you are defining.</source>
          <target state="translated">정의하고있는 도우미 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3cefe07ca40ac0098c2ecef7ab586bdb550e6c49" translate="yes" xml:space="preserve">
          <source>The name of the package to require.</source>
          <target state="translated">필요한 패키지 이름입니다.</target>
        </trans-unit>
        <trans-unit id="920ff863539ce75133ab803119feacd0042e2282" translate="yes" xml:space="preserve">
          <source>The name of the session variable to return</source>
          <target state="translated">리턴 할 세션 변수의 이름</target>
        </trans-unit>
        <trans-unit id="5172527e74ca00b58bba7ad9c1f71a91e09af72f" translate="yes" xml:space="preserve">
          <source>The name of the session variable to test</source>
          <target state="translated">테스트 할 세션 변수의 이름</target>
        </trans-unit>
        <trans-unit id="a06673519c2a8a449084e67603a463a768ba9138" translate="yes" xml:space="preserve">
          <source>The name of the template to include.</source>
          <target state="translated">포함 할 템플릿의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="176d65e18cc7bf7c5ed547ad17c8014fd2faa317" translate="yes" xml:space="preserve">
          <source>The name of this type of View. View names may be used to identify particular kinds of Views in code, but more often they simply aid in debugging and comprehensibility of the View tree. Views generated by Meteor have names like &amp;ldquo;Template.foo&amp;rdquo; and &amp;ldquo;if&amp;rdquo;.</source>
          <target state="translated">이 유형의보기 이름입니다. 뷰 이름은 코드에서 특정 종류의 뷰를 식별하는 데 사용될 수 있지만 더 자주 뷰 트리의 디버깅 및 이해를 돕는 데 도움이됩니다. Meteor에 의해 생성 된 뷰는&amp;ldquo;Template.foo&amp;rdquo;및&amp;ldquo;if&amp;rdquo;와 같은 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5ead238c6d0a0b1e2991bbc9d03dff84ecb261c1" translate="yes" xml:space="preserve">
          <source>The new document's ID.</source>
          <target state="translated">새 문서의 ID</target>
        </trans-unit>
        <trans-unit id="f640c1c0168d245bf62dac0b58ef4a4ea14d0f23" translate="yes" xml:space="preserve">
          <source>The new value for &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 의 새로운 가치</target>
        </trans-unit>
        <trans-unit id="5683e458ca2c49f3ed860b926a3f0940a626811a" translate="yes" xml:space="preserve">
          <source>The newer variant of &lt;code&gt;#each&lt;/code&gt; doesn&amp;rsquo;t change the data context but introduces a new variable that can be used in the body to refer to the current item:</source>
          <target state="translated">&lt;code&gt;#each&lt;/code&gt; 의 최신 변형은 데이터 컨텍스트를 변경하지 않지만 본문에서 현재 항목을 참조하는 데 사용할 수있는 새로운 변수를 도입합니다.</target>
        </trans-unit>
        <trans-unit id="0f6934cd801fccda166cd1d81a676851c4932e22" translate="yes" xml:space="preserve">
          <source>The node that will be the parent of the rendered template. It must be an Element node.</source>
          <target state="translated">렌더링 된 템플릿의 부모가 될 노드입니다. 요소 노드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6720aec8906bdb559b3f17f4d0beb9f284062970" translate="yes" xml:space="preserve">
          <source>The number of bytes of binary data to allocate.</source>
          <target state="translated">할당 할 이진 데이터의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="dba728d279234fa11e3c96752fea811c330fc820" translate="yes" xml:space="preserve">
          <source>The number of days from when a link to reset password is sent until token expires and user can't reset password with the link anymore. Defaults to 3.</source>
          <target state="translated">비밀번호 재설정 링크가 전송되고 토큰이 만료되고 사용자가 더 이상 링크를 사용하여 비밀번호를 재설정 할 수 없을 때까지의 일 수입니다. 기본값은 3입니다.</target>
        </trans-unit>
        <trans-unit id="fbf37e56e9df9c710871811ee1641a93403770db" translate="yes" xml:space="preserve">
          <source>The number of days from when a link to set inital password is sent until token expires and user can't set password with the link anymore. Defaults to 30.</source>
          <target state="translated">초기 비밀번호를 설정하기위한 링크가 전송되고 토큰이 만료되고 사용자가 더 이상 링크를 사용하여 비밀번호를 설정할 수 없을 때까지의 일 수입니다. 기본값은 30입니다.</target>
        </trans-unit>
        <trans-unit id="8dfaa8ca88d40642840c1c14b552a064b807998e" translate="yes" xml:space="preserve">
          <source>The number of days from when a user logs in until their token expires and they are logged out. Defaults to 90. Set to &lt;code&gt;null&lt;/code&gt; to disable login expiration.</source>
          <target state="translated">사용자가 로그인 한 후 토큰이 만료되어 로그 아웃 될 때까지의 일 수입니다. 로그인 만료를 비활성화 하려면 &lt;code&gt;null&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ea882e6e592495d4f1fdf5bb546bcff8a2a280da" translate="yes" xml:space="preserve">
          <source>The number of levels beyond the current data context to look. Defaults to 1.</source>
          <target state="translated">현재 데이터 컨텍스트를 넘어서는 수준의 수입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="ae4898ef734061446e0764ca241fb8bb5c700814" translate="yes" xml:space="preserve">
          <source>The number of times the View has been rendered, including the current time if the View is in the process of being rendered or re-rendered.</source>
          <target state="translated">보기가 렌더링되거나 다시 렌더링되는 현재 시간을 포함하여보기가 렌더링 된 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="abcbf76bd08ffde7566c6e27b725b9d0896f531e" translate="yes" xml:space="preserve">
          <source>The number of times the client has tried to reconnect since the connection was lost. 0 when connected.</source>
          <target state="translated">연결이 끊어진 후 클라이언트가 다시 연결을 시도한 횟수입니다. 연결되면 0입니다.</target>
        </trans-unit>
        <trans-unit id="fa479a8e3972469522ab5d930e7d1250954d3cb0" translate="yes" xml:space="preserve">
          <source>The observer fetches the current set of documents matching the cursor, and passes them back to the subscription (via the &lt;code&gt;this.added()&lt;/code&gt; callback).</source>
          <target state="translated">관찰자는 커서와 일치하는 현재 문서 세트를 가져 와서 &lt;code&gt;this.added()&lt;/code&gt; 콜백을 통해 구독으로 다시 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="53c688a2194b2f27c34a7591e8d0eaa760d0d64a" translate="yes" xml:space="preserve">
          <source>The observer observes the query. Typically, it &lt;a href=&quot;https://github.com/meteor/meteor/wiki/Oplog-Observe-Driver&quot;&gt;uses MongoDB&amp;rsquo;s Oplog&lt;/a&gt; to notice changes that affect the query. If it sees a relevant change, like a new matching document or a change in a field on a matching document, it calls into the subscription (via &lt;code&gt;.added()&lt;/code&gt;, &lt;code&gt;.changed()&lt;/code&gt; or &lt;code&gt;.removed()&lt;/code&gt;), which again sends the changes to the mergebox, and then to the client via DDP.</source>
          <target state="translated">관찰자는 쿼리를 관찰합니다. 일반적으로 &lt;a href=&quot;https://github.com/meteor/meteor/wiki/Oplog-Observe-Driver&quot;&gt;MongoDB의 Oplog&lt;/a&gt; 를 사용 하여 쿼리에 영향을주는 변경 사항을 확인합니다. 일치하는 새 문서 또는 일치하는 문서의 필드 변경과 같은 관련 변경이 있으면 구독을 호출합니다 ( &lt;code&gt;.added()&lt;/code&gt; , &lt;code&gt;.changed()&lt;/code&gt; 또는 &lt;code&gt;.removed()&lt;/code&gt; ). 병합 상자로 변경 한 다음 DDP를 통해 클라이언트로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="a30a5dd8e1c97f27469429c022c3fb3c77e8af44" translate="yes" xml:space="preserve">
          <source>The only reason not to use &lt;code&gt;{{#each .. in}}&lt;/code&gt; would be because it makes it difficult to access the &lt;code&gt;todo&lt;/code&gt; symbol inside event handlers. Typically the solution to this is to use a sub-component to render the inside of the loop:</source>
          <target state="translated">&lt;code&gt;{{#each .. in}}&lt;/code&gt; 을 사용하지 않는 유일한 이유 는 이벤트 핸들러 내 에서 할 &lt;code&gt;todo&lt;/code&gt; 기호 에 액세스하기 어렵 기 때문 입니다. 일반적으로 이것에 대한 해결책은 하위 구성 요소를 사용하여 루프 내부를 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9db3a42ebc5acbaa53c1172351d4309de2d80567" translate="yes" xml:space="preserve">
          <source>The opposite scenario occurs when you want to publish data to be consumed by a 3rd party, typically over REST. If the data we want to publish is the same as what we already publish via a publication, then we can use the &lt;a href=&quot;https://atmospherejs.com/simple/rest&quot;&gt;simple:rest&lt;/a&gt; package to do this really easily.</source>
          <target state="translated">반대 시나리오는 일반적으로 REST를 통해 써드 파티가 소비 할 데이터를 공개하려고 할 때 발생합니다. 게시하려는 데이터가 게시를 통해 이미 게시 한 데이터와 동일한 경우 &lt;a href=&quot;https://atmospherejs.com/simple/rest&quot;&gt;simple : rest&lt;/a&gt; 패키지를 사용하여이 작업을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde54f116d99f5d06808179c05f7ba6f1e4e9bf" translate="yes" xml:space="preserve">
          <source>The page is reloaded and the web view re-requests the assets from the local web server</source>
          <target state="translated">페이지가 다시로드되고 웹보기가 로컬 웹 서버에서 자산을 다시 요청합니다.</target>
        </trans-unit>
        <trans-unit id="80cd78cf234184e72a37dc201f7f4bfe9d15c435" translate="yes" xml:space="preserve">
          <source>The path of the asset, relative to the application's &lt;code&gt;private&lt;/code&gt; subdirectory.</source>
          <target state="translated">애플리케이션의 &lt;code&gt;private&lt;/code&gt; 서브 디렉토리 와 관련된 자산의 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="521a81640f8ab9eac4784c022ded2d4326c35d63" translate="yes" xml:space="preserve">
          <source>The pattern defining affected domains or URLs.</source>
          <target state="translated">영향을받는 도메인 또는 URL을 정의하는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="1bb24703e108f8284fd72e3479806a47df145761" translate="yes" xml:space="preserve">
          <source>The pattern to match &lt;code&gt;value&lt;/code&gt; against</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 과 일치하는 패턴</target>
        </trans-unit>
        <trans-unit id="a49d39bb128771a179d0edca97783db6bfdd1f6c" translate="yes" xml:space="preserve">
          <source>The place to get started with Meteor is the &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/creating-an-app&quot;&gt;official tutorial&lt;/a&gt;.</source>
          <target state="translated">Meteor를 시작하는 장소는 &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/creating-an-app&quot;&gt;공식 튜토리얼&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="556bd230d169ee45ecc4f1fc92dc61ae62f450a8" translate="yes" xml:space="preserve">
          <source>The pointer enters or leaves the bounds of an element. These events do not bubble.</source>
          <target state="translated">포인터는 요소의 경계에 들어가거나 떠납니다. 이 사건은 거품이 없습니다.</target>
        </trans-unit>
        <trans-unit id="12b9ea0078874b778b28fde7c6f18922178d5a9e" translate="yes" xml:space="preserve">
          <source>The primary challenge is properly sharing code between the different applications you are building. The simplest approach to deal with this issue is to simply deploy the &lt;em&gt;same&lt;/em&gt; application on different web servers, controlling the behavior via different &lt;a href=&quot;deployment#environment&quot;&gt;settings&lt;/a&gt;. This approach allows you to easily deploy different versions with different scaling behavior but doesn&amp;rsquo;t enjoy most of the other advantages stated above.</source>
          <target state="translated">가장 큰 과제는 구축중인 여러 응용 프로그램간에 코드를 올바르게 공유하는 것입니다. 이 문제를 해결하는 가장 간단한 방법은 다른 웹 서버에 &lt;em&gt;동일한&lt;/em&gt; 응용 프로그램을 배포하여 다른 &lt;a href=&quot;deployment#environment&quot;&gt;설정을&lt;/a&gt; 통해 동작을 제어하는 ​​것 입니다. 이 접근 방식을 사용하면 다른 확장 동작으로 다른 버전을 쉽게 배포 할 수 있지만 위에서 언급 한 다른 이점은 대부분 누리지 못합니다.</target>
        </trans-unit>
        <trans-unit id="51b06a1c4c72e4d0ba519e2db4fda58b6aa5f310" translate="yes" xml:space="preserve">
          <source>The primary way to test your application in Meteor is the &lt;code&gt;meteor test&lt;/code&gt; command.</source>
          <target state="translated">Meteor에서 애플리케이션을 테스트하는 기본 방법은 &lt;code&gt;meteor test&lt;/code&gt; 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2f82a21783db5564684bce916eecdb8fff7a0fe6" translate="yes" xml:space="preserve">
          <source>The problem with this mechanism is that it overrides complete files, so it is not a good solution for customizing &lt;code&gt;config.xml&lt;/code&gt;. Replacing the generated version with your own file means you lose all configuration information set by the build process and by installed plugins, which will likely break your app.</source>
          <target state="translated">이 메커니즘의 문제점은 완전한 파일을 대체하므로 &lt;code&gt;config.xml&lt;/code&gt; 사용자 정의를위한 좋은 솔루션이 아니라는 것입니다 . 생성 된 버전을 자신의 파일로 바꾸면 빌드 프로세스 및 설치된 플러그인에서 설정 한 모든 구성 정보가 손실되어 앱이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc08b261ed5c2929402efaa830642474a0ba56e" translate="yes" xml:space="preserve">
          <source>The publication calls the &lt;code&gt;.ready()&lt;/code&gt; callback, which sends the DDP &lt;code&gt;ready&lt;/code&gt; message to the client. The subscription handle on the client is marked as ready.</source>
          <target state="translated">게시는 &lt;code&gt;.ready()&lt;/code&gt; 콜백을 호출 하여 클라이언트에 DDP &lt;code&gt;ready&lt;/code&gt; 메시지를 보냅니다 . 클라이언트의 구독 핸들이 준비 됨으로 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a8d0ec773fc1b82243adbf0c7b6d3bba0abed5" translate="yes" xml:space="preserve">
          <source>The publication handler identifies that the return value is a cursor. This enables a convenient mode for publishing cursors.</source>
          <target state="translated">공개 핸들러는 리턴 값이 커서임을 식별합니다. 커서를 게시하기위한 편리한 모드를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c51dcc1727b3af5900a6cc6c56c706886097ed5b" translate="yes" xml:space="preserve">
          <source>The reactive data source &lt;em&gt;invalidates&lt;/em&gt; the autorun computation (marks it so that it re-runs in the next Tracker flush cycle).</source>
          <target state="translated">반응 데이터 소스 는 자동 실행 계산을 &lt;em&gt;무효화&lt;/em&gt; 합니다 (다음 트래커 플러시 사이클에서 다시 실행되도록 표시).</target>
        </trans-unit>
        <trans-unit id="309d6f42b267e108ba41490cedacb95ce33b8a65" translate="yes" xml:space="preserve">
          <source>The reason Dependencies do not store data themselves is that it can be useful to associate multiple Dependencies with the same piece of data. For example, one Dependency might represent the result of a database query, while another might represent just the number of documents in the result. A Dependency could represent whether the weather is sunny or not, or whether the temperature is above freezing. &lt;a href=&quot;#session_equals&quot;&gt;&lt;code&gt;Session.equals&lt;/code&gt;&lt;/a&gt; is implemented this way for efficiency. When you call &lt;code&gt;Session.equals('weather', 'sunny')&lt;/code&gt;, the current computation is made to depend on an internal Dependency that does not change if the weather goes from, say, &lt;code&gt;rainy&lt;/code&gt; to &lt;code&gt;cloudy&lt;/code&gt;.</source>
          <target state="translated">종속성이 데이터 자체를 저장하지 않는 이유는 여러 종속성을 동일한 데이터 조각과 연관시키는 것이 유용 할 수 있기 때문입니다. 예를 들어, 하나의 종속성은 데이터베이스 쿼리 결과를 나타내고 다른 하나는 결과의 문서 수를 나타낼 수 있습니다. 종속성은 날씨가 맑은 지 또는 온도가 얼어 있는지를 나타낼 수 있습니다. &lt;a href=&quot;#session_equals&quot;&gt; &lt;code&gt;Session.equals&lt;/code&gt; &lt;/a&gt; 는 효율성을 위해이 방법으로 구현됩니다. 당신이 호출 할 때 &lt;code&gt;Session.equals('weather', 'sunny')&lt;/code&gt; , 현재의 계산은 날씨가, 말에서가는 경우 변경되지 않는 내부 종속성에 의존한다 &lt;code&gt;rainy&lt;/code&gt; 에 &lt;code&gt;cloudy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c001cca251f1269a800c30cf115f1757697ea195" translate="yes" xml:space="preserve">
          <source>The reason this is needed is because updates delivered through hot code push replace the initially bundled &lt;code&gt;index.html&lt;/code&gt; with a freshly generated one. If the &lt;code&gt;ROOT_URL&lt;/code&gt; on your server hasn&amp;rsquo;t been set, it defaults to &lt;code&gt;localhost:3000&lt;/code&gt;, and this would leave the app unable to connect to the server, both for data loading and for receiving further hot code pushes. In Meteor 1.3, we protect against this by blocking updates that would change the &lt;code&gt;ROOT_URL&lt;/code&gt; to &lt;code&gt;localhost&lt;/code&gt;, but the consequence of this is that hot code push is disabled until you configure &lt;code&gt;ROOT_URL&lt;/code&gt; correctly.</source>
          <target state="translated">이것이 필요한 이유는 핫 코드 푸시를 통해 제공되는 업데이트가 처음에 번들로 제공되는 &lt;code&gt;index.html&lt;/code&gt; 을 새로 생성 된 것으로 대체하기 때문 입니다. 서버 에서 &lt;code&gt;ROOT_URL&lt;/code&gt; 을 설정하지 않은 경우 기본적으로 &lt;code&gt;localhost:3000&lt;/code&gt; 으로 설정 되어 데이터로드 및 추가 핫 코드 푸시 수신을 위해 앱을 서버에 연결할 수 없습니다. Meteor 1.3에서는 &lt;code&gt;ROOT_URL&lt;/code&gt; 을 &lt;code&gt;localhost&lt;/code&gt; 로 변경하는 업데이트를 차단하여이 문제를 방지 하지만 그 결과 &lt;code&gt;ROOT_URL&lt;/code&gt; 을 올바르게 구성 할 때까지 핫 코드 푸시가 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea4ad2f495ec6f870bb27648ac9cfca44b40af11" translate="yes" xml:space="preserve">
          <source>The rendered template will update reactively in response to data changes until the View is removed using &lt;a href=&quot;#Blaze-remove&quot;&gt;&lt;code&gt;Blaze.remove&lt;/code&gt;&lt;/a&gt; or the View&amp;rsquo;s parent element is removed by Meteor or jQuery.</source>
          <target state="translated">&lt;a href=&quot;#Blaze-remove&quot;&gt; &lt;code&gt;Blaze.remove&lt;/code&gt; 를&lt;/a&gt; 사용하여 View를 제거 하거나 Meteor 또는 jQuery로 View의 상위 요소를 제거 할 때까지 데이터 변경에 대한 응답으로 렌더링 된 템플릿이 반응 적으로 업데이트 됩니다.</target>
        </trans-unit>
        <trans-unit id="346fb3496c3ed7d82e3d8d06285355dda446588d" translate="yes" xml:space="preserve">
          <source>The return value from &lt;code&gt;Blaze.render&lt;/code&gt; or &lt;code&gt;Blaze.renderWithData&lt;/code&gt;, or the &lt;code&gt;view&lt;/code&gt; property of a Blaze.Template instance. Calling &lt;code&gt;Blaze.remove(Template.instance().view)&lt;/code&gt; from within a template event handler will destroy the view as well as that template and trigger the template's &lt;code&gt;onDestroyed&lt;/code&gt; handlers.</source>
          <target state="translated">&lt;code&gt;Blaze.render&lt;/code&gt; 또는 &lt;code&gt;Blaze.renderWithData&lt;/code&gt; 의 반환 값 또는 Blaze.Template 인스턴스 의 &lt;code&gt;view&lt;/code&gt; 속성입니다. 템플릿 이벤트 처리기 내에서 &lt;code&gt;Blaze.remove(Template.instance().view)&lt;/code&gt; 를 호출 하면 해당 뷰뿐만 아니라 해당 뷰도 삭제되고 템플릿의 &lt;code&gt;onDestroyed&lt;/code&gt; 처리기가 트리거 됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab08929e21ebfd079d0562223de60b4a09e6f70" translate="yes" xml:space="preserve">
          <source>The return value of the Method simulation is discarded, unless the &lt;code&gt;returnStubValue&lt;/code&gt; option is passed when calling the Method, in which case it is returned to the Method caller. ValidatedMethod passes this option by default.</source>
          <target state="translated">메소드를 호출 할 때 &lt;code&gt;returnStubValue&lt;/code&gt; 옵션이 전달 되지 않으면 메소드 시뮬레이션의 리턴 값이 삭제됩니다. 이 경우 메소드 호출자에게 리턴됩니다. ValidatedMethod는 기본적으로이 옵션을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1bd226c832ab492024761da3688ff4ca08a6a08b" translate="yes" xml:space="preserve">
          <source>The reusable sub-component can then use the &lt;code&gt;hasChanges&lt;/code&gt; argument to determine if it should show some kind of callout to the user to indicate changes are available, and then use the &lt;code&gt;onShowChanges&lt;/code&gt; callback to trigger them to be shown.</source>
          <target state="translated">재사용 가능한 하위 구성 요소는 &lt;code&gt;hasChanges&lt;/code&gt; 인수를 사용하여 사용자에게 변경 사항이 있음을 나타내는 일종의 콜 아웃을 표시해야하는지 여부를 결정한 다음 &lt;code&gt;onShowChanges&lt;/code&gt; 콜백을 사용하여 해당 구성 요소 가 표시되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7398f7e34b816d147c67530ad472fee00ff0e8b" translate="yes" xml:space="preserve">
          <source>The role URLs play in a client-rendered app, and how it&amp;rsquo;s different from a traditional server-rendered app.</source>
          <target state="translated">역할 URL은 클라이언트 렌더링 앱에서 작동하며 기존 서버 렌더링 앱과 다른 점입니다.</target>
        </trans-unit>
        <trans-unit id="12ec5d01ec42e9704e010290897925f6ffe6f076" translate="yes" xml:space="preserve">
          <source>The runtime environment</source>
          <target state="translated">런타임 환경</target>
        </trans-unit>
        <trans-unit id="9afa6d691c99313dd9b95ca03d32651044f3ba8a" translate="yes" xml:space="preserve">
          <source>The same debugging functionality can be achieved by adding the &lt;code&gt;--debug-port &amp;lt;port&amp;gt;&lt;/code&gt; option to other &lt;code&gt;meteor&lt;/code&gt; tool commands, such as &lt;code&gt;meteor run&lt;/code&gt; and &lt;code&gt;meteor test-packages&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;meteor run&lt;/code&gt; 및 &lt;code&gt;meteor test-packages&lt;/code&gt; 와 같은 다른 &lt;code&gt;meteor&lt;/code&gt; 도구 명령에 &lt;code&gt;--debug-port &amp;lt;port&amp;gt;&lt;/code&gt; 옵션을 추가하여 동일한 디버깅 기능을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="702dec1a6bf9b4464cba0750cef4f3711229ca75" translate="yes" xml:space="preserve">
          <source>The same syntax can be used for &lt;code&gt;api.use&lt;/code&gt;, &lt;code&gt;api.imply&lt;/code&gt;, and &lt;code&gt;api.export&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;api.use&lt;/code&gt; , &lt;code&gt;api.imply&lt;/code&gt; 및 &lt;code&gt;api.export&lt;/code&gt; 에 동일한 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9c0308c51f25dae18970cb3a07fdc1cd767a80a" translate="yes" xml:space="preserve">
          <source>The same template may occur many times on a page, and these occurrences are called template instances. Template instances have a life cycle of being created, put into the document, and later taken out of the document and destroyed. Meteor manages these stages for you, including determining when a template instance has been removed or replaced and should be cleaned up. You can associate data with a template instance, and you can access its DOM nodes when it is in the document.</source>
          <target state="translated">페이지에서 동일한 템플릿이 여러 번 나타날 수 있으며 이러한 경우를 템플릿 인스턴스라고합니다. 템플릿 인스턴스는 수명주기를 생성하여 문서에 넣은 후 나중에 문서에서 꺼내서 소멸시킵니다. Meteor는 템플릿 인스턴스가 언제 제거 또는 교체되고 정리되어야하는지 결정하는 것을 포함하여 이러한 단계를 관리합니다. 데이터를 템플릿 인스턴스와 연결할 수 있으며 문서에있을 때 DOM 노드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64032b8927e78661e3f868ef314eb3f245c7dc6d" translate="yes" xml:space="preserve">
          <source>The same way that you don&amp;rsquo;t read English sentences one word at a time, you don&amp;rsquo;t read code one token at a time. Mostly you just look at the shape of a certain expression, or the way it highlights in your editor, and assume what it does. If the style of every bit of code is consistent, that ensures that bits of code that look the same actually &lt;em&gt;are&lt;/em&gt; the same - there isn&amp;rsquo;t any hidden punctuation or gotchas that you don&amp;rsquo;t expect, so you can focus on understanding the logic instead of the symbols. One example of this is indentation - while in JavaScript, indentation is not meaningful, it&amp;rsquo;s helpful to have all of your code consistently indented so that you don&amp;rsquo;t need to read all of the brackets in detail to see what is going on.</source>
          <target state="translated">한 번에 한 단어 씩 영어 문장을 읽지 않는 것과 같은 방식으로 한 번에 한 토큰 씩 코드를 읽지 않습니다. 대부분 특정 표현식의 모양이나 편집기에서 강조 표시되는 방식을보고 그 동작을 가정합니다. 모든 코드 비트의 스타일이 일관된 경우 실제로 동일한 코드 비트가 동일하게 유지 &lt;em&gt;됩니다&lt;/em&gt; . 예상치 못한 숨겨진 구두점이나 문제점이 없으므로 논리 이해에 집중할 수 있습니다. 기호 대신. 이에 대한 한 가지 예는 들여 쓰기입니다. JavaScript에서는 들여 쓰기가 의미가 없지만 모든 코드를 일관되게 들여 쓰는 것이 도움이되므로 모든 괄호를 자세히 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bd72f15648c21b68e1c62222d240964640ae880" translate="yes" xml:space="preserve">
          <source>The second is when the URL is valid, but doesn&amp;rsquo;t actually match any data. In this case, the URL matches a route, but once the route has successfully subscribed, it discovers there is no data. It usually makes sense in this case for the page component (which subscribes and fetches the data) to render a not-found template instead of the usual template for the page:</source>
          <target state="translated">두 번째는 URL이 유효하지만 실제로는 데이터와 일치하지 않는 경우입니다. 이 경우 URL은 경로와 일치하지만 일단 경로가 성공적으로 구독되면 데이터가 없음을 알게됩니다. 이 경우 일반적으로 데이터를 구독하고 페치하는 페이지 컴포넌트가 페이지의 일반 템플리트 대신 찾을 수없는 템플리트를 렌더링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4390553f93c001bde55a8e234067b449495d68dd" translate="yes" xml:space="preserve">
          <source>The section above talked about JavaScript code in general - you can easily apply it in any JavaScript application, not just with Meteor apps. However, there are some style questions that are Meteor-specific, in particular how to name and structure all of the different components of your app.</source>
          <target state="translated">위의 섹션에서는 일반적인 JavaScript 코드에 대해 설명했습니다. Meteor 앱뿐만 아니라 모든 JavaScript 애플리케이션에 쉽게 적용 할 수 있습니다. 그러나 Meteor에 특정한 몇 가지 스타일 질문이 있습니다. 특히 앱의 다양한 구성 요소의 이름을 지정하고 구성하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca89d1440c014241d0e14e42159bf3494b1c84e" translate="yes" xml:space="preserve">
          <source>The security surface area of a Meteor app.</source>
          <target state="translated">Meteor 앱의 보안 영역입니다.</target>
        </trans-unit>
        <trans-unit id="72bbc6dfb75bf94765ca8935d2157cc923c27d4e" translate="yes" xml:space="preserve">
          <source>The server &lt;em&gt;explicitly&lt;/em&gt; waits until all the data is sent down (the new subscription is ready) for the new subscription before removing the data from the old subscription. The idea here is to avoid flicker&amp;mdash;you can, if desired, continue to show the old subscription&amp;rsquo;s data until the new data is ready, then instantly switch over to the new subscription&amp;rsquo;s complete data set.</source>
          <target state="translated">서버 는 이전 구독에서 데이터를 제거하기 전에 새 구독에 대해 모든 데이터가 전송 될 때까지 (새 구독이 준비 될 때까지) &lt;em&gt;명시 적으로&lt;/em&gt; 대기합니다. 여기서 아이디어는 깜박임을 피하는 것입니다. 원하는 경우 새 데이터가 준비 될 때까지 이전 구독 데이터를 계속 표시 한 다음 즉시 새 구독의 전체 데이터 세트로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="746fab1fce56a89f377ea80e4afe7658f62e7c56" translate="yes" xml:space="preserve">
          <source>The server connection that will manage this collection. Uses the default connection if not specified. Pass the return value of calling &lt;a href=&quot;#ddp_connect&quot;&gt;&lt;code&gt;DDP.connect&lt;/code&gt;&lt;/a&gt; to specify a different server. Pass &lt;code&gt;null&lt;/code&gt; to specify no connection. Unmanaged (&lt;code&gt;name&lt;/code&gt; is null) collections cannot specify a connection.</source>
          <target state="translated">이 컬렉션을 관리 할 서버 연결입니다. 지정되지 않은 경우 기본 연결을 사용합니다. &lt;a href=&quot;#ddp_connect&quot;&gt; &lt;code&gt;DDP.connect&lt;/code&gt; &lt;/a&gt; 호출의 리턴 값을 전달 하여 다른 서버를 지정하십시오. 패스 &lt;code&gt;null&lt;/code&gt; 더 연결을 지정 할 수 있습니다. 관리되지 않는 ( &lt;code&gt;name&lt;/code&gt; is null) 컬렉션은 연결을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9cb77650aef11e195d36d66bcd612105e751c461" translate="yes" xml:space="preserve">
          <source>The server process debugger will listen for incoming connections from debugging clients, such as node-inspector, on port 5858 by default. To specify a different port use the &lt;code&gt;--debug-port &amp;lt;port&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">서버 프로세스 디버거는 기본적으로 포트 5858에서 노드 검사기와 같은 디버깅 클라이언트로부터 들어오는 연결을 수신합니다. 다른 포트를 지정하려면 &lt;code&gt;--debug-port &amp;lt;port&amp;gt;&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="057dbd182acf9a6c2ccbc6671595895194b7d7f9" translate="yes" xml:space="preserve">
          <source>The server process will be suspended just before the first statement of server code that would normally execute. In order to continue execution of server code, use either the web-based Node Inspector or the command-line debugger (further instructions will be printed in the console).</source>
          <target state="translated">서버 프로세스는 일반적으로 실행되는 서버 코드의 첫 번째 명령문 직전에 일시 중단됩니다. 서버 코드를 계속 실행하려면 웹 기반 노드 검사기 또는 명령 줄 디버거를 사용하십시오 (자세한 내용은 콘솔에 인쇄 됨).</target>
        </trans-unit>
        <trans-unit id="fe8af390358ce5dba4612c0e33e5297f0d01891d" translate="yes" xml:space="preserve">
          <source>The server reads from the &lt;code&gt;MAIL_URL&lt;/code&gt; environment variable to determine how to send mail. The &lt;code&gt;MAIL_URL&lt;/code&gt; should reference an &lt;a href=&quot;https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol&quot;&gt;SMTP&lt;/a&gt; server and use the form &lt;code&gt;smtp://USERNAME:PASSWORD@HOST:PORT&lt;/code&gt; or &lt;code&gt;smtps://USERNAME:PASSWORD@HOST:PORT&lt;/code&gt;. The &lt;code&gt;smtps://&lt;/code&gt; form (the &lt;code&gt;s&lt;/code&gt; is for &amp;ldquo;secure&amp;rdquo;) should be used if the mail server requires TLS/SSL (and does not use &lt;code&gt;STARTTLS&lt;/code&gt;) and is most common on port 465. Connections which start unencrypted prior to being upgraded to TLS/SSL (using &lt;code&gt;STARTTLS&lt;/code&gt;) typically use port 587 (and &lt;em&gt;sometimes&lt;/em&gt; 25) and should use &lt;code&gt;smtp://&lt;/code&gt;. For more information see the &lt;a href=&quot;https://nodemailer.com/smtp/&quot;&gt;Nodemailer docs&lt;/a&gt;</source>
          <target state="translated">서버는 &lt;code&gt;MAIL_URL&lt;/code&gt; 환경 변수를 읽어 메일을 보내는 방법을 결정합니다. &lt;code&gt;MAIL_URL&lt;/code&gt; 는 참조해야 &lt;a href=&quot;https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol&quot;&gt;SMTP의&lt;/a&gt; 서버 및 양식 사용 &lt;code&gt;smtp://USERNAME:PASSWORD@HOST:PORT&lt;/code&gt; 또는 &lt;code&gt;smtps://USERNAME:PASSWORD@HOST:PORT&lt;/code&gt; . &lt;code&gt;smtps://&lt;/code&gt; 형식합니다 ( &lt;code&gt;s&lt;/code&gt; 메일 서버가 TLS / SSL이 필요한 경우 사용되어야한다 (그리고 사용하지 않는 &quot;안전이&quot;입니다) &lt;code&gt;STARTTLS&lt;/code&gt; 를 ) 암호화되지 않은 이전으로 업그레이드되기 시작 포트 465 연결에 가장 일반적입니다 TLS / SSL ( &lt;code&gt;STARTTLS&lt;/code&gt; 사용 )은 일반적으로 포트 587 ( &lt;em&gt;때로는&lt;/em&gt; 25)을 사용하며 &lt;code&gt;smtp://&lt;/code&gt; 를 사용해야합니다 . 자세한 내용은&lt;a href=&quot;https://nodemailer.com/smtp/&quot;&gt;노드 메일러 문서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="069a91677cd1cf24c181a4723eafdb77ebd45a94" translate="yes" xml:space="preserve">
          <source>The server sets up a query observer on that cursor, unless such an observer already exists on the server (for any user), in which case that observer is re-used.</source>
          <target state="translated">서버에 그러한 관찰자가 이미 존재하지 않는 한 서버는 해당 커서에 쿼리 관찰자를 설정합니다 (이 경우 사용자는 해당 관찰자가 재 사용됨).</target>
        </trans-unit>
        <trans-unit id="097e5c67d62065e88e6065da77e5ec00a14928d6" translate="yes" xml:space="preserve">
          <source>The server starts up the subscription by running the publication handler function.</source>
          <target state="translated">서버는 발행 핸들러 기능을 실행하여 구독을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c5a40c32ec4d5c6a93d6ea4f6e1e60dc0d236f27" translate="yes" xml:space="preserve">
          <source>The server stops its internal subscription object, triggering the following effects:</source>
          <target state="translated">서버는 내부 구독 오브젝트를 중지하여 다음과 같은 효과를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5fdfc53475d513083d8a034d3c39368f38afe631" translate="yes" xml:space="preserve">
          <source>The service name, such as &amp;ldquo;password&amp;rdquo; or &amp;ldquo;twitter&amp;rdquo;.</source>
          <target state="translated">&quot;암호&quot;또는 &quot;twitter&quot;와 같은 서비스 이름.</target>
        </trans-unit>
        <trans-unit id="41acf53ac46904bb6e77bd2a44b34aa17cee14bb" translate="yes" xml:space="preserve">
          <source>The shell maintains a persistent history across sessions. Previously-run commands can be accessed by pressing the up arrow.</source>
          <target state="translated">셸은 여러 세션에서 지속적인 기록을 유지합니다. 위쪽 화살표를 누르면 이전에 실행 한 명령에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="562d3e8f78be8f0d4590814f3055a13d654387ee" translate="yes" xml:space="preserve">
          <source>The shell supports tab completion for global variables like &lt;code&gt;Meteor&lt;/code&gt;, &lt;code&gt;Mongo&lt;/code&gt;, and &lt;code&gt;Package&lt;/code&gt;. Try typing &lt;code&gt;Meteor.is&lt;/code&gt; and then pressing tab.</source>
          <target state="translated">이 쉘은 &lt;code&gt;Meteor&lt;/code&gt; , &lt;code&gt;Mongo&lt;/code&gt; 및 &lt;code&gt;Package&lt;/code&gt; 와 같은 전역 변수에 대한 탭 완성을 지원합니다 . &lt;code&gt;Meteor.is&lt;/code&gt; 를 입력 한 다음 tab을 누르십시오.</target>
        </trans-unit>
        <trans-unit id="6aa874cbb26c1a6cd4be959c8f1ba01ee5ff71a9" translate="yes" xml:space="preserve">
          <source>The simple way to work around the problem is to take the application down for the period in between deployment and completing the migration. This is far from ideal, especially considering some migrations can take hours to run (although using &lt;a href=&quot;#bulk-data-changes&quot;&gt;Bulk Updates&lt;/a&gt; probably helps a lot here).</source>
          <target state="translated">문제를 해결하는 간단한 방법은 배포와 마이그레이션 완료 사이의 기간 동안 응용 프로그램을 중단시키는 것입니다. &lt;a href=&quot;#bulk-data-changes&quot;&gt;대량&lt;/a&gt; 마이그레이션을 사용 하면 여기에 많은 도움이 되지만 일부 마이그레이션을 실행하는 데 몇 시간이 걸릴 수 있다는 점을 고려하면 이상적이지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dca64431a60adfcc58a7cda7ad819b143861c80b" translate="yes" xml:space="preserve">
          <source>The simplest approach is to point both applications at the same &lt;code&gt;MONGO_URL&lt;/code&gt; and allow both applications to read and write from the database directly. This works well thanks to Meteor&amp;rsquo;s support for reactivity through the database. When one app changes some data in MongoDB, users of any other app connected to the database will see the changes immediately thanks to Meteor&amp;rsquo;s livequery.</source>
          <target state="translated">가장 간단한 방법은 두 응용 프로그램을 동일한 &lt;code&gt;MONGO_URL&lt;/code&gt; 을 가리키고 두 응용 프로그램 이 데이터베이스에서 직접 읽고 쓸 수 있도록하는 것입니다. 이것은 Meteor의 데이터베이스를 통한 반응성에 대한 지원 덕분에 잘 작동합니다. 한 앱이 MongoDB에서 일부 데이터를 변경하면 데이터베이스에 연결된 다른 앱의 사용자는 Meteor의 라이브 쿼리 덕분에 즉시 변경 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="415b97d9fafddf82aacde9699b97ade4bea5f0e1" translate="yes" xml:space="preserve">
          <source>The simplest selectors are just a string or &lt;a href=&quot;#mongo_object_id&quot;&gt;&lt;code&gt;Mongo.ObjectID&lt;/code&gt;&lt;/a&gt;. These selectors match the document with that value in its &lt;code&gt;_id&lt;/code&gt; field.</source>
          <target state="translated">가장 간단한 선택기는 문자열 또는 &lt;a href=&quot;#mongo_object_id&quot;&gt; &lt;code&gt;Mongo.ObjectID&lt;/code&gt; &lt;/a&gt; 입니다. 이 선택기는 &lt;code&gt;_id&lt;/code&gt; 필드의 해당 값과 문서를 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="276138ce12ffe75d29b12930d8c09959208e2833" translate="yes" xml:space="preserve">
          <source>The simplest way to provide a server-server API is to use Meteor&amp;rsquo;s built-in DDP protocol directly. This is the same way your Meteor client gets data from your server, but you can also use it to communicate between different applications. You can use &lt;a href=&quot;http://docs.meteor.com/#/full/ddp_connect&quot;&gt;&lt;code&gt;DDP.connect()&lt;/code&gt;&lt;/a&gt; to connect from a &amp;ldquo;client&amp;rdquo; server to the master server, and then use the connection object returned to make method calls and read from publications.</source>
          <target state="translated">서버-서버 API를 제공하는 가장 간단한 방법은 Meteor의 내장 DDP 프로토콜을 직접 사용하는 것입니다. 이는 Meteor 클라이언트가 서버에서 데이터를 가져 오는 것과 같은 방법이지만 다른 응용 프로그램간에 통신하는 데 사용할 수도 있습니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;http://docs.meteor.com/#/full/ddp_connect&quot;&gt; &lt;code&gt;DDP.connect()&lt;/code&gt; &lt;/a&gt; 마스터 서버로 &quot;클라이언트&quot;서버에서 연결 한 후 연결 객체가 메서드 호출을하고 출판물에서 읽을 돌려 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0cb76e9ab7889fb86c50e261ae5f43478e4cac2b" translate="yes" xml:space="preserve">
          <source>The source files that make up the build plugin, independent from &lt;a href=&quot;#pack_addFiles&quot;&gt;api.addFiles&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pack_addFiles&quot;&gt;api.addFiles&lt;/a&gt; 와 독립적으로 빌드 플러그인을 구성하는 소스 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="71f0b54587199ae5ce51413291798c894c72f957" translate="yes" xml:space="preserve">
          <source>The subscription detects this, and given that anything is possible in next computation run, marks itself for destruction.</source>
          <target state="translated">서브 스크립 션은이를 감지하고 다음 계산 실행에서 가능한 모든 것을 고려할 때 자체적으로 소멸을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c6f295b3b87dd070837aff2f0d0a6a3c94dfe452" translate="yes" xml:space="preserve">
          <source>The subscription handle also has another important property, the &lt;code&gt;.stop()&lt;/code&gt; method. When you are subscribing, it is very important to ensure that you always call &lt;code&gt;.stop()&lt;/code&gt; on the subscription when you are done with it. This ensures that the documents sent by the subscription are cleared from your local Minimongo cache and the server stops doing the work required to service your subscription. If you forget to call stop, you&amp;rsquo;ll consume unnecessary resources both on the client and the server.</source>
          <target state="translated">구독 핸들에는 또 다른 중요한 속성 인 &lt;code&gt;.stop()&lt;/code&gt; 메서드가 있습니다. 구독 할 때 구독이 끝나면 구독에서 항상 &lt;code&gt;.stop()&lt;/code&gt; 을 호출 해야 합니다. 이렇게하면 구독에서 보낸 문서가 로컬 Minimongo 캐시에서 지워지고 서버는 구독 서비스에 필요한 작업을 중지합니다. 호출 중지를 잊어 버린 경우 클라이언트와 서버 모두에서 불필요한 리소스가 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="91927b29e575261e6c8d02feb858ac50e635a114" translate="yes" xml:space="preserve">
          <source>The subscription passes the added documents to the subscribing client&amp;rsquo;s connection &lt;em&gt;mergebox&lt;/em&gt;, which is an on-server cache of the documents that have been published to this particular client. Each document is merged with any existing version of the document that the client knows about, and an &lt;code&gt;added&lt;/code&gt; (if the document is new to the client) or &lt;code&gt;changed&lt;/code&gt; (if it is known but this subscription is adding or changing fields) DDP message is sent.</source>
          <target state="translated">구독은 추가 된 문서를 구독 클라이언트의 연결 &lt;em&gt;mergebox&lt;/em&gt; 로 전달합니다.이 &lt;em&gt;대화 상자&lt;/em&gt; 는이 특정 클라이언트에 공개 된 문서의 서버 내 캐시입니다. 각 문서는 클라이언트가 알고있는 기존 버전의 문서와 병합되며 &lt;code&gt;added&lt;/code&gt; (문서가 클라이언트에 새로운 경우 ) 또는 &lt;code&gt;changed&lt;/code&gt; (알려져 있지만이 구독이 필드를 추가 또는 변경하는 경우) DDP 메시지가 전송됩니다. .</target>
        </trans-unit>
        <trans-unit id="27cd2a4faa764d089ebe647c80d95c496bd197a5" translate="yes" xml:space="preserve">
          <source>The supported browsers that can be enabled or disabled include, but are not limited to, &lt;code&gt;android&lt;/code&gt;, &lt;code&gt;chrome&lt;/code&gt;, &lt;code&gt;chromium&lt;/code&gt;, &lt;code&gt;chromeMobileIOS&lt;/code&gt;, &lt;code&gt;firefox&lt;/code&gt;, &lt;code&gt;ie&lt;/code&gt;, &lt;code&gt;mobileSafari&lt;/code&gt; and &lt;code&gt;safari&lt;/code&gt;.</source>
          <target state="translated">활성화 또는 비활성화가 포함되며 이에 국한되지 않습니다 할 수있는 지원되는 브라우저 &lt;code&gt;android&lt;/code&gt; , &lt;code&gt;chrome&lt;/code&gt; , &lt;code&gt;chromium&lt;/code&gt; , &lt;code&gt;chromeMobileIOS&lt;/code&gt; , &lt;code&gt;firefox&lt;/code&gt; , &lt;code&gt;ie&lt;/code&gt; , &lt;code&gt;mobileSafari&lt;/code&gt; 와 &lt;code&gt;safari&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44c6e24f74b0df3afa42e317d3c73162804f043e" translate="yes" xml:space="preserve">
          <source>The syntax to add a plugin from Git is kind of awkward. The name (the part before the &lt;code&gt;@&lt;/code&gt;) is the plugin ID and will have to match what is specified in the plugin&amp;rsquo;s &lt;code&gt;plugin.xml&lt;/code&gt;. Instead of a version, you specify a URL to a Git repository with the SHA hash as an anchor (the part after the &lt;code&gt;#&lt;/code&gt;):</source>
          <target state="translated">Git에서 플러그인을 추가하는 문법은 어색합니다. 이름 ( &lt;code&gt;@&lt;/code&gt; 앞에있는 부분 )은 플러그인 ID이며 플러그인의 &lt;code&gt;plugin.xml&lt;/code&gt; 에 지정된 것과 일치해야합니다 . 버전 대신 SHA 해시를 앵커 ( &lt;code&gt;#&lt;/code&gt; 다음 부분)로 Git 저장소에 대한 URL을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="6bbb2d039d4932c20a858d127e21c3eb7d1c653b" translate="yes" xml:space="preserve">
          <source>The tag must evaluate to an object that serves as a dictionary of attribute name and value strings. For convenience, the value may also be a string or null. An empty string or null expands to &lt;code&gt;{}&lt;/code&gt;. A non-empty string must be an attribute name, and expands to an attribute with an empty value; for example, &lt;code&gt;&quot;checked&quot;&lt;/code&gt; expands to &lt;code&gt;{checked: &quot;&quot;}&lt;/code&gt; (which, as far as HTML is concerned, means the checkbox is checked).</source>
          <target state="translated">태그는 속성 이름 및 값 문자열의 사전 역할을하는 객체로 평가되어야합니다. 편의상이 값은 문자열이거나 null 일 수도 있습니다. 빈 문자열 또는 null은 &lt;code&gt;{}&lt;/code&gt; 로 확장됩니다 . 비어 있지 않은 문자열은 속성 이름이어야하며 값이 비어있는 속성으로 확장됩니다. 예를 들어 &lt;code&gt;&quot;checked&quot;&lt;/code&gt; 는 &lt;code&gt;{checked: &quot;&quot;}&lt;/code&gt; 확장됩니다 (HTML과 관련하여 확인란이 선택되어 있음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="b8125d20cd4452677a9491582fd02d620c207adf" translate="yes" xml:space="preserve">
          <source>The technique above can also be used to provide a location to &amp;ldquo;hook&amp;rdquo; extra functionality into the collection. For instance, when removing a list, we &lt;em&gt;always&lt;/em&gt; want to remove all of its todos at the same time.</source>
          <target state="translated">위의 기술을 사용하여 추가 기능을 컬렉션에 &quot;후크&quot;할 수있는 위치를 제공 할 수도 있습니다. 예를 들어, 목록을 제거 할 때 &lt;em&gt;항상&lt;/em&gt; 모든 할 일을 동시에 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="034e7f74fb6db86e567a63ea331823c40a21e813" translate="yes" xml:space="preserve">
          <source>The template (e.g. &lt;code&gt;Template.myTemplate&lt;/code&gt;) or View object from which to generate HTML.</source>
          <target state="translated">HTML을 생성 할 템플릿 (예 : &lt;code&gt;Template.myTemplate&lt;/code&gt; ) 또는 View 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d8e63bce841f73d768307448657db139ec098866" translate="yes" xml:space="preserve">
          <source>The template (e.g. &lt;code&gt;Template.myTemplate&lt;/code&gt;) or View object to render.</source>
          <target state="translated">렌더링 할 템플릿 (예 : &lt;code&gt;Template.myTemplate&lt;/code&gt; ) 또는 View 객체입니다.</target>
        </trans-unit>
        <trans-unit id="41249779096e24a297a4e65929b43298def99b87" translate="yes" xml:space="preserve">
          <source>The template (e.g. &lt;code&gt;Template.myTemplate&lt;/code&gt;) or View object to render. If a template, a View object is &lt;a href=&quot;#template_constructview&quot;&gt;constructed&lt;/a&gt;. If a View, it must be an unrendered View, which becomes a rendered View and is returned.</source>
          <target state="translated">렌더링 할 템플릿 (예 : &lt;code&gt;Template.myTemplate&lt;/code&gt; ) 또는 View 객체입니다. 템플릿 인 경우 View 객체가 &lt;a href=&quot;#template_constructview&quot;&gt;생성&lt;/a&gt; 됩니다. 뷰인 경우 렌더링되지 않은 뷰 여야하며 렌더링 된 뷰가되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7d84dd762c7d0220ca76f4a43e1c2813420edf4a" translate="yes" xml:space="preserve">
          <source>The template inclusion tag, &lt;code&gt;{{&amp;gt; Todos_item (todoArgs todo)}}&lt;/code&gt; which renders the &lt;code&gt;Todos_item&lt;/code&gt; component with the data context returned from the &lt;code&gt;todosArg&lt;/code&gt; helper.</source>
          <target state="translated">&lt;code&gt;todosArg&lt;/code&gt; 헬퍼 에서 리턴 된 데이터 컨텍스트를 사용하여 &lt;code&gt;Todos_item&lt;/code&gt; 컴포넌트 를 렌더링하는 템플리트 포함 태그 &lt;code&gt;{{&amp;gt; Todos_item (todoArgs todo)}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="573b5fbd0391064796b87f40c1db56b1c4bc4d6a" translate="yes" xml:space="preserve">
          <source>The template instance serves as the document root for the selector. Only elements inside the template and its sub-templates can match parts of the selector.</source>
          <target state="translated">템플릿 인스턴스는 선택기의 문서 루트 역할을합니다. 템플릿과 해당 하위 템플릿 내의 요소 만 선택기의 일부와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="008d54f6db6e00ce95a452f003837c432202d425" translate="yes" xml:space="preserve">
          <source>The test is slightly simpler than the Blaze version above because the React sample app is not internationalized. Otherwise, it&amp;rsquo;s conceptually identical. We use Enzyme&amp;rsquo;s &lt;code&gt;shallow&lt;/code&gt; function to render the &lt;code&gt;TodoItem&lt;/code&gt; component, and the resulting object to query the document, and also to simulate user interactions. And here&amp;rsquo;s an example of simulating a user checking the todo item:</source>
          <target state="translated">React 샘플 앱이 국제화되지 않았기 때문에 위의 Blaze 버전보다 약간 단순합니다. 그렇지 않으면 개념적으로 동일합니다. Enzyme의 &lt;code&gt;shallow&lt;/code&gt; 함수를 사용하여 &lt;code&gt;TodoItem&lt;/code&gt; 구성 요소와 결과 개체 를 렌더링 하여 문서를 쿼리하고 사용자 상호 작용을 시뮬레이션합니다. 다음은 할일 항목을 확인하는 사용자를 시뮬레이션하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f343dc469f126c1ea38aefc825230c5c7a86d365" translate="yes" xml:space="preserve">
          <source>The token retrieved from the reset password URL.</source>
          <target state="translated">비밀번호 재설정 URL에서 검색된 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="2c6e0b8ef722da8420c87bbca69163609f13e897" translate="yes" xml:space="preserve">
          <source>The token retrieved from the verification URL.</source>
          <target state="translated">확인 URL에서 검색된 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="8bda0c1c785971202641067eef854eeb2b5c0955" translate="yes" xml:space="preserve">
          <source>The two alteratives to Angular are &lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt; and &lt;a href=&quot;react&quot;&gt;React&lt;/a&gt;. &lt;a href=&quot;ui-ux#view-layers&quot;&gt;Here&amp;rsquo;s a comparison&lt;/a&gt; of all three.</source>
          <target state="translated">Angular의 두 가지 대안은 &lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt; 와 &lt;a href=&quot;react&quot;&gt;React&lt;/a&gt; 입니다. &lt;a href=&quot;ui-ux#view-layers&quot;&gt;다음&lt;/a&gt; 은 세 가지를 모두 비교 한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="251bf726eb97960278b61f839fdf72b93fb2ca39" translate="yes" xml:space="preserve">
          <source>The two nodes &lt;code&gt;firstNode&lt;/code&gt; and &lt;code&gt;lastNode&lt;/code&gt; indicate the extent of the rendered template in the DOM. The rendered template includes these nodes, their intervening siblings, and their descendents. These two nodes are siblings (they have the same parent), and &lt;code&gt;lastNode&lt;/code&gt; comes after &lt;code&gt;firstNode&lt;/code&gt;, or else they are the same node.</source>
          <target state="translated">두 개의 노드 &lt;code&gt;firstNode&lt;/code&gt; 및 &lt;code&gt;lastNode&lt;/code&gt; 는 DOM에서 렌더링 된 템플리트의 범위를 나타냅니다. 렌더링 된 템플릿에는 이러한 노드, 중간 형제 및 하위 항목이 포함됩니다. 이 두 노드는 형제이며 부모가 동일하며 &lt;code&gt;lastNode&lt;/code&gt; 는 &lt;code&gt;firstNode&lt;/code&gt; 뒤에 옵니다 . 그렇지 않으면 동일한 노드입니다.</target>
        </trans-unit>
        <trans-unit id="1d7ffd8a888b1262ac59e6639f670a995882f6fe" translate="yes" xml:space="preserve">
          <source>The unsigned &lt;code&gt;apk&lt;/code&gt; bundle and the outputted Xcode project can be used to deploy your mobile apps to Android Play Store and Apple App Store.</source>
          <target state="translated">서명되지 않은 &lt;code&gt;apk&lt;/code&gt; 번들 및 출력 된 Xcode 프로젝트를 사용하여 모바일 앱을 Android Play Store 및 Apple App Store에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfcdd510434f17af6c092af6290adc687923cf50" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;userId&lt;/code&gt; wants to insert the document &lt;code&gt;doc&lt;/code&gt; into the collection. Return &lt;code&gt;true&lt;/code&gt; if this should be allowed.</source>
          <target state="translated">&lt;code&gt;userId&lt;/code&gt; 사용자 는 문서 &lt;code&gt;doc&lt;/code&gt; 를 콜렉션 에 삽입하려고합니다 . 이것이 허용되면 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe801444a7c8711efa09c71940bb8ba8ae6f6b09" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;userId&lt;/code&gt; wants to remove &lt;code&gt;doc&lt;/code&gt; from the database. Return &lt;code&gt;true&lt;/code&gt; to permit this.</source>
          <target state="translated">사용자 &lt;code&gt;userId&lt;/code&gt; 가 데이터베이스에서 &lt;code&gt;doc&lt;/code&gt; 를 제거하려고 합니다. 이를 허용하려면 &lt;code&gt;true&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="08bef4fc2671c2024349524e02270b0ba38a2819" translate="yes" xml:space="preserve">
          <source>The user &lt;code&gt;userId&lt;/code&gt; wants to update a document &lt;code&gt;doc&lt;/code&gt;. (&lt;code&gt;doc&lt;/code&gt; is the current version of the document from the database, without the proposed update.) Return &lt;code&gt;true&lt;/code&gt; to permit the change.</source>
          <target state="translated">&lt;code&gt;userId&lt;/code&gt; 사용자 는 문서 &lt;code&gt;doc&lt;/code&gt; 을 업데이트하려고합니다 . ( &lt;code&gt;doc&lt;/code&gt; 은 제안 된 업데이트없이 데이터베이스에서 문서의 현재 버전입니다.) 변경을 허용하려면 &lt;code&gt;true&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="9b98eab3af4d739796a1a360b91b07b1db47c9f0" translate="yes" xml:space="preserve">
          <source>The user id is an arbitrary string &amp;mdash; typically the id of the user record in the database. You can set it with the &lt;code&gt;setUserId&lt;/code&gt; function. If you&amp;rsquo;re using the &lt;a href=&quot;#accounts_api&quot;&gt;Meteor accounts system&lt;/a&gt; then this is handled for you.</source>
          <target state="translated">사용자 ID는 임의의 문자열입니다. 일반적으로 데이터베이스에있는 사용자 레코드의 ID입니다. &lt;code&gt;setUserId&lt;/code&gt; 함수를 사용하여 설정할 수 있습니다 . &lt;a href=&quot;#accounts_api&quot;&gt;Meteor 계정 시스템&lt;/a&gt; 을 사용하는 경우 이것이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf032e7944e1e3983413c57fa3ae8548dca23173" translate="yes" xml:space="preserve">
          <source>The user presses a keyboard key. &lt;code&gt;keypress&lt;/code&gt; is most useful for catching typing in text fields, while &lt;code&gt;keydown&lt;/code&gt; and &lt;code&gt;keyup&lt;/code&gt; can be used for arrow keys or modifier keys.</source>
          <target state="translated">사용자가 키보드 키를 누릅니다. &lt;code&gt;keypress&lt;/code&gt; 는 텍스트 필드에서 입력을 잡는 데 가장 유용한 반면, &lt;code&gt;keydown&lt;/code&gt; 및 &lt;code&gt;keyup&lt;/code&gt; 은 화살표 키 또는 수정 자 키에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8f396aec2f98b55e4d3dffa0512958e211f380" translate="yes" xml:space="preserve">
          <source>The user's current password. This is &lt;strong&gt;not&lt;/strong&gt; sent in plain text over the wire.</source>
          <target state="translated">사용자의 현재 비밀번호입니다. 이것은 와이어를 통해 일반 텍스트로 전송 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="807c55624f8479c8eb47f6be16ce5d1b43ab7288" translate="yes" xml:space="preserve">
          <source>The user's email address.</source>
          <target state="translated">사용자의 이메일 주소</target>
        </trans-unit>
        <trans-unit id="10eab012c461bfc94dae75aa1fcd8595ad75aaa3" translate="yes" xml:space="preserve">
          <source>The user's password.</source>
          <target state="translated">사용자의 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="59a0e240b9207fb55d72a9754f4e95a7557b4d0f" translate="yes" xml:space="preserve">
          <source>The user's password. This is &lt;strong&gt;not&lt;/strong&gt; sent in plain text over the wire.</source>
          <target state="translated">사용자의 비밀번호입니다. 이것은 와이어를 통해 일반 텍스트로 전송 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="08cc72d10c9fa5edf945d26a3ed1b5582f01e95e" translate="yes" xml:space="preserve">
          <source>The user's profile, typically including the &lt;code&gt;name&lt;/code&gt; field.</source>
          <target state="translated">일반적으로 &lt;code&gt;name&lt;/code&gt; 필드를 포함한 사용자의 프로필 입니다.</target>
        </trans-unit>
        <trans-unit id="58253cd708fc4aae51ae3f5cce7ee272c7c95324" translate="yes" xml:space="preserve">
          <source>The username to look for</source>
          <target state="translated">찾을 사용자 이름</target>
        </trans-unit>
        <trans-unit id="e71b6aa32f716490ff5aaa8aa6ada5169a88d769" translate="yes" xml:space="preserve">
          <source>The value for that preference.</source>
          <target state="translated">해당 환경 설정의 값입니다.</target>
        </trans-unit>
        <trans-unit id="f0c9eb5c99d36714cd633ae73fcbbea6530e2cdd" translate="yes" xml:space="preserve">
          <source>The value that should be returned by &lt;code&gt;userId&lt;/code&gt; on this connection.</source>
          <target state="translated">이 연결에서 &lt;code&gt;userId&lt;/code&gt; 가 리턴해야하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="224a586b5c96fa838ab0d25ab2f1c9ecb9042587" translate="yes" xml:space="preserve">
          <source>The value to check</source>
          <target state="translated">확인할 값</target>
        </trans-unit>
        <trans-unit id="3fdb08efce1dd734be1b5cea101b0b4e5b482201" translate="yes" xml:space="preserve">
          <source>The value to test against</source>
          <target state="translated">테스트 할 가치</target>
        </trans-unit>
        <trans-unit id="572affcd555e45a118ca8c255703b01188667dc6" translate="yes" xml:space="preserve">
          <source>The value to test.</source>
          <target state="translated">테스트 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="f6aec9757e763674c114ae79bf7a90019a5f4b5e" translate="yes" xml:space="preserve">
          <source>The variable to check.</source>
          <target state="translated">확인할 변수입니다.</target>
        </trans-unit>
        <trans-unit id="71addf175afde40d4d6f69932118df3855185e6e" translate="yes" xml:space="preserve">
          <source>The way that you move data from the server (and MongoDB-backed) collection into the client (in-memory) collection is the subject of the &lt;a href=&quot;data-loading&quot;&gt;data loading article&lt;/a&gt;. Generally speaking, you &lt;em&gt;subscribe&lt;/em&gt; to a &lt;em&gt;publication&lt;/em&gt;, which pushes data from the server to the client. Usually, you can assume that the client contains an up-to-date copy of some subset of the full MongoDB collection.</source>
          <target state="translated">서버 (및 MongoDB 지원) 콜렉션에서 클라이언트 (메모리 내) 콜렉션으로 데이터를 이동하는 방법은 &lt;a href=&quot;data-loading&quot;&gt;데이터로드 기사&lt;/a&gt; 의 주제입니다 . 일반적으로 서버에서 클라이언트로 데이터를 푸시 하는 &lt;em&gt;발행물&lt;/em&gt; 을 &lt;em&gt;구독&lt;/em&gt; 합니다 . 일반적으로 클라이언트에 전체 MongoDB 콜렉션의 일부 서브 세트에 대한 최신 사본이 포함되어 있다고 가정 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30f5a256e98f9ccafa77d05bb3ec50f629893163" translate="yes" xml:space="preserve">
          <source>The way this package works is to first establish a cursor on one collection, and then explicitly set up a second level of cursors on a second collection with the results of the first cursor. The package uses a query observer behind the scenes to trigger the subscription to change and queries to re-run whenever the source data changes.</source>
          <target state="translated">이 패키지가 작동하는 방식은 먼저 한 컬렉션에서 커서를 설정 한 다음 첫 번째 커서의 결과를 사용하여 두 번째 컬렉션에서 두 번째 수준의 커서를 명시 적으로 설정하는 것입니다. 패키지는 백그라운드에서 쿼리 옵저버를 사용하여 구독이 변경되도록 트리거하고 소스 데이터가 변경 될 때마다 쿼리를 다시 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3911b92d29cad53d31a6e86b7339b0a08113614e" translate="yes" xml:space="preserve">
          <source>The web view situation on Android is a little more complicated. On older Android versions, the included web view is known to be rather slow and buggy. That improved somewhat with Android 4.4, which includes a web view based on Chromium, the open source project behind the Chrome browser.</source>
          <target state="translated">Android의 웹보기 상황은 조금 더 복잡합니다. 이전 Android 버전에서는 포함 된 웹보기가 다소 느리고 버그가있는 것으로 알려져 있습니다. Chrome 브라우저의 오픈 소스 프로젝트 인 Chromium을 기반으로 한 웹 뷰를 포함하는 Android 4.4에서는 다소 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="f8d0127e05868bdd01cc2bef27a7b76f589b6e20" translate="yes" xml:space="preserve">
          <source>The whole directory or path should indicate that these templates are related to the &lt;code&gt;Lists&lt;/code&gt; module, so it&amp;rsquo;s not necessary to reproduce that information in the file name. Read more about directory structure &lt;a href=&quot;structure#javascript-structure&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">전체 디렉토리 또는 경로는 이러한 템플리트가 &lt;code&gt;Lists&lt;/code&gt; 모듈 과 관련되어 있음을 나타내 므로 파일 이름으로 해당 정보를 재현 할 필요는 없습니다. &lt;a href=&quot;structure#javascript-structure&quot;&gt;아래&lt;/a&gt; 디렉토리 구조에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="17ceb8a53f7ac1ca2da2c14a2be51c5643c2f2f1" translate="yes" xml:space="preserve">
          <source>Then &lt;strong&gt;restart&lt;/strong&gt; (or &lt;strong&gt;reload&lt;/strong&gt; by pressing Ctrl+Alt+R / Cmd+Opt+R) Atom to activate linting.</source>
          <target state="translated">이어서 &lt;strong&gt;다시 시작&lt;/strong&gt; (또는 &lt;strong&gt;장전&lt;/strong&gt; Ctrl + Alt + R / +에서는 Cmd + R 탈퇴 누름) 아톰 linting 활성화한다.</target>
        </trans-unit>
        <trans-unit id="1d3382dd82b1cd83e103bbc2c27f6d355cfcfd5b" translate="yes" xml:space="preserve">
          <source>Then just include it anywhere in a Blaze template:</source>
          <target state="translated">그런 다음 Blaze 템플릿의 아무 곳에 나 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="9f8939db65b9680811ecc2555a938732b394618f" translate="yes" xml:space="preserve">
          <source>Then on the client side, we&amp;rsquo;d set some kind of reactive state variable to control how many items to request:</source>
          <target state="translated">그런 다음 클라이언트 측에서 요청하는 항목 수를 제어하기 위해 일종의 반응 상태 변수를 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="f4d9739e6092184526ef79541a30ac9c3401861e" translate="yes" xml:space="preserve">
          <source>Then on the client, after subscribing to that publication, we can access the count with</source>
          <target state="translated">그런 다음 클라이언트에서 해당 발행물을 구독 한 후</target>
        </trans-unit>
        <trans-unit id="7072456d1ba04eaf3f572a3a3033977e037d8365" translate="yes" xml:space="preserve">
          <source>Then simply add the &lt;code&gt;{{&amp;gt; loginButtons}}&lt;/code&gt; helper to an HTML file. This will place a login widget on the page. If there is only one provider configured and it is an external service, this will add a login/logout button. If you use &lt;code&gt;accounts-password&lt;/code&gt; or use multiple external login services, this will add a &amp;ldquo;Sign in&amp;rdquo; link which opens a dropdown menu with login options. If you plan to position the login dropdown in the right edge of the screen, use &lt;code&gt;{{&amp;gt; loginButtons align=&quot;right&quot;}}&lt;/code&gt; in order to get the dropdown to lay itself out without expanding off the edge of the screen.</source>
          <target state="translated">그런 다음 간단히 &lt;code&gt;{{&amp;gt; loginButtons}}&lt;/code&gt; 도우미를 HTML 파일에 추가하십시오. 그러면 페이지에 로그인 위젯이 배치됩니다. 공급자가 하나만 구성되어 있고 외부 서비스 인 경우 로그인 / 로그 아웃 버튼이 추가됩니다. &lt;code&gt;accounts-password&lt;/code&gt; 를 사용 하거나 여러 개의 외부 로그인 서비스를 사용하는 경우 로그인 옵션이있는 드롭 다운 메뉴를 여는 &quot;로그인&quot;링크가 추가됩니다. 로그인 드롭 다운을 화면 오른쪽 가장자리에 배치하려는 경우 &lt;code&gt;{{&amp;gt; loginButtons align=&quot;right&quot;}}&lt;/code&gt; 을 사용하여 드롭 다운을 화면 가장자리 밖으로 확장하지 않고 자체적으로 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="aa68d811db3705a398d7f023589ffb5ac8d66234" translate="yes" xml:space="preserve">
          <source>Then somewhere in your UI you can &lt;code&gt;CurrentLanguage.set('es')&lt;/code&gt; when a user chooses a new language.</source>
          <target state="translated">그런 다음 UI 어딘가에서 사용자가 새 언어를 선택할 때 &lt;code&gt;CurrentLanguage.set('es')&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffac89bfc6e35fb7f8b28410fec691dee710b039" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;validate()&lt;/code&gt; call will throw a &lt;code&gt;ValidationError&lt;/code&gt; which contains details about what is wrong with the &lt;code&gt;list&lt;/code&gt; document.</source>
          <target state="translated">그런 다음 &lt;code&gt;validate()&lt;/code&gt; 호출은 &lt;code&gt;list&lt;/code&gt; 문서의 문제점에 대한 세부 사항이 포함 된 &lt;code&gt;ValidationError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="260b32eee2d9a5b59e01c5ec1dbac06b4b12a7b8" translate="yes" xml:space="preserve">
          <source>Then use it directly after you shrinkwrap</source>
          <target state="translated">그런 다음 수축 포장 후 바로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74c6024d2e572e7374bad7c40761f6fbca1e759b" translate="yes" xml:space="preserve">
          <source>Then we can install any npm CSS processing packages that we&amp;rsquo;d like to use and reference them from a &lt;code&gt;postcss&lt;/code&gt; section of our &lt;code&gt;package.json&lt;/code&gt;. In the Todos example app, we use &lt;code&gt;autoprefixer&lt;/code&gt; package to increase browser support:</source>
          <target state="translated">그런 다음 사용하려는 npm CSS 처리 패키지를 설치 하고 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;postcss&lt;/code&gt; 섹션 에서 참조 할 수 있습니다 . Todos 예제 앱에서 &lt;code&gt;autoprefixer&lt;/code&gt; 패키지를 사용하여 브라우저 지원을 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="573abc801b2e89cb55d831c86476e22620e88570" translate="yes" xml:space="preserve">
          <source>Then we create a &lt;code&gt;ListPageContainer&lt;/code&gt; container component which wraps it and provides a data source:</source>
          <target state="translated">그런 다음이 를 감싸고 데이터 소스를 제공하는 &lt;code&gt;ListPageContainer&lt;/code&gt; 컨테이너 구성 요소를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="41c39c5ed035281dfd4080e777ed40dd343de321" translate="yes" xml:space="preserve">
          <source>Then when a client calls &lt;code&gt;Meteor.subscribe('Posts.all')&lt;/code&gt; the following things happen inside Meteor:</source>
          <target state="translated">그런 다음 클라이언트가 &lt;code&gt;Meteor.subscribe('Posts.all')&lt;/code&gt; 를 호출 하면 Meteor 내부에서 다음과 같은 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8c3d9a94679f38475c8ba863bf42d61eed4fad5" translate="yes" xml:space="preserve">
          <source>Then you can call that function from within an event handler:</source>
          <target state="translated">그런 다음 이벤트 핸들러 내에서 해당 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9eb38d2a2f935321307f2ba1548c6e36667347" translate="yes" xml:space="preserve">
          <source>Then you can call this helper from template like this:</source>
          <target state="translated">그런 다음 템플릿에서이 헬퍼를 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c7cbf60740227e4b5fe04cc6418e3ab825fa0b" translate="yes" xml:space="preserve">
          <source>Then you can open two browser windows to see the app in action while also ensuring that you don&amp;rsquo;t break any tests as you make changes.</source>
          <target state="translated">그런 다음 두 개의 브라우저 창을 열어 앱이 작동 중인지 확인하면서 변경하면서 테스트를 중단하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8031e6eeba4412cee7511fc6dc77cce0b1a22293" translate="yes" xml:space="preserve">
          <source>Then, in your app (this example is for the Weebo service):</source>
          <target state="translated">그런 다음 앱에서 (이 예제는 Weebo 서비스 용) :</target>
        </trans-unit>
        <trans-unit id="8cd450ec03ae5a265091ed22d858bbec593ebb0a" translate="yes" xml:space="preserve">
          <source>Then, like with any other &lt;a href=&quot;https://guide.meteor.com/using-packages.html#npm&quot;&gt;npm package&lt;/a&gt;, you can import the component in your application:</source>
          <target state="translated">그런 다음 다른 &lt;a href=&quot;https://guide.meteor.com/using-packages.html#npm&quot;&gt;npm package&lt;/a&gt; 와 마찬가지로 응용 프로그램에서 구성 요소를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bde930c0db8e155e3e481dedb64107f8c4b1ffc" translate="yes" xml:space="preserve">
          <source>Then, make sure to pick a login provider; they will automatically integrate with &lt;code&gt;accounts-ui&lt;/code&gt;:</source>
          <target state="translated">그런 다음 로그인 공급자를 선택하십시오. 그들은 &lt;code&gt;accounts-ui&lt;/code&gt; 와 자동으로 통합됩니다 :</target>
        </trans-unit>
        <trans-unit id="9f6aea17917affab1cf7bf3c7dbfb69dae113f60" translate="yes" xml:space="preserve">
          <source>Then, upsert into the &lt;code&gt;ServiceConfiguration&lt;/code&gt; collection:</source>
          <target state="translated">그런 다음 &lt;code&gt;ServiceConfiguration&lt;/code&gt; 콜렉션에 upsert하십시오 .</target>
        </trans-unit>
        <trans-unit id="b744cde79a1b4ac3b6afad6287dca315638c63e9" translate="yes" xml:space="preserve">
          <source>Then, use the &lt;code&gt;replaces&lt;/code&gt; function on the template to override the existing template from &lt;code&gt;useraccounts&lt;/code&gt;:</source>
          <target state="translated">그런 다음 템플리트 에서 &lt;code&gt;replaces&lt;/code&gt; 함수를 사용하여 &lt;code&gt;useraccounts&lt;/code&gt; 에서 기존 템플리트를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="913f2bbc905424a2214ec1676fe36fe6118b4fb2" translate="yes" xml:space="preserve">
          <source>Then, you can install Ubuntu Make itself:</source>
          <target state="translated">그런 다음 Ubuntu Make 자체를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccbe4b42586263d044fa5838e3a8b202e1122a13" translate="yes" xml:space="preserve">
          <source>Then, you need to get the user&amp;rsquo;s access token. You can find this token in the &lt;code&gt;Meteor.users&lt;/code&gt; collection under the &lt;code&gt;services&lt;/code&gt; field. For example, if you wanted to get a particular user&amp;rsquo;s Facebook access token:</source>
          <target state="translated">그런 다음 사용자의 액세스 토큰을 가져와야합니다. &lt;code&gt;services&lt;/code&gt; 필드 의 &lt;code&gt;Meteor.users&lt;/code&gt; 컬렉션 에서이 토큰을 찾을 수 있습니다 . 예를 들어 특정 사용자의 Facebook 액세스 토큰을 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0616b2298bc7bf0120583700f8e42e63bb5d9fac" translate="yes" xml:space="preserve">
          <source>There are a few UX techniques for dealing with this waiting period. The simplest is simply to switch out the page you are rendering with a generic &amp;ldquo;loading&amp;rdquo; page while you wait for all the data (typically a page may open several subscriptions) to load. As an example, in the Todos example app, we wait until all the public lists and the user&amp;rsquo;s private lists have loaded before we try to render the actual page:</source>
          <target state="translated">이 대기 시간을 처리하기위한 몇 가지 UX 기술이 있습니다. 가장 간단한 방법은 모든 데이터 (일반적으로 페이지가 여러 구독을 열 수 있음)가로드 될 때까지 기다리는 동안 일반 &quot;로드&quot;페이지로 렌더링중인 페이지를 전환하는 것입니다. 예를 들어, Todos 예제 앱에서 실제 페이지를 렌더링하기 전에 모든 공개 목록과 사용자의 개인 목록이로드 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="da275f2e26e4c28337f85a135b94b346fbf76f30" translate="yes" xml:space="preserve">
          <source>There are a few built-in block helpers that are worth knowing about:</source>
          <target state="translated">알아야 할 몇 가지 기본 제공 블록 도우미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3b1fa605865c0bbd62ab255e0141b17088222d" translate="yes" xml:space="preserve">
          <source>There are a few points to know about configuring OAuth login:</source>
          <target state="translated">OAuth 로그인 구성에 대해 알아야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a4d3b881a64de5bae1c3445eddbfc0bad8a0b33" translate="yes" xml:space="preserve">
          <source>There are a few things to understand about this code block. First, we&amp;rsquo;ve named the publication with the unique string &lt;code&gt;lists.public&lt;/code&gt;, and that will be how we access it from the client. Second, we are simply returning a Mongo &lt;em&gt;cursor&lt;/em&gt; from the publication function. Note that the cursor is filtered to only return certain fields from the collection, as detailed in the &lt;a href=&quot;security#fields&quot;&gt;Security article&lt;/a&gt;.</source>
          <target state="translated">이 코드 블록에 대해 이해해야 할 것이 몇 가지 있습니다. 먼저 고유 한 문자열 &lt;code&gt;lists.public&lt;/code&gt; 사용하여 발행물의 이름을 지정 했습니다. 둘째, 우리는 단순히 게시 함수에서 Mongo &lt;em&gt;커서&lt;/em&gt; 를 반환 합니다. &lt;a href=&quot;security#fields&quot;&gt;보안 기사에&lt;/a&gt; 설명 된대로 커서는 컬렉션에서 특정 필드 만 반환하도록 필터링됩니다 .</target>
        </trans-unit>
        <trans-unit id="f279f980da322c753b3d3b123835e562e12b4bc3" translate="yes" xml:space="preserve">
          <source>There are a few ways to search for Meteor packages published to Atmosphere:</source>
          <target state="translated">Atmosphere에 게시 된 Meteor 패키지를 검색하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
