<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="meteor">
    <body>
      <group id="meteor">
        <trans-unit id="0eae0f347d8525842b158b584cb38dde66950cf7" translate="yes" xml:space="preserve">
          <source>There are a variety of services out there, and we recommend that you select one of the below services depending on your requirements:</source>
          <target state="translated">다양한 서비스가 있으므로 요구 사항에 따라 아래 서비스 중 하나를 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a77ca7c834708bc27abce528eb4fe0c5dca2d9d7" translate="yes" xml:space="preserve">
          <source>There are a variety of states that such a list can be in:</source>
          <target state="translated">이러한 목록에있을 수있는 다양한 상태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a8fd0cbe5c5ba2ada837c704e9b11a68c8df87e" translate="yes" xml:space="preserve">
          <source>There are also two Spacebars built-in helpers, &lt;code&gt;{{#each}}&lt;/code&gt;, and &lt;code&gt;{{#with}}&lt;/code&gt;, which we do not recommend using (see prefer using each-in). These block helpers change the data context within a template, which can be difficult to reason about.</source>
          <target state="translated">또한 스페이스 바 내장 도우미 &lt;code&gt;{{#each}}&lt;/code&gt; 및 &lt;code&gt;{{#with}}&lt;/code&gt; 가 있으며 사용하지 않는 것이 좋습니다 (각각의 사용을 선호합니다). 이러한 블록 도우미는 템플릿 내에서 데이터 컨텍스트를 변경하므로 추론하기 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9db9f125309420b9eaf551aa5225901471c409" translate="yes" xml:space="preserve">
          <source>There are several load order rules. They are &lt;em&gt;applied sequentially&lt;/em&gt; to all applicable files in the application, in the priority given below:</source>
          <target state="translated">몇 가지로드 순서 규칙이 있습니다. 이 파일들은 아래 주어진 우선 순위에 따라 응용 프로그램의 모든 해당 파일에 &lt;em&gt;순차적&lt;/em&gt; 으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="643b5d33eec2cb6ebea1e10e6cb8fe7af80e31a3" translate="yes" xml:space="preserve">
          <source>There are several options. Choose the ones that makes sense for your app. You may depend on more than one and set up different test commands for different situations.</source>
          <target state="translated">몇 가지 옵션이 있습니다. 앱에 적합한 것을 선택하십시오. 둘 이상의 상황에 따라 상황에 따라 다른 테스트 명령을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47cd41854f1f21c6492e42cc51ca1b7e984fef53" translate="yes" xml:space="preserve">
          <source>There are some advantages of splitting your application in this way:</source>
          <target state="translated">이러한 방식으로 응용 프로그램을 분할하면 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec780adbc9edba54f7c0e2a6046d003ce4834206" translate="yes" xml:space="preserve">
          <source>There are some other considerations that you should make before you deploy your application to a production host. Remember that you should if possible do these steps for both your production &lt;em&gt;and&lt;/em&gt; staging environments.</source>
          <target state="translated">응용 프로그램을 프로덕션 호스트에 배포하기 전에 고려해야 할 다른 사항이 있습니다. 가능하면 프로덕션 환경 &lt;em&gt;과&lt;/em&gt; 준비 환경 모두에서이 단계를 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="16ce97471d90d7ab84abc40ca0cbd444d1605cef" translate="yes" xml:space="preserve">
          <source>There are three CSS pre-processors that are particularly popular right now:</source>
          <target state="translated">현재 특히 인기있는 CSS 프리 프로세서는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92e0c816137fbce8e368720b2f3e96dc5c961b2" translate="yes" xml:space="preserve">
          <source>There are three main locations in the HTML where template tags are allowed:</source>
          <target state="translated">템플릿 태그가 허용되는 HTML에는 세 가지 주요 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f97831b97e3142dfd1638a82832efb146598bd0a" translate="yes" xml:space="preserve">
          <source>There are three types of build plugins supported by Meteor today:</source>
          <target state="translated">오늘 Meteor가 지원하는 세 가지 유형의 빌드 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55369396dc38842070e110e69cfabbaea6e8805" translate="yes" xml:space="preserve">
          <source>There are two main kinds of test driver packages:</source>
          <target state="translated">테스트 드라이버 패키지에는 두 가지 주요 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa4cc6275a1be273aa99621fffa8ed93477a3e1" translate="yes" xml:space="preserve">
          <source>There are two main options for routing with Meteor and React. Either way, we recommend consulting our &lt;a href=&quot;routing&quot;&gt;Routing article&lt;/a&gt; for some general principles of routing in Meteor before writing your app.</source>
          <target state="translated">Meteor 및 React를 통한 라우팅에는 두 가지 주요 옵션이 있습니다. 어느 쪽이든, 앱을 작성하기 전에 &lt;a href=&quot;routing&quot;&gt;라우팅 기사&lt;/a&gt; 에서 Meteor의 라우팅에 대한 일반적인 원칙을 참조 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0219a31195ba33c6e3e859d4f4599fb46f8cf025" translate="yes" xml:space="preserve">
          <source>There are two main ways to configure your application outside of the code of the app itself:</source>
          <target state="translated">앱 자체 코드 외부에서 애플리케이션을 구성하는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb30cded6eb49815f7639ec528590f00713c5bb" translate="yes" xml:space="preserve">
          <source>There are two principal ways to do it: on the developer&amp;rsquo;s machine before allowing them to push code to the central repository, and on a dedicated CI server after each push. Both techniques are useful, and both require running tests in a commandline-only fashion.</source>
          <target state="translated">이를 수행하는 두 가지 주요 방법이 있습니다. 개발자 컴퓨터에서 코드를 중앙 리포지토리로 푸시 할 수 있도록 허용하기 전과 각 푸시 후 전용 CI 서버에서 수행합니다. 두 기술 모두 유용하며 명령 줄 전용 방식으로 테스트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="43c4918fa555b203c351dfdd223a82fcdeb657a3" translate="yes" xml:space="preserve">
          <source>There are two styles of pagination that are commonly used, a &amp;ldquo;page-by-page&amp;rdquo; style&amp;mdash;where you show only one page of results at a time, starting at some offset (which the user can control), and &amp;ldquo;infinite-scroll&amp;rdquo; style, where you show an increasing number of pages of items, as the user moves through the list (this is the typical &amp;ldquo;feed&amp;rdquo; style user interface).</source>
          <target state="translated">일반적으로 사용되는 &quot;페이지 별&quot;스타일의 두 가지 페이지 매김 스타일이 있습니다.이 페이지에서는 한 번에 하나의 결과 페이지 만 표시하고 사용자가 제어 할 수있는 오프셋에서 시작하고 &quot;무한 스크롤&quot; &amp;rdquo;스타일-사용자가 목록을 이동할 때 점점 더 많은 항목의 페이지를 표시합니다 (일반적인 &quot;피드&quot;스타일 사용자 인터페이스입니다).</target>
        </trans-unit>
        <trans-unit id="c6e479eb712d65001efc0c3274b79c7089c641d5" translate="yes" xml:space="preserve">
          <source>There are two types of minifiers one can add: a minifier processing JavaScript (registered extensions: &lt;code&gt;['js']&lt;/code&gt;) and a minifier processing CSS (extensions: &lt;code&gt;['css']&lt;/code&gt;).</source>
          <target state="translated">추가 할 수있는 두 가지 유형의 축소기에는 JavaScript를 처리하는 축소 기 (등록 된 확장자 : &lt;code&gt;['js']&lt;/code&gt; )와 CSS를 처리하는 축소 기 (확장자 : &lt;code&gt;['css']&lt;/code&gt; )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf02af84cef61722b1c0fd9d70c286fa884e8629" translate="yes" xml:space="preserve">
          <source>There are types of rendering logic that appear related to the route but which also seem related to user interface rendering. A classic example is authorization; for instance, you may want to render a login form for some subset of your pages if the user is not yet logged in.</source>
          <target state="translated">경로와 관련이 있지만 사용자 인터페이스 렌더링과 관련이있는 렌더링 논리 유형이 있습니다. 전형적인 예는 인증입니다. 예를 들어, 사용자가 아직 로그인하지 않은 경우 페이지의 일부 서브 세트에 대한 로그인 양식을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feab03640f5b214fd02eb8bb24522c7d32ba70f6" translate="yes" xml:space="preserve">
          <source>There have been several articles about the potential pitfalls of accepting MongoDB update operators from the client, in particular the &lt;a href=&quot;https://www.discovermeteor.com/blog/allow-deny-security-challenge/&quot;&gt;Allow &amp;amp; Deny Security Challenge&lt;/a&gt; and its &lt;a href=&quot;https://www.discovermeteor.com/blog/allow-deny-challenge-results/&quot;&gt;results&lt;/a&gt;, both on the Discover Meteor blog.</source>
          <target state="translated">Discover Meteor 블로그 에서 클라이언트의 MongoDB 업데이트 운영자, 특히 &lt;a href=&quot;https://www.discovermeteor.com/blog/allow-deny-security-challenge/&quot;&gt;Allow &amp;amp; Deny Security Challenge&lt;/a&gt; 및 그 &lt;a href=&quot;https://www.discovermeteor.com/blog/allow-deny-challenge-results/&quot;&gt;결과&lt;/a&gt; 를 받아들이는 잠재적 인 함정에 대한 기사가 여러 개 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6637cc8dcff95fec1db52157e25b45ccd9b5eb4" translate="yes" xml:space="preserve">
          <source>There is a case where you might &lt;em&gt;need&lt;/em&gt; to use CommonJS, even if your project has the &lt;code&gt;ecmascript&lt;/code&gt; package: if you want to conditionally include a module. &lt;code&gt;import&lt;/code&gt; statements must be at top-level scope, so they cannot be within an &lt;code&gt;if&lt;/code&gt; block. If you&amp;rsquo;re writing a common file, loaded on both client and server, you might want to import a module in only one or the other environment:</source>
          <target state="translated">당신이 수있는 경우가 &lt;em&gt;해야 할&lt;/em&gt; 프로젝트가있는 경우에도, CommonJS를 사용하는 &lt;code&gt;ecmascript&lt;/code&gt; 는 모듈을 조건부을 포함 할 경우 : 패키지. &lt;code&gt;import&lt;/code&gt; 문은 최상위 범위에 있어야하므로 &lt;code&gt;if&lt;/code&gt; 블록 내에있을 수 없습니다 . 클라이언트와 서버 모두에로드 된 공통 파일을 작성하는 경우 하나 또는 다른 환경에서만 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6e1bfc4ca9347027386872848599f05e98d3f9" translate="yes" xml:space="preserve">
          <source>There is a complementary function &lt;code&gt;Template.instance().subscriptionsReady()&lt;/code&gt; which returns true when all of the subscriptions called with &lt;code&gt;this.subscribe&lt;/code&gt; are ready.</source>
          <target state="translated">&lt;code&gt;this.subscribe&lt;/code&gt; 로 호출 된 모든 구독 이 준비 되면 true를 반환 하는 보완 함수 &lt;code&gt;Template.instance().subscriptionsReady()&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="97410b7e4ad6f74d2c57319fad31065551487f09" translate="yes" xml:space="preserve">
          <source>There is a core package called &lt;code&gt;caching-compiler&lt;/code&gt; that implements most of the common logic of keeping both in-memory and on-disk caches. The easiest way to implement caching correctly is to subclass the &lt;code&gt;CachingCompiler&lt;/code&gt; or &lt;code&gt;MultiFileCachingCompiler&lt;/code&gt; class from this package in your build plugin. &lt;code&gt;CachingCompiler&lt;/code&gt; is for compilers that consider each file completely independently; &lt;code&gt;MultiFileCachingCompiler&lt;/code&gt; is for compilers that allow files to reference each other. To get this class in your plugin namespace, add a dependency to the plugin definition:</source>
          <target state="translated">메모리 내 캐시와 디스크 내 캐시를 모두 유지하는 일반적인 논리 대부분을 구현하는 &lt;code&gt;caching-compiler&lt;/code&gt; 라는 핵심 패키지 가 있습니다. 캐싱을 올바르게 구현하는 가장 쉬운 방법은 빌드 플러그인의이 패키지에서 &lt;code&gt;CachingCompiler&lt;/code&gt; 또는 &lt;code&gt;MultiFileCachingCompiler&lt;/code&gt; 클래스 를 서브 클래 싱하는 것입니다 . &lt;code&gt;CachingCompiler&lt;/code&gt; 는 각 파일을 완전히 독립적으로 고려하는 컴파일러 용입니다. &lt;code&gt;MultiFileCachingCompiler&lt;/code&gt; 는 파일이 서로 참조 할 수 있도록하는 컴파일러를위한 것입니다. 플러그인 네임 스페이스에서이 클래스를 가져 오려면 플러그인 정의에 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6d7ba477b67bd7644f00634976ebf7c00089618a" translate="yes" xml:space="preserve">
          <source>There is a package for logging in with Weibo, but it is no longer being actively maintained.</source>
          <target state="translated">Weibo로 로그인하기위한 패키지가 있지만 더 이상 적극적으로 유지 보수되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0675137be3d2503602c9c45a075ffbecacf390da" translate="yes" xml:space="preserve">
          <source>There is a special top-level directory named &lt;code&gt;cordova-build-override/&lt;/code&gt; that allows you to override, in an ad-hoc way, parts of your Cordova project that Meteor generates for you in the &lt;code&gt;.meteor/local/cordova-build&lt;/code&gt; directory. The entire file tree of this directory will be &lt;code&gt;cp -R&lt;/code&gt; (copied overwriting existing files) to the Cordova project right before the build and compilation step.</source>
          <target state="translated">&lt;code&gt;cordova-build-override/&lt;/code&gt; 라는 특별한 최상위 디렉토리가 있으며, 이를 통해 Meteor가 &lt;code&gt;.meteor/local/cordova-build&lt;/code&gt; 디렉토리 에서 생성 한 Cordova 프로젝트의 일부를 임시 방식으로 대체 할 수 있습니다 . 이 디렉토리의 전체 파일 트리는 빌드 및 컴파일 단계 직전에 Cordova 프로젝트에 &lt;code&gt;cp -R&lt;/code&gt; (기존 파일을 덮어 쓴 복사 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="251b75c3cf94838235667d95e75c2d48cb410ab8" translate="yes" xml:space="preserve">
          <source>There is a third way to use a collection in Meteor. On the client or server, if you create a collection in one of these two ways:</source>
          <target state="translated">Meteor에서 컬렉션을 사용하는 세 번째 방법이 있습니다. 클라이언트 또는 서버에서 다음 두 가지 방법 중 하나로 콜렉션을 작성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="184bcfb237dc3a9a373f09cead584292fd3ae177" translate="yes" xml:space="preserve">
          <source>There is no need to use Android Studio if you prefer a stand-alone install. Just make sure you install the most recent versions of the &lt;a href=&quot;http://developer.android.com/sdk/index.html#Other&quot;&gt;Android SDK Tools&lt;/a&gt; and download the required &lt;a href=&quot;http://developer.android.com/sdk/installing/adding-packages.html&quot;&gt;additional packages&lt;/a&gt; yourself using the &lt;a href=&quot;http://developer.android.com/tools/help/sdk-manager.html&quot;&gt;Android SDK Manager&lt;/a&gt;.</source>
          <target state="translated">독립형 설치를 선호하는 경우 Android Studio를 사용할 필요가 없습니다. 최신 버전의 &lt;a href=&quot;http://developer.android.com/sdk/index.html#Other&quot;&gt;Android SDK 도구&lt;/a&gt; 를 설치 하고 &lt;a href=&quot;http://developer.android.com/tools/help/sdk-manager.html&quot;&gt;Android SDK 관리자를&lt;/a&gt; 사용하여 필요한 &lt;a href=&quot;http://developer.android.com/sdk/installing/adding-packages.html&quot;&gt;추가 패키지를&lt;/a&gt; 직접 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="60536baf67b087ae397279b17bac6d9f9583412b" translate="yes" xml:space="preserve">
          <source>There is no need to use Android Studio if you prefer a stand-alone install. Just make sure you install the most recent versions of the &lt;a href=&quot;https://developer.android.com/sdk/index.html#Other&quot;&gt;Android SDK Tools&lt;/a&gt; and download the required &lt;a href=&quot;https://developer.android.com/sdk/installing/adding-packages.html&quot;&gt;additional packages&lt;/a&gt; yourself using the &lt;a href=&quot;https://developer.android.com/tools/help/sdk-manager.html&quot;&gt;Android SDK Manager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe6efa47a0fe8274a5583e2a7b872695d5c6d1d" translate="yes" xml:space="preserve">
          <source>There is no way to make a package-scope variable from a &lt;code&gt;.coffee&lt;/code&gt; file other than exporting it. We couldn&amp;rsquo;t figure out a way to make this fit naturally inside the CoffeeScript language. If you want to use package-scope variables with CoffeeScript, one way is to make a short &lt;code&gt;.js&lt;/code&gt; file that declares all of your package-scope variables. They can then be used and assigned to from &lt;code&gt;.coffee&lt;/code&gt; files.</source>
          <target state="translated">내보내기 이외 의 &lt;code&gt;.coffee&lt;/code&gt; 파일 에서 package-scope 변수를 만들 수있는 방법이 없습니다 . CoffeeScript 언어에 자연스럽게 적용 할 수있는 방법을 찾지 못했습니다. CoffeeScript와 함께 패키지 범위 변수를 사용하려는 경우 한 가지 방법은 모든 패키지 범위 변수를 선언 하는 짧은 &lt;code&gt;.js&lt;/code&gt; 파일 을 만드는 것 입니다. 그런 다음 &lt;code&gt;.coffee&lt;/code&gt; 파일 에서 사용 및 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f89804adfbd1890343bdde871e3f79d9613a1d" translate="yes" xml:space="preserve">
          <source>There is ongoing work in the Cordova project that will improve this situation and make it easier for plugins to specify their platform dependencies, so Cordova can determine compatible versions.</source>
          <target state="translated">Cordova 프로젝트에는 이러한 상황을 개선하고 플러그인이 플랫폼 종속성을 쉽게 지정할 수 있도록 진행중인 작업이 있으므로 Cordova는 호환 가능한 버전을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfb2dcddd69bdf56e8fea78278201a4bbf2ca9f" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a lot of scope for better isolation and testing utilities.</source>
          <target state="translated">더 나은 분리 및 테스트 유틸리티를위한 다양한 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="904c13513264628b49aa329ab4057be303f110f9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a tempting existing field called &lt;code&gt;profile&lt;/code&gt; that is added by default when a new user registers. This field was historically intended to be used as a scratch pad for user-specific data - maybe their image avatar, name, intro text, etc. Because of this, &lt;strong&gt;the &lt;code&gt;profile&lt;/code&gt; field on every user is automatically writeable by that user from the client&lt;/strong&gt;. It&amp;rsquo;s also automatically published to the client for that particular user.</source>
          <target state="translated">새로운 사용자가 등록 할 때 기본적으로 추가되는 &lt;code&gt;profile&lt;/code&gt; 이라는 유혹적인 기존 필드 가 있습니다. 이 필드는 역사적으로 사용자 별 데이터를위한 스크래치 패드로 사용되었습니다. 이미지 아바타, 이름, 소개 텍스트 등일 수 있습니다.이 때문에 &lt;strong&gt;모든 사용자 &lt;/strong&gt;&lt;strong&gt;의 &lt;code&gt;profile&lt;/code&gt; 필드는 해당 사용자가 클라이언트에서 자동으로 쓸 수&lt;/strong&gt; 있습니다. 또한 특정 사용자를 위해 클라이언트에 자동으로 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="a078125e6fb6f9cf6e07d3afe9afdbe13358796a" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also an even more restricted type of reusable component, a &amp;ldquo;pure&amp;rdquo; component, which does not have any internal state. For instance in the Todos app, the &lt;code&gt;Todos_item&lt;/code&gt; template decides what to render solely based on its arguments. Pure components are even easier to reason about and test than reusable ones and so should be preferred wherever possible.</source>
          <target state="translated">내부 상태가없는 &quot;순수한&quot;구성 요소 인 재사용 가능한 구성 요소 유형이 훨씬 제한되어 있습니다. 예를 들어 Todos 앱에서 &lt;code&gt;Todos_item&lt;/code&gt; 템플릿은 인수를 기반으로 단독으로 렌더링 할 대상을 결정합니다. 순수한 구성 요소는 재사용 가능한 구성 요소보다 추론 및 테스트가 훨씬 쉬우므로 가능하면 선호하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1d10271641a82dc525695dafaf181e6eed96146c" translate="yes" xml:space="preserve">
          <source>Therefore, when you include &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt;, Spacebars hides the data context of the calling template, and any data contexts established in the template by &lt;code&gt;#each&lt;/code&gt; and &lt;code&gt;#with&lt;/code&gt;. They are not visible to the content block, even via &lt;code&gt;..&lt;/code&gt;. Put another way, it&amp;rsquo;s as if the &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; inclusion occurred at the location where &lt;code&gt;{{#unless}}&lt;/code&gt; was invoked, as far as the data context stack is concerned.</source>
          <target state="translated">따라서 포함 할 때 &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; , Spacebars는 호출 템플릿의 데이터 컨텍스트 및하여 템플릿에 설립 된 모든 데이터 컨텍스트 숨 깁니다 &lt;code&gt;#each&lt;/code&gt; 및 &lt;code&gt;#with&lt;/code&gt; 을 . 그들은 심지어 통해, 내용 블록에 표시되지 않습니다 &lt;code&gt;..&lt;/code&gt; . . 다시 &lt;code&gt;{{#unless}}&lt;/code&gt; , 데이터 컨텍스트 스택에 관한 한 {{#unless}} 가 호출 된 위치에서 &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; 포함이 발생한 것처럼 보입니다 .</target>
        </trans-unit>
        <trans-unit id="0fb4dc7b086310844026b5109a868ecfb50eaa5c" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;main.js&lt;/code&gt; files won&amp;rsquo;t do anything themselves, but they should import some &lt;em&gt;startup&lt;/em&gt; modules which will run immediately, on client and server respectively, when the app loads. These modules should do any configuration necessary for the packages you are using in your app, and import the rest of your app&amp;rsquo;s code.</source>
          <target state="translated">이 &lt;code&gt;main.js&lt;/code&gt; 파일은 자체적으로 아무것도하지 않지만 앱이로드 될 때 클라이언트와 서버에서 각각 즉시 실행되는 일부 &lt;em&gt;시작&lt;/em&gt; 모듈을 가져와야 합니다. 이 모듈은 앱에서 사용중인 패키지에 필요한 구성을 수행하고 나머지 앱 코드를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8c668bbb50dc31bc7ad377168e8cd34efdfa7e" translate="yes" xml:space="preserve">
          <source>These callbacks are called when an occurrence of a template is taken off the page for any reason and not replaced with a re-rendering. Inside a callback, &lt;code&gt;this&lt;/code&gt; is the &lt;a href=&quot;templates#Template-instances&quot;&gt;template instance&lt;/a&gt; object being destroyed.</source>
          <target state="translated">이러한 콜백은 템플릿 발생이 어떤 이유로 든 페이지에서 제거되어 다시 렌더링으로 대체되지 않을 때 호출됩니다. 콜백 내부, &lt;code&gt;this&lt;/code&gt; 는 IS &lt;a href=&quot;templates#Template-instances&quot;&gt;템플릿 인스턴스&lt;/a&gt; 파괴되는 객체.</target>
        </trans-unit>
        <trans-unit id="ad6368edeb141c9a5233fbf9cf37e2d787311f9b" translate="yes" xml:space="preserve">
          <source>These callbacks fire once and are the first group of callbacks to fire. Handling the &lt;code&gt;created&lt;/code&gt; event is a useful way to set up values on template instance that are read from template helpers using &lt;code&gt;Template.instance()&lt;/code&gt;.</source>
          <target state="translated">이 콜백은 한 번만 실행되며 첫 번째 콜백 그룹입니다. &lt;code&gt;created&lt;/code&gt; 이벤트를 처리하는 것은 &lt;code&gt;Template.instance()&lt;/code&gt; 사용하여 템플리트 헬퍼에서 읽은 템플리트 인스턴스에서 값을 설정하는 유용한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="9ac06c44043110df5a9f32a56f7326ea9c7b464e" translate="yes" xml:space="preserve">
          <source>These checks are run only when a client tries to write to the database directly, for example by calling &lt;code&gt;update&lt;/code&gt; from inside an event handler. Server code is trusted and isn&amp;rsquo;t subject to &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;deny&lt;/code&gt; restrictions. That includes methods that are called with &lt;code&gt;Meteor.call&lt;/code&gt; &amp;mdash; they are expected to do their own access checking rather than relying on &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;deny&lt;/code&gt;.</source>
          <target state="translated">이러한 검사는 클라이언트가 이벤트 핸들러 내부에서 &lt;code&gt;update&lt;/code&gt; 를 호출하여 데이터베이스에 직접 쓰려고 할 때만 실행됩니다 . 서버 코드는 신뢰할 &lt;code&gt;allow&lt;/code&gt; 있으며 제한 을 허용 하거나 &lt;code&gt;deny&lt;/code&gt; 하지 않습니다 . 여기에는 &lt;code&gt;Meteor.call&lt;/code&gt; 을 통해 호출 된 메소드가 포함됩니다 . &lt;code&gt;allow&lt;/code&gt; 및 &lt;code&gt;deny&lt;/code&gt; 에 의존하기보다는 자체 액세스 점검을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0472ebc553ae1a2a8b1a21ce12a92864782fec0d" translate="yes" xml:space="preserve">
          <source>These days, the landscape of JavaScript tools and frameworks is constantly shifting, and the language itself is evolving just as rapidly. It&amp;rsquo;s no longer reasonable to wait for web browsers to implement the language features you want to use. Most JavaScript development workflows rely on compiling code to work on the lowest common denominator of environments, while letting you use the newest features in development. Meteor has support for some of the most popular tools out of the box.</source>
          <target state="translated">요즘 JavaScript 도구와 프레임 워크의 환경은 끊임없이 변화하고 있으며 언어 자체도 빠르게 발전하고 있습니다. 더 이상 웹 브라우저가 사용하려는 언어 기능을 구현할 때까지 기다리는 것이 합리적이지 않습니다. 대부분의 JavaScript 개발 워크 플로우는 개발 환경에서 최신 기능을 사용할 수있게하면서 가장 일반적인 환경 분모에서 작동하도록 코드를 컴파일합니다. Meteor는 가장 널리 사용되는 몇 가지 도구를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0462e62c402247a57e8f7002d0a85b243ae39cbc" translate="yes" xml:space="preserve">
          <source>These declarations make the variables &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; (and so on) available not only within the scope of the &lt;code&gt;exporter.js&lt;/code&gt; module, but also to other modules that &lt;code&gt;import&lt;/code&gt; from &lt;code&gt;exporter.js&lt;/code&gt;.</source>
          <target state="translated">이러한 변수 선언 할 , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 의 범위 내에서뿐만 아니라, 가능한 (등) &lt;code&gt;exporter.js&lt;/code&gt; 의 모듈뿐만 아니라 다른 모듈에 해당 &lt;code&gt;import&lt;/code&gt; 에서 &lt;code&gt;exporter.js&lt;/code&gt; 를 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa30eaf1ec7e1a6cff7a8ca0df382678b559449a" translate="yes" xml:space="preserve">
          <source>These examples should get you started with &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax. For further reading, here is a very detailed &lt;a href=&quot;http://www.2ality.com/2014/09/es6-modules-final.html&quot;&gt;explanation&lt;/a&gt; by &lt;a href=&quot;https://twitter.com/rauschma&quot;&gt;Axel Rauschmayer&lt;/a&gt; of every variation of &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax.</source>
          <target state="translated">이 예제는 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 구문으로 시작해야 합니다. 자세한 &lt;a href=&quot;http://www.2ality.com/2014/09/es6-modules-final.html&quot;&gt;내용&lt;/a&gt; 은 &lt;a href=&quot;https://twitter.com/rauschma&quot;&gt;Axel Rauschmayer&lt;/a&gt; 의 모든 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 구문 변형에 대한 자세한 설명 입니다.</target>
        </trans-unit>
        <trans-unit id="86ffc0e598a4abbfe59e37179c7768598dbd5db6" translate="yes" xml:space="preserve">
          <source>These functions control how Meteor servers publish sets of records and how clients can subscribe to those sets.</source>
          <target state="translated">이 기능은 Meteor 서버가 레코드 세트를 게시하는 방법과 클라이언트가 해당 세트를 구독 할 수있는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="413e991212ab4f5b5a723391d1126b6621314b66" translate="yes" xml:space="preserve">
          <source>These functions initiate the login process with an external service (eg: Facebook, Google, etc), using OAuth. When called they open a new pop-up window that loads the provider&amp;rsquo;s login page. Once the user has logged in with the provider, the pop-up window is closed and the Meteor client logs in to the Meteor server with the information provided by the external service.</source>
          <target state="translated">이러한 기능은 OAuth를 사용하여 외부 서비스 (예 : Facebook, Google 등)로 로그인 프로세스를 시작합니다. 호출되면 제공자의 로그인 페이지를로드하는 새 팝업 창을 엽니 다. 사용자가 제공자에 로그인하면 팝업 창이 닫히고 Meteor 클라이언트는 외부 서비스에서 제공 한 정보를 사용하여 Meteor 서버에 로그인합니다.</target>
        </trans-unit>
        <trans-unit id="f173cac486c90f6e2b82eb2f5a948c07b6f5903d" translate="yes" xml:space="preserve">
          <source>These functions manage and inspect the network connection between the Meteor client and server.</source>
          <target state="translated">이 기능은 Meteor 클라이언트와 서버 간의 네트워크 연결을 관리하고 검사합니다.</target>
        </trans-unit>
        <trans-unit id="77ecb52a72d05d652813dad8d51a58ce85f791f1" translate="yes" xml:space="preserve">
          <source>These functions return an object with a single method, &lt;code&gt;stop&lt;/code&gt;. Calling &lt;code&gt;stop()&lt;/code&gt; unregisters the callback.</source>
          <target state="translated">이 함수는 단일 메소드 &lt;code&gt;stop&lt;/code&gt; 으로 객체를 반환합니다 . &lt;code&gt;stop()&lt;/code&gt; 호출 하면 콜백이 등록 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5e0a2b593413ab6cf5bbff134c8ade7f0cfd0d20" translate="yes" xml:space="preserve">
          <source>These functions work just like their native JavaScript equivalents. If you call the native function, you&amp;rsquo;ll get an error stating that Meteor code must always run within a Fiber, and advising to use &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt;.</source>
          <target state="translated">이러한 함수는 기본 JavaScript와 동일하게 작동합니다. 기본 함수를 호출하면 Meteor 코드가 항상 Fibre 내에서 실행되어야하며 &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; 사용을 권장 한다는 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="687e7b274a6eae98d2e66cec678c87ccb2d9bf12" translate="yes" xml:space="preserve">
          <source>These include some notable differences like:</source>
          <target state="translated">여기에는 다음과 같은 몇 가지 주목할만한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66dafb931800467947ce0ab24f061cc337d9ed82" translate="yes" xml:space="preserve">
          <source>These methods are defined on &lt;code&gt;AccountsClient.prototype&lt;/code&gt;, and are thus available only on the client:</source>
          <target state="translated">이러한 메소드는 &lt;code&gt;AccountsClient.prototype&lt;/code&gt; 에 정의되어 있으므로 클라이언트에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76aec7f369ba86f9b87f342cec6d5acb90f5cf8a" translate="yes" xml:space="preserve">
          <source>These methods are defined on &lt;code&gt;AccountsServer.prototype&lt;/code&gt;, and are thus available only on the server:</source>
          <target state="translated">이러한 메소드는 &lt;code&gt;AccountsServer.prototype&lt;/code&gt; 에 정의되어 있으므로 서버에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52712d93b5313cf282a026010bf4fe32ddf1e70a" translate="yes" xml:space="preserve">
          <source>These packages don&amp;rsquo;t do anything in development or production mode. They declare themselves &lt;code&gt;testOnly&lt;/code&gt; so they are not even loaded outside of testing. But when our app is run in &lt;a href=&quot;#test-modes&quot;&gt;test mode&lt;/a&gt;, the test driver package takes over, executing test code on both the client and server, and rendering results to the browser.</source>
          <target state="translated">이 패키지는 개발 또는 프로덕션 모드에서 아무것도하지 않습니다. 그들은 &lt;code&gt;testOnly&lt;/code&gt; 를 선언 하므로 테스트 외부에도로드되지 않습니다. 그러나 앱이 &lt;a href=&quot;#test-modes&quot;&gt;테스트 모드&lt;/a&gt; 에서 실행 되면 테스트 드라이버 패키지가 대신 클라이언트와 서버에서 테스트 코드를 실행하고 결과를 브라우저에 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="1df35b5cd39963e0ef7b946e9d1dad130ae27137" translate="yes" xml:space="preserve">
          <source>These rate limiting rules can be removed by calling &lt;code&gt;Accounts.removeDefaultRateLimit()&lt;/code&gt;. Please see the &lt;a href=&quot;#ddpratelimiter&quot;&gt;&lt;code&gt;DDPRateLimiter&lt;/code&gt;&lt;/a&gt; docs for more information.</source>
          <target state="translated">이러한 속도 제한 규칙은 &lt;code&gt;Accounts.removeDefaultRateLimit()&lt;/code&gt; 를 호출하여 제거 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#ddpratelimiter&quot;&gt; &lt;code&gt;DDPRateLimiter&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="091be4fe8840d9c388f77334a0339ebc333e19dd" translate="yes" xml:space="preserve">
          <source>These should never be stored as part of your app&amp;rsquo;s source code in version control, because developers might copy code around to unexpected places and forget that it contains secret keys. You can keep your keys separately in &lt;a href=&quot;https://www.dropbox.com/&quot;&gt;Dropbox&lt;/a&gt;, &lt;a href=&quot;https://lastpass.com&quot;&gt;LastPass&lt;/a&gt;, or another service, and then reference them when you need to deploy the app.</source>
          <target state="translated">개발자가 예기치 않은 장소로 코드를 복사하고 비밀 키가 포함되어 있음을 잊어 버릴 수 있기 때문에 버전 관리에서 앱 소스 코드의 일부로 저장해서는 안됩니다. &lt;a href=&quot;https://www.dropbox.com/&quot;&gt;Dropbox&lt;/a&gt; , &lt;a href=&quot;https://lastpass.com&quot;&gt;LastPass&lt;/a&gt; 또는 다른 서비스 에 키를 별도로 보관 한 다음 앱을 배포해야 할 때 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a445af3d040c25b8330c9363849d6ce9a55beda7" translate="yes" xml:space="preserve">
          <source>These two Sass files will be lazily evaluated and only included in the CSS of the app if imported from some other file.</source>
          <target state="translated">이 두 Sass 파일은 느리게 평가되며 다른 파일에서 가져온 경우에만 앱의 CSS에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4a401db56f47d9c403aef3a45748c136d372f7f2" translate="yes" xml:space="preserve">
          <source>They all have their pros and cons, and different people have different preferences, just like with JavaScript transpiled languages. The most popular one at the time of writing seems to be Sass with the SCSS syntax. Popular CSS frameworks like Bootstrap 4 and more are switching to Sass, and the C++ LibSass implementation appears to be faster than some of the other compilers available.</source>
          <target state="translated">그들은 모두 장단점이 있으며 JavaScript 번역 언어와 마찬가지로 다른 사람들이 선호도가 다릅니다. 글을 쓰는 시점에서 가장 인기있는 것은 SCSS 구문을 사용하는 Sass 인 것 같습니다. Bootstrap 4 이상과 같은 인기있는 CSS 프레임 워크는 Sass로 전환하고 있으며 C ++ LibSass 구현은 사용 가능한 다른 컴파일러보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="404ff9c7ee74b794fd80c600e63432c861667cb4" translate="yes" xml:space="preserve">
          <source>They are easy to add to component style guides&amp;mdash;as we&amp;rsquo;ll see in the section about &lt;a href=&quot;#styleguides&quot;&gt;component style guides&lt;/a&gt;, when creating a style guide, a clean environment makes things much easier to work with.</source>
          <target state="translated">구성 요소 스타일 안내서에 추가하기가 쉽습니다. 구성 요소 스타일 안내서 섹션에서 알 수 있듯이 &lt;a href=&quot;#styleguides&quot;&gt;스타일 안내서&lt;/a&gt; 를 작성할 때 깨끗한 환경에서는 작업을 훨씬 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0204351e627ad69ea6062bf41e41cc9a672796b0" translate="yes" xml:space="preserve">
          <source>They are easy to reason about&amp;mdash;you don&amp;rsquo;t need to understand how the data in the global store changes, simply how the arguments to the component change.</source>
          <target state="translated">전역 저장소의 데이터가 어떻게 변경되는지, 구성 요소에 대한 인수가 어떻게 변경되는지 이해할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff28052343adf56ab51445577eee9880f6365bad" translate="yes" xml:space="preserve">
          <source>They are easy to test&amp;mdash;you don&amp;rsquo;t need to be careful about the environment you render them in, all you need to do is provide the right arguments.</source>
          <target state="translated">테스트하기 쉬우므로 렌더링 환경에주의를 기울일 필요가 없습니다. 올바른 인수를 제공하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0c439fbad9298eea7eb6b9df98a9f29741aa80e6" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the argument to the &lt;code&gt;#each&lt;/code&gt; reactively changes between different cursor objects, or between arrays of plain JavaScript objects that may not be identified clearly. The implementation of &lt;code&gt;#each&lt;/code&gt; tries to be intelligent without doing too much expensive work. Specifically, it tries to identify items between the old and new array or cursor with the following strategy:</source>
          <target state="translated">&lt;code&gt;#each&lt;/code&gt; 에 대한 인수가 다른 커서 객체간에 또는 명확하게 식별되지 않을 수있는 일반 JavaScript 객체의 어레이간에 반응 적으로 바뀌면 상황이 더 복잡해집니다 . &lt;code&gt;#each&lt;/code&gt; 의 구현은 너무 많은 비용을 들이지 않고 지능적으로 노력합니다. 특히 다음 전략을 사용하여 이전 배열과 새 배열 또는 커서 사이의 항목을 식별하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7786d1c21c37e7d0448b609968b761e8a555c3be" translate="yes" xml:space="preserve">
          <source>Things can get more complicated; for instance you may want to deal with documents being removed, or share the work of polling between multiple users (in a case where the data being polled isn&amp;rsquo;t private to that user), rather than doing the exact same poll for each interested user.</source>
          <target state="translated">상황이 더 복잡해질 수 있습니다. 예를 들어 관심있는 각 사용자에 대해 동일한 설문 조사를 수행하기보다는 제거중인 문서를 처리하거나 여러 사용자 (폴링중인 데이터가 해당 사용자의 개인 정보가 아닌 경우)간에 폴링 작업을 공유 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="0576eeb506460b5dccf03d1672ed987f9bdfe8f4" translate="yes" xml:space="preserve">
          <source>This Method doesn&amp;rsquo;t modify the other user, but uses it as a target; for example, it could be a Method for sending a private message, or adding a user as a friend.</source>
          <target state="translated">이 방법은 다른 사용자를 수정하지는 않지만 대상으로 사용합니다. 예를 들어 개인 메시지를 보내거나 사용자를 친구로 추가하는 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea561a8f044f7b9be6d1c2784007839ecff81d6" translate="yes" xml:space="preserve">
          <source>This Method is callable from the client and server using &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_call&quot;&gt;&lt;code&gt;Meteor.call&lt;/code&gt;&lt;/a&gt;. Note that you should only use a Method in the case where some code needs to be callable from the client; if you just want to modularize code that is only going to be called from the server, use a regular JavaScript function, not a Method.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_call&quot;&gt; &lt;code&gt;Meteor.call&lt;/code&gt; 을&lt;/a&gt; 사용하여 클라이언트와 서버에서 호출 할 수 있습니다 . 클라이언트에서 일부 코드를 호출 할 수있는 경우에만 메소드를 사용해야합니다. 서버에서만 호출되는 코드를 모듈화하려는 경우 메소드가 아닌 일반 JavaScript 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e27bf202267e291c40855efdc53a65423f72cf0" translate="yes" xml:space="preserve">
          <source>This Sass file will be eagerly evaluated and its compiled form will be added to the CSS of the app immediately.</source>
          <target state="translated">이 Sass 파일은 열심히 평가되며 컴파일 된 양식은 앱의 CSS에 즉시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb333b750d679d2f9e108958e92d320df6a97d3" translate="yes" xml:space="preserve">
          <source>This built-in feature means that you always get &lt;code&gt;this.userId&lt;/code&gt; inside Methods and Publications, and can access the user ID on the client. This is a great starting point for building your own custom accounts system, but most developers won&amp;rsquo;t need to worry about the mechanics, since you&amp;rsquo;ll mostly be interacting with the &lt;code&gt;accounts-base&lt;/code&gt; package instead.</source>
          <target state="translated">이 기본 제공 기능은 항상 Methods and Publications 내에서 &lt;code&gt;this.userId&lt;/code&gt; 를 가져 오고 클라이언트의 사용자 ID에 액세스 할 수 있음을 의미합니다 . 이것은 자신 만의 맞춤 계정 시스템을 구축하기위한 좋은 출발점이지만 대부분의 개발자는 대신 &lt;code&gt;accounts-base&lt;/code&gt; 패키지 와 상호 작용하기 때문에 메커니즘에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1494ff5c828d1c003edc7baff04b7cdc0cd7dcd4" translate="yes" xml:space="preserve">
          <source>This call to &lt;code&gt;Accounts.config&lt;/code&gt; should be made at load time (place at the top level of your source file), not called from inside of a &lt;code&gt;Meteor.startup&lt;/code&gt; block.</source>
          <target state="translated">이 &lt;code&gt;Accounts.config&lt;/code&gt; 호출 은 &lt;code&gt;Meteor.startup&lt;/code&gt; 블록 내부에서 호출되지 않고로드시 (소스 파일의 최상위 레벨에 위치) 수행 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="00dda21f71615faabea32336583a89e5ba8843f6" translate="yes" xml:space="preserve">
          <source>This can be a good place to apply any DOM manipulations you want, after the template is rendered for the first time.</source>
          <target state="translated">템플릿을 처음으로 렌더링 한 후 원하는 DOM 조작을 적용하기에 좋은 위치입니다.</target>
        </trans-unit>
        <trans-unit id="49b610f7e6d70f00ad635cc0e9f0a628d173b1cc" translate="yes" xml:space="preserve">
          <source>This can be called multiple times. If any of the functions return &lt;code&gt;false&lt;/code&gt; or throw an error, the new user creation is aborted. To set a specific error message (which will be displayed by &lt;a href=&quot;#accountsui&quot;&gt;&lt;code&gt;accounts-ui&lt;/code&gt;&lt;/a&gt;), throw a new &lt;a href=&quot;#meteor_error&quot;&gt;&lt;code&gt;Meteor.Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 번 호출 할 수 있습니다. 함수 중 하나라도 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 오류가 발생하면 새 사용자 생성이 중단됩니다. &lt;a href=&quot;#accountsui&quot;&gt; &lt;code&gt;accounts-ui&lt;/code&gt; &lt;/a&gt; 로 표시 될 특정 오류 메시지를 설정하려면 새 &lt;a href=&quot;#meteor_error&quot;&gt; &lt;code&gt;Meteor.Error&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba9c26adcd09a8462852af3edd373ed19e4f6ea3" translate="yes" xml:space="preserve">
          <source>This can be used to save battery on mobile devices when real time updates are not required.</source>
          <target state="translated">실시간 업데이트가 필요하지 않은 경우 모바일 장치에서 배터리를 절약하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94cd2c64f57ec94ff31140e50d2d1b56d6fb9068" translate="yes" xml:space="preserve">
          <source>This can be useful if you have a function that accepts several different kinds of objects, and you want to determine which was passed in.</source>
          <target state="translated">여러 종류의 객체를 받아들이고 전달 된 함수를 결정하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd1d4c62c7a1bea960b0474218c6c81157bcc3a" translate="yes" xml:space="preserve">
          <source>This class represents a symbolic error thrown by a method.</source>
          <target state="translated">이 클래스는 메소드에 의해 발생 된 기호 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="64724a799ae7bd0e491ad9115cd1f1b4cb55d6c0" translate="yes" xml:space="preserve">
          <source>This class should be defined inside a file called &lt;code&gt;ClickCounter.js&lt;/code&gt;. When you import it, it&amp;rsquo;ll look like this:</source>
          <target state="translated">이 클래스는 &lt;code&gt;ClickCounter.js&lt;/code&gt; 파일 내에 정의되어야합니다 . 가져 오면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="089e6d34c258f08d8e6ca86a1401d84507dfa237" translate="yes" xml:space="preserve">
          <source>This collection contains one document per registered user. Here&amp;rsquo;s an example user document:</source>
          <target state="translated">이 모음에는 등록 된 사용자 당 하나의 문서가 포함되어 있습니다. 예제 사용자 문서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87ab89ad8bc8b00f4ed6f86ade9f3d7e6855af73" translate="yes" xml:space="preserve">
          <source>This content has moved to the &lt;a href=&quot;http://blazejs.org/guide/introduction.html&quot;&gt;Blaze Community Site&lt;/a&gt;.</source>
          <target state="translated">이 콘텐츠는 &lt;a href=&quot;http://blazejs.org/guide/introduction.html&quot;&gt;Blaze 커뮤니티 사이트&lt;/a&gt; 로 이동했습니다 .</target>
        </trans-unit>
        <trans-unit id="e6303c4721a1e16fb0eb3ba65404169967013c6d" translate="yes" xml:space="preserve">
          <source>This continues until the client &lt;a href=&quot;#stopping-subscriptions&quot;&gt;stops&lt;/a&gt; the subscription, triggering the following behavior:</source>
          <target state="translated">이는 클라이언트 &lt;a href=&quot;#stopping-subscriptions&quot;&gt;가&lt;/a&gt; 구독을 중지 할 때까지 계속 되어 다음 동작을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="04f3e1b2e189c27c21d8fa1593eb85dba46a4976" translate="yes" xml:space="preserve">
          <source>This creates a &lt;em&gt;local collection&lt;/em&gt;. This is a Minimongo collection that has no database connection (ordinarily a collection would either be directly connected to the database on the server, or via a subscription on the client).</source>
          <target state="translated">&lt;em&gt;로컬 컬렉션을&lt;/em&gt; 만듭니다 . 이것은 데이터베이스 연결이없는 Minimongo 모음입니다 (보통 모음은 서버의 데이터베이스에 직접 연결되거나 클라이언트의 구독을 통해 수집 됨).</target>
        </trans-unit>
        <trans-unit id="cfa530bf2a13ea8bbfe14b7270456e8e605460bd" translate="yes" xml:space="preserve">
          <source>This default export may then be imported without curly braces, using any name the importing module chooses:</source>
          <target state="translated">그런 다음 가져 오기 모듈에서 선택한 이름을 사용하여 중괄호없이이 기본 내보내기를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76024cf2694aebadfd1b2ceeea8dacb89817643" translate="yes" xml:space="preserve">
          <source>This deletes your data! Make sure you do not have any information you care about in your local mongo database by running &lt;code&gt;meteor mongo&lt;/code&gt;. From the mongo shell, use &lt;code&gt;show collections&lt;/code&gt; and &lt;code&gt;db.&lt;i&gt;collection&lt;/i&gt;.find()&lt;/code&gt; to inspect your data.</source>
          <target state="translated">데이터가 삭제됩니다! &lt;code&gt;meteor mongo&lt;/code&gt; 를 실행하여 로컬 몽고 데이터베이스에 관심있는 정보가 없는지 확인하십시오 . mongo 쉘에서 &lt;code&gt;show collections&lt;/code&gt; 및 &lt;code&gt;db.&lt;i&gt;collection&lt;/i&gt;.find()&lt;/code&gt; 사용 하십시오. &lt;i&gt;collection&lt;/i&gt; .find () 를 사용하여 데이터를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="c158f9fcf362fbb1d28056dfb42a24467b8e8f7c" translate="yes" xml:space="preserve">
          <source>This documentation has moved to the &lt;a href=&quot;http://blazejs.org/guide/spacebars.html&quot;&gt;Blaze Community Site&lt;/a&gt;.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;http://blazejs.org/guide/spacebars.html&quot;&gt;Blaze 커뮤니티 사이트&lt;/a&gt; 로 옮겨졌습니다 .</target>
        </trans-unit>
        <trans-unit id="1a0f72edbce4c9f80b70de0ce3e5dc63933cd70c" translate="yes" xml:space="preserve">
          <source>This example for Twitter shows how existing unencrypted user tokens can be encrypted. The query finds user documents which have a Twitter access token but not the &lt;code&gt;algorithm&lt;/code&gt; field which is created when the token is encrypted. The relevant fields in the service data are then encrypted.</source>
          <target state="translated">트위터에 대한이 예는 기존의 암호화되지 않은 사용자 토큰을 암호화하는 방법을 보여줍니다. 쿼리는 Twitter 액세스 토큰은 있지만 토큰이 암호화 될 때 생성되는 &lt;code&gt;algorithm&lt;/code&gt; 필드는 없는 사용자 문서를 찾습니다 . 그런 다음 서비스 데이터의 관련 필드가 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="58eff224482073fbf7b7b1b1a53aac5ad0180eeb" translate="yes" xml:space="preserve">
          <source>This example from the Todos app defines a schema with a few simple rules:</source>
          <target state="translated">Todos 앱의이 예제는 몇 가지 간단한 규칙으로 스키마를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="578956aae973a0288f7a3df64f0683166bf8f2a2" translate="yes" xml:space="preserve">
          <source>This example implements a weather data source with a simple getter and setter. The getter records that the current computation depends on the &lt;code&gt;weatherDep&lt;/code&gt; dependency using &lt;code&gt;depend()&lt;/code&gt;, while the setter signals the dependency to invalidate all dependent computations by calling &lt;code&gt;changed()&lt;/code&gt;.</source>
          <target state="translated">이 예제는 간단한 getter 및 setter를 사용하여 날씨 데이터 소스를 구현합니다. getter는 &lt;code&gt;depend()&lt;/code&gt; 사용하여 현재 계산이 &lt;code&gt;weatherDep&lt;/code&gt; 종속성 에 의존한다는 것을 기록하지만 setter는 &lt;code&gt;changed()&lt;/code&gt; 를 호출하여 모든 종속 계산을 무효화하도록 종속성을 신호합니다 .</target>
        </trans-unit>
        <trans-unit id="b4e770aff09288ae10b2ea6d8f309b9a30fbadee" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;aldeed:simple-schema&lt;/code&gt; package, which is recommended in several other articles, to validate the Method arguments.</source>
          <target state="translated">이 예제는 다른 여러 기사에서 권장되는 &lt;code&gt;aldeed:simple-schema&lt;/code&gt; 패키지 를 사용 하여 Method 인수의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7023a89c76ca1242e1a1925d2d3c73c2c65be3a4" translate="yes" xml:space="preserve">
          <source>This folder is for compatibility with JavaScript libraries that rely on variables declared with var at the top level being exported as globals. Files in this directory are executed without being wrapped in a new variable scope. These files are executed before other client-side JavaScript files.</source>
          <target state="translated">이 폴더는 전역으로 내보내지는 최상위 레벨에서 var로 선언 된 변수에 의존하는 JavaScript 라이브러리와 호환됩니다. 이 디렉토리의 파일은 새 변수 범위에 래핑되지 않고 실행됩니다. 이러한 파일은 다른 클라이언트 측 JavaScript 파일보다 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="888c6b7852db28389681b488182ba14942abf16c" translate="yes" xml:space="preserve">
          <source>This function accepts tokens passed into the callback registered with &lt;a href=&quot;#Accounts-onEmailVerificationLink&quot;&gt;&lt;code&gt;Accounts.onEmailVerificationLink&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#Accounts-onEmailVerificationLink&quot;&gt; &lt;code&gt;Accounts.onEmailVerificationLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백에 전달 된 토큰을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="4e951d6d992488255fc7760222db409da92418b0" translate="yes" xml:space="preserve">
          <source>This function accepts tokens passed into the callbacks registered with &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt;&lt;code&gt;AccountsClient#onResetPasswordLink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Accounts-onEnrollmentLink&quot;&gt;&lt;code&gt;Accounts.onEnrollmentLink&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt; &lt;code&gt;AccountsClient#onResetPasswordLink&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Accounts-onEnrollmentLink&quot;&gt; &lt;code&gt;Accounts.onEnrollmentLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백에 전달 된 토큰을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="853415bfe43c8e5627902fb641ef2fd4dc19a5ed" translate="yes" xml:space="preserve">
          <source>This function initiates an HTTP request to a remote server.</source>
          <target state="translated">이 기능은 원격 서버에 대한 HTTP 요청을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="33d20fd1aee97efaed83300758d99e2ca92322cb" translate="yes" xml:space="preserve">
          <source>This function is only used for creating users with passwords. The external service login flows do not use this function.</source>
          <target state="translated">이 기능은 비밀번호를 사용하여 사용자를 작성하는 데만 사용됩니다. 외부 서비스 로그인 플로우는이 기능을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3710dbe607b3779e72356fb84c019967225df98" translate="yes" xml:space="preserve">
          <source>This function is provided by the &lt;code&gt;accounts-password&lt;/code&gt; package. See the &lt;a href=&quot;#accounts_passwords&quot;&gt;Passwords&lt;/a&gt; section below.</source>
          <target state="translated">이 기능은 &lt;code&gt;accounts-password&lt;/code&gt; 패키지 에서 제공 합니다. 아래의 &lt;a href=&quot;#accounts_passwords&quot;&gt;비밀번호&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bf79919d22e37fb2acdadd71186801ba1a3f125" translate="yes" xml:space="preserve">
          <source>This group of callbacks is most useful for cleaning up or undoing any external effects of &lt;code&gt;created&lt;/code&gt; or &lt;code&gt;rendered&lt;/code&gt; groups. This group fires once and is the last callback to fire.</source>
          <target state="translated">이 콜백 그룹은 &lt;code&gt;created&lt;/code&gt; 되거나 &lt;code&gt;rendered&lt;/code&gt; 그룹 의 외부 효과를 정리하거나 실행 취소 할 때 가장 유용합니다 . 이 그룹은 한 번만 실행되며 마지막으로 실행되는 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="38a6eae8b7ed206fa06d0407ddfd4141f3e7f3d3" translate="yes" xml:space="preserve">
          <source>This guide is quite short and we think you&amp;rsquo;ll find the upgrade from 1.4 to 1.5 quite painless. We encourage reading &lt;a href=&quot;http://docs.meteor.com/changelog.html&quot;&gt;full history&lt;/a&gt; and comparing the full differences between the versions you are upgrading from and to.</source>
          <target state="translated">이 가이드는 매우 짧으며 1.4에서 1.5 로의 업그레이드가 상당히 고통스럽지 않을 것입니다. &lt;a href=&quot;http://docs.meteor.com/changelog.html&quot;&gt;전체 히스토리를&lt;/a&gt; 읽고 업그레이드하는 버전 간의 차이점을 비교하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca8cd2d0b20d19fb3c2c877e3eefe0d87ac148ab" translate="yes" xml:space="preserve">
          <source>This hook is the basis for the &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;created&lt;/code&gt;&lt;/a&gt; template callback.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;created&lt;/code&gt; &lt;/a&gt; 템플릿 콜백 의 기초입니다 .</target>
        </trans-unit>
        <trans-unit id="c9ae260e2f1fc810773fa91da7c3e22097801f4e" translate="yes" xml:space="preserve">
          <source>This hook is the basis for the &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; template callback.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; 템플릿 콜백 의 기초입니다 .</target>
        </trans-unit>
        <trans-unit id="24be87346489f672bc2a3578d4ed560c5fcca9ed" translate="yes" xml:space="preserve">
          <source>This hook is the basis for the &lt;a href=&quot;templates#Template-onRendered&quot;&gt;&lt;code&gt;rendered&lt;/code&gt;&lt;/a&gt; template callback.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;templates#Template-onRendered&quot;&gt; &lt;code&gt;rendered&lt;/code&gt; &lt;/a&gt; 템플릿 콜백 의 기초입니다 .</target>
        </trans-unit>
        <trans-unit id="8670b644668ab6da0b45974fa33e6ff9aaa365cc" translate="yes" xml:space="preserve">
          <source>This imports the default export from the package into the symbol &lt;code&gt;moment&lt;/code&gt;.</source>
          <target state="translated">패키지에서 기본 내보내기를 심볼 &lt;code&gt;moment&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="99a34389d271656974b9c9fa9e1b4f0b498b91a3" translate="yes" xml:space="preserve">
          <source>This integration test can be run the exact same way as we ran &lt;a href=&quot;#running-unit-tests&quot;&gt;unit tests above&lt;/a&gt;.</source>
          <target state="translated">이 통합 테스트는 &lt;a href=&quot;#running-unit-tests&quot;&gt;위의 단위 테스트를&lt;/a&gt; 실행 한 것과 동일한 방식으로 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="001effefd1558355a79e62f14860078c0c8dc165" translate="yes" xml:space="preserve">
          <source>This interface is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.forEach&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.forEach&lt;/a&gt; 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6cbd3c9de88c077284e7b05a3de4407073b52a84" translate="yes" xml:space="preserve">
          <source>This interface is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;Array.map&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;Array.map&lt;/a&gt; 과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c34f87e3793dad1c4b6604e9819cbbbd50b1cf9" translate="yes" xml:space="preserve">
          <source>This is a Method only accessible by admin users, who are allowed to edit other users. See the section about user roles to learn how to check that a user is in a certain role.</source>
          <target state="translated">다른 사용자를 편집 할 수있는 관리자 만 액세스 할 수있는 방법입니다. 사용자가 특정 역할에 있는지 확인하는 방법을 알아 보려면 사용자 역할에 대한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6385fecfa1299ef18c9fcd3297aa13710b6a3016" translate="yes" xml:space="preserve">
          <source>This is a collection of points to check about your app that might catch common errors. However, it&amp;rsquo;s not an exhaustive list yet&amp;mdash;if we missed something, please let us know or file a pull request!</source>
          <target state="translated">일반적인 오류가 발생할 수있는 앱을 확인하기위한 포인트 모음입니다. 그러나 아직 완전한 목록은 아닙니다. 만약 우리가 무언가를 놓쳤다면 저희에게 알려주거나 풀 요청을 제출하십시오!</target>
        </trans-unit>
        <trans-unit id="d48b590dbdc754a6789c10b5ac34b4b30fe1405a" translate="yes" xml:space="preserve">
          <source>This is a set of articles outlining opinions on best-practice application development using the &lt;a href=&quot;https://meteor.com&quot;&gt;Meteor&lt;/a&gt; platform. Our aim is to cover patterns that are common to the development of all modern web and mobile applications, so many concepts documented here are not necessarily Meteor specific and could be applied to any application built with a focus on modern, interactive user interfaces.</source>
          <target state="translated">이 글은 &lt;a href=&quot;https://meteor.com&quot;&gt;Meteor&lt;/a&gt; 플랫폼을 사용한 모범 사례 응용 프로그램 개발에 대한 의견을 요약 한 기사 입니다. 우리의 목표는 모든 최신 웹 및 모바일 애플리케이션 개발에 공통적 인 패턴을 다루는 것이므로 여기에 설명 된 많은 개념이 반드시 Meteor에만 해당되는 것은 아니며 현대적인 대화식 사용자 인터페이스에 중점을 둔 빌드 된 모든 애플리케이션에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9c80f628d09c9720572fe82d2d5a73f6f13b6f" translate="yes" xml:space="preserve">
          <source>This is a very short section, but it deserves its own place in the table of contents.</source>
          <target state="translated">이것은 매우 짧은 섹션이지만 목차에서 자체 위치를 차지할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c9c9d64c69b591b97f3c25e31c84c45419def8" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;Object&lt;/code&gt; with several fields that are used to generate text/html for the emails sent by &lt;code&gt;sendResetPasswordEmail&lt;/code&gt;, &lt;code&gt;sendEnrollmentEmail&lt;/code&gt;, and &lt;code&gt;sendVerificationEmail&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendResetPasswordEmail&lt;/code&gt; , &lt;code&gt;sendEnrollmentEmail&lt;/code&gt; 및 &lt;code&gt;sendVerificationEmail&lt;/code&gt; 이 보낸 전자 메일에 대한 텍스트 / html을 생성하는 데 사용되는 여러 필드 가있는 &lt;code&gt;Object&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1771b35db1ef9be590fa6643f323285f06ff6da3" translate="yes" xml:space="preserve">
          <source>This is constant. However, if the logged-in user changes, the publish function is rerun with the new value.</source>
          <target state="translated">이것은 일정하다. 그러나 로그인 한 사용자가 변경되면 공개 기능이 새 값으로 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc80719fd9be55eafa15350b547d0ffb5d420f24" translate="yes" xml:space="preserve">
          <source>This is how to invoke a method. It will run the method on the server. If a stub is available, it will also run the stub on the client. (See also &lt;a href=&quot;#meteor_apply&quot;&gt;&lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt;, which is identical to &lt;code&gt;Meteor.call&lt;/code&gt; except that you specify the parameters as an array instead of as separate arguments and you can specify a few options controlling how the method is executed.)</source>
          <target state="translated">이것이 메소드를 호출하는 방법입니다. 서버에서 메소드를 실행합니다. 스텁이 사용 가능한 경우 클라이언트에서 스텁도 실행됩니다. (참조 &lt;a href=&quot;#meteor_apply&quot;&gt; &lt;code&gt;Meteor.apply&lt;/code&gt; &lt;/a&gt; 동일, &lt;code&gt;Meteor.call&lt;/code&gt; 을 당신이 배열로 대신 별도의 인수로 매개 변수를 지정하고 메소드가 실행되는 방법을 제어하는 몇 가지 옵션을 지정할 수 있다는 점을 제외.)</target>
        </trans-unit>
        <trans-unit id="48f914f21d3910c489d4970a419dcdf59be4c203" translate="yes" xml:space="preserve">
          <source>This is more or less the way that the &lt;a href=&quot;https://atmospherejs.com/kadira/blaze-layout&quot;&gt;&lt;code&gt;kadira:blaze-layout&lt;/code&gt;&lt;/a&gt; package works.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://atmospherejs.com/kadira/blaze-layout&quot;&gt; &lt;code&gt;kadira:blaze-layout&lt;/code&gt; &lt;/a&gt; 패키지가 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="3df02605eec21c0b790a57b252cdaa7d18f53aff" translate="yes" xml:space="preserve">
          <source>This is not to be confused with &lt;a href=&quot;#meteorshell&quot;&gt;&lt;code&gt;meteor shell&lt;/code&gt;&lt;/a&gt;, which provides an almost identical experience but also gives you access to the &amp;ldquo;server&amp;rdquo; context of a Meteor application. Typically, &lt;code&gt;meteor shell&lt;/code&gt; will be preferred.</source>
          <target state="translated">이것은 &lt;a href=&quot;#meteorshell&quot;&gt; &lt;code&gt;meteor shell&lt;/code&gt; &lt;/a&gt; 과 혼동되지 않아야하며 , 이는 거의 동일한 경험을 제공하지만 Meteor 응용 프로그램의 &quot;서버&quot;컨텍스트에 액세스 할 수도 있습니다. 일반적으로 &lt;code&gt;meteor shell&lt;/code&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="23a99e1a018e2efa992d69a031eb168f30c77355" translate="yes" xml:space="preserve">
          <source>This is one reason why being able to achieve any state at will in the &lt;a href=&quot;#styleguides&quot;&gt;component style guide&lt;/a&gt; is so useful. As our reusable component &lt;code&gt;Lists_show&lt;/code&gt; simply chooses to render based on its &lt;code&gt;todosReady&lt;/code&gt; argument and does not concern itself with a subscription, it is trivial to render its loading state in a style guide.</source>
          <target state="translated">이것이 &lt;a href=&quot;#styleguides&quot;&gt;구성 요소 스타일 안내서&lt;/a&gt; 에서 원하는대로 상태를 달성 할 수있는 것이 유용한 이유 중 하나 입니다. 재사용 가능한 컴포넌트 &lt;code&gt;Lists_show&lt;/code&gt; 는 단순히 &lt;code&gt;todosReady&lt;/code&gt; 인수를 기반으로 렌더링을 선택 하고 구독과 관련이 없으므로 스타일 가이드에서로드 상태를 렌더링하는 것은 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51a69742ccb1bab8bfe4255d153c5ec4ba5fe86d" translate="yes" xml:space="preserve">
          <source>This is similar to test mode, with key differences:</source>
          <target state="translated">이것은 주요 차이점을 제외하고 테스트 모드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a87f42c164c9dae4abe6d1483b1376306796103e" translate="yes" xml:space="preserve">
          <source>This is the default command. Simply running &lt;code&gt;meteor&lt;/code&gt; is the same as &lt;code&gt;meteor run&lt;/code&gt;.</source>
          <target state="translated">이것이 기본 명령입니다. 간단하게 실행 &lt;code&gt;meteor&lt;/code&gt; 동일하다 &lt;code&gt;meteor run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b359abc10a8fa3c78cc55353582ce42ddb2f4c69" translate="yes" xml:space="preserve">
          <source>This is the guide for using Meteor, a full-stack JavaScript platform for developing modern web and mobile applications.</source>
          <target state="translated">최신 웹 및 모바일 애플리케이션 개발을위한 풀 스택 JavaScript 플랫폼 인 Meteor를 사용하기위한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="d744ec4abf94bb00d26a28350cfe22a79493e68f" translate="yes" xml:space="preserve">
          <source>This is the known Isobuild feature &amp;ldquo;packages&amp;rdquo; sorted by the first release of Meteor which supports them.</source>
          <target state="translated">이것은 알려진 Meteor의 첫 번째 릴리스별로 정렬 된 알려진 Isobuild 기능 &quot;패키지&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1fd96287a19052abb4a3d7fe8fe7567c888216ed" translate="yes" xml:space="preserve">
          <source>This is useful in initialization code, to avoid re-initializing a session variable every time a new version of your app is loaded.</source>
          <target state="translated">이는 새 버전의 앱이로드 될 때마다 세션 변수를 다시 초기화하지 않도록 초기화 코드에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d5a1929983cd56ef820285a3278e0929c97728ab" translate="yes" xml:space="preserve">
          <source>This loads your application in a special &amp;ldquo;test mode&amp;rdquo;. What this does is:</source>
          <target state="translated">응용 프로그램을 특수한 &quot;테스트 모드&quot;로로드합니다. 이것이하는 일은 :</target>
        </trans-unit>
        <trans-unit id="56971b15e750e9340198a79af0020869551f26ab" translate="yes" xml:space="preserve">
          <source>This looks like it should just work, but there&amp;rsquo;s one problem: Sometimes the rendering system will prefer to simply change an existing component rather than switching it out and triggering the animation system. For example in the Todos example app, when you navigate between lists, by default Blaze will try to simply re-render the &lt;code&gt;Lists_show&lt;/code&gt; component with a new &lt;code&gt;listId&lt;/code&gt; (a changed argument) rather than pull the old list out and put in a new one. This is an optimization that is nice in principle, but that we want to avoid here for animation purposes. More specifically, we want to make sure the animation &lt;em&gt;only&lt;/em&gt; happens when the &lt;code&gt;listId&lt;/code&gt; changes and not on other reactive changes.</source>
          <target state="translated">이것은 작동하는 것처럼 보이지만 한 가지 문제가 있습니다. 때때로 렌더링 시스템은 기존 구성 요소를 전환하고 애니메이션 시스템을 트리거하는 대신 기존 구성 요소를 변경하는 것을 선호합니다. 예를 들어 Todos 예제 앱에서, 목록을 탐색 할 때 Blaze는 기본적으로 기존 목록을 가져 와서 새 목록에 넣지 않고 &lt;code&gt;Lists_show&lt;/code&gt; 구성 요소를 새로운 &lt;code&gt;listId&lt;/code&gt; (변경된 인수)로 다시 렌더링하려고합니다 . 이것은 원칙적으로는 좋지만 애니메이션 목적으로 사용하지 않는 최적화입니다. 보다 구체적으로, 다른 반응 형 변경이 아닌 &lt;code&gt;listId&lt;/code&gt; 가 변경 될 &lt;em&gt;때만&lt;/em&gt; 애니메이션이 발생 하도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e998a2640d4e37a48b95f25447a86ef5b31b66d8" translate="yes" xml:space="preserve">
          <source>This makes it easy to then import all the client startup code with a single import as a module from our main eagerly loaded client entry point &lt;code&gt;client/main.js&lt;/code&gt;:</source>
          <target state="translated">이렇게하면 열성적으로로드 된 주요 클라이언트 진입 점 &lt;code&gt;client/main.js&lt;/code&gt; 에서 모듈로 단일 가져 오기로 모든 클라이언트 시작 코드를 쉽게 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdd7d395468a24d103f30652c24b648d07b68765" translate="yes" xml:space="preserve">
          <source>This means a React component also can&amp;rsquo;t be the only thing in a Blaze template, because it&amp;rsquo;s impossible to tell where the template will be used.</source>
          <target state="translated">즉, 템플릿이 사용될 위치를 알 수 없기 때문에 React 구성 요소도 Blaze 템플릿에서 유일한 요소가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d99f1c619bdf42d30011f5632556efc7d7c1312" translate="yes" xml:space="preserve">
          <source>This means adding the Meteor package to your project would also install the specified Cordova plugin.</source>
          <target state="translated">즉, 프로젝트에 Meteor 패키지를 추가하면 지정된 Cordova 플러그인도 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="250fec3a571cd1dcf5cc1f0d54023aaf9b6dd8a2" translate="yes" xml:space="preserve">
          <source>This means that the entirety of your application (including for instance the web server and client side router) is loaded and will run as normal. This enables you to write much more &lt;a href=&quot;#full-app-integration-test&quot;&gt;complex integration tests&lt;/a&gt; and also load additional files for &lt;a href=&quot;#acceptance-testing&quot;&gt;acceptance tests&lt;/a&gt;.</source>
          <target state="translated">이는 애플리케이션 전체 (예 : 웹 서버 및 클라이언트 측 라우터 포함)가로드되어 정상적으로 실행됨을 의미합니다. 이를 통해 훨씬 더 &lt;a href=&quot;#full-app-integration-test&quot;&gt;복잡한 통합 테스트를 작성&lt;/a&gt; 하고 &lt;a href=&quot;#acceptance-testing&quot;&gt;승인 테스트를&lt;/a&gt; 위해 추가 파일을로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="835d2dd6df725b5975ecf6adebc2fb10440698ab" translate="yes" xml:space="preserve">
          <source>This means the &lt;code&gt;client.js&lt;/code&gt; module will not be evaluated during app startup unless/until another module imports it, and will not even be included in the client bundle if no importing code is found.</source>
          <target state="translated">즉, 다른 모듈에서 가져 오기 전까지 는 &lt;code&gt;client.js&lt;/code&gt; 모듈이 앱 시작 중에 평가되지 않으며 가져 오기 코드가 없으면 클라이언트 번들에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae147d3fdb3daffac7849df948b923c4d04af3c4" translate="yes" xml:space="preserve">
          <source>This means when you render a Blaze template, you are simply running a function on the client that corresponds to the Spacebars content you defined in the &lt;code&gt;.html&lt;/code&gt; file.</source>
          <target state="translated">이는 Blaze 템플릿을 렌더링 할 때 클라이언트에서 &lt;code&gt;.html&lt;/code&gt; 파일에 정의한 스페이스 바 내용에 해당하는 기능을 실행하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4cfc7fb6043f0ffb01ccd22d1a053df62fa7164e" translate="yes" xml:space="preserve">
          <source>This method can fail throwing one of the following errors:</source>
          <target state="translated">이 방법은 다음 오류 중 하나를 throw하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dcd07d51c59652f99a5b12a8030b3c50838d5e3" translate="yes" xml:space="preserve">
          <source>This method does nothing if the client is already connected.</source>
          <target state="translated">이 방법은 클라이언트가 이미 연결된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74b9c17757f7f26bc57a20c37bc79d6d49da3861" translate="yes" xml:space="preserve">
          <source>This method returns the status of the connection between the client and the server. The return value is an object with the following fields:</source>
          <target state="translated">이 메소드는 클라이언트와 서버 간의 연결 상태를 리턴합니다. 리턴 값은 다음 필드를 가진 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="f83d5ba415f5b6d71caf10ce74bdd3390d233ae8" translate="yes" xml:space="preserve">
          <source>This migration, which is sequenced to be the first migration to run over the database, will, when called, bring each list up to date with the current todo count.</source>
          <target state="translated">데이터베이스를 실행하는 첫 번째 마이그레이션으로 시퀀스 된이 마이그레이션은 호출 될 때 현재 할 일 수와 함께 각 목록을 최신 상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5a9cda279a9be008b8893e91e2b611934eb188c0" translate="yes" xml:space="preserve">
          <source>This package also allows you to add handlers for HTTP requests. This lets other services access your app&amp;rsquo;s data through an HTTP API, allowing it to easily interoperate with tools and frameworks that don&amp;rsquo;t yet support DDP.</source>
          <target state="translated">이 패키지를 사용하면 HTTP 요청에 대한 핸들러를 추가 할 수도 있습니다. 이를 통해 다른 서비스는 HTTP API를 통해 앱의 데이터에 액세스 할 수 있으므로 아직 DDP를 지원하지 않는 도구 및 프레임 워크와 쉽게 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c4f2192b968c8539e39c850904cfb5d88a576c" translate="yes" xml:space="preserve">
          <source>This package causes Meteor to require that all arguments passed to methods and publish functions are &lt;a href=&quot;#check&quot;&gt;checked&lt;/a&gt;. Any method that does not pass each one of its arguments to &lt;code&gt;check&lt;/code&gt; will throw an error, which will be logged on the server and which will appear to the client as a &lt;code&gt;500 Internal server error&lt;/code&gt;. This is a simple way to help ensure that your app has complete check coverage.</source>
          <target state="translated">이 패키지는 유성이 모든 인수가 메소드에 전달 기능을하는 게시해야됩니다 &lt;a href=&quot;#check&quot;&gt;확인&lt;/a&gt; . &lt;code&gt;check&lt;/code&gt; 하기 위해 각 인수를 전달하지 않는 메소드 는 서버에 기록되고 클라이언트에게 &lt;code&gt;500 Internal server error&lt;/code&gt; 로 표시되는 오류를 발생시킵니다 . 앱이 완벽한 확인 범위를 갖도록하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8e7a2a2ce9dbe7b4d56a019bdf8af6c776e97b35" translate="yes" xml:space="preserve">
          <source>This package depends on &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/non-core/npm-node-aes-gcm&quot;&gt;npm-node-aes-gcm&lt;/a&gt;, which requires you to have OpenSSL installed on your system to run. To install OpenSSL on Windows, use one of the binaries on &lt;a href=&quot;http://slproweb.com/products/Win32OpenSSL.html&quot;&gt;this page&lt;/a&gt;. Don&amp;rsquo;t forget to install the Visual Studio 2008 redistributables if you don&amp;rsquo;t have them yet.</source>
          <target state="translated">이 패키지는 &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/non-core/npm-node-aes-gcm&quot;&gt;npm-node-aes-gcm&lt;/a&gt; 에 따라 달라 지므로 시스템에 OpenSSL을 설치해야합니다. Windows에 OpenSSL을 설치하려면 &lt;a href=&quot;http://slproweb.com/products/Win32OpenSSL.html&quot;&gt;이 페이지&lt;/a&gt; 의 바이너리 중 하나를 사용 하십시오 . Visual Studio 2008 재배포 가능 패키지가없는 경우 반드시 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="cb32dccefe9ece55571ae3a2429d3bebc1760c17" translate="yes" xml:space="preserve">
          <source>This package depends on &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/non-core/npm-node-aes-gcm&quot;&gt;npm-node-aes-gcm&lt;/a&gt;, which requires you to have OpenSSL installed on your system to run. To install OpenSSL on Windows, use one of the binaries on &lt;a href=&quot;https://slproweb.com/products/Win32OpenSSL.html&quot;&gt;this page&lt;/a&gt;. Don&amp;rsquo;t forget to install the Visual Studio 2008 redistributables if you don&amp;rsquo;t have them yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8ed5a9b6b0c2d0403c7ea5b473b18617755da9" translate="yes" xml:space="preserve">
          <source>This package exports a function named &lt;code&gt;onPageLoad&lt;/code&gt; which takes a callback function that will be called at page load (on the client) or whenever a new request happens (on the server).</source>
          <target state="translated">이 패키지 는 페이지로드시 (클라이언트에서) 또는 새 요청이 발생할 때마다 (서버에서) 콜백 함수를 취하는 &lt;code&gt;onPageLoad&lt;/code&gt; 라는 함수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="801611c7f69b14d0acd01859ac3266f4e2976b62" translate="yes" xml:space="preserve">
          <source>This package implements generic support for server-side rendering in Meteor apps, by providing a mechanism for injecting fragments of HTML into the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and/or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; of the application&amp;rsquo;s initial HTML response.</source>
          <target state="translated">이 패키지 는 애플리케이션의 초기 HTML 응답 의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 에 HTML 조각을 주입하는 메커니즘을 제공함으로써 Meteor 앱에서 서버 측 렌더링에 대한 일반적인 지원을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b2e97b74b5413d63b2e976de4ef86343e97411c5" translate="yes" xml:space="preserve">
          <source>This package is the core of Meteor&amp;rsquo;s developer-facing user accounts functionality. This includes:</source>
          <target state="translated">이 패키지는 Meteor의 개발자 용 사용자 계정 기능의 핵심입니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="80fa61d7865956796febe9210ec66eda836f241d" translate="yes" xml:space="preserve">
          <source>This package lets you use Markdown in your templates. It&amp;rsquo;s easy: just put your markdown inside &lt;code&gt;{{#markdown}} ... {{/markdown}}&lt;/code&gt; tags. You can still use all of the usual Meteor template features inside a Markdown block, such as &lt;code&gt;{{#each}}&lt;/code&gt;, and you still get reactivity.</source>
          <target state="translated">이 패키지를 사용하면 템플릿에서 Markdown을 사용할 수 있습니다. 간단합니다 : 마크 다운을 &lt;code&gt;{{#markdown}} ... {{/markdown}}&lt;/code&gt; 태그 안에 넣으십시오 . &lt;code&gt;{{#each}}&lt;/code&gt; 와 같이 Markdown 블록 내에서 일반적인 모든 Meteor 템플릿 기능을 계속 사용할 수 있으며 여전히 반응성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4e961bf0fc729e479ae4a4d0a644d2e705a5f8" translate="yes" xml:space="preserve">
          <source>This package lets you use new JavaScript language features that are part of the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015 specification&lt;/a&gt; but are not yet supported by all engines or browsers. Unsupported syntax is automatically translated into standard JavaScript that behaves the same way.</source>
          <target state="translated">이 패키지를 사용하면 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015 사양의&lt;/a&gt; 일부 이지만 아직 모든 엔진 또는 브라우저에서 지원되지 않는 새로운 JavaScript 언어 기능을 사용할 수 있습니다 . 지원되지 않는 구문은 동일한 방식으로 작동하는 표준 JavaScript로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="006b4651eab4288ede0a5b6e4c1adc9ac054c896" translate="yes" xml:space="preserve">
          <source>This package lets you use new JavaScript language features that are part of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015 specification&lt;/a&gt; but are not yet supported by all engines or browsers. Unsupported syntax is automatically translated into standard JavaScript that behaves the same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b909aee537737131c5908ff7f5d3bee31b5c58" translate="yes" xml:space="preserve">
          <source>This package requires data provided by the project&amp;rsquo;s minifier. For this reason, it is necessary to use the official &lt;code&gt;standard-minifier-js&lt;/code&gt; package or a minifier which includes file-size details obtained during minification.</source>
          <target state="translated">이 패키지에는 프로젝트 축소 기에서 제공 한 데이터가 필요합니다. 따라서 공식 &lt;code&gt;standard-minifier-js&lt;/code&gt; 패키지 또는 축소 중에 얻은 파일 크기 세부 정보가 포함 된 축소 기를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8112cf60cd8f8bde1fa31e9f72d1cf81609fbdc" translate="yes" xml:space="preserve">
          <source>This package utilizes the &lt;code&gt;&amp;lt;hash&amp;gt;.stats.json&lt;/code&gt; files which are written alongside file bundles when the application is ran with the &lt;code&gt;--production&lt;/code&gt; flag. The specific details for the minified file sizes is added by the minifier package and therefore it&amp;rsquo;s important to review the minifier requirements below.</source>
          <target state="translated">이 패키지는 응용 프로그램이 &lt;code&gt;--production&lt;/code&gt; 플래그 와 함께 실행될 때 파일 번들과 함께 작성된 &lt;code&gt;&amp;lt;hash&amp;gt;.stats.json&lt;/code&gt; 파일을 사용합니다 . 축소 된 파일 크기에 대한 특정 세부 사항은 축소 기 패키지에 의해 추가되므로 아래의 축소 기 요구 사항을 검토하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d86cd0f3de421a09763190d39a42110bf482dbe8" translate="yes" xml:space="preserve">
          <source>This predefined &lt;code&gt;Accounts&lt;/code&gt; object (along with similar convenience methods of &lt;code&gt;Meteor&lt;/code&gt;, such as &lt;a href=&quot;#meteor_logout&quot;&gt;&lt;code&gt;Meteor.logout&lt;/code&gt;&lt;/a&gt;) is sufficient to implement most accounts-related logic in Meteor apps. Nevertheless, these two constructors can be instantiated more than once, to create multiple independent connections between different accounts servers and their clients, in more complicated authentication situations.</source>
          <target state="translated">이 사전 정의 된 &lt;code&gt;Accounts&lt;/code&gt; 객체 ( &lt;a href=&quot;#meteor_logout&quot;&gt; &lt;code&gt;Meteor.logout&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;code&gt;Meteor&lt;/code&gt; 의 유사한 편리한 방법과 함께 )는 Meteor 앱에서 대부분의 계정 관련 로직을 구현하기에 충분합니다. 그럼에도 불구하고이 두 생성자를 두 번 이상 인스턴스화하면보다 복잡한 인증 상황에서 서로 다른 계정 서버와 해당 클라이언트간에 여러 개의 독립적 인 연결을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c4a6fc2f5f5924859380777c5c56621212bd0a" translate="yes" xml:space="preserve">
          <source>This property is a convenience to support the common pattern where a computation has logic specific to the first run.</source>
          <target state="translated">이 속성은 계산에 첫 번째 실행과 관련된 논리가있는 공통 패턴을 지원하기에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="4ae5bddb8bb73be03a77d52e596196e40e29091a" translate="yes" xml:space="preserve">
          <source>This property is initially false. It is set to true by &lt;code&gt;stop()&lt;/code&gt; and &lt;code&gt;invalidate()&lt;/code&gt;. It is reset to false when the computation is recomputed at flush time.</source>
          <target state="translated">이 속성은 처음에 false입니다. &lt;code&gt;stop()&lt;/code&gt; 및 &lt;code&gt;invalidate()&lt;/code&gt; 의해 true로 설정됩니다 . 플러시 시간에 계산이 다시 계산 될 때 false로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fb00818fbd4c3f0ee41c33e0ab820318dc22e1a2" translate="yes" xml:space="preserve">
          <source>This property provides access to the data context at the top level of the template. It is updated each time the template is re-rendered. Access is read-only and non-reactive.</source>
          <target state="translated">이 속성은 템플릿의 최상위 수준에서 데이터 컨텍스트에 대한 액세스를 제공합니다. 템플릿을 다시 렌더링 할 때마다 업데이트됩니다. 액세스가 읽기 전용이며 반응이 없습니다.</target>
        </trans-unit>
        <trans-unit id="587ae170156cabbbb1873110223a0a24e094712c" translate="yes" xml:space="preserve">
          <source>This publication will let the client pass an array of user IDs it&amp;rsquo;s interested in, and get the initials for all of those users.</source>
          <target state="translated">이 발행물을 통해 클라이언트는 관심있는 사용자 ID 배열을 전달하고 해당 사용자 모두의 이니셜을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047a4a73f6287c3aae77e94110795e810f780ecc" translate="yes" xml:space="preserve">
          <source>This removes the package entirely. To continue using the package, but remove its version constraint, use &lt;a href=&quot;#meteoradd&quot;&gt;&lt;code&gt;meteor add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지가 완전히 제거됩니다. 패키지를 계속 사용하면서 버전 제약 조건을 제거하려면 &lt;a href=&quot;#meteoradd&quot;&gt; &lt;code&gt;meteor add&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d1220c5c6562fab58e9ce30b67ea6ba7f2f5999" translate="yes" xml:space="preserve">
          <source>This route handler will run in two situations: if the page loads initially at a URL that matches the URL pattern, or if the URL changes to one that matches the pattern while the page is open. Note that, unlike in a server-side-rendered app, the URL can change without any additional requests to the server.</source>
          <target state="translated">이 경로 핸들러는 두 가지 상황에서 실행됩니다. 페이지가 URL 패턴과 일치하는 URL에서 처음로드되거나 페이지가 열려있는 동안 URL이 패턴과 일치하는 URL로 변경되는 경우입니다. 서버 측 렌더링 된 앱과 달리 서버에 대한 추가 요청없이 URL이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1143251d242c452f6bc2432fe1288e1cc774476f" translate="yes" xml:space="preserve">
          <source>This snippet illustrates a few things:</source>
          <target state="translated">이 스 니펫은 몇 가지 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc1be5265ed6b663c3c7f231529f42fd1bd6242a" translate="yes" xml:space="preserve">
          <source>This subscribes you to the chat messages in the current room and to your private messages. When you change rooms by calling &lt;code&gt;Session.set('currentRoom',
'newRoom')&lt;/code&gt;, Meteor will subscribe to the new room&amp;rsquo;s chat messages, unsubscribe from the original room&amp;rsquo;s chat messages, and continue to stay subscribed to your private messages.</source>
          <target state="translated">현재 방의 채팅 메시지와 개인 메시지를 구독합니다. &lt;code&gt;Session.set('currentRoom', 'newRoom')&lt;/code&gt; 을 호출 하여 회의실을 변경하면 Meteor는 새 회의실의 채팅 메시지를 구독하고 원래 회의실의 채팅 메시지를 수신 거부하며 개인 메시지를 계속 구독합니다.</target>
        </trans-unit>
        <trans-unit id="d7753196602f0f2606a0a72f558e9df929883512" translate="yes" xml:space="preserve">
          <source>This technique has a few disadvantages:</source>
          <target state="translated">이 기술에는 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f46b4e27a3d324e56832175b5b5a854a0e6d1b16" translate="yes" xml:space="preserve">
          <source>This technique will only work on the server. If you need to reset the database from a client test, you can use a method to do so:</source>
          <target state="translated">이 기술은 서버에서만 작동합니다. 클라이언트 테스트에서 데이터베이스를 재설정해야하는 경우 방법을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61916130428c7c39febc6a5b00a7fc3490f64309" translate="yes" xml:space="preserve">
          <source>This template expects to be rendered with an object with key &lt;code&gt;todo&lt;/code&gt; as data context (we&amp;rsquo;ll see &lt;a href=&quot;reusable-components#Validate-data-context&quot;&gt;below&lt;/a&gt; how to enforce that). We access the properties of the &lt;code&gt;todo&lt;/code&gt; using the mustache tag, such as &lt;code&gt;{{todo.text}}&lt;/code&gt;. The default behavior is to render that property as a string; however for some attributes (such as &lt;code&gt;checked={{todo.checked}}&lt;/code&gt;) it can be resolved as a boolean value.</source>
          <target state="translated">이 템플릿 은 데이터 컨텍스트로 키 할 &lt;code&gt;todo&lt;/code&gt; 이있는 객체로 렌더링 될 것으로 예상합니다 ( &lt;a href=&quot;reusable-components#Validate-data-context&quot;&gt;아래에서&lt;/a&gt; 이를 적용하는 방법 참조 ). &lt;code&gt;{{todo.text}}&lt;/code&gt; 와 같은 수염 태그를 사용하여 할 &lt;code&gt;todo&lt;/code&gt; 의 속성에 액세스합니다 . 기본 동작은 해당 속성을 문자열로 렌더링하는 것입니다. 그러나 일부 속성 (예 : &lt;code&gt;checked={{todo.checked}}&lt;/code&gt; )의 경우 부울 값으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99aa26bcf6e8036b27297eaf0ee901e829f04cb5" translate="yes" xml:space="preserve">
          <source>This template tag cannot be used in attributes or in an HTML start tag.</source>
          <target state="translated">이 템플릿 태그는 속성 또는 HTML 시작 태그에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fd60aaa94235fd5c2bccfebc902b5e5f028e4f7" translate="yes" xml:space="preserve">
          <source>This threatens to leave many older Android devices behind however, because they would be stuck on the web view included with the OS and are often unable to update to newer OS versions. Fortunately, the &lt;a href=&quot;https://crosswalk-project.org/documentation/cordova.html&quot;&gt;Crosswalk plugin&lt;/a&gt; allows you to embed Chromium in your app and use it instead of the web view that comes with the OS on any of the Android versions supported by Cordova (currently Android 4.0 or higher). Embedding Chromium means the size of your APK will grow by about 20MB, but the benefit is that you can rely on a consistent web view with considerably better performance and enhanced standards support.</source>
          <target state="translated">그러나 많은 오래된 안드로이드 기기는 OS에 포함 된 웹보기에 멈춰서 종종 새로운 OS 버전으로 업데이트 할 수 없기 때문에 위협을받습니다. 다행히 &lt;a href=&quot;https://crosswalk-project.org/documentation/cordova.html&quot;&gt;Crosswalk 플러그인을&lt;/a&gt; 사용하면 앱에 Chromium을 포함시켜 Cordova에서 지원하는 Android 버전 (현재 Android 4.0 이상)에서 OS와 함께 제공되는 웹보기 대신 사용할 수 있습니다. Chromium을 포함하면 APK 크기가 약 20MB 정도 증가하지만 이점은 성능이 향상되고 표준 지원이 향상되어 일관된 웹보기에 의존 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b290580d14297d70b42dba5af21fd3331e72d861" translate="yes" xml:space="preserve">
          <source>This triggers a call to &lt;a href=&quot;#accounts_sendresetpasswordemail&quot;&gt;&lt;code&gt;Accounts.sendResetPasswordEmail&lt;/code&gt;&lt;/a&gt; on the server. When the user visits the link in this email, the callback registered with &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt;&lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">서버 에서 &lt;a href=&quot;#accounts_sendresetpasswordemail&quot;&gt; &lt;code&gt;Accounts.sendResetPasswordEmail&lt;/code&gt; &lt;/a&gt; 에 대한 호출이 트리거됩니다 . 사용자가이 이메일의 링크를 방문하면 &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt; &lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6e78af78626e2d274d2efffe0137fb644bc10d58" translate="yes" xml:space="preserve">
          <source>This value indicates, whether a flush is in progress or not.</source>
          <target state="translated">이 값은 플러시가 진행 중인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16a3b01978773414a6791844da14b071c10debc4" translate="yes" xml:space="preserve">
          <source>This value is useful for data source implementations to determine whether they are being accessed reactively or not.</source>
          <target state="translated">이 값은 데이터 소스 구현이 반응 적으로 액세스되는지 여부를 판별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="00e25c0f0c2b9b088c9d6549c9a282416f6cdd2b" translate="yes" xml:space="preserve">
          <source>This visualization can uncover details about which files or packages are occupying space within the initial client bundle. This can be useful in determining which imports might be candidates for being converted to dynamic &lt;code&gt;import()&lt;/code&gt; statements (which are excluded from the initial client bundle), or for identifying packages which have been inadvertently included in a project.</source>
          <target state="translated">이 시각화는 초기 클라이언트 번들에서 공간을 차지하는 파일 또는 패키지에 대한 세부 사항을 발견 할 수 있습니다. 이는 동적 &lt;code&gt;import()&lt;/code&gt; 명령문 으로 변환 될 후보 ( 초기 클라이언트 번들에서 제외됨 )를 가져 오거나 프로젝트에 실수로 포함 된 패키지를 식별 하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2484bce687a38d7267ef24756c09c0bf48a19416" translate="yes" xml:space="preserve">
          <source>This way you get the full reactive power of the store.</source>
          <target state="translated">이렇게하면 상점의 최대 무효 전력을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ccc372c2aae5302b11a64624bdca5e27ef9ece9" translate="yes" xml:space="preserve">
          <source>This will add the newest version of the desired package that is compatible with the other packages in your app. If you want to specify a particular version, you can specify it by adding a suffix to the package name like: &lt;code&gt;meteor add kadira:flow-router@2.10.0&lt;/code&gt;.</source>
          <target state="translated">그러면 앱의 다른 패키지와 호환되는 원하는 패키지의 최신 버전이 추가됩니다. 특정 버전을 지정하려면 &lt;code&gt;meteor add kadira:flow-router@2.10.0&lt;/code&gt; 과 같이 패키지 이름에 접미 부를 추가하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8af6528337b018bf0e73207d060ed653d2043fb9" translate="yes" xml:space="preserve">
          <source>This will both update your &lt;code&gt;package.json&lt;/code&gt; with information about the dependency and download the package into your app&amp;rsquo;s local &lt;code&gt;node_modules/&lt;/code&gt; directory. Typically, you don&amp;rsquo;t check the &lt;code&gt;node_modules/&lt;/code&gt; directory into source control and your teammates run &lt;code&gt;meteor npm install&lt;/code&gt; to get up to date when dependencies change:</source>
          <target state="translated">이것은 의존성에 대한 정보로 &lt;code&gt;package.json&lt;/code&gt; 을 업데이트 하고 패키지를 앱의 로컬 &lt;code&gt;node_modules/&lt;/code&gt; 디렉토리에 다운로드합니다 . 일반적으로 &lt;code&gt;node_modules/&lt;/code&gt; 디렉토리를 소스 제어로 확인하지 않고 팀원은 &lt;code&gt;meteor npm install&lt;/code&gt; 을 실행하여 종속성이 변경 될 때 최신 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0b0f429ae05b1d3a65fdc3c547b24d79b7ececf2" translate="yes" xml:space="preserve">
          <source>This will create an &lt;code&gt;npm-shrinkwrap.json&lt;/code&gt; file containing the exact versions of each dependency, and you should check this file into source control. For even more precision (the contents of a given version of a package &lt;em&gt;can&lt;/em&gt; change), and to avoid a reliance on the npm server during deployment, you should consider using &lt;a href=&quot;#npm-shrinkpack&quot;&gt;&lt;code&gt;npm shrinkpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러면 각 종속성의 정확한 버전이 포함 된 &lt;code&gt;npm-shrinkwrap.json&lt;/code&gt; 파일 이 생성 되므로이 파일을 소스 제어로 확인해야합니다. 훨씬 더 정밀한 (특정 패키지 버전의 내용이 변경 &lt;em&gt;될&lt;/em&gt; 수 있음) 배포 중에 npm 서버에 대한 의존을 피하려면 &lt;a href=&quot;#npm-shrinkpack&quot;&gt; &lt;code&gt;npm shrinkpack&lt;/code&gt; &lt;/a&gt; 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="674cc981f9cbe7f05f2e547d4d0f5c3c73d94911" translate="yes" xml:space="preserve">
          <source>This will generate a directory at &lt;code&gt;&amp;lt;build-output-directory&amp;gt;&lt;/code&gt;, which includes a server bundle tarball and the project source for each targeted mobile platform in the &lt;code&gt;/ios&lt;/code&gt; and &lt;code&gt;/android&lt;/code&gt; directories.</source>
          <target state="translated">&lt;code&gt;&amp;lt;build-output-directory&amp;gt;&lt;/code&gt; 에 디렉토리가 생성 되는데, 여기에는 서버 번들 tarball과 &lt;code&gt;/ios&lt;/code&gt; 및 &lt;code&gt;/android&lt;/code&gt; 디렉토리 에있는 각 대상 모바일 플랫폼에 대한 프로젝트 소스가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba4f7b787374b855dcd48af800c0b12543a38390" translate="yes" xml:space="preserve">
          <source>This will install &lt;code&gt;react&lt;/code&gt; into your project and allow you to access it within your files with &lt;code&gt;import React from 'react'&lt;/code&gt;. Most React code is written in &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt;, which you can use by &lt;a href=&quot;http://guide.meteor.com/build-tool.html#react-jsx&quot;&gt;default in Meteor&lt;/a&gt; if you include the &lt;code&gt;ecmascript&lt;/code&gt; package (which is installed in all Meteor apps by default).</source>
          <target state="translated">그러면 프로젝트에 &lt;code&gt;react&lt;/code&gt; 이 설치 되고 &lt;code&gt;import React from 'react'&lt;/code&gt; 하여 파일 내에서 프로젝트에 액세스 할 수 있습니다 . 대부분의 React 코드는 &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-in-depth.html&quot;&gt;JSX&lt;/a&gt; 로 작성되며 , &lt;code&gt;ecmascript&lt;/code&gt; 패키지 (기본적으로 모든 Meteor 앱에 설치됨) 를 포함하면 &lt;a href=&quot;http://guide.meteor.com/build-tool.html#react-jsx&quot;&gt;Meteor에서 기본적으로&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7bc7dbeba23dc5ab03e040f2caabd3e92a29378" translate="yes" xml:space="preserve">
          <source>This will make every Method only callable 5 times per second per connection. This is a rate limit that shouldn&amp;rsquo;t be noticeable by the user at all, but will prevent a malicious script from totally flooding the server with requests. You will need to tune the limit parameters to match your app&amp;rsquo;s needs.</source>
          <target state="translated">이렇게하면 모든 메소드가 연결 당 초당 5 회만 호출 할 수 있습니다. 이 속도 제한은 사용자가 전혀 눈에 띄지 않아야하지만 악의적 인 스크립트가 서버에 요청을 완전히 넘치지 못하게합니다. 앱의 요구에 맞게 제한 매개 변수를 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d00463c67f24a756272b7c19d96a983f98dce029" translate="yes" xml:space="preserve">
          <source>This will provide you with a bundled application &lt;code&gt;.tar.gz&lt;/code&gt; which you can extract and run without the &lt;code&gt;meteor&lt;/code&gt; tool. The environment you choose will need the correct version of Node.js and connectivity to a MongoDB server.</source>
          <target state="translated">이것은 &lt;code&gt;meteor&lt;/code&gt; 도구 없이 추출하고 실행할 수 있는 번들 응용 프로그램 &lt;code&gt;.tar.gz&lt;/code&gt; 를 제공합니다 . 선택한 환경에는 올바른 Node.js 버전과 MongoDB 서버 연결이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7c3e01dd8888acaa316a8d408f465642baa4cd94" translate="yes" xml:space="preserve">
          <source>This will run a special app containing only a &amp;ldquo;test&amp;rdquo; version of your package and start a Mocha &lt;a href=&quot;testing#driver-packages&quot;&gt;test driver package&lt;/a&gt;.</source>
          <target state="translated">패키지의 &quot;테스트&quot;버전 만 포함 된 특수 앱을 실행하고 Mocha &lt;a href=&quot;testing#driver-packages&quot;&gt;테스트 드라이버 패키지를&lt;/a&gt; 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="631977ba51c5ef6322cb4a01ef1125dcdc3b59c4" translate="yes" xml:space="preserve">
          <source>This will run your app on a default simulated iOS device. You can open Xcode to install and select another simulated device.</source>
          <target state="translated">기본 시뮬레이션 된 iOS 기기에서 앱이 실행됩니다. Xcode를 열어 다른 시뮬레이션 장치를 설치하고 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faaee2d55a8237b2d82a8ce38647f9502d00edf7" translate="yes" xml:space="preserve">
          <source>This works just like &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt;, except it lets you make sure that certain writes are definitely denied, even if there is an &lt;code&gt;allow&lt;/code&gt; rule that says that they should be permitted.</source>
          <target state="translated">이것은 허용되어야한다고 말하는 &lt;code&gt;allow&lt;/code&gt; 규칙 이 있더라도 특정 쓰기가 확실히 거부되도록하는 것을 제외하고는 &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0c906b8ece5764400141a1240ce8dd7ae9a3eb69" translate="yes" xml:space="preserve">
          <source>Though Meteor 1.2 introduced support for &lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/packages/ecmascript/README.md#supported-es2015-features&quot;&gt;many new ECMAScript 2015 features&lt;/a&gt;, one of the most notable omissions was &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax&lt;/a&gt;. Meteor 1.3 fills that gap with a fully standards-compliant module system that works on both the client and the server, solves multiple long-standing problems for Meteor applications (such as controlling file load order), and yet maintains full backwards compatibility with existing Meteor code. This document explains the usage and key features of the new module system.</source>
          <target state="translated">Meteor 1.2가 &lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/packages/ecmascript/README.md#supported-es2015-features&quot;&gt;많은 새로운 ECMAScript 2015 기능에&lt;/a&gt; 대한 지원을 도입했지만 가장 주목할만한 누락 중 하나는 &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;ES2015 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 구문&lt;/a&gt; 입니다. Meteor 1.3은 클라이언트와 서버 모두에서 작동하는 완전한 표준 호환 모듈 시스템으로 이러한 차이를 메우고, 파일로드 순서 제어와 같은 Meteor 응용 프로그램의 여러 가지 오랜 문제를 해결하면서도 기존 Meteor와의 완전한 하위 호환성을 유지합니다 암호. 이 문서는 새로운 모듈 시스템의 사용법과 주요 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="418c3d8b355720dc7fb8cd91171708c487964921" translate="yes" xml:space="preserve">
          <source>Throttling method calls on user action</source>
          <target state="translated">사용자 조치에 대한 제한 메소드 호출</target>
        </trans-unit>
        <trans-unit id="19237b8bc8352c4f24f44ebb12277437918eb9e8" translate="yes" xml:space="preserve">
          <source>Throwing errors from a Method</source>
          <target state="translated">메소드에서 오류 발생</target>
        </trans-unit>
        <trans-unit id="0c50361a14d76093904430e81fc260348a28b36b" translate="yes" xml:space="preserve">
          <source>Thus it&amp;rsquo;s a good way to develop the test&amp;mdash;this is why chimp has a feature where we mark tests with a &lt;code&gt;@watch&lt;/code&gt; in the name to call out the tests we want to work on (running our entire acceptance test suite can be time consuming in a large application).</source>
          <target state="translated">따라서 테스트를 개발하는 좋은 방법입니다. 이것이 &lt;code&gt;@watch&lt;/code&gt; 에 이름으로 @watch 로 테스트를 표시 하여 작업하려는 테스트를 호출하는 기능입니다 (전체 승인 테스트 스위트를 실행하는 데 시간이 오래 걸릴 수 있음) 큰 응용 프로그램).</target>
        </trans-unit>
        <trans-unit id="80f7bfc991a68ad35271fc4c44c57c7313dda264" translate="yes" xml:space="preserve">
          <source>Thus it&amp;rsquo;s best to keep the size of the cache below 5MB. The &lt;code&gt;appcache&lt;/code&gt; package will print a warning on the Meteor server console if the total size of the resources being cached is over 5MB.</source>
          <target state="translated">따라서 캐시 크기를 5MB 미만으로 유지하는 것이 가장 좋습니다. &lt;code&gt;appcache&lt;/code&gt; 캐시되는 자원의 전체 크기가 5메가바이트 이상이면 패키지는 유성 서버 콘솔에 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="af43d192a2db078a74e425ebd0d1c79c0db4abe8" translate="yes" xml:space="preserve">
          <source>To achieve a similar abstraction for subscriptions/publications, you may want to write a simple wrapper for &lt;code&gt;Meteor.subscribe()&lt;/code&gt;.</source>
          <target state="translated">구독 / 게시에 대한 유사한 추상화를 달성하기 위해 &lt;code&gt;Meteor.subscribe()&lt;/code&gt; 대한 간단한 래퍼를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="307b88b07be557df43048b1b3f979a69bd726011" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Session&lt;/code&gt; to your application, run this command in your terminal:</source>
          <target state="translated">애플리케이션 에 &lt;code&gt;Session&lt;/code&gt; 을 추가하려면 터미널에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d66430b590f84a3a149870f6747c2e3c611fccb2" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;check&lt;/code&gt; (or &lt;code&gt;Match&lt;/code&gt;) to your application, run this command in your terminal:</source>
          <target state="translated">애플리케이션 에 &lt;code&gt;check&lt;/code&gt; (또는 &lt;code&gt;Match&lt;/code&gt; ) 를 추가하려면 터미널에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8471b2c71056ace887facad475281c4bcc82e584" translate="yes" xml:space="preserve">
          <source>To add Accounts and a set of login controls to an application, add the &lt;code&gt;accounts-ui&lt;/code&gt; package and at least one login provider package: &lt;code&gt;accounts-password&lt;/code&gt;, &lt;code&gt;accounts-facebook&lt;/code&gt;, &lt;code&gt;accounts-github&lt;/code&gt;, &lt;code&gt;accounts-google&lt;/code&gt;, &lt;code&gt;accounts-twitter&lt;/code&gt;, or &lt;code&gt;accounts-weibo&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에 계정 및 로그인 제어 세트를 추가하려면 &lt;code&gt;accounts-ui&lt;/code&gt; 패키지 및 하나 이상의 로그인 제공자 패키지를 추가하십시오 : &lt;code&gt;accounts-password&lt;/code&gt; , &lt;code&gt;accounts-facebook&lt;/code&gt; , &lt;code&gt;accounts-github&lt;/code&gt; , &lt;code&gt;accounts-google&lt;/code&gt; , &lt;code&gt;accounts-twitter&lt;/code&gt; 또는 &lt;code&gt;accounts-weibo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56392a39ad658fa9a39f5f4104aa485de77753ad" translate="yes" xml:space="preserve">
          <source>To add Flow Router Extra to your app, install the &lt;code&gt;ostrio:flow-router-extra&lt;/code&gt; package</source>
          <target state="translated">앱에 Flow Router Extra를 추가하려면 &lt;code&gt;ostrio:flow-router-extra&lt;/code&gt; 패키지를 설치하십시오</target>
        </trans-unit>
        <trans-unit id="bf6e1f6d46dabcbab0f79270020e6a693e92a930" translate="yes" xml:space="preserve">
          <source>To add Flow Router to your app, install the &lt;code&gt;kadira:flow-router&lt;/code&gt; package</source>
          <target state="translated">앱에 Flow Router를 추가하려면 &lt;code&gt;kadira:flow-router&lt;/code&gt; 패키지를 설치하십시오</target>
        </trans-unit>
        <trans-unit id="1df4465ea1c500c52f31b3a0dfa24a407bcb0200" translate="yes" xml:space="preserve">
          <source>To add Iron Router to your app, install the &lt;code&gt;iron:router&lt;/code&gt; package</source>
          <target state="translated">앱에 Iron Router를 추가하려면 &lt;code&gt;iron:router&lt;/code&gt; 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6f51538e10e4501f3e413cdc9568e5dd6845dc9" translate="yes" xml:space="preserve">
          <source>To add JavaScript files to a package, specify an entrypoint with &lt;a href=&quot;http://docs.meteor.com/#/full/pack_mainModule&quot;&gt;&lt;code&gt;api.mainModule()&lt;/code&gt;&lt;/a&gt; in the package&amp;rsquo;s &lt;code&gt;onUse&lt;/code&gt; block (this will already have been done by &lt;code&gt;meteor create --package&lt;/code&gt; above):</source>
          <target state="translated">패키지에 JavaScript 파일을 추가하려면 패키지의 &lt;code&gt;onUse&lt;/code&gt; 블록 에 &lt;a href=&quot;http://docs.meteor.com/#/full/pack_mainModule&quot;&gt; &lt;code&gt;api.mainModule()&lt;/code&gt; &lt;/a&gt; 을 사용하여 진입 점을 지정 하십시오 ( 위의 &lt;code&gt;meteor create --package&lt;/code&gt; 에서 이미 수행됨 ).</target>
        </trans-unit>
        <trans-unit id="bd33aa5cca26139c81c7aa17d474afe02cd166c9" translate="yes" xml:space="preserve">
          <source>To add password support to your application, run this command in your terminal:</source>
          <target state="translated">애플리케이션에 비밀번호 지원을 추가하려면 터미널에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a91b992f039d7294ffa8597df760e09fd36c5904" translate="yes" xml:space="preserve">
          <source>To add reactive i18n inline in your React components, simply use the &lt;code&gt;i18n.createComponent()&lt;/code&gt; function and pass it keys from your translation file. Here&amp;rsquo;s an example of a simple component wrapping i18n&amp;rsquo;s translation component:</source>
          <target state="translated">React 컴포넌트에 반응 형 i18n을 인라인으로 추가하려면 &lt;code&gt;i18n.createComponent()&lt;/code&gt; 함수를 사용하여 번역 파일에서 키를 전달하면됩니다. 다음은 i18n의 번역 구성 요소를 래핑하는 간단한 구성 요소의 예입니다.</target>
        </trans-unit>
        <trans-unit id="fa3553eeaac76c328a7b706dc9771d0e9fb911e6" translate="yes" xml:space="preserve">
          <source>To add routing to your app, install the &lt;a href=&quot;https://atmospherejs.com/kadira/flow-router&quot;&gt;&lt;code&gt;kadira:flow-router&lt;/code&gt;&lt;/a&gt; package:</source>
          <target state="translated">앱에 라우팅을 추가하려면 &lt;a href=&quot;https://atmospherejs.com/kadira/flow-router&quot;&gt; &lt;code&gt;kadira:flow-router&lt;/code&gt; &lt;/a&gt; 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="42eff87f5eef6265383b75626ff84bf3616f0a23" translate="yes" xml:space="preserve">
          <source>To add the &lt;code&gt;ecmascript&lt;/code&gt; package to an existing package, include the statement &lt;code&gt;api.use('ecmascript');&lt;/code&gt; in the &lt;code&gt;Package.onUse&lt;/code&gt; callback in your &lt;code&gt;package.js&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지를 기존 패키지에 추가하려면 &lt;code&gt;api.use('ecmascript');&lt;/code&gt; &lt;code&gt;package.js&lt;/code&gt; 파일 의 &lt;code&gt;Package.onUse&lt;/code&gt; 콜백에서 :</target>
        </trans-unit>
        <trans-unit id="e20880d00bcbd5eb38c559d663c3ec8def55d73f" translate="yes" xml:space="preserve">
          <source>To add this package to an existing app, run the following command from your app directory:</source>
          <target state="translated">이 패키지를 기존 앱에 추가하려면 앱 디렉토리에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f2e320cb01c4441352f907ce775a3e219f34ae6a" translate="yes" xml:space="preserve">
          <source>To alleviate some of the boilerplate that&amp;rsquo;s involved in correct Method definitions, we&amp;rsquo;ve published a wrapper package called &lt;code&gt;mdg:validated-method&lt;/code&gt; that does most of this for you. Here&amp;rsquo;s the same Method as above, but defined with the package:</source>
          <target state="translated">올바른 분석법 정의와 관련된 보일러 플레이트를 완화하기 위해 &lt;code&gt;mdg:validated-method&lt;/code&gt; 라는 래퍼 패키지를 게시했습니다 . 위와 같은 방법이지만 패키지로 정의한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92028f9907da1367d1d7658cebf0085075aa1418" translate="yes" xml:space="preserve">
          <source>To ask the user for permission to act on their behalf when offline, map the relevant external service to &lt;code&gt;true&lt;/code&gt;. Currently only supported with Google. See &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;Meteor.loginWithExternalService&lt;/a&gt; for more details.</source>
          <target state="translated">오프라인 일 때 사용자를 대신하여 작업 할 수있는 권한을 사용자에게 요청하려면 관련 외부 서비스를 &lt;code&gt;true&lt;/code&gt; 로 매핑하십시오 . 현재 Google에서만 지원됩니다. 자세한 내용은 &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;Meteor.loginWithExternalService&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e82f474960847ab4e3dd5d96da479d395c87223" translate="yes" xml:space="preserve">
          <source>To avoid storing the secret key in your application&amp;rsquo;s source code, you can use &lt;a href=&quot;http://docs.meteor.com/#meteor_settings&quot;&gt;&lt;code&gt;Meteor.settings&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">애플리케이션의 소스 코드에 비밀 키를 저장하지 않으려면 &lt;a href=&quot;http://docs.meteor.com/#meteor_settings&quot;&gt; &lt;code&gt;Meteor.settings&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf138440e10ab58d920cbae068c264e3b9e8f6da" translate="yes" xml:space="preserve">
          <source>To avoid this problem as a package author, you can request that users of your package have installed the npm package you want to use at the application level. This is similar to a &lt;a href=&quot;https://nodejs.org/en/blog/npm/peer-dependencies/&quot;&gt;peer dependency&lt;/a&gt; of an npm package (although with less support in the tool). You can use the &lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt;&lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt;&lt;/a&gt; package to ensure that they&amp;rsquo;ve done this, and to warn them if not.</source>
          <target state="translated">패키지 작성자로서이 문제를 피하기 위해 패키지 사용자가 응용 프로그램 레벨에서 사용하려는 npm 패키지를 설치하도록 요청할 수 있습니다. 이것은 npm 패키지 의 &lt;a href=&quot;https://nodejs.org/en/blog/npm/peer-dependencies/&quot;&gt;피어 종속성&lt;/a&gt; 과 비슷 하지만 도구에서 지원이 적더라도 마찬가지 입니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt; &lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt; &lt;/a&gt; 그들이 이런 짓을했는지 확인하기 위해 패키지, 그렇지 않은 경우이를 경고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd4b2d79f3651510148354743c21d68fffcd7de" translate="yes" xml:space="preserve">
          <source>To avoid this, we try to detect faulty versions and revert to the last known good version when this happens. The way detection works is that we expect all &lt;code&gt;Meteor.startup()&lt;/code&gt; callbacks to complete within a set period of time. If this doesn&amp;rsquo;t happen we consider the version faulty and will rollback the update. Unless the version on the server has been updated in the meantime, the server will try to hot code push the faulty version again. Therefore, we blacklist faulty versions on the device so we know not to retry.</source>
          <target state="translated">이를 방지하기 위해 결함이있는 버전을 감지하고 이러한 상황이 발생하면 알려진 최신 버전으로 되돌립니다. 감지가 작동하는 방식은 모든 &lt;code&gt;Meteor.startup()&lt;/code&gt; 콜백이 정해진 시간 내에 완료 될 것으로 예상한다는 것 입니다. 이 문제가 발생하지 않으면 버전에 문제가있는 것으로 간주하고 업데이트를 롤백합니다. 그 동안 서버의 버전이 업데이트되지 않은 경우 서버는 결함이있는 버전을 다시 핫 코드 푸시하려고 시도합니다. 따라서 장치에서 결함이있는 버전을 블랙리스트에 추가하여 재 시도하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="889da3514abbff3bdc30c516c15c84268a01e7c0" translate="yes" xml:space="preserve">
          <source>To be a unit test, we must stub out the dependencies of the module. In this case, thanks to the way we&amp;rsquo;ve isolated our code into a reusable component, there&amp;rsquo;s not much to do; principally we need to stub out the &lt;code&gt;{{_}}&lt;/code&gt; helper that&amp;rsquo;s created by the &lt;a href=&quot;ui-ux#i18n&quot;&gt;&lt;code&gt;tap:i18n&lt;/code&gt;&lt;/a&gt; system. Note that we stub it out in a &lt;code&gt;beforeEach&lt;/code&gt; and restore it the &lt;code&gt;afterEach&lt;/code&gt;.</source>
          <target state="translated">단위 테스트가 되려면 모듈의 종속성을 제거해야합니다. 이 경우 코드를 재사용 가능한 구성 요소로 분리 한 방식 덕분에 할 일이 많지 않습니다. 기본적으로 &lt;a href=&quot;ui-ux#i18n&quot;&gt; &lt;code&gt;tap:i18n&lt;/code&gt; &lt;/a&gt; 시스템에 의해 생성 된 &lt;code&gt;{{_}}&lt;/code&gt; 도우미를 제거해야 합니다. 우리는 그것을 밖으로 스텁 있습니다 &lt;code&gt;beforeEach&lt;/code&gt; 과 복원 &lt;code&gt;afterEach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ac96ab417fc38f4a32046c551631b848155388" translate="yes" xml:space="preserve">
          <source>To begin with, let&amp;rsquo;s consider two categories of UI components that are useful to think about, &amp;ldquo;reusable&amp;rdquo; and &amp;ldquo;smart&amp;rdquo;:</source>
          <target state="translated">우선, &quot;재사용 가능&quot;과 &quot;스마트&quot;에 대해 생각하는 데 유용한 두 가지 범주의 UI 구성 요소를 고려해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ed4d5d454132455710ac21f80b063535219155fb" translate="yes" xml:space="preserve">
          <source>To call methods on another Meteor application or subscribe to its data sets, call &lt;code&gt;DDP.connect&lt;/code&gt; with the URL of the application. &lt;code&gt;DDP.connect&lt;/code&gt; returns an object which provides:</source>
          <target state="translated">다른 Meteor 애플리케이션에서 메소드를 호출하거나 해당 데이터 세트를 구독하려면 애플리케이션 의 URL로 &lt;code&gt;DDP.connect&lt;/code&gt; 를 호출 하십시오. &lt;code&gt;DDP.connect&lt;/code&gt; 는 다음을 제공하는 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad15d4e2108b5e4f4e18e56d209df75232e22ec6" translate="yes" xml:space="preserve">
          <source>To change the user&amp;rsquo;s language, use &lt;code&gt;i18n.setLocale('en-US')&lt;/code&gt;. &lt;code&gt;universe:i18n&lt;/code&gt; allows retrieval of additional translations by method as well as including JSON files with a client bundle.</source>
          <target state="translated">사용자 언어를 변경하려면 &lt;code&gt;i18n.setLocale('en-US')&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;universe:i18n&lt;/code&gt; 을 사용하면 클라이언트 번들과 함께 JSON 파일을 포함 할뿐만 아니라 방법으로 추가 번역을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e88f12ad857f0a8069f69573d9439bf531b56b" translate="yes" xml:space="preserve">
          <source>To check if your device has been connected and set up correctly, you can run &lt;code&gt;adb devices&lt;/code&gt; to get a list of devices.</source>
          <target state="translated">장치가 연결되어 있고 올바르게 설정되어 있는지 확인하려면 &lt;code&gt;adb devices&lt;/code&gt; 를 실행 하여 장치 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bbb21b3f577bf0c5b96e583f3621b41becacc3" translate="yes" xml:space="preserve">
          <source>To configure the behavior of &lt;code&gt;{{&amp;gt; loginButtons}}&lt;/code&gt;, use &lt;a href=&quot;#accounts_ui_config&quot;&gt;&lt;code&gt;Accounts.ui.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{{&amp;gt; loginButtons}}&lt;/code&gt; 의 동작을 구성하려면 &lt;a href=&quot;#accounts_ui_config&quot;&gt; &lt;code&gt;Accounts.ui.config&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="326d3654ef346299bdd5fe0a3e3a039237f16e67" translate="yes" xml:space="preserve">
          <source>To create a cursor, use &lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;. To access the documents in a cursor, use &lt;a href=&quot;#foreach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#fetch&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커서를 만들려면 &lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 커서에서 문서에 액세스하려면 &lt;a href=&quot;#foreach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#fetch&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; 를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6661ac0f20ea90e07c90a94040185aa2b319f076" translate="yes" xml:space="preserve">
          <source>To create a helper that can be used in any template, use &lt;a href=&quot;templates#Template-registerHelper&quot;&gt;&lt;code&gt;Template.registerHelper&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 템플릿에서 사용할 수있는 도우미를 만들려면 &lt;a href=&quot;templates#Template-registerHelper&quot;&gt; &lt;code&gt;Template.registerHelper&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="70f904fa4649a456eb4c00ff9039079ddb96d9c5" translate="yes" xml:space="preserve">
          <source>To create a new npm package:</source>
          <target state="translated">새 npm 패키지를 만들려면</target>
        </trans-unit>
        <trans-unit id="78800447b009fa5409b4c7472f32c62903c7f745" translate="yes" xml:space="preserve">
          <source>To create test data in full-app test mode, it usually makes sense to create some special test methods which we can call from the client side. Usually when testing a full app, we want to make sure the publications are sending through the correct data (as we do in this test), and so it&amp;rsquo;s not sufficient to stub out the collections and place synthetic data in them. Instead we&amp;rsquo;ll want to actually create data on the server and let it be published.</source>
          <target state="translated">전체 응용 프로그램 테스트 모드에서 테스트 데이터를 만들려면 일반적으로 클라이언트 쪽에서 호출 할 수있는 특수 테스트 방법을 만드는 것이 좋습니다. 일반적으로 전체 앱을 테스트 할 때이 테스트에서와 같이 발행물이 올바른 데이터를 통해 전송되도록해야하므로 컬렉션을 스텁 아웃하고 합성 데이터를 배치하는 것만으로는 충분하지 않습니다. 대신 우리는 실제로 서버에서 데이터를 생성하고 게시하기를 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1c7b931814d0b4edc0a2feb9ebcefd06c998e9d" translate="yes" xml:space="preserve">
          <source>To customize the contents of the email, see &lt;a href=&quot;#accounts_emailtemplates&quot;&gt;&lt;code&gt;Accounts.emailTemplates&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이메일 내용을 사용자 정의하려면 &lt;a href=&quot;#accounts_emailtemplates&quot;&gt; &lt;code&gt;Accounts.emailTemplates&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5140047bd555ef9841e9e569c9b6435496eefd9e" translate="yes" xml:space="preserve">
          <source>To define your own block helper, simply declare a template, and then invoke it using &lt;code&gt;{{#someTemplate}}&lt;/code&gt; (block) instead of &lt;code&gt;{{&amp;gt; someTemplate}}&lt;/code&gt; (inclusion) syntax.</source>
          <target state="translated">자체 블록 도우미를 정의하려면 템플릿을 선언 한 다음 &lt;code&gt;{{&amp;gt; someTemplate}}&lt;/code&gt; (포함) 구문 대신 &lt;code&gt;{{#someTemplate}}&lt;/code&gt; (블록)을 사용하여 템플릿을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="10a4f9f5681102b3aa8983bb43c9d543e7c7e152" translate="yes" xml:space="preserve">
          <source>To delete an application you&amp;rsquo;ve deployed, specify the &lt;code&gt;--delete&lt;/code&gt; option along with the site.</source>
          <target state="translated">배포 한 응용 프로그램을 삭제하려면 사이트와 함께 &lt;code&gt;--delete&lt;/code&gt; 옵션을 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca105909ad53a383a4c4c0552475452b9b6d3334" translate="yes" xml:space="preserve">
          <source>To depend on another Atmosphere package, use &lt;a href=&quot;http://docs.meteor.com/#/full/pack_use&quot;&gt;&lt;code&gt;api.use&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다른 Atmosphere 패키지에 의존하려면 &lt;a href=&quot;http://docs.meteor.com/#/full/pack_use&quot;&gt; &lt;code&gt;api.use&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="db2b46db90ab1ebb570301353caa7e894f37ad63" translate="yes" xml:space="preserve">
          <source>To deploy to the EU region, set DEPLOY_HOSTNAME to eu-west-1.galaxy.meteor.com.</source>
          <target state="translated">EU 지역에 배포하려면 DEPLOY_HOSTNAME을 eu-west-1.galaxy.meteor.com으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bc138fd935e58931f06c928850c3e3e82fc4cb09" translate="yes" xml:space="preserve">
          <source>To do so in this case, we can use a little trick (that is specific to Blaze, although similar techniques apply to other view layers) of using the fact that the &lt;code&gt;{{#each}}&lt;/code&gt; helper diffs arrays of strings, and completely re-renders elements when they change.</source>
          <target state="translated">이 경우, &lt;code&gt;{{#each}}&lt;/code&gt; 도우미가 문자열 배열 을 서로 다른 점을 사용하여 약간의 트릭 (유사한 기법은 다른 뷰 레이어에도 적용되지만 Blaze에만 해당)을 사용할 수 있습니다. -요소가 변경되면 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="8e626fdece591b67182c18d3bfaaa9773e897c2a" translate="yes" xml:space="preserve">
          <source>To do so, we can subclass &lt;code&gt;Mongo.Collection&lt;/code&gt; and write our own &lt;code&gt;insert()&lt;/code&gt; method:</source>
          <target state="translated">이를 위해 &lt;code&gt;Mongo.Collection&lt;/code&gt; 을 서브 클래스로 작성하고 자체 &lt;code&gt;insert()&lt;/code&gt; 메소드를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd840205f9265be376583a8de5ffc63864b7423" translate="yes" xml:space="preserve">
          <source>To do so, we can use the &lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt; service, thanks to the &lt;a href=&quot;https://atmospherejs.com/dferber/prerender/&quot;&gt;&lt;code&gt;dferber:prerender&lt;/code&gt;&lt;/a&gt; package. It&amp;rsquo;s a simple as &lt;code&gt;meteor add&lt;/code&gt;-ing it, and optionally setting your prerender token if you have a premium prerender account and would like to enable more frequent cache changes. You can also just use the &lt;a href=&quot;https://www.npmjs.com/package/prerender-node&quot;&gt;&lt;code&gt;prerender-node&lt;/code&gt; NPM package&lt;/a&gt; directly, mimicing the small amount of &lt;a href=&quot;https://github.com/dferber90/meteor-prerender/blob/master/client/prerender.html&quot;&gt;client&lt;/a&gt; and &lt;a href=&quot;https://github.com/dferber90/meteor-prerender/blob/master/server/prerender.js&quot;&gt;server&lt;/a&gt; code in the Atmosphere package; do this if you need to use a newer version of the NPM package than the one in &lt;code&gt;dferber:prerender&lt;/code&gt;.</source>
          <target state="translated">그렇게 하기 위해 &lt;a href=&quot;https://atmospherejs.com/dferber/prerender/&quot;&gt; &lt;code&gt;dferber:prerender&lt;/code&gt; &lt;/a&gt; 패키지 덕분에 &lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt; 서비스를 사용할 수 있습니다 . &lt;code&gt;meteor add&lt;/code&gt; 으로 간단 하고 프리미엄 프리 렌더 계정이 있고 더 자주 캐시를 변경하려는 경우 프리 렌더 토큰을 선택적으로 설정합니다. 또한 &lt;a href=&quot;https://www.npmjs.com/package/prerender-node&quot;&gt; &lt;code&gt;prerender-node&lt;/code&gt; &lt;/a&gt; NPM 패키지를 직접 사용 하여 Atmosphere 패키지의 소량의 &lt;a href=&quot;https://github.com/dferber90/meteor-prerender/blob/master/client/prerender.html&quot;&gt;클라이언트&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/dferber90/meteor-prerender/blob/master/server/prerender.js&quot;&gt;서버&lt;/a&gt; 코드를 모방 할 수 있습니다 . &lt;code&gt;dferber:prerender&lt;/code&gt; 패키지보다 최신 버전의 NPM 패키지를 사용해야하는 경우이 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a768a43a236b5ea82c041d7df8e76472a7dbbaba" translate="yes" xml:space="preserve">
          <source>To do so, we use &lt;code&gt;attachSchema()&lt;/code&gt;:</source>
          <target state="translated">이를 위해 우리는 &lt;code&gt;attachSchema()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c3064ba3c3bc9bf6c5751a509112cdc7514f7e0b" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll use a very simple test helper that renders a Blaze component off-screen with a given data context. As we place it in &lt;code&gt;imports&lt;/code&gt;, it won&amp;rsquo;t load in our app by in normal mode (as it&amp;rsquo;s not required anywhere).</source>
          <target state="translated">이를 위해 주어진 데이터 컨텍스트에서 Blaze 구성 요소를 화면 밖으로 렌더링하는 매우 간단한 테스트 도우미를 사용합니다. &lt;code&gt;imports&lt;/code&gt; 에 배치하면 일반 모드 (어딘가 필요하지 않기 때문에)로 앱에로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ff636b12d986e98f989c21e7b6f8e715ec5fc87" translate="yes" xml:space="preserve">
          <source>To ensure the database is clean, the &lt;a href=&quot;https://atmospherejs.com/xolvio/cleaner&quot;&gt;&lt;code&gt;xolvio:cleaner&lt;/code&gt;&lt;/a&gt; package is useful. You can use it to reset the database in a &lt;code&gt;beforeEach&lt;/code&gt; block:</source>
          <target state="translated">데이터베이스를 깨끗하게하려면 &lt;a href=&quot;https://atmospherejs.com/xolvio/cleaner&quot;&gt; &lt;code&gt;xolvio:cleaner&lt;/code&gt; &lt;/a&gt; 패키지가 유용합니다. 이를 사용하여 &lt;code&gt;beforeEach&lt;/code&gt; 블록 에서 데이터베이스를 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e83ebaaf9a03f3c9ec0a00878488dab2fc3c08f7" translate="yes" xml:space="preserve">
          <source>To exclude specific fields from the result objects, the field specifier is a dictionary whose keys are field names and whose values are &lt;code&gt;0&lt;/code&gt;. All unspecified fields are included.</source>
          <target state="translated">결과 객체에서 특정 필드를 제외하기 위해 필드 지정자는 키가 필드 이름이고 값이 &lt;code&gt;0&lt;/code&gt; 인 사전입니다 . 지정되지 않은 모든 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c7dc59dc94ce9370f9fb28ded16d88dbe69a4ba0" translate="yes" xml:space="preserve">
          <source>To find out more about the API of the Migrations package, refer to &lt;a href=&quot;https://atmospherejs.com/percolate/migrations&quot;&gt;its documentation&lt;/a&gt;.</source>
          <target state="translated">마이그레이션 패키지의 API에 대한 자세한 내용은 &lt;a href=&quot;https://atmospherejs.com/percolate/migrations&quot;&gt;해당 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="518e1370fc3bf075f37072465daa36cb36517a04" translate="yes" xml:space="preserve">
          <source>To find that out, &lt;code&gt;Meteor.subscribe()&lt;/code&gt; and (&lt;code&gt;this.subscribe()&lt;/code&gt; in Blaze components) returns a &amp;ldquo;subscription handle&amp;rdquo;, which contains a reactive data source called &lt;code&gt;.ready()&lt;/code&gt;:</source>
          <target state="translated">그 밖에, 찾으려면 &lt;code&gt;Meteor.subscribe()&lt;/code&gt; 와 ( &lt;code&gt;this.subscribe()&lt;/code&gt; 블레이즈 구성 요소에서)라는 반응 데이터 소스가 들어있는 &quot;가입 핸들&quot;반환 &lt;code&gt;.ready()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8a565a3c59161196c5cb0a07442ef3d8376da2d8" translate="yes" xml:space="preserve">
          <source>To fully use the module system and ensure that our code only runs when we ask it to, we recommend that all of your application code should be placed inside the &lt;code&gt;imports/&lt;/code&gt; directory. This means that the Meteor build system will only bundle and include that file if it is referenced from another file using an &lt;code&gt;import&lt;/code&gt; (also called &amp;ldquo;lazy evaluation or loading&amp;rdquo;).</source>
          <target state="translated">모듈 시스템을 완전히 사용하고 코드를 요청할 때만 코드가 실행되도록하려면 모든 응용 프로그램 코드를 &lt;code&gt;imports/&lt;/code&gt; 디렉토리 안에 두는 것이 좋습니다 . 즉, Meteor 빌드 시스템은 &lt;code&gt;import&lt;/code&gt; ( &quot;지연 평가 또는로드&quot;라고도 함)를 사용하여 다른 파일에서 참조 된 경우에만 해당 파일을 번들링하고 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3a643a0227f5125cec9c22cfe467f934fdaa4fee" translate="yes" xml:space="preserve">
          <source>To generate a key:</source>
          <target state="translated">키를 생성하려면</target>
        </trans-unit>
        <trans-unit id="7e9c7c5069cc46c43a0fe4fbb79127bdc1495a68" translate="yes" xml:space="preserve">
          <source>To get Meteor to use the CDN for your Javascript and CSS bundles, call &lt;code&gt;WebAppInternals.setBundledJsCssPrefix(&quot;http://mycdn.com&quot;)&lt;/code&gt; on the server. This will also take care of relative image URLs inside your CSS files. If you need to use a dynamic prefix, you can return the prefix from a function passed to &lt;code&gt;WebAppInternals.setBundledJsCssUrlRewriteHook()&lt;/code&gt;.</source>
          <target state="translated">Meteor가 Javascript 및 CSS 번들에 CDN을 사용하도록 하려면 서버에서 &lt;code&gt;WebAppInternals.setBundledJsCssPrefix(&quot;http://mycdn.com&quot;)&lt;/code&gt; 를 호출 하십시오 . CSS 파일 내부의 상대 이미지 URL도 처리합니다. 동적 접두사를 사용해야하는 경우 &lt;code&gt;WebAppInternals.setBundledJsCssUrlRewriteHook()&lt;/code&gt; 전달 된 함수에서 접두사를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="083509a11ebc0343923c9ed2101dfbbdcc1b3374" translate="yes" xml:space="preserve">
          <source>To get a callback after a computation has been recomputed, you can call &lt;a href=&quot;#tracker_afterflush&quot;&gt;&lt;code&gt;Tracker.afterFlush&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;onInvalidate&lt;/code&gt;.</source>
          <target state="translated">계산이 재 계산 된 후 콜백을 받으려면 &lt;code&gt;onInvalidate&lt;/code&gt; 에서 &lt;a href=&quot;#tracker_afterflush&quot;&gt; &lt;code&gt;Tracker.afterFlush&lt;/code&gt; &lt;/a&gt; 를 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6ff0c69389a389eb4e79d3cfb2711f4cec23b17" translate="yes" xml:space="preserve">
          <source>To get around these restrictions, you&amp;rsquo;ll have to use what is known as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt;. In contrast to the whitelisting mechanism configured on the client, CORS relies on headers set by the server. In other words, in order to allow access to a remote resource, you may have to make configuration changes on the server, such as setting a &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">이러한 제한 사항을 해결하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS (Cross-Origin Resource Sharing&lt;/a&gt; )라는 것을 사용해야합니다 . CORS는 클라이언트에 구성된 화이트리스트 메커니즘과 달리 서버에서 설정 한 헤더를 사용합니다. 즉, 원격 리소스에 대한 액세스를 허용하기 위해 서버에서 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 설정과 같은 구성을 변경해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6a17d297a0ed288565efddad8aa5613aa4753b7" translate="yes" xml:space="preserve">
          <source>To get proper syntax highlighting, go to a .js file, then select the following through the &lt;em&gt;View&lt;/em&gt; dropdown menu: &lt;em&gt;Syntax&lt;/em&gt; -&amp;gt; &lt;em&gt;Open all with current extension as&amp;hellip;&lt;/em&gt; -&amp;gt; &lt;em&gt;Babel&lt;/em&gt; -&amp;gt; &lt;em&gt;JavaScript (Babel)&lt;/em&gt;. If you are using React .jsx files, do the same from a .jsx file. If it&amp;rsquo;s working, you will see &amp;ldquo;JavaScript (Babel)&amp;rdquo; in the lower right hand corner of the window when you are on one of these files. Refer to the &lt;a href=&quot;https://github.com/babel/babel-sublime&quot;&gt;package readme&lt;/a&gt; for information on compatible color schemes.</source>
          <target state="translated">올바른 구문 강조 표시를 얻으려면 .js 파일로 이동 한 다음 &lt;em&gt;보기&lt;/em&gt; 드롭 다운 메뉴를 통해 다음을 선택하십시오 . &lt;em&gt;구문&lt;/em&gt; -&amp;gt; &lt;em&gt;현재 확장자로 모두 열기&amp;hellip;&lt;/em&gt; -&amp;gt; &lt;em&gt;Babel-&lt;/em&gt; &amp;gt; &lt;em&gt;JavaScript (Babel)&lt;/em&gt; . React .jsx 파일을 사용하는 경우 .jsx 파일에서 동일한 작업을 수행하십시오. 작동하는 경우 이러한 파일 중 하나에있을 때 창의 오른쪽 하단에&amp;ldquo;JavaScript (바벨)&amp;rdquo;이 표시됩니다. 호환되는 색 구성표에 대한 내용 은 &lt;a href=&quot;https://github.com/babel/babel-sublime&quot;&gt;패키지 추가 정보&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="893855d63dbfcafd6b5027960d5d6bad6fc49291" translate="yes" xml:space="preserve">
          <source>To get started with React in Meteor, you can follow along the &lt;a href=&quot;https://www.meteor.com/tutorials/react/creating-an-app&quot;&gt;React tutorial&lt;/a&gt;. To see an example of a more complete Meteor application built with React, check out the &lt;a href=&quot;https://github.com/meteor/todos/tree/react&quot;&gt;&lt;code&gt;react&lt;/code&gt; branch&lt;/a&gt; of the Todos example application. Where applicable, code examples in this article will reference that app.</source>
          <target state="translated">Meteor에서 React를 시작하려면 &lt;a href=&quot;https://www.meteor.com/tutorials/react/creating-an-app&quot;&gt;React 튜토리얼을&lt;/a&gt; 따르십시오 . React로 빌드 된보다 완전한 Meteor 애플리케이션의 예를 보려면 Todos 예제 애플리케이션 의 &lt;a href=&quot;https://github.com/meteor/todos/tree/react&quot;&gt; &lt;code&gt;react&lt;/code&gt; 분기&lt;/a&gt; 를 확인하십시오 . 해당되는 경우이 기사의 코드 예제는 해당 앱을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1237ef25890ecb7c83c8507238bda2a4768be54f" translate="yes" xml:space="preserve">
          <source>To get started writing a package, use the Meteor command line tool:</source>
          <target state="translated">패키지 작성을 시작하려면 Meteor 명령 행 도구를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fcff710be19faa388283f090c0bbfef73c584354" translate="yes" xml:space="preserve">
          <source>To get started, run &lt;code&gt;meteor add universe:i18n&lt;/code&gt; to add it to your app. Add an English (&lt;code&gt;en-US&lt;/code&gt;) translation file in &lt;code&gt;JSON&lt;/code&gt; format to your app with the name &lt;code&gt;en-us.i18n.json&lt;/code&gt;. Translation files can be identified by file name or with the &lt;code&gt;{&quot;_locale&quot;: &quot;en-US&quot;}&lt;/code&gt; JSON property. The &lt;code&gt;YAML&lt;/code&gt; file format is also supported.</source>
          <target state="translated">시작하려면 &lt;code&gt;meteor add universe:i18n&lt;/code&gt; 을 실행 하여 앱에 추가하십시오. 이름이 &lt;code&gt;en-us.i18n.json&lt;/code&gt; 인 앱 에 &lt;code&gt;JSON&lt;/code&gt; 형식 의 영어 ( &lt;code&gt;en-US&lt;/code&gt; ) 번역 파일을 앱에 추가하십시오 . 번역 파일은 파일 이름 또는 &lt;code&gt;{&quot;_locale&quot;: &quot;en-US&quot;}&lt;/code&gt; JSON 속성 으로 식별 할 수 있습니다 . &lt;code&gt;YAML&lt;/code&gt; 의 파일 형식도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="151ec154149098f7e43708e70ab3d1aeb7854ef8" translate="yes" xml:space="preserve">
          <source>To get the full experience, you should also use the &lt;code&gt;es5-shim&lt;/code&gt; package which is included in all new apps by default. This means you can rely on runtime features like &lt;code&gt;Array#forEach&lt;/code&gt; without worrying about which browsers support them.</source>
          <target state="translated">완전한 경험을 얻으려면 기본적으로 모든 새로운 앱에 포함되어 있는 &lt;code&gt;es5-shim&lt;/code&gt; 패키지 도 사용해야합니다 . 즉, 어떤 브라우저에서 지원하는지 걱정할 필요없이 &lt;code&gt;Array#forEach&lt;/code&gt; 와 같은 런타임 기능에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3126a82b51c023edcd49d2e4f2d37d44f8ed4368" translate="yes" xml:space="preserve">
          <source>To handle more than one event / selector with the same function, use a comma-separated list.</source>
          <target state="translated">동일한 기능으로 둘 이상의 이벤트 / 선택자를 처리하려면 쉼표로 구분 된 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb51b8da00a2350bda11d13a4dbddef6793d1057" translate="yes" xml:space="preserve">
          <source>To help you write good Methods that exhaustively validate their arguments, we&amp;rsquo;ve written a simple wrapper package for Methods that enforces argument validation. Read more about how to use it in the &lt;a href=&quot;methods#validated-method&quot;&gt;Methods article&lt;/a&gt;. The rest of the code samples in this article will assume that you are using this package. If you aren&amp;rsquo;t, you can still apply the same principles but the code will look a little different.</source>
          <target state="translated">인수를 철저하게 검증하는 좋은 메소드를 작성하는 데 도움을주기 위해 인수 검증을 시행하는 메소드에 대한 간단한 랩퍼 패키지를 작성했습니다. &lt;a href=&quot;methods#validated-method&quot;&gt;Methods 기사&lt;/a&gt; 에서 사용법에 대해 자세히 읽어보십시오 . 이 기사의 나머지 코드 샘플에서는이 패키지를 사용한다고 가정합니다. 그렇지 않은 경우에도 동일한 원칙을 적용 할 수 있지만 코드는 약간 다르게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b15a95a8081b30a704b341479c98fb80fe07d12" translate="yes" xml:space="preserve">
          <source>To import a method named &lt;code&gt;exportedPackageMethod&lt;/code&gt;, simply:</source>
          <target state="translated">라는 방법을 가져 오려면 &lt;code&gt;exportedPackageMethod&lt;/code&gt; 단지를 :</target>
        </trans-unit>
        <trans-unit id="cd4e955cbe7e715ad66ced8ce2a933691be63e92" translate="yes" xml:space="preserve">
          <source>To include CSS files with your package you can use &lt;a href=&quot;http://docs.meteor.com/#/full/pack_addFiles&quot;&gt;&lt;code&gt;api.addFiles()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">패키지에 CSS 파일을 포함시키기 위해 &lt;a href=&quot;http://docs.meteor.com/#/full/pack_addFiles&quot;&gt; &lt;code&gt;api.addFiles()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2e05e948984ca7920b990616137fbf5b4325ad75" translate="yes" xml:space="preserve">
          <source>To include only specific fields in the result documents, use &lt;code&gt;1&lt;/code&gt; as the value. The &lt;code&gt;_id&lt;/code&gt; field is still included in the result.</source>
          <target state="translated">결과 문서에 특정 필드 만 포함 시키려면 &lt;code&gt;1&lt;/code&gt; 을 값으로 사용 하십시오. &lt;code&gt;_id&lt;/code&gt; 필드는 여전히 결과에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a768afacff969a47bc3ef71c575e618ff454162" translate="yes" xml:space="preserve">
          <source>To insert a literal &lt;code&gt;{{&lt;/code&gt;, &lt;code&gt;{{{&lt;/code&gt;, or any number of curly braces, put a vertical bar after it. So &lt;code&gt;{{|&lt;/code&gt; will show up as &lt;code&gt;{{&lt;/code&gt;, &lt;code&gt;{{{|&lt;/code&gt; will show up as &lt;code&gt;{{{&lt;/code&gt;, and so on.</source>
          <target state="translated">리터럴 &lt;code&gt;{{&lt;/code&gt; , &lt;code&gt;{{{&lt;/code&gt; 또는 여러 개의 중괄호 를 삽입하려면 그 뒤에 수직 막대를 넣으십시오. 따라서 &lt;code&gt;{{|&lt;/code&gt; 로 표시됩니다 &lt;code&gt;{{&lt;/code&gt; , &lt;code&gt;{{{|&lt;/code&gt; &lt;code&gt;{{{&lt;/code&gt; 등 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="159c4fc12d09660b9440e023e6407ec37258b099" translate="yes" xml:space="preserve">
          <source>To insert literal curly braces: &lt;code&gt;{{ }}&lt;/code&gt; and the like, add a pipe character, &lt;code&gt;|&lt;/code&gt;, to the opening braces:</source>
          <target state="translated">리터럴 중괄호 ( &lt;code&gt;{{ }}&lt;/code&gt; 등) 를 삽입하려면 파이프 문자 &lt;code&gt;|&lt;/code&gt; , 여는 중괄호 :</target>
        </trans-unit>
        <trans-unit id="aac0c6aa8b888b26e1c1478b1fa3d46df59f41dc" translate="yes" xml:space="preserve">
          <source>To install React in Meteor 1.3 you should simply add it as an npm dependency:</source>
          <target state="translated">Meteor 1.3에서 React를 설치하려면 간단히 npm 종속성으로 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4de29a47510c144543e45f3da5c47947b9193d" translate="yes" xml:space="preserve">
          <source>To install a package into your app you run the &lt;code&gt;npm install&lt;/code&gt; command with the &lt;code&gt;--save&lt;/code&gt; flag:</source>
          <target state="translated">앱에 패키지를 설치하려면 &lt;code&gt;--save&lt;/code&gt; 플래그 와 함께 &lt;code&gt;npm install&lt;/code&gt; 명령 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4dfb33e0812488c4502e9d019222e2ca9ba89e94" translate="yes" xml:space="preserve">
          <source>To install an Atmosphere package, you simply run &lt;code&gt;meteor add&lt;/code&gt;:</source>
          <target state="translated">Atmosphere 패키지를 설치하려면 &lt;code&gt;meteor add&lt;/code&gt; 를 실행 하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="65c7b0c2baa95fc697ec0b486a6699e6b2d07d01" translate="yes" xml:space="preserve">
          <source>To install an older version of SDK tools:</source>
          <target state="translated">이전 버전의 SDK 도구를 설치하려면</target>
        </trans-unit>
        <trans-unit id="6724f8aced3b9c11dcafc95c2cd737a185b83efa" translate="yes" xml:space="preserve">
          <source>To integrate the two systems, we&amp;rsquo;ve developed a &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt;&lt;code&gt;react-meteor-data&lt;/code&gt;&lt;/a&gt; package which allows React components to respond to data changes via Meteor&amp;rsquo;s &lt;a href=&quot;https://www.meteor.com/tracker&quot;&gt;Tracker&lt;/a&gt; reactivity system.</source>
          <target state="translated">두 시스템을 통합하기 위해 React 구성 요소가 Meteor의 &lt;a href=&quot;https://www.meteor.com/tracker&quot;&gt;Tracker&lt;/a&gt; 반응성 시스템을 통해 데이터 변경에 응답 할 수 있는 &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt; &lt;code&gt;react-meteor-data&lt;/code&gt; &lt;/a&gt; 패키지를 개발했습니다 .</target>
        </trans-unit>
        <trans-unit id="56d3564187390ed1e003c9f98758ef5c8a2f6b15" translate="yes" xml:space="preserve">
          <source>To learn more about using React in general and coming up to speed with the library, you should check out the &lt;a href=&quot;https://facebook.github.io/react/docs/getting-started.html&quot;&gt;React documentation&lt;/a&gt;, especially the &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;thinking in React&lt;/a&gt; post, which explains the React philosophy well.</source>
          <target state="translated">일반적으로 React를 사용하고 라이브러리를 빠르게 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://facebook.github.io/react/docs/getting-started.html&quot;&gt;React 문서&lt;/a&gt; , 특히 React 철학을 잘 설명하는 React post 의 &lt;a href=&quot;https://facebook.github.io/react/docs/thinking-in-react.html&quot;&gt;생각을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7be6e9a877bd53d1d673ad21f25bbe30867186b9" translate="yes" xml:space="preserve">
          <source>To maintain type safety, you can take advantage of TypeScript&amp;rsquo;s import elision and reference the types using the &lt;code&gt;typeof&lt;/code&gt; keyword. See the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/modules.html#optional-module-loading-and-other-advanced-loading-scenarios&quot;&gt;TypeScript handbook article&lt;/a&gt; for details or &lt;a href=&quot;http://ideasintosoftware.com/typescript-conditional-imports/&quot;&gt;this blog post&lt;/a&gt; for a concrete Meteor example.</source>
          <target state="translated">형식 안전성을 유지하기 위해 TypeScript의 가져 오기 제거 기능을 활용하고 &lt;code&gt;typeof&lt;/code&gt; 키워드를 사용하여 형식을 참조 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/modules.html#optional-module-loading-and-other-advanced-loading-scenarios&quot;&gt;TypeScript 핸드북 기사&lt;/a&gt; 를 참조하거나 구체적인 Meteor 예제는 &lt;a href=&quot;http://ideasintosoftware.com/typescript-conditional-imports/&quot;&gt;이 블로그 게시물&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d96712ff0cf5452414572df486c9a663c0830af" translate="yes" xml:space="preserve">
          <source>To make this easier, we can attach functions to the prototype of the documents that belong to a given collection, to give us &amp;ldquo;methods&amp;rdquo; on the documents (in the object oriented sense). We can then use these methods to create new queries to find related documents.</source>
          <target state="translated">이를보다 쉽게하기 위해, 주어진 컬렉션에 속하는 문서의 프로토 타입에 함수를 첨부하여 문서에 대한 &quot;방법&quot;을 제공 할 수 있습니다 (객체 지향적 의미로). 그런 다음이 방법을 사용하여 새 문서를 작성하여 관련 문서를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91224ae6dcebefbaa340524c9967570d3a9b865c" translate="yes" xml:space="preserve">
          <source>To orchestrate your own container-based deployment there are existing base images to consider before rolling your own:</source>
          <target state="translated">자체 컨테이너 기반 배포를 조정하려면 자체 배포 전에 고려해야 할 기존 기본 이미지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9154b71efe563daa58944cd919fae47c3e1fd255" translate="yes" xml:space="preserve">
          <source>To pass a callback to a React component that you are including with this helper, simply make a &lt;a href=&quot;http://blazejs.org/guide/reusable-components.html#Pass-callbacks&quot;&gt;template helper that returns a function&lt;/a&gt;, and pass it in as a prop, like so:</source>
          <target state="translated">이 헬퍼에 포함 된 React 컴포넌트에 콜백을 전달하려면 단순히 &lt;a href=&quot;http://blazejs.org/guide/reusable-components.html#Pass-callbacks&quot;&gt;함수를 리턴하는 템플리트 헬퍼를&lt;/a&gt; 작성하고 이를 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="bb59cd487bde7d1322d518f6f6b4daf80a607e47" translate="yes" xml:space="preserve">
          <source>To pass additional options to Node.js use the &lt;code&gt;NODE_OPTIONS&lt;/code&gt; environment variable. For example: &lt;code&gt;NODE_OPTIONS='--debug'&lt;/code&gt; or &lt;code&gt;NODE_OPTIONS='--debug-brk'&lt;/code&gt;</source>
          <target state="translated">Node.js에 추가 옵션을 전달하려면 &lt;code&gt;NODE_OPTIONS&lt;/code&gt; 환경 변수를 사용하십시오 . 예를 들면 다음과 같습니다. &lt;code&gt;NODE_OPTIONS='--debug'&lt;/code&gt; 또는 &lt;code&gt;NODE_OPTIONS='--debug-brk'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20e5eba1a0f3808376de81e4e3858f9e902eb214" translate="yes" xml:space="preserve">
          <source>To publish a package for the first time, use &lt;code&gt;meteor publish --create&lt;/code&gt;.</source>
          <target state="translated">패키지를 처음으로 &lt;code&gt;meteor publish --create&lt;/code&gt; 하려면 meteor publish --create를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="527330003be5c43207d078408f899a784b3f44c5" translate="yes" xml:space="preserve">
          <source>To publish publicly, &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;follow these instructions&lt;/a&gt;. When you&amp;rsquo;re done, anyone can add your package to their app with &lt;code&gt;npm install --save your-package&lt;/code&gt;.</source>
          <target state="translated">공개적으로 게시 &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;하려면 다음 지침을 따르십시오&lt;/a&gt; . 완료되면 누구나 &lt;code&gt;npm install --save your-package&lt;/code&gt; 를 사용 하여 패키지를 앱에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2fe6b82a49f279121fa4ad86b0495385edb893d" translate="yes" xml:space="preserve">
          <source>To publish records to clients, call &lt;code&gt;Meteor.publish&lt;/code&gt; on the server with two parameters: the name of the record set, and a &lt;em&gt;publish function&lt;/em&gt; that Meteor will call each time a client subscribes to the name.</source>
          <target state="translated">레코드를 클라이언트에 게시하려면 서버에서 &lt;code&gt;Meteor.publish&lt;/code&gt; 를 호출 하십시오. 레코드 세트의 이름과 클라이언트가 이름을 구독 할 때마다 Meteor가 호출 하는 &lt;em&gt;게시 함수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92d704cb2ecb8eaf3a9c4b3aeafeb43d83a7b0ab" translate="yes" xml:space="preserve">
          <source>To publish to a release track for the first time, use the &lt;code&gt;--create-track&lt;/code&gt; flag.</source>
          <target state="translated">릴리스 트랙에 처음으로 게시하려면 &lt;code&gt;--create-track&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="943f27f05db80da724049b8e2848fc0eac66d12d" translate="yes" xml:space="preserve">
          <source>To publish your package to Atmosphere, run &lt;a href=&quot;http://docs.meteor.com/#/full/meteorpublish&quot;&gt;&lt;code&gt;meteor publish&lt;/code&gt;&lt;/a&gt; from the package directory. To publish a package the package name must follow the format of &lt;code&gt;username:my-package&lt;/code&gt; and the package must contain a &lt;a href=&quot;#version-constraints&quot;&gt;SemVer version number&lt;/a&gt;.</source>
          <target state="translated">패키지를 Atmosphere에 &lt;a href=&quot;http://docs.meteor.com/#/full/meteorpublish&quot;&gt; &lt;code&gt;meteor publish&lt;/code&gt; &lt;/a&gt; 하려면 package 디렉토리에서 meteor publish 를 실행 하십시오. 패키지를 게시하려면 패키지 이름이 &lt;code&gt;username:my-package&lt;/code&gt; 형식을 따라야 하며 패키지는 &lt;a href=&quot;#version-constraints&quot;&gt;SemVer 버전 번호를&lt;/a&gt; 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c6e1b3bad2cef83474e361de7129172837aa3d8" translate="yes" xml:space="preserve">
          <source>To register a compiler plugin in your package, you need to do the following in your &lt;code&gt;package.js&lt;/code&gt; file:</source>
          <target state="translated">패키지에 컴파일러 플러그인을 등록하려면 &lt;code&gt;package.js&lt;/code&gt; 파일 에서 다음을 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="70f222ca7270bbb1d2257dae311e65ec53867601" translate="yes" xml:space="preserve">
          <source>To register a linter build plugin in your package, you need to do a couple of things in your &lt;code&gt;package.js&lt;/code&gt;:</source>
          <target state="translated">패키지에 linter 빌드 플러그인을 등록하려면 &lt;code&gt;package.js&lt;/code&gt; 에서 몇 가지 작업을 수행해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="adb98c78462560bd4ad9f58fe0504a52496105dc" translate="yes" xml:space="preserve">
          <source>To register a minifier plugin in your package, add the following in your &lt;code&gt;package.js&lt;/code&gt; file:</source>
          <target state="translated">패키지에 축소 기 플러그인을 등록하려면 &lt;code&gt;package.js&lt;/code&gt; 파일에 다음을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="1c8a804a7bd997f4f26015c9fd7cf3f1ad8f86b9" translate="yes" xml:space="preserve">
          <source>To remove a version constraint for a specific package, run &lt;code&gt;meteor add&lt;/code&gt; again without specifying a version. For example above, to stop using version &lt;code&gt;1.1.0&lt;/code&gt; exactly, run &lt;code&gt;meteor add package&lt;/code&gt;.</source>
          <target state="translated">특정 패키지에 대한 버전 제약 조건을 제거하려면 버전 을 지정하지 않고 &lt;code&gt;meteor add&lt;/code&gt; 를 다시 실행 하십시오. 예를 들어, 버전 &lt;code&gt;1.1.0&lt;/code&gt; 을 정확하게 사용하지 않으려면 &lt;code&gt;meteor add package&lt;/code&gt; 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a54fbd95e6effd52fd8ea6b988d5fdd111837c94" translate="yes" xml:space="preserve">
          <source>To remove an unwanted Atmosphere package run:</source>
          <target state="translated">원하지 않는 분위기 패키지를 제거하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8e0588ce4da8859f547b94b040e16f58fbac7712" translate="yes" xml:space="preserve">
          <source>To request them at runtime, consider using the &lt;a href=&quot;https://github.com/dpa99c/cordova-diagnostic-plugin&quot;&gt;&lt;code&gt;cordova.plugins.diagnostic&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">런타임에 요청하려면 &lt;a href=&quot;https://github.com/dpa99c/cordova-diagnostic-plugin&quot;&gt; &lt;code&gt;cordova.plugins.diagnostic&lt;/code&gt; &lt;/a&gt; 플러그인 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="b785c9ffe98a48372bd2c6c56ed1db2c560368a6" translate="yes" xml:space="preserve">
          <source>To run a migration against your development database, it&amp;rsquo;s easiest to use the Meteor shell:</source>
          <target state="translated">개발 데이터베이스에 대해 마이그레이션을 실행하려면 Meteor 셸을 사용하는 것이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="32df57f617c869a6e38979dc630b32322e8ab519" translate="yes" xml:space="preserve">
          <source>To run a migration against your production database, run your app locally in production mode (with production settings and environment variables, including database settings), and use the Meteor shell in the same way. What this does is run the &lt;code&gt;up()&lt;/code&gt; function of all outstanding migrations, against your production database. In our case, it should ensure all lists have a &lt;code&gt;todoCount&lt;/code&gt; field set.</source>
          <target state="translated">프로덕션 데이터베이스에 대해 마이그레이션을 실행하려면 프로덕션 모드에서 데이터베이스를 포함하여 프로덕션 설정 및 환경 변수와 함께 앱을 로컬로 실행하고 동일한 방식으로 Meteor 셸을 사용하십시오. 이것이하는 일은 프로덕션 데이터베이스에 대해 모든 미해결 마이그레이션 의 &lt;code&gt;up()&lt;/code&gt; 함수를 실행하는 것 입니다. 이 경우 모든 목록에 &lt;code&gt;todoCount&lt;/code&gt; 필드가 설정 되어 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a6363e284732c1e8431252139699e7c7aa9114c2" translate="yes" xml:space="preserve">
          <source>To run acceptance tests, we simply need to start our Meteor app as usual, and point Chimp at it.</source>
          <target state="translated">수락 테스트를 실행하려면 평소처럼 Meteor 앱을 시작하고 Chimp를 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="7482995f6f41dbf7835d0f1e35691487c3b162b5" translate="yes" xml:space="preserve">
          <source>To run the &lt;a href=&quot;#test-modes&quot;&gt;full-app tests&lt;/a&gt; in our application, we run:</source>
          <target state="translated">애플리케이션에서 &lt;a href=&quot;#test-modes&quot;&gt;전체 앱 테스트&lt;/a&gt; 를 실행하려면 다음을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4af85ca590bedf942279e432e4051efd8797f79c" translate="yes" xml:space="preserve">
          <source>To run the linter, you can now simply type:</source>
          <target state="translated">린터를 실행하려면 다음을 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="91ecd61c591d15456fbd8a7abc557338c58ffe3d" translate="yes" xml:space="preserve">
          <source>To run the tests that our app defines, we run our app in &lt;a href=&quot;#test-modes&quot;&gt;test mode&lt;/a&gt;:</source>
          <target state="translated">앱에서 정의한 테스트를 실행하기 위해 &lt;a href=&quot;#test-modes&quot;&gt;테스트 모드&lt;/a&gt; 에서 앱을 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="6d29f9a1f0846c19394927f4ddf634ba42100a88" translate="yes" xml:space="preserve">
          <source>To run the tests, visit &lt;a href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt; in your browser. This kicks off &lt;code&gt;practicalmeteor:mocha&lt;/code&gt;, which runs your tests both in the browser and on the server. It displays the test results in the browser in a Mocha test reporter:</source>
          <target state="translated">테스트를 실행하려면 브라우저에서 &lt;a href=&quot;http://localhost:3000&quot;&gt;http : // localhost : 3000&lt;/a&gt; 을 방문 하십시오 . 이것은 actualmeteor &lt;code&gt;practicalmeteor:mocha&lt;/code&gt; 시작 하여 브라우저와 서버에서 테스트를 실행합니다. 브라우저에서 Mocha 테스트 리포터의 테스트 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0b89b7e8c53deccf92bd51333b162e5480106210" translate="yes" xml:space="preserve">
          <source>To see all the Atmosphere packages installed run:</source>
          <target state="translated">설치된 모든 분위기 패키지를 보려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="be19c3df28624e7a1bf22f819db8f3e9d9376549" translate="yes" xml:space="preserve">
          <source>To see what options are available to you, read the complete description of the &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_passwords&quot;&gt;&lt;code&gt;accounts-password&lt;/code&gt; API in the Meteor docs&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션을 확인하려면 &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_passwords&quot;&gt;Meteor docs에서 &lt;/a&gt; &lt;code&gt;accounts-password&lt;/code&gt; API에 대한 전체 설명을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b0d5b3a3e30176d40e53bf24dc31b8037a8af8ae" translate="yes" xml:space="preserve">
          <source>To set and change the language that a user is seeing, you should call &lt;code&gt;TAPi18n.setLanguage(fn)&lt;/code&gt;, where &lt;code&gt;fn&lt;/code&gt; is a (possibly reactive) function that returns the current language. For instance you could write</source>
          <target state="translated">사용자가보고있는 언어를 설정하고 변경하려면 &lt;code&gt;TAPi18n.setLanguage(fn)&lt;/code&gt; 호출해야합니다 . 여기서 &lt;code&gt;fn&lt;/code&gt; 은 현재 언어를 반환하는 (반응 형) 함수입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e492a3c53e0896a354d18ab5ae0568e88766b4eb" translate="yes" xml:space="preserve">
          <source>To setup ESLint in your application, you can install the following &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm&lt;/a&gt; packages:</source>
          <target state="translated">응용 프로그램에서 ESLint를 설정하기 위해 다음 &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm&lt;/a&gt; 패키지를 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49464f868af9c94f409e998de694382cdd49d31d" translate="yes" xml:space="preserve">
          <source>To sign your app, you&amp;rsquo;ll need a private key. This key lets you publish and update your app. If you haven&amp;rsquo;t made a key for this app yet, run:</source>
          <target state="translated">앱에 서명하려면 개인 키가 필요합니다. 이 키를 사용하면 앱을 게시하고 업데이트 할 수 있습니다. 이 앱의 키를 아직 만들지 않은 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e95fc7df2acd06264c3dbd5b714c5f36f66449a3" translate="yes" xml:space="preserve">
          <source>To specify a port to listen on (instead of the default 3000), use &lt;code&gt;--port [PORT]&lt;/code&gt;. (The development server also uses port &lt;code&gt;N+1&lt;/code&gt; for the default MongoDB instance)</source>
          <target state="translated">기본 3000 대신 수신 대기 할 포트를 지정하려면 &lt;code&gt;--port [PORT]&lt;/code&gt; 를 사용하십시오 . (개발 서버는 기본 MongoDB 인스턴스에 포트 &lt;code&gt;N+1&lt;/code&gt; 도 사용 합니다)</target>
        </trans-unit>
        <trans-unit id="0e1a4f3e6eefd2251bedc17a2e534e23716c0d94" translate="yes" xml:space="preserve">
          <source>To start, let&amp;rsquo;s look at our &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos example application&lt;/a&gt;, which is a great example to follow when structuring your app. Below is an overview of its directory structure. You can generate a new app with this structure using the command &lt;code&gt;meteor create appName --full&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos 예제 애플리케이션을&lt;/a&gt; 살펴 보자 . 앱을 구성 할 때 따라야 할 훌륭한 예제이다. 아래는 디렉토리 구조의 개요입니다. &lt;code&gt;meteor create appName --full&lt;/code&gt; 명령을 사용하여이 구조로 새 앱을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">요약:</target>
        </trans-unit>
        <trans-unit id="c83c61683d4dad1ee11657a12ed5e9639f104d2f" translate="yes" xml:space="preserve">
          <source>To throttle writes, a typical approach is to use underscore&amp;rsquo;s &lt;a href=&quot;http://underscorejs.org/#throttle&quot;&gt;&lt;code&gt;.throttle()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://underscorejs.org/#debounce&quot;&gt;&lt;code&gt;.debounce()&lt;/code&gt;&lt;/a&gt; functions. For instance, in the Todos example app, we throttle writes on user input to 300ms:</source>
          <target state="translated">쓰기를 조절하기 위해 일반적인 접근 방식은 밑줄의 &lt;a href=&quot;http://underscorejs.org/#throttle&quot;&gt; &lt;code&gt;.throttle()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://underscorejs.org/#debounce&quot;&gt; &lt;code&gt;.debounce()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. 예를 들어, Todos 예제 앱에서 사용자 입력에 대한 쓰기를 300ms로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="6533f8b171f29c5816af4a97430c2edb37bb3744" translate="yes" xml:space="preserve">
          <source>To turn AppCache off for specific browsers use:</source>
          <target state="translated">특정 브라우저에서 AppCache를 끄려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f44b3c20156dfcb966dfaf567376efa26a8b538" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;DDPRateLimiter&lt;/code&gt; for modifying the default rate-limiting rules, add the &lt;code&gt;ddp-rate-limiter&lt;/code&gt; package to your project in your terminal:</source>
          <target state="translated">기본 속도 제한 규칙을 수정 하기 위해 &lt;code&gt;DDPRateLimiter&lt;/code&gt; 를 사용하려면 터미널의 프로젝트에 &lt;code&gt;ddp-rate-limiter&lt;/code&gt; 패키지를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eee61dad927f167f72684f93f35d91882bbb60fe" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;ReactiveVar&lt;/code&gt;, add the &lt;code&gt;reactive-var&lt;/code&gt; package to your project by running in your terminal:</source>
          <target state="translated">&lt;code&gt;ReactiveVar&lt;/code&gt; 를 사용하려면 터미널에서 실행 하여 &lt;code&gt;reactive-var&lt;/code&gt; 패키지를 프로젝트에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd100aba1fbcb5a43429e4f5cb263049645886c3" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;tap:i18n&lt;/code&gt;, first &lt;code&gt;meteor add tap:i18n&lt;/code&gt; to add it to your app. Then we need to add a translation JSON file for our default language (&lt;code&gt;en&lt;/code&gt; for English) &amp;ndash; we can put it at &lt;code&gt;i18n/en.i18n.json&lt;/code&gt;. Once we&amp;rsquo;ve done that we can import and use the &lt;code&gt;TAPi18n.__()&lt;/code&gt; function to get translations for strings or keys within our JavaScript code.</source>
          <target state="translated">&lt;code&gt;tap:i18n&lt;/code&gt; 을 사용하려면 먼저 &lt;code&gt;meteor add tap:i18n&lt;/code&gt; 을 앱에 추가하십시오. 그런 다음 기본 언어 ( 영어의 경우 &lt;code&gt;en&lt;/code&gt; ) 로 번역 JSON 파일을 추가해야합니다 . &lt;code&gt;i18n/en.i18n.json&lt;/code&gt; 에 넣을 수 있습니다 . 완료되면 &lt;code&gt;TAPi18n.__()&lt;/code&gt; 함수를 가져 와서 JavaScript 코드 내에서 문자열 또는 키에 대한 번역을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec5c3505a5272c0d1faceb3a43e931c7bcb12cd" translate="yes" xml:space="preserve">
          <source>To use an Atmosphere Package in your app you can import it with the &lt;code&gt;meteor/&lt;/code&gt; prefix:</source>
          <target state="translated">앱에서 분위기 패키지를 사용하려면 &lt;code&gt;meteor/&lt;/code&gt; 접두사 를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b02f75570d9ff673fb25a140cc15f35c4b13233" translate="yes" xml:space="preserve">
          <source>To use an npm package from a file in your application you simply &lt;code&gt;import&lt;/code&gt; the name of the package:</source>
          <target state="translated">응용 프로그램의 파일에서 npm 패키지를 사용하려면 패키지 이름을 &lt;code&gt;import&lt;/code&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="eddd004a514ac2215f120d35caf57c44cf72dd3b" translate="yes" xml:space="preserve">
          <source>To use data from a Meteor collection inside a React component, install &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt;&lt;code&gt;react-meteor-data&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">React 컴포넌트 내에서 Meteor 콜렉션의 데이터를 사용하려면 &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt; &lt;code&gt;react-meteor-data&lt;/code&gt; 를&lt;/a&gt; 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="8710d2dc353d315fe5dabead351df0239da0663c" translate="yes" xml:space="preserve">
          <source>To use it in Blaze:</source>
          <target state="translated">Blaze에서 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="2529ac4d2806e5f597d4647eb98ac036671d711b" translate="yes" xml:space="preserve">
          <source>To use publications, you need to create a subscription to it on the client. To do so, you call &lt;code&gt;Meteor.subscribe()&lt;/code&gt; with the name of the publication. When you do this, it opens up a subscription to that publication, and the server starts sending data down the wire to ensure that your client collections contain up to date copies of the data specified by the publication.</source>
          <target state="translated">발행물을 사용하려면 클라이언트에서 발행물을 작성해야합니다. 그렇게하려면 게시 이름으로 &lt;code&gt;Meteor.subscribe()&lt;/code&gt; 를 호출 하십시오. 이 작업을 수행하면 해당 게시에 대한 구독이 열리고 서버는 클라이언트 컬렉션에 게시에서 지정한 데이터의 최신 복사본이 포함되도록 유선으로 데이터를 보내기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93c9d5b7ae4011b1e04433e238d56705d9484724" translate="yes" xml:space="preserve">
          <source>To use remote debugging in Safari, you&amp;rsquo;ll first need to enable the Developer menu. Go to &lt;em&gt;Safari &amp;gt; Preferences&lt;/em&gt; and make sure &amp;lsquo;Show Develop menu in menu bar&amp;rsquo; is checked:</source>
          <target state="translated">Safari에서 원격 디버깅을 사용하려면 먼저 개발자 메뉴를 활성화해야합니다. &lt;em&gt;Safari&amp;gt; 환경 설정으로&lt;/em&gt; 이동하여 '메뉴 막대에 개발 메뉴 표시'가 선택되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0c5bc8e300a3279a22bfa4d7d8a85474e2a3797b" translate="yes" xml:space="preserve">
          <source>To use shrinkpack, first globally install it:</source>
          <target state="translated">수축 팩을 사용하려면 먼저 전역으로 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6b20c6cf1de2fcb393f33d879382a297bf883b54" translate="yes" xml:space="preserve">
          <source>To use the factory in a test, we simply call &lt;code&gt;Factory.create&lt;/code&gt;:</source>
          <target state="translated">테스트에서 팩토리를 사용하려면 &lt;code&gt;Factory.create&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="c07d9c508c0bb90680810845aec84361b9777cf0" translate="yes" xml:space="preserve">
          <source>To use this package, we need to define a &amp;ldquo;layout&amp;rdquo; component. In the Todos example app, that component is called &lt;code&gt;App_body&lt;/code&gt;:</source>
          <target state="translated">이 패키지를 사용하려면&amp;ldquo;레이아웃&amp;rdquo;구성 요소를 정의해야합니다. Todos 예제 앱에서 해당 컴포넌트의 이름은 &lt;code&gt;App_body&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7437bf72ebd1cf2ed63cd1afd16388e616aadb7f" translate="yes" xml:space="preserve">
          <source>To write data back to the server, you use a &lt;em&gt;Method&lt;/em&gt;, the subject of the &lt;a href=&quot;methods&quot;&gt;methods article&lt;/a&gt;.</source>
          <target state="translated">서버에 데이터를 다시 쓰려면 &lt;a href=&quot;methods&quot;&gt;메소드 기사&lt;/a&gt; 의 주제 인 &lt;em&gt;Method&lt;/em&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5db3239e498cad5ccfc3768fc1f7de9179b6a09" translate="yes" xml:space="preserve">
          <source>Tools like &lt;a href=&quot;http://browserify.org&quot;&gt;browserify&lt;/a&gt; and &lt;a href=&quot;https://webpack.github.io&quot;&gt;webpack&lt;/a&gt; are designed to provide a Node-like environment on the client so that many npm packages, even ones originally intended for the server, can run unmodified. Meteor&amp;rsquo;s ES2015 module system does this for you out of the box with no additional configuration necessary. In most cases, you can simply import npm dependencies from a client file, just as you would on the server.</source>
          <target state="translated">같은 도구 &lt;a href=&quot;http://browserify.org&quot;&gt;browserify&lt;/a&gt; 와 &lt;a href=&quot;https://webpack.github.io&quot;&gt;웹팩은&lt;/a&gt; A가 노드처럼 많은 NPM 패키지, 심지어 사람이 원래 서버를위한 그래서 클라이언트 환경, 수정되지 않은 실행할 수 있습니다 제공하도록 설계되었습니다. Meteor의 ES2015 모듈 시스템은 추가 구성없이 바로 사용할 수 있습니다. 대부분의 경우 서버에서와 마찬가지로 클라이언트 파일에서 npm 종속성을 간단히 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb90eb6ed224e27aae8dcf93409a2c0dae78f0a1" translate="yes" xml:space="preserve">
          <source>Top-level Elements in a &lt;code&gt;.html&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.html&lt;/code&gt; 파일의 최상위 요소</target>
        </trans-unit>
        <trans-unit id="c15771fc77a45dae33911c04bb171e6f49fa33cb" translate="yes" xml:space="preserve">
          <source>Tracker</source>
          <target state="translated">Tracker</target>
        </trans-unit>
        <trans-unit id="0fc9210e465ad693259057d1e18ab00a6a0a27d9" translate="yes" xml:space="preserve">
          <source>Tracker.Computation</source>
          <target state="translated">Tracker.Computation</target>
        </trans-unit>
        <trans-unit id="40abde14676099fc15058b971f3b7e5f33425e90" translate="yes" xml:space="preserve">
          <source>Tracker.Dependency</source>
          <target state="translated">Tracker.Dependency</target>
        </trans-unit>
        <trans-unit id="d6faef47982e15f8398607dca0cbf140a673f0b4" translate="yes" xml:space="preserve">
          <source>Triple-braced Tags</source>
          <target state="translated">트리플 브레이스 태그</target>
        </trans-unit>
        <trans-unit id="b90524605603fa0385a548e1dac399c130060cfa" translate="yes" xml:space="preserve">
          <source>Triple-braced tags are used to insert raw HTML into a template:</source>
          <target state="translated">삼중 괄호 태그는 템플릿에 원시 HTML을 삽입하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="297b38b7eb29ec5686435955320303c43ef3fa0e" translate="yes" xml:space="preserve">
          <source>True during the initial run of the computation at the time &lt;code&gt;Tracker.autorun&lt;/code&gt; is called, and false on subsequent reruns and at other times.</source>
          <target state="translated">&lt;code&gt;Tracker.autorun&lt;/code&gt; 이 호출 될 때 계산의 초기 실행 중에는 true 이고, 후속 재실행에서 또는 다른 경우에는 false입니다.</target>
        </trans-unit>
        <trans-unit id="337f1addcc2851e038a87f915a64650caf8dc133" translate="yes" xml:space="preserve">
          <source>True if a login method (such as &lt;code&gt;Meteor.loginWithPassword&lt;/code&gt;, &lt;code&gt;Meteor.loginWithFacebook&lt;/code&gt;, or &lt;code&gt;Accounts.createUser&lt;/code&gt;) is currently in progress. A reactive data source.</source>
          <target state="translated">로그인 방법 (예 : &lt;code&gt;Meteor.loginWithPassword&lt;/code&gt; , &lt;code&gt;Meteor.loginWithFacebook&lt;/code&gt; 또는 &lt;code&gt;Accounts.createUser&lt;/code&gt; )이 진행중인 경우 True 입니다. 반응적인 데이터 소스.</target>
        </trans-unit>
        <trans-unit id="2de2e1c51dcf99eb34511846e503d98e6f5854b3" translate="yes" xml:space="preserve">
          <source>True if currently connected to the server. If false, changes and method invocations will be queued up until the connection is reestablished.</source>
          <target state="translated">현재 서버에 연결되어 있으면 true입니다. false 인 경우, 연결이 다시 설정 될 때까지 변경 및 메소드 호출이 큐에 대기됩니다.</target>
        </trans-unit>
        <trans-unit id="1695b6982cf5b92a0fb48465ecc0f0225645a6a1" translate="yes" xml:space="preserve">
          <source>True if the server has &lt;a href=&quot;#publish_ready&quot;&gt;marked the subscription as ready&lt;/a&gt;. A reactive data source.</source>
          <target state="translated">서버가 &lt;a href=&quot;#publish_ready&quot;&gt;구독을 준비된 것으로 표시 한&lt;/a&gt; 경우 true 입니다. 반응적인 데이터 소스.</target>
        </trans-unit>
        <trans-unit id="f15d35bf2da46d0314bc5729dd44b0593fe8ade7" translate="yes" xml:space="preserve">
          <source>True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.</source>
          <target state="translated">현재 계산이있는 경우 True입니다. 즉, 반응 데이터 소스에 대한 종속성이 추적되어 현재 계산이 다시 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b429efdd186ff62d97dfc41b3fbe37cdcacaaf" translate="yes" xml:space="preserve">
          <source>True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.</source>
          <target state="translated">이 종속성에 하나 이상의 종속 계산이 있으면이 종속성이 변경되면 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="e35e5942afb506d095c8d820d2471850bc542ba1" translate="yes" xml:space="preserve">
          <source>True if this View has been called on to be rendered by &lt;code&gt;Blaze.render&lt;/code&gt; or &lt;code&gt;Blaze.toHTML&lt;/code&gt; or another View. Once it becomes true, never becomes false again. A &amp;ldquo;created&amp;rdquo; View&amp;rsquo;s &lt;code&gt;.parentView&lt;/code&gt; has been set to its final value. &lt;code&gt;isCreated&lt;/code&gt; is set to true before &lt;code&gt;onViewCreated&lt;/code&gt; hooks are called.</source>
          <target state="translated">이 뷰가 &lt;code&gt;Blaze.render&lt;/code&gt; 또는 &lt;code&gt;Blaze.toHTML&lt;/code&gt; 또는 다른 뷰에 의해 렌더링되도록 호출 된 경우 true 입니다. 그것이 사실이되면 다시는 거짓이되지 않습니다. &amp;ldquo;만든&amp;rdquo;보기의 &lt;code&gt;.parentView&lt;/code&gt; 가 최종 값으로 설정되었습니다. &lt;code&gt;onViewCreated&lt;/code&gt; 후크가 호출 되기 전에 &lt;code&gt;isCreated&lt;/code&gt; 가 true로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="db38e16aea3816ea9b45530a31ecf9d3d462eb67" translate="yes" xml:space="preserve">
          <source>True if this View has been destroyed, such as by &lt;code&gt;Blaze.remove()&lt;/code&gt; or by a reactive update that removes it. A destroyed View&amp;rsquo;s autoruns have been stopped, and its DOM nodes have generally been cleaned of all Meteor reactivity and possibly dismantled.</source>
          <target state="translated">이 뷰가 &lt;code&gt;Blaze.remove()&lt;/code&gt; 또는이를 제거하는 반응성 업데이트 등으로 파괴 된 경우 true 입니다. 파괴 된 View의 자동 실행이 중지되었으며 DOM 노드는 일반적으로 모든 Meteor 반응성을 정리하고 해체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="388166969413925a5bdd13cc81355743d4d4aa57" translate="yes" xml:space="preserve">
          <source>True if this View has been rendered to DOM by &lt;code&gt;Blaze.render&lt;/code&gt; or by the rendering of an enclosing View. Conversion to HTML by &lt;code&gt;Blaze.toHTML&lt;/code&gt; doesn&amp;rsquo;t count. Once true, never becomes false.</source>
          <target state="translated">이 뷰가 &lt;code&gt;Blaze.render&lt;/code&gt; 또는 엔 클로징 뷰의 렌더링에 의해 DOM으로 렌더링 된 경우 true 입니다. &lt;code&gt;Blaze.toHTML&lt;/code&gt; 에 의한 HTML 로의 변환 은 계산되지 않습니다. 일단 진실되면 결코 거짓이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2afcc0ebdfcd53b9a8c0c90e3fcfdfb7ae7e9143" translate="yes" xml:space="preserve">
          <source>True if this computation has been invalidated (and not yet rerun), or if it has been stopped.</source>
          <target state="translated">이 계산이 무효화되어 (아직 다시 실행되지 않은) 또는 중지 된 경우 참입니다.</target>
        </trans-unit>
        <trans-unit id="16b568cc105a32609145d75e97b1f22fc5eca124" translate="yes" xml:space="preserve">
          <source>True if this computation has been stopped.</source>
          <target state="translated">이 계산이 중지 된 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="89a5cb83cf1372831bb8c0ccce4a4760f6b37ce1" translate="yes" xml:space="preserve">
          <source>True if we are computing a computation now, either first time or recompute. This matches Tracker.active unless we are inside Tracker.nonreactive, which nullfies currentComputation even though an enclosing computation may still be running.</source>
          <target state="translated">지금 계산을 처음 또는 다시 계산하는 중이라면 참입니다. 우리가 Tracker.nonreactive 내부에 있지 않으면 Tracker.active와 일치합니다. 이는 엔 클로징 계산이 여전히 실행 중일지라도 currentComputation을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4094ad479b147ce7ecddb6050f4f8d861caff62e" translate="yes" xml:space="preserve">
          <source>True to insert a document if no matching documents are found.</source>
          <target state="translated">일치하는 문서가없는 경우 문서를 삽입하려면 true입니다.</target>
        </trans-unit>
        <trans-unit id="13fac8d83f412385a2ac1c4f5d68a58b134b3eb3" translate="yes" xml:space="preserve">
          <source>True to modify all matching documents; false to only modify one of the matching documents (the default).</source>
          <target state="translated">일치하는 모든 문서를 수정하려면 true입니다. 일치하는 문서 중 하나만 수정하려면 false입니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="4dd071ec4e8c2771db727bd75e53a147ad95bb75" translate="yes" xml:space="preserve">
          <source>Trusted code can modify multiple documents at once by setting &lt;code&gt;multi&lt;/code&gt; to true, and can use an arbitrary &lt;a href=&quot;#selectors&quot;&gt;Mongo selector&lt;/a&gt; to find the documents to modify. It bypasses any access control rules set up by &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt;. The number of affected documents will be returned from the &lt;code&gt;update&lt;/code&gt; call if you don&amp;rsquo;t pass a callback.</source>
          <target state="translated">신뢰할 수있는 코드는 &lt;code&gt;multi&lt;/code&gt; 를 true 로 설정하여 여러 문서를 한 번에 수정할 수 있으며 임의의 &lt;a href=&quot;#selectors&quot;&gt;Mongo 선택기&lt;/a&gt; 를 사용 하여 수정할 문서를 찾을 수 있습니다. &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 액세스 제어 규칙을 무시합니다 . 콜백을 전달하지 않으면 영향을받는 문서 수가 &lt;code&gt;update&lt;/code&gt; 호출 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="78ff66283afe305b1c3f9c20f9c03605cd4e3bc7" translate="yes" xml:space="preserve">
          <source>Trusted code can use an arbitrary &lt;a href=&quot;#selectors&quot;&gt;Mongo selector&lt;/a&gt; to find the documents to remove, and can remove more than one document at once by passing a selector that matches multiple documents. It bypasses any access control rules set up by &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt;. The number of removed documents will be returned from &lt;code&gt;remove&lt;/code&gt; if you don&amp;rsquo;t pass a callback.</source>
          <target state="translated">신뢰할 수있는 코드는 임의의 &lt;a href=&quot;#selectors&quot;&gt;Mongo 선택기&lt;/a&gt; 를 사용하여 제거 할 문서를 찾고 여러 문서와 일치하는 선택기를 전달하여 한 번에 둘 이상의 문서를 제거 할 수 있습니다. &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 액세스 제어 규칙을 무시합니다 . 콜백을 전달하지 않으면 &lt;code&gt;remove&lt;/code&gt; 된 문서 수가 제거에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5392c950bdde4be7e5f5b8fdc6a1ca5f21e905cf" translate="yes" xml:space="preserve">
          <source>Twitter</source>
          <target state="translated">Twitter</target>
        </trans-unit>
        <trans-unit id="e2a4b8e0efe9303205f3474381c0be495b8b5efd" translate="yes" xml:space="preserve">
          <source>Twitter with &lt;code&gt;accounts-twitter&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;accounts-twitter&lt;/code&gt; 트위터와 트위터</target>
        </trans-unit>
        <trans-unit id="65eca67ab5791ed11c8bb708753e02f7a5995d04" translate="yes" xml:space="preserve">
          <source>Twitter, Weibo, Meteor developer accounts: &lt;code&gt;requestPermissions&lt;/code&gt; currently not supported</source>
          <target state="translated">Twitter, Weibo, Meteor 개발자 계정 : &lt;code&gt;requestPermissions&lt;/code&gt; 현재 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="f3a65a19c82a566d2129fd24cf51620203153f21" translate="yes" xml:space="preserve">
          <source>TypeScript can be installed with:</source>
          <target state="translated">TypeScript는 다음과 함께 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc7b9f3cfba78c5f5f835da717556e7cfd7cf685" translate="yes" xml:space="preserve">
          <source>TypeScript does not support nested &lt;code&gt;import&lt;/code&gt; statements, therefore conditionally importing modules requires you to use the &lt;code&gt;require&lt;/code&gt; statement (see &lt;a href=&quot;structure#using-require&quot;&gt;Using &lt;code&gt;require&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">타이프 라이터가 중첩 된 지원하지 않습니다 &lt;code&gt;import&lt;/code&gt; 때문에 조건부 모듈을 수입하면 사용하도록 요구, 진술을 &lt;code&gt;require&lt;/code&gt; 합니다 (문을 &lt;a href=&quot;structure#using-require&quot;&gt;사용하여 &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="22bb752bbc5d1e1894badba0103272490abfd2b7" translate="yes" xml:space="preserve">
          <source>Types of build plugins</source>
          <target state="translated">빌드 플러그인의 유형</target>
        </trans-unit>
        <trans-unit id="f092c6d9cd99b0b7c54fc00ac8efb74941c361c9" translate="yes" xml:space="preserve">
          <source>Types of stores</source>
          <target state="translated">상점의 종류</target>
        </trans-unit>
        <trans-unit id="5b776c43a97f3a815a98825e62b260c4d762f804" translate="yes" xml:space="preserve">
          <source>Types of tests</source>
          <target state="translated">시험의 종류</target>
        </trans-unit>
        <trans-unit id="b4a89dbeb0804c1230ae2a9bb6fe31ec4e65b71d" translate="yes" xml:space="preserve">
          <source>Typically a package will export one or more symbols, which you&amp;rsquo;ll need to reference with the destructuring syntax. You can find these exported symbols by either looking in that package&amp;rsquo;s &lt;code&gt;package.js&lt;/code&gt; file for &lt;a href=&quot;http://docs.meteor.com/#/full/pack_export&quot;&gt;&lt;code&gt;api.export&lt;/code&gt;&lt;/a&gt; calls or by looking in that package&amp;rsquo;s main JavaScript file for ES2015 &lt;code&gt;export&lt;/code&gt; calls like &lt;code&gt;export const packageName = 'package-name';&lt;/code&gt;.</source>
          <target state="translated">일반적으로 패키지는 하나 이상의 심볼을 내 보내며, 이는 구조화 구문을 참조해야합니다. &lt;a href=&quot;http://docs.meteor.com/#/full/pack_export&quot;&gt; &lt;code&gt;api.export&lt;/code&gt; &lt;/a&gt; 호출을 위해 해당 패키지의 &lt;code&gt;package.js&lt;/code&gt; 파일을 보거나 &lt;code&gt;export const packageName = 'package-name';&lt;/code&gt; 과 같은 ES2015 &lt;code&gt;export&lt;/code&gt; 호출을 위해 해당 패키지의 기본 JavaScript 파일을 보면 이러한 내 보낸 심볼을 찾을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="243fffe4bd539132fde4dc4dfc5d8153e98f8fed" translate="yes" xml:space="preserve">
          <source>Typically the package will warn you if you have not done so. For example, if you install the &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt;&lt;code&gt;react-meteor-data&lt;/code&gt;&lt;/a&gt; package into your app, you&amp;rsquo;ll also need to &lt;a href=&quot;#installing-npm&quot;&gt;install&lt;/a&gt; the &lt;a href=&quot;https://www.npmjs.com/package/react&quot;&gt;&lt;code&gt;react&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.com/package/react-addons-pure-render-mixin&quot;&gt;&lt;code&gt;react-addons-pure-render-mixin&lt;/code&gt;&lt;/a&gt; packages:</source>
          <target state="translated">일반적으로 패키지를 설치하지 않은 경우 경고 메시지가 표시됩니다. 예를 들어 &lt;a href=&quot;https://atmospherejs.com/meteor/react-meteor-data&quot;&gt; &lt;code&gt;react-meteor-data&lt;/code&gt; &lt;/a&gt; 패키지를 앱에 &lt;a href=&quot;#installing-npm&quot;&gt;설치&lt;/a&gt; 하는 경우 &lt;a href=&quot;https://www.npmjs.com/package/react&quot;&gt; &lt;code&gt;react&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://www.npmjs.com/package/react-addons-pure-render-mixin&quot;&gt; &lt;code&gt;react-addons-pure-render-mixin&lt;/code&gt; &lt;/a&gt; 패키지 도 설치 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1e5aa8ac5c97cd73cd04a039a07f2269bda5a038" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;code&gt;.throttle()&lt;/code&gt; if you are OK with the event happening during the user series of actions (i.e. you don&amp;rsquo;t mind the multiple, throttled events happening over time, as in this case), whereas you use &lt;code&gt;.debounce()&lt;/code&gt; if you want the events to happen whenever (in this example) the user stops typing for 300ms or longer.</source>
          <target state="translated">일반적으로 사용자 일련의 동작 중에 발생하는 이벤트에 문제가 없으면 &lt;code&gt;.throttle()&lt;/code&gt; 을 사용합니다 (예 :이 경우와 같이 시간이 지남에 따라 발생하는 여러 개의 &lt;code&gt;.debounce()&lt;/code&gt; 이벤트는 신경 쓰지 않음). ) (이 예제에서) 사용자가 300ms 이상 입력을 중지 할 때마다 이벤트가 발생하도록하려면</target>
        </trans-unit>
        <trans-unit id="c82392d4c0fb079cd9e3dec6d6c2ab9c47a8f6f5" translate="yes" xml:space="preserve">
          <source>UI components</source>
          <target state="translated">UI 구성 요소</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2c4f2ea08e55fbeec99963e458291ac33dd45138" translate="yes" xml:space="preserve">
          <source>URL pattern matching</source>
          <target state="translated">URL 패턴 일치</target>
        </trans-unit>
        <trans-unit id="59addef772ceb127ba057b3e8227731ed35b79a1" translate="yes" xml:space="preserve">
          <source>URLs and Routing</source>
          <target state="translated">URL 및 라우팅</target>
        </trans-unit>
        <trans-unit id="13796f99f92349a87d26e6c9db3e70f9a6d02868" translate="yes" xml:space="preserve">
          <source>UX patterns for displaying new data</source>
          <target state="translated">새로운 데이터를 표시하기위한 UX 패턴</target>
        </trans-unit>
        <trans-unit id="5ea3df7599c377417c35fd5fbd655e8eafc83e3f" translate="yes" xml:space="preserve">
          <source>Under &amp;ldquo;Whitelist Headers&amp;rdquo;, scroll down to select &amp;ldquo;Origin&amp;rdquo;</source>
          <target state="translated">&quot;화이트리스트 헤더&quot;에서 아래로 스크롤하여 &quot;원본&quot;을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a0d58cc609adee7ef58bf0130c39755a9c3590cc" translate="yes" xml:space="preserve">
          <source>Under the hood, each helper starts a new &lt;a href=&quot;http://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt;. When its reactive dependencies change, the helper is rerun. Helpers depend on their data context, passed arguments and other reactive data sources accessed during execution.</source>
          <target state="translated">후드 아래에서 각 도우미는 새로운 &lt;a href=&quot;http://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; 을&lt;/a&gt; 시작합니다 . 반응성 종속성이 변경되면 헬퍼가 다시 실행됩니다. 헬퍼는 데이터 컨텍스트, 전달 된 인수 및 실행 중에 액세스되는 기타 반응 형 데이터 소스에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="f4b878bbf9598bb5ee06e42a0dfd282f49503fc5" translate="yes" xml:space="preserve">
          <source>Understanding Blaze</source>
          <target state="translated">블레이즈 이해</target>
        </trans-unit>
        <trans-unit id="72bc8c7ccecc57a4e0f125bd444e3ca066bd991d" translate="yes" xml:space="preserve">
          <source>Understanding Meteor performance</source>
          <target state="translated">유성 성능 이해</target>
        </trans-unit>
        <trans-unit id="4e5d96eae6460a3f1dcfd8fcf63848f4239348d0" translate="yes" xml:space="preserve">
          <source>Unexpected failures</source>
          <target state="translated">예기치 않은 고장</target>
        </trans-unit>
        <trans-unit id="7faa434689ebce51e5c367e561bf98ff54b8bd21" translate="yes" xml:space="preserve">
          <source>Unfortunately, not all publications are as simple to secure as the example above. For more tips on how to use &lt;code&gt;reywood:publish-composite&lt;/code&gt; to handle reactive changes in publications, see the &lt;a href=&quot;data-loading#complex-auth&quot;&gt;data loading article&lt;/a&gt;.</source>
          <target state="translated">불행히도, 모든 출판물이 위의 예처럼 보안이 간단하지는 않습니다. &lt;code&gt;reywood:publish-composite&lt;/code&gt; 를 사용하여 출판물의 반응적인 변화를 처리 하는 방법에 대한 자세한 내용은 &lt;a href=&quot;data-loading#complex-auth&quot;&gt;데이터로드 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd6fdd293670da229ce904119e1e6a9179af0a72" translate="yes" xml:space="preserve">
          <source>Unfortunately, the e-mail ecosystem is &lt;a href=&quot;http://busylog.net/smtp-tls-ssl-25-465-587/&quot;&gt;confusing&lt;/a&gt;. More information can be found in the &lt;a href=&quot;https://nodemailer.com/smtp/&quot;&gt;Nodemailer docs&lt;/a&gt;.</source>
          <target state="translated">불행히도 전자 메일 환경은 &lt;a href=&quot;http://busylog.net/smtp-tls-ssl-25-465-587/&quot;&gt;혼란 스럽습니다&lt;/a&gt; . 자세한 정보는 &lt;a href=&quot;https://nodemailer.com/smtp/&quot;&gt;Nodemailer docs&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81a4be7e010cb6daabd6b2dab1722b9ed0372269" translate="yes" xml:space="preserve">
          <source>Unit testing</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="ffb4f9edca2d5dda9f1d2bc06aea35521a5759ed" translate="yes" xml:space="preserve">
          <source>Unit testing is the process of isolating a section of code and then testing that the internals of that section work as you expect. As &lt;a href=&quot;structure&quot;&gt;we&amp;rsquo;ve split our code base up into ES2015 modules&lt;/a&gt; it&amp;rsquo;s natural to test those modules one at a time.</source>
          <target state="translated">단위 테스트는 코드 섹션을 분리 한 다음 해당 섹션의 내부가 예상대로 작동하는지 테스트하는 프로세스입니다. 마찬가지로 &lt;a href=&quot;structure&quot;&gt;우리는 ES2015 모듈로 우리의 코드베이스를 분할 한&lt;/a&gt; 그것은 한 번에 그 모듈 하나를 테스트하는 자연이다.</target>
        </trans-unit>
        <trans-unit id="ba6060d8f0b7a3c71d52884b176c4857139e83a3" translate="yes" xml:space="preserve">
          <source>Universal JavaScript</source>
          <target state="translated">범용 자바 스크립트</target>
        </trans-unit>
        <trans-unit id="86251b1e296d5f02e9e014d5fe362ea8a73881ec" translate="yes" xml:space="preserve">
          <source>Unless you have a specific need to roll your own hosting environment, the other options here are definitely easier, and probably make for a better setup than doing everything from scratch. Operating a Meteor app in a way that it works correctly for everyone can be complex, and &lt;a href=&quot;#galaxy&quot;&gt;Galaxy&lt;/a&gt; handles a lot of the specifics like routing clients to the right containers and handling coordinated version updates for you.</source>
          <target state="translated">고유 한 호스팅 환경을 롤링해야 할 필요가 없다면 여기의 다른 옵션은 확실히 더 쉽고 처음부터 모든 것을 수행하는 것보다 더 나은 설정을 할 수 있습니다. 모든 사람에게 올바르게 작동하는 방식으로 Meteor 앱을 운영하는 것은 복잡 할 수 있으며 &lt;a href=&quot;#galaxy&quot;&gt;Galaxy&lt;/a&gt; 는 클라이언트를 올바른 컨테이너로 라우팅하고 조정 된 버전 업데이트를 처리하는 등의 많은 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e5e475b4db8186c54e82b380c6960d256c3d5fc6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;observe&lt;/code&gt;, &lt;code&gt;observeChanges&lt;/code&gt; does not provide absolute position information (that is, &lt;code&gt;atIndex&lt;/code&gt; positions rather than &lt;code&gt;before&lt;/code&gt; positions.) This is for efficiency.</source>
          <target state="translated">달리 &lt;code&gt;observe&lt;/code&gt; , &lt;code&gt;observeChanges&lt;/code&gt; 는 (이라고 절대 위치 정보를 제공하지 않는다 &lt;code&gt;atIndex&lt;/code&gt; 에 대신 위치 &lt;code&gt;before&lt;/code&gt; 위치.) 이것은 효율이다.</target>
        </trans-unit>
        <trans-unit id="370730d29f8dba23681448b11394384e773e2def" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;{{#with}}&lt;/code&gt; (as used in templates), &lt;code&gt;Blaze.With&lt;/code&gt; has no &amp;ldquo;else&amp;rdquo; case, and a falsy value for the data context will not prevent the content from rendering.</source>
          <target state="translated">달리 &lt;code&gt;{{#with}}&lt;/code&gt; (템플릿에 사용되는) &lt;code&gt;Blaze.With&lt;/code&gt; 이 아니오 &quot;다른&quot;경우, 그리고 콘텐츠 렌더링의 방해가되지 않는 데이터 컨텍스트에 대한 falsy 가치가 없다.</target>
        </trans-unit>
        <trans-unit id="986225a2e3b5f21807473c42bae16262f3ad7f30" translate="yes" xml:space="preserve">
          <source>Unlike CommonJS &lt;code&gt;module.exports&lt;/code&gt;, the use of default exports does not prevent the simultaneous use of named exports. Here is how you can combine them:</source>
          <target state="translated">CommonJS &lt;code&gt;module.exports&lt;/code&gt; 와 달리 기본 내보내기를 사용하더라도 명명 된 내보내기를 동시에 사용할 수 있습니다. 그것들을 결합하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2018a4a7be9f98c1432fb054291dcc164d74f217" translate="yes" xml:space="preserve">
          <source>Unlike most other systems, you don&amp;rsquo;t have to manually declare these dependencies &amp;mdash; it &amp;ldquo;just works&amp;rdquo;. The mechanism is simple and efficient. When you call a function that supports reactive updates (such as a database query), it automatically saves the current Computation object, if any (representing, for example, the current template being rendered). Later, when the data changes, the function can &amp;ldquo;invalidate&amp;rdquo; the Computation, causing it to rerun (rerendering the template).</source>
          <target state="translated">대부분의 다른 시스템과 달리 이러한 종속성을 수동으로 선언 할 필요는 없습니다. 메커니즘은 간단하고 효율적입니다. 반응 형 업데이트 (예 : 데이터베이스 쿼리)를 지원하는 함수를 호출하면 현재 계산 개체 (있는 경우 현재 렌더링중인 템플릿 등)가있는 경우 현재 계산 개체가 자동으로 저장됩니다. 나중에 데이터가 변경되면 함수가 계산을 &quot;무효화&quot;하여 다시 실행 (템플릿 렌더링) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b609966fbe1d2e03907584cd43e0ec6aa829a110" translate="yes" xml:space="preserve">
          <source>Unlike purely string-based template systems, Spacebars is HTML-aware and designed to update the DOM automatically. As a result, you can&amp;rsquo;t use a template tag to insert strings of HTML that don&amp;rsquo;t stand on their own, such as a lone HTML start tag or end tag, or that can&amp;rsquo;t be easily modified, such as the name of an HTML element.</source>
          <target state="translated">순전히 문자열 기반 템플릿 시스템과 달리 스페이스 바는 HTML을 인식하며 DOM을 자동으로 업데이트하도록 설계되었습니다. 결과적으로 템플릿 태그를 사용하여 고독한 HTML 시작 태그 또는 종료 태그와 같이 자체적으로 존재하지 않거나 이름과 같이 쉽게 수정할 수없는 HTML 문자열을 삽입 할 수 없습니다 HTML 요소의</target>
        </trans-unit>
        <trans-unit id="187deee1552d77fbc316c605cbcd2f14f4607f34" translate="yes" xml:space="preserve">
          <source>Unlike the other functions, &lt;code&gt;count&lt;/code&gt; registers a dependency only on the number of matching documents. (Updates that just change or reorder the documents in the result set will not trigger a recomputation.)</source>
          <target state="translated">다른 함수와 달리 &lt;code&gt;count&lt;/code&gt; 는 일치하는 문서 수에만 종속성을 등록합니다. 결과 집합에서 문서를 변경하거나 순서를 바꾸는 업데이트는 재 계산을 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45e3392204b6952d6f61b85cf29209fca5d0f1bf" translate="yes" xml:space="preserve">
          <source>Untrusted code can only modify a single document at once, specified by its &lt;code&gt;_id&lt;/code&gt;. The modification is allowed only after checking any applicable &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt; rules. The number of affected documents will be returned to the callback. Untrusted code cannot perform upserts, except in insecure mode.</source>
          <target state="translated">신뢰할 수없는 코드는 &lt;code&gt;_id&lt;/code&gt; 로 지정된 한 번에 하나의 문서 만 수정할 수 있습니다 . 적용 가능한 &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; &lt;/a&gt; 규칙을 확인한 후에 만 ​​수정이 허용됩니다 . 영향을받는 문서 수는 콜백으로 반환됩니다. 안전하지 않은 모드를 제외하고 신뢰할 수없는 코드는 업 사트를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="342c03ffe7a1d69748a3d7ec1d39f9e9b6bfcb9f" translate="yes" xml:space="preserve">
          <source>Untrusted code can only remove a single document at a time, specified by its &lt;code&gt;_id&lt;/code&gt;. The document is removed only after checking any applicable &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt; rules. The number of removed documents will be returned to the callback.</source>
          <target state="translated">신뢰할 수없는 코드는 &lt;code&gt;_id&lt;/code&gt; 로 지정된 한 번에 하나의 문서 만 제거 할 수 있습니다 . 해당 &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; &lt;/a&gt; 규칙을 확인한 후에 만 ​​문서가 제거됩니다 . 제거 된 문서 수는 콜백으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21f2b5ca46c834095f797cd1368dfc747c462e2d" translate="yes" xml:space="preserve">
          <source>Updated assets are downloaded from the server using native downloading mechanisms, and stored on the device</source>
          <target state="translated">업데이트 된 자산은 기본 다운로드 메커니즘을 사용하여 서버에서 다운로드되어 장치에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b7048f3db131f1da42a30a677df5a041679373" translate="yes" xml:space="preserve">
          <source>Updating stores</source>
          <target state="translated">상점 업데이트</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="69f3545316c91218f1b07d896f6704b7536cb22e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--owner&lt;/code&gt; to decide which organization or user account you&amp;rsquo;d like to deploy a new app to if you are a member of more than one Galaxy-enabled account.</source>
          <target state="translated">&lt;code&gt;--owner&lt;/code&gt; 계정이 둘 이상인 경우 --owner 를 사용 하여 새 앱을 배포 할 조직 또는 사용자 계정을 결정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a734e5b84dc4f8a9c7aca4934d30b17967acd91c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.js-&lt;/code&gt; selectors for event maps</source>
          <target state="translated">이벤트 맵에 &lt;code&gt;.js-&lt;/code&gt; 선택기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20b4ef28f8108468d01cf394c4aa764c81b49d15" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Blaze.remove&lt;/code&gt; to remove a template or View previously inserted with &lt;code&gt;Blaze.render&lt;/code&gt;, in such a way that any behaviors attached to the DOM by Meteor are cleaned up. The rendered template or View is now considered &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt;&amp;ldquo;destroyed&amp;rdquo;&lt;/a&gt;, along with all nested templates and Views. In addition, any data assigned via jQuery to the DOM nodes is removed, as if the nodes were passed to jQuery&amp;rsquo;s &lt;code&gt;$(...).remove()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Blaze.remove&lt;/code&gt; 를 사용 하여 Meteor에 의해 DOM에 첨부 된 모든 동작이 정리되는 방식 으로 &lt;code&gt;Blaze.render&lt;/code&gt; 로 이전에 삽입 된 템플릿 또는 View를 제거 하십시오 . 렌더링 된 템플릿 또는 뷰는 이제 모든 중첩 템플릿 및 뷰와 함께 &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt;&quot;파기&quot;된&lt;/a&gt; 것으로 간주됩니다 . 또한 jQuery를 통해 DOM 노드에 할당 된 데이터는 마치 마치 jQuery의 &lt;code&gt;$(...).remove()&lt;/code&gt; 로 전달 된 것처럼 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="03bacce3a2a13672b7823bf8ed643281e07f3704" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;added&lt;/code&gt;, &lt;code&gt;changed&lt;/code&gt;, and &lt;code&gt;removed&lt;/code&gt; when you don&amp;rsquo;t care about the order of the documents in the result set. They are more efficient than &lt;code&gt;addedAt&lt;/code&gt;, &lt;code&gt;changedAt&lt;/code&gt;, and &lt;code&gt;removedAt&lt;/code&gt;.</source>
          <target state="translated">결과 집합의 문서 순서에 신경 쓰지 않을 때는 &lt;code&gt;added&lt;/code&gt; , &lt;code&gt;changed&lt;/code&gt; 및 &lt;code&gt;removed&lt;/code&gt; 를 사용하십시오 . 그들은 &lt;code&gt;addedAt&lt;/code&gt; , &lt;code&gt;changedAt&lt;/code&gt; 및 &lt;code&gt;removedAt&lt;/code&gt; 보다 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="f295d7c2395881484c4e1c78ecac8322edab4f02" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;meteor build &amp;lt;build-output-directory&amp;gt; --server=&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt; to build your app for production.</source>
          <target state="translated">사용 &lt;code&gt;meteor build &amp;lt;build-output-directory&amp;gt; --server=&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt; 생산에 대한 응용 프로그램을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="5ab113ea3c01b21ec5c4d1f81b0886db22f95c92" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;meteor search&lt;/code&gt; from the command line.</source>
          <target state="translated">명령 행에서 &lt;code&gt;meteor search&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8317dece1d60274612b01fbc235ed24dfc7cd9c7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;onRendered()&lt;/code&gt; for 3rd party libraries</source>
          <target state="translated">타사 라이브러리에 &lt;code&gt;onRendered()&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="961c4e8ba2af61e0a0e40a1c1a9d321b8bfd7613" translate="yes" xml:space="preserve">
          <source>Use Methods instead of client-side insert/update/remove and allow/deny.</source>
          <target state="translated">클라이언트 측 삽입 / 업데이트 / 제거 및 허용 / 거부 대신 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23d2be6d2a1e4ec9fc9f5e1bacecfada21f38c2d" translate="yes" xml:space="preserve">
          <source>Use a community package search website like &lt;a href=&quot;http://fastosphere.meteor.com/&quot;&gt;Fastosphere&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://fastosphere.meteor.com/&quot;&gt;Fastosphere&lt;/a&gt; 와 같은 커뮤니티 패키지 검색 웹 사이트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6cc0752cbd2ae038a130eb625a262df2d469c19" translate="yes" xml:space="preserve">
          <source>Use a package from Atmosphere or npm that wraps the API into a nice JavaScript interface. For example, if you&amp;rsquo;re trying to load data from Facebook you could use the &lt;a href=&quot;https://www.npmjs.com/package/fbgraph&quot;&gt;fbgraph&lt;/a&gt; npm package. Read more about how to use npm with your app in the &lt;a href=&quot;build-tool#npm&quot;&gt;Build System article&lt;/a&gt;.</source>
          <target state="translated">API를 멋진 JavaScript 인터페이스로 감싸는 Atmosphere 또는 npm 패키지를 사용하십시오. 예를 들어 Facebook에서 데이터를로드하려는 경우 &lt;a href=&quot;https://www.npmjs.com/package/fbgraph&quot;&gt;fbgraph&lt;/a&gt; npm 패키지를 사용할 수 있습니다 . &lt;a href=&quot;build-tool#npm&quot;&gt;빌드 시스템 기사&lt;/a&gt; 에서 앱에서 npm을 사용하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="76d566695283d1a57974142bff4b7d1b5185dbe9" translate="yes" xml:space="preserve">
          <source>Use a reactive dict for state</source>
          <target state="translated">상태에 반응 형 사전 사용</target>
        </trans-unit>
        <trans-unit id="a055520524f88e57197c0e698a97c17b390f1930" translate="yes" xml:space="preserve">
          <source>Use any router or UI framework</source>
          <target state="translated">라우터 또는 UI 프레임 워크 사용</target>
        </trans-unit>
        <trans-unit id="e6169a625b5c39cda78e91874ca2c90ff91eefb4" translate="yes" xml:space="preserve">
          <source>Use rate limiting to stop people from spamming you with subscriptions.</source>
          <target state="translated">요금 제한을 사용하여 사람들이 구독으로 스팸을 보내지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="a10eba6c6c8c4bdcba1683603289ff692d799fea" translate="yes" xml:space="preserve">
          <source>Use specific selectors and &lt;a href=&quot;http://guide.meteor.com/security.html#fields&quot;&gt;filter fields&lt;/a&gt; in publications.</source>
          <target state="translated">서적에서 특정 선택기 및 &lt;a href=&quot;http://guide.meteor.com/security.html#fields&quot;&gt;필터 필드&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="879291cc427788a9f0214648a5f462f8e276b0d0" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://docs.meteor.com/#/full/http&quot;&gt;&lt;code&gt;http&lt;/code&gt; package&lt;/a&gt; to access the service&amp;rsquo;s API directly. You&amp;rsquo;ll probably need to pass the access token from above in a header. For details you&amp;rsquo;ll need to search the API documentation for the service.</source>
          <target state="translated">사용 &lt;a href=&quot;http://docs.meteor.com/#/full/http&quot;&gt; &lt;code&gt;http&lt;/code&gt; 패키지를&lt;/a&gt; 직접 서비스의 API에 액세스 할 수 있습니다. 아마도 액세스 토큰을 위에서 헤더로 전달해야 할 것입니다. 자세한 내용은 서비스에 대한 API 설명서를 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d74fa0f4c5803f2a3e03cbab654e8caafe723a8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;ecmascript&lt;/code&gt; package</source>
          <target state="translated">사용 &lt;code&gt;ecmascript&lt;/code&gt; 패키지를</target>
        </trans-unit>
        <trans-unit id="5c09f7e3a2ce8af78ab146861944ef0ac08400f3" translate="yes" xml:space="preserve">
          <source>Use the below functions to initiate password changes or resets from the server or the client.</source>
          <target state="translated">아래 기능을 사용하여 서버 또는 클라이언트에서 비밀번호 변경 또는 재설정을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c688072a788bd50324e66e2dd4aa16fdf12bd9b8" translate="yes" xml:space="preserve">
          <source>Use the package &lt;a href=&quot;https://atmospherejs.com/juliancwirko/postcss&quot;&gt;juliancwirko:postcss&lt;/a&gt; to your app to enable PostCSS for your Meteor app. To do so, we remove the standard CSS minifier and replace it with the postcss package:</source>
          <target state="translated">앱에 &lt;a href=&quot;https://atmospherejs.com/juliancwirko/postcss&quot;&gt;juliancwirko : postcss&lt;/a&gt; 패키지 를 사용하여 Meteor 앱에 PostCSS를 활성화하십시오. 이를 위해 표준 CSS 축소기를 제거하고 postcss 패키지로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="72205db10ef5ee809240d7e0ab33037b7274d444" translate="yes" xml:space="preserve">
          <source>Use the template instance</source>
          <target state="translated">템플릿 인스턴스 사용</target>
        </trans-unit>
        <trans-unit id="e4bdb377e4fe443080ee254526a761941f90dc8f" translate="yes" xml:space="preserve">
          <source>Use this variable to set the SMTP server for sending e-mails. &lt;a href=&quot;https://www.postmarkapp.com&quot;&gt;Postmark&lt;/a&gt;, &lt;a href=&quot;https://www.mandrillapp.com&quot;&gt;Mandrill&lt;/a&gt;, &lt;a href=&quot;https://www.mailgun.com&quot;&gt;MailGun&lt;/a&gt; and &lt;a href=&quot;https://www.sendgrid.com&quot;&gt;SendGrid&lt;/a&gt; (among others) are companies who can provide this service. The &lt;code&gt;MAIL_URL&lt;/code&gt; contains all of the information for connecting to the SMTP server and, like a URL, should look like &lt;code&gt;smtp://user:pass@yourservice.com:587&lt;/code&gt; or &lt;code&gt;smtps://user:pass@yourservice.com:465&lt;/code&gt;.</source>
          <target state="translated">이 변수를 사용하여 이메일을 보낼 SMTP 서버를 설정하십시오. 이 서비스를 제공 할 수있는 회사는 &lt;a href=&quot;https://www.postmarkapp.com&quot;&gt;Postmark&lt;/a&gt; , &lt;a href=&quot;https://www.mandrillapp.com&quot;&gt;Mandrill&lt;/a&gt; , &lt;a href=&quot;https://www.mailgun.com&quot;&gt;MailGun&lt;/a&gt; 및 &lt;a href=&quot;https://www.sendgrid.com&quot;&gt;SendGrid&lt;/a&gt; 입니다. &lt;code&gt;MAIL_URL&lt;/code&gt; 는 URL이 같은 SMTP 서버에 연결하고 대한 모든 정보를 포함 같아야합니다 &lt;code&gt;smtp://user:pass@yourservice.com:587&lt;/code&gt; 또는 &lt;code&gt;smtps://user:pass@yourservice.com:465&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86e31c10b6d910bca69a8dc84d50e0ef2543b0f9" translate="yes" xml:space="preserve">
          <source>Use this when you need to do more than simply accept or reject new user creation. With this function you can programatically control the contents of new user documents.</source>
          <target state="translated">단순히 새로운 사용자 생성을 수락하거나 거부하는 것 이상을 수행해야 할 때 이것을 사용하십시오. 이 기능을 사용하면 새로운 사용자 문서의 내용을 프로그래밍 방식으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d617681615d8a768b31aa7d9fe8446ab56e69fa7" translate="yes" xml:space="preserve">
          <source>Use versions of core packages from a release. Unless provided, all packages will default to the versions released along with &lt;code&gt;meteorRelease&lt;/code&gt;. This will save you from having to figure out the exact versions of the core packages you want to use. For example, if the newest release of meteor is &lt;code&gt;METEOR@0.9.0&lt;/code&gt; and it includes &lt;code&gt;jquery@1.0.0&lt;/code&gt;, you can write &lt;code&gt;api.versionsFrom('METEOR@0.9.0')&lt;/code&gt; in your package, and when you later write &lt;code&gt;api.use('jquery')&lt;/code&gt;, it will be equivalent to &lt;code&gt;api.use('jquery@1.0.0')&lt;/code&gt;. You may specify an array of multiple releases, in which case the default value for constraints will be the &quot;or&quot; of the versions from each release: &lt;code&gt;api.versionsFrom(['METEOR@0.9.0',
'METEOR@0.9.5'])&lt;/code&gt; may cause &lt;code&gt;api.use('jquery')&lt;/code&gt; to be interpreted as &lt;code&gt;api.use('jquery@1.0.0 || 2.0.0')&lt;/code&gt;.</source>
          <target state="translated">릴리스의 핵심 패키지 버전을 사용하십시오. 제공되지 않는 한 모든 패키지는 &lt;code&gt;meteorRelease&lt;/code&gt; 와 함께 출시 된 버전으로 기본 설정됩니다 . 이를 통해 사용하려는 코어 패키지의 정확한 버전을 파악하지 않아도됩니다. 유성의 최신 버전 인 경우 예를 들어, &lt;code&gt;METEOR@0.9.0&lt;/code&gt; 하고 포함 &lt;code&gt;jquery@1.0.0&lt;/code&gt; 을 , 당신은 쓸 수 &lt;code&gt;api.versionsFrom('METEOR@0.9.0')&lt;/code&gt; 패키지에서, 그리고 때 나중에 쓰기 &lt;code&gt;api.use('jquery')&lt;/code&gt; 이면 &lt;code&gt;api.use('jquery@1.0.0')&lt;/code&gt; . 여러 릴리스의 배열을 지정할 수 있습니다.이 경우 제한 조건의 기본값은 각 릴리스에서 버전의 &quot;또는&quot;입니다. &lt;code&gt;api.versionsFrom(['METEOR@0.9.0', 'METEOR@0.9.5'])&lt;/code&gt; 인해 &lt;code&gt;api.use('jquery')&lt;/code&gt; 가 &lt;code&gt;api.use('jquery@1.0.0 || 2.0.0')&lt;/code&gt; 으로 해석 될 수 있습니다 . 0 ') .</target>
        </trans-unit>
        <trans-unit id="4c6848db95e8201decfb4d288c34ba8d67043b97" translate="yes" xml:space="preserve">
          <source>Used to generate URLs to your application by, among others, the accounts package. Provide a full URL to your application like this: &lt;code&gt;ROOT_URL=&quot;https://www.myapp.com&quot;&lt;/code&gt;.</source>
          <target state="translated">계정 패키지를 통해 애플리케이션에 대한 URL을 생성하는 데 사용됩니다. &lt;code&gt;ROOT_URL=&quot;https://www.myapp.com&quot;&lt;/code&gt; 과 같이 애플리케이션에 전체 URL을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="daccde9557869f82dccbade0cba1286c36c7a8ec" translate="yes" xml:space="preserve">
          <source>Useful patterns for managing subscriptions.</source>
          <target state="translated">구독 관리에 유용한 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="4325c61b581bf8fe6a3e2400d58928e7b9a55496" translate="yes" xml:space="preserve">
          <source>User Interfaces</source>
          <target state="translated">사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="ad4c8252553c4a4b05dbcaa42dcf601cea21365e" translate="yes" xml:space="preserve">
          <source>User documents in the database have secret data like access keys and hashed passwords. When &lt;a href=&quot;#publish-custom-data&quot;&gt;publishing user data to the client&lt;/a&gt;, be extra careful not to include anything that client shouldn&amp;rsquo;t be able to see.</source>
          <target state="translated">데이터베이스의 사용자 문서에는 액세스 키 및 해시 된 비밀번호와 같은 비밀 데이터가 있습니다. &lt;a href=&quot;#publish-custom-data&quot;&gt;클라이언트에 사용자 데이터를 게시&lt;/a&gt; 할 때 클라이언트가 볼 수없는 것을 포함하지 않도록 특히주의하십시오.</target>
        </trans-unit>
        <trans-unit id="c92ae70f9aa6d4032e366eb4340fc1e52d2bf92d" translate="yes" xml:space="preserve">
          <source>User experience patterns</source>
          <target state="translated">사용자 경험 패턴</target>
        </trans-unit>
        <trans-unit id="09d01c9af4a2007fdb6c1f64874508da43fe66cb" translate="yes" xml:space="preserve">
          <source>User experience, or UX, describes the experience of a user as they interact with your application. There are several UX patterns that are typical to most Meteor apps which are worth exploring here. Many of these patterns are tied to the way data is loaded as the user interacts with your app, so there are similar sections in the &lt;a href=&quot;data-loading#patterns&quot;&gt;data loading article&lt;/a&gt; talking about how to implement these patterns using Meteor&amp;rsquo;s publications and subscriptions.</source>
          <target state="translated">사용자 경험 또는 UX는 사용자가 응용 프로그램과 상호 작용할 때의 경험을 설명합니다. 여기에서 살펴볼 가치가있는 대부분의 Meteor 앱에 일반적인 몇 가지 UX 패턴이 있습니다. 이러한 패턴 중 많은 부분은 사용자가 앱과 상호 작용할 때 데이터가로드되는 방식과 관련이 있으므로 &lt;a href=&quot;data-loading#patterns&quot;&gt;데이터로드 아티클&lt;/a&gt; 에는 Meteor의 게시 및 구독을 사용하여 이러한 패턴을 구현하는 방법에 대한 비슷한 섹션 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3ba2af7f943c5da92635dc4cdd862ab5415d7a" translate="yes" xml:space="preserve">
          <source>User interface patterns</source>
          <target state="translated">사용자 인터페이스 패턴</target>
        </trans-unit>
        <trans-unit id="46eb6026b6ad46a4d08f316a52fffc281577db72" translate="yes" xml:space="preserve">
          <source>Users and Accounts</source>
          <target state="translated">사용자 및 계정</target>
        </trans-unit>
        <trans-unit id="633c224a715eb2226cdf3095674a790de9909b96" translate="yes" xml:space="preserve">
          <source>Users are by default allowed to specify their own &lt;code&gt;profile&lt;/code&gt; field with &lt;a href=&quot;#accounts_createuser&quot;&gt;&lt;code&gt;Accounts.createUser&lt;/code&gt;&lt;/a&gt; and modify it with &lt;code&gt;Meteor.users.update&lt;/code&gt;. To allow users to edit additional fields, use &lt;a href=&quot;#allow&quot;&gt;&lt;code&gt;Meteor.users.allow&lt;/code&gt;&lt;/a&gt;. To forbid users from making any modifications to their user document:</source>
          <target state="translated">사용자는 기본적 으로 &lt;a href=&quot;#accounts_createuser&quot;&gt; &lt;code&gt;Accounts.createUser&lt;/code&gt; 로&lt;/a&gt; 자신의 &lt;code&gt;profile&lt;/code&gt; 필드 를 지정하고 &lt;code&gt;Meteor.users.update&lt;/code&gt; 로이를 수정할 수 있습니다 . 사용자가 추가 필드를 편집 할 수있게하려면 &lt;a href=&quot;#allow&quot;&gt; &lt;code&gt;Meteor.users.allow&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 . 사용자가 자신의 사용자 문서를 수정하지 못하게하려면 :</target>
        </trans-unit>
        <trans-unit id="c716801b2d3bf8d16f7c2eb9c7eb5a26e35dddba" translate="yes" xml:space="preserve">
          <source>Using 3rd party packages</source>
          <target state="translated">타사 패키지 사용</target>
        </trans-unit>
        <trans-unit id="53bf5eee67f58057293029c899e24eead5ee207b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;require&lt;/code&gt;</source>
          <target state="translated">사용하여 &lt;code&gt;require&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3b08b28ba8d34643cfc722ee74c955be5f52685" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;tap:i18n&lt;/code&gt; in Blaze</source>
          <target state="translated">Blaze에서 &lt;code&gt;tap:i18n&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="9f58e648939108214570b0c5866de129d4492bad" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;tap:i18n&lt;/code&gt; in JavaScript</source>
          <target state="translated">JavaScript에서 &lt;code&gt;tap:i18n&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="93c01f30a7b96749ed7813c2c4b2657077db3732" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;universe:i18n&lt;/code&gt; in JS</source>
          <target state="translated">JS에서 &lt;code&gt;universe:i18n&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="0e51e68f230a8c2b63a310eb062178595feb3ccc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;universe:i18n&lt;/code&gt; in React</source>
          <target state="translated">React에서 &lt;code&gt;universe:i18n&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="7e5e4bbb41c286113d572be757efa96cd456055d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;universe:i18n&lt;/code&gt; in React components</source>
          <target state="translated">React 구성 요소에서 &lt;code&gt;universe:i18n&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="4b7a9d1a0615cfdfc10e353409b5c44dcd2b94b2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;withTracker&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;withTracker&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="1becafd3ff808f31d09078cd73dec993eb57d465" translate="yes" xml:space="preserve">
          <source>Using Atmosphere Packages</source>
          <target state="translated">분위기 패키지 사용</target>
        </trans-unit>
        <trans-unit id="dbbb18c55323003c2090d120062d5bcea8baa8df" translate="yes" xml:space="preserve">
          <source>Using Chromatic enables rapid development of complex components. Typically in a large application, it can be quite difficult to achieve certain states of components purely by &amp;ldquo;using&amp;rdquo; the application. For example, a component in Galaxy can enter a complex state if two deploys of the same app happen simultaneously. With Chromatic we&amp;rsquo;re able to define this state at the component level and test it independently of the application logic.</source>
          <target state="translated">Chromatic을 사용하면 복잡한 구성 요소를 신속하게 개발할 수 있습니다. 일반적으로 대규모 응용 프로그램에서는 응용 프로그램을 &quot;사용&quot;하여 특정 상태의 구성 요소를 얻는 것이 매우 어려울 수 있습니다. 예를 들어, 동일한 앱을 두 번 배포하면 동시에 Galaxy의 구성 요소가 복잡한 상태가 될 수 있습니다. Chromatic을 통해 컴포넌트 레벨에서이 상태를 정의하고 애플리케이션 로직과 독립적으로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9829782339534f68303ee625019442673b3ec5" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript</source>
          <target state="translated">CoffeeScript 사용</target>
        </trans-unit>
        <trans-unit id="4adad8e38f5d01139eefff6e8ab4cb08f160d418" translate="yes" xml:space="preserve">
          <source>Using ESLint in VS Code requires installation of the 3rd party &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint&quot;&gt;ESLint&lt;/a&gt; extension. In order to install the extension, follow these steps:</source>
          <target state="translated">VS Code에서 ESLint를 사용하려면 타사 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint&quot;&gt;ESLint&lt;/a&gt; 확장을 설치해야합니다 . 확장을 설치하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f79f5cdb6ee03272f55707b7689f81aee7587066" translate="yes" xml:space="preserve">
          <source>Using ESLint with Atom is simple. Just install these three packages:</source>
          <target state="translated">Atom과 함께 ESLint를 사용하는 것은 간단합니다. 이 세 가지 패키지 만 설치하면됩니다.</target>
        </trans-unit>
        <trans-unit id="17c6bb31f3077116b580521466ca91f208a028d1" translate="yes" xml:space="preserve">
          <source>Using Flow Router</source>
          <target state="translated">플로우 라우터 사용</target>
        </trans-unit>
        <trans-unit id="4d260bc0c0f70d136c4fb9d14420935843358c52" translate="yes" xml:space="preserve">
          <source>Using Flow Router with React is very similar to using it with Blaze. The only difference is that in your route actions, you should use the &lt;a href=&quot;https://www.npmjs.com/package/react-mounter&quot;&gt;&lt;code&gt;react-mounter&lt;/code&gt;&lt;/a&gt; package to mount components with a layout. Once you &lt;code&gt;meteor npm install --save react-mounter&lt;/code&gt;, you can do the following:</source>
          <target state="translated">React와 함께 Flow Router를 사용하는 것은 Blaze와 함께 사용하는 것과 매우 유사합니다. 유일한 차이점은 라우트 작업에서 &lt;a href=&quot;https://www.npmjs.com/package/react-mounter&quot;&gt; &lt;code&gt;react-mounter&lt;/code&gt; &lt;/a&gt; 패키지를 사용하여 레이아웃으로 컴포넌트를 마운트 해야한다는 것 입니다. 당신은 일단 &lt;code&gt;meteor npm install --save react-mounter&lt;/code&gt; 다음과 같은 작업을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1845bf9ab58b1949566b1478b9830d7643eac47e" translate="yes" xml:space="preserve">
          <source>Using Meteor&amp;rsquo;s data system</source>
          <target state="translated">Meteor의 데이터 시스템 사용</target>
        </trans-unit>
        <trans-unit id="4b414ab72c99070ca8b8fafcef4de7d95eeb309c" translate="yes" xml:space="preserve">
          <source>Using React Router is also straightforward. Once you &lt;code&gt;meteor npm install --save react-router history&lt;/code&gt;, you can simply export a list of nested routes as you would in any other React Router driven React application:</source>
          <target state="translated">React Router를 사용하는 것도 간단합니다. 당신은 일단 &lt;code&gt;meteor npm install --save react-router history&lt;/code&gt; 다른 라우터 기반 반작용 응용 프로그램 반응에 당신처럼, 당신은 단순히 중첩 된 경로 목록을 내보낼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ce0dca4a6a1231a9f0b22d19f1526d27457ca851" translate="yes" xml:space="preserve">
          <source>Using React in Atmosphere Packages</source>
          <target state="translated">분위기 패키지에서 반응 사용</target>
        </trans-unit>
        <trans-unit id="86ecdd2e45eb7214b2defd0d440c303ea897be28" translate="yes" xml:space="preserve">
          <source>Using Session.equals here means that when the user clicks on an item and changes the selection, only the newly selected and the newly unselected items are re-rendered.</source>
          <target state="translated">여기서 Session.equals를 사용하면 사용자가 항목을 클릭하고 선택을 변경할 때 새로 선택한 항목과 새로 선택되지 않은 항목 만 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1e63d2694fcde1eafdb5a2385c1ae2fc7da9f76a" translate="yes" xml:space="preserve">
          <source>Using Ubuntu Make</source>
          <target state="translated">우분투 사용하기</target>
        </trans-unit>
        <trans-unit id="a45711d8609a4d5a7f5e373c787e641c382e5e12" translate="yes" xml:space="preserve">
          <source>Using a local collection to store and display data fetched from a Method</source>
          <target state="translated">로컬 컬렉션을 사용하여 메소드에서 가져온 데이터 저장 및 표시</target>
        </trans-unit>
        <trans-unit id="ac426f4d17ac37edf8da6bfd273cc4964850681a" translate="yes" xml:space="preserve">
          <source>Using any of Meteor&amp;rsquo;s &lt;a href=&quot;build-tool#css&quot;&gt;supported CSS pre-processors&lt;/a&gt; you can import other style files provided by an NPM into your application using both relative and absolute paths. However, this will only work for the top-level app and will not work inside an Atmosphere package.</source>
          <target state="translated">Meteor에서 &lt;a href=&quot;build-tool#css&quot;&gt;지원하는 CSS 프리 프로세서&lt;/a&gt; 를 사용하면 NPM에서 제공하는 다른 스타일 파일을 상대 경로와 절대 경로를 모두 사용하여 응용 프로그램으로 가져올 수 있습니다. 그러나 이것은 최상위 앱에서만 작동하며 Atmosphere 패키지에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3c3cfb8bbd7432bd063ad887566596bb7be1f09" translate="yes" xml:space="preserve">
          <source>Using any of Meteor&amp;rsquo;s supported CSS pre-processors you can import other style files using the &lt;code&gt;{package-name}&lt;/code&gt; syntax as long as those files are designated to be lazily evaluated as &amp;ldquo;import&amp;rdquo; files. To get more details on how to determine this see &lt;a href=&quot;build-tool#css-source-vs-import&quot;&gt;CSS source versus import&lt;/a&gt; files.</source>
          <target state="translated">Meteor의 지원되는 CSS 프리 프로세서를 사용하면 파일이 &quot;가져 오기&quot;파일로 느리게 평가되도록 지정된 경우 &lt;code&gt;{package-name}&lt;/code&gt; 구문을 사용하여 다른 스타일 파일을 가져올 수 있습니다. 이를 결정하는 방법에 대한 자세한 내용은 &lt;a href=&quot;build-tool#css-source-vs-import&quot;&gt;CSS 소스와 가져 오기&lt;/a&gt; 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eea3cba804284a77f2e8a2c498c7830c69db10b3" translate="yes" xml:space="preserve">
          <source>Using npm Packages</source>
          <target state="translated">npm 패키지 사용</target>
        </trans-unit>
        <trans-unit id="d014bbccb76d2fb30ab515cc552cf71f5db19b0f" translate="yes" xml:space="preserve">
          <source>Using oauth-encryption on Windows</source>
          <target state="translated">Windows에서 oauth-encryption 사용</target>
        </trans-unit>
        <trans-unit id="3b5c16000f486145e2add9cb3f0d3da20e90fbc6" translate="yes" xml:space="preserve">
          <source>Using oauth-encryption with accounts</source>
          <target state="translated">계정에 oauth- 암호화 사용</target>
        </trans-unit>
        <trans-unit id="ec171f85b43e47ed7a519aded9254709b68e16b2" translate="yes" xml:space="preserve">
          <source>Using oauth-encryption without accounts</source>
          <target state="translated">계정없이 oauth- 암호화 사용</target>
        </trans-unit>
        <trans-unit id="cd99de4018ad13733eafdbf3510c5663df6e7836" translate="yes" xml:space="preserve">
          <source>Using plugins</source>
          <target state="translated">플러그인 사용</target>
        </trans-unit>
        <trans-unit id="5017817c024119d2f5bd08a3f92452d595bb4ff5" translate="yes" xml:space="preserve">
          <source>Using schemas on write</source>
          <target state="translated">쓰기시 스키마 사용</target>
        </trans-unit>
        <trans-unit id="c55a9fca65358172a95d4d2999bd0306206dafee" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;https://atmospherejs.com/johanbrook/publication-collector&quot;&gt;&lt;code&gt;johanbrook:publication-collector&lt;/code&gt;&lt;/a&gt; package, you&amp;rsquo;re able to test individual publication&amp;rsquo;s output without needing to create a traditional subscription:</source>
          <target state="translated">은 Using &lt;a href=&quot;https://atmospherejs.com/johanbrook/publication-collector&quot;&gt; &lt;code&gt;johanbrook:publication-collector&lt;/code&gt; &lt;/a&gt; 패키지를, 당신은 기존의 구독을 만들 필요없이 개인 출판의 출력을 테스트 할 수있어 :</target>
        </trans-unit>
        <trans-unit id="1ad9185ceb62e3d26112c00bede6f61a36486ad7" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;meteor npm ...&lt;/code&gt; commands in place of traditional &lt;code&gt;npm ...&lt;/code&gt; commands is particularly important when using Node.js modules that have binary dependencies that make native C calls (like &lt;a href=&quot;https://www.npmjs.com/package/bcrypt&quot;&gt;&lt;code&gt;bcrypt&lt;/code&gt;&lt;/a&gt;) because doing so ensures that they are built using the same libaries.</source>
          <target state="translated">기존 &lt;code&gt;npm ...&lt;/code&gt; 명령 대신 &lt;code&gt;meteor npm ...&lt;/code&gt; 명령을 사용하는 것은 &lt;a href=&quot;https://www.npmjs.com/package/bcrypt&quot;&gt; &lt;code&gt;bcrypt&lt;/code&gt; &lt;/a&gt; 와 같은 기본 C 호출을 수행하는 이진 종속성이있는 Node.js 모듈을 사용할 때 특히 중요 합니다. 도서관.</target>
        </trans-unit>
        <trans-unit id="f933359ba9f9f8c3a3b9d72930fa9d798376fb73" translate="yes" xml:space="preserve">
          <source>Using the style guide to prototype loading state</source>
          <target state="translated">스타일 가이드를 사용하여로드 상태 프로토 타입</target>
        </trans-unit>
        <trans-unit id="53683da0e52c2eee9035300710d9ff0c180f58d2" translate="yes" xml:space="preserve">
          <source>Usually build plugins implement a class that is given a list of files to process. Commonly, such files have the following methods:</source>
          <target state="translated">일반적으로 빌드 플러그인은 처리 할 파일 목록이 제공되는 클래스를 구현합니다. 일반적으로 이러한 파일에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d603c9c01b0a98ae82dd143867da9b4fbebd2f08" translate="yes" xml:space="preserve">
          <source>Usually it is better to not rely on your application code in migrations (because the application will change over time, and the migrations should not). For instance, having your migrations pass through your Collection2 collections (and thus check schemas, set autovalues etc) is likely to break them over time as your schemas change over time.</source>
          <target state="translated">일반적으로 마이그레이션시 응용 프로그램 코드에 의존하지 않는 것이 좋습니다 (응용 프로그램은 시간이 지남에 따라 변경되고 마이그레이션하지 않아야하기 때문에). 예를 들어, 이주가 Collection2 콜렉션을 통과하게하여 스키마를 확인하고 자동 값을 설정하는 등의 작업은 시간이 지남에 따라 스키마가 변경 될 때 시간이 지남에 따라 스키마를 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7df64632cf5e443809b8f851703ad5b54ec8b29" translate="yes" xml:space="preserve">
          <source>Usually it makes for a better UX to show as much of the screen as possible as quickly as possible and to only show loading state for the parts of the screen that are still waiting on data. So a nice pattern to follow is &amp;ldquo;per-component loading&amp;rdquo;. We do this in the Todos app when you visit the list page&amp;mdash;we instantly render the list metadata, such as its title and privacy settings, and render a loading state for the list of todos while we wait for them to appear.</source>
          <target state="translated">일반적으로 더 나은 UX는 가능한 한 많은 화면을 가능한 빨리 표시하고 여전히 데이터를 기다리고있는 화면 부분의 로딩 상태 만 표시합니다. 따라서 따라야 할 좋은 패턴은 &quot;구성 요소 별로드&quot;입니다. 목록 페이지를 방문 할 때 Todos 앱에서이 작업을 수행합니다. 제목 및 개인 정보 설정과 같은 목록 메타 데이터를 즉시 렌더링하고 할 일 목록이 나타날 때까지로드 목록을로드 상태로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="080418566278cf80d070092e08481e3b90f576c9" translate="yes" xml:space="preserve">
          <source>Usually such state is stored in a &lt;em&gt;global singleton&lt;/em&gt; object which we can call a store. A singleton is a data structure of which only a single copy logically exists. The current user and the router from above are typical examples of such global singletons.</source>
          <target state="translated">일반적으로 이러한 상태는 상점을 호출 할 수 있는 &lt;em&gt;전역 단일&lt;/em&gt; 객체에 저장됩니다. 싱글 톤은 논리적으로 단일 사본 만 존재하는 데이터 구조입니다. 위의 현재 사용자와 라우터는 이러한 글로벌 싱글 톤의 전형적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="4dd49f6dedfd5f286c952f4f335ead4222474ceb" translate="yes" xml:space="preserve">
          <source>Usually, the popup-based flow is preferable because the user will not have to reload your whole app at the end of the login flow. However, the popup-based flow requires browser features such as &lt;code&gt;window.close&lt;/code&gt; and &lt;code&gt;window.opener&lt;/code&gt; that are not available in all mobile environments. In particular, we recommend using &lt;code&gt;Meteor.loginWith&amp;lt;ExternalService&amp;gt;({ loginStyle: 'redirect' })&lt;/code&gt; in the following environments:</source>
          <target state="translated">일반적으로 팝업 흐름은 사용자가 로그인 흐름이 끝날 때 전체 앱을 다시로드 할 필요가 없기 때문에 바람직합니다. 그러나 팝업 기반 플로우에는 일부 모바일 환경에서 사용할 수없는 &lt;code&gt;window.close&lt;/code&gt; 및 &lt;code&gt;window.opener&lt;/code&gt; 와 같은 브라우저 기능이 필요 합니다. 특히 다음 환경에서 &lt;code&gt;Meteor.loginWith&amp;lt;ExternalService&amp;gt;({ loginStyle: 'redirect' })&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="448557a493c70fe0dcbe5cc202ed2a74070bab70" translate="yes" xml:space="preserve">
          <source>Usually, we can redirect in response to a user&amp;rsquo;s action by calling &lt;code&gt;FlowRouter.go()&lt;/code&gt; and friends, like in our list creation example above, but if a user browses directly to a URL that doesn&amp;rsquo;t exist, it&amp;rsquo;s useful to know how to redirect immediately.</source>
          <target state="translated">일반적으로 위의 목록 작성 예에서와 같이 &lt;code&gt;FlowRouter.go()&lt;/code&gt; 및 친구 를 호출하여 사용자의 조치에 대한 응답으로 경로 재 지정할 수 있지만 사용자가 존재하지 않는 URL을 직접 찾아 보는 경우 방법을 아는 것이 유용합니다 즉시 리디렉션하십시오.</target>
        </trans-unit>
        <trans-unit id="9d79eabf3b21a3edcb3cca6cccdaf3a8fbeea61e" translate="yes" xml:space="preserve">
          <source>Usually, while developing an application, it makes sense to run &lt;code&gt;meteor test&lt;/code&gt; on a second port (say &lt;code&gt;3100&lt;/code&gt;), while also running your main application in a separate process:</source>
          <target state="translated">일반적으로 응용 프로그램을 개발하는 동안 별도의 프로세스에서 기본 응용 프로그램을 실행하면서 두 번째 포트 (예 : &lt;code&gt;3100&lt;/code&gt; )에서 &lt;code&gt;meteor test&lt;/code&gt; 를 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0e80e11d33452a9a41da25c7cbb3152b516fe169" translate="yes" xml:space="preserve">
          <source>Usually, you don&amp;rsquo;t need to include &lt;code&gt;accounts-base&lt;/code&gt; yourself since it&amp;rsquo;s added for you if you use &lt;code&gt;accounts-password&lt;/code&gt; or similar, but it&amp;rsquo;s good to be aware of what is what.</source>
          <target state="translated">일반적으로 &lt;code&gt;accounts-password&lt;/code&gt; 또는 이와 유사한 것을 사용하는 경우 &lt;code&gt;accounts-base&lt;/code&gt; 이 추가되므로 계정 기반을 직접 포함 할 필요는 없지만 무엇이 무엇인지 알고있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bafcc18c6001832250fcc1b24de9d49644426902" translate="yes" xml:space="preserve">
          <source>Valid key values:</source>
          <target state="translated">유효한 키 값 :</target>
        </trans-unit>
        <trans-unit id="c4809279eaffccbaae44cdeedc2f2acf685589ca" translate="yes" xml:space="preserve">
          <source>Validate all Method and publication arguments, and include the &lt;code&gt;audit-argument-checks&lt;/code&gt; to check this automatically.</source>
          <target state="translated">모든 Method 및 Publication 인수 를 확인 하고 &lt;code&gt;audit-argument-checks&lt;/code&gt; 를 포함시켜 이를 자동으로 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="03557f20b760d4f31c2307f132591da6e45886a6" translate="yes" xml:space="preserve">
          <source>Validate all arguments</source>
          <target state="translated">모든 인수 확인</target>
        </trans-unit>
        <trans-unit id="888b7ee83a472f1d312ef6cdfc9d78c961d9a324" translate="yes" xml:space="preserve">
          <source>Validate all arguments using &lt;code&gt;check&lt;/code&gt; or &lt;code&gt;aldeed:simple-schema&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 또는 &lt;code&gt;aldeed:simple-schema&lt;/code&gt; 를 사용하여 모든 인수의 유효성을 검증 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b1a9c130d0822b346ebc944d18c77af8995f90f" translate="yes" xml:space="preserve">
          <source>Validate and check all inputs that come from the client.</source>
          <target state="translated">클라이언트에서 오는 모든 입력을 확인하고 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="15f0bb7c9a7bdb62845bdb709898269a288d135a" translate="yes" xml:space="preserve">
          <source>Validate data context</source>
          <target state="translated">데이터 컨텍스트 확인</target>
        </trans-unit>
        <trans-unit id="80a59d7c91ab12693f3c24c5b83bfd3385bd2c0e" translate="yes" xml:space="preserve">
          <source>Validate login attempts.</source>
          <target state="translated">로그인 시도를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="87ce9b6cba405f47ec78abd4743634d121c5bdee" translate="yes" xml:space="preserve">
          <source>Validate login callbacks that aren&amp;rsquo;t explicitly trying to override a previous error generally have no need to run if the attempt has already been determined to fail, and should start with</source>
          <target state="translated">이전 오류를 명시 적으로 무시하려고 시도하지 않는 로그인 콜백의 유효성 검사는 일반적으로 시도가 이미 실패한 것으로 판단되는 경우 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7890fdb5f8ccd072b05f6c52a66ef7fc2a051cb9" translate="yes" xml:space="preserve">
          <source>Validating against a schema</source>
          <target state="translated">스키마에 대한 유효성 검사</target>
        </trans-unit>
        <trans-unit id="fb936e80a470ebeaaad104b273f6fb1e1b350a2b" translate="yes" xml:space="preserve">
          <source>ValidationError for argument validation errors</source>
          <target state="translated">인수 유효성 검사 오류에 대한 ValidationError</target>
        </trans-unit>
        <trans-unit id="f429b7cf8a4db1908837249a6ac2a54a6e11bf9b" translate="yes" xml:space="preserve">
          <source>Values returned from helpers must be pure text, not HTML. (That is, strings should have &lt;code&gt;&amp;lt;&lt;/code&gt;, not &lt;code&gt;&amp;amp;lt;&lt;/code&gt;.) Spacebars will perform any necessary escaping if a template is rendered to HTML.</source>
          <target state="translated">도우미에서 반환 된 값은 HTML이 아닌 순수한 텍스트 여야합니다. 즉, 문자열은 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 아닌 &lt;code&gt;&amp;lt;&lt;/code&gt; 이어야합니다 . 템플릿이 HTML로 렌더링되는 경우 스페이스 바는 필요한 이스케이프 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="045c90945319688ae9d74869140c5d56b7e85fb9" translate="yes" xml:space="preserve">
          <source>Variables introduced this way take precedence over names of templates, global helpers, fields of the current data context and previously introduced variables with the same name.</source>
          <target state="translated">이 방법으로 도입 된 변수는 템플릿 이름, 전역 도우미, 현재 데이터 컨텍스트의 필드 및 이전에 도입 된 이름이 같은 변수보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bbd63e59c29dd06130dff6566b7da5d024348166" translate="yes" xml:space="preserve">
          <source>Version numbers in string form</source>
          <target state="translated">문자열 형식의 버전 번호</target>
        </trans-unit>
        <trans-unit id="f4db5c9295ba20317d97afec7f45171a7d75f8f0" translate="yes" xml:space="preserve">
          <source>View layers</source>
          <target state="translated">레이어보기</target>
        </trans-unit>
        <trans-unit id="80862a89e60d27db6c651d4339c6e41365075e1c" translate="yes" xml:space="preserve">
          <source>Viewing</source>
          <target state="translated">Viewing</target>
        </trans-unit>
        <trans-unit id="e5f044a125b61640854a6b6d36ce37e1659ea156" translate="yes" xml:space="preserve">
          <source>Visit the &lt;a href=&quot;https://forums.meteor.com&quot;&gt;Meteor discussion forums&lt;/a&gt; to announce projects, get help, talk about the community, or discuss changes to core.</source>
          <target state="translated">&lt;a href=&quot;https://forums.meteor.com&quot;&gt;Meteor 토론 포럼&lt;/a&gt; 을 방문하여 프로젝트 발표, 도움 받기, 커뮤니티에 대한 이야기 ​​또는 핵심 변경 사항에 대해 토론하십시오.</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">비주얼 스튜디오 코드</target>
        </trans-unit>
        <trans-unit id="80dba7512d8171ffe0c68de505c83939c8e4f7b6" translate="yes" xml:space="preserve">
          <source>Visually testing reusable components</source>
          <target state="translated">재사용 가능한 구성 요소를 시각적으로 테스트</target>
        </trans-unit>
        <trans-unit id="6f77218a678f83cf7b0f6386bfaa4b68ac89b8ee" translate="yes" xml:space="preserve">
          <source>Watch a query. Receive callbacks as the result set changes.</source>
          <target state="translated">쿼리를보십시오. 결과 집합이 변경되면 콜백을받습니다.</target>
        </trans-unit>
        <trans-unit id="023860dab61f66b01b653c243028682ec7205894" translate="yes" xml:space="preserve">
          <source>Watch a query. Receive callbacks as the result set changes. Only the differences between the old and new documents are passed to the callbacks.</source>
          <target state="translated">쿼리를보십시오. 결과 집합이 변경되면 콜백을받습니다. 이전 문서와 새 문서의 차이점 만 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e70677505fbf49c176a22cca7a1b636171a3e136" translate="yes" xml:space="preserve">
          <source>We achieve this by passing the readiness of the todos list down from the smart component which is subscribing (the &lt;code&gt;listShowPage&lt;/code&gt;) into the reusable component which renders the data:</source>
          <target state="translated">이를 수행 할 스마트 컴포넌트 ( &lt;code&gt;listShowPage&lt;/code&gt; ) 에서 todos 목록의 준비성을 데이터를 렌더링하는 재사용 가능한 컴포넌트로 전달하여이를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="c8b484b3d7f114e81448853cb7597adc9e8c0f6e" translate="yes" xml:space="preserve">
          <source>We are then able to wire in the denormalizer into the mutations of the &lt;code&gt;Todos&lt;/code&gt; collection like so:</source>
          <target state="translated">그런 다음 비정규 화 도구를 &lt;code&gt;Todos&lt;/code&gt; 컬렉션 의 돌연변이에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33f8b817ee66745ac583a46ea670f6a8c6a78db" translate="yes" xml:space="preserve">
          <source>We attach the schema to the namespace of &lt;code&gt;Lists&lt;/code&gt; directly, which allows us to check objects against this schema directly whenever we want, such as in a form or &lt;a href=&quot;methods&quot;&gt;Method&lt;/a&gt;. In the &lt;a href=&quot;#schemas-on-write&quot;&gt;next section&lt;/a&gt; we&amp;rsquo;ll see how to use this schema automatically when writing to the collection.</source>
          <target state="translated">스키마를 &lt;code&gt;Lists&lt;/code&gt; 네임 스페이스에 직접 연결하면 양식이나 &lt;a href=&quot;methods&quot;&gt;Method&lt;/a&gt; 등 원하는 경우 언제든지이 스키마에 대해 개체를 직접 확인할 수 있습니다 . 에서 &lt;a href=&quot;#schemas-on-write&quot;&gt;다음 섹션&lt;/a&gt; 우리는 컬렉션에 기록 할 때 자동으로이 스키마를 사용하는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54ff4d01015b98dd760aa2436a1958993a17aa88" translate="yes" xml:space="preserve">
          <source>We believe Methods provide a much better primitive for building modern applications than REST endpoints built on HTTP. Let&amp;rsquo;s go over some of the things you get for free with Methods that you would have to worry about if using HTTP. The purpose of this section is not to convince you that REST is bad - it&amp;rsquo;s just to remind you that you don&amp;rsquo;t need to handle these things yourself in a Meteor app.</source>
          <target state="translated">우리는 메소드가 HTTP 기반의 REST 엔드 포인트보다 최신 애플리케이션을 빌드하는 데 훨씬 더 나은 기본 요소를 제공한다고 생각합니다. HTTP를 사용하는 경우 걱정해야 할 메소드를 사용하여 무료로 얻을 수있는 것들을 살펴 보겠습니다. 이 섹션의 목적은 REST가 나쁘다는 것을 확신시키기위한 것이 아니라 Meteor 앱에서 이러한 것들을 직접 처리 할 필요가 없음을 상기시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="45f0dc5c09269563f1248497ac835d4da26a207a" translate="yes" xml:space="preserve">
          <source>We can also add that command to our &lt;code&gt;package.json&lt;/code&gt; as a &lt;code&gt;test&lt;/code&gt; script:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 스크립트 로 &lt;code&gt;package.json&lt;/code&gt; 에 해당 명령을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a9107c4505267d3b570f2f760a133029f39b3d4" translate="yes" xml:space="preserve">
          <source>We can also apply the same structure to testing React components and recommend the &lt;a href=&quot;https://github.com/airbnb/enzyme&quot;&gt;Enzyme&lt;/a&gt; package, which simulates a React component&amp;rsquo;s environment and allows you to query it using CSS selectors. A larger suite of tests is available in the &lt;a href=&quot;https://github.com/meteor/todos/tree/react&quot;&gt;react branch of the Todos app&lt;/a&gt;, but let&amp;rsquo;s look at a simple example for now:</source>
          <target state="translated">또한 React 구성 요소 테스트에 동일한 구조를 적용하고 React 구성 요소의 환경을 시뮬레이션하고 CSS 선택기를 사용하여 쿼리 할 수 있는 &lt;a href=&quot;https://github.com/airbnb/enzyme&quot;&gt;Enzyme&lt;/a&gt; 패키지를 권장 할 수 있습니다. &lt;a href=&quot;https://github.com/meteor/todos/tree/react&quot;&gt;Todos 앱&lt;/a&gt; 의 반응 브랜치 에서 더 큰 테스트 모음을 사용할 수 있지만 지금은 간단한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="92d2f77dfd1bf7e88a8d062c6fdb2f47955b940c" translate="yes" xml:space="preserve">
          <source>We can also easily use translations in Blaze templates. To do so, we can use the &lt;code&gt;{{_ }}&lt;/code&gt; helper. In the Todos app we use the actual string that we want to output in English as the i18n key, which means we don&amp;rsquo;t need to provide an English translation, although perhaps in a real app you might want to provide keys from the beginning.</source>
          <target state="translated">Blaze 템플릿에서 번역을 쉽게 사용할 수도 있습니다. 이를 위해 &lt;code&gt;{{_ }}&lt;/code&gt; 도우미를 사용할 수 있습니다 . Todos 앱에서는 영어로 출력하려는 ​​실제 문자열을 i18n 키로 사용합니다. 즉, 실제 앱에서는 처음부터 키를 제공 할 수도 있지만 영어 번역을 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f22f384764aee1fe14c7dafc10fb665e2fa8d68" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;publish-composite&lt;/code&gt; to perform complex authorization in publications. For instance, consider if we had a &lt;code&gt;Todos.admin.inList&lt;/code&gt; publication that allowed an admin to bypass default publication&amp;rsquo;s security for users with an &lt;code&gt;admin&lt;/code&gt; flag set.</source>
          <target state="translated">&lt;code&gt;publish-composite&lt;/code&gt; 를 사용하여 게시 에서 복잡한 인증을 수행 할 수도 있습니다 . 예를 들어, &lt;code&gt;admin&lt;/code&gt; 플래그가 설정된 사용자에 대해 관리자가 기본 게시의 보안을 우회 할 수있게 해주는 &lt;code&gt;Todos.admin.inList&lt;/code&gt; 게시 가 있는지 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="404edd3a8b9cec4841d4934e807761f1104d352e" translate="yes" xml:space="preserve">
          <source>We can also use a command-line driver for Mocha &lt;a href=&quot;https://atmospherejs.com/meteortesting/mocha&quot;&gt;&lt;code&gt;meteortesting:mocha&lt;/code&gt;&lt;/a&gt; to run our standard tests on the command line.</source>
          <target state="translated">또한 Mocha &lt;a href=&quot;https://atmospherejs.com/meteortesting/mocha&quot;&gt; &lt;code&gt;meteortesting:mocha&lt;/code&gt; &lt;/a&gt; 용 명령 줄 드라이버를 사용하여 명령 줄에서 표준 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8319bf829fd8fb9f0ee17a63e83f77c056cbca35" translate="yes" xml:space="preserve">
          <source>We can determine if the user is currently viewing the list with the &lt;code&gt;activeListClass&lt;/code&gt; helper:</source>
          <target state="translated">&lt;code&gt;activeListClass&lt;/code&gt; 도우미를 사용하여 사용자가 현재 목록을보고 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="180102553a75ea5c131b70101ebffe037336b39e" translate="yes" xml:space="preserve">
          <source>We can now distinguish between the 5 states above based on these conditions:</source>
          <target state="translated">다음 조건에 따라 위의 5 가지 상태를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8db255d04f2d2e46dd8598a7e77a72a778370ff8" translate="yes" xml:space="preserve">
          <source>We can now use the data from the local collection &lt;code&gt;ScoreAverages&lt;/code&gt; inside a UI component exactly the same way we would use a regular MongoDB collection. Instead of it updating automatically, we&amp;rsquo;ll need to call &lt;code&gt;updateAverages&lt;/code&gt; every time we need new results.</source>
          <target state="translated">이제 일반 MongoDB 컬렉션을 사용하는 것과 동일한 방식으로 UI 구성 요소 내 에서 로컬 컬렉션 &lt;code&gt;ScoreAverages&lt;/code&gt; 의 데이터를 사용할 수 있습니다 . 자동으로 업데이트되는 대신 새로운 결과가 필요할 때마다 &lt;code&gt;updateAverages&lt;/code&gt; 를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="111a91f091af503fa1f23d871fb7238da463c6a1" translate="yes" xml:space="preserve">
          <source>We can take advantage of the object specification form of a block tag to define an object with properties we name:</source>
          <target state="translated">블록 태그의 객체 지정 형식을 활용하여 이름이 지정된 속성으로 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e81303b7fca31ea4339d443f8ad45d76e557a92" translate="yes" xml:space="preserve">
          <source>We can use a subclass for this case as well, overriding the &lt;code&gt;remove()&lt;/code&gt; method:</source>
          <target state="translated">이 경우에도 서브 클래스를 사용하여 &lt;code&gt;remove()&lt;/code&gt; 메서드를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc12cc8dc89146524fb0f80a1ccdca1c2811d0de" translate="yes" xml:space="preserve">
          <source>We can use the &lt;a href=&quot;#test-data&quot;&gt;Factory package&amp;rsquo;s&lt;/a&gt;&lt;code&gt;.build()&lt;/code&gt; API to create a test document without inserting it into any collection. As we&amp;rsquo;ve been careful not to call out to any collections directly in the reusable component, we can pass the built &lt;code&gt;todo&lt;/code&gt; document directly into the template.</source>
          <target state="translated">우리는 사용할 수 있습니다 &lt;a href=&quot;#test-data&quot;&gt;공장 패키지의 &lt;/a&gt; &lt;code&gt;.build()&lt;/code&gt; 어떤 수집에 삽입하지 않고 테스트 문서를 만들 API를. 재사용 가능한 컴포넌트에서 직접 콜렉션을 호출하지 않도록주의 했으므로 빌드 된 &lt;code&gt;todo&lt;/code&gt; 문서를 템플리트로 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3849a93ff5248576e0a3e5125111f84d10c745f" translate="yes" xml:space="preserve">
          <source>We can use the &lt;a href=&quot;https://atmospherejs.com/dburles/collection-helpers&quot;&gt;&lt;code&gt;dburles:collection-helpers&lt;/code&gt;&lt;/a&gt; package to easily attach such methods (or &amp;ldquo;helpers&amp;rdquo;) to documents. For instance:</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/dburles/collection-helpers&quot;&gt; &lt;code&gt;dburles:collection-helpers&lt;/code&gt; &lt;/a&gt; 패키지를 사용하여 이러한 메소드 (또는 &quot;헬퍼&quot;)를 문서에 쉽게 첨부 할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="a9491149f883c97c881b591b443d5b7c9fb89ec3" translate="yes" xml:space="preserve">
          <source>We can use this information to be more subtle about when we try and show data to users, and when we show a loading screen.</source>
          <target state="translated">이 정보를 사용하여 사용자에게 데이터를 표시하려고 할 때와 로딩 화면을 표시 할 때 더 미묘한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74db3094b83b131983d2fc11f77e3f2242d446c" translate="yes" xml:space="preserve">
          <source>We could write our above migration like so (note that you must be on MongoDB 2.6 or later for the bulk update operations to exist). We can access the native MongoDB API via &lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection-rawCollection&quot;&gt;&lt;code&gt;Collection#rawCollection()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위의 마이그레이션을 이렇게 작성할 수 있습니다 (대량 업데이트 작업이 존재하려면 MongoDB 2.6 이상이어야합니다). &lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection-rawCollection&quot;&gt; &lt;code&gt;Collection#rawCollection()&lt;/code&gt; &lt;/a&gt; 통해 네이티브 MongoDB API에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eee7c51d10456d3ad169288246f8e84033bc7c4" translate="yes" xml:space="preserve">
          <source>We do that in the &lt;code&gt;action&lt;/code&gt; function of our &lt;code&gt;Lists.show&lt;/code&gt; route definition:</source>
          <target state="translated">우리는 &lt;code&gt;Lists.show&lt;/code&gt; 경로 정의 의 &lt;code&gt;action&lt;/code&gt; 함수 에서이를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="9855e9b007cc49cf29b6e64ad7e7bc2c6e5580ac" translate="yes" xml:space="preserve">
          <source>We do this for the same reason we subscribe in the component in the first place&amp;mdash;to avoid action at a distance and to make it easier to understand where data comes from. A common pattern is to fetch the data in a parent template, and then pass it into a &amp;ldquo;pure&amp;rdquo; child component, as we&amp;rsquo;ll see it in the &lt;a href=&quot;ui-ux#components&quot;&gt;UI Article&lt;/a&gt;.</source>
          <target state="translated">우리는 처음부터 컴포넌트를 구독하는 것과 같은 이유로 원거리에서 작업을 피하고 데이터의 출처를 더 쉽게 이해할 수 있도록하기 위해이를 수행합니다. 일반적인 패턴은 상위 템플릿에서 데이터를 가져온 다음 &lt;a href=&quot;ui-ux#components&quot;&gt;UI Article&lt;/a&gt; 에서 볼 수 있듯이 &quot;순수한&quot;하위 구성 요소로 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1651ae38461b176e14355178d2e8cdee134ca5be" translate="yes" xml:space="preserve">
          <source>We do this with Blaze&amp;rsquo;s &lt;code&gt;Template.subscriptionsReady&lt;/code&gt; which is perfect for this purpose, as it waits for all the subscriptions that the current component has asked for to become ready.</source>
          <target state="translated">Blaze의 &lt;code&gt;Template.subscriptionsReady&lt;/code&gt; 를 사용하면 현재 구성 요소가 준비하도록 요청한 모든 구독을 기다릴 수 있기 때문에이 목적에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="84f04ce9e68f5ba71117f050c42d38f05296bc5d" translate="yes" xml:space="preserve">
          <source>We have slightly modified the way Underscore differentiates between objects and arrays in &lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;collection functions&lt;/a&gt;. The original Underscore logic is to treat any object with a numeric &lt;code&gt;length&lt;/code&gt; property as an array (which helps it work properly on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NodeList&quot;&gt;&lt;code&gt;NodeList&lt;/code&gt;s&lt;/a&gt;). In Meteor&amp;rsquo;s version of Underscore, objects with a numeric &lt;code&gt;length&lt;/code&gt; property are treated as objects if they have no prototype (specifically, if &lt;code&gt;x.constructor === Object&lt;/code&gt;.</source>
          <target state="translated">Underscore가 &lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;컬렉션 함수&lt;/a&gt; 에서 객체와 배열을 구별하는 방식을 약간 수정 했습니다 . 원래 밑줄 로직은 숫자로 모든 개체를 치료하는 &lt;code&gt;length&lt;/code&gt; (그것에서 제대로 작동하는 데 도움이 배열 재산 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NodeList&quot;&gt; &lt;code&gt;NodeList&lt;/code&gt; 를 들&lt;/a&gt; ). Meteor의 Underscore 버전에서 숫자 &lt;code&gt;length&lt;/code&gt; 속성을 가진 객체는 프로토 타입이없는 경우 (특히 &lt;code&gt;x.constructor === Object&lt;/code&gt; 인 경우) 객체로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="a55ad990e0ddae5dc67ee2451fdf32e798033ca5" translate="yes" xml:space="preserve">
          <source>We might want to write:</source>
          <target state="translated">우리는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d92e893f2eb16248ff3c876dece5c8af700c08be" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;FlowRouter.go('Lists.show')&lt;/code&gt; outside of the callback of the Method call, so that it runs right away. First we &lt;em&gt;simulate&lt;/em&gt; the method (which creates a list locally in Minimongo), then route to it. Eventually the server returns, usually creating the exact same list (which the user will not even notice). In the unlikely event that the server call fails, we show an error and redirect back to the homepage.</source>
          <target state="translated">&lt;code&gt;FlowRouter.go('Lists.show')&lt;/code&gt; 를 Method 콜의 콜백 외부에 배치하여 즉시 실행되도록합니다. 먼저 메소드 (Minimongo에서 로컬로 목록을 작성 함)를 &lt;em&gt;시뮬레이션&lt;/em&gt; 한 후 경로를 지정합니다. 결국 서버가 반환되어 일반적으로 정확히 동일한 목록을 생성합니다 (사용자는 알지 못합니다). 서버 호출이 실패 할 경우 오류가 표시되고 홈페이지로 다시 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="c7531fbd03b44e92eb25ae25659d6ecd13b12937" translate="yes" xml:space="preserve">
          <source>We recommend choosing and sticking to a JavaScript style guide and enforcing it with tools. A popular option that we recommend is the &lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;Airbnb style guide&lt;/a&gt; with the ES6 extensions (and optionally React extensions).</source>
          <target state="translated">JavaScript 스타일 가이드를 선택하고 도구를 사용하여 적용하는 것이 좋습니다. ES6 확장 (및 선택적으로 React 확장) 이 포함 된 &lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;에어 비앤비 스타일 가이드&lt;/a&gt; 가 권장 됩니다.</target>
        </trans-unit>
        <trans-unit id="1b25b116ae91d3081999d0fc63470aeadac903ca" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&quot;&gt;Airbnb eslint configuration&lt;/a&gt; which verifies the Airbnb styleguide.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&quot;&gt;Airbnb 스타일 가이드&lt;/a&gt; 를 확인하는 에어 비앤비 에스 린트 구성 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="825bccad1882a72368fdd0d2dbb69ddc1f9a5239" translate="yes" xml:space="preserve">
          <source>We recommend using these approaches only if absolutely required and if your customizations can not be handled by standard configuration options.</source>
          <target state="translated">반드시 필요한 경우와 표준 구성 옵션으로 사용자 지정 내용을 처리 할 수없는 경우에만 이러한 방법을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e66eae3b48f33946df3e77d5d20aaa2c7257b1d2" translate="yes" xml:space="preserve">
          <source>We saw above that using a helper (or data context lookup) in the form &lt;code&gt;checked={{todo.checked}}&lt;/code&gt; will add the checked property to the HTML tag if &lt;code&gt;todo.checked&lt;/code&gt; evaluates to true. Also, you can directly include an object in the attribute list of an HTML element to set multiple attributes at once:</source>
          <target state="translated">위의 내용에서 &lt;code&gt;checked={{todo.checked}}&lt;/code&gt; 형식의 도우미 (또는 데이터 컨텍스트 조회)를 사용 하면 &lt;code&gt;todo.checked&lt;/code&gt; 가 true로 평가 되면 checked 속성이 HTML 태그에 추가됩니다 . 또한 HTML 요소의 속성 목록에 객체를 직접 포함시켜 여러 속성을 한 번에 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212c94829bfa33adf98a72f023b4376341891278" translate="yes" xml:space="preserve">
          <source>We simply define the &lt;code&gt;ListPage&lt;/code&gt; component as a presentational component that expects its data to be passed in using React &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">우리는 단순히 &lt;code&gt;ListPage&lt;/code&gt; 컴포넌트를 React &lt;code&gt;props&lt;/code&gt; 를 사용하여 데이터가 전달 될 것으로 예상하는 프리젠 테이션 컴포넌트로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e900738915d1e4581c9270c11ba6798344ecd067" translate="yes" xml:space="preserve">
          <source>We specify that the &lt;code&gt;name&lt;/code&gt; field of a list is required and must be a string.</source>
          <target state="translated">리스트 의 &lt;code&gt;name&lt;/code&gt; 필드는 필수이며 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0d948a30fbdb6a91c67d14d6ea8e2059f0606020" translate="yes" xml:space="preserve">
          <source>We specify that the &lt;code&gt;userId&lt;/code&gt;, which is optional, must be a string that looks like the ID of a user document.</source>
          <target state="translated">우리는 지정 &lt;code&gt;userId&lt;/code&gt; 를 보이는 사용자 문서의 ID를 좋아하는 선택 사항이며, 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2c7009320b4b09a7b757eb5e9991434d7ab9353a" translate="yes" xml:space="preserve">
          <source>We specify the &lt;code&gt;incompleteCount&lt;/code&gt; is a number, which on insertion is set to &lt;code&gt;0&lt;/code&gt; if not otherwise specified.</source>
          <target state="translated">우리는 지정 &lt;code&gt;incompleteCount&lt;/code&gt; 이 삽입시에 설정 한 번호 인 &lt;code&gt;0&lt;/code&gt; 달리 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="8b0a9a9ca4488500814241d40e6704df4afbb214" translate="yes" xml:space="preserve">
          <source>We suggest a convention of naming it &lt;code&gt;instance&lt;/code&gt; in these contexts and assigning it at the top of every relevant helper. For instance:</source>
          <target state="translated">이러한 맥락에서 &lt;code&gt;instance&lt;/code&gt; 의 이름을 지정하고 모든 관련 도우미의 맨 위에 할당 하는 규칙을 제안합니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="d5b5bece7791c8df87066cd2677025526a69426c" translate="yes" xml:space="preserve">
          <source>We suggest using the &lt;code&gt;this.userId&lt;/code&gt; property on the context of Methods and publications instead, and passing that around through function arguments to wherever you need it.</source>
          <target state="translated">대신 Methods 및 Publications의 컨텍스트 에서 &lt;code&gt;this.userId&lt;/code&gt; 속성을 사용하고 함수 인수를 통해 필요한 곳으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="2134562a7ab740161619af149b6d6f5e9287480e" translate="yes" xml:space="preserve">
          <source>We then import both of these files in &lt;code&gt;imports/startup/client/index.js&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;imports/startup/client/index.js&lt;/code&gt; 에서이 두 파일을 모두 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="713e02ddecbd33150bd5374b9b6500732e8e90ac" translate="yes" xml:space="preserve">
          <source>We think you&amp;rsquo;re going to love the new module system, and that&amp;rsquo;s why it will be installed by default for all new apps and packages. Nevertheless, the &lt;code&gt;modules&lt;/code&gt; package is totally optional, and it will be up to you to add it to existing apps and/or packages.</source>
          <target state="translated">우리는 당신이 새로운 모듈 시스템을 좋아할 것이라고 생각합니다. 이것이 모든 새로운 앱과 패키지에 기본적으로 설치되는 이유입니다. 그럼에도 불구하고 &lt;code&gt;modules&lt;/code&gt; 패키지는 전적으로 선택 사항이며 기존 앱 및 / 또는 패키지에 추가하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6e5c0c4ca46f3b35eb14ccc928b3173e72e033c7" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;this.subscribe()&lt;/code&gt; as opposed to &lt;code&gt;Meteor.subscribe()&lt;/code&gt; so that the component automatically keeps track of when the subscriptions are ready. We can use this information in our HTML template with the built-in &lt;code&gt;{{Template.subscriptionsReady}}&lt;/code&gt; helper or within helpers using &lt;code&gt;instance.subscriptionsReady()&lt;/code&gt;.</source>
          <target state="translated">우리는 사용 &lt;code&gt;this.subscribe()&lt;/code&gt; 에 반대 &lt;code&gt;Meteor.subscribe()&lt;/code&gt; 그래서 구성 요소가 자동으로 구독 준비가되었을 때의 추적있다. 내장 &lt;code&gt;{{Template.subscriptionsReady}}&lt;/code&gt; 헬퍼와 함께 또는 &lt;code&gt;instance.subscriptionsReady()&lt;/code&gt; 사용하여 헬퍼 내 에서 HTML 템플리트에서이 정보를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b95d2deaaa1a25dfab3069f2e104db52c56127d7" translate="yes" xml:space="preserve">
          <source>We use an &lt;code&gt;autorun()&lt;/code&gt; here to ensure that the data context is re-validated whenever it changes.</source>
          <target state="translated">우리는 사용 &lt;code&gt;autorun()&lt;/code&gt; 데이터 컨텍스트가 재 검증이 변경 될 때마다 있는지 확인하기 위해 여기를.</target>
        </trans-unit>
        <trans-unit id="a138c75af5bcc2abd919d1721259883355592db2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d increment that &lt;code&gt;requestedTodos&lt;/code&gt; variable when the user clicks &amp;ldquo;load more&amp;rdquo; (or perhaps just when they scroll to the bottom of the page).</source>
          <target state="translated">사용자가 &quot;추가로드&quot;를 클릭하거나 페이지 맨 아래로 스크롤 할 때 &lt;code&gt;requestedTodos&lt;/code&gt; 변수를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="55d04dac8ac69741203406a4991907b155caf924" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be referring to Meteor Methods with a capital M to differentiate them from class methods in JavaScript.</source>
          <target state="translated">JavaScript의 클래스 메소드와 구별하기 위해 대문자 M이있는 Meteor Methods를 참조 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="21e8fa969226cc6b287da3fa1545b1c42f850b79" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about how to handle the &lt;code&gt;ValidationError&lt;/code&gt; in the section on forms below.</source>
          <target state="translated">아래 양식의 섹션에서 &lt;code&gt;ValidationError&lt;/code&gt; 를 처리하는 방법에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="8a9cf8923f77b7e959c683403bee0429e2620088" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen an example of using an &lt;code&gt;autorun&lt;/code&gt; to re-subscribe when the (reactive) arguments to a subscription change. It&amp;rsquo;s worth digging in a little more detail to understand what happens in this scenario.</source>
          <target state="translated">(반응 형) 인수가 구독 변경에 대해 &lt;code&gt;autorun&lt;/code&gt; 을 사용하여 다시 구독 하는 예를 이미 보았습니다 . 이 시나리오에서 어떤 일이 발생하는지 이해하기 위해 조금 더 자세히 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c8fdb82d60c63756a3eca4d4896792eaca52e2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen examples above of failures which you don&amp;rsquo;t really anticipate will happen. It&amp;rsquo;s difficult and inefficient to defend against every possible error, however unlikely. However, there are some catch-all patterns that you can use for unexpected failures.</source>
          <target state="translated">우리는 당신이 실제로 예상하지 못한 실패의 예를 보았습니다. 그러나 가능한 모든 오류를 방어하는 것은 어렵고 비효율적입니다. 그러나 예기치 않은 장애에 사용할 수있는 모든 포괄 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a92ee0dd1acece00ece044f08379b324d51bfcb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen one example of running tests on the command line, using our &lt;code&gt;meteor npm run chimp-test&lt;/code&gt; mode.</source>
          <target state="translated">&lt;code&gt;meteor npm run chimp-test&lt;/code&gt; 모드를 사용하여 명령 행에서 테스트를 실행하는 예제를 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="898763cf37250e72b399888e07b50bfa8f05c41d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that &lt;code&gt;{{todo.title}}&lt;/code&gt; accesses the &lt;code&gt;title&lt;/code&gt; property of the &lt;code&gt;todo&lt;/code&gt; item on the current data context. Additionally, &lt;code&gt;..&lt;/code&gt; accesses the parent data context (rarely a good idea), &lt;code&gt;list.todos.[0]&lt;/code&gt; accesses the first element of the &lt;code&gt;todos&lt;/code&gt; array on &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{{todo.title}}&lt;/code&gt; 이 (가) 현재 데이터 컨텍스트 에서 &lt;code&gt;todo&lt;/code&gt; 항목 의 &lt;code&gt;title&lt;/code&gt; 속성에 액세스하는 것을 보았습니다 . 또한 &lt;code&gt;..&lt;/code&gt; 는 부모 데이터 컨텍스트 (드물게 좋은 아이디어) 인 &lt;code&gt;list.todos.[0]&lt;/code&gt; &lt;code&gt;list&lt;/code&gt; 의 &lt;code&gt;todos&lt;/code&gt; 배열 의 첫 번째 요소에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="3987502f114b2d73c65ea1910a97319cbcd2d663" translate="yes" xml:space="preserve">
          <source>WebStorm provides &lt;a href=&quot;https://www.jetbrains.com/webstorm/help/eslint.html&quot;&gt;these instructions for using ESLint&lt;/a&gt;. After you install the ESLint Node packages and set up your &lt;code&gt;package.json&lt;/code&gt;, just enable ESLint and click &amp;ldquo;Apply&amp;rdquo;. You can configure how WebStorm should find your &lt;code&gt;.eslintrc&lt;/code&gt; file, but on my machine it worked without any changes. It also automatically suggested switching to &amp;ldquo;JSX Harmony&amp;rdquo; syntax highlighting.</source>
          <target state="translated">WebStorm은 &lt;a href=&quot;https://www.jetbrains.com/webstorm/help/eslint.html&quot;&gt;ESLint 사용에 대한 지침을&lt;/a&gt; 제공합니다 . ESLint 노드 패키지를 설치하고 &lt;code&gt;package.json&lt;/code&gt; 을 설정 한 후 ESLint를 활성화하고&amp;ldquo;적용&amp;rdquo;을 클릭하십시오. WebStorm이 &lt;code&gt;.eslintrc&lt;/code&gt; 파일을 찾는 방법을 구성 할 수 있지만 내 컴퓨터에서는 아무런 변경없이 작동했습니다. 또한&amp;ldquo;JSX Harmony&amp;rdquo;구문 강조 표시로 자동 전환하도록 제안했습니다.</target>
        </trans-unit>
        <trans-unit id="9f52bca7c0abe7f1f7a60dc34b7755de6d6f44c7" translate="yes" xml:space="preserve">
          <source>What Cordova is, and how Meteor integrates with it to build mobile apps from a single codebase</source>
          <target state="translated">Cordova 란 무엇이며 Meteor와 통합하여 단일 코드베이스에서 모바일 앱을 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="715ab59402756713b9ed0fe2d54d30ea472c0019" translate="yes" xml:space="preserve">
          <source>What Methods are in Meteor and how they work in detail.</source>
          <target state="translated">Meteor의 방법 및 세부 작동 방법</target>
        </trans-unit>
        <trans-unit id="9a09cbaa3e5001ee250ebcf3fbc1b17367963e57" translate="yes" xml:space="preserve">
          <source>What React is, and why you would consider using it with Meteor.</source>
          <target state="translated">React가 무엇이며 Meteor와 함께 사용하는 것을 고려해야하는 이유.</target>
        </trans-unit>
        <trans-unit id="31e67532c2b2157c0135287af2681e37e1f7e285" translate="yes" xml:space="preserve">
          <source>What URL will users use to access your site? You&amp;rsquo;ll probably need to register a domain name with a domain registrar, and setup DNS entries to point to the site (this will depend on how you deploy, see below). If you deploy to Galaxy, you can use a &lt;code&gt;x.meteorapp.com&lt;/code&gt; or &lt;code&gt;x.eu.meteorapp.com&lt;/code&gt; domain while you are testing the app. &lt;a href=&quot;http://galaxy-guide.meteor.com/custom-domains.html#meteorapp-subdomain&quot;&gt;Learn more about Galaxy domains &amp;raquo;&lt;/a&gt;</source>
          <target state="translated">사용자가 사이트에 액세스하기 위해 어떤 URL을 사용합니까? 도메인 등록 기관에 도메인 이름을 등록하고 사이트를 가리 키도록 DNS 항목을 설정해야합니다 (이는 배포 방법에 따라 다릅니다 (아래 참조)). Galaxy에 배포하는 경우 앱을 테스트하는 동안 &lt;code&gt;x.meteorapp.com&lt;/code&gt; 또는 &lt;code&gt;x.eu.meteorapp.com&lt;/code&gt; 도메인을 사용할 수 있습니다 . &lt;a href=&quot;http://galaxy-guide.meteor.com/custom-domains.html#meteorapp-subdomain&quot;&gt;Galaxy 도메인에 대해 자세히 알아보기&amp;raquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="544add104824be68ef99321d0e73b9989fa0ae13" translate="yes" xml:space="preserve">
          <source>What about PhoneGap?</source>
          <target state="translated">PhoneGap은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="06b2c135c0cd5ad382fc2e7bf514ca2bf8828d46" translate="yes" xml:space="preserve">
          <source>What does it do?</source>
          <target state="translated">무엇을합니까?</target>
        </trans-unit>
        <trans-unit id="f95f4783f2f2b3eff2616770feda65452eb7647b" translate="yes" xml:space="preserve">
          <source>What does this mean for my app?</source>
          <target state="translated">내 앱에서 이것이 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="55de40f75713a616f3cba615561b4859feadc075" translate="yes" xml:space="preserve">
          <source>What features in core Meteor enable user accounts</source>
          <target state="translated">핵심 Meteor의 기능으로 사용자 계정 활성화</target>
        </trans-unit>
        <trans-unit id="cf5a4a470f538810dd11bc651364103fba56fdd4" translate="yes" xml:space="preserve">
          <source>What happens when you subscribe to a publication.</source>
          <target state="translated">발행물을 구독하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="edfc6c13c446747ffa72398d80b34ea405b37951" translate="yes" xml:space="preserve">
          <source>What is Meteor?</source>
          <target state="translated">유성은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="de11c908015e5632f5ff9ac616134a4c477aa358" translate="yes" xml:space="preserve">
          <source>What is a &lt;a href=&quot;https://github.com/meteor/validation-error/&quot;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt;? It&amp;rsquo;s a special error that is used in Meteor to indicate a user-input based error in modifying a collection. Typically, the details on a &lt;code&gt;ValidationError&lt;/code&gt; are used to mark up a form with information about what inputs don&amp;rsquo;t match the schema. In the &lt;a href=&quot;methods#validation-error&quot;&gt;methods article&lt;/a&gt;, we&amp;rsquo;ll see more about how this works.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/meteor/validation-error/&quot;&gt; &lt;code&gt;ValidationError&lt;/code&gt; &lt;/a&gt; 는 무엇입니까 ? 컬렉션을 수정할 때 사용자 입력 기반 오류를 나타 내기 위해 Meteor에서 사용되는 특수 오류입니다. 일반적으로 &lt;code&gt;ValidationError&lt;/code&gt; 에 대한 세부 정보는 스키마와 일치하지 않는 입력에 대한 정보로 양식을 표시하는 데 사용됩니다. 에서 &lt;a href=&quot;methods#validation-error&quot;&gt;방법 기사&lt;/a&gt; , 우리는 어떻게이 작품에 대한 자세한 내용을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ba3f66b14221964be28f5e6c73ddedb926e0b6" translate="yes" xml:space="preserve">
          <source>What is a Method?</source>
          <target state="translated">방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f3e027b7a31d82e4e8522767297430b9af264920" translate="yes" xml:space="preserve">
          <source>What is a view?</source>
          <target state="translated">보기 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fc8f340ba3180856db78ed055154bc9a7c919310" translate="yes" xml:space="preserve">
          <source>What is often confusing to people is that setting &lt;code&gt;App.accessRule&lt;/code&gt; is not enough to allow access to remote resources. While domain whitelisting allows the client to control which domains it can connect to, additional restrictions based on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt; also apply. By default, web views will not allow cross-origin HTTP requests initiated from JavaScript for instance, so you will likely run into this when using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사람들에게 종종 혼동되는 것은 &lt;code&gt;App.accessRule&lt;/code&gt; 을 설정하는 것만으로 는 원격 리소스에 액세스 할 수 없다는 것입니다. 도메인 화이트리스트를 사용하면 클라이언트가 연결할 수있는 도메인을 제어 할 수 있지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 출처 정책&lt;/a&gt; 에 따른 추가 제한 사항 도 적용됩니다. 기본적으로 웹보기는 예를 들어 JavaScript에서 시작된 교차 출처 HTTP 요청을 허용하지 않으므로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를&lt;/a&gt; 사용할 때이 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88608282acddee0150ea84bcd103b1021fe7d3b7" translate="yes" xml:space="preserve">
          <source>What is the Meteor Guide?</source>
          <target state="translated">유성 가이드는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a2240a5c4149dd89ccaa9b23d0c17cc195a959a5" translate="yes" xml:space="preserve">
          <source>What port will your app be served from?</source>
          <target state="translated">앱에서 어떤 포트를 제공합니까?</target>
        </trans-unit>
        <trans-unit id="50770b62e3fd36707eaf858b692bb5a3872e5843" translate="yes" xml:space="preserve">
          <source>What publications and subscriptions are in the Meteor platform.</source>
          <target state="translated">Meteor 플랫폼에는 어떤 출판물과 구독이 있습니까?</target>
        </trans-unit>
        <trans-unit id="ff5f4edfa3dd8e1d191a8ad001b5cea180637582" translate="yes" xml:space="preserve">
          <source>What that means is that the publication will simply ensure the set of data matching that query is available to any client that subscribes to it. In this case, all lists that do not have a &lt;code&gt;userId&lt;/code&gt; setting. So the collection named &lt;code&gt;Lists&lt;/code&gt; on the client will have all of the public lists that are available in the server collection named &lt;code&gt;Lists&lt;/code&gt; while that subscription is open. In this particular example in the Todos application, the subscription is initialized when the app starts and never stopped, but a later section will talk about &lt;a href=&quot;data-loading#patterns&quot;&gt;subscription life cycle&lt;/a&gt;.</source>
          <target state="translated">즉, 게시는 구독하는 모든 클라이언트가 해당 쿼리와 일치하는 데이터 집합을 사용할 수 있도록합니다. 이 경우 &lt;code&gt;userId&lt;/code&gt; 설정 이없는 모든 목록입니다 . 따라서 클라이언트에서 &lt;code&gt;Lists&lt;/code&gt; 라는 이름의 콜렉션 에는 해당 구독이 열려있는 동안 &lt;code&gt;Lists&lt;/code&gt; 라는 서버 콜렉션에서 사용 가능한 모든 공용 목록이 있습니다 . Todos 애플리케이션의이 특정 예제에서 구독은 앱이 시작되고 중지되지 않을 때 초기화되지만 이후 섹션에서는 &lt;a href=&quot;data-loading#patterns&quot;&gt;구독 수명주기에&lt;/a&gt; 대해 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="178359646449ea378ff0c1d727db3433d713dd22" translate="yes" xml:space="preserve">
          <source>What this means in practice is that you should place your subscription calls in &lt;em&gt;components&lt;/em&gt;. In Blaze, it&amp;rsquo;s best to do this in the &lt;code&gt;onCreated()&lt;/code&gt; callback:</source>
          <target state="translated">이것이 실제로 의미하는 것은 가입 호출을 &lt;em&gt;구성 요소에&lt;/em&gt; 배치해야한다는 것 입니다. Blaze에서는 &lt;code&gt;onCreated()&lt;/code&gt; 콜백 에서이 작업을 수행하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="667fca675b8ab923a3ef4072ae1f669cd0892f21" translate="yes" xml:space="preserve">
          <source>What this means is if users are accessing the site whilst the update is being prepared, it will likely go out of date! Also, a bulk update will lock the entire collection while it is being applied, which can cause a significant blip in your user experience if it takes a while. For these reason, you often need to stop your server and let your users know you are performing maintenance while the update is happening.</source>
          <target state="translated">업데이트가 준비되는 동안 사용자가 사이트에 액세스하는 경우 업데이트가 만료 될 수 있습니다. 또한 대량 업데이트는 전체 컬렉션이 적용되는 동안 전체 컬렉션을 잠그므로 시간이 오래 걸리면 사용자 환경이 크게 손상 될 수 있습니다. 이러한 이유로 종종 서버를 중지하고 업데이트가 진행되는 동안 유지 관리를 수행하고 있음을 사용자에게 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="cf6f95008e4d708b2c30094d082910c3ad04f398" translate="yes" xml:space="preserve">
          <source>What this means is in general, when changing subscriptions, there&amp;rsquo;ll be a period where you are &lt;em&gt;over-subscribed&lt;/em&gt; and there is more data on the client than you strictly asked for. This is one very important reason why you should always fetch the same data that you have subscribed to (don&amp;rsquo;t &amp;ldquo;over-fetch&amp;rdquo;).</source>
          <target state="translated">이것이 의미하는 바는 일반적으로 구독을 변경할 때 &lt;em&gt;초과 가입&lt;/em&gt; 한 기간이 있으며 엄격하게 요청한 것보다 더 많은 데이터가 클라이언트에 있다는 것입니다. 이것이 구독 한 것과 동일한 데이터를 항상 가져와야하는 중요한 이유 중 하나입니다 ( &quot;과다 반입&quot;하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="b1be9fc5a65038c6e36b8bb490dced9b113cd634" translate="yes" xml:space="preserve">
          <source>What this means is that now every time we call &lt;code&gt;Lists.insert()&lt;/code&gt;, &lt;code&gt;Lists.update()&lt;/code&gt;, &lt;code&gt;Lists.upsert()&lt;/code&gt;, first our document or modifier will be automatically checked against the schema (in subtly different ways depending on the exact mutator).</source>
          <target state="translated">이것이 의미하는 바는 이제 &lt;code&gt;Lists.insert()&lt;/code&gt; , &lt;code&gt;Lists.update()&lt;/code&gt; , &lt;code&gt;Lists.upsert()&lt;/code&gt; 호출 할 때마다 먼저 문서 또는 수정자가 스키마에 대해 자동으로 검사됩니다 (정확한 변경자에 따라 미묘하게 다른 방식으로) ).</target>
        </trans-unit>
        <trans-unit id="c74d3a339f6c99b15c158895f93ba6675398a76b" translate="yes" xml:space="preserve">
          <source>What this means is that whenever a user visits a URL of the form &lt;code&gt;/lists/X&lt;/code&gt;, the &lt;code&gt;Lists.show&lt;/code&gt; route will kick in, triggering the &lt;code&gt;BlazeLayout&lt;/code&gt; call to set the &lt;code&gt;main&lt;/code&gt; property of the &lt;code&gt;App_body&lt;/code&gt; component.</source>
          <target state="translated">이것이 의미하는 바입니다 사용자가 방문하는 양식의 URL이 때마다 &lt;code&gt;/lists/X&lt;/code&gt; 의 &lt;code&gt;Lists.show&lt;/code&gt; 의 경로가 트리거에서 시작된다 &lt;code&gt;BlazeLayout&lt;/code&gt; 의 세트에 전화를 &lt;code&gt;main&lt;/code&gt; 의 특성 &lt;code&gt;App_body&lt;/code&gt; 구성 요소를.</target>
        </trans-unit>
        <trans-unit id="18c7ac556ec60f6a1cc0e2bcef204f3d2f1d3c95" translate="yes" xml:space="preserve">
          <source>What this means is that you can write tests in files with a certain filename pattern and know they&amp;rsquo;ll not be included in normal builds of your app. When your app runs in test mode, those files will be loaded (and nothing else will), and they can import the modules you want to test. As we&amp;rsquo;ll see this is ideal for &lt;a href=&quot;#unit-testing&quot;&gt;unit tests&lt;/a&gt; and &lt;a href=&quot;#simple-integration-test&quot;&gt;simple integration tests&lt;/a&gt;.</source>
          <target state="translated">이것이 의미하는 바는 특정 파일 이름 패턴으로 파일에 테스트를 작성하고 테스트가 앱의 일반 빌드에 포함되지 않을 것임을 알 수 있습니다. 앱이 테스트 모드에서 실행되면 해당 파일이로드되고 다른 파일은로드되지 않으며 테스트하려는 모듈을 가져올 수 있습니다. 앞으로 살펴 보 겠지만 이는 &lt;a href=&quot;#unit-testing&quot;&gt;단위 테스트&lt;/a&gt; 및 &lt;a href=&quot;#simple-integration-test&quot;&gt;간단한 통합 테스트에&lt;/a&gt; 이상적입니다 .</target>
        </trans-unit>
        <trans-unit id="e40a8e983b9457978d17d73e419798dfcd21447b" translate="yes" xml:space="preserve">
          <source>What to consider before you deploy a Meteor application.</source>
          <target state="translated">Meteor 응용 프로그램을 배포하기 전에 고려해야 할 사항</target>
        </trans-unit>
        <trans-unit id="463789f77c1d0ba0ebb09ae7f72244ff76885ddc" translate="yes" xml:space="preserve">
          <source>What to consider when defining your collection&amp;rsquo;s schema.</source>
          <target state="translated">컬렉션 스키마를 정의 할 때 고려해야 할 사항</target>
        </trans-unit>
        <trans-unit id="36ee5edbedf8b9faf73b594f9f41959e17494e04" translate="yes" xml:space="preserve">
          <source>What you can do to create a good mobile user experience for your app</source>
          <target state="translated">앱에 좋은 모바일 사용자 경험을 제공하기 위해 할 수있는 일</target>
        </trans-unit>
        <trans-unit id="10ae24728db36499c26d2f6ef6407bc10f9e6817" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s special about &lt;code&gt;Session&lt;/code&gt; is that it&amp;rsquo;s reactive. If you call &lt;a href=&quot;#session_get&quot;&gt;&lt;code&gt;Session.get&lt;/code&gt;&lt;/a&gt;&lt;code&gt;('currentList')&lt;/code&gt; from inside a template, the template will automatically be rerendered whenever &lt;a href=&quot;#session_set&quot;&gt;&lt;code&gt;Session.set&lt;/code&gt;&lt;/a&gt;&lt;code&gt;('currentList', x)&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;Session&lt;/code&gt; 에서 특별한 점은 반응 형이라는 것입니다. 템플릿 내부에서 &lt;a href=&quot;#session_get&quot;&gt; &lt;code&gt;Session.get&lt;/code&gt; &lt;/a&gt; &lt;code&gt;('currentList')&lt;/code&gt; 을 호출하면 &lt;a href=&quot;#session_set&quot;&gt; &lt;code&gt;Session.set&lt;/code&gt; &lt;/a&gt; &lt;code&gt;('currentList', x)&lt;/code&gt; 가 호출 될 때마다 템플릿이 자동으로 다시 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="f287be46c03e5394c7dd4a50098d9da1a48027da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allowed&lt;/code&gt; is false, the exception describing why the login failed. It will be a &lt;code&gt;Meteor.Error&lt;/code&gt; for failures reported to the user (such as invalid password), and can be a another kind of exception for internal errors.</source>
          <target state="translated">때 &lt;code&gt;allowed&lt;/code&gt; 로그인이 실패한 이유를 제외하고는 기술, false입니다. 사용자에게보고 된 오류 (예 : 유효하지 않은 암호)에 대한 오류 는 &lt;code&gt;Meteor.Error&lt;/code&gt; 이며 내부 오류에 대한 또 다른 종류의 예외 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94185962f76bf2ba5a4988c8db706a34d1ffefd5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;meteor shell&lt;/code&gt; is executed in an application directory where a server is already running, it connects to the server and starts an interactive shell for evaluating server-side code.</source>
          <target state="translated">때 &lt;code&gt;meteor shell&lt;/code&gt; 서버가 이미 실행중인 응용 프로그램 디렉토리에 실행되고, 서버에 연결하여 서버 측 코드를 평가하는 대화 형 쉘을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a8016f520d55dbc8815070e60f070a3ca3d6f04c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, stringifies keys in an object in sorted order.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 정렬 된 순서로 객체에 키를 stringifies.</target>
        </trans-unit>
        <trans-unit id="e26ec741bd2757df67895e056248e865029ae19f" translate="yes" xml:space="preserve">
          <source>When Method simulations and server-side executions run, Meteor tracks any resulting changes to the database. This is what lets the Meteor data system roll back the changes from the Method simulation and replace them with the actual writes from the server. Without this automatic database tracking, it would be very difficult to implement a correct Optimistic UI system.</source>
          <target state="translated">분석법 시뮬레이션 및 서버 측 실행이 실행될 때 Meteor는 데이터베이스에 대한 모든 변경 사항을 추적합니다. 이를 통해 Meteor 데이터 시스템이 Method 시뮬레이션에서 변경 사항을 롤백하고이를 서버의 실제 쓰기로 대체 할 수 있습니다. 이 자동 데이터베이스 추적이 없으면 올바른 낙관적 UI 시스템을 구현하기가 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="3ab492bf401f85f1af3b44c3f0028684c11fe831" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Blaze.View&lt;/code&gt; is constructed by calling the constructor, no hooks are fired and no rendering is performed. In particular, the View is not yet considered to be &amp;ldquo;created.&amp;rdquo; Only when the View is actually used, by a call to &lt;code&gt;Blaze.render&lt;/code&gt; or &lt;code&gt;Blaze.toHTML&lt;/code&gt; or by inclusion in another View, is it &amp;ldquo;created,&amp;rdquo; right before it is rendered for the first time. When a View is created, its &lt;code&gt;.parentView&lt;/code&gt; is set if appropriate, and then the &lt;code&gt;onViewCreated&lt;/code&gt; hook is fired. The term &amp;ldquo;unrendered View&amp;rdquo; means a newly constructed View that has not been &amp;ldquo;created&amp;rdquo; or rendered.</source>
          <target state="translated">생성자를 호출하여 &lt;code&gt;Blaze.View&lt;/code&gt; 를 생성 하면 후크가 발생하지 않으며 렌더링이 수행되지 않습니다. 특히 뷰는 아직 &quot;만들어진&quot;것으로 간주되지 않습니다. &lt;code&gt;Blaze.render&lt;/code&gt; 또는 &lt;code&gt;Blaze.toHTML&lt;/code&gt; 을 호출 하거나 다른 View에 포함시켜 실제로 View를 사용하는 경우에만 처음으로 렌더링되기 직전에&amp;ldquo;만들어집니다&amp;rdquo;. 보기가 작성 되면 해당하는 경우 &lt;code&gt;.parentView&lt;/code&gt; 가 설정되고 &lt;code&gt;onViewCreated&lt;/code&gt; 후크가 실행됩니다. &quot;렌더링되지 않은 뷰&quot;라는 용어는 &quot;만들거나&quot;렌더링되지 않은 새로 구성된 뷰를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b643bcdc133f357c91b741fb04c842fa7c6cc282" translate="yes" xml:space="preserve">
          <source>When a Method call fails because the arguments are of the wrong type, it&amp;rsquo;s good to throw a &lt;code&gt;ValidationError&lt;/code&gt;. This works just like &lt;code&gt;Meteor.Error&lt;/code&gt;, but is a custom constructor that enforces a standard error format that can be read by different form and validation libraries. In particular, if you are calling this Method from a form, throwing a &lt;code&gt;ValidationError&lt;/code&gt; will make it easy to display nice error messages next to particular fields in the form.</source>
          <target state="translated">인수의 유형이 잘못되어 메소드 호출이 실패하면 &lt;code&gt;ValidationError&lt;/code&gt; 를 발생 시키는 것이 좋습니다 . 이것은 &lt;code&gt;Meteor.Error&lt;/code&gt; 와 똑같이 작동 하지만 다른 형식 및 유효성 검사 라이브러리에서 읽을 수있는 표준 오류 형식을 적용하는 사용자 지정 생성자입니다. 특히, 폼에서이 메서드를 호출하는 경우 &lt;code&gt;ValidationError&lt;/code&gt; 를 발생 시키면 폼의 특정 필드 옆에 멋진 오류 메시지를 쉽게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eac4758d2ad56c0b3a35a372dd96a644024d919" translate="yes" xml:space="preserve">
          <source>When a Method is called, it usually runs twice&amp;mdash;once on the client to simulate the result for Optimistic UI, and again on the server to make the actual change to the database. This means that if your Method throws an error, it will likely fail on the client &lt;em&gt;and&lt;/em&gt; the server. For this reason, &lt;code&gt;ValidatedMethod&lt;/code&gt; turns on undocumented option in Meteor to avoid calling the server-side implementation if the simulation throws an error.</source>
          <target state="translated">메소드가 호출되면 일반적으로 클라이언트에서 낙관적 UI의 결과를 시뮬레이트하기 위해 한 번, 서버에서 다시 데이터베이스를 실제로 변경하기 위해 두 번 실행됩니다. 즉, 메소드에 오류가 발생하면 클라이언트 &lt;em&gt;와&lt;/em&gt; 서버 에서 실패 할 가능성이 있습니다. 이러한 이유로 &lt;code&gt;ValidatedMethod&lt;/code&gt; 는 시뮬레이션에서 오류가 발생하는 경우 서버 측 구현을 호출하지 않도록 Meteor에서 문서화되지 않은 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f27358ca301a70e8e1ccb5fa9b7d2a60aa469862" translate="yes" xml:space="preserve">
          <source>When a client calls &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, or &lt;code&gt;remove&lt;/code&gt; on a collection, the collection&amp;rsquo;s &lt;code&gt;allow&lt;/code&gt; and &lt;a href=&quot;#deny&quot;&gt;&lt;code&gt;deny&lt;/code&gt;&lt;/a&gt; callbacks are called on the server to determine if the write should be allowed. If at least one &lt;code&gt;allow&lt;/code&gt; callback allows the write, and no &lt;code&gt;deny&lt;/code&gt; callbacks deny the write, then the write is allowed to proceed.</source>
          <target state="translated">클라이언트가 컬렉션에서 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 를 호출하면 쓰기 허용 여부를 결정하기 위해 서버 에서 컬렉션의 &lt;code&gt;allow&lt;/code&gt; 및 &lt;a href=&quot;#deny&quot;&gt; &lt;code&gt;deny&lt;/code&gt; &lt;/a&gt; 콜백이 호출됩니다. 적어도 하나의 경우 &lt;code&gt;allow&lt;/code&gt; 콜백 쓰기를 허용하고, 더는 &lt;code&gt;deny&lt;/code&gt; 콜백 쓰기를 거부하고 쓰기는 계속 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="56be403b018a89e0c484b891df47aaacd74309ca" translate="yes" xml:space="preserve">
          <source>When a client tries to write to a collection, the Meteor server first checks the collection&amp;rsquo;s &lt;code&gt;deny&lt;/code&gt; rules. If none of them return true then it checks the collection&amp;rsquo;s &lt;code&gt;allow&lt;/code&gt; rules. Meteor allows the write only if no &lt;code&gt;deny&lt;/code&gt; rules return &lt;code&gt;true&lt;/code&gt; and at least one &lt;code&gt;allow&lt;/code&gt; rule returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 컬렉션에 쓰려고 할 때 Meteor 서버는 먼저 컬렉션의 &lt;code&gt;deny&lt;/code&gt; 규칙을 확인합니다 . 둘 중 어느 것도 true를 반환하지 않으면 컬렉션의 &lt;code&gt;allow&lt;/code&gt; 규칙을 확인합니다 . Meteor는 &lt;code&gt;deny&lt;/code&gt; 규칙이 &lt;code&gt;true&lt;/code&gt; 를 리턴 하지 않고 하나 이상의 &lt;code&gt;allow&lt;/code&gt; 규칙이 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 경우에만 쓰기를 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="5f8b1f29683741b82952b614a02a61f2a2762e94" translate="yes" xml:space="preserve">
          <source>When a file represents a single class or UI component, the file should be named the same as the thing it defines, with the same capitalization. So if you have a file that exports a class:</source>
          <target state="translated">파일이 단일 클래스 또는 UI 구성 요소를 나타내는 경우 파일 이름은 대소 문자를 동일하게 정의하여 정의한 것과 동일하게 지정해야합니다. 따라서 클래스를 내보내는 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="3fc0dcffafb0edcd249b4653aefad9c49f2c13b3" translate="yes" xml:space="preserve">
          <source>When a login attempt is made, the registered validate login callbacks are called with a single argument, the attempt info object:</source>
          <target state="translated">로그인이 시도되면 등록 된 유효성 검사 로그인 콜백이 단일 인수, 시도 정보 객체로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5a7528a272a181b1ee878bbb86f45267fce4bfde" translate="yes" xml:space="preserve">
          <source>When a template is invoked as a block helper, it can use &lt;code&gt;{{&amp;gt;
Template.contentBlock}}&lt;/code&gt; and &lt;code&gt;{{&amp;gt; Template.elseBlock}}&lt;/code&gt; to include the block content it was passed.</source>
          <target state="translated">템플릿이 블록 도우미로 호출되면 &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; 및 &lt;code&gt;{{&amp;gt; Template.elseBlock}}&lt;/code&gt; 을 사용하여 전달 된 블록 컨텐츠를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e11c12f80a228b870e13b0f35420176ab42d353" translate="yes" xml:space="preserve">
          <source>When accessing a REST API, you will sometimes run into a situation where you make two requests one after the other, but the results arrive out of order. Meteor&amp;rsquo;s underlying machinery makes sure this never happens with Methods. When multiple Method calls are received &lt;em&gt;from the same client&lt;/em&gt;, Meteor runs each Method to completion before starting the next one. If you need to disable this functionality for one particularly long-running Method, you can use &lt;a href=&quot;http://docs.meteor.com/#/full/method_unblock&quot;&gt;&lt;code&gt;this.unblock()&lt;/code&gt;&lt;/a&gt; to allow the next Method to run while the current one is still in progress. Also, since Meteor is based on Websockets instead of HTTP, all Method calls and results are guaranteed to arrive in the order they are sent. You can also pass a special option &lt;code&gt;wait: true&lt;/code&gt; to &lt;code&gt;Meteor.apply&lt;/code&gt; to wait to send a particular Method until all others have returned, and not send any other Methods until this one returns.</source>
          <target state="translated">REST API에 액세스 할 때 때때로 두 개의 요청을 차례로 요청하지만 결과가 순서에 맞지 않는 상황이 발생할 수 있습니다. Meteor의 기본 기계는 이것이 Methods에서 발생하지 않도록합니다. &lt;em&gt;동일한 클라이언트에서&lt;/em&gt; 여러 메소드 호출이 수신 되면 Meteor는 다음 메소드를 시작하기 전에 각 메소드를 실행하여 완료합니다. 특히 오래 실행되는 하나의 메소드에 대해이 기능을 비활성화해야하는 경우 &lt;a href=&quot;http://docs.meteor.com/#/full/method_unblock&quot;&gt; &lt;code&gt;this.unblock()&lt;/code&gt; &lt;/a&gt; 을 사용하여 현재 메소드가 진행중인 동안 다음 메소드를 실행할 수 있습니다. 또한 Meteor는 HTTP 대신 Websocket을 기반으로하기 때문에 모든 메소드 호출 및 결과는 전송 된 순서대로 도착합니다. 특별한 옵션 인 &lt;code&gt;wait: true&lt;/code&gt; 전달할 수도 있습니다 : true to &lt;code&gt;Meteor.apply&lt;/code&gt; 다른 모든 메소드가 리턴 될 때까지 특정 메소드를 보내기 위해 대기하고이 메소드가 리턴 될 때까지 다른 메소드를 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cc1d86a3e890d7c741d73f68543dae5d85aa9eb3" translate="yes" xml:space="preserve">
          <source>When called from a reactive computation, &lt;code&gt;fetch&lt;/code&gt; registers dependencies on the matching documents.</source>
          <target state="translated">반응 형 계산에서 호출되면 &lt;code&gt;fetch&lt;/code&gt; 는 일치하는 문서에 대한 종속성을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="58e295144f4aaf2770409551c2ad80911987a55e" translate="yes" xml:space="preserve">
          <source>When called from a reactive computation, &lt;code&gt;forEach&lt;/code&gt; registers dependencies on the matching documents.</source>
          <target state="translated">반응 계산에서 호출되면 &lt;code&gt;forEach&lt;/code&gt; 는 일치하는 문서에 대한 종속성을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="6f02041312095e886de16679f31542a335300e54" translate="yes" xml:space="preserve">
          <source>When called from a reactive computation, &lt;code&gt;map&lt;/code&gt; registers dependencies on the matching documents.</source>
          <target state="translated">반응 형 계산에서 호출되면 &lt;code&gt;map&lt;/code&gt; 은 일치하는 문서에 대한 종속성을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="e9f539f9880266d2ecf565aad972822b36ddb602" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; Meteor will by default fetch the entire document &lt;code&gt;doc&lt;/code&gt; from the database. If you have large documents you may wish to fetch only the fields that are actually used by your functions. Accomplish this by setting &lt;code&gt;fetch&lt;/code&gt; to an array of field names to retrieve.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 를 호출하면 Meteor는 기본적으로 데이터베이스에서 전체 문서 &lt;code&gt;doc&lt;/code&gt; 를 가져옵니다 . 큰 문서가있는 경우 함수에서 실제로 사용하는 필드 만 가져 오려고 할 수 있습니다. 검색 할 필드 이름 배열로 &lt;code&gt;fetch&lt;/code&gt; 를 설정 하여이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b65295021601c6ad42cc39a2d2314775d836ef" translate="yes" xml:space="preserve">
          <source>When choosing a name for your npm package, be sure to follow the &lt;a href=&quot;https://docs.npmjs.com/files/package.json#name&quot;&gt;npm guidelines&lt;/a&gt;.</source>
          <target state="translated">npm 패키지의 이름을 선택할 때는 &lt;a href=&quot;https://docs.npmjs.com/files/package.json#name&quot;&gt;npm 지침&lt;/a&gt; 을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="cfa4e0f52e9f6b80996a3cf16bb74d5bb74947c4" translate="yes" xml:space="preserve">
          <source>When configuring OAuth login with a provider (such as Facebook or Google), Meteor lets you choose a popup- or redirect-based flow. In a popup-based flow, when a user logs in, they will be prompted to login at the provider in a popup window. In a redirect-based flow, the user&amp;rsquo;s whole browser window will be redirected to the login provider, and the window will redirect back to your app when the login is completed.</source>
          <target state="translated">제공자 (예 : Facebook 또는 Google)로 OAuth 로그인을 구성 할 때 Meteor를 사용하면 팝업 또는 리디렉션 기반 흐름을 선택할 수 있습니다. 팝업 기반 흐름에서 사용자가 로그인하면 팝업 창에서 공급자에게 로그인하라는 메시지가 표시됩니다. 리디렉션 기반 흐름에서 사용자의 전체 브라우저 창은 로그인 공급자로 리디렉션되고 로그인이 완료되면 창은 앱으로 다시 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="87f834418b0a161bdb589ea60fb5bd499786edd6" translate="yes" xml:space="preserve">
          <source>When creating a new application Meteor installs the &lt;code&gt;meteor-node-stubs&lt;/code&gt; npm package to help provide this client browser compatibility. If you are upgrading an application to Meteor 1.3 you may have to run &lt;code&gt;meteor npm install --save meteor-node-stubs&lt;/code&gt; manually.</source>
          <target state="translated">새 응용 프로그램을 만들 때 Meteor는 &lt;code&gt;meteor-node-stubs&lt;/code&gt; npm 패키지를 설치하여이 클라이언트 브라우저 호환성을 제공합니다. 애플리케이션을 Meteor 1.3으로 업그레이드하는 경우 &lt;code&gt;meteor npm install --save meteor-node-stubs&lt;/code&gt; 를 수동으로 실행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27641ba55976c03afe9ea728f7ce0b78ae1f8d99" translate="yes" xml:space="preserve">
          <source>When developing your application, Meteor starts a local MongoDB instance and automatically connects to it. In production, you must specify a &lt;code&gt;MONGO_URL&lt;/code&gt; environment variable pointing at your database in &lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string&quot;&gt;the standard mongo connection string format&lt;/a&gt;.</source>
          <target state="translated">애플리케이션을 개발할 때 Meteor는 로컬 MongoDB 인스턴스를 시작하고 자동으로 연결합니다. 프로덕션에서는 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string&quot;&gt;표준 몽고 연결 문자열 형식으로&lt;/a&gt; 데이터베이스를 가리키는 &lt;code&gt;MONGO_URL&lt;/code&gt; 환경 변수를 지정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="e30bfad33e2b2ae9c262f7db9b189a3554c310b1" translate="yes" xml:space="preserve">
          <source>When evaluating a path, identifiers after the first are used to index into the object so far, like JavaScript&amp;rsquo;s &lt;code&gt;.&lt;/code&gt;. However, an error is never thrown when trying to index into a non-object or an undefined value.</source>
          <target state="translated">경로를 평가할 때 첫 번째 이후의 식별자는 JavaScript와 같이 객체까지 색인하는 데 사용됩니다 &lt;code&gt;.&lt;/code&gt; . 그러나 객체가 아닌 값이나 정의되지 않은 값으로 색인을 생성 할 때 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="882ba392931740c858b2407f305d6e93fc1e7ea0" translate="yes" xml:space="preserve">
          <source>When finding users by email or username, make sure to use the case-insensitive functions provided by &lt;code&gt;accounts-password&lt;/code&gt;. See the &lt;a href=&quot;#case-sensitivity&quot;&gt;section about case-sensitivity&lt;/a&gt; for more details.</source>
          <target state="translated">이메일 또는 사용자 이름으로 사용자를 찾을 때는 &lt;code&gt;accounts-password&lt;/code&gt; 에서 제공하는 대소 문자를 구분하지 않는 기능을 사용해야 합니다 . 자세한 내용 &lt;a href=&quot;#case-sensitivity&quot;&gt;은 대소 문자 구분&lt;/a&gt; 에 관한 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e10ddd866bca5fc9cd97d0055b5eaf3bcb365a1e" translate="yes" xml:space="preserve">
          <source>When importing CSS from a JavaScript file, that CSS is not bundled with the rest of the CSS processed with the Meteor Build tool, but instead is put in your app&amp;rsquo;s &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag inside &lt;code&gt;&amp;lt;style&amp;gt;...&amp;lt;/style&amp;gt;&lt;/code&gt; after the main concatenated CSS file.</source>
          <target state="translated">JavaScript 파일에서 CSS를 가져올 때 해당 CSS는 Meteor Build 도구로 처리 된 나머지 CSS와 함께 번들로 제공되지 않고 대신 &lt;code&gt;&amp;lt;style&amp;gt;...&amp;lt;/style&amp;gt;&lt;/code&gt; 안에 앱의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 태그에 삽입됩니다 . 기본 연결된 CSS 파일.</target>
        </trans-unit>
        <trans-unit id="9ba272358ce62b3d533a6e65c536acbb17af37cc" translate="yes" xml:space="preserve">
          <source>When it is known which user was attempting to login, the Meteor user object. This will always be present for successful logins.</source>
          <target state="translated">어떤 사용자가 로그인을 시도했는지 알면 Meteor 사용자 개체입니다. 성공적인 로그인을 위해 항상 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6ebd83497c9cd8d312f13faa3d8a564f068765a4" translate="yes" xml:space="preserve">
          <source>When run in asynchronous mode, the callback receives two arguments, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; argument will contain an Error if the request fails in any way, including a network error, time-out, or an HTTP status code in the 400 or 500 range. In case of a 4xx/5xx HTTP status code, the &lt;code&gt;response&lt;/code&gt; property on &lt;code&gt;error&lt;/code&gt; matches the contents of the result object. When run in synchronous mode, either &lt;code&gt;result&lt;/code&gt; is returned from the function, or &lt;code&gt;error&lt;/code&gt; is thrown.</source>
          <target state="translated">비동기 모드에서 실행될 때 콜백은 &lt;code&gt;error&lt;/code&gt; 와 &lt;code&gt;result&lt;/code&gt; 의 두 가지 인수를받습니다 . &lt;code&gt;error&lt;/code&gt; 요청이 네트워크 오류, 타임 아웃, 또는 400 또는 500 범위의 HTTP 상태 코드를 포함, 어떤 방식으로 실패 할 경우 인수는 오류가 포함됩니다. 4xx / 5xx HTTP 상태 코드의 경우 &lt;code&gt;error&lt;/code&gt; 의 &lt;code&gt;response&lt;/code&gt; 특성 은 결과 오브젝트의 컨텐츠와 일치합니다. 동기 모드에서 실행될 때 &lt;code&gt;result&lt;/code&gt; 가 함수에서 리턴되거나 &lt;code&gt;error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4069c983e45cd40b231784c74934aa163775aa69" translate="yes" xml:space="preserve">
          <source>When running your bundled application in production mode, pass a string of JSON containing your settings with &lt;code&gt;METEOR_SETTINGS='{ &quot;server_only_setting&quot;: &quot;foo&quot;, &quot;public&quot;: { &quot;client_and_server_setting&quot;: &quot;bar&quot; } }'&lt;/code&gt;.</source>
          <target state="translated">번들 된 애플리케이션을 프로덕션 모드에서 실행할 때 &lt;code&gt;METEOR_SETTINGS='{ &quot;server_only_setting&quot;: &quot;foo&quot;, &quot;public&quot;: { &quot;client_and_server_setting&quot;: &quot;bar&quot; } }'&lt;/code&gt; 설정이 포함 된 JSON 문자열을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e027ab875d838258980cd654c7ec4b4e385b577" translate="yes" xml:space="preserve">
          <source>When selecting a hosted MongoDB service for production it is important to assess the features that the service provides. Below is a nonexhaustive list of features to consider when selecting a service:</source>
          <target state="translated">프로덕션을 위해 호스팅 된 MongoDB 서비스를 선택할 때 서비스가 제공하는 기능을 평가하는 것이 중요합니다. 다음은 서비스를 선택할 때 고려해야 할 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="492c2a03c639981f9d1af15676912f4ad0f5d4aa" translate="yes" xml:space="preserve">
          <source>When the argument to &lt;code&gt;#each&lt;/code&gt; changes, the DOM is always updated to reflect the new sequence, but it&amp;rsquo;s sometimes significant exactly how that is achieved. When the argument is a Meteor live cursor, the &lt;code&gt;#each&lt;/code&gt; has access to fine-grained updates to the sequence &amp;ndash; add, remove, move, and change callbacks &amp;ndash; and the items are all documents identified by unique ids. As long as the cursor itself remains constant (i.e. the query doesn&amp;rsquo;t change), it is very easy to reason about how the DOM will be updated as the contents of the cursor change. The rendered content for each document persists as long as the document is in the cursor, and when documents are re-ordered, the DOM is re-ordered.</source>
          <target state="translated">&lt;code&gt;#each&lt;/code&gt; 에 대한 인수가 변경되면 DOM은 항상 새로운 시퀀스를 반영하도록 업데이트되지만, 그것이 달성되는 방식과 정확히 일치하는 경우가 있습니다. 인수가 Meteor 라이브 커서 인 경우 &lt;code&gt;#each&lt;/code&gt; 는 콜백을 추가, 제거, 이동 및 변경하는 순서에 대한 세분화 된 업데이트에 액세스 할 수 있으며 항목은 모두 고유 한 ID로 식별되는 문서입니다. 커서 자체가 일정하게 유지되는 한 (즉, 쿼리가 변경되지 않는 한) 커서의 내용이 변경 될 때 DOM이 어떻게 업데이트되는지에 대한 이유를 쉽게 추론 할 수 있습니다. 각 문서에 대해 렌더링 된 컨텐츠는 문서가 커서에있는 한 지속되며 문서를 다시 정렬하면 DOM이 다시 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8fbb7af2f0221aafa1416badc1879abd3bc344ed" translate="yes" xml:space="preserve">
          <source>When the connection came in over an HTTP transport (such as with Meteor&amp;rsquo;s default SockJS implementation), this field contains whitelisted HTTP headers.</source>
          <target state="translated">연결이 HTTP 전송 (예 : Meteor의 기본 SockJS 구현)을 통해 제공된 경우이 필드에는 허용 된 HTTP 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8acdb696c1c490744ce20c0c102152308898e4a9" translate="yes" xml:space="preserve">
          <source>When the route is matched, the &lt;code&gt;action&lt;/code&gt; method executes, and you can perform any actions you need to. The &lt;code&gt;name&lt;/code&gt; property of the route is optional, but will let us refer to this route more conveniently later on.</source>
          <target state="translated">경로가 일치하면 &lt;code&gt;action&lt;/code&gt; 방법이 실행되고 필요한 작업을 수행 할 수 있습니다. 경로의 &lt;code&gt;name&lt;/code&gt; 속성은 선택 사항이지만 나중에이 경로를보다 편리하게 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8210de7978053be9a270f9aa7fe5907b39613d78" translate="yes" xml:space="preserve">
          <source>When the server receives the message, it executes the Method code again on the server. The client side version was a simulation that will be rolled back later, but this time it&amp;rsquo;s the real version that is writing to the actual database. Running the actual Method logic on the server is crucial because the server is a trusted environment where we know that security-critical code will run the way we expect.</source>
          <target state="translated">서버가 메시지를 받으면 서버에서 메소드 코드를 다시 실행합니다. 클라이언트 측 버전은 나중에 롤백되는 시뮬레이션 이었지만 이번에는 실제 데이터베이스에 쓰는 실제 버전입니다. 서버는 보안에 중요한 코드가 예상대로 실행된다는 것을 알고있는 신뢰할 수있는 환경이기 때문에 서버에서 실제 분석법 논리를 실행하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f7db065fe4a71159b3171ab13a66fdd9ec3d26f9" translate="yes" xml:space="preserve">
          <source>When the server was not able to complete the user&amp;rsquo;s desired action because of a known condition, you should throw a descriptive &lt;code&gt;Meteor.Error&lt;/code&gt; object to the client. In the Todos example app, we use these to report situations where the current user is not authorized to complete a certain action, or where the action is not allowed within the app - for example, deleting the last public list.</source>
          <target state="translated">서버가 알려진 조건으로 인해 사용자가 원하는 조치를 완료 할 수없는 경우 설명적인 &lt;code&gt;Meteor.Error&lt;/code&gt; 오브젝트를 클라이언트에 전달해야합니다. Todos 예제 앱에서는 현재 사용자에게 특정 작업을 완료 할 권한이 없거나 앱 내에서 작업이 허용되지 않는 상황 (예 : 마지막 공개 목록 삭제)을보고합니다.</target>
        </trans-unit>
        <trans-unit id="c48850747410c5cd72c5141a583d2b76dd92d83a" translate="yes" xml:space="preserve">
          <source>When the user receives the email and clicks the link inside, their web browser will take them to your app. Now, you need to be able to identify these special links and act appropriately. If you haven&amp;rsquo;t customized the link URL, then you can use some built-in callbacks to identify when the app is in the middle of an email flow.</source>
          <target state="translated">사용자가 이메일을 수신하고 내부 링크를 클릭하면 웹 브라우저가이를 사용자의 앱으로 가져갑니다. 이제 이러한 특수 링크를 식별하고 적절하게 행동 할 수 있어야합니다. 링크 URL을 사용자 정의하지 않은 경우 일부 내장 콜백을 사용하여 앱이 이메일 흐름의 중간에있을 때를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebc959d84e2f00c57251e00b09a3f3446960da1" translate="yes" xml:space="preserve">
          <source>When the user submits the form, you need to call the appropriate function to commit their change to the database. Each of these functions takes the new value and the token you got from the event in the previous step.</source>
          <target state="translated">사용자가 양식을 제출할 때 데이터베이스에 변경 사항을 커미트하려면 적절한 함수를 호출해야합니다. 이러한 각 기능은 이전 단계의 이벤트에서 얻은 새 값과 토큰을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dd0550e6771d8dd1264af2e577d690cdd386714d" translate="yes" xml:space="preserve">
          <source>When the user visits the link in this email, the callback registered with &lt;a href=&quot;#Accounts-onEmailVerificationLink&quot;&gt;&lt;code&gt;Accounts.onEmailVerificationLink&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">사용자가이 이메일의 링크를 방문하면 &lt;a href=&quot;#Accounts-onEmailVerificationLink&quot;&gt; &lt;code&gt;Accounts.onEmailVerificationLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3fe6b169f202a235d83bf081bf38e17e80961870" translate="yes" xml:space="preserve">
          <source>When the user visits the link in this email, the callback registered with &lt;a href=&quot;#Accounts-onEnrollmentLink&quot;&gt;&lt;code&gt;Accounts.onEnrollmentLink&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">사용자가이 이메일의 링크를 방문하면 &lt;a href=&quot;#Accounts-onEnrollmentLink&quot;&gt; &lt;code&gt;Accounts.onEnrollmentLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f9800212499cd4c2d741d3128152fb4fb34086" translate="yes" xml:space="preserve">
          <source>When the user visits the link in this email, the callback registered with &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt;&lt;code&gt;AccountsClient#onResetPasswordLink&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">사용자가이 이메일의 링크를 방문하면 &lt;a href=&quot;#Accounts-onResetPasswordLink&quot;&gt; &lt;code&gt;AccountsClient#onResetPasswordLink&lt;/code&gt; 에&lt;/a&gt; 등록 된 콜백 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cb509c883e02823449ddb0acf8ee526e4860d02e" translate="yes" xml:space="preserve">
          <source>When to use Atmosphere packages</source>
          <target state="translated">분위기 패키지를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="10cf50d586f68e33e97072be418db1f683520cb8" translate="yes" xml:space="preserve">
          <source>When to use npm packages</source>
          <target state="translated">npm 패키지를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="db85db92954475a7fc399432a4837ce50c526540" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;meteor run&lt;/code&gt;, server-side logs will be printed in the terminal as usual. In addition, running on an Android device or emulator will print a subset of the logs to that same terminal (these logs also include &lt;code&gt;console&lt;/code&gt; logging calls made from client-side code).</source>
          <target state="translated">&lt;code&gt;meteor run&lt;/code&gt; 을 사용하면 서버 측 로그가 평소와 같이 터미널에 인쇄됩니다. 또한 Android 디바이스 또는 에뮬레이터에서 실행하면 로그의 서브 세트를 동일한 터미널에 인쇄합니다 (이 로그에는 클라이언트 측 코드에서 작성된 &lt;code&gt;console&lt;/code&gt; 로깅 호출 도 포함됨 ).</target>
        </trans-unit>
        <trans-unit id="447ad09c0d1fdc3a32797ee25868519024416f2c" translate="yes" xml:space="preserve">
          <source>When using Flow Router, the simplest way to display different views on the page for different URLs is to use the complementary Blaze Layout package. First, make sure you have the Blaze Layout package installed:</source>
          <target state="translated">Flow Router를 사용할 때 다른 URL에 대해 페이지에 다른보기를 표시하는 가장 간단한 방법은 보완 Blaze Layout 패키지를 사용하는 것입니다. 먼저 Blaze Layout 패키지가 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2caa7f06023c191d78ffd7293a3abe576369f2d1" translate="yes" xml:space="preserve">
          <source>When using React Router in Meteor, you can follow roughly the &lt;a href=&quot;routing&quot;&gt;same principles&lt;/a&gt; as when using Flow Router, but you should also consider the idioms outlined in React Router&amp;rsquo;s own &lt;a href=&quot;https://github.com/ReactTraining/react-router&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">Meteor에서 React Router를 사용할 때 Flow Router를 사용할 때 &lt;a href=&quot;routing&quot;&gt;와&lt;/a&gt; 거의 동일한 원칙 을 따를 수 있지만 React Router 자체 &lt;a href=&quot;https://github.com/ReactTraining/react-router&quot;&gt;문서에&lt;/a&gt; 요약 된 관용구도 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ebf776e4e40a3817b024a4aac7bc6c6a3c060b26" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;oauth-encryption&lt;/code&gt; package, the 16 byte key using to encrypt sensitive account credentials in the database, encoded in base64. This option may only be specifed on the server. See packages/oauth-encryption/README.md for details.</source>
          <target state="translated">사용시 &lt;code&gt;oauth-encryption&lt;/code&gt; 패키지를 16 바이트 키 base64로 인코딩 데이터베이스에 민감한 계정 인증 정보를 암호화하는데 사용. 이 옵션은 서버에서만 지정할 수 있습니다. 자세한 내용은 packages / oauth-encryption / README.md를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9920294db4ac77a19f6718fbfede0bcf365fd961" translate="yes" xml:space="preserve">
          <source>When using the data in the sub-component, it&amp;rsquo;s a lot clearer what you are accessing; &lt;code&gt;{{todo.title}}&lt;/code&gt; is clearer than &lt;code&gt;{{title}}&lt;/code&gt;.</source>
          <target state="translated">하위 구성 요소에서 데이터를 사용할 때 액세스하는 것이 훨씬 명확합니다. &lt;code&gt;{{todo.title}}&lt;/code&gt; 이 &lt;code&gt;{{title}}&lt;/code&gt; 보다 명확 합니다.</target>
        </trans-unit>
        <trans-unit id="b6422a7af30f2af34e460106ecd1faa6548b81ec" translate="yes" xml:space="preserve">
          <source>When we connect to the test instance in a browser, we want to render a testing UI rather than our app UI, so the &lt;code&gt;mocha-web-reporter&lt;/code&gt; package will hide any UI of our application and overlay it with its own. However the app continues to behave as normal, so we are able to route around and check the correct data is loaded.</source>
          <target state="translated">브라우저에서 테스트 인스턴스에 연결할 때 앱 UI가 아닌 테스트 UI를 렌더링하려고하므로 &lt;code&gt;mocha-web-reporter&lt;/code&gt; 패키지는 애플리케이션의 UI를 숨기고 자체 UI로 오버레이합니다. 그러나 앱은 계속 정상적으로 작동하므로 라우팅하고 올바른 데이터가로드되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd82d12b6baa0c0a350e98ccef3e1e981c815c2" translate="yes" xml:space="preserve">
          <source>When we run our app in test mode, only our test files will be eagerly loaded. In particular, this means that in order to use our templates, we need to import them! In this test, we import &lt;code&gt;todos-item.js&lt;/code&gt;, which itself imports &lt;code&gt;todos.html&lt;/code&gt; (yes, you do need to import the HTML files of your Blaze templates!)</source>
          <target state="translated">테스트 모드에서 앱을 실행하면 테스트 파일 만 열심히로드됩니다. 특히 템플릿을 사용하려면 템플릿을 가져와야합니다. 이 테스트에서는 &lt;code&gt;todos-item.js&lt;/code&gt; 를 가져옵니다. &lt;code&gt;todos.html&lt;/code&gt; 자체를 가져 옵니다 (예, Blaze 템플릿의 HTML 파일을 가져와야합니다!)</target>
        </trans-unit>
        <trans-unit id="bb3f56c6bf039b669f547e48fd37ff5bf90e1987" translate="yes" xml:space="preserve">
          <source>When we subscribe to this publication on the client, we can provide this argument via the &lt;code&gt;Meteor.subscribe()&lt;/code&gt; call:</source>
          <target state="translated">클라이언트에서이 발행물을 구독하면 &lt;code&gt;Meteor.subscribe()&lt;/code&gt; 호출을 통해이 인수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95cd1d03e58d68d9f86955dfe1815fe2185dc62" translate="yes" xml:space="preserve">
          <source>When writing a package, CoffeeScript-defined variables can be exported like any other variable (see &lt;a href=&quot;../api/packagejs&quot;&gt;Package.js&lt;/a&gt;). Exporting a variable pulls it up to package scope, meaning that it will be visible to all of the code in your app or package (both &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.coffee&lt;/code&gt; files).</source>
          <target state="translated">패키지를 작성할 때 CoffeeScript 정의 변수는 다른 변수와 같이 내보낼 수 있습니다 ( &lt;a href=&quot;../api/packagejs&quot;&gt;Package.js&lt;/a&gt; 참조 ). 변수를 내 &lt;code&gt;.coffee&lt;/code&gt; 변수를 패키지 범위로 가져옵니다. 즉, 앱 또는 패키지의 모든 코드 ( &lt;code&gt;.js&lt;/code&gt; 및 .coffee 파일)에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aca05652e4e1ecf05f4402596047105617cd4ca3" translate="yes" xml:space="preserve">
          <source>When you add a type to EJSON, Meteor will be able to use that type in:</source>
          <target state="translated">EJSON에 유형을 추가하면 Meteor에서 다음 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b4c334a6d801637b4f898196fc3e2b6976be319" translate="yes" xml:space="preserve">
          <source>When you are developing a new npm package for your app, there are a couple methods for including the package in your app:</source>
          <target state="translated">앱을위한 새로운 npm 패키지를 개발할 때 앱에 패키지를 포함시키는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a935a965367d36d877014522bf6f55e86477f3" translate="yes" xml:space="preserve">
          <source>When you are running an app in production, it&amp;rsquo;s vitally important that you keep tabs on the performance of your application and ensure it is running smoothly.</source>
          <target state="translated">프로덕션 환경에서 앱을 실행할 때는 응용 프로그램의 성능에 대한 탭을 유지하고 원활하게 실행되도록하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f42b81db271dfd032a9fab7a5ff47683174f70ac" translate="yes" xml:space="preserve">
          <source>When you are running your app on multiple servers or containers, it&amp;rsquo;s not a good idea to shut down all of the servers at once and then start them all back up again. This will result in more downtime than necessary, and will cause a huge spike in CPU usage when all of your clients reconnect again at the same time. To alleviate this, Galaxy stops and re-starts containers one by one during deployment. There will be a time period during which some containers are running the old version and some the new version, as users are migrated incrementally to the new version of your app.</source>
          <target state="translated">여러 서버 또는 컨테이너에서 앱을 실행하는 경우 모든 서버를 한 번에 종료 한 다음 모두 다시 시작하는 것은 좋지 않습니다. 이로 인해 필요한 것보다 더 많은 다운 타임이 발생하고 모든 클라이언트가 동시에 다시 연결될 때 CPU 사용량이 급격히 증가합니다. 이를 완화하기 위해 Galaxy는 배포 중에 컨테이너를 하나씩 중지하고 다시 시작합니다. 사용자가 새 버전의 앱으로 점차 마이그레이션되므로 일부 컨테이너가 이전 버전과 일부 새 버전을 실행하는 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a4baba2cbc9c468159936fd9a8223205cd4c9fe" translate="yes" xml:space="preserve">
          <source>When you are setting up event maps in your JS files, you need to &amp;lsquo;select&amp;rsquo; the element in the template that the event attaches to. Rather than using the same CSS class names that are used to style the elements, it&amp;rsquo;s better practice to use classnames that are specifically added for those event maps. A reasonable convention is a class starting with &lt;code&gt;js-&lt;/code&gt; to indicate it is used by the JavaScript. For instance &lt;code&gt;.js-todo-add&lt;/code&gt; above.</source>
          <target state="translated">JS 파일에서 이벤트 맵을 설정하는 경우 이벤트가 첨부 된 템플리트에서 요소를 '선택'해야합니다. 요소의 스타일을 지정하는 데 사용되는 것과 동일한 CSS 클래스 이름을 사용하는 대신 해당 이벤트 맵에 특별히 추가 된 클래스 이름을 사용하는 것이 좋습니다. 합리적인 규칙은 &lt;code&gt;js-&lt;/code&gt; 로 시작 하여 JavaScript에서 사용됨을 나타내는 클래스 입니다. 예를 들어 &lt;code&gt;.js-todo-add&lt;/code&gt; 위.</target>
        </trans-unit>
        <trans-unit id="effe82c59d4faf6b5ea70030b1fa9c7eedadc2bf" translate="yes" xml:space="preserve">
          <source>When you call a Method, any errors thrown by it will be returned in the callback. At this point, you should identify which error type it is and display the appropriate message to the user. In this case, it is unlikely that the Method will throw a &lt;code&gt;ValidationError&lt;/code&gt; or an internal server error, so we will only handle the unauthorized error:</source>
          <target state="translated">메소드를 호출하면 메소드에 의해 발생 된 오류가 콜백에 리턴됩니다. 이때 오류 유형을 식별하고 적절한 메시지를 사용자에게 표시해야합니다. 이 경우 메소드가 &lt;code&gt;ValidationError&lt;/code&gt; 또는 내부 서버 오류를 발생 시킬 가능성이 없으므로 승인되지 않은 오류 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="075d7307f843533a02cf438e14f642882d9eef4b" translate="yes" xml:space="preserve">
          <source>When you create a collection on the server:</source>
          <target state="translated">서버에서 컬렉션을 만들 때 :</target>
        </trans-unit>
        <trans-unit id="3a2f52564d5b5f97fb1595e7f01037f0a1268735" translate="yes" xml:space="preserve">
          <source>When you deploy your Meteor server, you need a &lt;code&gt;MONGO_URL&lt;/code&gt; that points to your MongoDB database. You can either use a hosted MongoDB service or set up and run your own MongoDB server. We recommend using a hosted service, as the time saved and peace of mind are usually worth the higher monthly cost. In either case, the database should be hosted in the same region as the Meteor server (for lower latency). For example if your app is hosted on Galaxy in &lt;code&gt;us-east-1&lt;/code&gt; (on AWS), then you could create a database on &lt;a href=&quot;https://www.compose.io&quot;&gt;Compose&lt;/a&gt; in &lt;code&gt;AWS us-east-1&lt;/code&gt; or on &lt;a href=&quot;https://amazonlightsail.com/&quot;&gt;Amazon Lightsail&lt;/a&gt; in &lt;code&gt;us-east-1&lt;/code&gt;.</source>
          <target state="translated">Meteor 서버를 배포 할 때는 MongoDB 데이터베이스를 가리키는 &lt;code&gt;MONGO_URL&lt;/code&gt; 이 필요 합니다. 호스팅 된 MongoDB 서비스를 사용하거나 자체 MongoDB 서버를 설정하고 실행할 수 있습니다. 절약 된 시간과 마음의 평안은 일반적으로 더 높은 월 비용이 들기 때문에 호스팅 서비스를 사용하는 것이 좋습니다. 두 경우 모두 데이터베이스는 Meteor 서버와 동일한 리전에서 호스팅되어야합니다 (대기 시간 단축). 예를 들어 앱이 갤럭시에 호스팅되는 경우 &lt;code&gt;us-east-1&lt;/code&gt; (AWS에), 당신은에 데이터베이스를 만들 수 있습니다 &lt;a href=&quot;https://www.compose.io&quot;&gt;작성을&lt;/a&gt; 에 &lt;code&gt;AWS us-east-1&lt;/code&gt; 또는에 &lt;a href=&quot;https://amazonlightsail.com/&quot;&gt;아마존 Lightsail&lt;/a&gt; 에 &lt;code&gt;us-east-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e378e0f29233b9950fe4bbf47b108a785efccb3a" translate="yes" xml:space="preserve">
          <source>When you have a login system for your app based on user emails, that opens up the possibility for email-based account flows. The common thing between all of these workflows is that they involve sending a unique link to the user&amp;rsquo;s email address, which does something special when it is clicked. Let&amp;rsquo;s look at some common examples that Meteor&amp;rsquo;s &lt;code&gt;accounts-password&lt;/code&gt; package supports out of the box:</source>
          <target state="translated">사용자 이메일을 기반으로 앱에 대한 로그인 시스템을 사용하면 이메일 기반 계정 흐름이 가능합니다. 이러한 모든 워크 플로우 간의 공통점은 사용자의 이메일 주소에 대한 고유 한 링크를 전송하는 것입니다. 클릭하면 특별한 작업이 수행됩니다. Meteor의 &lt;code&gt;accounts-password&lt;/code&gt; 패키지가 기본적으로 지원하는 몇 가지 일반적인 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5429c6e3d582f717eeddd636edc9fea3e29e508a" translate="yes" xml:space="preserve">
          <source>When you have an error that doesn&amp;rsquo;t need to be reported to the client, but is internal to the server, throw a regular JavaScript error object. This will be reported to the client as a totally opaque internal server error with no details.</source>
          <target state="translated">클라이언트에보고 할 필요는 없지만 서버 내부에 오류가있는 경우 일반적인 JavaScript 오류 객체를 처리하십시오. 이것은 세부 사항없이 완전히 불투명 한 내부 서버 오류로 클라이언트에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3e447bb0be51e49d4dd5990564409fa5ec9ad4" translate="yes" xml:space="preserve">
          <source>When you insert documents into Minimongo from the client-side simulation of a Method, the &lt;code&gt;_id&lt;/code&gt; field of each document is a random string. When the Method call is executed on the server, the IDs are generated again before being inserted into the database. If it were implemented naively, it could mean that the IDs generated on the server are different, which would cause undesirable flickering and re-renders in the UI when the Method simulation was rolled back and replaced with the server data. But this is not the case in Meteor!</source>
          <target state="translated">메소드의 클라이언트 측 시뮬레이션에서 문서를 Minimongo에 삽입 할 때 각 문서 의 &lt;code&gt;_id&lt;/code&gt; 필드는 임의의 문자열입니다. 서버에서 메소드 호출이 실행되면 데이터베이스에 삽입되기 전에 ID가 다시 생성됩니다. 순진하게 구현 된 경우 서버에서 생성 된 ID가 다르기 때문에 메소드 시뮬레이션이 롤백되고 서버 데이터로 대체 될 때 UI에서 원하지 않는 깜박임 및 다시 렌더링이 발생할 수 있습니다. 그러나 이것은 Meteor의 경우가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="7d9263ed2bf4140536268b6c3e7022a85b39f5b7" translate="yes" xml:space="preserve">
          <source>When you render a template, the callbacks added with &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;onCreated&lt;/code&gt;&lt;/a&gt; are invoked immediately, before evaluating the content of the template. The callbacks added with &lt;a href=&quot;templates#Template-onRendered&quot;&gt;&lt;code&gt;onRendered&lt;/code&gt;&lt;/a&gt; are invoked after the View is rendered and inserted into the DOM.</source>
          <target state="translated">템플릿을 렌더링하면 템플릿 의 내용을 평가하기 전에 &lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;onCreated&lt;/code&gt; &lt;/a&gt; 로 추가 된 콜백 이 즉시 호출됩니다. &lt;a href=&quot;templates#Template-onRendered&quot;&gt; &lt;code&gt;onRendered&lt;/code&gt; &lt;/a&gt; 로 추가 된 콜백 은 View가 렌더링되고 DOM에 삽입 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63d91b96e4d54f69991586c52d485193e6bbc8b1" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;meteor&lt;/code&gt;, the tool starts up, and you should leave it running continuously while developing your app. The tool automatically detects any relevant file changes and recompiles the necessary changes, restarting your client or server environment if needed.</source>
          <target state="translated">&lt;code&gt;meteor&lt;/code&gt; 을 실행 하면 도구가 시작되므로 앱을 개발하는 동안 계속 실행해야합니다. 이 도구는 관련 파일 변경 사항을 자동으로 감지하고 필요한 변경 사항을 다시 컴파일하여 필요한 경우 클라이언트 또는 서버 환경을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="64bf9292535e3b8451e0fb5305e909f4e97ef965" translate="yes" xml:space="preserve">
          <source>When you run a &lt;code&gt;meteor test&lt;/code&gt; command, you must provide a &lt;code&gt;--driver-package&lt;/code&gt; argument. A test driver is a mini-application that runs in place of your app and runs each of your defined tests, whilst reporting the results in some kind of user interface.</source>
          <target state="translated">&lt;code&gt;meteor test&lt;/code&gt; 명령 을 실행할 때 &lt;code&gt;--driver-package&lt;/code&gt; 인수를 제공해야합니다 . 테스트 드라이버는 앱 대신 실행되고 정의 된 각 테스트를 실행하는 한편, 일종의 사용자 인터페이스로 결과를보고하는 미니 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="7e15c9215e768e8b1599afa9a242a231d9b85781" translate="yes" xml:space="preserve">
          <source>When you run this app, the &lt;code&gt;moment&lt;/code&gt; library will be imported on both the client and the server, and both consoles will log output similar to: &lt;code&gt;Today at 7:51 PM&lt;/code&gt;. Our hope is that the possibility of installing Node modules directly within an app will reduce the need for npm wrapper packages such as &lt;a href=&quot;https://atmospherejs.com/momentjs/moment&quot;&gt;https://atmospherejs.com/momentjs/moment&lt;/a&gt;.</source>
          <target state="translated">이 앱을 실행 하면 클라이언트와 서버 모두 에서 &lt;code&gt;moment&lt;/code&gt; 라이브러리를 가져오고 두 콘솔 모두 다음과 유사한 결과를 기록합니다. &lt;code&gt;Today at 7:51 PM&lt;/code&gt; . 앱 내에 직접 노드 모듈을 설치하면 &lt;a href=&quot;https://atmospherejs.com/momentjs/moment&quot;&gt;https://atmospherejs.com/momentjs/moment&lt;/a&gt; 와 같은 npm 래퍼 패키지의 필요성이 줄어들 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b750063f9a82be04c802b6c666fed345436303e4" translate="yes" xml:space="preserve">
          <source>When you subscribe to a record set, it tells the server to send records to the client. The client stores these records in local &lt;a href=&quot;#mongo_collection&quot;&gt;Minimongo collections&lt;/a&gt;, with the same name as the &lt;code&gt;collection&lt;/code&gt; argument used in the publish handler&amp;rsquo;s &lt;a href=&quot;#publish_added&quot;&gt;&lt;code&gt;added&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#publish_changed&quot;&gt;&lt;code&gt;changed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#publish_removed&quot;&gt;&lt;code&gt;removed&lt;/code&gt;&lt;/a&gt; callbacks. Meteor will queue incoming records until you declare the &lt;a href=&quot;#mongo_collection&quot;&gt;&lt;code&gt;Mongo.Collection&lt;/code&gt;&lt;/a&gt; on the client with the matching collection name.</source>
          <target state="translated">레코드 세트에 가입하면 서버가 클라이언트에 레코드를 보내도록 지시합니다. 클라이언트는 이러한 레코드를 로컬 &lt;a href=&quot;#mongo_collection&quot;&gt;Minimongo 컬렉션&lt;/a&gt; 에 저장 하며 게시 핸들러의 &lt;a href=&quot;#publish_added&quot;&gt; &lt;code&gt;added&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#publish_changed&quot;&gt; &lt;code&gt;changed&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#publish_removed&quot;&gt; &lt;code&gt;removed&lt;/code&gt; &lt;/a&gt; 콜백에 사용 된 &lt;code&gt;collection&lt;/code&gt; 인수 와 동일한 이름을 사용합니다 . Meteor는 클라이언트에서 일치하는 컬렉션 이름으로 &lt;a href=&quot;#mongo_collection&quot;&gt; &lt;code&gt;Mongo.Collection&lt;/code&gt; &lt;/a&gt; 을 선언 할 때까지 수신 레코드를 대기 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d9425b3b84e765f4cf9bc568175f5b6505bc2a81" translate="yes" xml:space="preserve">
          <source>When you subscribe to data in Meteor, it does not become instantly available on the client. Typically the user will need to wait for a few hundred milliseconds, or as long as a few seconds (depending on the connection speed), for the data to arrive. This is especially noticeable when the app is first starting up or you move between screens that are displaying completely new data.</source>
          <target state="translated">Meteor에서 데이터를 구독하면 클라이언트에서 해당 데이터를 즉시 사용할 수 없습니다. 일반적으로 사용자는 데이터가 도착하기 위해 수백 밀리 초 또는 연결 속도에 따라 몇 초 정도 기다려야합니다. 이는 앱이 처음 시작되거나 완전히 새로운 데이터를 표시하는 화면 사이를 이동할 때 특히 두드러집니다.</target>
        </trans-unit>
        <trans-unit id="9b6aadd05c8758e946dfc4c5a1ac49b4c8d09851" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;api.mainModule&lt;/code&gt;, the exports of the main module are exposed globally as &lt;code&gt;Package['my-modular-package']&lt;/code&gt;, along with any symbols exported by &lt;code&gt;api.export&lt;/code&gt;, and thus become available to any code that imports the package. In other words, the main module gets to decide what value of &lt;code&gt;Foo&lt;/code&gt; will be exported by &lt;code&gt;api.export&lt;/code&gt;, as well as providing other properties that can be explicitly imported from the package:</source>
          <target state="translated">&lt;code&gt;api.mainModule&lt;/code&gt; 을 사용 하면 기본 모듈의 내보내기가 &lt;code&gt;api.export&lt;/code&gt; 에서 내 보낸 기호와 함께 &lt;code&gt;Package['my-modular-package']&lt;/code&gt; 로 전체적으로 노출되므로 패키지 를 가져 오는 모든 코드에서 사용할 수 있습니다. 다시 말해, 메인 모듈은 &lt;code&gt;api.export&lt;/code&gt; 에 의해 &lt;code&gt;Foo&lt;/code&gt; 값을 내보낼 뿐만 아니라 패키지에서 명시 적으로 가져올 수있는 다른 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d6d3ff73d329befa7ea0114cfee7069682286880" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;mdg:validated-method&lt;/code&gt; with &lt;code&gt;aldeed:simple-schema&lt;/code&gt; as demonstrated above, this type of error is thrown for you.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;aldeed:simple-schema&lt;/code&gt; 와 함께 &lt;code&gt;mdg:validated-method&lt;/code&gt; 를 사용하면 이 유형의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb36f2c4e343f6bc6a8eb9498b2bd7152beb9fec" translate="yes" xml:space="preserve">
          <source>When you write a template as &lt;code&gt;&amp;lt;template name=&quot;foo&quot;&amp;gt; ... &amp;lt;/template&amp;gt;&lt;/code&gt; in an HTML file in your app, Meteor generates a &amp;ldquo;template object&amp;rdquo; named &lt;code&gt;Template.foo&lt;/code&gt;. Note that template name cannot contain hyphens and other special characters.</source>
          <target state="translated">앱의 HTML 파일에서 템플릿을 &lt;code&gt;&amp;lt;template name=&quot;foo&quot;&amp;gt; ... &amp;lt;/template&amp;gt;&lt;/code&gt; 으로 작성하면 Meteor는 &lt;code&gt;Template.foo&lt;/code&gt; 라는&amp;ldquo;템플릿 객체&amp;rdquo;를 생성합니다 . 템플릿 이름에는 하이픈과 기타 특수 문자가 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="844477ae54747e0c57dd9f37bba03e8419088085" translate="yes" xml:space="preserve">
          <source>When you write to the database on the client (&lt;a href=&quot;#insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#remove&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt;), the command is executed locally immediately, and, simultaneously, it&amp;rsquo;s sent to the server and executed there too. This happens via &lt;a href=&quot;#meteor_methods&quot;&gt;stubs&lt;/a&gt;, because writes are implemented as methods.</source>
          <target state="translated">클라이언트의 데이터베이스 ( &lt;a href=&quot;#insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#remove&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; ) 에 쓸 때 명령은 로컬에서 즉시 실행되며 동시에 서버로 전송되어 실행됩니다. 이것은 쓰기가 메소드로 구현되기 때문에 &lt;a href=&quot;#meteor_methods&quot;&gt;stubs&lt;/a&gt; 를 통해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e30d39386b8b030b289f7e5ecc23282b8048246d" translate="yes" xml:space="preserve">
          <source>When your app is run in test mode, it is initialized with a clean test database.</source>
          <target state="translated">앱이 테스트 모드에서 실행되면 깨끗한 테스트 데이터베이스로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="649b28c9fbe77cf6f86e691b286ea66818c0038d" translate="yes" xml:space="preserve">
          <source>When your package starts in test mode, rather than loading the &lt;code&gt;onUse&lt;/code&gt; block, Meteor loads the &lt;code&gt;onTest&lt;/code&gt; block:</source>
          <target state="translated">패키지가 &lt;code&gt;onUse&lt;/code&gt; 블록을 로드하지 않고 테스트 모드에서 시작하면 Meteor가 &lt;code&gt;onTest&lt;/code&gt; 를 로드합니다 블록을 .</target>
        </trans-unit>
        <trans-unit id="cda390f79e08ffb82360ffcae7aeb2a7d890946c" translate="yes" xml:space="preserve">
          <source>When, on the server, you write to a collection which has a specified &lt;code&gt;connection&lt;/code&gt; to another server, it sends the corresponding method to the other server and receives the changed values back from it over DDP. Unlike on the client, it does not execute the write locally first.</source>
          <target state="translated">서버에서 지정된 &lt;code&gt;connection&lt;/code&gt; 이있는 콜렉션에 쓸 때 다른 서버에 해당 메서드를 다른 서버로 보내고 DDP를 통해 변경된 값을 다시받습니다. 클라이언트와 달리 로컬에서 먼저 쓰기를 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3844a1398efe433ab3efe9372cc7cace53bae03" translate="yes" xml:space="preserve">
          <source>Where to store secret keys in development and production.</source>
          <target state="translated">개발 및 프로덕션에서 비밀 키를 저장할 위치</target>
        </trans-unit>
        <trans-unit id="c542b6c203cb13a4b0b0025a01d43cd78467d609" translate="yes" xml:space="preserve">
          <source>Where to subscribe on the client and in which templates.</source>
          <target state="translated">클라이언트에서 구독 할 위치 및 템플릿</target>
        </trans-unit>
        <trans-unit id="685ec8ab1ce73fc82fd8fe77efd7972951288ad9" translate="yes" xml:space="preserve">
          <source>Whether this login is allowed and will be successful (if not aborted by any of the validateLoginAttempt callbacks). False if the login will not succeed (for example, an invalid password or the login was aborted by a previous validateLoginAttempt callback).</source>
          <target state="translated">이 로그인이 허용되고 성공할지 여부 (validateLoginAttempt 콜백에 의해 중단되지 않은 경우) 로그인에 실패하면 (예 : 유효하지 않은 비밀번호 또는 이전 validateLoginAttempt 콜백에 의해 로그인이 중단 된 경우) False입니다.</target>
        </trans-unit>
        <trans-unit id="f0faaf49cc3d3da7633316ffa5af7fe5d0ac1847" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;#requestpermissions&quot;&gt;permissions&lt;/a&gt; to request from the user for each external service.</source>
          <target state="translated">어떤 &lt;a href=&quot;#requestpermissions&quot;&gt;권한을&lt;/a&gt; 각 외부 서비스에 대한 사용자의 요청에.</target>
        </trans-unit>
        <trans-unit id="5ec679ad7c4b83ccb85da84e8c8d841be2487999" translate="yes" xml:space="preserve">
          <source>Which fields to display in the user creation form. One of '&lt;code&gt;USERNAME_AND_EMAIL&lt;/code&gt;', '&lt;code&gt;USERNAME_AND_OPTIONAL_EMAIL&lt;/code&gt;', '&lt;code&gt;USERNAME_ONLY&lt;/code&gt;', or '&lt;code&gt;EMAIL_ONLY&lt;/code&gt;' (default).</source>
          <target state="translated">사용자 작성 양식에 표시 할 필드 ' &lt;code&gt;USERNAME_AND_EMAIL&lt;/code&gt; ', ' &lt;code&gt;USERNAME_AND_OPTIONAL_EMAIL&lt;/code&gt; ', ' &lt;code&gt;USERNAME_ONLY&lt;/code&gt; '또는 ' &lt;code&gt;EMAIL_ONLY&lt;/code&gt; '(기본값) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d73eb73aec594862bbf285f820336ad2d1337c61" translate="yes" xml:space="preserve">
          <source>Which port the app should listen on, for example: &lt;code&gt;PORT=3030&lt;/code&gt;</source>
          <target state="translated">앱이 수신해야하는 포트 (예 : &lt;code&gt;PORT=3030&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9380602b0bab772adf758776ce0f5c894e6be36a" translate="yes" xml:space="preserve">
          <source>Which style guide we recommend for JavaScript code</source>
          <target state="translated">JavaScript 코드에 권장되는 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="9accc8f889604a6fe19e76e94779c30b642fbe4d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;deny&lt;/code&gt; make it easy to get started building an app, it&amp;rsquo;s harder than it seems to write secure &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;deny&lt;/code&gt; rules. We recommend that developers avoid &lt;code&gt;allow&lt;/code&gt; and &lt;code&gt;deny&lt;/code&gt;, and switch directly to custom methods once they are ready to remove &lt;code&gt;insecure&lt;/code&gt; mode from their app. See &lt;a href=&quot;https://guide.meteor.com/security.html#allow-deny&quot;&gt;the Meteor Guide on security&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;allow&lt;/code&gt; 및 &lt;code&gt;deny&lt;/code&gt; 통해 앱을 쉽게 시작할 수 있지만 보안 &lt;code&gt;allow&lt;/code&gt; 및 &lt;code&gt;deny&lt;/code&gt; 규칙 을 작성하는 것보다 어렵습니다 . 개발자는 &lt;code&gt;allow&lt;/code&gt; 및 &lt;code&gt;deny&lt;/code&gt; 를 피하고 앱에서 &lt;code&gt;insecure&lt;/code&gt; 모드 를 제거 할 준비가되면 직접 사용자 정의 메소드로 전환 하는 것이 좋습니다 . 자세한 내용 &lt;a href=&quot;https://guide.meteor.com/security.html#allow-deny&quot;&gt;은 보안에&lt;/a&gt; 대한 Meteor 안내서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="274222bfd655a21cfd2ad10d479dd1d05213224a" translate="yes" xml:space="preserve">
          <source>While Meteor uses a built-in request interception mechanism on Android, supporting &lt;code&gt;WKWebView&lt;/code&gt; on iOS requires running a real embedded web server instead. That means the local web server needs a port to bind to, and we can&amp;rsquo;t simply use a fixed port because that might lead to conflicts when running multiple Meteor Cordova apps on the same device. The easiest solution may seem to use a randomized port, but this has a serious drawback: if the port changes each time you run the app, web features that depend on the origin (like caching, localStorage, IndexedDB) won&amp;rsquo;t persist between runs, and you also wouldn&amp;rsquo;t be able to specify a stable OAuth redirect URL. So instead we now pick a port from a predetermined range (12000-13000), calculated based on the &lt;code&gt;appId&lt;/code&gt;, a unique identifier that is part of every Meteor project. That ensures the same app will always use the same port, but it hopefully avoids collisions betweens apps as much as possible. (There is still a theoretical possibility of the selected port being in use. Currently, starting the local server will fail in that case.)</source>
          <target state="translated">Meteor는 Android에서 내장 된 요청 차단 메커니즘을 사용하지만 모든 Meteor 프로젝트의 일부인 고유 식별자 인 &lt;code&gt;WKWebView&lt;/code&gt; 를 iOS에서 를 하려면 실제 내장 웹 서버를 대신 실행해야합니다. 즉, 로컬 웹 서버에는 바인딩 할 포트가 필요하며 동일한 포트에서 여러 Meteor Cordova 앱을 실행할 때 충돌이 발생할 수 있으므로 고정 포트를 사용할 수 없습니다. 가장 쉬운 솔루션은 무작위 포트를 사용하는 것처럼 보이지만 심각한 단점이 있습니다. 앱을 실행할 때마다 포트가 변경되면 원본에 따라 달라지는 웹 기능 (캐싱, localStorage, IndexedDB 등)은 실행간에 유지되지 않습니다. 또한 안정적인 OAuth 리디렉션 URL을 지정할 수 없습니다. 대신 &lt;code&gt;appId&lt;/code&gt; 를 기반으로 계산 된 미리 결정된 범위 (12000-13000)에서 포트를 선택합니다. 지원 합니다. 따라서 동일한 앱이 항상 동일한 포트를 사용하지만 가능한 한 앱 간의 충돌을 피할 수 있기를 바랍니다. (선택된 포트가 사용 중일 가능성이 여전히 이론적으로 존재합니다. 현재 로컬 서버 시작은이 경우 실패합니다.)</target>
        </trans-unit>
        <trans-unit id="2de9826cb3a2523ab3b06a3a97256e623a505a34" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not necessarily important whether your code base uses single or double quotes for string literals, there are huge benefits to making that decision once and having it be consistent across your organization. These benefits also apply to the Meteor and JavaScript development communities as a whole.</source>
          <target state="translated">코드베이스가 문자열 리터럴에 작은 따옴표 나 큰 따옴표를 사용하는지 반드시 중요하지는 않지만 한 번 결정하고 조직 전체에서 일관성을 유지하면 큰 이점이 있습니다. 이러한 혜택은 Meteor 및 JavaScript 개발 커뮤니티에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7db46f60fa00aae0697520cc8b373796cd842008" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s optional and the basic functionality will work without it, it&amp;rsquo;s also a good idea to pick a router integration:</source>
          <target state="translated">선택 사항이며 기본 기능이 없으면 작동하지만 라우터 통합을 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1902b93c0a261071f41cb938ff4fddd869ca91f5" translate="yes" xml:space="preserve">
          <source>While most of the components in your app should be reusable, they need to get their data passed in from somewhere. This is where &amp;ldquo;smart&amp;rdquo; components come in. Such components typically do the following things:</source>
          <target state="translated">앱의 대부분의 구성 요소는 재사용 할 수 있어야하지만 데이터를 어딘가에서 전달해야합니다. 여기에 &quot;스마트&quot;구성 요소가 제공됩니다. 이러한 구성 요소는 일반적으로 다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d5d2526064b0becc82a0c00fbb4c9d47a012531a" translate="yes" xml:space="preserve">
          <source>While some packages exist just to provide side effects to the app, most packages provide a reusable bit of code that can be used by the consumer with &lt;code&gt;import&lt;/code&gt;. To export a symbol from your package, simply use the ES2015 &lt;code&gt;export&lt;/code&gt; syntax in your &lt;code&gt;mainModule&lt;/code&gt;:</source>
          <target state="translated">일부 패키지는 앱에 부작용을 제공하기 위해 존재하지만 대부분의 패키지는 소비자가 &lt;code&gt;import&lt;/code&gt; 와 함께 사용할 수있는 재사용 가능한 코드를 제공합니다 . 패키지에서 기호를 내보내려면 단순히 ES2015 사용 &lt;code&gt;export&lt;/code&gt; 당신의 구문을 &lt;code&gt;mainModule&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="084ba33c3d72a5c2e2c60387768e42e9c8ec756b" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;modules&lt;/code&gt; package is useful by itself, we very much encourage using the &lt;code&gt;ecmascript&lt;/code&gt; package (and thus &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;) instead of using &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; directly. If you need convincing, here&amp;rsquo;s a presentation that explains the differences: &lt;a href=&quot;http://benjamn.github.io/empirenode-2015&quot;&gt;http://benjamn.github.io/empirenode-2015&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 패키지는 그 자체로 유용 하지만 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;exports&lt;/code&gt; 를 직접 사용 하는 대신 &lt;code&gt;ecmascript&lt;/code&gt; 패키지를 사용하는 것이 좋습니다 (따라서 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; ) . 설득력이 필요한 경우 차이점을 설명하는 프레젠테이션이 있습니다. &lt;a href=&quot;http://benjamn.github.io/empirenode-2015&quot;&gt;http://benjamn.github.io/empirenode-2015&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c928041f7af9f9510ca49712bad641a9729806f3" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;modules&lt;/code&gt; package is useful by itself, we very much encourage using the &lt;code&gt;ecmascript&lt;/code&gt; package (and thus &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;) instead of using &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; directly. If you need convincing, here&amp;rsquo;s a presentation that explains the differences: &lt;a href=&quot;https://benjamn.github.io/empirenode-2015&quot;&gt;http://benjamn.github.io/empirenode-2015&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445d2277a61f8494c7b0d3e62400fa762c10ac8a" translate="yes" xml:space="preserve">
          <source>While the client-side code of your application is necessarily accessible by the browser, every application will have some secret code on the server that you don&amp;rsquo;t want to share with the world.</source>
          <target state="translated">브라우저에서 응용 프로그램의 클라이언트 쪽 코드에 액세스 할 수 있지만 모든 응용 프로그램은 서버와 공유하고 싶지 않은 비밀 코드가 서버에 있습니다.</target>
        </trans-unit>
        <trans-unit id="38fe9a4d0bc6b4111044e28548b07ff96c1a36a0" translate="yes" xml:space="preserve">
          <source>While this behavior is good for saving server resources in cases where a Method will certainly fail, it&amp;rsquo;s important to make sure that the simulation doesn&amp;rsquo;t throw an error in cases where the server Method would have succeeded (for example, if you didn&amp;rsquo;t load some data on the client that the Method needs to do the simulation properly). In this case, you can wrap server-side-only logic in a block that checks for a method simulation:</source>
          <target state="translated">이 동작은 메소드가 실패 할 경우 서버 자원을 절약하는 데 유용하지만 서버 메소드가 성공한 경우 (예 : 실패한 경우) 시뮬레이션에서 오류가 발생하지 않도록하는 것이 중요합니다. 메소드가 시뮬레이션을 올바르게 수행하는 데 필요한 일부 데이터를 클라이언트에로드하십시오. 이 경우 메소드 시뮬레이션을 확인하는 블록으로 서버 측 전용 로직을 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce6cc661b4ee7409838276e1cbb016385eb765f" translate="yes" xml:space="preserve">
          <source>While we recommend using ES2015 with the &lt;code&gt;ecmascript&lt;/code&gt; package as the best development experience for Meteor, everything in the platform is 100% compatible with &lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt; and many people in the Meteor community prefer it.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지 와 함께 ES2015 를 Meteor에 대한 최고의 개발 경험으로 사용하는 것이 좋지만 플랫폼의 모든 것은 &lt;a href=&quot;http://coffeescript.org/&quot;&gt;CoffeeScript&lt;/a&gt; 와 100 % 호환되며 Meteor 커뮤니티의 많은 사람들이 선호합니다.</target>
        </trans-unit>
        <trans-unit id="050af3a43f6c489ff4eceec775c37584c349289d" translate="yes" xml:space="preserve">
          <source>While you can easily use Methods in a simple app by following the Meteor introductory tutorial, it&amp;rsquo;s important to understand exactly how they work to use them effectively in a production app. One of the downsides of using a framework like Meteor that does a lot for you under the hood is that you don&amp;rsquo;t always understand what is going on, so it&amp;rsquo;s good to learn some of the core concepts.</source>
          <target state="translated">Meteor 입문 자습서를 따르면 간단한 앱에서 메서드를 쉽게 사용할 수 있지만 프로덕션 앱에서 메서드를 효과적으로 사용하려면 어떻게 작동하는지 정확하게 이해하는 것이 중요합니다. 후드 아래에서 당신을 위해 많은 것을하는 Meteor와 같은 프레임 워크를 사용하는 단점 중 하나는 진행중인 것을 항상 이해하지 못한다는 것입니다. 따라서 핵심 개념 중 일부를 배우는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4761c389a8dbeebd189831d04f1cbd6568091a24" translate="yes" xml:space="preserve">
          <source>Why it&amp;rsquo;s a good idea to have consistent code style</source>
          <target state="translated">일관된 코드 스타일을 갖는 것이 좋은 이유</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="48861b74369b2a39d8e8a84cecc4c61da61fd288" translate="yes" xml:space="preserve">
          <source>With Meteor, there is no need to install Cordova yourself, or use the &lt;code&gt;cordova&lt;/code&gt; command directly. Cordova project creation happens as part of the Meteor run and build commands, and the project itself is considered a build artifact (stored in &lt;code&gt;.meteor/local/cordova-build&lt;/code&gt; in your app directory) that can be deleted and recreated at any time. Instead of having you modify Cordova&amp;rsquo;s &lt;code&gt;config.xml&lt;/code&gt; file, Meteor reads a &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;&lt;code&gt;mobile-config.js&lt;/code&gt;&lt;/a&gt; file in the root of your app directory and uses the settings specified there to configure the generated project.</source>
          <target state="translated">Meteor를 사용하면 Cordova를 직접 설치하거나 &lt;code&gt;cordova&lt;/code&gt; 명령을 직접 사용할 필요가 없습니다 . Cordova 프로젝트 작성은 Meteor 실행 및 빌드 명령의 일부로 발생하며 프로젝트 자체는 언제든지 삭제하고 다시 작성할 수 있는 빌드 아티팩트로 간주됩니다 ( 앱 디렉토리의 &lt;code&gt;.meteor/local/cordova-build&lt;/code&gt; 에 저장 됨 ). Meteor는 Cordova의 &lt;code&gt;config.xml&lt;/code&gt; 파일 을 수정하지 않고 앱 디렉토리의 루트에서 &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt; &lt;code&gt;mobile-config.js&lt;/code&gt; &lt;/a&gt; 파일을 읽고 지정된 설정을 사용하여 생성 된 프로젝트를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="279d87e0ddbf5918498e3a648de58010464aea6c" translate="yes" xml:space="preserve">
          <source>With React Router, you&amp;rsquo;ll also need to explicity render the exported routes in a startup function:</source>
          <target state="translated">React Router를 사용하면 시작된 함수에서 내 보낸 경로를 명시 적으로 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="78ad02171a0a0b0e09d465faed8a9ed86b70efac" translate="yes" xml:space="preserve">
          <source>With one exception, it is not possible to mix inclusion and exclusion styles: the keys must either be all 1 or all 0. The exception is that you may specify &lt;code&gt;_id: 0&lt;/code&gt; in an inclusion specifier, which will leave &lt;code&gt;_id&lt;/code&gt; out of the result object as well. However, such field specifiers can not be used with &lt;a href=&quot;#observe_changes&quot;&gt;&lt;code&gt;observeChanges&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#observe&quot;&gt;&lt;code&gt;observe&lt;/code&gt;&lt;/a&gt;, cursors returned from a &lt;a href=&quot;#meteor_publish&quot;&gt;publish function&lt;/a&gt;, or cursors used in &lt;code&gt;{{#each}}&lt;/code&gt; in a template. They may be used with &lt;a href=&quot;#fetch&quot;&gt;&lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#findone&quot;&gt;&lt;code&gt;findOne&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#foreach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">한 가지 예외를 제외하면 포함 및 제외 스타일을 혼합 할 수는 없습니다. 키는 모두 1 또는 0이어야합니다. 예외는 포함 지정자에 &lt;code&gt;_id: 0&lt;/code&gt; 을 지정할 수 있으며 결과 객체에서 &lt;code&gt;_id&lt;/code&gt; 를 제외합니다. 게다가. 그러나 이러한 필드 지정 &lt;a href=&quot;#observe_changes&quot;&gt; &lt;code&gt;observeChanges&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#observe&quot;&gt; &lt;code&gt;observe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#meteor_publish&quot;&gt;publish 함수&lt;/a&gt; 에서 리턴 된 커서 또는 템플리트의 &lt;code&gt;{{#each}}&lt;/code&gt; 에 사용 된 커서 와 함께 사용할 수 없습니다 . &lt;a href=&quot;#fetch&quot;&gt; &lt;code&gt;fetch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#findone&quot;&gt; &lt;code&gt;findOne&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#foreach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 과 함께 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02148a75389c5623f51749325849a59f81199b42" translate="yes" xml:space="preserve">
          <source>With that said, in some situations you may need to call out to &lt;code&gt;require&lt;/code&gt; directly. One notable example is when requiring client or server-only code from a common file. As &lt;code&gt;import&lt;/code&gt;s must be at the top-level scope, you may not place them within an &lt;code&gt;if&lt;/code&gt; statement, so you&amp;rsquo;ll need to write code like:</source>
          <target state="translated">그렇게 말하면 어떤 상황 &lt;code&gt;require&lt;/code&gt; 직접 요구 하기 위해 불러야 할 수도 있습니다. 한 가지 주목할만한 예는 공통 파일에서 클라이언트 또는 서버 전용 코드가 필요한 경우입니다. 으로 &lt;code&gt;import&lt;/code&gt; 의 최상위 범위에 있어야합니다, 당신은 내을 배치하지 않을 &lt;code&gt;if&lt;/code&gt; 이 같은 코드를 작성해야합니다, 그래서 문 :</target>
        </trans-unit>
        <trans-unit id="888670c17dd555fac3d6da2eba246828fe64c7bc" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;less&lt;/code&gt; package installed, &lt;code&gt;.less&lt;/code&gt; files in your application are automatically compiled to CSS and the results are included in the client CSS bundle.</source>
          <target state="translated">으로 &lt;code&gt;less&lt;/code&gt; 패키지가 설치, &lt;code&gt;.less&lt;/code&gt; 응용 프로그램에서 파일이 자동으로 CSS로 컴파일하고 결과는 클라이언트 CSS 번들에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0235c8e9ddd6a614d1c7ada5608743610aa8aa76" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;imports/api&lt;/code&gt; directory, it&amp;rsquo;s sensible to split the code into directories based on the domain that the code is providing an API for &amp;mdash; typically this corresponds to the collections you&amp;rsquo;ve defined in your app. For instance in the Todos example app, we have the &lt;code&gt;imports/api/lists&lt;/code&gt; and &lt;code&gt;imports/api/todos&lt;/code&gt; domains. Inside each directory we define the collections, publications and methods used to manipulate the relevant domain data.</source>
          <target state="translated">&lt;code&gt;imports/api&lt;/code&gt; 디렉토리 내에서 코드가 API를 제공하는 도메인을 기반으로 코드를 디렉토리로 분할하는 것이 합리적입니다. 일반적으로 이는 앱에서 정의한 컬렉션에 해당합니다. 예를 들어 Todos 예제 앱에는 &lt;code&gt;imports/api/lists&lt;/code&gt; 및 &lt;code&gt;imports/api/todos&lt;/code&gt; 도메인이 있습니다. 각 디렉토리 내에서 관련 도메인 데이터를 조작하는 데 사용되는 모음, 출판물 및 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e5ca916316fecdfdcd09e7a02ea04536b16cb7a7" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;imports/ui&lt;/code&gt; directory it typically makes sense to group files into directories based on the type of UI side code they define, i.e. top level &lt;code&gt;pages&lt;/code&gt;, wrapping &lt;code&gt;layouts&lt;/code&gt;, or reusable &lt;code&gt;components&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;imports/ui&lt;/code&gt; 디렉토리 내에서는 일반적으로 파일이 정의한 UI 측 코드 유형 (예 : 최상위 &lt;code&gt;pages&lt;/code&gt; , 배치 &lt;code&gt;layouts&lt;/code&gt; 또는 재사용 가능한 &lt;code&gt;components&lt;/code&gt; 에 따라 파일을 디렉토리로 그룹화하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1a55595583f082ec27a6cd967c6cc4c9ea851fef" translate="yes" xml:space="preserve">
          <source>Working with REST APIs</source>
          <target state="translated">REST API 작업</target>
        </trans-unit>
        <trans-unit id="463cb6e65401ee33feefb1ca2a58091e4140b4aa" translate="yes" xml:space="preserve">
          <source>Wrap a function that takes a callback function as its final parameter. The signature of the callback of the wrapped function should be &lt;code&gt;function(error, result){}&lt;/code&gt;. On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback. If a callback is provided, the environment captured when the original function was called will be restored in the callback.</source>
          <target state="translated">콜백 함수를 최종 매개 변수로 사용하는 함수를 래핑하십시오. 랩핑 된 함수의 콜백 시그니처는 &lt;code&gt;function(error, result){}&lt;/code&gt; 이어야합니다 . 서버에서 랩핑 된 함수는 동 기적으로 (콜백을 전달하지 않고) 또는 비동기 적으로 (콜백을 전달할 때) 사용할 수 있습니다. 클라이언트에서는 항상 콜백이 필요합니다. 콜백이 없으면 오류가 기록됩니다. 콜백이 제공되면 원래 함수가 호출 될 때 캡처 된 환경이 콜백에 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="fbadab8600072e37a4780b4a78f0ec308c818630" translate="yes" xml:space="preserve">
          <source>Writing Atmosphere Packages</source>
          <target state="translated">분위기 패키지 작성</target>
        </trans-unit>
        <trans-unit id="682e327d7d036c873125604e373874ab72bb17c8" translate="yes" xml:space="preserve">
          <source>Writing a build plugin is a very advanced task that only the most advanced Meteor users should get into. The best place to start is to copy a different plugin that is the most similar to what you are trying to do. For example, if you wanted to make a new CSS compiler plugin, you could fork the &lt;code&gt;less&lt;/code&gt; package; if you wanted to make your own JS transpiler, you could fork &lt;code&gt;ecmascript&lt;/code&gt;. A good example of a linter is the &lt;code&gt;jshint&lt;/code&gt; package, and for a minifier you can look at &lt;code&gt;standard-minifiers-js&lt;/code&gt; and &lt;code&gt;standard-minifiers-css&lt;/code&gt;.</source>
          <target state="translated">빌드 플러그인 작성은 최첨단 Meteor 사용자 만 사용해야하는 고급 작업입니다. 시작하기 가장 좋은 곳은 수행하려는 작업과 가장 유사한 다른 플러그인을 복사하는 것입니다. 예를 들어, 새로운 CSS 컴파일러 플러그인을 만들고 싶다면 &lt;code&gt;less&lt;/code&gt; 패키지를 사용할 수 있습니다. 당신이 당신의 자신의 JS의 transpiler을하기를 원한다면, 당신은 포크 수 &lt;code&gt;ecmascript&lt;/code&gt; . 린터의 좋은 예는 &lt;code&gt;jshint&lt;/code&gt; 패키지이며 축소 기의 경우 &lt;code&gt;standard-minifiers-js&lt;/code&gt; 및 &lt;code&gt;standard-minifiers-css&lt;/code&gt; 를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a210f4b0062ab70f663ab7b33754f4f1e9cc07" translate="yes" xml:space="preserve">
          <source>Writing migrations</source>
          <target state="translated">마이그레이션 작성</target>
        </trans-unit>
        <trans-unit id="67d8eb5b83423e4c01ef5397e89bf9279b547e64" translate="yes" xml:space="preserve">
          <source>Writing npm Packages</source>
          <target state="translated">npm 패키지 작성</target>
        </trans-unit>
        <trans-unit id="0c5db175e86f27dd0d1bd5d4fe69519e4f6064af" translate="yes" xml:space="preserve">
          <source>Writing smart components with Blaze</source>
          <target state="translated">Blaze로 스마트 컴포넌트 작성</target>
        </trans-unit>
        <trans-unit id="dd28e043c6cb6a21402fa517b7192cb5a4a63908" translate="yes" xml:space="preserve">
          <source>Writing your own build plugin</source>
          <target state="translated">자신 만의 빌드 플러그인 작성</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="f0b30ebb13a341d741a1ad7680ddade64cb2fa6b" translate="yes" xml:space="preserve">
          <source>Xcode builds the app, installs it on the device, and launches it.</source>
          <target state="translated">Xcode는 앱을 빌드하고 장치에 설치 한 다음 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f12898521ccd045820f9f088b5338da1a95ec276" translate="yes" xml:space="preserve">
          <source>Yes, Meteor does hash your password or login token on the client before sending it over the wire, but that only prevents an attacker from figuring out your password - it doesn&amp;rsquo;t prevent them from logging in as you, since they could just send the hashed password to the server to log in! No matter how you slice it, logging in requires the client to send sensitive data to the server, and the only way to secure that transfer is by using SSL. Note that the same issue is present when using cookies for authentication in a normal HTTP web application, so any app that needs to reliably identify users should be running on SSL.</source>
          <target state="translated">예, Meteor는 유선으로 전송하기 전에 클라이언트에서 비밀번호 또는 로그인 토큰을 해시하지만 공격자가 비밀번호를 알아내는 것을 방지 할뿐입니다. 서버에 해시 된 비밀번호로 로그인하십시오! 슬라이스 방법에 관계없이 로그인하려면 클라이언트가 중요한 데이터를 서버로 보내야하며, 전송을 보호하는 유일한 방법은 SSL을 사용하는 것입니다. 일반 HTTP 웹 응용 프로그램에서 인증을 위해 쿠키를 사용할 때도 동일한 문제가 발생하므로 사용자를 안정적으로 식별해야하는 모든 응용 프로그램은 SSL에서 실행되고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f076b03a152a910a713055344401278fd44f1192" translate="yes" xml:space="preserve">
          <source>You &amp;ldquo;include&amp;rdquo; a sub-component with the &lt;code&gt;{{&amp;gt; }}&lt;/code&gt; syntax. By default, the sub-component will gain the data context of the caller, although it&amp;rsquo;s usually a good idea to be explicit. You can provide a single object which will become the entire data context (as we did with the object returned by the &lt;code&gt;todoArgs&lt;/code&gt; helper above), or provide a list of keyword arguments which will be put together into one object, like so:</source>
          <target state="translated">&lt;code&gt;{{&amp;gt; }}&lt;/code&gt; 구문 으로 하위 구성 요소를 &quot;포함&quot; 합니다. 기본적으로 하위 구성 요소는 호출자의 데이터 컨텍스트를 가져 오지만 일반적으로 명시적인 것이 좋습니다. 전체 데이터 컨텍스트가 될 단일 객체를 제공하거나 (위 의 &lt;code&gt;todoArgs&lt;/code&gt; 헬퍼가 리턴 한 객체와 마찬가지로) 다음과 같이 하나의 객체에 결합 할 키워드 인수 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b90deaca0ef701768f16f25209af315869bc5d5a" translate="yes" xml:space="preserve">
          <source>You are creating a collection within MongoDB, and an interface to that collection to be used on the server. It&amp;rsquo;s a fairly straightforward layer on top of the underlying Node MongoDB driver, but with a synchronous API:</source>
          <target state="translated">MongoDB 내에서 콜렉션을 작성하고 서버에서 사용할 해당 콜렉션에 대한 인터페이스를 작성합니다. 기본 Node MongoDB 드라이버 위에는 매우 간단한 계층이지만 동기식 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be27b62d3961acc7a6cd24129ef110f528fef299" translate="yes" xml:space="preserve">
          <source>You call it the same way you call the advanced Method above, but the Method definition is significantly simpler. We believe this style of Method lets you clearly see the important parts - the name of the Method sent over the wire, the format of the expected arguments, and the JavaScript namespace by which the Method can be referenced. Validated methods only accept a single argument and a callback function.</source>
          <target state="translated">위의 고급 메소드를 호출하는 것과 같은 방식으로 호출하지만 메소드 정의가 훨씬 간단합니다. 이러한 스타일의 메소드를 사용하면 중요한 부분, 즉 유선으로 전송 된 메소드의 이름, 예상 인수의 형식 및 메소드를 참조 할 수있는 JavaScript 네임 스페이스를 명확하게 볼 수 있습니다. 검증 된 메소드는 단일 인수와 콜백 함수 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a35763ae89deeee3538169e6f8edd2fab5a390f1" translate="yes" xml:space="preserve">
          <source>You can add Cordova plugins to your project either directly, or as a dependency of a Meteor package.</source>
          <target state="translated">Cordova 플러그인을 프로젝트에 직접 추가하거나 Meteor 패키지의 종속성으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb166ada98fada3a6ab9f0cf1a163f7b421ea333" translate="yes" xml:space="preserve">
          <source>You can add information specific to a particular deployment of your application by using the &lt;code&gt;--settings&lt;/code&gt; option. The argument to &lt;code&gt;--settings&lt;/code&gt; is a file containing any JSON string. The object in your settings file will appear on the server side of your application in &lt;a href=&quot;#meteor_settings&quot;&gt;&lt;code&gt;Meteor.settings&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--settings&lt;/code&gt; 옵션 을 사용하여 특정 응용 프로그램 배포와 관련된 정보를 추가 할 수 있습니다 . &lt;code&gt;--settings&lt;/code&gt; 에 대한 인수 는 JSON 문자열을 포함하는 파일입니다. 설정 파일의 개체는 &lt;a href=&quot;#meteor_settings&quot;&gt; &lt;code&gt;Meteor.settings&lt;/code&gt; &lt;/a&gt; 의 응용 프로그램 서버쪽에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9b2782964809756050678023f65eea3fd7ace175" translate="yes" xml:space="preserve">
          <source>You can add the Crosswalk plugin to your app with &lt;code&gt;meteor add crosswalk&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;meteor add crosswalk&lt;/code&gt; 를 사용하여 앱에 Crosswalk 플러그인을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b85c023f8b0658958d03f07ac969ba3039532cee" translate="yes" xml:space="preserve">
          <source>You can allow different teams at your organization to work on the different applications independently.</source>
          <target state="translated">조직의 다른 팀이 다른 응용 프로그램에서 독립적으로 작업하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="247cffea5b43b8414001541dffd25090106f85a3" translate="yes" xml:space="preserve">
          <source>You can also access authenticated publications (such as &lt;code&gt;lists.private&lt;/code&gt;). Suppose we&amp;rsquo;ve signed up (via the web UI) as &lt;code&gt;user@example.com&lt;/code&gt;, with the password &lt;code&gt;password&lt;/code&gt;, and created a private list. Then we can access it as follows:</source>
          <target state="translated">인증 된 발행물 (예 : &lt;code&gt;lists.private&lt;/code&gt; )에 액세스 할 수도 있습니다 . 비밀번호가 &lt;code&gt;password&lt;/code&gt; 인 &lt;code&gt;user@example.com&lt;/code&gt; 으로 웹 UI를 통해 등록 하고 개인 목록을 생성 했다고 가정 합니다. 그런 다음 다음과 같이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d44a4238826b91db16ad530c52f74b0cd87286" translate="yes" xml:space="preserve">
          <source>You can also add a &lt;code&gt;eslintConfig&lt;/code&gt; section to your &lt;code&gt;package.json&lt;/code&gt; to specify that you&amp;rsquo;d like to use the Airbnb config, and to enable &lt;a href=&quot;https://github.com/dferber90/eslint-plugin-meteor&quot;&gt;ESLint-plugin-Meteor&lt;/a&gt;. You can also setup any extra rules you want to change, as well as adding a lint npm command:</source>
          <target state="translated">&lt;code&gt;eslintConfig&lt;/code&gt; 섹션을 &lt;code&gt;package.json&lt;/code&gt; 에 추가 하여 Airbnb 구성을 사용하도록 지정하고 &lt;a href=&quot;https://github.com/dferber90/eslint-plugin-meteor&quot;&gt;ESLint-plugin-Meteor&lt;/a&gt; 를 활성화 할 수도 있습니다. lint npm 명령을 추가 할뿐만 아니라 변경하려는 추가 규칙을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="938eb70c71a7246257e05ba047445913de769e60" translate="yes" xml:space="preserve">
          <source>You can also add any source file that would be compiled to a JS file (such as a CoffeeScript file) in a similar way, assuming you &lt;a href=&quot;#dependencies&quot;&gt;depend&lt;/a&gt; on an appropriate build plugin.</source>
          <target state="translated">적절한 빌드 플러그인에 &lt;a href=&quot;#dependencies&quot;&gt;의존&lt;/a&gt; 한다고 가정하면 유사한 방식으로 JS 파일 (예 : CoffeeScript 파일)에 컴파일 될 소스 파일을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="207367ccef744450937729110472f3b5a5c4bbd6" translate="yes" xml:space="preserve">
          <source>You can also change only part of the URL if you want to, using the &lt;code&gt;FlowRouter.setParams()&lt;/code&gt; and &lt;code&gt;FlowRouter.setQueryParams()&lt;/code&gt;. For instance, if we were viewing one list and wanted to go to another, we could write:</source>
          <target state="translated">원하는 경우 &lt;code&gt;FlowRouter.setParams()&lt;/code&gt; 및 &lt;code&gt;FlowRouter.setQueryParams()&lt;/code&gt; 사용하여 URL의 일부만 변경할 수도 있습니다 . 예를 들어, 한 목록을보고 다른 목록으로 가고 싶다면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a6add1c3ff370e5a611f819b812a945a44b50f" translate="yes" xml:space="preserve">
          <source>You can also import CSS directly from a JavaScript file to control load order if you have the &lt;code&gt;ecmascript&lt;/code&gt; package installed:</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지가 설치된 경우 JavaScript 파일에서 CSS를 직접 가져 와서로드 순서를 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f5167c9831c495628d994dede0a720b9c76fd97" translate="yes" xml:space="preserve">
          <source>You can also import CSS from a JavaScript file if you have the &lt;code&gt;ecmascript&lt;/code&gt; package installed:</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지가 설치된 경우 JavaScript 파일에서 CSS를 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9fca25291bcef9d8bce2cfc18822749de67e9f" translate="yes" xml:space="preserve">
          <source>You can also import other files or JS entry points from a package:</source>
          <target state="translated">패키지에서 다른 파일 또는 JS 진입 점을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aff4aafc57685ef38f27de719f338d5b0b10183" translate="yes" xml:space="preserve">
          <source>You can also import specific functions from a package using the destructuring syntax:</source>
          <target state="translated">파괴 구문을 사용하여 패키지에서 특정 함수를 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa3e246284b66255d672bd1fff87fab5ee4aa809" translate="yes" xml:space="preserve">
          <source>You can also log into the Galaxy UI at &lt;a href=&quot;https://galaxy.meteor.com&quot;&gt;https://galaxy.meteor.com&lt;/a&gt;. Once there you can manage your applications, monitor the number of connections and resource usage, view logs, and change settings.</source>
          <target state="translated">&lt;a href=&quot;https://galaxy.meteor.com&quot;&gt;https://galaxy.meteor.com&lt;/a&gt; 에서 Galaxy UI에 로그인 할 수도 있습니다 . 일단 응용 프로그램을 관리하고 연결 수와 리소스 사용량을 모니터링하고 로그를보고 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02fc3314e275aaaf86c0c8bb0f6b41848338f151" translate="yes" xml:space="preserve">
          <source>You can also pass the output of a helper to a template inclusion or other helper. To do so, use parentheses to show precedence:</source>
          <target state="translated">헬퍼의 출력을 템플릿 포함 또는 다른 헬퍼로 전달할 수도 있습니다. 이렇게하려면 괄호를 사용하여 우선 순위를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="0d26a2823a09071aec3e17d038a8f356b7f2c1b1" translate="yes" xml:space="preserve">
          <source>You can also pick which type of login to do by passing an option to &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;&lt;code&gt;Meteor.loginWith&amp;lt;ExternalService&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">옵션을 &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt; &lt;code&gt;Meteor.loginWith&amp;lt;ExternalService&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 전달하여 수행 할 로그인 유형을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a82cd9a2c751894e11f1b6c264863c21e3d7f5b" translate="yes" xml:space="preserve">
          <source>You can also set &lt;code&gt;MONGO_URL&lt;/code&gt; in development if you want to connect to a different MongoDB instance.</source>
          <target state="translated">다른 MongoDB 인스턴스에 연결하려는 경우 개발시 &lt;code&gt;MONGO_URL&lt;/code&gt; 을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="231463b81c735f806c6f07dd41a9a53507c490db" translate="yes" xml:space="preserve">
          <source>You can also simply write &lt;code&gt;exports&lt;/code&gt; instead of &lt;code&gt;module.exports&lt;/code&gt; if you prefer. If you need to &lt;code&gt;require&lt;/code&gt; from an ES2015 module with a &lt;code&gt;default&lt;/code&gt; export, you can access the export with &lt;code&gt;require('package').default&lt;/code&gt;.</source>
          <target state="translated">원하는 경우 &lt;code&gt;module.exports&lt;/code&gt; 대신 간단하게 &lt;code&gt;exports&lt;/code&gt; 를 작성할 수도 있습니다 . &lt;code&gt;default&lt;/code&gt; 내보내기 를 사용하여 ES2015 모듈에서 &lt;code&gt;require&lt;/code&gt; 해야하는 경우 &lt;code&gt;require('package').default&lt;/code&gt; 를 사용하여 내보내기에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="645188ed51b5c49ada822d64bf978d39a6b8333f" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_startup&quot;&gt;Meteor.startup&lt;/a&gt; to control when run code is run on both the server and the client.</source>
          <target state="translated">또한 &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_startup&quot;&gt;Meteor.startup&lt;/a&gt; 을 사용 하여 서버와 클라이언트 모두에서 실행 코드를 실행할시기를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8524fc012f4cf38b4aa5d7d9bc8492ed402c3c2" translate="yes" xml:space="preserve">
          <source>You can also use traditional CommonJS syntax with CoffeeScript.</source>
          <target state="translated">CoffeeScript와 함께 일반적인 CommonJS 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd2e6bef96133f1d047a1f15f2d0e9bd5d2f02f1" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;allow&lt;/code&gt; as many times as you like, and each call can include any combination of &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; functions. The functions should return &lt;code&gt;true&lt;/code&gt; if they think the operation should be allowed. Otherwise they should return &lt;code&gt;false&lt;/code&gt;, or nothing at all (&lt;code&gt;undefined&lt;/code&gt;). In that case Meteor will continue searching through any other &lt;code&gt;allow&lt;/code&gt; rules on the collection.</source>
          <target state="translated">당신은 호출 할 수 &lt;code&gt;allow&lt;/code&gt; 당신이 원하는만큼 여러 번, 각 통화의 조합이 포함될 수 있습니다 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 기능을. 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환해야 합니다작업이 허용되어야한다고 생각되면 해야합니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 하거나 전혀 ( &lt;code&gt;undefined&lt;/code&gt; )를 반환해야합니다 . 이 경우 Meteor는 컬렉션의 다른 &lt;code&gt;allow&lt;/code&gt; 규칙을 계속 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="5f4c0a240b04c218b0779d19d12aa57965fb7dbf" translate="yes" xml:space="preserve">
          <source>You can chain block helpers:</source>
          <target state="translated">블록 헬퍼를 연결할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3ae789f218267cb434db4ec292f653b98d787972" translate="yes" xml:space="preserve">
          <source>You can chain block tags:</source>
          <target state="translated">블록 태그를 연결할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0898dbcdbfd719b78eadecb6b100c5ec73dbe583" translate="yes" xml:space="preserve">
          <source>You can combine multiple dynamic attributes tags with other attributes:</source>
          <target state="translated">여러 동적 속성 태그를 다른 속성과 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655ed346f81784d0581261653e9a7e79ed6e13ef" translate="yes" xml:space="preserve">
          <source>You can connect any native iOS or Android app to a Meteor server via &lt;a href=&quot;https://www.meteor.com/ddp&quot;&gt;DDP&lt;/a&gt;. For iOS, use the &lt;a href=&quot;https://github.com/martijnwalraven/meteor-ios&quot;&gt;&lt;code&gt;meteor-ios&lt;/code&gt;&lt;/a&gt; framework.</source>
          <target state="translated">&lt;a href=&quot;https://www.meteor.com/ddp&quot;&gt;DDP&lt;/a&gt; 를 통해 기본 iOS 또는 Android 앱을 Meteor 서버에 연결할 수 있습니다 . iOS의 경우&lt;a href=&quot;https://github.com/martijnwalraven/meteor-ios&quot;&gt; &lt;code&gt;meteor-ios&lt;/code&gt; &lt;/a&gt; 프레임 워크를.</target>
        </trans-unit>
        <trans-unit id="10e7ff79681a417b72ff452347965d4639b403fc" translate="yes" xml:space="preserve">
          <source>You can construct your own user interface using the functions below, or use the &lt;a href=&quot;#accountsui&quot;&gt;&lt;code&gt;accounts-ui&lt;/code&gt; package&lt;/a&gt; to include a turn-key user interface for password-based sign-in.</source>
          <target state="translated">아래 함수를 사용하여 자신의 사용자 인터페이스를 구성하거나 &lt;a href=&quot;#accountsui&quot;&gt; &lt;code&gt;accounts-ui&lt;/code&gt; 패키지&lt;/a&gt; 를비밀번호 기반 로그인을위한 턴키 사용자 인터페이스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdec73e8983ba2f0768d7d2b3675a40f95d715b6" translate="yes" xml:space="preserve">
          <source>You can control the load order of files by encoding dependencies through imports, since the load order of CSS matters.</source>
          <target state="translated">CSS의로드 순서가 중요하므로 가져 오기를 통해 종속성을 인코딩하여 파일의로드 순서를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8ffab423d6590f5ab5449fc0acfba427671200" translate="yes" xml:space="preserve">
          <source>You can create reusable CSS &amp;ldquo;modules&amp;rdquo; that just have variables and mixins and don&amp;rsquo;t actually generate any CSS.</source>
          <target state="translated">변수와 믹스 인 만 있고 실제로 CSS를 생성하지 않는 재사용 가능한 CSS&amp;ldquo;모듈&amp;rdquo;을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b876b900f8ebf93e1a5d810796db77a2b1fc0092" translate="yes" xml:space="preserve">
          <source>You can create wrapper components by using the &amp;ldquo;template as block helper&amp;rdquo; ability of Blaze (see the &lt;a href=&quot;http://blazejs.org/guide/spacebars.html#Block-Helpers&quot;&gt;Blaze Article&lt;/a&gt;). Here&amp;rsquo;s how we could write an authorization template:</source>
          <target state="translated">Blaze의 &quot;template as block helper&quot;기능을 사용하여 래퍼 구성 요소를 만들 수 있습니다 ( &lt;a href=&quot;http://blazejs.org/guide/spacebars.html#Block-Helpers&quot;&gt;Blaze 기사&lt;/a&gt; 참조). ). 인증 템플릿을 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54d5d17b9a75b2c6635708869dea8a0fad77e70e" translate="yes" xml:space="preserve">
          <source>You can decrypt them using &lt;code&gt;OAuth.openSecrets&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OAuth.openSecrets&lt;/code&gt; 를 사용하여 암호를 해독 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6febc32541eb91e25edcf07cae361f84d66b94d4" translate="yes" xml:space="preserve">
          <source>You can define helpers and event maps on &lt;code&gt;Template.body&lt;/code&gt; just like on any &lt;code&gt;Template.myTemplate&lt;/code&gt; object.</source>
          <target state="translated">당신은에 헬퍼 및 이벤트 맵을 정의 할 수 있습니다 &lt;code&gt;Template.body&lt;/code&gt; 그냥에 같은 &lt;code&gt;Template.myTemplate&lt;/code&gt; 의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="90f08cabf85c560b4a952c6f1009803e3fcd5ddc" translate="yes" xml:space="preserve">
          <source>You can deploy in debug mode by passing &lt;code&gt;--debug&lt;/code&gt;. This will leave your source code readable by your favorite in-browser debugger, just like it is in local development mode.</source>
          <target state="translated">&lt;code&gt;--debug&lt;/code&gt; 를 전달하여 디버그 모드로 배포 할 수 있습니다 . 이렇게하면 로컬 개발 모드와 마찬가지로 즐겨 사용하는 브라우저 내 디버거에서 소스 코드를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7087bebd85af6832dc0e73cc2d2c852b1a6c7a59" translate="yes" xml:space="preserve">
          <source>You can deploy the different applications with different scaling setups and secure them differently (for instance you might restrict access to your admin application to users behind a firewall).</source>
          <target state="translated">서로 다른 확장 설정으로 다른 응용 프로그램을 배포하고 다르게 보호 할 수 있습니다 (예 : 방화벽 뒤의 사용자에 대한 관리 응용 프로그램 액세스를 제한 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="9fdf88d2aeda1f8f8f2af4bdaf00f46c4ce2dbde" translate="yes" xml:space="preserve">
          <source>You can do this by adding these lines to your &lt;code&gt;~/.bash_profile&lt;/code&gt; file (or the equivalent file for your shell environment, like &lt;code&gt;~/.zshrc&lt;/code&gt;):</source>
          <target state="translated">이 행을 &lt;code&gt;~/.bash_profile&lt;/code&gt; 파일 (또는 &lt;code&gt;~/.zshrc&lt;/code&gt; 와 같은 셸 환경의 해당 파일) 에 추가하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a997f0bdfa31505b73b36af52ca54e4e80fbb12" translate="yes" xml:space="preserve">
          <source>You can do this in a Blaze component&amp;rsquo;s &lt;code&gt;onCreated()&lt;/code&gt; callback, like so:</source>
          <target state="translated">다음과 같이 Blaze 구성 요소의 &lt;code&gt;onCreated()&lt;/code&gt; 콜백 에서이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f36db4ab7b9147091e249710cef30c56c5932bab" translate="yes" xml:space="preserve">
          <source>You can find a complete list of different available routes in the &lt;a href=&quot;https://github.com/meteor-useraccounts/flow-routing#routes&quot;&gt;documentation the &lt;code&gt;useraccounts:flow-routing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/meteor-useraccounts/flow-routing#routes&quot;&gt; &lt;code&gt;useraccounts:flow-routing&lt;/code&gt; &lt;/a&gt; 문서 에서 사용 가능한 다른 경로의 전체 목록을 찾을 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="9a55fbf2d641e4c9a755a2b5e40269f365086d17" translate="yes" xml:space="preserve">
          <source>You can find more information about remote debugging in the &lt;a href=&quot;https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/&quot;&gt;Safari Developer Guide&lt;/a&gt;.</source>
          <target state="translated">원격 디버깅에 대한 자세한 정보는 &lt;a href=&quot;https://developer.apple.com/library/safari/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/&quot;&gt;Safari 개발자 안내서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad878ee63ef308bf3e69d3d1482b8bb5cb81181f" translate="yes" xml:space="preserve">
          <source>You can get more details on all the package commands in the &lt;a href=&quot;http://docs.meteor.com/#/full/meteorhelp&quot;&gt;Meteor Command line documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.meteor.com/#/full/meteorhelp&quot;&gt;Meteor Command line documentation&lt;/a&gt; 에서 모든 패키지 명령에 대한 자세한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0363ebd129bb08306b7f37eaa1513563789a23e9" translate="yes" xml:space="preserve">
          <source>You can import the dependency from within you package code in the same way that you would inside an &lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;application&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;응용 프로그램&lt;/a&gt; 내부에서와 동일한 방식으로 패키지 코드 내에서 종속성을 가져올 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="0f2b672405dfa4b775a2f8ae94d2a939150eb3c4" translate="yes" xml:space="preserve">
          <source>You can include other assets, such as fonts, icons or images, to your package using &lt;a href=&quot;http://docs.meteor.com/#/full/PackageAPI-addAssets&quot;&gt;&lt;code&gt;api.addAssets&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://docs.meteor.com/#/full/PackageAPI-addAssets&quot;&gt; &lt;code&gt;api.addAssets&lt;/code&gt; 를&lt;/a&gt; 사용하여 글꼴, 아이콘 또는 이미지와 같은 기타 자산을 패키지에 포함 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="d7f85cf2b5c56691bb7ac107c35e0b042bf6d157" translate="yes" xml:space="preserve">
          <source>You can install MongoDB on your own server&amp;mdash;one you own, rent, or a VPS (recommended) like &lt;a href=&quot;https://www.digitalocean.com/&quot;&gt;DigitalOcean&lt;/a&gt; or &lt;a href=&quot;https://amazonlightsail.com/&quot;&gt;Lightsail&lt;/a&gt;. As you can see from the above section, there are many aspects of database setup and maintenance that you have to take care of. For example, to get the best performance, you should choose a server with an &lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#use-solid-state-disks-ssds&quot;&gt;SSD&lt;/a&gt; large enough to fit your data and with enough RAM to fit the working set (indexes + active documents) in memory.</source>
          <target state="translated">MongoDB는 자신의 서버 (소유, 임대 또는 &lt;a href=&quot;https://www.digitalocean.com/&quot;&gt;DigitalOcean&lt;/a&gt; 또는 &lt;a href=&quot;https://amazonlightsail.com/&quot;&gt;Lightsail&lt;/a&gt; 과 같은 VPS (권장))에 설치할 수 있습니다. 위 섹션에서 알 수 있듯이 데이터베이스 설정 및 유지 관리에는 여러 가지 측면이 있습니다. 예를 들어 최고의 성능을 얻으려면 &lt;a href=&quot;https://docs.mongodb.com/manual/administration/production-notes/#use-solid-state-disks-ssds&quot;&gt;SSD가&lt;/a&gt; 장착 된 서버를 선택해야합니다 려면 데이터에 적합한 와 메모리의 작업 세트 (인덱스 + 활성 문서)에 맞는 RAM이 충분한 .</target>
        </trans-unit>
        <trans-unit id="4348bb45d713a8d15ac0c352fb3b5b097b01b822" translate="yes" xml:space="preserve">
          <source>You can install the Sublime Text packages that integrate them into the text editor. It&amp;rsquo;s generally recommended to use Package Control to add these packages. If you already have that setup, you can just add the these packages by name; if not, click the instructions links:</source>
          <target state="translated">텍스트 편집기에 패키지를 통합하는 Sublime Text 패키지를 설치할 수 있습니다. 일반적으로 패키지 제어를 사용하여 이러한 패키지를 추가하는 것이 좋습니다. 해당 설정이 이미있는 경우 이름별로 이러한 패키지를 추가 할 수 있습니다. 그렇지 않은 경우 지침 링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="992cbf137974fe8c5e9ec2abc1303415564d38c5" translate="yes" xml:space="preserve">
          <source>You can install version 4 from &lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;nodejs.org&lt;/a&gt; or version 5 with &lt;code&gt;brew install node&lt;/code&gt;. Then we can install the Chimp tool globally using:</source>
          <target state="translated">&lt;code&gt;brew install node&lt;/code&gt; 로&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;nodejs.org&lt;/a&gt; 또는 version 5 에서 버전 4를 설치할 수 있습니다. . 그런 다음 다음을 사용하여 Chimp 도구를 전역 적으로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1b72fb128df42fc961796e6e6d09f01ca8aa297" translate="yes" xml:space="preserve">
          <source>You can learn more about arguments to helpers in &lt;a href=&quot;spacebars&quot;&gt;Spacebars&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;spacebars&quot;&gt;스페이스 바&lt;/a&gt; 에서 헬퍼에 대한 인수에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9270f9a713e8f91d4e81ecf6e55a1eb6aa5eb27c" translate="yes" xml:space="preserve">
          <source>You can obtain a View object by calling &lt;a href=&quot;#Blaze-render&quot;&gt;&lt;code&gt;Blaze.render&lt;/code&gt;&lt;/a&gt; on a template, or by accessing &lt;a href=&quot;templates#Blaze-TemplateInstance-view&quot;&gt;&lt;code&gt;template.view&lt;/code&gt;&lt;/a&gt; on a template instance.</source>
          <target state="translated">템플릿에서 &lt;a href=&quot;#Blaze-render&quot;&gt; &lt;code&gt;Blaze.render&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 템플릿 인스턴스에서 &lt;a href=&quot;templates#Blaze-TemplateInstance-view&quot;&gt; &lt;code&gt;template.view&lt;/code&gt; &lt;/a&gt; 에 액세스 하여 View 객체를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47a8e9d55ad24a87920c2c18a1bb927d48212ab4" translate="yes" xml:space="preserve">
          <source>You can obtain a server running Ubuntu or Debian from many generic hosting providers and Meteor Up can SSH into your server with the keys you provide in the config. You can also &lt;a href=&quot;https://www.youtube.com/watch?v=WLGdXtZMmiI&quot;&gt;watch this video&lt;/a&gt; for a more complete walkthrough on how to do it.</source>
          <target state="translated">많은 일반 호스팅 공급자로부터 Ubuntu 또는 Debian을 실행하는 서버를 얻을 수 있으며 Meteor Up은 구성에서 제공 한 키를 사용하여 서버에 SSH로 연결할 수 있습니다. &lt;a href=&quot;https://www.youtube.com/watch?v=WLGdXtZMmiI&quot;&gt;이 비디오&lt;/a&gt; 를 시청 하는 방법에 대한 더 자세한 연습을 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2995106fad3a164c44aca51698ab73d2b15e7538" translate="yes" xml:space="preserve">
          <source>You can often work out &lt;em&gt;why&lt;/em&gt; a helper has re-run by tracing the source of the reactive invalidation:</source>
          <target state="translated">반응성 무효화 소스를 추적하여 헬퍼가 다시 실행 된 &lt;em&gt;이유를&lt;/em&gt; 종종 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb41f49a9b4285630e5a878037ee396237fbbaae" translate="yes" xml:space="preserve">
          <source>You can only access &lt;code&gt;findAll&lt;/code&gt;, &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;firstNode&lt;/code&gt;, and &lt;code&gt;lastNode&lt;/code&gt; from the &lt;code&gt;onRendered&lt;/code&gt; callback and event handlers, not from &lt;code&gt;onCreated&lt;/code&gt; and &lt;code&gt;onDestroyed&lt;/code&gt;, because they require the template instance to be in the DOM.</source>
          <target state="translated">당신은 액세스 할 수 &lt;code&gt;findAll&lt;/code&gt; , &lt;code&gt;find&lt;/code&gt; , &lt;code&gt;firstNode&lt;/code&gt; 및 &lt;code&gt;lastNode&lt;/code&gt; 를 으로부터 &lt;code&gt;onRendered&lt;/code&gt; 에서하지, 콜백 및 이벤트 핸들러 &lt;code&gt;onCreated&lt;/code&gt; 및 &lt;code&gt;onDestroyed&lt;/code&gt; 들이 DOM에있을 템플릿 인스턴스를 필요로하기 때문에.</target>
        </trans-unit>
        <trans-unit id="4ef732022f03cd81ea0fb4da7fb108bbe19b4465" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;--server-only&lt;/code&gt; to only build the server bundle. This allows you to build your app without installing the mobile SDKs on the build machine. This is useful if you use an automated deployment setup for instance. (If you remove the mobile platforms before building instead, hot code push will be disabled because the assets for Cordova included in the server bundle will not be generated.)</source>
          <target state="translated">당신은 통과 할 수 있습니다 &lt;code&gt;--server-only&lt;/code&gt; 를 하여 서버 번들 만 빌드 . 이를 통해 빌드 머신에 모바일 SDK를 설치하지 않고도 앱을 빌드 할 수 있습니다. 예를 들어 자동 배포 설정을 사용하는 경우에 유용합니다. (빌드하기 전에 모바일 플랫폼을 제거하면 서버 번들에 포함 된 Cordova의 자산이 생성되지 않으므로 핫 코드 푸시가 비활성화됩니다.)</target>
        </trans-unit>
        <trans-unit id="0f89febf1cc0cf2286f84dd4a884cdffa35a0bae" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;METEOR_SESSION_FILE=token.json&lt;/code&gt; before &lt;code&gt;meteor login&lt;/code&gt; to generate a login session token so you don&amp;rsquo;t have to share your login credentials with third-party service providers.</source>
          <target state="translated">&lt;code&gt;METEOR_SESSION_FILE=token.json&lt;/code&gt; 을 전달 하기 전에 &lt;code&gt;meteor login&lt;/code&gt; 하여 로그인 세션 토큰을 생성 할 수 있으므로 로그인 자격 증명을 타사 서비스 제공 업체와 공유 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7830a21ba1d3347cb7951399fc28fac7f35d173c" translate="yes" xml:space="preserve">
          <source>You can pass an argument to &lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; or &lt;code&gt;{{&amp;gt;
Template.elseBlock}}&lt;/code&gt; to invoke it with a data context of your choice. You can also use &lt;code&gt;{{#if Template.contentBlock}}&lt;/code&gt; to see if the current template was invoked as a block helper rather than an inclusion.</source>
          <target state="translated">&lt;code&gt;{{&amp;gt; Template.contentBlock}}&lt;/code&gt; 또는 &lt;code&gt;{{&amp;gt; Template.elseBlock}}&lt;/code&gt; 에 인수를 전달 하여 선택한 데이터 컨텍스트로 인수를 호출 할 수 있습니다. &lt;code&gt;{{#if Template.contentBlock}}&lt;/code&gt; 을 (를) 사용하여 현재 템플릿이 포함이 아닌 블록 도우미로 호출되었는지 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c39cad7f669d627f6f48626c10d710892e6935c4" translate="yes" xml:space="preserve">
          <source>You can pass in the flag &lt;code&gt;--packages-only&lt;/code&gt; to update only the packages, and not the release itself. Similarly, you can pass in names of packages (&lt;code&gt;meteor update foo:kittens baz:cats&lt;/code&gt;) to only update specific packages.</source>
          <target state="translated">&lt;code&gt;--packages-only&lt;/code&gt; 플래그를 전달 하면 릴리스 자체가 아닌 패키지 만 업데이트 할 수 있습니다 . 마찬가지로 특정 패키지 만 업데이트하기 위해 패키지 이름 ( &lt;code&gt;meteor update foo:kittens baz:cats&lt;/code&gt; )을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2670efad128c2847df08821969530c5982124949" translate="yes" xml:space="preserve">
          <source>You can pass settings to your app through a &lt;em&gt;settings file&lt;/em&gt; or an &lt;em&gt;environment variable&lt;/em&gt;. Most of your app settings should be in JSON files that you pass in when starting your app. You can start your app with a settings file by passing the &lt;code&gt;--settings&lt;/code&gt; flag:</source>
          <target state="translated">&lt;em&gt;설정 파일&lt;/em&gt; 또는 &lt;em&gt;환경 변수를&lt;/em&gt; 통해 설정을 앱에 전달할 수 있습니다 . 대부분의 앱 설정은 앱을 시작할 때 전달하는 JSON 파일에 있어야합니다. 전달하여 설정 파일로 앱을 시작할 수 있습니다. &lt;code&gt;--settings&lt;/code&gt; 플래그 .</target>
        </trans-unit>
        <trans-unit id="acb1a747720b365b65f3ef3ee4fd8e5cf9afb54d" translate="yes" xml:space="preserve">
          <source>You can provide arguments to a helper like &lt;code&gt;checkedClass&lt;/code&gt; by simply placing the argument after the helper call, as in: &lt;code&gt;{{checkedClass todo true 'checked'}}&lt;/code&gt;. You can also provide a list of named keyword arguments to a helper with &lt;code&gt;{{checkedClass todo noClass=true classname='checked'}}&lt;/code&gt;. When you pass keyword arguments, you need to read them off of the &lt;code&gt;hash&lt;/code&gt; property of the final argument. Here&amp;rsquo;s how it would look for the example we just saw:</source>
          <target state="translated">&lt;code&gt;{{checkedClass todo true 'checked'}}&lt;/code&gt; 와 같이 헬퍼 호출 후 인수를 간단히 배치하여 &lt;code&gt;checkedClass&lt;/code&gt; 와 같은 헬퍼에 인수를 제공 할 수 있습니다 . &lt;code&gt;{{checkedClass todo noClass=true classname='checked'}}&lt;/code&gt; 를 사용하여 이름 지정된 키워드 인수 목록을 헬퍼에게 제공 할 수도 있습니다 . 키워드 인수를 전달할 때 &lt;code&gt;hash&lt;/code&gt; 에서 읽어야합니다. 최종 인수 속성에서 . 방금 본 예제를 찾는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d344814d6de6796e279884e12eed7f40b8c8feb2" translate="yes" xml:space="preserve">
          <source>You can read about the full syntax &lt;a href=&quot;../api/spacebars&quot;&gt;in the Spacebars&lt;/a&gt;. In this section we&amp;rsquo;ll attempt to cover some of the important details beyond just the syntax.</source>
          <target state="translated">&lt;a href=&quot;../api/spacebars&quot;&gt;스페이스 바에서&lt;/a&gt; 전체 구문 에 대해 읽을 수 있습니다 . 이 섹션에서는 구문 이외의 중요한 세부 사항을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="39f1fe3fe0f293991aba353817d2fa496b238d62" translate="yes" xml:space="preserve">
          <source>You can read about the module system in detail in the &lt;a href=&quot;https://docs.meteor.com/#/full/modules&quot;&gt;&lt;code&gt;modules&lt;/code&gt; package README&lt;/a&gt;. This package is automatically included in every new Meteor app as part of the &lt;a href=&quot;https://docs.meteor.com/#/full/ecmascript&quot;&gt;&lt;code&gt;ecmascript&lt;/code&gt; meta-package&lt;/a&gt;, so most apps won&amp;rsquo;t need to do anything to start using modules right away.</source>
          <target state="translated">&lt;a href=&quot;https://docs.meteor.com/#/full/modules&quot;&gt; &lt;code&gt;modules&lt;/code&gt; 패키지 README&lt;/a&gt; 에서 모듈 시스템에 대해 자세히 읽을 수 있습니다 . 이 패키지는 &lt;a href=&quot;https://docs.meteor.com/#/full/ecmascript&quot;&gt; &lt;code&gt;ecmascript&lt;/code&gt; &lt;/a&gt; 메타 패키지의 일부로 모든 새로운 Meteor 앱에 자동으로 포함 됩니다 되므로 대부분의 앱은 모듈 사용을 바로 시작할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="677ed86f4653021adb6464050b4696cd107ee3c9" translate="yes" xml:space="preserve">
          <source>You can read more about testing in Meteor in the &lt;a href=&quot;testing&quot;&gt;Testing article&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing&quot;&gt;테스트 기사&lt;/a&gt; 에서 Meteor의 테스트에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cac7c58eebbebcfee2eda69b304193fbfc66655e" translate="yes" xml:space="preserve">
          <source>You can read more about views in the &lt;a href=&quot;../api/blaze#Blaze-View&quot;&gt;Blaze View&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/blaze#Blaze-View&quot;&gt;Blaze View&lt;/a&gt; 에서 뷰에 대한 자세한 내용을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21588630855ee60edffdf41d2ca535f1e8042ae6" translate="yes" xml:space="preserve">
          <source>You can read this &lt;a href=&quot;https://www.okgrow.com/posts/mongodb-atlas-setup&quot;&gt;detailed guide&lt;/a&gt; by OK GROW! for step-by-step instructions to deploying a production ready MongoDB database on MongoDB Atlas.</source>
          <target state="translated">OK GROW를 통해이 &lt;a href=&quot;https://www.okgrow.com/posts/mongodb-atlas-setup&quot;&gt;자세한 안내서&lt;/a&gt; 를 읽을 수 있습니다 ! MongoDB Atlas에 프로덕션 준비 MongoDB 데이터베이스를 배포하기위한 단계별 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ec22f3709b6dd7897c4dc5c586588309576d5758" translate="yes" xml:space="preserve">
          <source>You can remove a previously added plugin using &lt;code&gt;meteor remove&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;meteor remove&lt;/code&gt; 를 사용하여 이전에 추가 한 플러그인을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6df52778bbe12b2b5233490bb56338c1012b18d" translate="yes" xml:space="preserve">
          <source>You can render a component hierarchy to the DOM using the &lt;code&gt;react-dom&lt;/code&gt; package:</source>
          <target state="translated">&lt;code&gt;react-dom&lt;/code&gt; 패키지를 사용하여 컴포넌트 계층을 DOM으로 렌더링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb8d291d4800eeca1965120be1b6b109c90338d3" translate="yes" xml:space="preserve">
          <source>You can see a proof of concept of this architecture in an &lt;a href=&quot;https://github.com/tmeasday/multi-app-accounts&quot;&gt;example repository&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tmeasday/multi-app-accounts&quot;&gt;예제 리포지토리&lt;/a&gt; 에서이 아키텍처의 개념 증명을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d46847fb3216d60b044b6960139d813e62a86cdb" translate="yes" xml:space="preserve">
          <source>You can see that although the situation is a little complex, it&amp;rsquo;s also completely determined by the arguments and thus very much testable. A component style guide helps immeasurably in seeing all these states easily! In Galaxy we have each state in our style guide for each of the lists of our app and we can ensure all work as expected and appear correctly:</source>
          <target state="translated">상황은 조금 복잡하지만 인수에 의해 완전히 결정되므로 테스트가 가능하다는 것을 알 수 있습니다. 컴포넌트 스타일 가이드는 이러한 모든 상태를 쉽게 볼 수 있도록 도와줍니다! Galaxy에서는 각 앱 목록에 대한 스타일 가이드에 각 상태가 있으며 모든 예상대로 작동하고 올바르게 표시되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a344188b17a4c7783bc4cfc054ff302f93a67981" translate="yes" xml:space="preserve">
          <source>You can see that this Method does a &lt;em&gt;very specific thing&lt;/em&gt; - it just makes a single list private. An alternative would have been to have a Method called &lt;code&gt;setPrivacy&lt;/code&gt;, which could set the list to private or public, but it turns out that in this particular app the security considerations for the two related operations - &lt;code&gt;makePrivate&lt;/code&gt; and &lt;code&gt;makePublic&lt;/code&gt; - are very different. By splitting our operations into different Methods, we make each one much clearer. It&amp;rsquo;s obvious from the above Method definition which arguments we accept, what security checks we perform, and what operations we do on the database.</source>
          <target state="translated">이 방법은 &lt;em&gt;매우 특정한 일을&lt;/em&gt; 수행한다는 것을 알 수 있습니다 . 단일 목록을 비공개로 만듭니다. 대안은 &lt;code&gt;setPrivacy&lt;/code&gt; 라는 메소드를 사용하는 것인데, 목록을 개인 또는 공용으로 설정할 수 있지만이 특정 앱에서 두 가지 관련 작업 ( &lt;code&gt;makePrivate&lt;/code&gt; 및 &lt;code&gt;makePublic&lt;/code&gt; )에 대한 보안 고려 사항 이 매우 다르다는 것이 밝혀졌습니다 . 우리의 작업을 다른 방법으로 나누면 각각을 훨씬 명확하게 만듭니다. 위의 메소드 정의에서 우리가 받아들이는 인수, 수행하는 보안 검사 및 데이터베이스에서 수행하는 작업은 분명합니다.</target>
        </trans-unit>
        <trans-unit id="67994359c59c850118111c14804dfe397f0d8e8f" translate="yes" xml:space="preserve">
          <source>You can see that with relatively little code we&amp;rsquo;ve managed to restrict the format of a list significantly. You can read more about more complex things that can be done with schemas in the &lt;a href=&quot;http://atmospherejs.com/aldeed/simple-schema&quot;&gt;Simple Schema docs&lt;/a&gt;.</source>
          <target state="translated">비교적 적은 코드로 목록의 형식을 크게 제한했다는 것을 알 수 있습니다. &lt;a href=&quot;http://atmospherejs.com/aldeed/simple-schema&quot;&gt;단순 스키마 문서&lt;/a&gt; 에서 스키마로 수행 할 수있는보다 복잡한 작업에 대한 자세한 내용을 읽을 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="f24de5f82ac264207f621dbd3478c799651b6cd5" translate="yes" xml:space="preserve">
          <source>You can share your package with others by publishing it to the npm registry. While most packages are public, you can control who may view and use your package with &lt;a href=&quot;https://docs.npmjs.com/private-modules/intro&quot;&gt;private modules&lt;/a&gt;).</source>
          <target state="translated">패키지를 npm 레지스트리에 게시하여 다른 사용자와 패키지를 공유 할 수 있습니다. 대부분의 패키지는 공용이지만 &lt;a href=&quot;https://docs.npmjs.com/private-modules/intro&quot;&gt;개인 모듈로&lt;/a&gt; 패키지를보고 사용할 수있는 사람을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87be8aa1162e791406bf47cce0fe0a2ae8a5b729" translate="yes" xml:space="preserve">
          <source>You can specify multiple targets, so &lt;code&gt;meteor run ios android-device&lt;/code&gt; will run the app on both the iOS Simulator and an Android device for example.</source>
          <target state="translated">여러 대상을 지정할 수 있으므로 &lt;code&gt;meteor run ios android-device&lt;/code&gt; 는 iOS 시뮬레이터와 Android 장치 모두에서 앱을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4d08bf500dca58dc82a365871bba78de6c21404a" translate="yes" xml:space="preserve">
          <source>You can take the above UI a step further by showing placeholders whilst you wait for the data to load. This is a UX pattern that has been pioneered by Facebook which gives the user a more solid impression of what data is coming down the wire. It also prevents parts of the UI from moving around when data loads, if you can make the placeholder have the same dimensions as the final element.</source>
          <target state="translated">데이터가로드 될 때까지 자리 표시자를 표시하여 위의 UI를 한 단계 더 발전시킬 수 있습니다. 이것은 Facebook에 의해 개척 된 UX 패턴으로, 사용자는 데이터가 전송되는 데이터에 대해보다 확실한 인상을줍니다. 또한 자리 표시자를 최종 요소와 동일한 크기로 만들 수있는 경우 데이터가로드 될 때 UI의 일부가 움직이지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="b7f98eb30614a882d79daa6d32c8320a50158703" translate="yes" xml:space="preserve">
          <source>You can then access these files from the client from a URL &lt;code&gt;/packages/username_my-package/font/OpenSans-Regular-webfont.eot&lt;/code&gt; or from the server using the &lt;a href=&quot;http://docs.meteor.com/#/full/assets_getText&quot;&gt;Assets API&lt;/a&gt;.</source>
          <target state="translated">그런 다음 URL &lt;code&gt;/packages/username_my-package/font/OpenSans-Regular-webfont.eot&lt;/code&gt; 또는 서버에서 &lt;a href=&quot;http://docs.meteor.com/#/full/assets_getText&quot;&gt;Assets API를&lt;/a&gt; 사용하여 클라이언트에서 이러한 파일에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5acc6e398770bfc30afc03d44106e7b8e78f17e" translate="yes" xml:space="preserve">
          <source>You can then get the data back out of Flow Router using &lt;a href=&quot;http://docs.meteor.com/#/full/ejson_parse&quot;&gt;&lt;code&gt;EJSON.parse()&lt;/code&gt;&lt;/a&gt;. Note that Flow Router does the URL decoding for you automatically:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;http://docs.meteor.com/#/full/ejson_parse&quot;&gt; &lt;code&gt;EJSON.parse()&lt;/code&gt; &lt;/a&gt; 사용하여 Flow Router에서 데이터를 다시 가져올 수 있습니다 . Flow Router는 자동으로 URL 디코딩을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="01dd8fbee8fa942fc00d0b0c2bc37f5b7f748b58" translate="yes" xml:space="preserve">
          <source>You can then run the application by invoking &lt;code&gt;node&lt;/code&gt; with a &lt;code&gt;ROOT_URL&lt;/code&gt;, and &lt;code&gt;MONGO_URL&lt;/code&gt;. These instructions are also available in the &lt;code&gt;README&lt;/code&gt; file found in the root of the bundle you built above.</source>
          <target state="translated">그런 다음 &lt;code&gt;ROOT_URL&lt;/code&gt; 및 &lt;code&gt;MONGO_URL&lt;/code&gt; 을 사용하여 &lt;code&gt;node&lt;/code&gt; 를 호출하여 애플리케이션을 실행할 수 있습니다 . 이 지침은 &lt;code&gt;README&lt;/code&gt; 에서도 볼 수 있습니다 위에서 빌드 한 번들의 루트 파일 .</target>
        </trans-unit>
        <trans-unit id="d6f1b08b6ac58a8312bbfcc767daabb4523afb12" translate="yes" xml:space="preserve">
          <source>You can use (1) or (2) to override the version from Atmosphere. You can even do this to load patched versions of Meteor core packages - just copy the code of the package from &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages&quot;&gt;Meteor&amp;rsquo;s GitHub repository&lt;/a&gt;, and edit away.</source>
          <target state="translated">(1) 또는 (2)를 사용하여 Atmosphere의 버전을 재정의 할 수 있습니다. 패치 된 버전의 Meteor 코어 패키지를로드하기 위해이 작업을 수행 할 수도 있습니다. &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages&quot;&gt;Meteor의 GitHub 리포지토리&lt;/a&gt; 에서 패키지 코드를 복사하여 편집하면됩니다.</target>
        </trans-unit>
        <trans-unit id="abe82bb58f5585431c4fb1a02e95ab64101879b1" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#writingpackages&quot;&gt;local packages&lt;/a&gt; to define custom build plugins for your app, with one caveat. In published packages, build plugins are already bundled with their transitive dependencies. So if you want a dependency of a build plugin to be satisfied by a local package, you must use a local copy of the package that defines the plugin (even if you make no changes to that package) so that Meteor will pick up the local dependency.</source>
          <target state="translated">&lt;a href=&quot;#writingpackages&quot;&gt;로컬 패키지&lt;/a&gt; 를 사용하여 하나의 경고와 함께 앱의 사용자 지정 빌드 플러그인을 정의 할 수 있습니다 . 게시 된 패키지에서 빌드 플러그인은 이미 전이 종속성과 함께 번들로 제공됩니다. 따라서 로컬 패키지에서 빌드 플러그인의 종속성을 충족 시키려면 플러그인을 정의하는 패키지의 로컬 사본을 사용해야합니다 (패키지를 변경하지 않더라도) Meteor가 로컬을 선택합니다. 의존.</target>
        </trans-unit>
        <trans-unit id="719484cd6caa5518b91e86f8f54edebcfe7b939d" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/meteor/chromatic&quot;&gt;Chromatic component explorer&lt;/a&gt; in your Meteor + React app with &lt;code&gt;meteor add mdg:chromatic&lt;/code&gt;. Similar projects built in React are &lt;a href=&quot;http://www.uiharness.com/&quot;&gt;UI Harness&lt;/a&gt; by Phil Cockfield and &lt;a href=&quot;https://github.com/kadirahq/react-storybook&quot;&gt;React Storybook&lt;/a&gt; by Arunoda Susiripala.</source>
          <target state="translated">&lt;code&gt;meteor add mdg:chromatic&lt;/code&gt; 과 함께 Meteor + React 앱에서 &lt;a href=&quot;https://github.com/meteor/chromatic&quot;&gt;Chromatic 컴포넌트 탐색기&lt;/a&gt; 를 사용할 수 있습니다 . React에 내장 된 유사한 프로젝트는 Phil Cockfield의 &lt;a href=&quot;http://www.uiharness.com/&quot;&gt;UI Harness&lt;/a&gt; 와 Arunoda Susiripala의 &lt;a href=&quot;https://github.com/kadirahq/react-storybook&quot;&gt;React Storybook&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7b55ec6860cbf09c67efb1cbe8e061e27768ad2" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;this.autorun&lt;/code&gt; from an &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;onCreated&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;templates#Template-onRendered&quot;&gt;&lt;code&gt;onRendered&lt;/code&gt;&lt;/a&gt; callback to reactively update the DOM or the template instance. You can use &lt;code&gt;Template.currentData()&lt;/code&gt; inside of this callback to access reactive data context of the template instance. The Computation is automatically stopped when the template is destroyed.</source>
          <target state="translated">&lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;onCreated&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;templates#Template-onRendered&quot;&gt; &lt;code&gt;onRendered&lt;/code&gt; &lt;/a&gt; 콜백 에서 &lt;code&gt;this.autorun&lt;/code&gt; 을 사용 하여 DOM 또는 템플릿 인스턴스를 반응 적으로 업데이트 할 수 있습니다 . 이 콜백 내에서 &lt;code&gt;Template.currentData()&lt;/code&gt; 사용 하여 템플릿 인스턴스의 반응 형 데이터 컨텍스트에 액세스 할 수 있습니다. 템플릿이 삭제되면 계산이 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="def8b86be88e1a4fba9288b0f7a13fb4141a9c59" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;this.subscribe&lt;/code&gt; from an &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;onCreated&lt;/code&gt;&lt;/a&gt; callback to specify which data publications this template depends on. The subscription is automatically stopped when the template is destroyed.</source>
          <target state="translated">&lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;onCreated&lt;/code&gt; &lt;/a&gt; 콜백 에서 &lt;code&gt;this.subscribe&lt;/code&gt; 를 사용 하여이 템플릿이 의존하는 데이터 게시를 지정할 수 있습니다 . 템플릿이 삭제되면 구독이 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="625bdbdf3540913a4eaf0e9ae255ce21f5a4b00b" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;update&lt;/code&gt; to perform a Mongo upsert by setting the &lt;code&gt;upsert&lt;/code&gt; option to true. You can also use the &lt;a href=&quot;#upsert&quot;&gt;&lt;code&gt;upsert&lt;/code&gt;&lt;/a&gt; method to perform an upsert that returns the &lt;code&gt;_id&lt;/code&gt; of the document that was inserted (if there was one) in addition to the number of affected documents.</source>
          <target state="translated">&lt;code&gt;upsert&lt;/code&gt; 옵션을 true 로 설정하여 &lt;code&gt;update&lt;/code&gt; 를 사용하여 Mongo upsert를 수행 할 수 있습니다 . &lt;a href=&quot;#upsert&quot;&gt; &lt;code&gt;upsert&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 영향을받는 문서 수와 함께 삽입 된 문서 (있는 경우) 의 &lt;code&gt;_id&lt;/code&gt; 를 리턴하는 upsert를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="367cb316ce142085cf3595052ca4c41bb3735b2b" translate="yes" xml:space="preserve">
          <source>You can use a special variable &lt;code&gt;@index&lt;/code&gt; in the body of &lt;code&gt;#each&lt;/code&gt; to get the 0-based index of the currently rendered value in the sequence.</source>
          <target state="translated">당신은 특별한 변수 사용할 수 있습니다 &lt;code&gt;@index&lt;/code&gt; 을 본문에 &lt;code&gt;#each&lt;/code&gt; 순서에서 현재 렌더링 된 값의 제로로부터 시작되는 인덱스를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49c3186f6fceef6b76bf646f03fdbf62e5da70d6" translate="yes" xml:space="preserve">
          <source>You can use any field name other than those &lt;a href=&quot;http://docs.meteor.com/api/accounts.html#Meteor-users&quot;&gt;used by the Accounts system&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.meteor.com/api/accounts.html#Meteor-users&quot;&gt;계정 시스템에서 사용되는&lt;/a&gt; 것 이외의 다른 필드 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69d614007a524a4d41a28ee9d3ec31704c6b72fe" translate="yes" xml:space="preserve">
          <source>You can use the application by pointing your web browser at &lt;a href=&quot;http://localhost:3000&quot;&gt;localhost:3000&lt;/a&gt;. No Internet connection is required.</source>
          <target state="translated">&lt;a href=&quot;http://localhost:3000&quot;&gt;localhost : 3000&lt;/a&gt; 에서 웹 브라우저를 지정하여 응용 프로그램을 사용할 수 있습니다 . 인터넷 연결이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d6f0840a85fe3661c42350e24c5642aadd13d23" translate="yes" xml:space="preserve">
          <source>You can use the application server bundle to host a Meteor application on your own server, instead of deploying to Galaxy. You will have to deal with logging, monitoring, backups, load-balancing, etc, all of which we handle for you if you use Galaxy.</source>
          <target state="translated">Galaxy에 배포하는 대신 응용 프로그램 서버 번들을 사용하여 자체 서버에서 Meteor 응용 프로그램을 호스팅 할 수 있습니다. Galaxy를 사용하는 경우 로깅, 모니터링, 백업,로드 밸런싱 등을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="693e68c4cc153f63f032100b0ef2420caddc6788" translate="yes" xml:space="preserve">
          <source>You can use the official search at &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmjs.com&lt;/a&gt; or see results sorted by package quality (code quality, maintenance status, development velocity, popularity etc.) at &lt;a href=&quot;https://npms.io/&quot;&gt;npms.io&lt;/a&gt;. There are also sites that search certain types of packages, like &lt;a href=&quot;https://js.coach/&quot;&gt;js.coach&lt;/a&gt;&amp;lsquo;s &lt;a href=&quot;https://js.coach/react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://js.coach/react-native&quot;&gt;React Native&lt;/a&gt; sections.</source>
          <target state="translated">당신은 공식 검색 사용할 수 있습니다 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmjs.com을&lt;/a&gt; 또는 패키지의 품질 (코드 품질, 유지 보수 상태, 개발 속도, 인기 등)으로 분류 결과를 참조 &lt;a href=&quot;https://npms.io/&quot;&gt;npms.io를&lt;/a&gt; . &lt;a href=&quot;https://js.coach/&quot;&gt;js.coach&lt;/a&gt; 의 &lt;a href=&quot;https://js.coach/react&quot;&gt;React&lt;/a&gt; 및 &lt;a href=&quot;https://js.coach/react-native&quot;&gt;React Native&lt;/a&gt; 섹션 과 같은 특정 유형의 패키지를 검색하는 사이트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e397dc59d62c9ff4b2d7ce9e37575739e480e5" translate="yes" xml:space="preserve">
          <source>You can write apps with native UI elements in JavaScript using &lt;a href=&quot;https://facebook.github.io/react-native/&quot;&gt;React Native&lt;/a&gt;. For the most recent information on how to use React Native with Meteor, see &lt;a href=&quot;https://github.com/spencercarli/react-native-meteor-index&quot;&gt;this reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react-native/&quot;&gt;React Native를&lt;/a&gt; 사용하여 JavaScript에서 기본 UI 요소가있는 앱을 작성할 수 있습니다 . Meteor와 함께 React Native를 사용하는 방법에 대한 최신 정보는 &lt;a href=&quot;https://github.com/spencercarli/react-native-meteor-index&quot;&gt;이 참조를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca897cb3ea8d43f3dac013232817716ef78944b4" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t do security at the rendering layer</source>
          <target state="translated">렌더링 레이어에서 보안을 수행 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="d161470ddf8dd7abd3373375e088cf4830cbd38a" translate="yes" xml:space="preserve">
          <source>You configure these images with &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-icons&quot;&gt;&lt;code&gt;App.icons&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-launchScreens&quot;&gt;&lt;code&gt;App.launchScreens&lt;/code&gt;&lt;/a&gt;, which both use names to refer to the various supported image sizes (see API documentation).</source>
          <target state="translated">&lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-icons&quot;&gt; &lt;code&gt;App.icons&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-launchScreens&quot;&gt; &lt;code&gt;App.launchScreens&lt;/code&gt; 로&lt;/a&gt; 이러한 이미지를 구성합니다. App.icons 및 App.launchScreens 는 이름을 사용하여 다양한 지원되는 이미지 크기를 참조합니다 (API 설명서 참조).</target>
        </trans-unit>
        <trans-unit id="a96fd67b2ef2cc7b602721cd756aad2ccde351f8" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to put all your method definitions into a single &lt;code&gt;Meteor.methods&lt;/code&gt; call; you may call it multiple times, as long as each method has a unique name.</source>
          <target state="translated">모든 메소드 정의를 단일 &lt;code&gt;Meteor.methods&lt;/code&gt; 호출 에 넣을 필요는 없습니다 . 각 메소드의 이름이 고유 한 한 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16d7b01173b10b72630fe0e9d73f4211139f847" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use the &lt;code&gt;ecmascript&lt;/code&gt; package or ES2015 syntax in order to use modules. Just like Node.js in the pre-ES2015 days, you can use &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt;&amp;mdash;that&amp;rsquo;s what the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements are compiling into, anyway.</source>
          <target state="translated">모듈을 사용하기 위해 &lt;code&gt;ecmascript&lt;/code&gt; 패키지 또는 ES2015 구문 을 사용할 필요가 없습니다 . ES2015 이전의 Node.js 와 &lt;code&gt;module.exports&lt;/code&gt; &lt;code&gt;require&lt;/code&gt; 및 module.exports를 사용할 수 있습니다. 이는 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 문이 컴파일하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="35340523a28f631b7ad9ff725dba3eac18ec03b4" translate="yes" xml:space="preserve">
          <source>You install plugins from the local file system by specifying a &lt;code&gt;file://&lt;/code&gt; URL, which gets interpreted relative to the project directory:</source>
          <target state="translated">프로젝트 디렉토리와 관련하여 해석되는 &lt;code&gt;file://&lt;/code&gt; URL 을 지정하여 로컬 파일 시스템에서 플러그인을 설치 합니다 .</target>
        </trans-unit>
        <trans-unit id="7f9de81df1636001e3313767d2c4f81a6f21e25d" translate="yes" xml:space="preserve">
          <source>You know exactly what dependencies you need to provide for them to work in different environments.</source>
          <target state="translated">서로 다른 환경에서 작동하기 위해 어떤 종속성을 제공해야하는지 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7230ad8e312e005df99bc928963df2b191b25e59" translate="yes" xml:space="preserve">
          <source>You may also need to click &amp;lsquo;Allow&amp;rsquo; on the &lt;code&gt;Allow USB debugging?&lt;/code&gt; prompt on the device.</source>
          <target state="translated">&lt;code&gt;Allow USB debugging?&lt;/code&gt; 에서 '허용'을 클릭해야 할 수도 있습니다 . 장치에 프롬프트.</target>
        </trans-unit>
        <trans-unit id="b7dcf010c68b008bb21d0fa44d110cd195c477ae" translate="yes" xml:space="preserve">
          <source>You may also pass the &lt;code&gt;--release&lt;/code&gt; flag to act as an override to update to a specific release. This is an override: if it cannot find compatible versions of packages, it will log a warning, but perform the update anyway. This will only change your package versions if necessary.</source>
          <target state="translated">&lt;code&gt;--release&lt;/code&gt; 플래그를 전달하여 특정 릴리스로 업데이트하기위한 재정의 역할을 할 수도 있습니다. 호환되는 버전의 패키지를 찾을 수 없으면 경고를 기록하지만 업데이트를 수행합니다. 필요한 경우 패키지 버전 만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5d633e2969e79a6a5d2823a964f03c203967aa6f" translate="yes" xml:space="preserve">
          <source>You may be aware that WKWebView on iOS 8 doesn&amp;rsquo;t allow files to be loaded from the local filesystem. This is problematic for standard Cordova apps, because these use &lt;code&gt;file://&lt;/code&gt; URLs to load the app. But because the Meteor integration serves assets from &lt;code&gt;localhost&lt;/code&gt;, WKWebView works fine on both iOS 8 and iOS 9.</source>
          <target state="translated">iOS 8의 WKWebView에서는 로컬 파일 시스템에서 파일을로드 할 수 없습니다. &lt;code&gt;file://&lt;/code&gt; URL을 사용하여 앱을로드 하기 때문에 표준 Cordova 앱에서는 문제가 됩니다. 그러나 Meteor 통합은 &lt;code&gt;localhost&lt;/code&gt; 의 자산을 제공하기 때문에 WKWebView는 iOS 8과 iOS 9 모두에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="03a010eb4ddfc7f27147ebb347fbb6b90ecb2990" translate="yes" xml:space="preserve">
          <source>You may have heard of PhoneGap, and wonder how it relates to Cordova. PhoneGap is a product name used by Adobe since 2011, when they acquired a company called Nitobi, the original creators of what is now the Cordova project. When Adobe donated the code to Apache in 2012 to ensure a more open governance model, the open source project was rebranded as Cordova. PhoneGap is now one of the distributions of Cordova, on a par with other distributions like Ionic, Telerik, Monaca, or Intel XDK. These distributions mainly differ in tooling and integration with cloud services, but they share the underlying platform and plugins. Meteor could also be considered a Cordova distribution.</source>
          <target state="translated">PhoneGap에 대해 들어봤을 때 그것이 Cordova와 어떤 관련이 있는지 궁금합니다. PhoneGap은 2011 년부터 Adobe에서 사용하는 제품 이름으로, 현재 Cordova 프로젝트의 최초 작성자 인 Nitobi라는 회사를 인수했습니다. 보다 개방적인 거버넌스 모델을 보장하기 위해 Adobe가 2012 년에 코드를 Apache에 기증했을 때 오픈 소스 프로젝트는 Cordova로 브랜드가 변경되었습니다. PhoneGap은 이제 Ionic, Telerik, Monaca 또는 Intel XDK와 같은 다른 배포판과 동등한 Cordova 배포판 중 하나입니다. 이러한 배포판은 주로 툴링 및 클라우드 서비스와의 통합이 다르지만 기본 플랫폼 및 플러그인을 공유합니다. 유성은 또한 코르도바 분포로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c952d45a07adebdf65651853743470414f4a2cd" translate="yes" xml:space="preserve">
          <source>You may notice in the example Method above, we didn&amp;rsquo;t need to write any callbacks when interacting with MongoDB, but the Method still has the non-blocking properties that people associate with Node.js and callback-style code. Meteor uses a coroutine library called &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers&lt;/a&gt; to enable you to write code that uses return values and throws errors, and avoid dealing with lots of nested callbacks.</source>
          <target state="translated">위의 예제 메소드에서 MongoDB와 상호 작용할 때 콜백을 작성할 필요는 없지만 메소드에는 여전히 사람들이 Node.js 및 콜백 스타일 코드와 연결하는 비 차단 속성이 있습니다. Meteor는 &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers&lt;/a&gt; 라는 코 루틴 라이브러리 를 사용하여 반환 값을 사용하고 오류를 발생시키는 코드를 작성하고 중첩 된 콜백을 많이 처리하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="439bddc16ca01d35482ca36832a9f9a0a7bbb438" translate="yes" xml:space="preserve">
          <source>You may notice that, with the exception of Meteor platform packages, all packages on Atmosphere have a name of the form &lt;code&gt;prefix:package-name&lt;/code&gt;. The prefix is the Meteor Developer username of the organization or user that published the package. Meteor uses such a convention for package naming to make sure that it&amp;rsquo;s clear who has published a certain package, and to avoid an ad-hoc namespacing convention. Meteor platform packages do not have any &lt;code&gt;prefix:&lt;/code&gt;.</source>
          <target state="translated">Meteor 플랫폼 패키지를 제외하고 Atmosphere의 모든 패키지 이름은 &lt;code&gt;prefix:package-name&lt;/code&gt; 형식 입니다. 접두사는 패키지를 게시 한 조직 또는 사용자의 Meteor Developer 사용자 이름입니다. Meteor는 패키지 명명에 이러한 규칙을 사용하여 누가 특정 패키지를 게시했는지 명확하게하고 임시 네임 스페이스 규칙을 피합니다. Meteor 플랫폼 패키지에는 &lt;code&gt;prefix:&lt;/code&gt; 가 없습니다 : .</target>
        </trans-unit>
        <trans-unit id="480387cb61cb7ba5a817f84602da8f194071d532" translate="yes" xml:space="preserve">
          <source>You may want to override the compatibility version if you want hot code push to reach older apps that don&amp;rsquo;t have the latest version of your native code from the app store. Let&amp;rsquo;s say you&amp;rsquo;re developing an iOS app, you have the plugin &lt;code&gt;cordova-plugin-camera@2.4.0&lt;/code&gt;, and your app has the compatibility version pictured above, &lt;code&gt;3ed5b9318b2916b595f7721759ead4d708dfbd46&lt;/code&gt;. If you were to update to version &lt;code&gt;2.4.1&lt;/code&gt; of &lt;code&gt;cordova-plugin-camera&lt;/code&gt;, your server would generate a new compatibility version and your users&amp;rsquo; apps would stop receiving hot code pushes. However, you can tell your server to use the old compatilibity version:</source>
          <target state="translated">핫 코드 푸시가 앱 스토어에서 최신 버전의 기본 코드가없는 이전 앱에 도달하도록하려면 호환성 버전을 재정의 할 수 있습니다. iOS 앱을 개발 &lt;code&gt;cordova-plugin-camera@2.4.0&lt;/code&gt; 플러그인 cordova-plugin-camera@2.4.0 이 있고 앱의 호환성 버전이 &lt;code&gt;3ed5b9318b2916b595f7721759ead4d708dfbd46&lt;/code&gt; 이라고 가정 합니다. 이 버전으로 업데이트 인 경우에 &lt;code&gt;2.4.1&lt;/code&gt; 의 &lt;code&gt;cordova-plugin-camera&lt;/code&gt; , 서버는 핫 코드 푸시 수신을 중지하는 새로운 호환성 버전과 사용자의 애플리케이션을 생성합니다. 그러나 서버에 이전 호환성 버전을 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5517118161752100ae95c4743085b7c6793f3e0" translate="yes" xml:space="preserve">
          <source>You may want to track non-page change related events (for instance publication subscription, or method calls) also. To do so you can use the custom event tracking functionality:</source>
          <target state="translated">비 페이지 변경 관련 이벤트 (예 : 게시 구독 또는 메서드 호출)도 추적 할 수 있습니다. 이를 위해 사용자 정의 이벤트 추적 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad14068ffe4882e6762492f9fc7f94c1f18c977d" translate="yes" xml:space="preserve">
          <source>You might run into a situation where many Methods in your app have the same security checks. This can be simplified by factoring out the security into a separate module, wrapping the Method body, or extending the &lt;code&gt;Mongo.Collection&lt;/code&gt; class to do security inside the &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; implementations on the server. However, implementing your client-server communication via specific Methods is still a good idea rather than sending arbitrary &lt;code&gt;update&lt;/code&gt; operators from the client, since a malicious client can&amp;rsquo;t send an &lt;code&gt;update&lt;/code&gt; operator that you didn&amp;rsquo;t test for.</source>
          <target state="translated">앱의 많은 메소드가 동일한 보안 검사를 갖는 상황이 발생할 수 있습니다. 이는 보안을 별도의 모듈로 분리하거나, 메소드 본문을 랩핑하거나, &lt;code&gt;Mongo.Collection&lt;/code&gt; 클래스를 확장하여 서버 의 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 구현 내에서 보안을 수행 함으로써 단순화 될 수 있습니다 . 그러나 악의적 인 클라이언트는 테스트하지 않은 &lt;code&gt;update&lt;/code&gt; 연산자를 보낼 수 없으므로 특정 방법을 통해 클라이언트-서버 통신을 구현하는 것은 클라이언트 에서 임의의 &lt;code&gt;update&lt;/code&gt; 연산자를 보내는 것이 아니라 여전히 좋은 생각 입니다.</target>
        </trans-unit>
        <trans-unit id="7797a5602e77f30aa23f9f397d14291df3056a7e" translate="yes" xml:space="preserve">
          <source>You must close all HTML tags except the ones specified to have no end tag, like BR, HR, IMG and INPUT. You can write these tags as &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; or equivalently &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">BR, HR, IMG 및 INPUT과 같이 종료 태그가 없도록 지정된 태그를 제외한 모든 HTML 태그를 닫아야합니다. 이 태그를 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 또는 이와 동등한 &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8a7cd629849d965704b4691a76f5d0c59ef0c85" translate="yes" xml:space="preserve">
          <source>You must provide the &lt;code&gt;from&lt;/code&gt; option and at least one of &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt;, and &lt;code&gt;bcc&lt;/code&gt;; all other options are optional.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 옵션과 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;cc&lt;/code&gt; 및 &lt;code&gt;bcc&lt;/code&gt; 중 하나 이상을 제공해야합니다 . 다른 모든 옵션은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="613bb83304959ed4153e2a7554d7321223107489" translate="yes" xml:space="preserve">
          <source>You need to include a &lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; in your body&amp;rsquo;s HTML somewhere of course.</source>
          <target state="translated">물론 몸의 HTML에 &lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 를 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="4be047212ec41d65f51b475be6fd8fe404292cb3" translate="yes" xml:space="preserve">
          <source>You should access stores in the same way you&amp;rsquo;d access other reactive data in your templates&amp;mdash;that means centralizing your store access, much like you centralize your subscribing and data fetch. For a Blaze template, that&amp;rsquo;s either in a helper, or from within a &lt;code&gt;this.autorun()&lt;/code&gt; inside an &lt;code&gt;onCreated()&lt;/code&gt; callback.</source>
          <target state="translated">템플릿의 다른 반응 형 데이터에 액세스하는 것과 같은 방식으로 상점에 액세스해야합니다. 즉, 구독 및 데이터 가져 오기를 중앙 집중화하는 것처럼 상점 액세스를 중앙 집중화해야합니다. Blaze 템플릿의 경우 헬퍼 또는 &lt;code&gt;onCreated()&lt;/code&gt; 콜백 내의 &lt;code&gt;this.autorun()&lt;/code&gt; 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8879023240bd4396cad16507c8521fc47765904f" translate="yes" xml:space="preserve">
          <source>You should be extremely careful about doing this, and always ensure you aren&amp;rsquo;t returning user-generated content (or escape it if you do!) from such a helper.</source>
          <target state="translated">이 작업에 매우주의를 기울여야하며, 항상 도우미에서 사용자 생성 콘텐츠를 반환하지 않아야합니다 (그렇지 않으면 이스케이프하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="08549087f148f7c277d241dcc1dcdc6d0ff81a79" translate="yes" xml:space="preserve">
          <source>You should subscribe to publications from the server from an &lt;code&gt;onCreated&lt;/code&gt; callback (within an &lt;code&gt;autorun&lt;/code&gt; block if you have reactively changing arguments). In the Todos example app, in the &lt;code&gt;Lists_show_page&lt;/code&gt; template we subscribe to the &lt;code&gt;todos.inList&lt;/code&gt; publication based on the current &lt;code&gt;_id&lt;/code&gt; FlowRouter param:</source>
          <target state="translated">&lt;code&gt;onCreated&lt;/code&gt; 콜백 을 통해 서버에서 발행물을 구독해야합니다 ( 인수를 수동으로 변경하는 경우 &lt;code&gt;autorun&lt;/code&gt; 블록 내 ). Todos 예제 앱의 &lt;code&gt;Lists_show_page&lt;/code&gt; 템플릿 에서 현재 &lt;code&gt;_id&lt;/code&gt; FlowRouter 매개 변수를 기반으로 &lt;code&gt;todos.inList&lt;/code&gt; 게시를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="bc2775eb509ea9a26144cc4eb7f44b5dd7ae36ff" translate="yes" xml:space="preserve">
          <source>You should then check the generated &lt;code&gt;node_shrinkwrap/&lt;/code&gt; directory into source control, but ensure it is ignored by your text editor.</source>
          <target state="translated">그런 다음 생성 된 &lt;code&gt;node_shrinkwrap/&lt;/code&gt; 디렉토리를 소스 제어로 점검해야 하지만 텍스트 편집기에서 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="66c226daf843ca8e6cba7357af776299e8c0338d" translate="yes" xml:space="preserve">
          <source>You should use the ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; features to manage your code. This will let you better understand the dependencies between different parts of your code, and it will be easy to know where to look if you need to read the source code of a dependency.</source>
          <target state="translated">ES2015 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 기능을 사용하여 코드를 관리해야합니다. 이를 통해 코드의 여러 부분 간의 종속성을 더 잘 이해할 수 있으며 종속성의 소스 코드를 읽어야하는 경우 어디에서 찾을 수 있는지 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d51b211fc87565ae85755593dea4bd46e042154" translate="yes" xml:space="preserve">
          <source>You should wrap any functionality which relies on a Cordova plugin in a &lt;code&gt;Meteor.startup()&lt;/code&gt; block to make sure the plugin has been fully initialized (by listening to the &lt;code&gt;deviceready&lt;/code&gt; event). For example, when using the Cordova geolocation plugin:</source>
          <target state="translated">&lt;code&gt;Meteor.startup()&lt;/code&gt; 블록 에서 Cordova 플러그인을 사용하는 기능을 랩핑 하여 플러그인이 완전히 초기화되었는지 확인하십시오 ( &lt;code&gt;deviceready&lt;/code&gt; 이벤트를 청취하여 ). 예를 들어, Cordova 지리적 위치 플러그인을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d6ba28d94f3ec5d74bff845de110966d89125010" translate="yes" xml:space="preserve">
          <source>You use methods all the time, because the database mutators (&lt;a href=&quot;#insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#remove&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt;) are implemented as methods. When you call any of these functions on the client, you&amp;rsquo;re invoking their stub version that update the local cache, and sending the same write request to the server. When the server responds, the client updates the local cache with the writes that actually occurred on the server.</source>
          <target state="translated">데이터베이스 뮤 테이터 ( &lt;a href=&quot;#insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#remove&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; )가 메소드로 구현 되므로 메소드를 항상 사용 합니다. 클라이언트에서 이러한 함수를 호출하면 로컬 캐시를 업데이트하는 스텁 버전을 호출하고 서버에 동일한 쓰기 요청을 보냅니다. 서버가 응답하면 클라이언트는 서버에서 실제로 발생한 쓰기로 로컬 캐시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a6fcd201a20fd9b38fb187354839c9d5feb92cec" translate="yes" xml:space="preserve">
          <source>You will also want to show some kind of indication that the method is working in between their click of the button and the redirect completing. Don&amp;rsquo;t forget to provide feedback if the method is returning an error.</source>
          <target state="translated">또한 버튼 클릭과 리디렉션 완료 사이에 방법이 작동하고 있음을 나타내는 표시가 필요합니다. 메소드가 오류를 리턴하는 경우 피드백을 제공하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c2ff7526e0fd0ef6dc980122bb340e5d83684469" translate="yes" xml:space="preserve">
          <source>You will encounter three types of logs in a Meteor Cordova app:</source>
          <target state="translated">Meteor Cordova 앱에서 3 가지 유형의 로그가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f6c8827c0f45795f7d486d0ed929b3901badd41" translate="yes" xml:space="preserve">
          <source>You will have to sign and &lt;code&gt;zipalign&lt;/code&gt; both APKs. You will also have to submit both to the Play Store, see &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;submitting multiple APKs&lt;/a&gt; for more information.</source>
          <target state="translated">두 APK 에 서명하고 &lt;code&gt;zipalign&lt;/code&gt; 해야 합니다. 또한 Play 스토어에 두 가지를 모두 제출해야합니다 . 자세한 내용 은 &lt;a href=&quot;http://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;여러 개의 APK 제출&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0856094a5b5c09e0414432ba50a661a0f2afe398" translate="yes" xml:space="preserve">
          <source>You will have to sign and &lt;code&gt;zipalign&lt;/code&gt; both APKs. You will also have to submit both to the Play Store, see &lt;a href=&quot;https://developer.android.com/google/play/publishing/multiple-apks.html&quot;&gt;submitting multiple APKs&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3bf410faf44328e0141c6e0ed75c7d1940fcf1" translate="yes" xml:space="preserve">
          <source>You will need to pass in the component class with a helper:</source>
          <target state="translated">도우미와 함께 구성 요소 클래스를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ff6535487cf313117c5f2e69e51c24b2e94e078" translate="yes" xml:space="preserve">
          <source>You will probably want to customize the emails &lt;code&gt;accounts-password&lt;/code&gt; will send on your behalf. This can be easily done through the &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_emailtemplates&quot;&gt;&lt;code&gt;Accounts.emailTemplates&lt;/code&gt; API&lt;/a&gt;. Below is some example code from the Todos app:</source>
          <target state="translated">&lt;code&gt;accounts-password&lt;/code&gt; 가 사용자를 대신하여 보낼 이메일을 사용자 정의 할 수 있습니다. 이것은 &lt;a href=&quot;http://docs.meteor.com/#/full/accounts_emailtemplates&quot;&gt; &lt;code&gt;Accounts.emailTemplates&lt;/code&gt; API를&lt;/a&gt; 통해 쉽게 수행 할 수 있습니다 . 아래는 Todos 앱의 예제 코드입니다.</target>
        </trans-unit>
        <trans-unit id="b9e60497380a0d0e7fd7c98d7871a8d07fabaef3" translate="yes" xml:space="preserve">
          <source>You will then have to reload &lt;code&gt;.bash_profile&lt;/code&gt; (by executing &lt;code&gt;source ~/.bash_profile&lt;/code&gt;) or open a new terminal session to apply the new environment.</source>
          <target state="translated">그런 다음 &lt;code&gt;.bash_profile&lt;/code&gt; 을 다시로드 하거나 ( &lt;code&gt;source ~/.bash_profile&lt;/code&gt; 을 실행 하여) 새 터미널 세션을 열어서 새 환경을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="da2d9dc3cf81454dfa3e09ad55298729c27793ad" translate="yes" xml:space="preserve">
          <source>You would invoke it as:</source>
          <target state="translated">다음과 같이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a69667edabb5f55dd20a8a936ca05ca8c4a8c8d3" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll also need to enable the Web Inspector on your iOS device. Go to &lt;em&gt;Settings &amp;gt; Safari &amp;gt; Advanced&lt;/em&gt; and enable &amp;lsquo;Web Inspector&amp;rsquo;:</source>
          <target state="translated">iOS 기기에서 웹 검사기를 활성화해야합니다. &lt;em&gt;설정&amp;gt; Safari&amp;gt; 고급으로&lt;/em&gt; 이동하여 '웹 검사기'를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="f653248bfacd541b98d5458c3c0e8c97a22531ba" translate="yes" xml:space="preserve">
          <source>Your app sees only the exports of the packages that you use directly. If you use package A, and package A uses package B, then you only see package A&amp;rsquo;s exports. Package B&amp;rsquo;s exports don&amp;rsquo;t &amp;ldquo;leak&amp;rdquo; into your namespace just because you used package A. Each app or package only sees their own globals plus the APIs of the packages that they specifically use and depend upon.</source>
          <target state="translated">앱은 직접 사용하는 패키지 내보내기 만 볼 수 있습니다. 패키지 A를 사용하고 패키지 A가 패키지 B를 사용하는 경우 패키지 A의 내보내기 만 표시됩니다. 패키지 B의 내보내기는 패키지 A를 사용했다고해서 네임 스페이스에 &quot;누설&quot;되지 않습니다. 각 앱 또는 패키지는 자체적으로 사용하는 전역과 특별히 사용하고 의존하는 패키지의 API 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a60bf01c71769ba32875a616bbd1e6e581da5f" translate="yes" xml:space="preserve">
          <source>Your client JavaScript bundle can be significantly smaller if you separate out code that a specific type of user will never use.</source>
          <target state="translated">특정 유형의 사용자가 절대 사용하지 않는 코드를 분리하면 클라이언트 JavaScript 번들이 훨씬 작아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b85346c9b63e7d112518073509d10c23fc11779" translate="yes" xml:space="preserve">
          <source>Your collections, as well as the &lt;code&gt;Meteor.users&lt;/code&gt; collection,</source>
          <target state="translated">&lt;code&gt;Meteor.users&lt;/code&gt; 컬렉션 뿐만 아니라 귀하의 컬렉션 ,</target>
        </trans-unit>
        <trans-unit id="b7e989771eb31f770ff05ee04531369bcade571e" translate="yes" xml:space="preserve">
          <source>Your database password.</source>
          <target state="translated">데이터베이스 비밀번호</target>
        </trans-unit>
        <trans-unit id="3b8185f9a4851a44eb3797131162788d510f9ba4" translate="yes" xml:space="preserve">
          <source>a directory with an Xcode project source if iOS is targetted as a mobile platform</source>
          <target state="translated">iOS가 모바일 플랫폼을 대상으로하는 경우 Xcode 프로젝트 소스가있는 디렉토리</target>
        </trans-unit>
        <trans-unit id="6f06478f58a2c8f9a50a939555db380008e3c183" translate="yes" xml:space="preserve">
          <source>a function: for the event to satisfy the matcher, the function must evaluate to true when passed the value of the same property in the event object</source>
          <target state="translated">함수 : 이벤트가 매처를 만족 시키려면 함수가 이벤트 오브젝트에서 동일한 특성 값을 전달할 때 true로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a77d0176448fc334ffe13823e7169116511c84b4" translate="yes" xml:space="preserve">
          <source>a straightforward approach is simply to include the common code as a &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Submodules&quot;&gt;git submodule&lt;/a&gt; of both applications.</source>
          <target state="translated">간단한 접근 방식은 단순히 공통 코드 를 두 응용 프로그램 의 &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Submodules&quot;&gt;git 하위 모듈&lt;/a&gt; 로 포함시키는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="70e3e605f1bcbc94ed03f9011b11f6b2fa51ac31" translate="yes" xml:space="preserve">
          <source>a string: for the event to satisfy the matcher, this value must be equal to the value of the same property in the event object</source>
          <target state="translated">문자열 : 이벤트가 매처를 만족 시키려면이 값이 이벤트 오브젝트의 동일한 특성 값과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f308829cc49a9491fd8b714d523aaa30e68c8ec7" translate="yes" xml:space="preserve">
          <source>a tarball (.tar.gz) that includes everything necessary to run the application server (see the &lt;code&gt;README&lt;/code&gt; in the tarball for details). Using the &lt;code&gt;--directory&lt;/code&gt; option will produce a &lt;code&gt;bundle&lt;/code&gt; directory instead of the tarball.</source>
          <target state="translated">응용 프로그램 서버를 실행하는 데 필요한 모든 것을 포함하는 tarball (.tar.gz) ( 자세한 내용은 tarball 의 &lt;code&gt;README&lt;/code&gt; 를 참조하십시오). &lt;code&gt;--directory&lt;/code&gt; 옵션을 사용하면 tarball 대신 &lt;code&gt;bundle&lt;/code&gt; 디렉토리 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f6d69c202b8f9fe872a7e8d5e9bcb55454000e7" translate="yes" xml:space="preserve">
          <source>accounts-ui</source>
          <target state="translated">accounts-ui</target>
        </trans-unit>
        <trans-unit id="87d2a05490bf43487c105a23530f5c58114fe3ee" translate="yes" xml:space="preserve">
          <source>added(document)or</source>
          <target state="translated">added(document)or</target>
        </trans-unit>
        <trans-unit id="32baf52ba59fafec16a0a1a005603d878aa9fcef" translate="yes" xml:space="preserve">
          <source>added(id, fields)or</source>
          <target state="translated">추가 (ID, 필드) 또는</target>
        </trans-unit>
        <trans-unit id="681e13dbe41dc73aa4b6b1108b2f7012580f98a6" translate="yes" xml:space="preserve">
          <source>addedAt(document, atIndex, before)</source>
          <target state="translated">addedAt (document, atIndex, before)</target>
        </trans-unit>
        <trans-unit id="cd3f32650155ee5e7eaa76b5aa83446bc88e41e0" translate="yes" xml:space="preserve">
          <source>addedBefore(id, fields, before)</source>
          <target state="translated">addedBefore (id, 필드, 이전)</target>
        </trans-unit>
        <trans-unit id="ad845dc5c233de90812e0d92642d8da6f8340c33" translate="yes" xml:space="preserve">
          <source>alanning:roles</source>
          <target state="translated">alanning:roles</target>
        </trans-unit>
        <trans-unit id="a1a857dd38fda4b8de5eed6bce429f7eedefd708" translate="yes" xml:space="preserve">
          <source>allowedBoolean</source>
          <target state="translated">allowedBoolean</target>
        </trans-unit>
        <trans-unit id="a413809824517467fe6e874e5e0a65a327c543d1" translate="yes" xml:space="preserve">
          <source>allowing your type in &lt;a href=&quot;#session&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; variables.</source>
          <target state="translated">&lt;a href=&quot;#session&quot;&gt; &lt;code&gt;Session&lt;/code&gt; &lt;/a&gt; 변수에 유형을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="056c888a3211f88a8b0527c1e6528e47103eac66" translate="yes" xml:space="preserve">
          <source>allowing your type in the return values or arguments to &lt;a href=&quot;#methods_header&quot;&gt;methods&lt;/a&gt;.</source>
          <target state="translated">반환 값 또는 인수를 &lt;a href=&quot;#methods_header&quot;&gt;메소드에&lt;/a&gt; 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f44985d5b80e9a1b5b78395a21677990e50da68" translate="yes" xml:space="preserve">
          <source>alternatively, if you include both applications in a single repository, you can use symbolic links to include the common module inside both apps.</source>
          <target state="translated">또는 두 애플리케이션을 단일 저장소에 모두 포함하는 경우 기호 링크를 사용하여 두 앱 모두에 공통 모듈을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4373ea5720d4d20c2b3214d55fb9e0af933d45ca" translate="yes" xml:space="preserve">
          <source>an unsigned &lt;code&gt;apk&lt;/code&gt; bundle and a project source if Android is targetted as a mobile platform</source>
          <target state="translated">Android가 모바일 플랫폼으로 타겟팅 된 경우 서명되지 않은 &lt;code&gt;apk&lt;/code&gt; 번들 및 프로젝트 소스</target>
        </trans-unit>
        <trans-unit id="9afd00e8c50bfbbea664455202bddf35d54b8a9c" translate="yes" xml:space="preserve">
          <source>and instead call &lt;a href=&quot;#meteor_publish&quot;&gt;&lt;code&gt;Meteor.publish&lt;/code&gt;&lt;/a&gt; to specify which parts of your collection should be published to which users.</source>
          <target state="translated">대신 &lt;a href=&quot;#meteor_publish&quot;&gt; &lt;code&gt;Meteor.publish&lt;/code&gt; &lt;/a&gt; 를 호출 하여 컬렉션의 어느 부분을 어떤 사용자에게 게시 해야하는지 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="48aee7a36f2b83100df312b9edbff502a89b7b77" translate="yes" xml:space="preserve">
          <source>and use the &lt;code&gt;Meteor.loginWithGithub&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;Meteor.loginWithGithub&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c16f370cee25b21f0992cb7c946594f04cf38bf4" translate="yes" xml:space="preserve">
          <source>and you can access &lt;code&gt;AccountsTemplates&lt;/code&gt; via &lt;code&gt;UserAccountsCore.AccountsTemplates&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UserAccountsCore.AccountsTemplates&lt;/code&gt; 를 통해 &lt;code&gt;AccountsTemplates&lt;/code&gt; 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="337553caea598d0d286cbb38bfb16f0dda424eed" translate="yes" xml:space="preserve">
          <source>api.addAssets()</source>
          <target state="translated">api.addAssets()</target>
        </trans-unit>
        <trans-unit id="263ddf06871ccf581a6906beb7782d3bfd2b651a" translate="yes" xml:space="preserve">
          <source>api.addFiles()</source>
          <target state="translated">api.addFiles()</target>
        </trans-unit>
        <trans-unit id="f0e400cce3088a342f2618e9f458aa5203ca354f" translate="yes" xml:space="preserve">
          <source>api.export()</source>
          <target state="translated">api.export()</target>
        </trans-unit>
        <trans-unit id="52a1eb7fdeb6ff5a761c21f8f37c57982f7a9e86" translate="yes" xml:space="preserve">
          <source>api.imply()</source>
          <target state="translated">api.imply()</target>
        </trans-unit>
        <trans-unit id="5b149e74ec94b8db90695d3b5dda3d0c5749a417" translate="yes" xml:space="preserve">
          <source>api.use()</source>
          <target state="translated">api.use()</target>
        </trans-unit>
        <trans-unit id="82a7a0ef25c64de45ca1118dd5524ab3212fcb50" translate="yes" xml:space="preserve">
          <source>api.versionsFrom()</source>
          <target state="translated">api.versionsFrom()</target>
        </trans-unit>
        <trans-unit id="799467800736cc259595fda194df8afa84f3d069" translate="yes" xml:space="preserve">
          <source>apollo</source>
          <target state="translated">apollo</target>
        </trans-unit>
        <trans-unit id="6d003f368abe9913162366183acee34bd1c4af93" translate="yes" xml:space="preserve">
          <source>appcache</source>
          <target state="translated">appcache</target>
        </trans-unit>
        <trans-unit id="322634c19b595675d1343c2e97fa0918a2cbe28f" translate="yes" xml:space="preserve">
          <source>audit-argument-checks</source>
          <target state="translated">audit-argument-checks</target>
        </trans-unit>
        <trans-unit id="cb78c7866bd354810b3988098b2ec83d7efd97dc" translate="yes" xml:space="preserve">
          <source>autopublish</source>
          <target state="translated">autopublish</target>
        </trans-unit>
        <trans-unit id="f4bc6a03d26f76170cdc720bac320958112e8111" translate="yes" xml:space="preserve">
          <source>blaze-html-templates</source>
          <target state="translated">blaze-html-templates</target>
        </trans-unit>
        <trans-unit id="eec8758ec9848c46de47939a142ef18e0cb3ec61" translate="yes" xml:space="preserve">
          <source>bundle-visualizer</source>
          <target state="translated">bundle-visualizer</target>
        </trans-unit>
        <trans-unit id="df7cf341160ad91ea752ecca5a26d4d5d1ab7cbd" translate="yes" xml:space="preserve">
          <source>calls:</source>
          <target state="translated">calls:</target>
        </trans-unit>
        <trans-unit id="85004e4aec3d0bb5ff39ddf66472b9d20484e16c" translate="yes" xml:space="preserve">
          <source>can be rewritten to use CommonJS &lt;code&gt;module.exports&lt;/code&gt;:</source>
          <target state="translated">CommonJS &lt;code&gt;module.exports&lt;/code&gt; 를 사용하도록 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d9ea3c0d7ce1b63b7bc6c804421576c74bcfa35" translate="yes" xml:space="preserve">
          <source>can be written with CommonJS like this:</source>
          <target state="translated">다음과 같이 CommonJS로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="393e268fa535e418ab452aad69e8b29af4fcabe7" translate="yes" xml:space="preserve">
          <source>causes files in your &lt;code&gt;public/online&lt;/code&gt; directory to not be cached, and so they will only be available online. You can then move your large files into that directory and refer to them at the new URL:</source>
          <target state="translated">&lt;code&gt;public/online&lt;/code&gt; 디렉토리의 파일 이 캐시되지 않으므로 온라인에서만 사용할 수 있습니다. 그런 다음 큰 파일을 해당 디렉토리로 이동하여 새 URL에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22feb8a4e84029cbe6237d80b48b21771fcef697" translate="yes" xml:space="preserve">
          <source>changed(id, fields)</source>
          <target state="translated">변경됨 (ID, 필드)</target>
        </trans-unit>
        <trans-unit id="73ef343416195b0aa93d754f66cfb2a698ee1704" translate="yes" xml:space="preserve">
          <source>changed(newDocument, oldDocument) or</source>
          <target state="translated">변경됨 (newDocument, oldDocument) 또는</target>
        </trans-unit>
        <trans-unit id="73b5bcb8160d83003f4ac6a91f265023d6f6d8b3" translate="yes" xml:space="preserve">
          <source>changedAt(newDocument, oldDocument, atIndex)</source>
          <target state="translated">changedAt (newDocument, oldDocument, atIndex)</target>
        </trans-unit>
        <trans-unit id="d56d985300d4b52eb6e189be006f44f8d23c5ec9" translate="yes" xml:space="preserve">
          <source>check</source>
          <target state="translated">check</target>
        </trans-unit>
        <trans-unit id="1f6d22f056609770956ad56fd0a4605ac4c32186" translate="yes" xml:space="preserve">
          <source>chriswessels/meteor-tupperware</source>
          <target state="translated">chriswessels/meteor-tupperware</target>
        </trans-unit>
        <trans-unit id="0bfe991f64a92e574abf91696ef883387dc58d98" translate="yes" xml:space="preserve">
          <source>clientAddressString</source>
          <target state="translated">clientAddressString</target>
        </trans-unit>
        <trans-unit id="b9dc902e551bc0ff53e48b2ec7096990efb51cdb" translate="yes" xml:space="preserve">
          <source>closeFunction</source>
          <target state="translated">closeFunction</target>
        </trans-unit>
        <trans-unit id="f5fbc02e24988b5ca567bcf3a45121224fa91a32" translate="yes" xml:space="preserve">
          <source>coffeescript</source>
          <target state="translated">coffeescript</target>
        </trans-unit>
        <trans-unit id="a3d96f494937846929339ab6fa25cc1872a5a284" translate="yes" xml:space="preserve">
          <source>connectedBoolean</source>
          <target state="translated">connectedBoolean</target>
        </trans-unit>
        <trans-unit id="c487fcb2799f8d2d61d01bf00bacb808b48e7929" translate="yes" xml:space="preserve">
          <source>connectionObject</source>
          <target state="translated">connectionObject</target>
        </trans-unit>
        <trans-unit id="26188050a295ca85745caf9bcf1be2b1b009d853" translate="yes" xml:space="preserve">
          <source>contentString</source>
          <target state="translated">contentString</target>
        </trans-unit>
        <trans-unit id="dea9a7c5509fa8416711d8e51eeee8c363546832" translate="yes" xml:space="preserve">
          <source>currentTargetDOM Element</source>
          <target state="translated">currentTargetDOM 요소</target>
        </trans-unit>
        <trans-unit id="7a4eb3b4c695dc29a4a3bb40c5dde8b7a87ad2bb" translate="yes" xml:space="preserve">
          <source>dataObject or &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">dataObject 또는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0b23868e4456acbebf96fd9f9636f5ac81135c3" translate="yes" xml:space="preserve">
          <source>depend on &lt;code&gt;isobuild:minifier-plugin@1.0.0&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;isobuild:minifier-plugin@1.0.0&lt;/code&gt; 패키지 에 의존</target>
        </trans-unit>
        <trans-unit id="fe2fd87bb819cba67dc48ddae6833aed2f9395fb" translate="yes" xml:space="preserve">
          <source>depend on the &lt;code&gt;isobuild:compiler-plugin@1.0.0&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;isobuild:compiler-plugin@1.0.0&lt;/code&gt; 패키지 에 의존</target>
        </trans-unit>
        <trans-unit id="210638acae66da57ddf80e15b2aa2ed5a2f6e4a0" translate="yes" xml:space="preserve">
          <source>depend on the &lt;code&gt;isobuild:linter-plugin@1.0.0&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;isobuild:linter-plugin@1.0.0&lt;/code&gt; 패키지 에 의존</target>
        </trans-unit>
        <trans-unit id="84fc50220ede69f2f7d823fd283052aef56d4ad2" translate="yes" xml:space="preserve">
          <source>dynamic-import</source>
          <target state="translated">dynamic-import</target>
        </trans-unit>
        <trans-unit id="ffdd886259c31d8aa8f5e64f7987626a20ee013a" translate="yes" xml:space="preserve">
          <source>ecmascript</source>
          <target state="translated">ecmascript</target>
        </trans-unit>
        <trans-unit id="b47a43585289c6f31ef3e4081f4af2b50781a391" translate="yes" xml:space="preserve">
          <source>errorException</source>
          <target state="translated">errorException</target>
        </trans-unit>
        <trans-unit id="8a049923432d3522e804c213f2697a5cd3849ee8" translate="yes" xml:space="preserve">
          <source>es5-shim</source>
          <target state="translated">es5-shim</target>
        </trans-unit>
        <trans-unit id="0db613a2ac6478cf73360eeacae4bc69b9f8dbde" translate="yes" xml:space="preserve">
          <source>function to be called after a rule is executed.</source>
          <target state="translated">규칙이 실행 된 후 호출 될 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ed357dc0ea4edcec2bbf0109e3be571b2141b9e6" translate="yes" xml:space="preserve">
          <source>headersObject</source>
          <target state="translated">headersObject</target>
        </trans-unit>
        <trans-unit id="1c3f7bc2a7736cca7c328899ec167bdea781aae6" translate="yes" xml:space="preserve">
          <source>httpHeadersObject</source>
          <target state="translated">httpHeadersObject</target>
        </trans-unit>
        <trans-unit id="1f24c14a2571bc0a5f8dd92d9d8524a52a9312ea" translate="yes" xml:space="preserve">
          <source>iCalendar event attachment</source>
          <target state="translated">iCalendar 이벤트 첨부</target>
        </trans-unit>
        <trans-unit id="6413e837d316aafcf260786cd21a849f88ae3069" translate="yes" xml:space="preserve">
          <source>iOS</source>
          <target state="translated">iOS</target>
        </trans-unit>
        <trans-unit id="b22e494620da9c73804fad039c471367072572c3" translate="yes" xml:space="preserve">
          <source>iOS App Store</source>
          <target state="translated">iOS 앱 스토어</target>
        </trans-unit>
        <trans-unit id="e24748607671f9e76bea4879f63bd8d68a0f3025" translate="yes" xml:space="preserve">
          <source>idString</source>
          <target state="translated">idString</target>
        </trans-unit>
        <trans-unit id="a2337e8ec6c42d96d125e45bd2a8fdf8c3233d4b" translate="yes" xml:space="preserve">
          <source>insecure</source>
          <target state="translated">insecure</target>
        </trans-unit>
        <trans-unit id="cd680c9a868f19e429854f411d600f738684db22" translate="yes" xml:space="preserve">
          <source>insert(userId, doc)</source>
          <target state="translated">삽입 (userId, doc)</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b016c46ec354cbc4bea797d892262b87c3bd58a" translate="yes" xml:space="preserve">
          <source>isDefaultPrevented()</source>
          <target state="translated">isDefaultPrevented()</target>
        </trans-unit>
        <trans-unit id="55d512020baa96f81e58a174450e28a1a88c39e2" translate="yes" xml:space="preserve">
          <source>isImmediatePropagationStopped()</source>
          <target state="translated">isImmediatePropagationStopped()</target>
        </trans-unit>
        <trans-unit id="776c48ff6073e31bb1c594594e4d39f44c2d54d3" translate="yes" xml:space="preserve">
          <source>isPropagationStopped()</source>
          <target state="translated">isPropagationStopped()</target>
        </trans-unit>
        <trans-unit id="71b71b51e74f77e588b8f6d4fbf399c995cb4b63" translate="yes" xml:space="preserve">
          <source>johanbrook:publication-collector</source>
          <target state="translated">johanbrook:publication-collector</target>
        </trans-unit>
        <trans-unit id="6f2ab963b5a51d155d69ac091e52e506d1055057" translate="yes" xml:space="preserve">
          <source>jquery</source>
          <target state="translated">jquery</target>
        </trans-unit>
        <trans-unit id="ff4a70604b3c4420201a59080331d35228c9f28b" translate="yes" xml:space="preserve">
          <source>jshimko/meteor-launchpad</source>
          <target state="translated">jshimko/meteor-launchpad</target>
        </trans-unit>
        <trans-unit id="c05f6475fd52854d25d68aea3340ac1e5b28e7b5" translate="yes" xml:space="preserve">
          <source>juliancwirko:postcss</source>
          <target state="translated">juliancwirko:postcss</target>
        </trans-unit>
        <trans-unit id="52a1d17ad00685f00f37b61a98744d74988466d3" translate="yes" xml:space="preserve">
          <source>kadira:blaze-layout</source>
          <target state="translated">kadira:blaze-layout</target>
        </trans-unit>
        <trans-unit id="11722dc77961f3026ccf64947faea40c3661d1d7" translate="yes" xml:space="preserve">
          <source>kadira:flow-router</source>
          <target state="translated">kadira:flow-router</target>
        </trans-unit>
        <trans-unit id="0b439cf4e10f87567e60f4b7818ecd57383dc7f0" translate="yes" xml:space="preserve">
          <source>less</source>
          <target state="translated">less</target>
        </trans-unit>
        <trans-unit id="446e52e51c36d579c8101ac4fae2f00bc14a938b" translate="yes" xml:space="preserve">
          <source>mLab</source>
          <target state="translated">mLab</target>
        </trans-unit>
        <trans-unit id="90320b91e55bc2ec44b699d76f6fd9743cac0c81" translate="yes" xml:space="preserve">
          <source>markdown</source>
          <target state="translated">markdown</target>
        </trans-unit>
        <trans-unit id="3baddc005f502139dff2bb2841892b709ef377ee" translate="yes" xml:space="preserve">
          <source>matches pattern?</source>
          <target state="translated">패턴과 일치합니까?</target>
        </trans-unit>
        <trans-unit id="18eded645860e9ac14032e82d301d596df6fe772" translate="yes" xml:space="preserve">
          <source>mdg:validated-method</source>
          <target state="translated">mdg:validated-method</target>
        </trans-unit>
        <trans-unit id="cf2a39f47fea662b4bbe164ebde8a7a9d18f00bf" translate="yes" xml:space="preserve">
          <source>meteor add</source>
          <target state="translated">유성 추가</target>
        </trans-unit>
        <trans-unit id="4162ceb16092221530080a8796a9597abd67317e" translate="yes" xml:space="preserve">
          <source>meteor add package</source>
          <target state="translated">유성 패키지 추가</target>
        </trans-unit>
        <trans-unit id="667b1f95551a4556971c55866bd196b724db80e2" translate="yes" xml:space="preserve">
          <source>meteor add-platform</source>
          <target state="translated">유성 추가 플랫폼</target>
        </trans-unit>
        <trans-unit id="db20c6879752cae48129691f8bb5d754d9af4d0b" translate="yes" xml:space="preserve">
          <source>meteor add-platform platform</source>
          <target state="translated">유성 추가 플랫폼 플랫폼</target>
        </trans-unit>
        <trans-unit id="b4cc825b03053bf2e2541259d881b7535d680a6a" translate="yes" xml:space="preserve">
          <source>meteor admin</source>
          <target state="translated">유성 관리자</target>
        </trans-unit>
        <trans-unit id="99bdc95ebc8ec710c34572e64de8e48c7115e110" translate="yes" xml:space="preserve">
          <source>meteor build</source>
          <target state="translated">유성 빌드</target>
        </trans-unit>
        <trans-unit id="88afe7bf54e1cc1e3392d0b524293af479845320" translate="yes" xml:space="preserve">
          <source>meteor create</source>
          <target state="translated">유성 창조</target>
        </trans-unit>
        <trans-unit id="39380593196060e2d56e0583d23b8ddc499a2a33" translate="yes" xml:space="preserve">
          <source>meteor create name</source>
          <target state="translated">유성 이름을 만들</target>
        </trans-unit>
        <trans-unit id="074fdda244acb9ff36c78cd433278d12fefe4ca6" translate="yes" xml:space="preserve">
          <source>meteor debug</source>
          <target state="translated">유성 디버그</target>
        </trans-unit>
        <trans-unit id="bc3d4ed87c6c372f32a2a153dbdf9bae0c41a15c" translate="yes" xml:space="preserve">
          <source>meteor deploy</source>
          <target state="translated">유성 배치</target>
        </trans-unit>
        <trans-unit id="805f0f097834d349c322be7c837fbffafb694ffe" translate="yes" xml:space="preserve">
          <source>meteor deploy site</source>
          <target state="translated">유성 배포 사이트</target>
        </trans-unit>
        <trans-unit id="e2c90d1fb7d0aa2d9a05db75bc173caad257bb10" translate="yes" xml:space="preserve">
          <source>meteor help</source>
          <target state="translated">유성 도움</target>
        </trans-unit>
        <trans-unit id="e685d60635580bd33b59660777292819324bea43" translate="yes" xml:space="preserve">
          <source>meteor lint</source>
          <target state="translated">유성 보풀</target>
        </trans-unit>
        <trans-unit id="297172c0a5460f8eb736a829eafaa0a1891ab198" translate="yes" xml:space="preserve">
          <source>meteor list</source>
          <target state="translated">유성 목록</target>
        </trans-unit>
        <trans-unit id="1774672a644529f54d533a11c69195350b91480b" translate="yes" xml:space="preserve">
          <source>meteor list-platforms</source>
          <target state="translated">유성 목록 플랫폼</target>
        </trans-unit>
        <trans-unit id="d526fc3bad5ff16795f44d8812bbe8ba7408d861" translate="yes" xml:space="preserve">
          <source>meteor login / logout</source>
          <target state="translated">유성 로그인 / 로그 아웃</target>
        </trans-unit>
        <trans-unit id="9ed6ee46e63af9fa9330a57bb043376c8ec6b821" translate="yes" xml:space="preserve">
          <source>meteor mongo</source>
          <target state="translated">유성 몽고</target>
        </trans-unit>
        <trans-unit id="5f6f267339c41262a61d7487e19a4273597f0e36" translate="yes" xml:space="preserve">
          <source>meteor node</source>
          <target state="translated">유성 노드</target>
        </trans-unit>
        <trans-unit id="70c40393775ede0deeb4a54f86b908acb5cd5bee" translate="yes" xml:space="preserve">
          <source>meteor npm</source>
          <target state="translated">유성 npm</target>
        </trans-unit>
        <trans-unit id="7c1772d10b7c1d6ec0a0ae106c46e9ebd19b9d0b" translate="yes" xml:space="preserve">
          <source>meteor publish</source>
          <target state="translated">유성 출판</target>
        </trans-unit>
        <trans-unit id="be0194d8f1f6619658812507529c3048aa83871b" translate="yes" xml:space="preserve">
          <source>meteor publish-for-arch</source>
          <target state="translated">유성 게시 아치</target>
        </trans-unit>
        <trans-unit id="8ea91d3da1f213360f4bcf4a3abb1455e0966756" translate="yes" xml:space="preserve">
          <source>meteor publish-release</source>
          <target state="translated">유성 출판 출시</target>
        </trans-unit>
        <trans-unit id="fa10d4cbfad6842250a5d0ca24190dc7a87f4436" translate="yes" xml:space="preserve">
          <source>meteor remove</source>
          <target state="translated">유성 제거</target>
        </trans-unit>
        <trans-unit id="9ed6b15a8130c87b930be7f1cbe21492eea47458" translate="yes" xml:space="preserve">
          <source>meteor remove package</source>
          <target state="translated">유성 제거 패키지</target>
        </trans-unit>
        <trans-unit id="5a86b771d74e63ef189705cadf84b9c4f6d87b01" translate="yes" xml:space="preserve">
          <source>meteor remove-platform</source>
          <target state="translated">유성 제거 플랫폼</target>
        </trans-unit>
        <trans-unit id="f1c4f349e355df0bf112878834961365329babf4" translate="yes" xml:space="preserve">
          <source>meteor remove-platform platform</source>
          <target state="translated">유성 제거 플랫폼 플랫폼</target>
        </trans-unit>
        <trans-unit id="199b661e006783c7029b28b68420cf1871ece594" translate="yes" xml:space="preserve">
          <source>meteor reset</source>
          <target state="translated">유성 재설정</target>
        </trans-unit>
        <trans-unit id="702a411f029221565cd8584482209027057fad6c" translate="yes" xml:space="preserve">
          <source>meteor run</source>
          <target state="translated">유성 실행</target>
        </trans-unit>
        <trans-unit id="455a8a0ef13ae2d720a99991dad08a7810a1e000" translate="yes" xml:space="preserve">
          <source>meteor search</source>
          <target state="translated">유성 검색</target>
        </trans-unit>
        <trans-unit id="506b01654468ce52df65961d51ff2f24f6ba9659" translate="yes" xml:space="preserve">
          <source>meteor shell</source>
          <target state="translated">유성 껍질</target>
        </trans-unit>
        <trans-unit id="7e55ac06f7765a190d6c40f5d4cde28cd606c375" translate="yes" xml:space="preserve">
          <source>meteor show</source>
          <target state="translated">유성 쇼</target>
        </trans-unit>
        <trans-unit id="1863c8dd851a8c8877f06fc26a571db8bee3edcf" translate="yes" xml:space="preserve">
          <source>meteor test-packages</source>
          <target state="translated">유성 테스트 패키지</target>
        </trans-unit>
        <trans-unit id="0a78db04edd85aa1bcc0469eef35cd2b8609ae91" translate="yes" xml:space="preserve">
          <source>meteor update</source>
          <target state="translated">유성 업데이트</target>
        </trans-unit>
        <trans-unit id="1990eaae0d3c3a2d5c4549c35edb6c2909d95b3b" translate="yes" xml:space="preserve">
          <source>meteor-base</source>
          <target state="translated">meteor-base</target>
        </trans-unit>
        <trans-unit id="062f313045cb95708db4ed0985a62b0b823c8a4d" translate="yes" xml:space="preserve">
          <source>meteorhacks/meteord</source>
          <target state="translated">meteorhacks/meteord</target>
        </trans-unit>
        <trans-unit id="941e89275636ba30ac463825cb61078cfa9ae272" translate="yes" xml:space="preserve">
          <source>methodArgumentsArray</source>
          <target state="translated">methodArgumentsArray</target>
        </trans-unit>
        <trans-unit id="709ac1a21e00f882c6be74b80fc087c5a61d3908" translate="yes" xml:space="preserve">
          <source>methodNameString</source>
          <target state="translated">methodNameString</target>
        </trans-unit>
        <trans-unit id="73314acfcf0e407857b86ab83676a26ead9fa7f2" translate="yes" xml:space="preserve">
          <source>mobile-experience</source>
          <target state="translated">mobile-experience</target>
        </trans-unit>
        <trans-unit id="e83284a649504ba68fd077c3fd6ad4e7410a34eb" translate="yes" xml:space="preserve">
          <source>module is fetched from the server at runtime.</source>
          <target state="translated">모듈은 런타임에 서버에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="67b5df3a35529734623a1486e386f71fa806e1dd" translate="yes" xml:space="preserve">
          <source>module would be bundled into the initial JavaScript bundle, a dynamically</source>
          <target state="translated">모듈은 초기 JavaScript 번들에 동적으로 번들로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="d8101c974cfd4cab63dd00ac0a5b89f6376ebb83" translate="yes" xml:space="preserve">
          <source>mongo</source>
          <target state="translated">mongo</target>
        </trans-unit>
        <trans-unit id="bef95319d159a10c9b709d5c1aed04e31dd0a96f" translate="yes" xml:space="preserve">
          <source>movedBefore(id, before)</source>
          <target state="translated">movedBefore (id, before)</target>
        </trans-unit>
        <trans-unit id="ca206eae60ca726013e31fbfc6ca73a0738572a3" translate="yes" xml:space="preserve">
          <source>movedTo(document, fromIndex, toIndex, before)</source>
          <target state="translated">movedTo (문서, fromIndex, toIndex, 이전)</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="910f462fe19fdf93943d8fd34bcbfc0954de811f" translate="yes" xml:space="preserve">
          <source>npm Shrinkwrap</source>
          <target state="translated">npm 수축 랩</target>
        </trans-unit>
        <trans-unit id="5035753810f86ca8932b0ce5bcd5a271b58add68" translate="yes" xml:space="preserve">
          <source>npm dependencies</source>
          <target state="translated">npm 종속성</target>
        </trans-unit>
        <trans-unit id="9b9ac73b42b059e722990755c3574ae5935d3739" translate="yes" xml:space="preserve">
          <source>npm is a repository of general JavaScript packages. These packages were originally intended solely for the Node.js server-side environment, but as the JavaScript ecosystem matured, solutions arose to enable the use of npm packages in other environments such as the browser. Today, npm is used for all types of JavaScript packages.</source>
          <target state="translated">npm은 일반적인 JavaScript 패키지의 저장소입니다. 이 패키지는 원래 Node.js 서버 측 환경만을위한 것이지만 JavaScript 에코 시스템이 발전함에 따라 브라우저와 같은 다른 환경에서 npm 패키지를 사용할 수있는 솔루션이 생겼습니다. 현재 npm은 모든 유형의 JavaScript 패키지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5bd46cde7c08be44eff431ccef262f3ffc18be" translate="yes" xml:space="preserve">
          <source>npm on the client</source>
          <target state="translated">클라이언트의 npm</target>
        </trans-unit>
        <trans-unit id="1226cc9ee2ebf50412e803250c7d8dca0de70049" translate="yes" xml:space="preserve">
          <source>npm packages are configured in a &lt;code&gt;package.json&lt;/code&gt; file at the root of your project. If you create a new Meteor project, you will have such a file created for you. If not you can run &lt;code&gt;meteor npm init&lt;/code&gt; to create one.</source>
          <target state="translated">npm 패키지는 프로젝트 루트의 &lt;code&gt;package.json&lt;/code&gt; 파일에서 구성됩니다 . 새 Meteor 프로젝트를 생성하면 그러한 파일이 생성됩니다. 그렇지 않으면 &lt;code&gt;meteor npm init&lt;/code&gt; 를 실행 하여 하나를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4129bf75818a50bb7965907d71d47d194b5244a9" translate="yes" xml:space="preserve">
          <source>number of requests allowed per time interval. Default = 10.</source>
          <target state="translated">시간 간격 당 허용되는 요청 수 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="e3cad9087d59df1fcb6d8b1e44f00fe9edfe17d3" translate="yes" xml:space="preserve">
          <source>oauth-encryption</source>
          <target state="translated">oauth-encryption</target>
        </trans-unit>
        <trans-unit id="bdd377f97f5899b549b58be4c82ee7779d909f2b" translate="yes" xml:space="preserve">
          <source>onCloseFunction</source>
          <target state="translated">onCloseFunction</target>
        </trans-unit>
        <trans-unit id="e71003c6b7dd4093ce139ac0c51a6ba38d54a439" translate="yes" xml:space="preserve">
          <source>outputs</source>
          <target state="translated">outputs</target>
        </trans-unit>
        <trans-unit id="582681c2eae02b3f3d399c0c26d321560f6c567a" translate="yes" xml:space="preserve">
          <source>package</source>
          <target state="translated">package</target>
        </trans-unit>
        <trans-unit id="5a9f1ec8210ba10422a7ced2e302a9a8202bc69e" translate="yes" xml:space="preserve">
          <source>package.js</source>
          <target state="translated">package.js</target>
        </trans-unit>
        <trans-unit id="fd7b034e09b752c24942cd9b0b20c29db2dc3e90" translate="yes" xml:space="preserve">
          <source>params</source>
          <target state="translated">params</target>
        </trans-unit>
        <trans-unit id="3c72abbe626f27d174d80fc434b851cce7bde6d3" translate="yes" xml:space="preserve">
          <source>platform</source>
          <target state="translated">platform</target>
        </trans-unit>
        <trans-unit id="c5902f602739a721c03b66d736b59e404808626e" translate="yes" xml:space="preserve">
          <source>practicalmeteor:mocha</source>
          <target state="translated">practicalmeteor:mocha</target>
        </trans-unit>
        <trans-unit id="b8caa37d2c3b307b03dcd597548444681aed22fc" translate="yes" xml:space="preserve">
          <source>preventDefault()</source>
          <target state="translated">preventDefault()</target>
        </trans-unit>
        <trans-unit id="bfd29548d005c543f55b2f33e265bff1d80542a3" translate="yes" xml:space="preserve">
          <source>publishing objects of your type if you pass them to publish handlers.</source>
          <target state="translated">게시 핸들러로 전달하는 경우 해당 유형의 게시 개체</target>
        </trans-unit>
        <trans-unit id="2d3f674d191956615d3649b2c58b5fb5450d7e3a" translate="yes" xml:space="preserve">
          <source>queryParams</source>
          <target state="translated">queryParams</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">random</target>
        </trans-unit>
        <trans-unit id="d593f709a8526aea211bdac9207b7d32c45271c1" translate="yes" xml:space="preserve">
          <source>reactive-var</source>
          <target state="translated">reactive-var</target>
        </trans-unit>
        <trans-unit id="b295ba3a088a2749141ef4d930011cb33bc650ec" translate="yes" xml:space="preserve">
          <source>ready()</source>
          <target state="translated">ready()</target>
        </trans-unit>
        <trans-unit id="adaa8e57042fde322ad9e847878e803a7d8fd347" translate="yes" xml:space="preserve">
          <source>reasonString or undefined</source>
          <target state="translated">reasonString 또는 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="7d73773099fa8639ebc85ab6ccb6ec6a80d2ba56" translate="yes" xml:space="preserve">
          <source>register a build plugin: &lt;code&gt;Package.registerBuildPlugin({ name, sources, ... });&lt;/code&gt; (see docs)</source>
          <target state="translated">빌드 플러그인을 등록하십시오. &lt;code&gt;Package.registerBuildPlugin({ name, sources, ... });&lt;/code&gt; (문서 참조)</target>
        </trans-unit>
        <trans-unit id="5686cab9d0ba10a4e636be747aba6318c4bf56b8" translate="yes" xml:space="preserve">
          <source>remove(userId, doc)</source>
          <target state="translated">제거 (사용자 ID, 문서)</target>
        </trans-unit>
        <trans-unit id="48b5c64f6710ca64b88178a5264378b28929d282" translate="yes" xml:space="preserve">
          <source>removed(id)</source>
          <target state="translated">removed(id)</target>
        </trans-unit>
        <trans-unit id="01cb54c380b4b86fccbd3d6fc5be0c440d5d8b29" translate="yes" xml:space="preserve">
          <source>removed(oldDocument)or</source>
          <target state="translated">removed(oldDocument)or</target>
        </trans-unit>
        <trans-unit id="6fde0d4145af6f130233103a906937dcc27f2aae" translate="yes" xml:space="preserve">
          <source>removedAt(oldDocument, atIndex)</source>
          <target state="translated">removedAt (oldDocument, atIndex)</target>
        </trans-unit>
        <trans-unit id="eb884f579685f726927154a469130919b8d4a214" translate="yes" xml:space="preserve">
          <source>retryCountNumber</source>
          <target state="translated">retryCountNumber</target>
        </trans-unit>
        <trans-unit id="88d4fec792cb8f94a51f38bdf413822b04ed974c" translate="yes" xml:space="preserve">
          <source>retryTimeNumber or undefined</source>
          <target state="translated">retryTimeNumber 또는 정의되지 않은</target>
        </trans-unit>
        <trans-unit id="0253b19e390f88e6eb6c01226ad518dac0e119ec" translate="yes" xml:space="preserve">
          <source>server-render</source>
          <target state="translated">server-render</target>
        </trans-unit>
        <trans-unit id="246f313d0f99102356e00ed9e499faddf0437e50" translate="yes" xml:space="preserve">
          <source>shell-server</source>
          <target state="translated">shell-server</target>
        </trans-unit>
        <trans-unit id="c099a42a5555825cdb50df0c04932bcd29613457" translate="yes" xml:space="preserve">
          <source>site</source>
          <target state="translated">site</target>
        </trans-unit>
        <trans-unit id="3295ce705f7d58f6c875c2e5d9287d22d24c2f3d" translate="yes" xml:space="preserve">
          <source>spacebars</source>
          <target state="translated">spacebars</target>
        </trans-unit>
        <trans-unit id="f7b760b065b23efe842f84774f27e1606c186508" translate="yes" xml:space="preserve">
          <source>standard-minifier-css</source>
          <target state="translated">standard-minifier-css</target>
        </trans-unit>
        <trans-unit id="c5c935e3078e4856147e3536a1174a89366fd0fe" translate="yes" xml:space="preserve">
          <source>standard-minifier-js</source>
          <target state="translated">standard-minifier-js</target>
        </trans-unit>
        <trans-unit id="b22a2840a91bacb1f6e01d3fc8208988072fe3eb" translate="yes" xml:space="preserve">
          <source>static-html</source>
          <target state="translated">static-html</target>
        </trans-unit>
        <trans-unit id="aa83989c850adcae8ef925148d978bb2e7739501" translate="yes" xml:space="preserve">
          <source>statusCodeNumber</source>
          <target state="translated">statusCodeNumber</target>
        </trans-unit>
        <trans-unit id="e425b3085024e944b20e4f80f32d2184fc3f6376" translate="yes" xml:space="preserve">
          <source>statusString</source>
          <target state="translated">statusString</target>
        </trans-unit>
        <trans-unit id="2391ebebb2e141a6296591ac99a4157e9c94c126" translate="yes" xml:space="preserve">
          <source>stop()</source>
          <target state="translated">stop()</target>
        </trans-unit>
        <trans-unit id="7ef27ab18c03510d2f32b8160dbcd4476dd32b5c" translate="yes" xml:space="preserve">
          <source>stopImmediatePropagation()</source>
          <target state="translated">stopImmediatePropagation()</target>
        </trans-unit>
        <trans-unit id="b15f8f63d4cd5bd1058824e14f73bf9b9ea4affc" translate="yes" xml:space="preserve">
          <source>stopPropagation()</source>
          <target state="translated">stopPropagation()</target>
        </trans-unit>
        <trans-unit id="ad1d082e45e9c9cfeebb7a19362108f51012fdf3" translate="yes" xml:space="preserve">
          <source>storing your type client-side in Minimongo.</source>
          <target state="translated">유형 클라이언트 측을 Minimongo에 저장</target>
        </trans-unit>
        <trans-unit id="754c12b525469a4a0de566c4dcc3572f6937c1d3" translate="yes" xml:space="preserve">
          <source>subscriptionId</source>
          <target state="translated">subscriptionId</target>
        </trans-unit>
        <trans-unit id="63dc4e9af93d170de794a4d1381cd0176730542d" translate="yes" xml:space="preserve">
          <source>targetDOM Element</source>
          <target state="translated">targetDOM 요소</target>
        </trans-unit>
        <trans-unit id="57ccfc6979340891e7fa546f8fe76cbb8070f453" translate="yes" xml:space="preserve">
          <source>then you&amp;rsquo;ll need to import &lt;code&gt;Todos&lt;/code&gt; both in that file and in the test:</source>
          <target state="translated">그런 다음 해당 파일과 테스트에서 모두 &lt;code&gt;Todos&lt;/code&gt; 를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="998ce3c46a62e42e8da88bfa0578dd35e0261470" translate="yes" xml:space="preserve">
          <source>this.added()</source>
          <target state="translated">this.added()</target>
        </trans-unit>
        <trans-unit id="dedb150fbcd5341d63bb5c5fe4c8af9e44bddb6b" translate="yes" xml:space="preserve">
          <source>this.changed()</source>
          <target state="translated">this.changed()</target>
        </trans-unit>
        <trans-unit id="dcaee1dbdb8dee3d73923fa3979be501265a1633" translate="yes" xml:space="preserve">
          <source>this.connection</source>
          <target state="translated">this.connection</target>
        </trans-unit>
        <trans-unit id="648515391fe232cdbe01bfaa097913307421f900" translate="yes" xml:space="preserve">
          <source>this.error()</source>
          <target state="translated">this.error()</target>
        </trans-unit>
        <trans-unit id="56b4a9013193acb055264f70bdc3216bb7025e94" translate="yes" xml:space="preserve">
          <source>this.isSimulation</source>
          <target state="translated">this.isSimulation</target>
        </trans-unit>
        <trans-unit id="454626c560d7c9c3f8a51b43bfff6d84a5acc256" translate="yes" xml:space="preserve">
          <source>this.onStop()</source>
          <target state="translated">this.onStop()</target>
        </trans-unit>
        <trans-unit id="6737c79d410b920b0054902750ef22374dbdf7c7" translate="yes" xml:space="preserve">
          <source>this.ready()</source>
          <target state="translated">this.ready()</target>
        </trans-unit>
        <trans-unit id="89afe52b86c3889f25fa2278cb337d0a1658f2ee" translate="yes" xml:space="preserve">
          <source>this.removed()</source>
          <target state="translated">this.removed()</target>
        </trans-unit>
        <trans-unit id="820a06fcb7f5b40a96f42159f3a900998789f728" translate="yes" xml:space="preserve">
          <source>this.setUserId()</source>
          <target state="translated">this.setUserId()</target>
        </trans-unit>
        <trans-unit id="10e5d9c1da767dac16046d9bb5e88cb510f2a344" translate="yes" xml:space="preserve">
          <source>this.stop()</source>
          <target state="translated">this.stop()</target>
        </trans-unit>
        <trans-unit id="b386dda33725f71caed877eab0952302e2808769" translate="yes" xml:space="preserve">
          <source>this.unblock()</source>
          <target state="translated">this.unblock()</target>
        </trans-unit>
        <trans-unit id="22391baea91712e653f15c774a97b60545067b3a" translate="yes" xml:space="preserve">
          <source>this.userId</source>
          <target state="translated">this.userId</target>
        </trans-unit>
        <trans-unit id="26baf33fc32935132ec7550c1383167674b1712a" translate="yes" xml:space="preserve">
          <source>though keep in mind that since the exclusion is by prefix (this is a limitation of the application cache manifest), excluding &lt;code&gt;/largedata.json&lt;/code&gt; will also exclude such URLs as &lt;code&gt;/largedata.json.orig&lt;/code&gt; and &lt;code&gt;/largedata.json/file1&lt;/code&gt;.</source>
          <target state="translated">제외는 접두사에 의한 것이므로 (애플리케이션 캐시 매니페스트의 제한 사항) &lt;code&gt;/largedata.json&lt;/code&gt; 을 제외하면 &lt;code&gt;/largedata.json.orig&lt;/code&gt; 및 &lt;code&gt;/largedata.json/file1&lt;/code&gt; 과 같은 URL도 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec93f2e9b718802cb48e29d13c62409a296b2b6b" translate="yes" xml:space="preserve">
          <source>time interval in milliseconds after which rule's counters are reset. Default = 1000.</source>
          <target state="translated">규칙 카운터가 재설정 된 후의 시간 간격 (밀리 초) 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="8c6ae142dcaf7a80bda8e0fe217f1156a4842ca8" translate="yes" xml:space="preserve">
          <source>tracker</source>
          <target state="translated">tracker</target>
        </trans-unit>
        <trans-unit id="7724755d91bdf156391d60c8e541cc016069f025" translate="yes" xml:space="preserve">
          <source>typeString</source>
          <target state="translated">typeString</target>
        </trans-unit>
        <trans-unit id="64bc6893bc3cd89e154861739424a03acc7fa393" translate="yes" xml:space="preserve">
          <source>underscore</source>
          <target state="translated">underscore</target>
        </trans-unit>
        <trans-unit id="6941455180eddfa012acff6599db3cc19414485f" translate="yes" xml:space="preserve">
          <source>update(userId, doc, fieldNames, modifier)</source>
          <target state="translated">업데이트 (userId, doc, fieldNames, modifier)</target>
        </trans-unit>
        <trans-unit id="1c57162a6cef7912ab8ec25c6f868e465f2ac932" translate="yes" xml:space="preserve">
          <source>userId in DDP</source>
          <target state="translated">DDP의 userId</target>
        </trans-unit>
        <trans-unit id="32fa043bb813fcc7f432930643740540dbb33faf" translate="yes" xml:space="preserve">
          <source>userObject</source>
          <target state="translated">userObject</target>
        </trans-unit>
        <trans-unit id="a5d1b3feae16382df6e19f5a62b83130a10db8b4" translate="yes" xml:space="preserve">
          <source>v.25.&lt;strong&gt;3.0&lt;/strong&gt;&lt;strong&gt;will not work&lt;/strong&gt; due to &lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;extensive changes&lt;/a&gt;. See &lt;a href=&quot;https://github.com/meteor/meteor/issues/8464&quot;&gt;issue #8464&lt;/a&gt; for more information.</source>
          <target state="translated">v.25. &lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;광범위한 변경&lt;/a&gt; 으로 인해 &lt;strong&gt;3.0 &lt;/strong&gt;&lt;strong&gt;이 작동하지 않습니다&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;https://github.com/meteor/meteor/issues/8464&quot;&gt;문제 # 8464&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d2278cd7906e178c08854dde22a1222c0870d337" translate="yes" xml:space="preserve">
          <source>webapp</source>
          <target state="translated">webapp</target>
        </trans-unit>
        <trans-unit id="b4d485bdd0e2fc3d3eb72c008213efa5bfb9b905" translate="yes" xml:space="preserve">
          <source>whichNumber</source>
          <target state="translated">whichNumber</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="1abfabe581e56f5a89f11de2b5983b661f57771e" translate="yes" xml:space="preserve">
          <source>your compatibility version would not change.</source>
          <target state="translated">호환성 버전은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f879ca3ed1a06d3391c60c86cbd53b0b71323d" translate="yes" xml:space="preserve">
          <source>{ _id: &amp;ldquo;1&amp;rdquo;}</source>
          <target state="translated">{_id :&amp;ldquo;1&amp;rdquo;}</target>
        </trans-unit>
        <trans-unit id="23755fe1288af72e293d0ea9430da108a7bd4a9a" translate="yes" xml:space="preserve">
          <source>{ _id: &amp;ldquo;eMtGij5AFESbTKfkT&amp;rdquo;}</source>
          <target state="translated">{_id :&amp;ldquo;eMtGij5AFESbTKfkT&amp;rdquo;}</target>
        </trans-unit>
        <trans-unit id="deecf398b57231a458c154b9c72c8cd28568a836" translate="yes" xml:space="preserve">
          <source>{ todoSort: &amp;ldquo;top&amp;rdquo; }</source>
          <target state="translated">{todoSort : &quot;상위&quot;}</target>
        </trans-unit>
        <trans-unit id="4448e1dbcb7f6e8f55f2f5b257a1169d8c4db209" translate="yes" xml:space="preserve">
          <source>{ }</source>
          <target state="translated">{}</target>
        </trans-unit>
        <trans-unit id="ade57cfa4384f99c7aa2665116aa623962e92578" translate="yes" xml:space="preserve">
          <source>{{ currentUser }}</source>
          <target state="translated">{{ 현재 사용자 }}</target>
        </trans-unit>
        <trans-unit id="8fdf813e9b8965614d6ba010b7f33c56eea39d31" translate="yes" xml:space="preserve">
          <source>{{ loggingIn }}</source>
          <target state="translated">{{loggingIn}}</target>
        </trans-unit>
        <trans-unit id="091a9c159802ba71c70f9fc01b633d56d0f8951a" translate="yes" xml:space="preserve">
          <source>{{&amp;gt; Template.dynamic }}</source>
          <target state="translated">{{&amp;gt; Template.dynamic}}</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
