<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="37cbf6da85f81293291a3c0f70bd83d035bcf72f" translate="yes" xml:space="preserve">
          <source>Causing infinite loops etc.</source>
          <target state="translated">무한 루프 등 발생</target>
        </trans-unit>
        <trans-unit id="b643ecf0f138f7f21c8987e5e43245e6d526028e" translate="yes" xml:space="preserve">
          <source>Causing signals (especially SIGFPE and SIGALARM) to affect your process.</source>
          <target state="translated">신호에 영향을 미치므로 (특히 SIGFPE 및 SIGALARM) 공정에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="f78acd3020c7919c3876959d6358cd31ff6af003" translate="yes" xml:space="preserve">
          <source>Caution : use this option only if you know that your coderefs will be properly reconstructed by &lt;code&gt;B::Deparse&lt;/code&gt; .</source>
          <target state="translated">주의 :이 옵션은 &lt;code&gt;B::Deparse&lt;/code&gt; 의해 코드 참조가 올바르게 재구성 될 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ad563e2579a1d16afd8a48937c2a4c8af5b92ac" translate="yes" xml:space="preserve">
          <source>Caution : use this option only if you know that your coderefs will be properly reconstructed by &lt;code&gt;B::Deparse&lt;/code&gt;.</source>
          <target state="translated">주의 : 코드 참조가 &lt;code&gt;B::Deparse&lt;/code&gt; 의해 올바르게 재구성된다는 것을 알고있는 경우에만이 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="6c45fe1a67bfe92ba6c4b2119ad5a8061d201ed7" translate="yes" xml:space="preserve">
          <source>Caveat: this is a bit of a kludge. In particular note that if anything that appears on STDERR looks like a test result the test harness will get confused. Use this option only if you understand the consequences and can live with the risk.</source>
          <target state="translated">경고 : 이것은 약간의 혼란입니다. 특히 STDERR에 나타나는 것이 테스트 결과처럼 보이는 경우 테스트 하네스가 혼동 될 수 있습니다. 결과를 이해하고 위험을 감수 할 수있는 경우에만이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="ff751acd8ebba60eb35fa0124046207c1b17cdf6" translate="yes" xml:space="preserve">
          <source>Caveats mentioned in the description of &lt;code&gt;$!&lt;/code&gt; generally apply to &lt;code&gt;$^E&lt;/code&gt; , also.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 설명에 언급 된주의 사항 ! 일반적으로 &lt;code&gt;$^E&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="edc717de27ac4961ab4fdc9df6b9f7edd3ca7ed3" translate="yes" xml:space="preserve">
          <source>Caveats mentioned in the description of &lt;code&gt;&lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;&lt;/code&gt; generally apply to &lt;code&gt;$^E&lt;/code&gt;, also.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;&lt;/code&gt; 설명에 언급 된주의 사항 일반적으로 &lt;code&gt;$^E&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2480f4a426ee72a3f6daf975f41b3976cd3d2933" translate="yes" xml:space="preserve">
          <source>Caveats:</source>
          <target state="translated">Caveats:</target>
        </trans-unit>
        <trans-unit id="f904f3f198a1560f6503e45c25c6ea2281d83a7a" translate="yes" xml:space="preserve">
          <source>Central America</source>
          <target state="translated">중앙 아메리카</target>
        </trans-unit>
        <trans-unit id="09fe478d9ba3d71f7c5e36ee02ee955b6c719e87" translate="yes" xml:space="preserve">
          <source>Centralized management of resources</source>
          <target state="translated">중앙 집중식 자원 관리</target>
        </trans-unit>
        <trans-unit id="e7fb0f6eb972f6f903d5d8421fe8c063e2da1bee" translate="yes" xml:space="preserve">
          <source>Cerebral C and C++ programmers should take note of the following:</source>
          <target state="translated">대뇌 C 및 C ++ 프로그래머는 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="098ac784d3c3bb2be5336c055d431de5a978080e" translate="yes" xml:space="preserve">
          <source>Certain Perl operations that are set-up within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; retain that effect even outside the scope. These include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 범위 내에서 설정된 특정 Perl 조작 밖에서도 그 영향을 유지합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e4b96ee87d74a7f64e565d1787fa16238cdf53ec" translate="yes" xml:space="preserve">
          <source>Certain Perl operations that are set-up within the scope of a &lt;code&gt;use locale&lt;/code&gt; retain that effect even outside the scope. These include:</source>
          <target state="translated">&lt;code&gt;use locale&lt;/code&gt; 범위 내에서 설정된 특정 Perl 작업은 범위 밖에서도 해당 효과를 유지합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e445bdfbac84e85f57db984a7caae903e4414a5a" translate="yes" xml:space="preserve">
          <source>Certain SV types are considered 'special'. They're represented by B::SPECIAL and are referred to by a number from the specialsv_list. This array maps that number back to the name of the SV (like 'Nullsv' or '&amp;amp;PL_sv_undef').</source>
          <target state="translated">특정 SV 유형은 '특별한'것으로 간주됩니다. B :: SPECIAL로 표시되며 specialsv_list의 숫자로 나타납니다. 이 배열은 해당 숫자를 SV 이름 (예 : 'Nullsv'또는 '&amp;amp; PL_sv_undef')에 다시 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8edd6c5378e389e68c51d5a29d8332712fb8e453" translate="yes" xml:space="preserve">
          <source>Certain Win32 programs called from cygwin programs might need some environment variable, such as e.g. ADODB needs %COMMONPROGRAMFILES%. Call Cygwin::sync_winenv() to copy all Win32 environment variables to your process and note that cygwin will warn on every encounter of non-POSIX paths.</source>
          <target state="translated">cygwin 프로그램에서 호출 된 특정 Win32 프로그램은 ADODB에 % COMMONPROGRAMFILES %와 같은 일부 환경 변수가 필요할 수 있습니다. Cygwin :: sync_winenv ()를 호출하여 모든 Win32 환경 변수를 프로세스에 복사하고 cygwin은 POSIX가 아닌 경로가 발생할 때마다 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0c5660d59e9ee01e56352c20048bf93f027e41cc" translate="yes" xml:space="preserve">
          <source>Certain built-in Unix features help prevent this most of the time. For instance, filehandles have a &quot;close on exec&quot; flag, which is set</source>
          <target state="translated">특정 내장 Unix 기능은 대부분의 시간을 막습니다. 예를 들어, 파일 핸들에는 &quot;close on exec&quot;플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e1ceadd8b0aea91be4cf67f149af0de9a680656" translate="yes" xml:space="preserve">
          <source>Certain code points are considered problematic. These are Unicode surrogates, Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF. By default these are considered regular code points, but certain situations warrant special handling for them, which can be specified using the &lt;code&gt;flags&lt;/code&gt; parameter. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, all three classes are treated as malformations and handled as such. The flags &lt;code&gt;UTF8_DISALLOW_SURROGATE&lt;/code&gt;, &lt;code&gt;UTF8_DISALLOW_NONCHAR&lt;/code&gt;, and &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; (meaning above the legal Unicode maximum) can be set to disallow these categories individually. &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; restricts the allowed inputs to the strict UTF-8 traditionally defined by Unicode. Use &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; to use the strictness definition given by &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. The difference between traditional strictness and C9 strictness is that the latter does not forbid non-character code points. (They are still discouraged, however.) For more discussion see &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="translated">특정 코드 포인트는 문제가있는 것으로 간주됩니다. 이들은 유니 코드 서로 게이트, 유니 코드 비 문자 및 유니 코드 최대 값 인 0x10FFFF를 초과하는 코드 포인트입니다. 기본적으로 이들은 일반 코드 포인트로 간주되지만 특정 상황에서는 &lt;code&gt;flags&lt;/code&gt; 매개 변수를 사용하여 지정할 수있는 특수 처리가 필요합니다 . &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; 가 포함 된 경우 세 클래스 모두 기형으로 처리되고 그대로 처리됩니다. 플래그 &lt;code&gt;UTF8_DISALLOW_SURROGATE&lt;/code&gt; , &lt;code&gt;UTF8_DISALLOW_NONCHAR&lt;/code&gt; 및 &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; (법적인 유니 코드 최대 값 이상을 의미 함)는 이러한 범주를 개별적으로 허용하지 않도록 설정할 수 있습니다. &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; 허용 된 입력을 전통적으로 유니 코드로 정의 된 엄격한 UTF-8로 제한합니다. 사용 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; 는 에 의해 주어진 엄격 정의를 사용하는 &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;유니 코드 정오표의 # 9&lt;/a&gt; . 전통적인 엄격 성과 C9 엄격 성의 차이점은 후자는 비 문자 코드 포인트를 금지하지 않는다는 것입니다. (그러나 여전히 권장되지 않습니다.) 자세한 내용은 &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;perlunicode의 &quot;비 문자 코드 포인트&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd014b85703f4f23ce05ad07fc9ca7afcd931605" translate="yes" xml:space="preserve">
          <source>Certain code points are considered problematic. These are Unicode surrogates, Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF. By default these are considered regular code points, but certain situations warrant special handling for them. If &lt;code&gt;flags&lt;/code&gt; contains UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as malformations and handled as such. The flags UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal Unicode maximum) can be set to disallow these categories individually.</source>
          <target state="translated">특정 코드 포인트는 문제가있는 것으로 간주됩니다. 유니 코드 대리자, 유니 코드 비 문자 및 유니 코드 최대 0x10FFFF를 초과하는 코드 포인트입니다. 기본적으로 이들은 일반적인 코드 포인트로 간주되지만 특정 상황에서는 특별한 처리가 필요합니다. &lt;code&gt;flags&lt;/code&gt; 에 UTF8_DISALLOW_ILLEGAL_INTERCHANGE가 포함 된 경우 세 클래스 모두 기형으로 처리되어 처리됩니다. UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR 및 UTF8_DISALLOW_SUPER 플래그 (법적 유니 코드 최대 값 이상)는 이러한 범주를 개별적으로 허용하지 않도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02926fb30feba66eb4b4ce45a0942f1b38d9143" translate="yes" xml:space="preserve">
          <source>Certain file systems have a limited ability to store the times on a file at the expected level of precision. For example, the FAT and HPFS filesystem are unable to create dates on files with a finer granularity than two seconds. This is a limitation of the filesystems, not of utime().</source>
          <target state="translated">특정 파일 시스템은 파일에 예상 정확도 수준으로 시간을 저장하는 기능이 제한되어 있습니다. 예를 들어 FAT 및 HPFS 파일 시스템은 2 초보다 세분화 된 파일에서 날짜를 만들 수 없습니다. 이것은 utime ()이 아닌 파일 시스템의 한계입니다.</target>
        </trans-unit>
        <trans-unit id="37d5dc51bb3f3e8f5f3c6c97dff5e509bb4e1f21" translate="yes" xml:space="preserve">
          <source>Certain glyph variations for character display are standardized. This lists the non-Unihan ones; the Unihan ones are also not used by Perl, and are in a separate Unicode data base &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</source>
          <target state="translated">문자 표시를위한 특정 글리프 변형이 표준화됩니다. 여기에는 비 유니 한 것들이 나열됩니다. Unihan은 Perl에서도 사용되지 않으며 별도의 유니 코드 데이터베이스 ( &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd)에 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e533d3ad8c20d01d8ecf9ab421d4077df153545a" translate="yes" xml:space="preserve">
          <source>Certain instances became fatal in Perl 5.28; others in perl 5.32.</source>
          <target state="translated">특정 인스턴스는 Perl 5.28에서 치명적이었습니다. Perl 5.32.의 기타</target>
        </trans-unit>
        <trans-unit id="d0b6cb7913f706e7a5eacb52a20195ab75fdb53c" translate="yes" xml:space="preserve">
          <source>Certain internal algorithms used in the implementation of Perl can be attacked by choosing the input carefully to consume large amounts of either time or space or both. This can lead into the so-called</source>
          <target state="translated">Perl 구현에 사용 된 특정 내부 알고리즘은 많은 시간 또는 공간 또는 둘 다를 소비하도록 입력을 신중하게 선택하여 공격 할 수 있습니다. 이것은 소위</target>
        </trans-unit>
        <trans-unit id="96a386c331a35cc383e0fb0a983cc8532170d5c8" translate="yes" xml:space="preserve">
          <source>Certain internal hooks can be also set using the &lt;code&gt;%SIG&lt;/code&gt; hash. The routine indicated by &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; is called when a warning message is about to be printed. The warning message is passed as the first argument. The presence of a &lt;code&gt;__WARN__&lt;/code&gt; hook causes the ordinary printing of warnings to &lt;code&gt;STDERR&lt;/code&gt; to be suppressed. You can use this to save warnings in a variable, or turn warnings into fatal errors, like this:</source>
          <target state="translated">&lt;code&gt;%SIG&lt;/code&gt; 해시를 사용하여 특정 내부 후크를 설정할 수도 있습니다 . &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 표시된 루틴은 경고 메시지가 인쇄 될 때 호출됩니다. 경고 메시지가 첫 번째 인수로 전달됩니다. (A)의 존재 &lt;code&gt;__WARN__&lt;/code&gt; 의 후크에 경고 통상 인쇄 발생 &lt;code&gt;STDERR&lt;/code&gt; 이 억제된다. 이를 사용하여 경고를 변수에 저장하거나 다음과 같이 경고를 치명적인 오류로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64cf21b984a47fe95b3c69dcb71d4d0db67b02a" translate="yes" xml:space="preserve">
          <source>Certain properties are accessible also via core function calls. These are:</source>
          <target state="translated">핵심 속성 호출을 통해서도 특정 속성에 액세스 할 수 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="d27dc694c4a5fbe7b1d7b9b68b009abd079b8811" translate="yes" xml:space="preserve">
          <source>Certain signals like SEGV, ILL, and BUS are generated by virtual memory addressing errors and similar &quot;faults&quot;. These are normally fatal: there is little a Perl-level handler can do with them. So Perl delivers them immediately rather than attempting to defer them.</source>
          <target state="translated">SEGV, ILL 및 BUS와 같은 특정 신호는 가상 메모리 주소 지정 오류 및 유사한 &quot;오류&quot;에 의해 생성됩니다. 이것들은 일반적으로 치명적입니다. Perl 레벨 핸들러가 그들과 함께 할 수있는 일은 거의 없습니다. 따라서 Perl은이를 연기하려고하지 않고 즉시 전달합니다.</target>
        </trans-unit>
        <trans-unit id="50b8ebc63c7a4f1ab576c809f44f4ce8daaac27b" translate="yes" xml:space="preserve">
          <source>Certainly you could write your own code to do this &amp;mdash; or, once again, you could kick that work over to another program. In this case, &lt;code&gt;cat&lt;/code&gt;, running with its own &lt;code&gt;-n&lt;/code&gt; option to activate line numbering, should do the trick:</source>
          <target state="translated">확실히 여러분은 이것을하기 위해 여러분 자신의 코드를 작성할 수 있습니다. 또는 다시 한번, 여러분은 그 작업을 다른 프로그램으로 넘길 수 있습니다. 이 경우 자체 &lt;code&gt;-n&lt;/code&gt; 옵션을 사용하여 행 번호 지정을 활성화 하는 &lt;code&gt;cat&lt;/code&gt; 은 트릭을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d5c6a969ce5b67e0225d17c82fb95228c449920" translate="yes" xml:space="preserve">
          <source>Certificate verification requires a file containing trusted CA certificates.</source>
          <target state="translated">인증서 확인에는 신뢰할 수있는 CA 인증서가 포함 된 파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9669f7ca96bc0e47d1de13f6d426c2b99745d33f" translate="yes" xml:space="preserve">
          <source>Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;전제 조건&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="536f525355145c06eb27b43dd05eceed140e4f71" translate="yes" xml:space="preserve">
          <source>Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b90248a63c8f592d9dd961a96f1170c6b169a4" translate="yes" xml:space="preserve">
          <source>Ch. 15 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Ch. Larry Wall, Tom Christiansen, Jon Orwant 의 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 15 ; 오라일리 및 어소시에이트; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="9fe7a1219b8f1fb95786f557bb47edce5064d4db" translate="yes" xml:space="preserve">
          <source>Ch. 15, pp. 403 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Ch. Larry Wall, Tom Christiansen, Jon Orwant 의 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 의 15, pp. 403 ; 오라일리 및 어소시에이트; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="c1d2b87261dd962ea7037f4bf10689856392c9bc" translate="yes" xml:space="preserve">
          <source>Chad Granum &amp;lt;exodist@cpan.org&amp;gt;</source>
          <target state="translated">Chad Granum &amp;lt;exodist@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5a0c17600e124559bac5dc05a65044b12007a724" translate="yes" xml:space="preserve">
          <source>Chad Granum (EXODIST) &amp;lt;exodist@cpan.org&amp;gt;</source>
          <target state="translated">Chad Granum (EXODIST) &amp;lt;exodist@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b457e42384ae1fdfecf1f9dd9ea5b09206f240a0" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for meta data about the source. This defaults to an empty hashref. See &lt;a href=&quot;#assemble_meta&quot;&gt;&quot;assemble_meta&quot;&lt;/a&gt; for more info.</source>
          <target state="translated">소스에 대한 메타 데이터에 대한 getter / setter 연결. 기본값은 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#assemble_meta&quot;&gt;&quot;assemble_meta&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d493056c1da57a03b23c818e0ed106583a75e9df" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for meta data about the source. This defaults to an empty hashref. See &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; for more info.</source>
          <target state="translated">소스에 대한 메타 데이터에 대한 체인 getter / setter. 기본적으로 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d37cf9e27bcdb9224f76d171f3ec04e137833197" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the configuration of the available source handlers. This is a hashref keyed on handler class whose values contain config to be passed onto the handlers during detection &amp;amp; creation. Class names may be fully qualified or abbreviated, eg:</source>
          <target state="translated">사용 가능한 소스 핸들러 구성을위한 체인화 getter / setter. 이것은 발견 및 생성 중에 핸들러로 전달 될 구성이 값에 포함 된 핸들러 클래스에 키가 지정된 해시 참조입니다. 클래스 이름은 다음과 같이 정규화되거나 약어로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e3ffd2df81751de57a2fcbade1ad6be4b71309" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the flag that dictates whether STDOUT and STDERR should be merged (where appropriate). Defaults to undef.</source>
          <target state="translated">STDOUT과 STDERR의 병합 여부를 지시하는 플래그에 대한 체인 Getter / setter (적절한 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="fa3fa390f5b11b8da2cbd991e38fe6758bc14f24" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line arguments that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">소스에 전달해야하는 명령 행 인수 목록에 대한 getter / setter를 체인으로 연결하십시오 (적절한 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="6875662647c6f1815155ad787b4b2ddda071cbb4" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line switches that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">소스로 전달되어야하는 명령 행 스위치 목록에 대한 체인 getter / setter (해당하는 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="484c910049e12d13347861a5be23f00c8321a0d6" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the raw TAP source. This is a reference, as it may contain large amounts of data (eg: raw TAP).</source>
          <target state="translated">원시 TAP 소스에 대한 체인 게터 / 세터. 이는 많은 양의 데이터 (예 : 원시 TAP)를 포함 할 수 있으므로 참조입니다.</target>
        </trans-unit>
        <trans-unit id="5de177d0512081cef9520546bf06381211cd6854" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the source's configuration, if any has been provided by the user. How it's used is up to you. This defaults to an empty hashref. See &lt;a href=&quot;#config_for&quot;&gt;&quot;config_for&quot;&lt;/a&gt; for more info.</source>
          <target state="translated">사용자가 제공 한 경우 소스 구성에 대한 getter / setter 연결. 사용 방법은 귀하에게 달려 있습니다. 기본값은 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#config_for&quot;&gt;&quot;config_for&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74174c42fd62072d6ee5d0a7398fa78f44559dff" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the source's configuration, if any has been provided by the user. How it's used is up to you. This defaults to an empty hashref. See &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; for more info.</source>
          <target state="translated">사용자가 소스 구성을 제공 한 경우 소스 구성을위한 체인화 getter / setter. 그것이 사용되는 방법은 당신에게 달려 있습니다. 기본적으로 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ffe17af6dc7344517f00a57c19ba135952528bf" translate="yes" xml:space="preserve">
          <source>Chang name from Module::Build::META-spec to CPAN::META::Specification.</source>
          <target state="translated">Module :: Build :: META-spec에서 CPAN :: META :: Specification으로의 Chang 이름입니다.</target>
        </trans-unit>
        <trans-unit id="930947c88d29b6f085064df238c19e6c783d2627" translate="yes" xml:space="preserve">
          <source>Change and/or examine calling process's signal mask. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; and &lt;code&gt;oldsigset&lt;/code&gt; arguments. Consult your system's &lt;code&gt;sigprocmask&lt;/code&gt; manpage for details.</source>
          <target state="translated">호출 프로세스의 신호 마스크를 변경 및 / 또는 검사합니다. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;sigset&lt;/code&gt; 및 &lt;code&gt;oldsigset&lt;/code&gt; 인수. 자세한 내용은 시스템의 &lt;code&gt;sigprocmask&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47d396cd087a5a418e7353a4c45e6745ef5c9209" translate="yes" xml:space="preserve">
          <source>Change directory to /</source>
          <target state="translated">디렉토리를 /로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="6b35e50e6231ecd47c51f9d0f60727b3553c64b4" translate="yes" xml:space="preserve">
          <source>Change directory to the parent of the current directory.</source>
          <target state="translated">디렉토리를 현재 디렉토리의 상위 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="6eba8b030681c63dbaca5c083fcb141f12c78bec" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode.</source>
          <target state="translated">$ file의 모드를 $ mode로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="61d995589ae611e0f4742d3a0cee92270e9ce91b" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode. The mode can be a string or a number which is interpreted as octal whether or not a leading 0 is given.</source>
          <target state="translated">$ file의 모드를 $ mode로 변경하십시오. 모드는 문자열 또는 숫자 일 수 있으며 앞에 0이 제공되는지 여부에 따라 8 진수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3a726567b511b7efb1456c7410856f0769212a35" translate="yes" xml:space="preserve">
          <source>Change owner $file to $uname and $gname.</source>
          <target state="translated">소유자 $ file을 $ uname 및 $ gname으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c8ee54b2a4c58db1f595c468254073b721477b33" translate="yes" xml:space="preserve">
          <source>Change owner of $file to $user. If a $group is given that is changed as well. You can also pass a single parameter with a colon separating the use and group as in 'root:wheel'.</source>
          <target state="translated">$ file의 소유자를 $ user로 변경하십시오. $ group이 주어지면 그것도 변경됩니다. 'root : wheel'에서와 같이 사용 및 그룹을 구분하는 콜론으로 단일 매개 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad1746f9b9be805d4a6fb33e7166d4914a6f334" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate object &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">수축 오브젝트 &lt;code&gt;$d&lt;/code&gt; 의 설정을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a70b55acdbc806db3f9cf83ddddd7fdb5197c49" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate object &lt;code&gt;$d&lt;/code&gt;.</source>
          <target state="translated">deflate 개체 &lt;code&gt;$d&lt;/code&gt; 대한 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="a6d7824dc2aeadd89378b9289a40f5baa46baf4c" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">수축 스트림 &lt;code&gt;$d&lt;/code&gt; 의 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="855b623e66d74b9d1b178db74b447aa56559610a" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$d&lt;/code&gt;.</source>
          <target state="translated">수축 스트림 &lt;code&gt;$d&lt;/code&gt; 대한 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="f11138eabf6401374fb6ae86928421d28ef54011" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$gz&lt;/code&gt; .</source>
          <target state="translated">수축 스트림 &lt;code&gt;$gz&lt;/code&gt; 의 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="74de238b909fa3831ee3e337a8181b892ae78c10" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$gz&lt;/code&gt;.</source>
          <target state="translated">deflate 스트림 &lt;code&gt;$gz&lt;/code&gt; 대한 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="cc239982b98cfe5d4bf5a6e97925df8bb9b66869" translate="yes" xml:space="preserve">
          <source>Change style of array and hash dump. If true, short array may be printed on one line.</source>
          <target state="translated">배열 및 해시 덤프 스타일 변경 참이면 짧은 배열이 한 줄에 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc31075534bc4e1f585b7495788835ad53a5ed8b" translate="yes" xml:space="preserve">
          <source>Change style of string dump. Default value of &lt;code&gt;tick&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; , one can enable either double-quotish dump, or single-quotish by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. By default, characters with high bit set are printed</source>
          <target state="translated">문자열 덤프의 스타일을 변경하십시오. 의 기본값 &lt;code&gt;tick&lt;/code&gt; 입니다 &lt;code&gt;auto&lt;/code&gt; , 하나에 설정하여 두 번 quotish 덤프, 또는 단일 quotish을 활성화 할 수 있습니다 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; . 기본적으로 높은 비트 세트와 문자가 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="c7c77d36bf3e842d4b8fb4ade6b48c7e8524fbf5" translate="yes" xml:space="preserve">
          <source>Change style of string dump. Default value of &lt;code&gt;tick&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, one can enable either double-quotish dump, or single-quotish by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. By default, characters with high bit set are printed</source>
          <target state="translated">문자열 덤프의 스타일을 변경합니다. &lt;code&gt;tick&lt;/code&gt; 의 기본값 은 &lt;code&gt;auto&lt;/code&gt; 이며 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 로 설정하여 큰 따옴표 또는 작은 따옴표를 사용할 수 있습니다 . 기본적으로 높은 비트가 설정된 문자가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f62e18a300604c2d0b5ad8fe35bb69d2aa22ab89" translate="yes" xml:space="preserve">
          <source>Change the line reading:</source>
          <target state="translated">행 판독 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b8669f91f069c7f2a75dd91ca49f0f2e9423b632" translate="yes" xml:space="preserve">
          <source>Change the partition layout of the disk. &lt;code&gt;$pOutBuf&lt;/code&gt; should be &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;$pInBuf&lt;/code&gt; should be a &lt;code&gt;DISK_LAYOUT_INFORMATION&lt;/code&gt; data structure including several &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; data structures.</source>
          <target state="translated">디스크의 파티션 레이아웃을 변경합니다. &lt;code&gt;$pOutBuf&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . &lt;code&gt;$pInBuf&lt;/code&gt; 는 여러 &lt;code&gt;PARTITION_INFORMATION&lt;/code&gt; 데이터 구조를 포함 하는 &lt;code&gt;DISK_LAYOUT_INFORMATION&lt;/code&gt; 데이터 구조 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5ba9e028e71b7c3b6cfe8c3482bc252c2e3c53" translate="yes" xml:space="preserve">
          <source>Change the size of code list window (default is 10 lines).</source>
          <target state="translated">코드 목록 창의 크기를 변경하십시오 (기본값은 10 행).</target>
        </trans-unit>
        <trans-unit id="569c8a1e53a15c2ffb329e7aa5e5500846bb9b87" translate="yes" xml:space="preserve">
          <source>Change the style of array and hash output. If &lt;code&gt;compactDump&lt;/code&gt; , short array may be printed on one line.</source>
          <target state="translated">배열 및 해시 출력 스타일을 변경하십시오. &lt;code&gt;compactDump&lt;/code&gt; 인 경우 짧은 배열이 한 줄에 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0572b73adc9b639f456597dd06554cd0f6cc05cd" translate="yes" xml:space="preserve">
          <source>Change the style of array and hash output. If &lt;code&gt;compactDump&lt;/code&gt;, short array may be printed on one line.</source>
          <target state="translated">배열 및 해시 출력의 스타일을 변경합니다. 경우 &lt;code&gt;compactDump&lt;/code&gt; 짧은 배열은 하나 개의 라인 상에 인쇄 할 수있다.</target>
        </trans-unit>
        <trans-unit id="1ddcd6267b5132268c1d3a6f92ad7c15283dd197" translate="yes" xml:space="preserve">
          <source>Change the style of string dump. The default value for &lt;code&gt;quote&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; ; one can enable double-quotish or single-quotish format by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, respectively. By default, characters with their high bit set are printed verbatim.</source>
          <target state="translated">문자열 덤프 스타일을 변경하십시오. &lt;code&gt;quote&lt;/code&gt; 의 기본값 은 &lt;code&gt;auto&lt;/code&gt; 입니다 . 큰 따옴표 또는 작은 따옴표 형식을 각각 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 . 기본적으로 비트 수가 높은 문자는 그대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b59db7b54f3893729c4a3b0a52e805d2eba1378c" translate="yes" xml:space="preserve">
          <source>Change the style of string dump. The default value for &lt;code&gt;quote&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;; one can enable double-quotish or single-quotish format by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, respectively. By default, characters with their high bit set are printed verbatim.</source>
          <target state="translated">문자열 덤프의 스타일을 변경하십시오. &lt;code&gt;quote&lt;/code&gt; 의 기본값 은 &lt;code&gt;auto&lt;/code&gt; 입니다 . 각각 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 로 설정하여 큰 따옴표 또는 작은 따옴표 형식을 활성화 할 수 있습니다 . 기본적으로 높은 비트가 설정된 문자는 그대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4eef76669da6afcc6f9856d189296d7117faccd7" translate="yes" xml:space="preserve">
          <source>Change the type of the partition. &lt;code&gt;$opOutBuf&lt;/code&gt; should be &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;$pInBuf&lt;/code&gt; should be a &lt;code&gt;SET_PARTITION_INFORMATION&lt;/code&gt; data structure which is just a single byte containing the new partition type [see the &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; export class for a list of known types]:</source>
          <target state="translated">파티션 유형을 변경하십시오. &lt;code&gt;$opOutBuf&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 이어야합니다 . &lt;code&gt;$pInBuf&lt;/code&gt; 는 새 파티션 유형을 포함하는 단일 바이트 인 &lt;code&gt;SET_PARTITION_INFORMATION&lt;/code&gt; 데이터 구조 여야합니다. [ 알려진 유형 목록은 &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; 내보내기 클래스 참조 ] :</target>
        </trans-unit>
        <trans-unit id="38de6175abf6da26b6853e84b1888d7d917d0994" translate="yes" xml:space="preserve">
          <source>Change this to</source>
          <target state="translated">이것을 다음으로 변경하십시오</target>
        </trans-unit>
        <trans-unit id="0558571d851a8433aad3815610abfaf16dab150e" translate="yes" xml:space="preserve">
          <source>Change to an empty directory, and create a placeholder &amp;lt;Makefile.PL&amp;gt;:</source>
          <target state="translated">빈 디렉토리로 변경하고 플레이스 홀더 &amp;lt;Makefile.PL&amp;gt;을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bbbe466cbb3d9bd600f9492fe6485ab273c48d8c" translate="yes" xml:space="preserve">
          <source>Change to the &lt;code&gt;./pod&lt;/code&gt; directory of the build tree, download the Perl logo</source>
          <target state="translated">빌드 트리 의 &lt;code&gt;./pod&lt;/code&gt; 디렉토리로 변경 하고 Perl 로고를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="862ce088bc8e3f533e4bd14af7a6130330f00504" translate="yes" xml:space="preserve">
          <source>Change to the directory of extraction.</source>
          <target state="translated">추출 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1a08104f60eb079d49d12cd925f4ebbd076f6abd" translate="yes" xml:space="preserve">
          <source>Change to the extension directory where its source files are present.</source>
          <target state="translated">소스 파일이있는 확장 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="622a8441b6e400617adf70d8d715f1f671124897" translate="yes" xml:space="preserve">
          <source>Change to the installation directory (most probably ADE:), and extract the binary distribution:</source>
          <target state="translated">설치 디렉토리 (대부분 ADE :)로 변경하고 바이너리 배포판을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe22841ca5b7f3eb852bce99657eae649bc132d" translate="yes" xml:space="preserve">
          <source>Changed 'generated_by' to be mandatory</source>
          <target state="translated">'generated_by'를 필수로 변경</target>
        </trans-unit>
        <trans-unit id="fe067864c4ddea7a2cf4dd4257394cf887e48fd9" translate="yes" xml:space="preserve">
          <source>Changed 'license' to a list and revised the set of valid licenses</source>
          <target state="translated">'라이선스'를 목록으로 변경하고 유효한 라이선스 세트를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="05ee9857664bbd025f8dc08c9054192f5a4ba70b" translate="yes" xml:space="preserve">
          <source>Changed 'license' to be mandatory</source>
          <target state="translated">'라이선스'를 필수로 변경</target>
        </trans-unit>
        <trans-unit id="9bfc844686b44976ffdf32afc2bbc6d5e84d1fb7" translate="yes" xml:space="preserve">
          <source>Changed 'name' to be mandatory</source>
          <target state="translated">'이름'을 필수로 변경</target>
        </trans-unit>
        <trans-unit id="b579ee9bd8e733da6c1f683ab92dd52d015201d5" translate="yes" xml:space="preserve">
          <source>Changed 'optional_features'</source>
          <target state="translated">'optional_features'변경</target>
        </trans-unit>
        <trans-unit id="0e1c9a853d9918f33e6f1e78a544dfe2b9f18d41" translate="yes" xml:space="preserve">
          <source>Changed 'resources' subkey 'bugtracker' to a hash for either web or mailto resource</source>
          <target state="translated">'resources'하위 키 'bugtracker'를 web 또는 mailto 리소스에 대한 해시로 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="83d61a8037cdd7d60908582796ac0f493b14a2fc" translate="yes" xml:space="preserve">
          <source>Changed 'resources' subkey 'repository' to a hash that clarifies repository type, url for browsing and url for checkout</source>
          <target state="translated">'resources'하위 키 'repository'를 저장소 유형, 검색 용 URL 및 체크 아웃 용 URL을 명확히하는 해시로 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="5af24ccd949d33a1adc74637fde3315e088baac1" translate="yes" xml:space="preserve">
          <source>Changed 'version' to be mandatory</source>
          <target state="translated">'버전'을 필수로 변경</target>
        </trans-unit>
        <trans-unit id="093782d21f6c66e7970abb2b02096897e344f3cd" translate="yes" xml:space="preserve">
          <source>Changed &lt;code&gt;authored_by&lt;/code&gt; to &lt;a href=&quot;#author&quot;&gt;&quot;author&quot;&lt;/a&gt;, since that's always been what it's actually called in actual</source>
          <target state="translated">&lt;code&gt;authored_by&lt;/code&gt; 를 &lt;a href=&quot;#author&quot;&gt;&quot;author&quot;로&lt;/a&gt; 변경 했습니다. 이것이 항상 실제로 실제로 호출 된 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="91be31dca7e646c5ba6bd8ea6f84da13d38425e2" translate="yes" xml:space="preserve">
          <source>Changed specification of 'optional_features':</source>
          <target state="translated">'optional_features'사양 변경 :</target>
        </trans-unit>
        <trans-unit id="4160512942c89c6a796514c3260118220f95e06c" translate="yes" xml:space="preserve">
          <source>Changed to use new prereqs data structure instead of individual keys</source>
          <target state="translated">개별 키 대신 새로운 필수 데이터 구조를 사용하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d82ce619d11521a894a962f613af5bfbbfd623ad" translate="yes" xml:space="preserve">
          <source>Changes / enhancements you plan to make in the future.</source>
          <target state="translated">향후 변경 / 향상 될 계획입니다.</target>
        </trans-unit>
        <trans-unit id="4371a5117e6fef40651394dbe58dc03dbb87745b" translate="yes" xml:space="preserve">
          <source>Changes EQUALIZE_TIMESTAMP to set revision date of target file to one second later than source file, since MMK interprets precisely equal revision dates for a source and target file as a sign that the target needs to be updated.</source>
          <target state="translated">MMK는 소스 및 대상 파일에 대해 정확히 동일한 개정 날짜를 대상을 업데이트해야한다는 표시로 해석하므로 EQUALIZE_TIMESTAMP를 변경하여 대상 파일의 개정 날짜를 소스 파일보다 1 초 늦게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="81b572865eb4145038cce91d99f19dba42417f16" translate="yes" xml:space="preserve">
          <source>Changes are always applied directly to the main development branch, called &quot;blead&quot;. Some patches may be backported to a maintenance branch. If you think your patch is appropriate for the maintenance branch (see &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;&quot;MAINTENANCE BRANCHES&quot; in perlpolicy&lt;/a&gt;), please explain why when you submit it.</source>
          <target state="translated">변경 사항은 항상 &quot;blead&quot;라고하는 주요 개발 브랜치에 직접 적용됩니다. 일부 패치는 유지 관리 분기로 백 포트 될 수 있습니다. 패치가 유지 보수 브랜치에 적합하다고 생각되면 ( &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;perlpolicy의 &quot;MAINTENANCE BRANCHES&quot;&lt;/a&gt; 참조 ) 제출할 때 이유를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="4d2ce6a709b5b2cac8d8c837247b977c30d65233" translate="yes" xml:space="preserve">
          <source>Changes are always applied directly to the main development branch, called &quot;blead&quot;. Some patches may be backported to a maintenance branch. If you think your patch is appropriate for the maintenance branch (see &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;MAINTENANCE BRANCHES in perlpolicy&lt;/a&gt;), please explain why when you submit it.</source>
          <target state="translated">변경 사항은 항상 &quot;블레이드&quot;라고하는 기본 개발 지점에 직접 적용됩니다. 일부 패치는 유지 관리 지점으로 백 포트 될 수 있습니다. 패치가 유지 보수 브랜치에 적합하다고 생각되면 ( &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;perlpolicy&lt;/a&gt; 의 유지 보수 지점 참조 ) 제출할 때 이유를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="1aa5832c7b70a5878149d5b5588b7d55b7c3bff5" translate="yes" xml:space="preserve">
          <source>Changes for h2xs as of Perl 5.8.x by Renee Baecker</source>
          <target state="translated">Renee Baecker의 Perl 5.8.x 기준 h2x 변경 사항</target>
        </trans-unit>
        <trans-unit id="62a553e5ccf5c46fdfc0ab8ea84db2a7f76cbebc" translate="yes" xml:space="preserve">
          <source>Changes how to run the linker.</source>
          <target state="translated">링커 실행 방법을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f786f1f1a07415a1d8f2db0065ca900fcd53b8f6" translate="yes" xml:space="preserve">
          <source>Changes in code reference aliasing</source>
          <target state="translated">코드 참조 앨리어싱 변경</target>
        </trans-unit>
        <trans-unit id="be9cab3f4b47428605082907ec95e1b8c3df99df" translate="yes" xml:space="preserve">
          <source>Changes that might break existing code, either on the perl or C level</source>
          <target state="translated">Perl 또는 C 레벨에서 기존 코드를 손상시킬 수있는 변경 사항</target>
        </trans-unit>
        <trans-unit id="ef30b1765940718c3a97213ad99c566c80da7d35" translate="yes" xml:space="preserve">
          <source>Changes the access and modification times on each file of a list of files. The first two elements of the list must be the NUMERIC access and modification times, in that order. Returns the number of files successfully changed. The inode change time of each file is set to the current time. For example, this code has the same effect as the Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch(1)&lt;/a&gt; command when the files</source>
          <target state="translated">파일 목록의 각 파일에 대한 액세스 및 수정 시간을 변경합니다. 목록의 처음 두 요소는 순서대로 NUMERIC 액세스 및 수정 시간이어야합니다. 성공적으로 변경된 파일 수를 반환합니다. 각 파일의 inode 변경 시간은 현재 시간으로 설정됩니다. 예를 들어,이 코드는 파일이 다음과 같은 경우 Unix &lt;a href=&quot;http://man.he.net/man1/touch&quot;&gt;touch (1)&lt;/a&gt; 명령 과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="db0ec37c30cf600ec53fc96678818cec2782658c" translate="yes" xml:space="preserve">
          <source>Changes the access and modification times on each file of a list of files. The first two elements of the list must be the NUMERIC access and modification times, in that order. Returns the number of files successfully changed. The inode change time of each file is set to the current time. For example, this code has the same effect as the Unix touch(1) command when the files</source>
          <target state="translated">파일 목록의 각 파일에 대한 액세스 및 수정 시간을 변경합니다. 목록의 처음 두 요소는 순서대로 NUMERIC 액세스 및 수정 시간이어야합니다. 성공적으로 변경된 파일 수를 반환합니다. 각 파일의 inode 변경 시간은 현재 시간으로 설정됩니다. 예를 들어,이 코드는 파일의 Unix touch (1) 명령과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4b4b4c86467333f8b7a7b80f4a01e7d1918a1a32" translate="yes" xml:space="preserve">
          <source>Changes the name of a file; an existing file NEWNAME will be clobbered. Returns true for success, false otherwise.</source>
          <target state="translated">파일 이름을 변경합니다. 기존 파일 NEWNAME이 삭제됩니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8b1fed7eb953f32d4b671261c0f298f432b77d6" translate="yes" xml:space="preserve">
          <source>Changes the owner (and group) of a list of files. The first two elements of the list must be the</source>
          <target state="translated">파일 목록의 소유자 (및 그룹)를 변경합니다. 목록의 처음 두 요소는</target>
        </trans-unit>
        <trans-unit id="1c7b4f13f0f9f250ad54a523828fe1dadc6bd8b6" translate="yes" xml:space="preserve">
          <source>Changes the path separator with .</source>
          <target state="translated">로 경로 구분 기호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2250a43272b4d912fcb35a54a90fbad3a0416b17" translate="yes" xml:space="preserve">
          <source>Changes the permissions of a list of files. The first element of the list must be the numeric mode, which should probably be an octal number, and which definitely should</source>
          <target state="translated">파일 목록의 권한을 변경합니다. 목록의 첫 번째 요소는 숫자 모드 여야하며, 이는 아마도 8 진수 여야하며 반드시</target>
        </trans-unit>
        <trans-unit id="9bd248973528630e1bf213ec672fc9ef7ebeb306" translate="yes" xml:space="preserve">
          <source>Changes the style of printout of strings. Possible values are &lt;code&gt;unctrl&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; .</source>
          <target state="translated">문자열의 인쇄 스타일을 변경합니다. 가능한 값은 &lt;code&gt;unctrl&lt;/code&gt; 및 &lt;code&gt;quote&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="746a717e68c80b6993dbf023afb108508405fcf6" translate="yes" xml:space="preserve">
          <source>Changes the style of printout of strings. Possible values are &lt;code&gt;unctrl&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt;.</source>
          <target state="translated">문자열의 출력 스타일을 변경합니다. 가능한 값은 &lt;code&gt;unctrl&lt;/code&gt; 및 &lt;code&gt;quote&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e08e00af7afee19133f68fcfa5c4f8c0f8fe0ac1" translate="yes" xml:space="preserve">
          <source>Changes the value of specified keys and returns the changed part.</source>
          <target state="translated">지정된 키의 값을 변경하고 변경된 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3647bf8ac5df1429e21c0b23760ce2722ca59762" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 작업 디렉토리를 EXPR로 변경합니다. EXPR을 생략하면 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 지정된 디렉토리로 변경 됩니다 (설정된 경우). 그렇지 않은 경우 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 지정된 디렉토리로 변경하십시오 . (VMS에서 변수 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; 도 검사되며 설정되어 있으면 사용됩니다.) 둘 다 설정 되지 않으면 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 아무 작업도 수행하지 않습니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 아래 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1086b5985822b0db7454ba706dee00d51c0ece8" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 작업 디렉토리를 EXPR로 변경합니다. EXPR을 생략하면 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 지정된 디렉토리로 변경 됩니다 (설정된 경우). 그렇지 않은 경우 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 지정된 디렉토리로 변경하십시오 . (VMS에서 변수 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; 도 검사되며 설정되어 있으면 사용됩니다.) 둘 다 설정 되지 않으면 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 아무 작업도 수행하지 않습니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 아래 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df4f043dbae922d023318ec21c602939a6ef560c" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt;, if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt;. (Under VMS, the variable &lt;code&gt;$ENV{'SYS$LOGIN'}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;a href=&quot;#chdir-EXPR&quot;&gt;&lt;code&gt;chdir&lt;/code&gt;&lt;/a&gt; does nothing and fails. It returns true on success, false otherwise. See the example under &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 경우 작업 디렉토리를 EXPR로 변경합니다. EXPR이 생략되면 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 지정된 디렉토리로 변경 됩니다 (설정된 경우). 그렇지 않은 경우 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 지정된 디렉토리로 변경합니다 . (VMS에서 &lt;code&gt;$ENV{'SYS$LOGIN'}&lt;/code&gt; 변수 도 검사하고 설정되어 있으면 사용됩니다.) 둘 다 설정되지 않은 경우 &lt;a href=&quot;#chdir-EXPR&quot;&gt; &lt;code&gt;chdir&lt;/code&gt; &lt;/a&gt; 은 아무 작업도 수행하지 않고 실패합니다. 성공하면 true를 반환하고 그렇지 않으면 false를 반환합니다. &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt; 아래의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fabf30bdd6213704e83eeade8922d6faf64b5fd" translate="yes" xml:space="preserve">
          <source>Changes to the array are reflected in the file immediately.</source>
          <target state="translated">배열에 대한 변경 사항은 파일에 즉시 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="6803890e536e93e672442636eafadf71854a5e67" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution associated with this module has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">이 모듈과 연관된 분배가 압축 해제 된 디렉토리로 변경하고 거기에서 서브 쉘을 엽니 다. 서브 쉘을 종료하면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e4202a82c344d58c60462a8105e61b62b6fab966" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">배포가 압축 해제 된 디렉토리로 변경하고 거기에서 서브 쉘을 엽니 다. 서브 쉘을 종료하면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b8731050a8a7a9f8df1483a6a44fb58459c692c8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make clean&lt;/code&gt; there.</source>
          <target state="translated">배포판의 압축을 풀고 실행 한 디렉토리를 변경 &lt;code&gt;make clean&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2cf85dcec97c298d42a66cbcf92705947c20dbb8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make test&lt;/code&gt; there.</source>
          <target state="translated">배포가 풀린 디렉토리를 변경하고 실행 &lt;code&gt;make test&lt;/code&gt; 가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce66a23f208dbab005ac63aadf6ed1d3fdec95de" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs something like</source>
          <target state="translated">배포가 풀린 디렉토리로 변경하고 다음과 같은 것을 실행합니다</target>
        </trans-unit>
        <trans-unit id="936a954c5967e4fb0f809c16524179a6172e7265" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs the external command &lt;code&gt;make install&lt;/code&gt; there. If &lt;code&gt;make&lt;/code&gt; has not yet been run, it will be run first. A &lt;code&gt;make test&lt;/code&gt; is issued in any case and if this fails, the install is cancelled. The cancellation can be avoided by letting &lt;code&gt;force&lt;/code&gt; run the &lt;code&gt;install&lt;/code&gt; for you.</source>
          <target state="translated">배포가 압축 해제 된 디렉토리를 변경하고 외부 명령 &lt;code&gt;make install&lt;/code&gt; 을 실행하십시오 . &lt;code&gt;make&lt;/code&gt; 가 아직 실행되지 않은 경우 먼저 실행됩니다. &lt;code&gt;make test&lt;/code&gt; 어떤 경우에 발행이 실패 할 경우, 취소되어 설치된다. &lt;code&gt;force&lt;/code&gt; &lt;code&gt;install&lt;/code&gt; 를 실행하면 취소를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d2f22b32c63b840e8428c9c499976b73e6154e7" translate="yes" xml:space="preserve">
          <source>Changing &lt;code&gt;IO::Socket&lt;/code&gt;'s default behaviour means that calling the &lt;code&gt;IO::Socket&lt;/code&gt; constructor with either &lt;code&gt;PF_INET&lt;/code&gt; or &lt;code&gt;PF_INET6&lt;/code&gt; as the &lt;code&gt;Domain&lt;/code&gt; parameter will yield an &lt;code&gt;IO::Socket::IP&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;IO::Socket&lt;/code&gt; 의 기본 동작을 변경하면 &lt;code&gt;PF_INET&lt;/code&gt; 또는 &lt;code&gt;PF_INET6&lt;/code&gt; 을 &lt;code&gt;Domain&lt;/code&gt; 매개 변수 로 사용 하여 &lt;code&gt;IO::Socket&lt;/code&gt; 생성자 를 호출 하면 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 개체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e076fc61139c9d1115b2d2eddf0b31da186ab91" translate="yes" xml:space="preserve">
          <source>Changing directory to &quot;&quot; does not fail ?</source>
          <target state="translated">디렉토리를 &quot;&quot;(으)로 변경해도 실패하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="3d3b3f1bc0445ad3c7b600875f43d2f0c065a2c3" translate="yes" xml:space="preserve">
          <source>Changing parts of a string via the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator. (We avoid use of this term to mean &lt;b&gt;variable interpolation&lt;/b&gt;.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자 를 통해 문자열 부분 변경 &lt;b&gt;변수 보간&lt;/b&gt; 을 의미하기 위해이 용어를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="69dfdee69d05801ca9b633c050ee49949268fa02" translate="yes" xml:space="preserve">
          <source>Changing parts of a string via the &lt;code&gt;s///&lt;/code&gt; operator. (We avoid use of this term to mean &lt;b&gt;variable interpolation&lt;/b&gt;.)</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 연산자 를 통해 문자열의 일부를 변경 합니다. ( &lt;b&gt;변수 보간&lt;/b&gt; 을 의미하기 위해이 용어를 사용하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="d7a71579d5e34f224f4b7a44cf8dcd2dbcaa9c26" translate="yes" xml:space="preserve">
          <source>Changing the BTREE sort order</source>
          <target state="translated">BTREE 정렬 순서 변경</target>
        </trans-unit>
        <trans-unit id="e17474358ec9689585fdd62efb80f2dbb797c7f5" translate="yes" xml:space="preserve">
          <source>Changing the case of a scalar, that is, using &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\l&lt;/code&gt; in double-quotish contexts, such as regular expression substitutions.</source>
          <target state="translated">스칼라의 대소 문자 변경, 즉 정규 표현식과 같이 큰 따옴표로 묶은 문맥에서 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\l&lt;/code&gt; 대체.</target>
        </trans-unit>
        <trans-unit id="1e56842505959df6ca38c46b4b80b41e13ef0bc5" translate="yes" xml:space="preserve">
          <source>Changing the case of a scalar, that is, using &lt;code&gt;uc()&lt;/code&gt;, &lt;code&gt;ucfirst()&lt;/code&gt;, &lt;code&gt;lc()&lt;/code&gt;, and &lt;code&gt;lcfirst()&lt;/code&gt;, or &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\l&lt;/code&gt; in double-quotish contexts, such as regular expression substitutions.</source>
          <target state="translated">스칼라의 대소 문자 변경, 즉 &lt;code&gt;uc()&lt;/code&gt; , &lt;code&gt;ucfirst()&lt;/code&gt; , &lt;code&gt;lc()&lt;/code&gt; 및 &lt;code&gt;lcfirst()&lt;/code&gt; 를 사용하거나 정규식과 같은 큰 따옴표 컨텍스트에서 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\l&lt;/code&gt; 대체.</target>
        </trans-unit>
        <trans-unit id="df6f7a30e2f621822d21b001b70407e472b19e52" translate="yes" xml:space="preserve">
          <source>Changing the program's locale should be avoided by XS code. Nevertheless, certain non-Perl libraries called from XS, such as &lt;code&gt;Gtk&lt;/code&gt; do so. When this happens, Perl needs to be told that the locale has changed. Use this function to do so, before returning to Perl.</source>
          <target state="translated">XS 코드로 프로그램 로케일을 변경하지 않아야합니다. 그럼에도 불구하고 &lt;code&gt;Gtk&lt;/code&gt; 와 같은 XS에서 호출 된 비 Perl 라이브러리 는 그렇게합니다. 이 경우, Perl은 로케일이 변경되었음을 알려줘야합니다. Perl로 돌아 가기 전에이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e1948c28b77c30e8fb57b5aff7a3dda34db561" translate="yes" xml:space="preserve">
          <source>Character Class Tests</source>
          <target state="translated">캐릭터 클래스 테스트</target>
        </trans-unit>
        <trans-unit id="09d5ec3fa8dfa6626f64711e08afb866161e2c4e" translate="yes" xml:space="preserve">
          <source>Character Classes and other Special Escapes</source>
          <target state="translated">캐릭터 클래스 및 기타 특수 탈출</target>
        </trans-unit>
        <trans-unit id="34a9fd5b966d1c074e2cee0432c22ae8d6ad1a1d" translate="yes" xml:space="preserve">
          <source>Character Data</source>
          <target state="translated">캐릭터 데이터</target>
        </trans-unit>
        <trans-unit id="f710e107c2984efab355453a12a4c6ea080f5d29" translate="yes" xml:space="preserve">
          <source>Character Encoding Scheme</source>
          <target state="translated">문자 인코딩 체계</target>
        </trans-unit>
        <trans-unit id="4cf0ae92275a457503e6f1502570311bf8750725" translate="yes" xml:space="preserve">
          <source>Character Encodings for Input and Output</source>
          <target state="translated">입력 및 출력을위한 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="20ec21ca7596ab8473642f9e0c8182b338e1d924" translate="yes" xml:space="preserve">
          <source>Character Escapes</source>
          <target state="translated">캐릭터 탈출</target>
        </trans-unit>
        <trans-unit id="70a24f05bd3a1beeddb3d790c2d17711c420ebac" translate="yes" xml:space="preserve">
          <source>Character Ranges</source>
          <target state="translated">문자 범위</target>
        </trans-unit>
        <trans-unit id="d2f44b6bf2d1636aa1643ea45ee60f381bdc2aa5" translate="yes" xml:space="preserve">
          <source>Character Ranges and Classes</source>
          <target state="translated">문자 범위 및 클래스</target>
        </trans-unit>
        <trans-unit id="def6212f0e6caec39a85ca7bef2c8e9c647d0bd2" translate="yes" xml:space="preserve">
          <source>Character and block devices. devmajor and devminor should specify the major and minor device numbers.</source>
          <target state="translated">캐릭터 및 블록 장치. devmajor와 devminor는 주 장치 번호와 부 장치 번호를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fae5ab4ae64b19dd3884a0674108f420e439509e" translate="yes" xml:space="preserve">
          <source>Character case changing</source>
          <target state="translated">대소 문자 변경</target>
        </trans-unit>
        <trans-unit id="5c948c7ed34065b8008d26ee3576913d72d9cc02" translate="yes" xml:space="preserve">
          <source>Character class.</source>
          <target state="translated">캐릭터 클래스.</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="b8d7eaa1fb86bcd30ed62dcabd2cca16ff64d891" translate="yes" xml:space="preserve">
          <source>Character classes also have ordinary and special characters, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; and are matched using an escape:</source>
          <target state="translated">문자 클래스에는 일반 문자와 특수 문자가 있지만 문자 클래스 내부의 일반 문자와 특수 문자 세트는 문자 클래스 외부의 문자와 다릅니다. 문자 클래스의 특수 문자는 &lt;code&gt;-]\^$&lt;/code&gt; 이며 이스케이프를 사용하여 일치합니다.</target>
        </trans-unit>
        <trans-unit id="334bc0b92c2c74eb72d0f1cbef4062f7de8fe371" translate="yes" xml:space="preserve">
          <source>Character classes in regular expressions match based on the character properties specified in the Unicode properties database.</source>
          <target state="translated">정규식의 문자 클래스는 유니 코드 특성 데이터베이스에 지정된 문자 특성을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">문자 분류</target>
        </trans-unit>
        <trans-unit id="0c5cbf9ae05984cb96206744590414bbd855ee84" translate="yes" xml:space="preserve">
          <source>Character code set ID 0037 is a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 0037 is used in North American English locales on the OS/400 operating system that runs on AS/400 computers. CCSID 0037 differs from ISO 8859-1 in 236 places; in other words they agree on only 20 code point values.</source>
          <target state="translated">문자 코드 세트 ID 0037은 ASCII와 Latin-1 문자 (예 : ISO 8859-1)를 EBCDIC 세트에 매핑 한 것입니다. 0037은 AS / 400 컴퓨터에서 실행되는 OS / 400 운영 체제의 북미 영어 로케일에서 사용됩니다. CCSID 0037은 236 개 장소에서 ISO 8859-1과 다릅니다. 즉, 20 개의 코드 포인트 값에만 동의합니다.</target>
        </trans-unit>
        <trans-unit id="40746c1bc8caca4e8597fe4115baf09938eb4d04" translate="yes" xml:space="preserve">
          <source>Character code set ID 1047 is also a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 1047 is used under Unix System Services for OS/390 or z/OS, and OpenEdition for VM/ESA. CCSID 1047 differs from CCSID 0037 in eight places, and from ISO 8859-1 in 236.</source>
          <target state="translated">문자 코드 세트 ID 1047은 ASCII와 Latin-1 문자 (예 : ISO 8859-1)를 EBCDIC 세트에 매핑 한 것입니다. 1047은 OS / 390 또는 z / OS 용 Unix 시스템 서비스 및 VM / ESA 용 OpenEdition에서 사용됩니다. CCSID 1047은 8 곳의 CCSID 0037과 236의 ISO 8859-1과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d32256dddf94c58de00208fb12aedf2f63688834" translate="yes" xml:space="preserve">
          <source>Character encodings in Perl</source>
          <target state="translated">Perl의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="2d10d3301c84a1fea5306a9e0a3b17b5a412a339" translate="yes" xml:space="preserve">
          <source>Character following &quot;\c&quot; must be printable ASCII</source>
          <target state="translated">&quot;\ c&quot;뒤에 오는 문자는 인쇄 가능한 ASCII 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1c549b491b9f34e1abcb580dad4e3f5293c2b051" translate="yes" xml:space="preserve">
          <source>Character following \%c must be '{' or a single-character Unicode property name in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">\ % c 뒤에 오는 문자는 '{'또는 정규식의 단일 문자 유니 코드 속성 이름이어야합니다. &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="7b0607657161e2340ffa7a4beebbbda12ccd68cf" translate="yes" xml:space="preserve">
          <source>Character in '%c' format wrapped in unpack</source>
          <target state="translated">unpack에서 래핑 된 '% c'형식의 문자</target>
        </trans-unit>
        <trans-unit id="1e5b2353a10cbca5544ef51fa95c440fa9cf183b" translate="yes" xml:space="preserve">
          <source>Character in 'C' format wrapped in pack</source>
          <target state="translated">팩에 포장 된 'C'형식의 문자</target>
        </trans-unit>
        <trans-unit id="d19980cf7dd07b0c2ceae0bcd55a36893092a1f6" translate="yes" xml:space="preserve">
          <source>Character in 'W' format wrapped in pack</source>
          <target state="translated">팩에 포장 된 'W'형식의 문자</target>
        </trans-unit>
        <trans-unit id="e366b10c4a9e32d9917de4d038b754077537c5b7" translate="yes" xml:space="preserve">
          <source>Character in 'c' format wrapped in pack</source>
          <target state="translated">팩에 포장 된 'c'형식의 문자</target>
        </trans-unit>
        <trans-unit id="704c519e45bb20896b1cac037d9dc1f99d2661e9" translate="yes" xml:space="preserve">
          <source>Character ranges in regular expression bracketed character classes ( e.g., &lt;code&gt;/[a-z]/&lt;/code&gt; ) and in the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (also known as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) operator are not magically Unicode-aware. What this means is that &lt;code&gt;[A-Za-z]&lt;/code&gt; will not magically start to mean &quot;all alphabetic letters&quot; (not that it does mean that even for 8-bit characters; for those, if you are using locales (&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), use &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; and if not, use the 8-bit-aware property &lt;code&gt;\p{alpha}&lt;/code&gt; ).</source>
          <target state="translated">정규식 대괄호로 묶은 문자 클래스 (예 : &lt;code&gt;/[a-z]/&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 라고도 함 ) 연산자의 문자 범위는 마술처럼 유니 코드를 인식하지 않습니다. 이것이 의미하는 바는 &lt;code&gt;[A-Za-z]&lt;/code&gt; 가 마술처럼 &quot;모든 알파벳 문자&quot;를 의미하지는 않는다는 것입니다 (8 비트 문자의 경우도 마찬가지입니다. 로케일 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; )을 사용하는 경우에는 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; 그렇지 않은 경우 8 비트 인식 속성 &lt;code&gt;\p{alpha}&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="2aad3249cc0562f24dd1bcebe06ca0ccf5f52570" translate="yes" xml:space="preserve">
          <source>Character ranges in regular expression bracketed character classes ( e.g., &lt;code&gt;/[a-z]/&lt;/code&gt;) and in the &lt;code&gt;tr///&lt;/code&gt; (also known as &lt;code&gt;y///&lt;/code&gt;) operator are not magically Unicode-aware. What this means is that &lt;code&gt;[A-Za-z]&lt;/code&gt; will not magically start to mean &quot;all alphabetic letters&quot; (not that it does mean that even for 8-bit characters; for those, if you are using locales (&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), use &lt;code&gt;/[[:alpha:]]/&lt;/code&gt;; and if not, use the 8-bit-aware property &lt;code&gt;\p{alpha}&lt;/code&gt;).</source>
          <target state="translated">정규식 대괄호 문자 클래스 (예 : &lt;code&gt;/[a-z]/&lt;/code&gt; ) 및 &lt;code&gt;tr///&lt;/code&gt; ( &lt;code&gt;y///&lt;/code&gt; 라고도 함 ) 연산자의 문자 범위는 마술처럼 유니 코드를 인식하지 않습니다. 이것이 의미하는 바는 &lt;code&gt;[A-Za-z]&lt;/code&gt; 가 &quot;모든 알파벳 문자&quot;를 의미하는 마법처럼 시작하지 않는다는 것입니다 (8 비트 문자의 경우에도 의미가 아닙니다. 로케일 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; )을 사용하는 경우에는 다음을 사용하십시오. &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; 그렇지 않은 경우 8 비트 인식 속성 &lt;code&gt;\p{alpha}&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab09560bcba17bdf766d4a698ea4d48d5665939a" translate="yes" xml:space="preserve">
          <source>Character set</source>
          <target state="translated">캐릭터 세트</target>
        </trans-unit>
        <trans-unit id="562694c8fa3ccd4702e9b5a3b83e76744b7e6c8c" translate="yes" xml:space="preserve">
          <source>Character set modifier behavior prior to Perl 5.14</source>
          <target state="translated">Perl 5.14 이전의 문자 세트 수정 자 동작</target>
        </trans-unit>
        <trans-unit id="e156811acff779a0efdf0149cf0ae9a427195a9d" translate="yes" xml:space="preserve">
          <source>Character set modifiers</source>
          <target state="translated">문자 세트 수정 자</target>
        </trans-unit>
        <trans-unit id="5b676207ec8a3106cd8805847b93ca527620baf4" translate="yes" xml:space="preserve">
          <source>Character sets and character encoding</source>
          <target state="translated">문자 세트 및 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="854257539f57f0ac53768f96edc002447a2a13c6" translate="yes" xml:space="preserve">
          <source>Character(s) in '%c' format wrapped in pack</source>
          <target state="translated">팩에 래핑 된 '% c'형식의 문자</target>
        </trans-unit>
        <trans-unit id="e3fad3deb369c1ebdb0a0b9d423ca12990358d04" translate="yes" xml:space="preserve">
          <source>Character(s) in '%c' format wrapped in unpack</source>
          <target state="translated">압축 풀기에 래핑 된 '% c'형식의 문자</target>
        </trans-unit>
        <trans-unit id="0dd9c6f6d08e52935fa08236378969d99f092384" translate="yes" xml:space="preserve">
          <source>Characters in Pod documents may be conveyed either as literals, or by number in E&amp;lt;n&amp;gt; codes, or by an equivalent mnemonic, as in E&amp;lt;eacute&amp;gt; which is exactly equivalent to E&amp;lt;233&amp;gt;. The numbers are the Latin1/Unicode values, even on EBCDIC platforms.</source>
          <target state="translated">포드 문서의 문자는 리터럴 또는 E &amp;lt;n&amp;gt; 코드의 숫자 또는 E &amp;lt;233&amp;gt;과 정확히 동일한 E &amp;lt;eacute&amp;gt;와 같은 등가의 니모닉으로 전달 될 수 있습니다. 숫자는 EBCDIC 플랫폼에서도 Latin1 / Unicode 값입니다.</target>
        </trans-unit>
        <trans-unit id="dcec8944860f789b80b281bc04ffb139e54ea11c" translate="yes" xml:space="preserve">
          <source>Characters may be literals or any of the escape sequences accepted in double-quoted strings. But there is no interpolation, so &lt;code&gt;&quot;$&quot;&lt;/code&gt; and &lt;code&gt;&quot;@&quot;&lt;/code&gt; are treated as literals. A hyphen at the beginning or end, or preceded by a backslash is considered a literal. Escape sequence details are in &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;the table near the beginning of this section&lt;/a&gt;. It is a bug in Perl v5.22 that something like</source>
          <target state="translated">문자는 리터럴이거나 큰 따옴표로 묶인 문자열에서 허용되는 이스케이프 시퀀스 일 수 있습니다. 그러나 보간법이 없으므로 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 는 리터럴로 취급됩니다. 시작 또는 끝의 하이픈 또는 백 슬래시가 앞에 오는 문자는 리터럴로 간주됩니다. 이스케이프 시퀀스 세부 정보는 &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;이 섹션의 시작 부분 근처&lt;/a&gt; 에 있는 표에 있습니다 . Perl v5.22의 버그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="163cc83d116a56baee9fe03cafd587b92e5a5bb4" translate="yes" xml:space="preserve">
          <source>Characters may be literals, or (if the delimiters aren't single quotes) any of the escape sequences accepted in double-quoted strings. But there is never any variable interpolation, so &lt;code&gt;&quot;$&quot;&lt;/code&gt; and &lt;code&gt;&quot;@&quot;&lt;/code&gt; are always treated as literals. A hyphen at the beginning or end, or preceded by a backslash is also always considered a literal. Escape sequence details are in &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;the table near the beginning of this section&lt;/a&gt;.</source>
          <target state="translated">문자는 리터럴이거나 (구분자가 작은 따옴표가 아닌 경우) 큰 따옴표로 묶인 문자열에서 허용되는 이스케이프 시퀀스 중 하나 일 수 있습니다. 그러나 변수 보간이 없으므로 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 는 항상 리터럴로 처리됩니다. 시작 또는 끝의 하이픈 또는 백 슬래시가 앞에 오는 것도 항상 리터럴로 간주됩니다. 이스케이프 시퀀스에 대한 자세한 내용은 &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;이 섹션의 시작 부분&lt;/a&gt; 에 있는 표에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9963f5cdbae1775d9f83906b3a5cbef411c1ebf6" translate="yes" xml:space="preserve">
          <source>Characters may be specified using a metacharacter syntax much like that used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a form feed, etc. More generally, \</source>
          <target state="translated">C에서 사용되는 것과 비슷한 메타 문자 구문을 사용하여 문자를 지정할 수 있습니다. &quot;\ n&quot;은 개행, &quot;\ t&quot;탭, &quot;\ r&quot;캐리지 리턴, &quot;\ f&quot;폼 피드 등과 일치합니다. , \</target>
        </trans-unit>
        <trans-unit id="6677fa2bd945e79a1181804df0a34874fe2d47f6" translate="yes" xml:space="preserve">
          <source>Characters that are not coded in logical order and to be rearranged. If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or less than 11, default is:</source>
          <target state="translated">논리적 순서로 코딩되지 않고 재 배열 될 문자 경우 &lt;code&gt;UCA_Version&lt;/code&gt; 이 같거나 11보다 작은, 기본값은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="87ac5130c826b6e80d3a59535b9d6400acad5f5d" translate="yes" xml:space="preserve">
          <source>Characters that may carry a special meaning inside a character class are: &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</source>
          <target state="translated">문자 클래스 내에서 특별한 의미를 가질 수있는 문자는 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 이며 아래에서 설명합니다. 백 슬래시를 사용하여 이스케이프 처리 할 수 ​​있지만, 때로는 필요하지 않지만이 경우 백 슬래시를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8852ce3ecb56edbb61a29ed226d95901da960cba" translate="yes" xml:space="preserve">
          <source>Characters that may carry a special meaning inside a character class are: &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</source>
          <target state="translated">문자 클래스 내에서 특별한 의미를 가질 수있는 문자는 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 이며 아래에서 설명합니다. 때때로 필요하지 않지만 백 슬래시로 이스케이프 할 수 있습니다.이 경우 백 슬래시를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4dafb52fa02eb41cdb895328b5e1fe67da8f211" translate="yes" xml:space="preserve">
          <source>Charles Bailey</source>
          <target state="translated">찰스 베일리</target>
        </trans-unit>
        <trans-unit id="d3be1cf05483936221b495528c8e656819916a6e" translate="yes" xml:space="preserve">
          <source>Charles Bailey &amp;lt;</source>
          <target state="translated">찰스 베일리 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5e62c89e7209c56822c7a94ca2800f8e7a4f3ee5" translate="yes" xml:space="preserve">
          <source>Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</source>
          <target state="translated">Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</target>
        </trans-unit>
        <trans-unit id="9de6174de33823948f5f6b768255de294e0aa21b" translate="yes" xml:space="preserve">
          <source>Charles Bailey bailey@newman.upenn.edu</source>
          <target state="translated">찰스 베일리 bailey@newman.upenn.edu</target>
        </trans-unit>
        <trans-unit id="22cb7bacebab63abf9230cfeb35ec01ffa449880" translate="yes" xml:space="preserve">
          <source>Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc.fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</source>
          <target state="translated">Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc .fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ec77758a3a3e74069b9047f26277c667bea10ea2" translate="yes" xml:space="preserve">
          <source>Charlie Gonzalez &amp;lt;</source>
          <target state="translated">찰리 곤잘레스 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7f45f4145d31345768a09969013e2d6f185c06a1" translate="yes" xml:space="preserve">
          <source>Chdir to the djgpp subdirectory of perl toplevel and type the following commands:</source>
          <target state="translated">perl toplevel의 djgpp 서브 디렉토리에 Chdir을 입력하고 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd62971ab763d962e7526e5485d69c623bb9430" translate="yes" xml:space="preserve">
          <source>Check 2 data structures. Please note that this is a</source>
          <target state="translated">2 개의 데이터 구조를 확인하십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="8940df58b96cd7c07fc9ea07120c785f6f8a4a5c" translate="yes" xml:space="preserve">
          <source>Check a remote host for reachability</source>
          <target state="translated">연결 가능성에 대한 원격 호스트 확인</target>
        </trans-unit>
        <trans-unit id="e185048ce3c07f61069845d16a69507a66ba5ea9" translate="yes" xml:space="preserve">
          <source>Check again</source>
          <target state="translated">다시 확인</target>
        </trans-unit>
        <trans-unit id="d7a845256cebed69e9f121b044f6c493f63a9f2a" translate="yes" xml:space="preserve">
          <source>Check for correct syntax of hyperlinks &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . See &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; for details.</source>
          <target state="translated">하이퍼 링크 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 의 올바른 구문을 확인하십시오 . 자세한 내용은 &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8bdc034e4189b4605128a06513999466ec157b0" translate="yes" xml:space="preserve">
          <source>Check for correct syntax of hyperlinks &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for details.</source>
          <target state="translated">하이퍼 링크 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 의 올바른 구문을 확인하십시오 . 자세한 내용은 &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abb3f832fd190f3b3ed53530b24afb5eea0c92cc" translate="yes" xml:space="preserve">
          <source>Check for duplicate declarations: report any of:</source>
          <target state="translated">중복 선언 확인 : 다음 중 하나를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="958d7ef30eb1cb4c2c9bdb613326b0eabb0fd9a1" translate="yes" xml:space="preserve">
          <source>Check for malformed or non-existing entities &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">잘못되었거나 존재하지 않는 엔터티 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b21e54ef9b2e545471d1f5d2abbe4bbee1c2e36" translate="yes" xml:space="preserve">
          <source>Check for malformed or non-existing entities &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">형식이 잘못되었거나 존재하지 않는 엔티티 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9bacd3ffc2516115599a71ea7b04dc011ace75" translate="yes" xml:space="preserve">
          <source>Check for proper balancing of &lt;code&gt;=begin&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt; . The contents of such a block are generally ignored, i.e. no syntax checks are performed.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 및 &lt;code&gt;=end&lt;/code&gt; 의 적절한 균형을 확인하십시오 . 이러한 블록의 내용은 일반적으로 무시됩니다. 즉, 구문 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40b5ca578f891471ab958e1c6e7d3033f2e0063b" translate="yes" xml:space="preserve">
          <source>Check for proper balancing of &lt;code&gt;=begin&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt;. The contents of such a block are generally ignored, i.e. no syntax checks are performed.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 및 &lt;code&gt;=end&lt;/code&gt; 의 적절한 균형을 확인하십시오 . 이러한 블록의 내용은 일반적으로 무시됩니다. 즉, 구문 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cf90762a2de5be38eed8acc089a711c78e01421" translate="yes" xml:space="preserve">
          <source>Check for proper nesting and balancing of &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; and &lt;code&gt;=back&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; 및 &lt;code&gt;=back&lt;/code&gt; 의 적절한 중첩 및 균형을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1a8d801a59730d1b931118bf7a048ef7c7f5fe9" translate="yes" xml:space="preserve">
          <source>Check for proper nesting and balancing of &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt; and &lt;code&gt;=back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; 및 &lt;code&gt;=back&lt;/code&gt; 의 적절한 중첩 및 균형을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bb965418973274267147c8cc4fc0522a33ac593" translate="yes" xml:space="preserve">
          <source>Check for same nested interior-sequences (e.g. &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">동일한 중첩 된 내부 시퀀스를 확인하십시오 (예 : &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eacd44b00e12dfbcc0672a7ce6d8176f78df3437" translate="yes" xml:space="preserve">
          <source>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</source>
          <target state="translated">cur_env.je_ret의 사례 0 또는 3이 eval 컨텍스트 내에서만 사용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0d6f75515a999669b8c1d54704fc6c80c44584" translate="yes" xml:space="preserve">
          <source>Check for unresolved document-internal links. This check may also reveal misspelled links that seem to be internal links but should be links to something else.</source>
          <target state="translated">해결되지 않은 문서 내부 링크를 확인하십시오. 이 검사는 또한 내부 링크 인 것처럼 보이지만 다른 것으로 링크 된 철자가 틀린 링크를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a7651bd9a47f2d66aae82c5f9a35a8557e3c59a" translate="yes" xml:space="preserve">
          <source>Check if 2 events are related. In this case related means their traces share a signature meaning they were created with the same context (or at the very least by contexts which share an id, which is the same thing unless someone is doing something very bad).</source>
          <target state="translated">2 개의 이벤트가 관련되어 있는지 확인하십시오. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 경우 관련이란 추적이 동일한 컨텍스트로 생성되었음을 의미하는 서명을 공유 함을 의미합니다 (또는 적어도 누군가가 매우 나쁜 일을하지 않는 한 동일한 일인 ID를 공유하는 컨텍스트에 의해 생성됨).</target>
        </trans-unit>
        <trans-unit id="ef8d920f49717c2489195caccccf8fc813cbdb8f" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;$INC{'Test2/API.pm'}&lt;/code&gt; is set, if it is then no indentation should be expected. If it is not set, then the old Test::Builder is in use, indentation should be expected.</source>
          <target state="translated">있는지 확인 &lt;code&gt;$INC{'Test2/API.pm'}&lt;/code&gt; 설정은 다음 들여 쓰기는 예상해야하는 경우. 설정되지 않은 경우 이전 Test :: Builder가 사용 중이므로 들여 쓰기가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="303e071a39abc96fd64873d09760f15ff3fe8293" translate="yes" xml:space="preserve">
          <source>Check if IPC is disabled</source>
          <target state="translated">IPC가 비활성화되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="bacbf644ebf224308eedfa346896f0e9559cf48e" translate="yes" xml:space="preserve">
          <source>Check if IPC is disabled.</source>
          <target state="translated">IPC가 비활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8cf01f3e17393c98aa466478d49f4f03f393e125" translate="yes" xml:space="preserve">
          <source>Check if IPC is enabled.</source>
          <target state="translated">IPC가 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c43ba9dcdb432cd432fedcb03a03818ab2888c56" translate="yes" xml:space="preserve">
          <source>Check if Test2 believes it is the END phase.</source>
          <target state="translated">Test2가 END 단계라고 생각하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cdcfb4ca0f8db976dcc8e24eb0fb303e039ca091" translate="yes" xml:space="preserve">
          <source>Check if a formatter has been set.</source>
          <target state="translated">포맷터가 설정되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d6fabbaa68065f92237c60138ecddb521d11db66" translate="yes" xml:space="preserve">
          <source>Check if all required arguments have been provided</source>
          <target state="translated">필요한 모든 인수가 제공되었는지 확인</target>
        </trans-unit>
        <trans-unit id="a8509d0714b54138e112fcca7c6d8b6753f39078" translate="yes" xml:space="preserve">
          <source>Check if passed in handles are open for read/write</source>
          <target state="translated">전달 된 핸들이 읽기 / 쓰기를 위해 열려 있는지 확인</target>
        </trans-unit>
        <trans-unit id="6fd3cde46049874971f2b8cfda5aded02ba4b0c9" translate="yes" xml:space="preserve">
          <source>Check if polling is enabled.</source>
          <target state="translated">폴링이 활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f79df82175c5eb3e95e2c6cd96c98c735fe9a6fb" translate="yes" xml:space="preserve">
          <source>Check if the archive contains a certain file. It will return true if the file is in the archive, false otherwise.</source>
          <target state="translated">아카이브에 특정 파일이 포함되어 있는지 확인하십시오. 파일이 아카이브에 있으면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f7e1fb3d76fef513d960c53a327dd45df04cd68" translate="yes" xml:space="preserve">
          <source>Check if the event or facets contain any diagnostics information.</source>
          <target state="translated">이벤트 또는 패싯에 진단 정보가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="52ca030276ce67bc4cd267b50bb04ea684a6e47a" translate="yes" xml:space="preserve">
          <source>Check if the event or facets make an assertion.</source>
          <target state="translated">이벤트 또는 패싯이 어설 션을 작성하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0509ecd37d0266c697523223ef576efb2ecc36d9" translate="yes" xml:space="preserve">
          <source>Check if the event or facets need to be globally processed.</source>
          <target state="translated">이벤트 또는 패싯을 전역 적으로 처리해야하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9d1b49e029c5d15477edaf39f3e80aa24d78cc6" translate="yes" xml:space="preserve">
          <source>Check if the event or facets result in a failing state.</source>
          <target state="translated">이벤트 또는 패싯으로 인해 실패 상태가 발생하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ee3d96627de58e67f2705fa8ea0075be28ff956" translate="yes" xml:space="preserve">
          <source>Check if the event or facets set a plan, and return the plan details.</source>
          <target state="translated">이벤트 또는 패싯이 계획을 설정했는지 확인하고 계획 세부 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="615b2a8a3b3592d24d4dbec7a82a4376dacd4cc3" translate="yes" xml:space="preserve">
          <source>Check if the event or facets should be rendered or hidden.</source>
          <target state="translated">이벤트 또는 패싯을 렌더링하거나 숨겨야하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4342d3f548c68cd8255f930076bf26fc2f17df34" translate="yes" xml:space="preserve">
          <source>Check if the event or facets should result in process termination, if so the exit code is returned (which could be 0). undef is returned if no termination is requested.</source>
          <target state="translated">이벤트 또는 패싯으로 인해 프로세스가 종료되어야하는지 확인하십시오.이 경우 종료 코드가 반환됩니다 (0 일 수 있음). 종료가 요청되지 않으면 undef가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ace7c9922868275872da3901e2c788cb488b0b" translate="yes" xml:space="preserve">
          <source>Check if the object is finalized. Finalization happens when either &lt;code&gt;ipc()&lt;/code&gt;, &lt;code&gt;stack()&lt;/code&gt;, or &lt;code&gt;format()&lt;/code&gt; are called on the object. Once finalization happens these fields are considered unchangeable (not enforced here, enforced by &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;).</source>
          <target state="translated">개체가 완료되었는지 확인합니다. 어느 때 마무리 발생 &lt;code&gt;ipc()&lt;/code&gt; , &lt;code&gt;stack()&lt;/code&gt; , 또는 &lt;code&gt;format()&lt;/code&gt; 개체에 호출됩니다. 완료되면 이러한 필드는 &lt;a href=&quot;test2&quot;&gt;변경할 수&lt;/a&gt; 없는 것으로 간주됩니다 (여기에서는 적용되지 않고 Test2 에 의해 적용됨 ).</target>
        </trans-unit>
        <trans-unit id="0866e80fc11cc3c7149102b7d0a5b3d1a6318d10" translate="yes" xml:space="preserve">
          <source>Check if the overall test run is a failure. Can also be used to set the pass/fail status.</source>
          <target state="translated">전체 테스트 실행이 실패인지 확인하십시오. 합격 / 불합격 상태를 설정하는데도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b03d03fd3a1c6a8cb9d842cd54e006e7f6354b" translate="yes" xml:space="preserve">
          <source>Check if the plan and counts match, but only if the tests have ended. If tests have not ended this will return undef, otherwise it will be a true/false.</source>
          <target state="translated">계획과 개수가 일치하는지 확인하되 테스트가 종료 된 경우에만 확인하십시오. 테스트가 종료되지 않은 경우 undef가 반환되고, 그렇지 않으면 true / false가됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5e4799133ac0defe83d83d7bf340921f23b44a" translate="yes" xml:space="preserve">
          <source>Check if the state is set to loaded.</source>
          <target state="translated">상태가로드 됨으로 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="998cc11daba6177490db3aeddca70b082c0a9284" translate="yes" xml:space="preserve">
          <source>Check if this event sets the testing plan. It will return an empty list if it does not. If it does set the plan it will return a list of 1 to 3 items in order: Expected Test Count, Test Directive, Reason for directive.</source>
          <target state="translated">이 이벤트가 테스트 계획을 설정하는지 확인하십시오. 그렇지 않은 경우 빈 목록을 반환합니다. 계획을 설정하면 예상 테스트 횟수, 테스트 지침, 지침에 대한 이유의 순서대로 1 ~ 3 개의 항목 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c8420ecae3d4622430e248d264df7927020a881a" translate="yes" xml:space="preserve">
          <source>Check it's new</source>
          <target state="translated">새로운 지 확인</target>
        </trans-unit>
        <trans-unit id="1a3059c728f920e1399329e5c1ad9c928030d581" translate="yes" xml:space="preserve">
          <source>Check out the MLDBM module, available on CPAN in the directory</source>
          <target state="translated">CPAN의 디렉토리에있는 MLDBM 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="da39caa4bdb8a551abdb17c85c154b129315c71f" translate="yes" xml:space="preserve">
          <source>Check out the source repository</source>
          <target state="translated">소스 저장소 확인</target>
        </trans-unit>
        <trans-unit id="8d20ca8b6c95c57523eed6a448e4762d5395b670" translate="yes" xml:space="preserve">
          <source>Check pod documents for syntax errors</source>
          <target state="translated">구문 오류에 대한 포드 문서 확인</target>
        </trans-unit>
        <trans-unit id="ca159b8d6ca8bc89a6d10a26dae1e203c859a67d" translate="yes" xml:space="preserve">
          <source>Check that a hash is in an internally consistent state.</source>
          <target state="translated">해시가 내부적으로 일관성있는 상태인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6c679ad8ca10d169e6a7df72723849d47a11c40b" translate="yes" xml:space="preserve">
          <source>Check that some temporary files did not make into the perl install tree. Run something like this</source>
          <target state="translated">일부 임시 파일이 perl 설치 트리로 작성되지 않았는지 점검하십시오. 이런 식으로 실행</target>
        </trans-unit>
        <trans-unit id="ad7649629b85f92dfc5d446ddfd0a8b0ed94757d" translate="yes" xml:space="preserve">
          <source>Check that the input string does not match the regex.</source>
          <target state="translated">입력 문자열이 정규식과 일치하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d4a5814455d4d53950c67798588ac9e4929c9b" translate="yes" xml:space="preserve">
          <source>Check that the input string matches the regex.</source>
          <target state="translated">입력 문자열이 정규식과 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9defd6564bb9099fa189d5588407b66bb7555daa" translate="yes" xml:space="preserve">
          <source>Check that you have &lt;b&gt;BSD&lt;/b&gt; libraries and headers installed, and - optionally - Berkeley DB headers and libraries, and crypt.</source>
          <target state="translated">&lt;b&gt;BSD&lt;/b&gt; 라이브러리 및 헤더가 설치되어 있고 선택적으로 Berkeley DB 헤더 및 라이브러리 및 암호가 설치되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cfcc4548a2343eadc2629dda5508ccfded48bd5" translate="yes" xml:space="preserve">
          <source>Check that you have link386 installed. It comes standard with OS/2, but may be not installed due to customization. If typing</source>
          <target state="translated">link386이 설치되어 있는지 확인하십시오. OS / 2에는 표준으로 제공되지만 사용자 정의로 인해 설치되지 않을 수 있습니다. 입력하는 경우</target>
        </trans-unit>
        <trans-unit id="79d08dd23471c409ed3ca7645ef7d274508c7b47" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;Benchmark&lt;/code&gt; docs for further useful techniques.</source>
          <target state="translated">유용한 기술에 대해서는 &lt;code&gt;Benchmark&lt;/code&gt; 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="14e9adf4a018a86aa09ce8983af2c630914d716c" translate="yes" xml:space="preserve">
          <source>Check the CPAN Testers if a module should work with your platform but it doesn't behave as you'd expect, or you aren't sure whether or not a module will work under your platform. If the module you want isn't listed there, you can test it yourself and let CPAN Testers know, you can join CPAN Testers, or you can request it be tested.</source>
          <target state="translated">모듈이 플랫폼에서 작동해야하지만 예상대로 작동하지 않거나 모듈이 플랫폼에서 작동하는지 확실하지 않은 경우 CPAN 테스터를 확인하십시오. 원하는 모듈이 목록에 없으면 직접 테스트하여 CPAN 테스터에게 알리거나 CPAN 테스터에 가입하거나 테스트를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5173a90532c2701f8f8cdb88adc2b6f4e6723f22" translate="yes" xml:space="preserve">
          <source>Check the PerlIO::via:: namespace on CPAN for examples of PerlIO layers implemented in Perl. To give you an idea how simple the implementation of a PerlIO layer can look, a simple example is included here.</source>
          <target state="translated">Perl에서 구현 된 PerlIO 계층의 예는 CPAN의 PerlIO :: via :: 네임 스페이스를 확인하십시오. PerlIO 레이어의 구현이 얼마나 간단한 지 알기 위해 간단한 예제가 여기에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7b70cf85fde5d10a4d6750e595901816be3c74" translate="yes" xml:space="preserve">
          <source>Check the Pod syntax of a document</source>
          <target state="translated">문서의 포드 구문 확인</target>
        </trans-unit>
        <trans-unit id="f91480d26f728c8f70780347d46c3882a8821adf" translate="yes" xml:space="preserve">
          <source>Check the contents of the distribution. Read the module's documentation, looking for reasons why you might have trouble using it with MacPerl. Look for</source>
          <target state="translated">배포 내용을 확인하십시오. MacPerl에서 모듈을 사용하는 데 문제가있을 수있는 이유를 찾아 모듈 설명서를 읽으십시오. 찾다</target>
        </trans-unit>
        <trans-unit id="9e48cf52c63c2d0f64a711912719de261c9edcba" translate="yes" xml:space="preserve">
          <source>Check the validity of the stream if</source>
          <target state="translated">스트림의 유효성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9e8967b00a81a9d723ab21648f7d0d7f4c57338" translate="yes" xml:space="preserve">
          <source>Checkcc.U</source>
          <target state="translated">Checkcc.U</target>
        </trans-unit>
        <trans-unit id="ed045ab4ccfe5bf8141076961571d30ec378ba8c" translate="yes" xml:space="preserve">
          <source>Checking the environment entails either looking ahead on the trail, looking behind, or both. &lt;code&gt;'^'&lt;/code&gt; looks behind, to see that there are no characters before. &lt;code&gt;'$'&lt;/code&gt; looks ahead, to see that there are no characters after. &lt;code&gt;\b&lt;/code&gt; looks both ahead and behind, to see if the characters on either side differ in their &quot;word-ness&quot;.</source>
          <target state="translated">환경을 확인하는 것은 트레일에서 앞을 내다 보거나 뒤를 보거나 또는 둘 모두를 수반합니다. &lt;code&gt;'^'&lt;/code&gt; 는 뒤에 문자가 없는지 확인합니다. &lt;code&gt;'$'&lt;/code&gt; 는 앞에 문자가 없는지 확인합니다. &lt;code&gt;\b&lt;/code&gt; 는 앞뒤를 모두보고 양쪽에있는 문자의 &quot;단어 성&quot;이 다른지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="82a2acac5750a7cb12b97634f29af8ec944c5757" translate="yes" xml:space="preserve">
          <source>Checking the environment entails either looking ahead on the trail, looking behind, or both. &lt;code&gt;^&lt;/code&gt; looks behind, to see that there are no characters before. &lt;code&gt;$&lt;/code&gt; looks ahead, to see that there are no characters after. &lt;code&gt;\b&lt;/code&gt; looks both ahead and behind, to see if the characters on either side differ in their &quot;word-ness&quot;.</source>
          <target state="translated">환경을 점검하려면 트레일을 미리 보거나 뒤에 보거나 둘 다를 수반해야합니다. &lt;code&gt;^&lt;/code&gt; 뒤에 문자가 없는지 확인하기 위해 뒤를 돌아 봅니다. 뒤에 문자가 없다는 것을 알기 위해 &lt;code&gt;$&lt;/code&gt; 가 계속 보입니다. &lt;code&gt;\b&lt;/code&gt; 는 앞뒤를 보면서 양쪽의 문자가 &quot;단어&quot;가 다른지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="241245aa2d17d53491de163e9619ea5f88ee1470" translate="yes" xml:space="preserve">
          <source>Checking the return value</source>
          <target state="translated">반환 값 확인</target>
        </trans-unit>
        <trans-unit id="223804327875b075a53dd25f4221175abf389942" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;. Tests:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 확인합니다 . 테스트 :</target>
        </trans-unit>
        <trans-unit id="3a60535c47ae3686d1195136cbe426251f2f931d" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; on a filehandle just opened for write - I do not know why this should or should not work.</source>
          <target state="translated">쓰기 위해 열린 파일 핸들에서 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; 를 확인합니다 -왜 이것이 작동 해야하는지 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="564e49285a0398ab07e0e7063594b4b39a5abcbe" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;atime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; - unfortunately, HPFS provides only 2sec time granularity (for compatibility with FAT?).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;atime&lt;/code&gt; 및 &lt;code&gt;mtime&lt;/code&gt; 을 확인합니다. 불행히도 HPFS는 2 초의 시간 단위 (FAT와의 호환성을 위해) 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75de396b5f2c5c2cfac86d95628c89b9bf929036" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;atime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; of &lt;code&gt;stat()&lt;/code&gt; - unfortunately, HPFS provides only 2sec time granularity (for compatibility with FAT?).</source>
          <target state="translated">&lt;code&gt;stat()&lt;/code&gt; 의 &lt;code&gt;atime&lt;/code&gt; 및 &lt;code&gt;mtime&lt;/code&gt; 을 확인합니다. 불행히도 HPFS는 2 초 단위 시간 단위 만 제공합니다 (FAT와의 호환성을 위해?).</target>
        </trans-unit>
        <trans-unit id="91d374f3d87b169a9bc3fe67ed761b6e0e67e0f7" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;stat()&lt;/code&gt;. Tests:</source>
          <target state="translated">&lt;code&gt;stat()&lt;/code&gt; 확인합니다 . 테스트 :</target>
        </trans-unit>
        <trans-unit id="3c55bc933dd0fad49fed8b9abe30bb836a465793" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;truncate()&lt;/code&gt; on a filehandle just opened for write - I do not know why this should or should not work.</source>
          <target state="translated">방금 쓰기 위해 열린 파일 핸들에서 &lt;code&gt;truncate()&lt;/code&gt; 를 확인 합니다. 이것이 작동해야하는 이유와 작동하지 않아야하는 이유를 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="e7aa1e4bbcb9ef8e50cbb1ca2e0aa94d40c33e10" translate="yes" xml:space="preserve">
          <source>Checks for VMS directory spec as well as Unix separators.</source>
          <target state="translated">VMS 디렉토리 스펙과 유닉스 구분 기호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3af941bd688efd7585a7f0e144f9af47e846d7a5" translate="yes" xml:space="preserve">
          <source>Checks for the perl program under several common perl extensions.</source>
          <target state="translated">몇 가지 일반적인 perl 확장에서 perl 프로그램을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f3d96161e784b66068319a1db708dc0748d310a2" translate="yes" xml:space="preserve">
          <source>Checks if a group with the given name has matched something.</source>
          <target state="translated">주어진 이름을 가진 그룹이 무언가와 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bd58afee7ae5bcf5112dbf01db1faa210e7afa56" translate="yes" xml:space="preserve">
          <source>Checks if a group with the given name has matched something. Full syntax: &lt;code&gt;(?(&amp;lt;name&amp;gt;)then|else)&lt;/code&gt;</source>
          <target state="translated">주어진 이름의 그룹이 일치하는지 확인합니다. 전체 구문 : &lt;code&gt;(?(&amp;lt;name&amp;gt;)then|else)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b64ff69951ab67fee8d9d86a7a4cf97007ecbf7" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated inside of recursion.</source>
          <target state="translated">식이 재귀 안에서 평가되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d1da258437f3b81bdf80ad61adf62e4aecb30a13" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated inside of recursion. Full syntax: &lt;code&gt;(?(R)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="translated">식이 재귀 내에서 평가되었는지 확인합니다. 전체 구문 : &lt;code&gt;(?(R)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6dad515448c742f2dc10676e5ccdb019e7a0c22" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated while executing directly inside of the n-th capture group. This check is the regex equivalent of</source>
          <target state="translated">n 번째 캡처 그룹 내에서 직접 실행하는 동안 표현식이 평가되었는지 확인합니다. 이 검사는 정규식에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="29b9caf4fecb2c45031e3e282976736db6a59c9c" translate="yes" xml:space="preserve">
          <source>Checks if the numbered capturing group has matched something.</source>
          <target state="translated">번호가 매겨진 캡처 그룹이 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f5da775ed1b71b8b62ebf522a42da2fb67ee7606" translate="yes" xml:space="preserve">
          <source>Checks if the numbered capturing group has matched something. Full syntax: &lt;code&gt;(?(1)then|else)&lt;/code&gt;</source>
          <target state="translated">번호가 매겨진 캡처 그룹이 일치하는지 확인합니다. 전체 구문 : &lt;code&gt;(?(1)then|else)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7915221a7e3c9b01fb693fd7e47a678921143862" translate="yes" xml:space="preserve">
          <source>Checks if two arrays are equivalent. This is a deep check, so multi-level structures are handled correctly.</source>
          <target state="translated">두 배열이 같은지 확인합니다. 이것은 철저한 검사이므로 다중 레벨 구조가 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e40bfce6a6d81449f234a025589a2a5b020bf9fa" translate="yes" xml:space="preserve">
          <source>Checks to make sure the $module or $object can do these @methods (works with functions, too).</source>
          <target state="translated">$ module 또는 $ object가 이러한 @method를 수행 할 수 있는지 확인합니다 (함수와 함께 작동).</target>
        </trans-unit>
        <trans-unit id="55b2f57a95767c489c56b01d1268c9dfc91fb618" translate="yes" xml:space="preserve">
          <source>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.</source>
          <target state="translated">SV가 오염되었는지 확인합니다. 참이면 참을, 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3c0b5dd82119b45805bc8cb1d101b8d9a91fd41" translate="yes" xml:space="preserve">
          <source>Checks to see if the current operating system is one of the given flavors.</source>
          <target state="translated">현재 운영 체제가 지정된 특징 중 하나인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="963de9ea3a8bb874b459828c02df2b61c6ee5c78" translate="yes" xml:space="preserve">
          <source>Checks to see if the given &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; . Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</source>
          <target state="translated">주어진 &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; 합니다. 또한 객체가 처음에 정의되었는지 확인합니다. 이런 종류의 일에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="daaaaf198d9542464bc1a7c79801e676fbfcfd1e" translate="yes" xml:space="preserve">
          <source>Checks to see if the given &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt;. Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</source>
          <target state="translated">주어진 &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; 합니다. 또한 객체가 처음에 정의되었는지 확인합니다. 이런 종류의 일에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="deed6108b030bfb42052b56fb5c535f65fcd83f1" translate="yes" xml:space="preserve">
          <source>Checks whether the argument would be either an infinity or &lt;code&gt;NaN&lt;/code&gt; when used as a number, but is careful not to trigger non-numeric or uninitialized warnings. it assumes the caller has done &lt;code&gt;SvGETMAGIC(sv)&lt;/code&gt; already.</source>
          <target state="translated">인수가 숫자로 사용될 때 무한대인지 &lt;code&gt;NaN&lt;/code&gt; 인지 확인 하지만 숫자가 아니거나 초기화되지 않은 경고를 트리거하지 않도록주의합니다. 호출자가 이미 &lt;code&gt;SvGETMAGIC(sv)&lt;/code&gt; 수행 했다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ac6373448a4e97de67ddcff713361ab246705ca8" translate="yes" xml:space="preserve">
          <source>Checks whether the pattern matches (or does not match, for the '!' variants).</source>
          <target state="translated">패턴이 일치하는지 또는 '!'변형에 대해 일치하지 않는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a0784bf4c9b988fb0a185f79b6a458b1ead9c855" translate="yes" xml:space="preserve">
          <source>Checks whether the pattern matches (or does not match, for the &lt;code&gt;&quot;!&quot;&lt;/code&gt; variants). Full syntax: &lt;code&gt;(?(?=&lt;i&gt;lookahead&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="translated">패턴이 일치하는지 (또는 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 변형에 대해 일치하지 않는지 ) 확인합니다. 전체 구문 : &lt;code&gt;(?(?=&lt;i&gt;lookahead&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acfac0fe5ba60bfef12b9f1265f8a0428c3029f8" translate="yes" xml:space="preserve">
          <source>Checksum field for the tar header</source>
          <target state="translated">tar 헤더의 체크섬 필드</target>
        </trans-unit>
        <trans-unit id="ffee64cf2b1c4af879bff0e274c6633e34c9742b" translate="yes" xml:space="preserve">
          <source>Child classes can override this method to change how default messages are formatted.</source>
          <target state="translated">자식 클래스는이 메서드를 재정 의하여 기본 메시지 형식을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52718161ef0f431cda10c0e79bdec6d20b2e152" translate="yes" xml:space="preserve">
          <source>Child classes can override this method to change how they're stringified.</source>
          <target state="translated">자식 클래스는이 메서드를 재정 의하여 문자열 화 방법을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="607b7fc55b056c24f1c8cacc3987ff9e25b1dcc5" translate="yes" xml:space="preserve">
          <source>Children's times are only included for terminated children.</source>
          <target state="translated">아동 시간은 해고 된 아동에게만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="349507e41dd8c71c10c9df6d2444b5e64a285691" translate="yes" xml:space="preserve">
          <source>Chile</source>
          <target state="translated">Chile</target>
        </trans-unit>
        <trans-unit id="d2eaf2aa1512d6596e0a5bae633537c6b8e779a3" translate="yes" xml:space="preserve">
          <source>China</source>
          <target state="translated">China</target>
        </trans-unit>
        <trans-unit id="189da622f3fbd822d1e732459ee0eddbbb7cd8ef" translate="yes" xml:space="preserve">
          <source>China-based Chinese Encodings</source>
          <target state="translated">중국 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="15dc18865567bcc98554a72a8036e1b64a8b85d5" translate="yes" xml:space="preserve">
          <source>Chinese</source>
          <target state="translated">Chinese</target>
        </trans-unit>
        <trans-unit id="d48a6b368170de01eb1a86e009fcbab8bf75cbe6" translate="yes" xml:space="preserve">
          <source>Chip Salzenberg &amp;lt;</source>
          <target state="translated">칩 잘젠 버그 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e4bddc7a2d81236ab3d83bc9f7e071985e724af1" translate="yes" xml:space="preserve">
          <source>Choose a name</source>
          <target state="translated">이름을 선택하세요</target>
        </trans-unit>
        <trans-unit id="f92e3f195464d519a284541bb4d50a0a8112bfbe" translate="yes" xml:space="preserve">
          <source>Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)</source>
          <target state="translated">적절하고 일관된 버전 번호 체계를 선택하십시오 (X.YY는 일반적인 Perl 모듈 번호 체계입니다)</target>
        </trans-unit>
        <trans-unit id="26d5375b27ee62ca78bfa742d3f1dc585cc2baa3" translate="yes" xml:space="preserve">
          <source>Choose an appropriate license (GPL/Artistic is a good default)</source>
          <target state="translated">적절한 라이센스를 선택하십시오 (GPL / Artistic이 좋은 기본값입니다)</target>
        </trans-unit>
        <trans-unit id="80fb4b6e80ff447b460548828bfa4306c5610812" translate="yes" xml:space="preserve">
          <source>Choose an appropriate name</source>
          <target state="translated">적절한 이름을 선택하십시오</target>
        </trans-unit>
        <trans-unit id="d82893eb0e9cc35f7e43c5d3e352d8ca738e05ba" translate="yes" xml:space="preserve">
          <source>Choose mnemonic identifiers. If you can't remember what mnemonic means, you've got a problem.</source>
          <target state="translated">니모닉 식별자를 선택하십시오. 니모닉의 의미를 기억할 수 없다면 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed88e1b0d9bb812c4891cf57f9140a2970de186a" translate="yes" xml:space="preserve">
          <source>Choose wisely.</source>
          <target state="translated">현명하게 선택해.</target>
        </trans-unit>
        <trans-unit id="f68f3e0f920c046e7af5038b0261d7ac2b4646da" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">문자열의 마지막 문자를 잘라 내고 잘린 문자를 반환합니다. 문자열을 스캔하거나 복사하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 보다 훨씬 효율적 입니다. VARIABLE을 생략하면 &lt;code&gt;$_&lt;/code&gt; 잘라 냅니다. VARIABLE이 해시 인 경우 프로세스 의 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 해시 값을 자르고 키는 자르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06caa54c979ede41f81e5b2bef50565e9d2ae230" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">문자열의 마지막 문자를 잘라 내고 잘린 문자를 반환합니다. 문자열을 스캔하거나 복사하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 보다 훨씬 효율적 입니다. VARIABLE을 생략하면 &lt;code&gt;$_&lt;/code&gt; 잘라 냅니다. VARIABLE이 해시 인 경우 프로세스 의 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 해시 값을 자르고 키는 자르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="75642c9b4de22cd87f57f3970064644e82310c40" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;s/.$//s&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; iterator in the process.</source>
          <target state="translated">문자열의 마지막 문자를 잘라내어 잘라낸 문자를 반환합니다. 문자열을 스캔하거나 복사하지 않기 때문에 &lt;code&gt;s/.$//s&lt;/code&gt; 보다 훨씬 효율적 입니다. VARIABLE이 생략되면 &lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 잘라 냅니다. VARIABLE이 해시이면 키가 아닌 해시 값을 잘라 프로세스 의 &lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt; 반복기를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6c578d45c5f714d41a2fcf7ac43a1d3b9259519c" translate="yes" xml:space="preserve">
          <source>Chris 'BinGOs' Williams &amp;lt;chris@bingosnet.co.uk&amp;gt;</source>
          <target state="translated">Chris 'BinGOs' Williams &amp;lt;chris@bingosnet.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9a1bd8889480f6200aab39143b71843fe93d9348" translate="yes" xml:space="preserve">
          <source>Chris &lt;code&gt;BinGOs&lt;/code&gt; Williams &amp;lt;chris@bingosnet.co.uk&amp;gt;</source>
          <target state="translated">크리스 &lt;code&gt;BinGOs&lt;/code&gt; 윌리엄스 &amp;lt;chris@bingosnet.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="abee13b6939fa80fd30e20450da7f3b4b64b18ad" translate="yes" xml:space="preserve">
          <source>Chris Nehren &amp;lt;apeiron@cpan.org&amp;gt;</source>
          <target state="translated">크리스 네렌 &amp;lt;apeiron@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4680e00383524fe7680da1f5ed7fc999f0aaab2b" translate="yes" xml:space="preserve">
          <source>Chris Weyl &amp;lt;cweyl@alumni.drew.edu&amp;gt;</source>
          <target state="translated">크리스 웨일 &amp;lt;cweyl@alumni.drew.edu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92fdef0f255605951e0003542bf785af92a2896b" translate="yes" xml:space="preserve">
          <source>Christian Hansen &amp;lt;chansen@cpan.org&amp;gt;</source>
          <target state="translated">Christian Hansen &amp;lt;chansen@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d172830092c16e3b76f3bbe5147847756d9ac80" translate="yes" xml:space="preserve">
          <source>Christian Walde &amp;lt;walde.christian@googlemail.com&amp;gt;</source>
          <target state="translated">Christian Walde &amp;lt;walde.christian@googlemail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="aeace3b5b0b6d6ef61d3311fa7df4fd29dbde4ef" translate="yes" xml:space="preserve">
          <source>Christopher J. Madsen &amp;lt;cjm@cpan.org&amp;gt;</source>
          <target state="translated">Christopher J. Madsen &amp;lt;cjm@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="53ccad4bb819b68a73cf3637ef33a5d1aeee9bf1" translate="yes" xml:space="preserve">
          <source>Chuck Adams &amp;lt;cja987@gmail.com&amp;gt;</source>
          <target state="translated">Chuck Adams &amp;lt;cja987@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26d10419c85d39f36202cd562489c0cca977e3fc" translate="yes" xml:space="preserve">
          <source>Circular References</source>
          <target state="translated">원형 참조</target>
        </trans-unit>
        <trans-unit id="29285dd5c7a27e978de25c300eb6e17434a810c3" translate="yes" xml:space="preserve">
          <source>Civility is simple: stick to the facts while avoiding demeaning remarks and sarcasm. It is not enough to be factual. You must also be civil. Responding in kind to incivility is not acceptable.</source>
          <target state="translated">문명은 단순합니다. 사실을 고수하면서 말과 비난을 피하십시오. 사실이 충분하지 않습니다. 또한 시민이어야합니다. 무례에 대한 종류의 대응은 용납되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dfb184266e164f25957890f2de49bc55597501a" translate="yes" xml:space="preserve">
          <source>Civility is simple: stick to the facts while avoiding demeaning remarks, belittling other individuals, sarcasm, or a presumption of bad faith. It is not enough to be factual. You must also be civil. Responding in kind to incivility is not acceptable. If you relay otherwise-unposted comments to the list from a third party, you take responsibility for the content of those comments, and you must therefore ensure that they are civil.</source>
          <target state="translated">예의 바르게 행동하는 것은 간단합니다. 비하하는 발언을 피하고, 다른 사람을 경멸하거나, 비꼬거나, 악의에 대한 추측을 피하면서 사실을 고수하십시오. 사실적인 것만으로는 충분하지 않습니다. 당신은 또한 예의 바르게 행동해야합니다. 무례함에 현물로 대응하는 것은 용납되지 않습니다. 게시되지 않은 댓글을 제 3 자의 목록에 전달하는 경우 해당 댓글의 내용에 대한 책임이 있으므로 해당 댓글이 민사인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b90ba8ba0b734645b20aafbecdbbe2c01778c68c" translate="yes" xml:space="preserve">
          <source>Claes Jakobsson &amp;lt;claes@surfar.nu&amp;gt;</source>
          <target state="translated">Claes Jakobsson &amp;lt;claes@surfar.nu&amp;gt;</target>
        </trans-unit>
        <trans-unit id="921b4678530ac39289303d56c764868a0f90e4d0" translate="yes" xml:space="preserve">
          <source>Clarified &lt;a href=&quot;#dynamic_config&quot;&gt;&quot;dynamic_config&quot;&lt;/a&gt; a bit.</source>
          <target state="translated">&lt;a href=&quot;#dynamic_config&quot;&gt;&quot;dynamic_config&quot;&lt;/a&gt; 가 약간 명확 해졌습니다 .</target>
        </trans-unit>
        <trans-unit id="7557bc9cb46ce626dd758bc650ab1d5cdac0da1f" translate="yes" xml:space="preserve">
          <source>Clarified intended use of 'author' as generalized contact list</source>
          <target state="translated">일반화 된 연락처 목록으로 '저자'의 용도를 명확히했습니다.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="27da14a1fe7c43b167b1731875fb84c22c822b0c" translate="yes" xml:space="preserve">
          <source>Class 'Foo' tried to inherit from itself</source>
          <target state="translated">클래스 'Foo'가 자신을 상속하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="352b661369c278e18b0da8e3c270f498025dcaf8" translate="yes" xml:space="preserve">
          <source>Class (&lt;code&gt;'Class_Name'&lt;/code&gt; or &lt;code&gt;'*Class_Name'&lt;/code&gt;)</source>
          <target state="translated">클래스 ( &lt;code&gt;'Class_Name'&lt;/code&gt; 또는 &lt;code&gt;'*Class_Name'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1e7fb31960aaba1258b4feeaa688fcb9336dfe6f" translate="yes" xml:space="preserve">
          <source>Class Creation at Compile Time</source>
          <target state="translated">컴파일 타임에 클래스 생성</target>
        </trans-unit>
        <trans-unit id="48d732c8305b8b551da41c39926c3f8b3cd63041" translate="yes" xml:space="preserve">
          <source>Class Instance Operator</source>
          <target state="translated">클래스 인스턴스 연산자</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="3fda1907fb10f41774bfaecce153bd2dcb1991b7" translate="yes" xml:space="preserve">
          <source>Class Names as Strings</source>
          <target state="translated">문자열로서의 클래스 이름</target>
        </trans-unit>
        <trans-unit id="f3e7ba90394996375a075b54692b14d58b442ff0" translate="yes" xml:space="preserve">
          <source>Class method for use inside a thread to change its own behavior for &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 의 자체 동작을 변경하기 위해 스레드 내부에서 사용하기위한 클래스 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="488dbbda6a117b4743feeab1f60e1bf900a5fa01" translate="yes" xml:space="preserve">
          <source>Class method for use inside a thread to change its own behavior for &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exit()&lt;/code&gt; 대한 자체 동작을 변경하기 위해 스레드 내부에서 사용하는 클래스 메서드입니다 .</target>
        </trans-unit>
        <trans-unit id="a38175b54007e6872fad46c411f63af989070306" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to detach itself.</source>
          <target state="translated">스레드가 스스로 분리 할 수 ​​있도록하는 클래스 메소드</target>
        </trans-unit>
        <trans-unit id="0e0095b85b575f8ed03afeaf1d333c819ad78615" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to determine whether or not it is detached.</source>
          <target state="translated">스레드가 분리되었는지 여부를 판별 할 수있는 클래스 메소드.</target>
        </trans-unit>
        <trans-unit id="e73d227a516617a6441904d7cb0de003fa8faaff" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own</source>
          <target state="translated">스레드가 자체적으로 얻을 수있는 클래스 메소드</target>
        </trans-unit>
        <trans-unit id="4898ddb7865314fdb26c20ddf401c39b5082833c" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own ID.</source>
          <target state="translated">스레드가 자체 ID를 얻을 수있게하는 클래스 메소드.</target>
        </trans-unit>
        <trans-unit id="fddf8c93c0000670b5cdf682b97e468968024e66" translate="yes" xml:space="preserve">
          <source>Class method to return the current thread's context. This returns the same value as running &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; inside the current thread's entry point function.</source>
          <target state="translated">현재 스레드의 컨텍스트를 반환하는 클래스 메서드 현재 스레드의 진입 점 함수 내에서 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 를 실행하는 것과 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66c8ddfff1d6edc57d53312ba77ecdf9a1d523f5" translate="yes" xml:space="preserve">
          <source>Class method to return the current thread's context. This returns the same value as running &lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray()&lt;/a&gt; inside the current thread's entry point function.</source>
          <target state="translated">현재 스레드의 컨텍스트를 반환하는 클래스 메서드입니다. 이것은 현재 스레드의 진입 점 함수 내에서 &lt;a href=&quot;perlfunc#wantarray&quot;&gt;wantarray ()&lt;/a&gt; 를 실행하는 것과 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="900e960bfc32d7354820f2e10ac47623183d4172" translate="yes" xml:space="preserve">
          <source>Class method.</source>
          <target state="translated">클래스 방법.</target>
        </trans-unit>
        <trans-unit id="61e8fdd13a105e0002eef0663431494746684737" translate="yes" xml:space="preserve">
          <source>Class::Accessor</source>
          <target state="translated">Class::Accessor</target>
        </trans-unit>
        <trans-unit id="394e591256dfedee8ffcd71362b2ad76a446733c" translate="yes" xml:space="preserve">
          <source>Class::C3</source>
          <target state="translated">Class::C3</target>
        </trans-unit>
        <trans-unit id="6d45f04ee3b770e5707c62b830d994b42f571d44" translate="yes" xml:space="preserve">
          <source>Class::Struct</source>
          <target state="translated">Class::Struct</target>
        </trans-unit>
        <trans-unit id="2ea8699f7b748850b0a3f5be8865468e94f1fe28" translate="yes" xml:space="preserve">
          <source>Class::Struct - declare struct-like datatypes as Perl classes</source>
          <target state="translated">Class :: Struct-구조체와 유사한 데이터 유형을 Perl 클래스로 선언</target>
        </trans-unit>
        <trans-unit id="eabd5b700d02e72052a5dba7a49163d27d89c51a" translate="yes" xml:space="preserve">
          <source>Class::Tiny</source>
          <target state="translated">Class::Tiny</target>
        </trans-unit>
        <trans-unit id="77e7593f3ad030d22758c56fb1b2215a3db2ee44" translate="yes" xml:space="preserve">
          <source>Classes and inherited methods.</source>
          <target state="translated">클래스와 상속 된 메소드.</target>
        </trans-unit>
        <trans-unit id="1161f577bbba62479b9f81c878cce8a1b390e9a9" translate="yes" xml:space="preserve">
          <source>Classes based on the &lt;code&gt;id()&lt;/code&gt; function (and hence classes based on &lt;code&gt;idhash()&lt;/code&gt; and &lt;code&gt;fieldhash()&lt;/code&gt; ) show a peculiar behavior in that the class name can be used like an object. Specifically, methods that set or read data associated with an object continue to work as class methods, just as if the class name were an object, distinct from all other objects, with its own data. This object may be called the</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수를 기반으로하는 클래스 (따라서 &lt;code&gt;idhash()&lt;/code&gt; 및 &lt;code&gt;fieldhash()&lt;/code&gt; 기반 클래스 )는 클래스 이름을 객체처럼 사용할 수 있다는 특이한 동작을 보여줍니다. 특히, 객체와 관련된 데이터를 설정하거나 읽는 메서드는 클래스 이름이 다른 모든 객체와 다른 객체 인 것처럼 자체 데이터가있는 것처럼 클래스 메서드로 계속 작동합니다. 이 개체는</target>
        </trans-unit>
        <trans-unit id="6ad5d015aacfec0dfde0e9600202357a1382762e" translate="yes" xml:space="preserve">
          <source>Classes based on the &lt;code&gt;id()&lt;/code&gt; function (and hence classes based on &lt;code&gt;idhash()&lt;/code&gt; and &lt;code&gt;fieldhash()&lt;/code&gt;) show a peculiar behavior in that the class name can be used like an object. Specifically, methods that set or read data associated with an object continue to work as class methods, just as if the class name were an object, distinct from all other objects, with its own data. This object may be called the</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수를 기반으로하는 클래스 (따라서 &lt;code&gt;idhash()&lt;/code&gt; 및 &lt;code&gt;fieldhash()&lt;/code&gt; 기반 클래스 )는 클래스 이름을 객체처럼 사용할 수 있다는 점에서 특이한 동작을 보여줍니다. 특히, 객체와 연관된 데이터를 설정하거나 읽는 메소드는 마치 클래스 이름이 자체 데이터를 가진 다른 모든 객체와 구별되는 객체 인 것처럼 계속해서 클래스 메소드로 작동합니다. 이 개체는</target>
        </trans-unit>
        <trans-unit id="6fe3306e3ca4485e41a1374bad73dbf1cbd32c97" translate="yes" xml:space="preserve">
          <source>Clean out some extra dll.{base,exp} files which might be generated by gcc. Otherwise, take out all *.pdb files.</source>
          <target state="translated">gcc에 의해 생성 될 수있는 추가 dll. {base, exp} 파일을 정리하십시오. 그렇지 않으면 모든 * .pdb 파일을 꺼내십시오.</target>
        </trans-unit>
        <trans-unit id="44fff3c8b56cfdff2a4b1fd6a798cd0eef5df63b" translate="yes" xml:space="preserve">
          <source>Clean package to evaluate code in</source>
          <target state="translated">코드를 평가하기위한 패키지 정리</target>
        </trans-unit>
        <trans-unit id="a72e6202d4001a9b912438ef80c86fb133020828" translate="yes" xml:space="preserve">
          <source>Clean up ERRSV so we can safely set it.</source>
          <target state="translated">ERRSV를 정리하여 안전하게 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10cfbcf1f47828bf537936a130691a497387fb6d" translate="yes" xml:space="preserve">
          <source>Clean up some OS specific files. Plus the temp file used to shorten a lot of commands. And the name mangler database.</source>
          <target state="translated">일부 OS 특정 파일을 정리하십시오. 또한 많은 명령을 단축하는 데 사용되는 임시 파일. 그리고 이름 mangler 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="81ba7eebd7e241b8a0d3ee0f0dc83f6dcb213ac0" translate="yes" xml:space="preserve">
          <source>Cleaning Up Your Path</source>
          <target state="translated">경로 정리</target>
        </trans-unit>
        <trans-unit id="f0ac618dc389d1f694ce2b22b281bf48e0a7c7e1" translate="yes" xml:space="preserve">
          <source>Cleaning a working directory</source>
          <target state="translated">작업 디렉토리 정리</target>
        </trans-unit>
        <trans-unit id="c39c68e4f213f84f2b2c6b1480b516f413b3ce6f" translate="yes" xml:space="preserve">
          <source>Cleanup VOS core files</source>
          <target state="translated">VOS 코어 파일 정리</target>
        </trans-unit>
        <trans-unit id="89d75847cf7d1968a70859baea6df0822891a7f0" translate="yes" xml:space="preserve">
          <source>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</source>
          <target state="translated">컴파일 중 범위 끝에서 정리 :이 범위에서 어휘에 대한 최대 seq 번호를 설정하고 소개되지 않은 어휘에 대해 경고하십시오.</target>
        </trans-unit>
        <trans-unit id="090755b1798e39d1824b0b1af3f46d5a518ba79a" translate="yes" xml:space="preserve">
          <source>Clear (remove, delete, ...) all values from the tied array associated with object</source>
          <target state="translated">객체와 연결된 묶인 배열에서 모든 값을 지우거나</target>
        </trans-unit>
        <trans-unit id="f3388c6c3c8ea1834f8402fd24982f91fd19df77" translate="yes" xml:space="preserve">
          <source>Clear all cached times.</source>
          <target state="translated">캐시 된 시간을 모두 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="d49faf737a36f02abafb6ec88b142fb354d6f3ff" translate="yes" xml:space="preserve">
          <source>Clear all values from the tied hash</source>
          <target state="translated">묶인 해시에서 모든 값을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="716a5cc3044dab9309ffffc76efde99c4966f639" translate="yes" xml:space="preserve">
          <source>Clear an SV: call any destructors, free up any memory used by the body, and free the body itself. The SV's head is</source>
          <target state="translated">SV 지우기 : 소멸자를 호출하고 본문에서 사용하는 메모리를 비우고 본문 자체를 비 웁니다. SV의 머리는</target>
        </trans-unit>
        <trans-unit id="4d44f4bb1140ae5aa0e259ee5cb4bd4ea4aba014" translate="yes" xml:space="preserve">
          <source>Clear any placeholders from a locked hash. Should not be used directly. You should use the wrapper functions provided by Hash::Util instead. As of 5.25 also available as &lt;code&gt; Hash::Util::_clear_placeholders(%hash) &lt;/code&gt;</source>
          <target state="translated">잠긴 해시에서 자리 표시자를 모두 지 웁니다. 직접 사용해서는 안됩니다. 대신 Hash :: Util에서 제공하는 래퍼 함수를 ​​사용해야합니다. 5.25부터 &lt;code&gt; Hash::Util::_clear_placeholders(%hash) &lt;/code&gt; 로도 사용 가능</target>
        </trans-unit>
        <trans-unit id="1f45c3303d209b593f661cc5395c426e8611e2fe" translate="yes" xml:space="preserve">
          <source>Clear end-of-file and error indicators. Should call &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; to set the &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags, which may suffice.</source>
          <target state="translated">파일 끝 및 오류 표시기를 지우십시오. &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 플래그 를 설정하려면 &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c704c7949a89c5080ffdb34efe24fd104216362a" translate="yes" xml:space="preserve">
          <source>Clear out all the active components of a CV. This can happen either by an explicit &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; , or by the reference count going to zero. In the former case, we keep the CvOUTSIDE pointer, so that any anonymous children can still follow the full lexical scope chain.</source>
          <target state="translated">CV의 모든 활성 구성 요소를 지우십시오. 이것은 명시적인 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 또는 참조 카운트가 0 이 될 때 발생할 수 있습니다 . 전자의 경우 익명의 자식이 여전히 전체 어휘 범위 체인을 따를 수 있도록 CvOUTSIDE 포인터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="602d9589991fce06a0e1b36e0a5e4e7b3e5616d2" translate="yes" xml:space="preserve">
          <source>Clear out all the active components of a CV. This can happen either by an explicit &lt;code&gt;undef &amp;amp;foo&lt;/code&gt;, or by the reference count going to zero. In the former case, we keep the &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointer, so that any anonymous children can still follow the full lexical scope chain.</source>
          <target state="translated">CV의 모든 활성 구성 요소를 지 웁니다. 이것은 명시적인 &lt;code&gt;undef &amp;amp;foo&lt;/code&gt; 또는 0이되는 참조 횟수에 의해 발생할 수 있습니다 . 전자의 경우 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 포인터를 유지 하므로 익명의 자식이 전체 어휘 범위 체인을 계속 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a19b93ff531ba8a433d86d2a96a77579a9f89c2d" translate="yes" xml:space="preserve">
          <source>Clear something magical that the SV represents. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV가 나타내는 마법 같은 것을 제거하십시오. &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b91d04ce711fbc4bae58028f0e5981dcdbd67ba" translate="yes" xml:space="preserve">
          <source>Clear something magical that the SV represents. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV가 나타내는 마술 같은 것을 지우십시오. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b01d4c4067d3dfce27d55a2e8d3ed5071a36b77" translate="yes" xml:space="preserve">
          <source>Clear the cached time for COUNT rounds of the null loop.</source>
          <target state="translated">null 루프의 COUNT 라운드에 대해 캐시 된 시간을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="634725c3d47211ac8f6d330d62e66b608d7b2140" translate="yes" xml:space="preserve">
          <source>Clear the contents of &lt;code&gt;$@&lt;/code&gt;, setting it to the empty string.</source>
          <target state="translated">&lt;code&gt;$@&lt;/code&gt; 의 내용을 지우고 빈 문자열로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="46dd73c2f90db1a664404bb49713a30b15f4ee3a" translate="yes" xml:space="preserve">
          <source>Clear the default .SUFFIXES and put in our own list.</source>
          <target state="translated">기본 .SUFFIXES를 지우고 자체 목록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="16fa1383ef967c8f5a42bfabaf38f90efd78fb32" translate="yes" xml:space="preserve">
          <source>Clear the error and EOF flags. A no-op.</source>
          <target state="translated">오류 및 EOF 플래그를 지 웁니다. 안돼.</target>
        </trans-unit>
        <trans-unit id="1b8e52e2f767f085e79c243fc87322fea735897b" translate="yes" xml:space="preserve">
          <source>Clear the given handle's error indicator. Returns -1 if the handle is invalid, 0 otherwise.</source>
          <target state="translated">주어진 핸들의 오류 표시기를 지우십시오. 핸들이 유효하지 않으면 -1을, 그렇지 않으면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4550ae4c0426155ad5abb566d892619b67766b1" translate="yes" xml:space="preserve">
          <source>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</source>
          <target state="translated">범위 종료에서 지정된 패드 값을 지우십시오. (즉, 'my'의 런타임 동작)</target>
        </trans-unit>
        <trans-unit id="f63b2e6eb249335bd7855ca4714c16200d5e2e3f" translate="yes" xml:space="preserve">
          <source>Clear the pointed to pad value on scope exit. (i.e. the runtime action of &lt;code&gt;my&lt;/code&gt;)</source>
          <target state="translated">범위 종료시 지적 된 패드 값을 지 웁니다. (즉, &lt;code&gt;my&lt;/code&gt; ) 의 런타임 작업</target>
        </trans-unit>
        <trans-unit id="4788b3cbc9894af08698b7c684455094faa0d2de" translate="yes" xml:space="preserve">
          <source>Clearerr</source>
          <target state="translated">Clearerr</target>
        </trans-unit>
        <trans-unit id="57a12ccd13dcf014dfc25137bea182ded0f98ac8" translate="yes" xml:space="preserve">
          <source>Clears a slot in the current scratchpad which corresponds to &lt;code&gt;sv&lt;/code&gt; at the end of</source>
          <target state="translated">현재 스크래치 패드에서 슬롯 의 끝에있는 &lt;code&gt;sv&lt;/code&gt; 에 해당하는 슬롯을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="3ef31da8d602e77684482123705889bd007979e0" translate="yes" xml:space="preserve">
          <source>Clears an array, making it empty. Does not free the memory the av uses to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed when this function returns.</source>
          <target state="translated">배열을 비워서 비 웁니다. av가 스칼라 목록을 저장하는 데 사용하는 메모리를 비우지 않습니다. 결과적으로 소멸자가 트리거되면이 함수가 리턴 될 때 av 자체가 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd338daf3e28d8a698a54a756c5a2c73cce2208" translate="yes" xml:space="preserve">
          <source>Clears any placeholders from a hash. If a restricted hash has any of its keys marked as readonly and the key is subsequently deleted, the key is not actually deleted but is marked by assigning it a value of &amp;amp;PL_sv_placeholder. This tags it so it will be ignored by future operations such as iterating over the hash, but will still allow the hash to have a value reassigned to the key at some future point. This function clears any such placeholder keys from the hash. See Hash::Util::lock_keys() for an example of its use.</source>
          <target state="translated">자리 표시자를 해시에서 지 웁니다. 제한된 해시에 키 중 하나가 읽기 전용으로 표시되고 이후에 키가 삭제되면 키는 실제로 삭제되지 않지만 키에 &amp;amp; PL_sv_placeholder 값을 지정하여 표시됩니다. 이것은 태그를 지정하여 해시 반복과 같은 향후 작업에서 무시되지만 나중에 해시가 키에 값을 다시 할당하도록 허용합니다. 이 함수는 이러한 자리 표시 자 키를 해시에서 지 웁니다. 사용 예는 Hash :: Util :: lock_keys ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fe4e4728f7507a12291c7ff61795e7c7e55d94d" translate="yes" xml:space="preserve">
          <source>Clears any placeholders from a hash. If a restricted hash has any of its keys marked as readonly and the key is subsequently deleted, the key is not actually deleted but is marked by assigning it a value of &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt;. This tags it so it will be ignored by future operations such as iterating over the hash, but will still allow the hash to have a value reassigned to the key at some future point. This function clears any such placeholder keys from the hash. See &lt;code&gt;&lt;a href=&quot;Hash::Util#lock_keys&quot;&gt;Hash::Util::lock_keys()&lt;/a&gt;&lt;/code&gt; for an example of its use.</source>
          <target state="translated">해시에서 모든 자리 표시자를 지 웁니다. 제한된 해시에 읽기 전용으로 표시된 키가 있고 이후에 키가 삭제되는 경우 키는 실제로 삭제되지 않지만 &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; 값을 할당하여 표시됩니다 . 이 태그는 해시 반복과 같은 향후 작업에서 무시되도록 태그를 지정하지만, 향후 어느 시점에서 해시 값이 키에 재 할당되도록 허용합니다. 이 함수는 해시에서 이러한 자리 표시 자 키를 지 웁니다. 사용 예는 &lt;code&gt;&lt;a href=&quot;Hash::Util#lock_keys&quot;&gt;Hash::Util::lock_keys()&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8694e0be1c305fe59f17048c06b457a918bbcd82" translate="yes" xml:space="preserve">
          <source>Clears the internal table of &quot;seen&quot; references and returns the object itself.</source>
          <target state="translated">&quot;본&quot;참조의 내부 테이블을 지우고 개체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82cd24de384e7ca6d6eaf2bbced43a0f53cdbcf4" translate="yes" xml:space="preserve">
          <source>Click Terminal, and enable SSH service.</source>
          <target state="translated">터미널을 클릭하고 SSH 서비스를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="47b31851c74e0f5ebbb3dfaea28b4822609aa2b8" translate="yes" xml:space="preserve">
          <source>Client Callback Methods</source>
          <target state="translated">클라이언트 콜백 메소드</target>
        </trans-unit>
        <trans-unit id="37da5860354a7f86a5ca376c0d24243e5da20032" translate="yes" xml:space="preserve">
          <source>Clients of &lt;b&gt;Pod::Parser&lt;/b&gt; should use the following methods to access instance data fields:</source>
          <target state="translated">&lt;b&gt;Pod :: Parser의&lt;/b&gt; 클라이언트는 다음 방법을 사용하여 인스턴스 데이터 필드에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8f56e5d3f841631a5128f11a375acab88f21279" translate="yes" xml:space="preserve">
          <source>Clinton Gormley &amp;lt;clint@traveljury.com&amp;gt;</source>
          <target state="translated">클린턴 곰리 &amp;lt;clint@traveljury.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b6d24920f2b48bf829e8a23e9a90dfdd3440760d" translate="yes" xml:space="preserve">
          <source>Clone a CV, making a lexical closure.</source>
          <target state="translated">어휘 폐쇄를 만들어 CV를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="c2d64e5c66bdee86828e39b3698f3c30869504f6" translate="yes" xml:space="preserve">
          <source>Clone a CV, making a lexical closure. &lt;code&gt;proto&lt;/code&gt; supplies the prototype of the function: its code, pad structure, and other attributes. The prototype is combined with a capture of outer lexicals to which the code refers, which are taken from the currently-executing instance of the immediately surrounding code.</source>
          <target state="translated">CV를 복제하여 어휘를 닫습니다. &lt;code&gt;proto&lt;/code&gt; 는 함수의 프로토 타입 (코드, 패드 구조 및 기타 속성)을 제공합니다. 프로토 타입은 바로 주변 코드의 현재 실행중인 인스턴스에서 가져온 코드가 참조하는 외부 어휘 캡처와 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="5f979b64a2e1385f3005f3cb2103d9f2baf2955c" translate="yes" xml:space="preserve">
          <source>Clone the state variables associated with running and compiling pads.</source>
          <target state="translated">실행 및 컴파일 패드와 관련된 상태 변수를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="8a76336a32c405fad8ce65baf95c160bc7bd1714" translate="yes" xml:space="preserve">
          <source>Cloning an interpreter</source>
          <target state="translated">통역사 복제</target>
        </trans-unit>
        <trans-unit id="8a6abe2df9c376503528626a55b51135b582ffa4" translate="yes" xml:space="preserve">
          <source>Cloning substitution context is unimplemented</source>
          <target state="translated">복제 대체 컨텍스트가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="812eb05f8409200b76b98524bad237dfeaf7b1bd" translate="yes" xml:space="preserve">
          <source>Close Terminal and the Control Panel.</source>
          <target state="translated">터미널과 제어판을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="4b55eaddcc64cc03fb97cb5cfdc6e4a0b7e1eab8" translate="yes" xml:space="preserve">
          <source>Close the data connection and get a response from the FTP server. Returns</source>
          <target state="translated">데이터 연결을 닫고 FTP 서버에서 응답을 받으십시오. 보고</target>
        </trans-unit>
        <trans-unit id="1c0a792433b635cbfbf3a9fa1132f2f138428c0e" translate="yes" xml:space="preserve">
          <source>Close the file associated with the object and disassociate the file from the handle. Done automatically on destroy.</source>
          <target state="translated">객체와 관련된 파일을 닫고 파일을 핸들에서 분리합니다. 파괴하면 자동으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="19ff0b1a9c29ac2abd677ef11d03ad865001d751" translate="yes" xml:space="preserve">
          <source>Close the file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일을 닫습니다. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d601154aa4cecad1b8fde6d9e3eaacabc6a0aacc" translate="yes" xml:space="preserve">
          <source>Close the file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">파일을 닫습니다. 이것은 &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 설명자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6557bfb4a242f6c8d48bf95461a4833d7849fd1a" translate="yes" xml:space="preserve">
          <source>Close the handle</source>
          <target state="translated">핸들을 닫습니다</target>
        </trans-unit>
        <trans-unit id="bb4472090f184d3ee362c8c35a0ec02ede037401" translate="yes" xml:space="preserve">
          <source>Close the network connection for this ping object. The network connection is also closed by &quot;undef $p&quot;. The network connection is automatically closed if the ping object goes out of scope (e.g. $p is local to a subroutine and you leave the subroutine).</source>
          <target state="translated">이 핑 개체의 네트워크 연결을 닫습니다. &quot;undef $ p&quot;에 의해 네트워크 연결도 닫힙니다. Ping 오브젝트가 범위를 벗어나면 네트워크 연결이 자동으로 닫힙니다 (예 : $ p가 서브 루틴에 로컬이고 서브 루틴을 떠나는 경우).</target>
        </trans-unit>
        <trans-unit id="190ae3f86d0557b4127e04bcfb326cc6d030a90a" translate="yes" xml:space="preserve">
          <source>Close the stream. Should normally call &lt;code&gt;PerlIOBase_close()&lt;/code&gt; to flush itself and close layers below, and then deallocate any data structures (buffers, translation tables, ...) not held directly in the data structure.</source>
          <target state="translated">스트림을 닫습니다. 일반적으로 &lt;code&gt;PerlIOBase_close()&lt;/code&gt; 를 호출 하여 자체를 플러시하고 아래 레이어를 닫은 다음 데이터 구조에 직접 보유하지 않은 데이터 구조 (버퍼, 변환 테이블 등)를 할당 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c376981e20d6d653e0df1db5c58fa5d8bb42c5c" translate="yes" xml:space="preserve">
          <source>CloseHandle</source>
          <target state="translated">CloseHandle</target>
        </trans-unit>
        <trans-unit id="31da48802b39a62004814937a9e31811a752be6b" translate="yes" xml:space="preserve">
          <source>Closely associated with the &lt;code&gt;//g&lt;/code&gt; modifier is the &lt;code&gt;\G&lt;/code&gt; anchor. The &lt;code&gt;\G&lt;/code&gt; anchor matches at the point where the previous &lt;code&gt;//g&lt;/code&gt; match left off. &lt;code&gt;\G&lt;/code&gt; allows us to easily do context-sensitive matching:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 수정 자 와 밀접하게 관련된 것은 &lt;code&gt;\G&lt;/code&gt; 앵커입니다. &lt;code&gt;\G&lt;/code&gt; 이전 지점에서 앵커 일치 &lt;code&gt;//g&lt;/code&gt; 경기 중단. &lt;code&gt;\G&lt;/code&gt; 사용하면 상황에 맞는 일치를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735908554f005a832d720ed97de9330810e2fd8b" translate="yes" xml:space="preserve">
          <source>Closely associated with the &lt;code&gt;/g&lt;/code&gt; modifier is the &lt;code&gt;\G&lt;/code&gt; anchor. The &lt;code&gt;\G&lt;/code&gt; anchor matches at the point where the previous &lt;code&gt;/g&lt;/code&gt; match left off. &lt;code&gt;\G&lt;/code&gt; allows us to easily do context-sensitive matching:</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 수정 자 와 밀접하게 연관된 것은 &lt;code&gt;\G&lt;/code&gt; 앵커입니다. &lt;code&gt;\G&lt;/code&gt; 이전 지점에서 앵커 경기 &lt;code&gt;/g&lt;/code&gt; 의 경기 중단. &lt;code&gt;\G&lt;/code&gt; 사용하면 상황에 맞는 일치를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed2c86b22aa0e19fdc594e6bdac3be5d440f77af" translate="yes" xml:space="preserve">
          <source>Closely associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 밀접하게 연관된</target>
        </trans-unit>
        <trans-unit id="8777b46f63ed0b629d607c4fa1c16f7048b523ba" translate="yes" xml:space="preserve">
          <source>Closely associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 밀접하게 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8880824b2c0a8c129675fe4efa8e806c399c31" translate="yes" xml:space="preserve">
          <source>Closes a Win32 native handle, such as one opened via &lt;code&gt;CreateFile&lt;/code&gt;. Like most routines, returns a true value if successful and a false value [and sets &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;regLastError()&lt;/code&gt;] on failure.</source>
          <target state="translated">&lt;code&gt;CreateFile&lt;/code&gt; 을 통해 열린 것과 같은 Win32 네이티브 핸들을 닫습니다 . 대부분의 루틴과 마찬가지로 성공하면 true 값을 반환하고 실패하면 false 값을 반환합니다 [그리고 &lt;code&gt;$^E&lt;/code&gt; 및 &lt;code&gt;regLastError()&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="c1957127886446201a908976dafcb8b93a55e849" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;a href=&quot;#opendir-DIRHANDLE%2CEXPR&quot;&gt;&lt;code&gt;opendir&lt;/code&gt;&lt;/a&gt; and returns the success of that system call.</source>
          <target state="translated">&lt;a href=&quot;#opendir-DIRHANDLE%2CEXPR&quot;&gt; &lt;code&gt;opendir&lt;/code&gt; 에&lt;/a&gt; 의해 열린 디렉토리를 닫고 해당 시스템 호출의 성공을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c6e55c513c3700cb482b5228ee114dea0eb2014" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 에 의해 열린 디렉토리를 닫고 해당 시스템 호출의 성공을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1718bbd298f85e4f92aa5e14dbae95e752272e78" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 에 의해 열린 디렉토리를 닫고 해당 시스템 호출의 성공을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c738bf1c5aeadafd66d4f3177f0ec53c7a05eef3" translate="yes" xml:space="preserve">
          <source>Closes the compressed file. Any pending data is flushed to the file before it is closed.</source>
          <target state="translated">압축 파일을 닫습니다. 보류중인 데이터는 파일을 닫기 전에 파일로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d528fd6e4e57f9b4f4824f906e152d2b52aa44" translate="yes" xml:space="preserve">
          <source>Closes the current compressed data stream and starts a new one.</source>
          <target state="translated">현재 압축 된 데이터 스트림을 닫고 새 스트림을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="51e188a428b2b9dba319c461ba18765571b8c558" translate="yes" xml:space="preserve">
          <source>Closes the file or pipe associated with the filehandle, flushes the IO buffers, and closes the system file descriptor. Returns true if those operations succeed and if no error was reported by any PerlIO layer. Closes the currently selected filehandle if the argument is omitted.</source>
          <target state="translated">파일 핸들과 연관된 파일 또는 파이프를 닫고 IO 버퍼를 플러시하고 시스템 파일 설명자를 닫습니다. 해당 작업이 성공하고 PerlIO 계층에서 오류가보고되지 않은 경우 true를 반환합니다. 인수가 생략되면 현재 선택된 파일 핸들을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="fea628f203f0d9f7135eed7983ec3d8792beb442" translate="yes" xml:space="preserve">
          <source>Closes the log file and returns true on success.</source>
          <target state="translated">로그 파일을 닫고 성공하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2bbc309bbe5a51ba61bf619d197d1239e2eb8ce" translate="yes" xml:space="preserve">
          <source>Closes the output file/buffer.</source>
          <target state="translated">출력 파일 / 버퍼를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="6e6277ad25e946651d9d89cd0e79f61e229c9e4d" translate="yes" xml:space="preserve">
          <source>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파이프 된 파일 핸들을 닫으면 상위 프로세스가 하위 프로세스가 완료 될 때까지 기다린 다음 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;및 &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba43eac7b65017fd2089f1e6bc015f1ec8c511e2" translate="yes" xml:space="preserve">
          <source>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">파이프 된 파일 핸들을 닫으면 상위 프로세스가 하위 프로세스가 완료 될 때까지 대기 한 다음 상태 값을 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dcf08fb56e6d72fb32ed7e1eabe87691436e56" translate="yes" xml:space="preserve">
          <source>Closing bracket for XSUB arguments. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for other uses.</source>
          <target state="translated">XSUB 인수에 대한 닫는 대괄호. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 다른 용도에 대해서는 &lt;code&gt;PUSHMARK&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b828d78c11a19df48982701325f4289b3ec96fcd" translate="yes" xml:space="preserve">
          <source>Closing bracket for XSUB arguments. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#PUSHMARK&quot;&gt;&quot;PUSHMARK&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for other uses.</source>
          <target state="translated">XSUB 인수에 대한 닫는 대괄호. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 다른 용도에 대해서는 &lt;code&gt;&lt;a href=&quot;#PUSHMARK&quot;&gt;&quot;PUSHMARK&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36201343a78cce5fa585681913d9bd6d07bd74bb" translate="yes" xml:space="preserve">
          <source>Closing bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="translated">경량 콜백을위한 닫는 대괄호. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 &quot;경량 콜백&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="737b7e3ad0d2423ad5a8db0c5d04ee20b1d52475" translate="yes" xml:space="preserve">
          <source>Closing bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을위한 닫기 브래킷. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="025879f4052cca3f4ee52667eb96341828d977ac" translate="yes" xml:space="preserve">
          <source>Closing bracket for temporaries on a callback. See &lt;code&gt;&lt;a href=&quot;#SAVETMPS&quot;&gt;&quot;SAVETMPS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 임시를위한 닫는 대괄호. &lt;code&gt;&lt;a href=&quot;#SAVETMPS&quot;&gt;&quot;SAVETMPS&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2745a4c8776a0e5fafe11f0f22ec70fe0d72258" translate="yes" xml:space="preserve">
          <source>Closing bracket for temporaries on a callback. See &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 임시에 대한 닫는 대괄호입니다. &lt;code&gt;SAVETMPS&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33a3b7785a6c484e8e0a2dab27562cfff41e1b07" translate="yes" xml:space="preserve">
          <source>Closing bracket on a callback. See &lt;code&gt;&lt;a href=&quot;#ENTER&quot;&gt;&quot;ENTER&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 닫는 대괄호. &lt;code&gt;&lt;a href=&quot;#ENTER&quot;&gt;&quot;ENTER&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ba349d3ba72088b84c46b90a7f642094300bd0d" translate="yes" xml:space="preserve">
          <source>Closing bracket on a callback. See &lt;code&gt;ENTER&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 닫는 괄호. &lt;code&gt;ENTER&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23a4c843ad3bbdd040a62a1e5a6170f0fcb264c5" translate="yes" xml:space="preserve">
          <source>Closing the read end of a pipe before the process writing to it at the other end is done writing results in the writer receiving a SIGPIPE. If the other end can't handle that, be sure to read all the data before closing the pipe.</source>
          <target state="translated">프로세스가 다른 쪽 끝에 파이프에 쓰기 전에 파이프의 읽기 쪽을 닫으면 작성기가 SIGPIPE를받습니다. 다른 쪽 끝이이를 처리 할 수없는 경우 파이프를 닫기 전에 모든 데이터를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="684bcc83d42f8ebc0a3f44360c0e98695b53b5c1" translate="yes" xml:space="preserve">
          <source>Closure prototype called</source>
          <target state="translated">클로저 프로토 타입 호출</target>
        </trans-unit>
        <trans-unit id="b6d86b58c6ea474356b305c2ad2f3387941bd459" translate="yes" xml:space="preserve">
          <source>Closures are documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">클로저는 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e50ba612fbe1c93f394383c8388d370e33f827" translate="yes" xml:space="preserve">
          <source>Closures are most often used in programming languages where you can have the return value of a function be itself a function, as you can in Perl. Note that some languages provide anonymous functions but are not capable of providing proper closures: the Python language, for example. For more information on closures, check out any textbook on functional programming. Scheme is a language that not only supports but encourages closures.</source>
          <target state="translated">클로저는 Perl 에서처럼 함수의 반환 값을 함수로 가질 수있는 프로그래밍 언어에서 가장 자주 사용됩니다. 일부 언어는 익명 함수를 제공하지만 Python 언어와 같은 적절한 클로저를 제공 할 수는 없습니다. 클로저에 대한 자세한 내용은 함수형 프로그래밍에 대한 모든 교과서를 확인하십시오. 체계는 폐쇄를 지원할뿐만 아니라 격려하는 언어입니다.</target>
        </trans-unit>
        <trans-unit id="625dad30655b90e54e26f3f025084dbfc6f7497b" translate="yes" xml:space="preserve">
          <source>Closures are often used for less esoteric purposes. For example, when you want to pass in a bit of code into a function:</source>
          <target state="translated">폐쇄는 종종 난해한 목적으로 사용됩니다. 예를 들어, 약간의 코드를 함수에 전달하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5161af4a1cac3a1b9b45f56c8dea0b53f7bfbecc" translate="yes" xml:space="preserve">
          <source>Co-existence with stdio</source>
          <target state="translated">stdio와 공존</target>
        </trans-unit>
        <trans-unit id="6517f8be2c6a95c643a9a9b5bb9a2d69ac206184" translate="yes" xml:space="preserve">
          <source>Cocoa</source>
          <target state="translated">Cocoa</target>
        </trans-unit>
        <trans-unit id="95c99c8aeaa2e8fc96be370bcb2d2ba452daba68" translate="yes" xml:space="preserve">
          <source>Code &lt;code&gt;x&lt;/code&gt; skips a byte, since we don't need the count yet. Code &lt;code&gt;n&lt;/code&gt; takes care of the 16-bit big-endian integer address, and &lt;code&gt;C&lt;/code&gt; unpacks the record type. Being at offset 4, where the data begins, we need the count. &lt;code&gt;X4&lt;/code&gt; brings us back to square one, which is the byte at offset 0. Now we pick up the count, and zoom forth to offset 4, where we are now fully furnished to extract the exact number of data bytes, leaving the trailing checksum byte alone.</source>
          <target state="translated">코드 &lt;code&gt;x&lt;/code&gt; 는 아직 카운트가 필요하지 않기 때문에 바이트를 건너 뜁니다. 코드 &lt;code&gt;n&lt;/code&gt; 은 16 비트 빅 엔디안 정수 주소를 처리하고 &lt;code&gt;C&lt;/code&gt; 는 레코드 유형을 압축 해제합니다. 데이터가 시작되는 오프셋 4에 있기 때문에 카운트가 필요합니다. &lt;code&gt;X4&lt;/code&gt; 는 오프셋 0의 바이트 인 정사각형 1로 다시 돌아옵니다. 이제 카운트를 가져 와서 오프셋 4로 축소하여 정확한 데이터 바이트 수를 추출하여 후행 체크섬 바이트를 남겨 둡니다. 혼자.</target>
        </trans-unit>
        <trans-unit id="9af6c66c871662d13b2ee5b92ff6ae3f53e9f58a" translate="yes" xml:space="preserve">
          <source>Code and documentation based on the Math::BigInt::Calc module by Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt;</source>
          <target state="translated">Tels &amp;lt;nospam-abuse@bloodgate.com&amp;gt;의 Math :: BigInt :: Calc 모듈을 기반으로 한 코드 및 문서</target>
        </trans-unit>
        <trans-unit id="88ed008dc7a2ff797ab17a3de73dfdb055a98c4d" translate="yes" xml:space="preserve">
          <source>Code blocks such as &lt;code&gt;(?{BLOCK})&lt;/code&gt; are handled by temporarily passing control back to the perl parser, in a similar way that an interpolated array subscript expression such as &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; would be.</source>
          <target state="translated">&lt;code&gt;(?{BLOCK})&lt;/code&gt; 과 같은 코드 블록 은 &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; 와 같은 보간 배열 첨자 표현식과 유사한 방식으로 제어를 perl 파서에 일시적으로 다시 전달하여 처리됩니다 . &quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="762d66380b843da111702ccfbb2c67a26389d7e3" translate="yes" xml:space="preserve">
          <source>Code evaluation</source>
          <target state="translated">코드 평가</target>
        </trans-unit>
        <trans-unit id="ad324d0623845b77009d134b9199e2f4016ff03f" translate="yes" xml:space="preserve">
          <source>Code expressions are zero-width assertions, and the value they return depends on their environment. There are two possibilities: either the code expression is used as a conditional in a conditional expression &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)...)&lt;/code&gt;, or it is not. If the code expression is a conditional, the code is evaluated and the result (</source>
          <target state="translated">코드 표현식은 너비가 0 인 어설 션이며 반환되는 값은 환경에 따라 다릅니다. 두 가지 가능성이 있습니다. 코드 표현식이 조건식 &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)...)&lt;/code&gt; 에서 &lt;i&gt;조건부로 사용&lt;/i&gt; 되거나 그렇지 않습니다. 코드 표현식이 조건부이면 코드가 평가되고 결과 (</target>
        </trans-unit>
        <trans-unit id="37d37b9a8d116d9e1ae5c945c68e058e2feb14aa" translate="yes" xml:space="preserve">
          <source>Code expressions are zero-width assertions, and the value they return depends on their environment. There are two possibilities: either the code expression is used as a conditional in a conditional expression &lt;code&gt;(?(condition)...)&lt;/code&gt;, or it is not. If the code expression is a conditional, the code is evaluated and the result (i.e., the result of the last statement) is used to determine truth or falsehood. If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . The variable &lt;code&gt;$^R&lt;/code&gt; can then be used in code expressions later in the regexp. Here are some silly examples:</source>
          <target state="translated">코드 표현식은 너비가 0 인 어설 션이며 반환되는 값은 환경에 따라 다릅니다. 코드 표현식이 조건식 &lt;code&gt;(?(condition)...)&lt;/code&gt; 에서 조건부로 사용 되거나 그렇지 않은 두 가지 가능성이 있습니다 . 코드 표현식이 조건부 인 경우 코드가 평가되고 결과 (즉, 마지막 문의 결과)가 진실 또는 허위를 결정하는 데 사용됩니다. 코드 표현식이 조건부로 사용되지 않으면 어설 션은 항상 true로 평가되고 결과는 특수 변수 &lt;code&gt;$^R&lt;/code&gt; 됩니다. 변수 &lt;code&gt;$^R&lt;/code&gt; 은 나중에 정규 표현식의 코드 표현식에서 사용될 수 있습니다. 다음은 어리석은 예입니다.</target>
        </trans-unit>
        <trans-unit id="16588d7ea09d6c8a62bccdc2d6ce591ced66cdbf" translate="yes" xml:space="preserve">
          <source>Code expressions, conditional expressions, and independent expressions are</source>
          <target state="translated">코드 표현식, 조건식 및 독립 표현식은</target>
        </trans-unit>
        <trans-unit id="0d4a4669a2b66538a054bb02710d7250ecbe4161" translate="yes" xml:space="preserve">
          <source>Code for &lt;code&gt;constant()&lt;/code&gt; s regenerated by Nicholas Clark &amp;lt;</source>
          <target state="translated">Nicholas Clark이 다시 생성 한 &lt;code&gt;constant()&lt;/code&gt; 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5104f2fb52438f2a95c6656e61514fb0901b155c" translate="yes" xml:space="preserve">
          <source>Code for &lt;code&gt;constant()&lt;/code&gt;s regenerated by Nicholas Clark &amp;lt;</source>
          <target state="translated">Nicholas Clark &amp;lt;에 의해 재생성 된 &lt;code&gt;constant()&lt;/code&gt; 의 코드</target>
        </trans-unit>
        <trans-unit id="d3cbaac4d40358f731935693702135f199e63c95" translate="yes" xml:space="preserve">
          <source>Code is executed in the caller's package.</source>
          <target state="translated">코드는 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="55f7b9d679e82f6ff6b32abc5e72be9fa415121f" translate="yes" xml:space="preserve">
          <source>Code missing after '/'</source>
          <target state="translated">'/'뒤에 코드 누락</target>
        </trans-unit>
        <trans-unit id="763a00414c37fe629fac947138c2be136cbf143b" translate="yes" xml:space="preserve">
          <source>Code of the form:</source>
          <target state="translated">형식의 코드 :</target>
        </trans-unit>
        <trans-unit id="44b7c0500e40c11db7bf0e11bd6e37ab7d88c5ec" translate="yes" xml:space="preserve">
          <source>Code originally inside MM_Win32. Original author unknown.</source>
          <target state="translated">원래 MM_Win32 내부의 코드입니다. 원저자 불명</target>
        </trans-unit>
        <trans-unit id="de9401c97e1f4ad9abf2e4fafee48326fcab7f4e" translate="yes" xml:space="preserve">
          <source>Code point 0x%X is not Unicode, and not portable</source>
          <target state="translated">코드 포인트 0x % X는 유니 코드가 아니며 이식 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e53339de09de2795af9c075262e4563620af5d1" translate="yes" xml:space="preserve">
          <source>Code point 0x%X is not Unicode, may not be portable</source>
          <target state="translated">코드 포인트 0x % X는 유니 코드가 아니므로 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b3f7aaeddd506c37fdcace0f412c9da257991f8" translate="yes" xml:space="preserve">
          <source>Code points above 0x7FFF_FFFF (2**31 - 1) were never specified in any standard, and so some extension must be used to express them. Perl uses a natural extension to UTF-8 to represent the ones up to 2**36-1, and invented a further extension to represent even higher ones, so that any code point that fits in a 64-bit word can be represented. Text using these extensions is not likely to be portable to non-Perl code. We lump both of these extensions together and refer to them as Perl extended UTF-8. There exist other extensions that people have invented, incompatible with Perl's.</source>
          <target state="translated">0x7FFF_FFFF (2 ** 31-1) 이상의 코드 포인트는 어떤 표준에도 지정되지 않았으므로이를 표현하기 위해 일부 확장을 사용해야합니다. Perl은 UTF-8에 대한 자연스러운 확장을 사용하여 최대 2 ** 36-1까지 표현하고 더 높은 확장을 개발하여 64 비트 단어에 맞는 모든 코드 포인트를 표현할 수 있습니다. 이러한 확장을 사용하는 텍스트는 Perl이 아닌 코드로 이식 할 수 없습니다. 이 두 확장을 함께 묶어 Perl 확장 UTF-8이라고합니다. 사람들이 펄과 호환되지 않는 다른 확장 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8436b969660cb68895cc5b50cc98f0ce889fd84c" translate="yes" xml:space="preserve">
          <source>Code repository for CPAN distribution: &lt;a href=&quot;https://github.com/Dual-Life/Thread-Queue&quot;&gt;https://github.com/Dual-Life/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">CPAN 배포 용 코드 저장소 : &lt;a href=&quot;https://github.com/Dual-Life/Thread-Queue&quot;&gt;https://github.com/Dual-Life/Thread-Queue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3226dc817f3e43a541d4477c8cbc2a285c0d917" translate="yes" xml:space="preserve">
          <source>Code repository for CPAN distribution: &lt;a href=&quot;https://github.com/Dual-Life/Thread-Semaphore&quot;&gt;https://github.com/Dual-Life/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">CPAN 배포 용 코드 저장소 : &lt;a href=&quot;https://github.com/Dual-Life/Thread-Semaphore&quot;&gt;https://github.com/Dual-Life/Thread-Semaphore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94acf728f03fa23f03ba8018e9898ca330c48e77" translate="yes" xml:space="preserve">
          <source>Code repository for CPAN distribution: &lt;a href=&quot;https://github.com/Dual-Life/threads&quot;&gt;https://github.com/Dual-Life/threads&lt;/a&gt;</source>
          <target state="translated">CPAN 배포 용 코드 저장소 : &lt;a href=&quot;https://github.com/Dual-Life/threads&quot;&gt;https://github.com/Dual-Life/threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25b71075d4c9fabe584d6768feef1abbfedbb667" translate="yes" xml:space="preserve">
          <source>Code repository for CPAN distribution: &lt;a href=&quot;https://github.com/Dual-Life/threads-shared&quot;&gt;https://github.com/Dual-Life/threads-shared&lt;/a&gt;</source>
          <target state="translated">CPAN 배포 용 코드 저장소 : &lt;a href=&quot;https://github.com/Dual-Life/threads-shared&quot;&gt;https://github.com/Dual-Life/threads-shared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="242e717fb5b853da360c4c4e3fd5e16c899cc09d" translate="yes" xml:space="preserve">
          <source>Code tree</source>
          <target state="translated">코드 트리</target>
        </trans-unit>
        <trans-unit id="bda59a9692c886a3b695a5c5e5d92b31fb40c2d3" translate="yes" xml:space="preserve">
          <source>Code using &lt;code&gt;File::Glob::glob()&lt;/code&gt; should call &lt;code&gt;File::Glob::bsd_glob()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;File::Glob::glob()&lt;/code&gt; 사용하는 코드 는 대신 &lt;code&gt;File::Glob::bsd_glob()&lt;/code&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="238c9390ad5966dbe9669eb0b38a5c9c564b39c3" translate="yes" xml:space="preserve">
          <source>Code which is compiled outside the compartment can choose to place variables into (or</source>
          <target state="translated">구획 외부에서 컴파일 된 코드는 변수를 (또는</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="3f51a692049ded00dfd0b82b9eb597826fa63f6e" translate="yes" xml:space="preserve">
          <source>Coderef of a subroutine to call inside of the main waiting loop (while &lt;code&gt;run_forked&lt;/code&gt; waits for the external to finish or fail). It is useful to stop running external process before it ends by itself, e.g.</source>
          <target state="translated">메인 대기 루프 내부에서 호출 할 서브 루틴의 &lt;code&gt;run_forked&lt;/code&gt; ( run_forked 는 외부가 완료되거나 실패 할 때 까지 대기 하는 동안 ). 자체적으로 종료되기 전에 외부 프로세스 실행을 중지하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7346b6c55ef1dd3ee635f412ba8c8fa0b34bc040" translate="yes" xml:space="preserve">
          <source>Coderef of a subroutine to call when a portion of data is received on STDERR from the executing program.</source>
          <target state="translated">STDERR에서 실행중인 프로그램으로부터 일부 데이터가 수신 될 때 호출 할 서브 루틴의 코드 참조.</target>
        </trans-unit>
        <trans-unit id="0e6272092332283344899c5d9151fdf70f8638d8" translate="yes" xml:space="preserve">
          <source>Coderef of a subroutine to call when a portion of data is received on STDOUT from the executing program.</source>
          <target state="translated">STDOUT에서 실행중인 프로그램으로부터 일부 데이터가 수신 될 때 호출 할 서브 루틴의 코드 참조.</target>
        </trans-unit>
        <trans-unit id="cc3b474bef3775734e7b035b9dfcfb4a3687ffad" translate="yes" xml:space="preserve">
          <source>Coding style is a matter of personal taste. Many people evolve their style over several years as they learn what helps them write and maintain good code. Here's one set of assorted suggestions that seem to be widely used by experienced developers:</source>
          <target state="translated">코딩 스타일은 개인적인 취향의 문제입니다. 많은 사람들이 좋은 코드를 작성하고 유지하는 데 도움이되는 것을 배우면서 몇 년 동안 자신의 스타일을 발전시킵니다. 다음은 숙련 된 개발자가 널리 사용하는 것으로 보이는 여러 가지 제안입니다.</target>
        </trans-unit>
        <trans-unit id="83c20e2b46967a4d332883ed6f06dc35bb23a9dc" translate="yes" xml:space="preserve">
          <source>Coerce the given SV to a double and return it. See &lt;code&gt;SvNVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 더블로 강제 변환하고 리턴하십시오. sv를 한 번만 평가하는 버전 은 &lt;code&gt;SvNVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1439f0faa00b37d7eb0523484bb7109ca3648951" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to IV and returns it. The returned value in many circumstances will get stored in &lt;code&gt;sv&lt;/code&gt;'s IV slot, but not in all cases. (Use &lt;code&gt;&lt;a href=&quot;#sv_setiv&quot;&gt;&quot;sv_setiv&quot;&lt;/a&gt;&lt;/code&gt; to make sure it does).</source>
          <target state="translated">주어진 SV를 IV로 강제 변환하고 반환합니다. 많은 상황에서 반환 된 값은 &lt;code&gt;sv&lt;/code&gt; 의 IV 슬롯에 저장 되지만 모든 경우에 저장 되지는 않습니다. ( &lt;code&gt;&lt;a href=&quot;#sv_setiv&quot;&gt;&quot;sv_setiv&quot;&lt;/a&gt;&lt;/code&gt; 를 사용 하여 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="78cc7c3007865e80d454f255101cca70238d1909" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to NV and returns it. The returned value in many circumstances will get stored in &lt;code&gt;sv&lt;/code&gt;'s NV slot, but not in all cases. (Use &lt;code&gt;&lt;a href=&quot;#sv_setnv&quot;&gt;&quot;sv_setnv&quot;&lt;/a&gt;&lt;/code&gt; to make sure it does).</source>
          <target state="translated">주어진 SV를 NV로 강제 변환하고 반환합니다. 많은 상황에서 반환 된 값은 &lt;code&gt;sv&lt;/code&gt; 의 NV 슬롯에 저장 되지만 모든 경우에 저장 되지는 않습니다. ( &lt;code&gt;&lt;a href=&quot;#sv_setnv&quot;&gt;&quot;sv_setnv&quot;&lt;/a&gt;&lt;/code&gt; 를 사용 하여 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="9da642418dbe4eaadacbf20eb4f86655556d568a" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to UV and returns it. The returned value in many circumstances will get stored in &lt;code&gt;sv&lt;/code&gt;'s UV slot, but not in all cases. (Use &lt;code&gt;&lt;a href=&quot;#sv_setuv&quot;&gt;&quot;sv_setuv&quot;&lt;/a&gt;&lt;/code&gt; to make sure it does).</source>
          <target state="translated">주어진 SV를 UV로 강제 변환하고 반환합니다. 많은 상황에서 반환 된 값은 &lt;code&gt;sv&lt;/code&gt; 의 UV 슬롯에 저장 되지만 모든 경우에 저장 되지는 않습니다. ( &lt;code&gt;&lt;a href=&quot;#sv_setuv&quot;&gt;&quot;sv_setuv&quot;&lt;/a&gt;&lt;/code&gt; 를 사용 하여 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="3b9cb8dd077ee8e9789410150752cb5df2cf59b7" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to a double and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvNV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 double로 강제 변환하고 리턴합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvNV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bac4ad8b9286fd32a256bd30b536befa1ae2a9ff" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an integer and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvIV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 정수로 강제 변환하고 반환합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvIV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4398a91485317bebc11f68b77ab6f61e17b4142" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an integer and returns it. See &lt;code&gt;SvIVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 정수로 강제 변환하고 반환합니다. sv를 한 번만 평가할 수있는 버전 은 &lt;code&gt;SvIVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7056ee3094a77bc1cd5afdf0d2f7a644af6c1de6" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an unsigned integer and returns it. Guarantees to evaluate &lt;code&gt;sv&lt;/code&gt; only once. Only use this if &lt;code&gt;sv&lt;/code&gt; is an expression with side effects, otherwise use the more efficient &lt;code&gt;SvUV&lt;/code&gt; .</source>
          <target state="translated">주어진 SV를 부호없는 정수로 강제 변환하고 반환합니다. &lt;code&gt;sv&lt;/code&gt; 를 한 번만 평가할 수 있습니다. &lt;code&gt;sv&lt;/code&gt; 가 부작용이있는 표현식 인 경우에만 사용 하고 그렇지 않으면보다 효율적인 &lt;code&gt;SvUV&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="796a973103d95c3243cc98edd65b34d9d2c5c67f" translate="yes" xml:space="preserve">
          <source>Coerces the given SV to an unsigned integer and returns it. See &lt;code&gt;SvUVx&lt;/code&gt; for a version which guarantees to evaluate sv only once.</source>
          <target state="translated">주어진 SV를 부호없는 정수로 강제 변환하고 반환합니다. sv를 한 번만 평가할 수있는 버전 은 &lt;code&gt;SvUVx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49c49717ff09c67db8d10c08594119a0d133d246" translate="yes" xml:space="preserve">
          <source>Collate/CJK/*.pm</source>
          <target state="translated">Collate/CJK/*.pm</target>
        </trans-unit>
        <trans-unit id="12531e2c5b86aed0f71274cc20edcb8aadae3b4c" translate="yes" xml:space="preserve">
          <source>Collate/Locale.pm</source>
          <target state="translated">Collate/Locale.pm</target>
        </trans-unit>
        <trans-unit id="ac7a02f9743685f110e221f67c081d8076b3a9ed" translate="yes" xml:space="preserve">
          <source>Collate/Locale/*.pm</source>
          <target state="translated">Collate/Locale/*.pm</target>
        </trans-unit>
        <trans-unit id="fa0c7bf1775e1c9275988dd635488dcfa27e43d9" translate="yes" xml:space="preserve">
          <source>Collate/allkeys.txt</source>
          <target state="translated">Collate/allkeys.txt</target>
        </trans-unit>
        <trans-unit id="d3838b05ac03a3af9736ff68451b7f3620421d92" translate="yes" xml:space="preserve">
          <source>Collation of strings containing embedded &lt;code&gt;NUL&lt;/code&gt; characters</source>
          <target state="translated">포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자를 포함하는 문자열의 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="18549aa8a36d18f9b318470ae9821a1fcf274031" translate="yes" xml:space="preserve">
          <source>Collation of strings containing embedded NUL characters</source>
          <target state="translated">포함 된 NUL 문자를 포함하는 문자열의 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="1e80d6bc20f631d59e355402947af07d5291bfe8" translate="yes" xml:space="preserve">
          <source>Collation reordering is not supported</source>
          <target state="translated">데이터 정렬 순서 변경은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea772ad5805b57d6b06159ae7393c73ccddc1d9c" translate="yes" xml:space="preserve">
          <source>CollationTest_NON_IGNORABLE.txt</source>
          <target state="translated">CollationTest_NON_IGNORABLE.txt</target>
        </trans-unit>
        <trans-unit id="7b7f09f7ff55d9003bbbf6e2b6ad35cc1d55629d" translate="yes" xml:space="preserve">
          <source>CollationTest_SHIFTED.txt</source>
          <target state="translated">CollationTest_SHIFTED.txt</target>
        </trans-unit>
        <trans-unit id="75fb813627b472bae8bccd59c58705cc36ebe703" translate="yes" xml:space="preserve">
          <source>Collection of tools used by &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; and friends.</source>
          <target state="translated">&lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; 와 친구들이 사용하는 도구 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="ca66835bc771bd4402dea87da5941178b9bd8799" translate="yes" xml:space="preserve">
          <source>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear malloced buffer, which the caller &lt;b&gt;must&lt;/b&gt; Perl_free_c_backtrace().</source>
          <target state="translated">역 추적 (일명 &quot;스택 트레이스&quot;)을 단일 선형 malloced 버퍼로 수집합니다.이 버퍼는 호출자 &lt;b&gt;가&lt;/b&gt; Perl_free_c_backtrace () &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fd55a62dc71f117a550a11fe2cc351f02e961ba8" translate="yes" xml:space="preserve">
          <source>Collects the backtrace (aka &quot;stacktrace&quot;) into a single linear malloced buffer, which the caller &lt;b&gt;must&lt;/b&gt;&lt;code&gt;Perl_free_c_backtrace()&lt;/code&gt;.</source>
          <target state="translated">역 추적 (일명 &quot;stacktrace&quot;)을 단일 선형 malloced 버퍼로 수집합니다. 호출자 &lt;b&gt;는 &lt;/b&gt; &lt;code&gt;Perl_free_c_backtrace()&lt;/code&gt; &lt;b&gt;여야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e2794035cca1617a1f9360d576b9e234bb68e64d" translate="yes" xml:space="preserve">
          <source>Color for debugging messages?</source>
          <target state="translated">메시지 디버깅을위한 색상?</target>
        </trans-unit>
        <trans-unit id="931d4698b17a59cb56194fcf346f0e3466642612" translate="yes" xml:space="preserve">
          <source>Color for normal output?</source>
          <target state="translated">정상적인 출력을위한 색상?</target>
        </trans-unit>
        <trans-unit id="943c85b3de9955c182721971471df60c6005726b" translate="yes" xml:space="preserve">
          <source>Color for warnings?</source>
          <target state="translated">경고 색상?</target>
        </trans-unit>
        <trans-unit id="37277b98a26979971b3578b4784f262eaebdf1a4" translate="yes" xml:space="preserve">
          <source>Color screen output using ANSI escape sequences</source>
          <target state="translated">ANSI 이스케이프 시퀀스를 사용한 컬러 화면 출력</target>
        </trans-unit>
        <trans-unit id="ffcd8cdd6d4fafb69165ab91311fd30e417a36d0" translate="yes" xml:space="preserve">
          <source>Color support requires &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; and, on windows platforms, also &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt;. If the necessary module(s) are not installed colored output will not be available.</source>
          <target state="translated">색상 지원에는 &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 가 필요하며 Windows 플랫폼에서는 &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI도 필요&lt;/a&gt; 합니다. 필요한 모듈이 설치되지 않은 경우 컬러 출력을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="814253eeac185847ba47c5faad82c62ef62cc160" translate="yes" xml:space="preserve">
          <source>Color support requires &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; on Unix-like platforms and &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; on windows. If the necessary module is not installed colored output will not be available.</source>
          <target state="translated">색상을 지원하려면 Unix와 유사한 플랫폼에서 &lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 가 필요 하고 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Windows에서는 Win32 :: Console이&lt;/a&gt; 필요합니다. 필요한 모듈이 설치되어 있지 않으면 컬러 출력을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="303879dcc89284b00c097930cabcb85cc2dc5e5d" translate="yes" xml:space="preserve">
          <source>Colored Test Output</source>
          <target state="translated">컬러 테스트 출력</target>
        </trans-unit>
        <trans-unit id="8500a95267a6088fd62196511e82c874787b2950" translate="yes" xml:space="preserve">
          <source>Colored test output using &lt;a href=&quot;TAP::Formatter::Color&quot;&gt;TAP::Formatter::Color&lt;/a&gt; is the default, but if output is not to a terminal, color is disabled. You can override this by adding the &lt;code&gt;--color&lt;/code&gt; switch.</source>
          <target state="translated">&lt;a href=&quot;TAP::Formatter::Color&quot;&gt;TAP :: Formatter :: Color를&lt;/a&gt; 사용한 컬러 테스트 출력 이 기본값이지만 터미널로 출력되지 않으면 컬러가 비활성화됩니다. &lt;code&gt;--color&lt;/code&gt; 스위치 를 추가하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8864b43824503a2f85bf0964b2768f6f871f7626" translate="yes" xml:space="preserve">
          <source>Colored test output using &lt;a href=&quot;tap/formatter/color&quot;&gt;TAP::Formatter::Color&lt;/a&gt; is the default, but if output is not to a terminal, color is disabled. You can override this by adding the &lt;code&gt;--color&lt;/code&gt; switch.</source>
          <target state="translated">&lt;a href=&quot;tap/formatter/color&quot;&gt;TAP :: Formatter :: Color를&lt;/a&gt; 사용하는 컬러 테스트 출력 이 기본값이지만 출력이 터미널로 출력되지 않으면 컬러가 비활성화됩니다. &lt;code&gt;--color&lt;/code&gt; 스위치 를 추가하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4410624857a9a39d3470d2f887cb38370bddb90" translate="yes" xml:space="preserve">
          <source>Column 1</source>
          <target state="translated">열 1</target>
        </trans-unit>
        <trans-unit id="62f84ac056c4c73f73e5266ab0c3a844a0f86eb3" translate="yes" xml:space="preserve">
          <source>Column 2</source>
          <target state="translated">열 2</target>
        </trans-unit>
        <trans-unit id="f47e7f7f6997145626eff833add5e11cf1169935" translate="yes" xml:space="preserve">
          <source>Column 3</source>
          <target state="translated">열 3</target>
        </trans-unit>
        <trans-unit id="3923712e15f6cde93b49aa53ec44f5c8d09bcfff" translate="yes" xml:space="preserve">
          <source>Combination of perl's malloc() and rigid DLL name resolution creates a special problem with library functions which expect their return value to be free()d by system's free(). To facilitate extensions which need to call such functions, system memory-allocation functions are still available with the prefix &lt;code&gt;emx_&lt;/code&gt; added. (Currently only DLL perl has this, it should propagate to</source>
          <target state="translated">perl의 malloc ()과 엄격한 DLL 이름 확인의 조합은 시스템의 free ()에 의해 반환 값이 free ()가 될 것으로 기대하는 라이브러리 함수에 특별한 문제를 만듭니다. 이러한 함수를 호출해야하는 확장을 용이하게하기 위해 접두어 &lt;code&gt;emx_&lt;/code&gt; 를 추가 하여 시스템 메모리 할당 기능을 계속 사용할 수 있습니다 . (현재 DLL perl만이 이것을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e162a6515086455c7354669175e63cf762e730" translate="yes" xml:space="preserve">
          <source>Combined with &lt;code&gt;stdout_handler&lt;/code&gt; and &lt;code&gt;stderr_handler&lt;/code&gt; allows terminating external command based on its output. Could also be used as a timer without engaging with &lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt; (signals).</source>
          <target state="translated">&lt;code&gt;stdout_handler&lt;/code&gt; 및 &lt;code&gt;stderr_handler&lt;/code&gt; 와 결합 하면 출력에 따라 외부 명령을 종료 할 수 있습니다. &lt;a href=&quot;alarm&quot;&gt;알람&lt;/a&gt; (신호) 없이 타이머로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4084d48b233ef3ed460fe34c2d006a3d174500e" translate="yes" xml:space="preserve">
          <source>Combining RE Pieces</source>
          <target state="translated">RE 조각 결합</target>
        </trans-unit>
        <trans-unit id="d5245a49f5313d2490851a0af63ee29dbcb57fb2" translate="yes" xml:space="preserve">
          <source>Combining that form with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and putting parentheses immediately around a hash are forbidden (because it is not clear what they should do):</source>
          <target state="translated">해당 형식을 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 과 결합하고 괄호를 해시 주위에 두는 것은 금지되어 있습니다 (왜냐하면 무엇을 해야하는지 명확하지 않기 때문입니다).</target>
        </trans-unit>
        <trans-unit id="2da6f341ea06cfbda7a953d08a38c6933556547f" translate="yes" xml:space="preserve">
          <source>Combining that form with &lt;code&gt;local&lt;/code&gt; and putting parentheses immediately around a hash are forbidden (because it is not clear what they should do):</source>
          <target state="translated">해당 양식을 &lt;code&gt;local&lt;/code&gt; 과 결합 하고 해시 바로 주위에 괄호를 넣는 것은 금지되어 있습니다 (어떻게해야하는지 명확하지 않기 때문에).</target>
        </trans-unit>
        <trans-unit id="763921651d0da6d3a3be0284d4211879873417fe" translate="yes" xml:space="preserve">
          <source>Combining two pack codes with a slash (&lt;code&gt;/&lt;/code&gt;) associates them with a single value from the argument list. In &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the length of the argument is taken and packed according to the first code while the argument itself is added after being converted with the template code after the slash. This saves us the trouble of inserting the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; call, but it is in &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; where we really score: The value of the length byte marks the end of the string to be taken from the buffer. Since this combination doesn't make sense except when the second pack code isn't &lt;code&gt;a*&lt;/code&gt; , &lt;code&gt;A*&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; , Perl won't let you.</source>
          <target state="translated">두 팩 코드를 슬래시 ( &lt;code&gt;/&lt;/code&gt; )와 결합하면 인수 목록에서 단일 값과 연관됩니다. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 에서는 인수의 길이가 첫 번째 코드에 따라 채워지고 압축되며 인수 자체는 슬래시 후 템플리트 코드로 변환 된 후 추가됩니다. 이것은 우리에게 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 호출 을 삽입하는 수고를 덜어 주지만 우리가 실제로 점수를 매기는 곳의 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; . 길이 바이트 값은 버퍼에서 가져올 문자열의 끝을 나타냅니다. 이 조합은 두 번째 팩 코드가 &lt;code&gt;a*&lt;/code&gt; , &lt;code&gt;A*&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; 가 아닌 경우를 제외하고는 의미가 없으므로 Perl에서는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20db66d1a2628ffa3532fa0ee858a072ce28b6d2" translate="yes" xml:space="preserve">
          <source>Combining two pack codes with a slash (&lt;code&gt;/&lt;/code&gt;) associates them with a single value from the argument list. In &lt;code&gt;pack&lt;/code&gt;, the length of the argument is taken and packed according to the first code while the argument itself is added after being converted with the template code after the slash. This saves us the trouble of inserting the &lt;code&gt;length&lt;/code&gt; call, but it is in &lt;code&gt;unpack&lt;/code&gt; where we really score: The value of the length byte marks the end of the string to be taken from the buffer. Since this combination doesn't make sense except when the second pack code isn't &lt;code&gt;a*&lt;/code&gt;, &lt;code&gt;A*&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;, Perl won't let you.</source>
          <target state="translated">두 팩 코드를 슬래시 ( &lt;code&gt;/&lt;/code&gt; )로 결합하면 인수 목록의 단일 값과 연관됩니다. 에서는 &lt;code&gt;pack&lt;/code&gt; 인자 자체가 슬래시 후의 템플릿 코드로 변환 된 후에 첨가하면서, 인수의 길이는 첫 번째 코드에 따라 채취 및 포장된다. 이것은 우리가 &lt;code&gt;length&lt;/code&gt; 호출 을 삽입하는 수고를 덜어 주지만 우리가 실제로 점수를 매기 는 부분은 &lt;code&gt;unpack&lt;/code&gt; 에 있습니다. 길이 바이트의 값은 버퍼에서 가져올 문자열의 끝을 표시합니다. 이 조합은 두 번째 팩 코드가 &lt;code&gt;a*&lt;/code&gt; , &lt;code&gt;A*&lt;/code&gt; 또는 &lt;code&gt;Z*&lt;/code&gt; 가 아닌 경우를 제외하고는 의미가 없으므로 Perl은 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32bae387055126d95306c7bb6532b73268f5a2d5" translate="yes" xml:space="preserve">
          <source>Comma Operator</source>
          <target state="translated">쉼표 연산자</target>
        </trans-unit>
        <trans-unit id="62802cbe492e03ca981781cca641adb33725f540" translate="yes" xml:space="preserve">
          <source>Command Line Options, an Introduction</source>
          <target state="translated">명령 줄 옵션, 소개</target>
        </trans-unit>
        <trans-unit id="18beb4c43cfe79cec6e126626aa3ad7fd190e477" translate="yes" xml:space="preserve">
          <source>Command Paragraph</source>
          <target state="translated">명령 단락</target>
        </trans-unit>
        <trans-unit id="8a1ca3d4fefdc5713e41ac29c4283a0c7477fc1a" translate="yes" xml:space="preserve">
          <source>Command Shell</source>
          <target state="translated">명령 셸</target>
        </trans-unit>
        <trans-unit id="417187d63fa0def34d24b8c333083506dc32200a" translate="yes" xml:space="preserve">
          <source>Command Switches</source>
          <target state="translated">명령 스위치</target>
        </trans-unit>
        <trans-unit id="f6fe35e209171bf42b301a97ecb399ad5a56cfaf" translate="yes" xml:space="preserve">
          <source>Command line</source>
          <target state="translated">커맨드 라인</target>
        </trans-unit>
        <trans-unit id="12f9d6c76aaded8fe20cb1cb15944fff0ce754c0" translate="yes" xml:space="preserve">
          <source>Command line operated programs traditionally take their arguments from the command line, for example filenames or other information that the program needs to know. Besides arguments, these programs often take command line</source>
          <target state="translated">명령 행 운영 프로그램은 전통적으로 명령 행에서 인수를 가져옵니다 (예 : 파일 이름 또는 프로그램이 알아야하는 기타 정보). 인수 외에도 이러한 프로그램은 종종 명령 행을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="97c3aa97cab34b4855e7892644f3277edc0d033f" translate="yes" xml:space="preserve">
          <source>Command line options come in several flavours. Historically, they are preceded by a single dash &lt;code&gt;-&lt;/code&gt; , and consist of a single letter.</source>
          <target state="translated">커맨드 라인 옵션은 여러 가지 맛이 있습니다. 역사적으로, 앞에는 단일 대시 ( &lt;code&gt;-&lt;/code&gt; )가 있고 단일 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0257ae3370be4bc7727ce1ed69c6457101bb2926" translate="yes" xml:space="preserve">
          <source>Command line options come in several flavours. Historically, they are preceded by a single dash &lt;code&gt;-&lt;/code&gt;, and consist of a single letter.</source>
          <target state="translated">명령 줄 옵션은 여러 가지 형태로 제공됩니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 역사적으로, 그들은 하나의 대시 ( &lt;code&gt;-&lt;/code&gt; ) 가 앞에 오고 하나의 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee51dd0beb8fe1eba61df99e777a8a7fdc630b8" translate="yes" xml:space="preserve">
          <source>Command line options used by &lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt; , and thus by &lt;code&gt;WriteMakefile()&lt;/code&gt; . The string is split as the shell would, and the result is processed before any actual command line arguments are processed.</source>
          <target state="translated">&lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt; 및 &lt;code&gt;WriteMakefile()&lt;/code&gt; 의해 사용되는 명령 행 옵션 . 문자열은 쉘처럼 분할되고 결과는 실제 명령 행 인수가 처리되기 전에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1a25b72f618c0b7eea268ce6faf4f45ccebf23" translate="yes" xml:space="preserve">
          <source>Command line options used by &lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt;, and thus by &lt;code&gt;WriteMakefile()&lt;/code&gt;. The string is split as the shell would, and the result is processed before any actual command line arguments are processed.</source>
          <target state="translated">&lt;code&gt;MakeMaker-&amp;gt;new()&lt;/code&gt; 및 &lt;code&gt;WriteMakefile()&lt;/code&gt; 사용하는 명령 줄 옵션 입니다. 문자열은 쉘처럼 분할되며 실제 명령 줄 인수가 처리되기 전에 결과가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="774ba146a62c9c3ff46ff9cc5455b08807e03827" translate="yes" xml:space="preserve">
          <source>Command line switches</source>
          <target state="translated">커맨드 라인 스위치</target>
        </trans-unit>
        <trans-unit id="878211c78a67be0fed3e28b560c4cca71216618c" translate="yes" xml:space="preserve">
          <source>Command names versus file pathnames</source>
          <target state="translated">명령 이름과 파일 경로 이름</target>
        </trans-unit>
        <trans-unit id="f1032cc2ac5d43d9d5d41261914fc29d43686b3f" translate="yes" xml:space="preserve">
          <source>Command so make does not print the literal commands it's running.</source>
          <target state="translated">따라서 make 명령은 실행중인 리터럴 명령을 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c37e3809f3281c8c25395b17b26a434eb5f38e1" translate="yes" xml:space="preserve">
          <source>Command-interpreters on non-Unix systems have rather different ideas on quoting than Unix shells. You'll need to learn the special characters in your command-interpreter (&lt;code&gt;*&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are common) and how to protect whitespace and these characters to run one-liners (see &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; below).</source>
          <target state="translated">비 유닉스 시스템의 명령 해석기는 Unix 쉘과는 다른 인용 방식을 가지고 있습니다. 명령 해석기의 특수 문자 ( &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 는 일반적 임)와 공백을 보호하고 이러한 문자를 보호하여 한 줄짜리 문자를 실행하는 방법 (아래 &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; 참조)을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ea7e7557fd2f62f17cb4750e688d00bc1c4fd4c" translate="yes" xml:space="preserve">
          <source>Command-interpreters on non-Unix systems have rather different ideas on quoting than Unix shells. You'll need to learn the special characters in your command-interpreter (&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are common) and how to protect whitespace and these characters to run one-liners (see &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; below).</source>
          <target state="translated">비 Unix 시스템의 명령 인터프리터는 인용에 대한 아이디어가 Unix 쉘과 다소 다릅니다. 명령 해석기의 특수 문자 ( &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 는 일반적 임)와 공백 및 이러한 문자를 한 줄로 실행하기 위해 보호하는 방법 을 배워야합니다 (아래 &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="47a59356f4b875cbe8d0f17e3d7412ec087e8196" translate="yes" xml:space="preserve">
          <source>Command-line Wildcard Expansion</source>
          <target state="translated">명령 줄 와일드 카드 확장</target>
        </trans-unit>
        <trans-unit id="8f9ed330b4379486f6715a06438f0f05a4999609" translate="yes" xml:space="preserve">
          <source>Command-line options (switches). Switches in this variable are treated as if they were on every Perl command line. Only the &lt;b&gt;-[CDIMTUWdmtw]&lt;/b&gt; switches are allowed. When running taint checks (either because the program was running setuid or setgid, or because the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was used), this variable is ignored. If PERL5OPT begins with &lt;b&gt;-T&lt;/b&gt;, tainting will be enabled and subsequent options ignored. If PERL5OPT begins with &lt;b&gt;-t&lt;/b&gt;, tainting will be enabled, a writable dot removed from @INC, and subsequent options honored.</source>
          <target state="translated">명령 줄 옵션 (스위치). 이 변수의 스위치는 모든 Perl 명령 줄에있는 것처럼 처리됩니다. 만 &lt;b&gt;- [CDIMTUWdmtw]&lt;/b&gt; 스위치는 허용된다. 오염 검사를 실행할 때 (프로그램이 setuid 또는 setgid를 실행 중이거나 &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; 또는 &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; 스위치가 사용 되었기 때문에 )이 변수는 무시됩니다. PERL5OPT가 &lt;b&gt;-T로&lt;/b&gt; 시작하면 오염이 활성화되고 후속 옵션이 무시됩니다. PERL5OPT가 &lt;b&gt;-t로&lt;/b&gt; 시작하면 오염이 활성화되고 @INC에서 쓰기 가능한 점이 제거되며 후속 옵션이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f2498f5306d2ed5cdf02e78b8fd02f5090806ac" translate="yes" xml:space="preserve">
          <source>Command-line options (switches). Switches in this variable are treated as if they were on every Perl command line. Only the &lt;b&gt;-[CDIMUdmtwW]&lt;/b&gt; switches are allowed. When running taint checks (either because the program was running setuid or setgid, or because the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was used), this variable is ignored. If PERL5OPT begins with &lt;b&gt;-T&lt;/b&gt;, tainting will be enabled and subsequent options ignored. If PERL5OPT begins with &lt;b&gt;-t&lt;/b&gt;, tainting will be enabled, a writable dot removed from @INC, and subsequent options honored.</source>
          <target state="translated">명령 줄 옵션 (스위치). 이 변수의 스위치는 마치 모든 Perl 명령 행에있는 것처럼 취급됩니다. 만 &lt;b&gt;- [CDIMUdmtwW]&lt;/b&gt; 스위치는 허용된다. 프로그램이 setuid 또는 setgid를 실행 중이거나 &lt;b&gt;-T&lt;/b&gt; 또는 &lt;b&gt;-t&lt;/b&gt; 스위치를 사용 했기 때문에 오염 검사를 실행할 때이 변수는 무시됩니다. PERL5OPT가 &lt;b&gt;-T로&lt;/b&gt; 시작하면 오염이 활성화되고 후속 옵션은 무시됩니다. PERL5OPT가 &lt;b&gt;-t로&lt;/b&gt; 시작하면 오염이 활성화되고 쓰기 가능한 점이 @INC에서 제거되고 후속 옵션이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f3e177b917fb27cf84346755d918af92a7cfb2b" translate="yes" xml:space="preserve">
          <source>Commands for the MM's to use in Makefiles</source>
          <target state="translated">MM이 Makefile에서 사용할 명령</target>
        </trans-unit>
        <trans-unit id="2312e47cb85161c64e509845981fc1af27401c37" translate="yes" xml:space="preserve">
          <source>Commands that launch external processes are generally supported on most platforms (though many of them do not support any type of forking). The problem with using them arises from what you invoke them on. External tools are often named differently on different platforms, may not be available in the same location, might accept different arguments, can behave differently, and often present their results in a platform-dependent way. Thus, you should seldom depend on them to produce consistent results. (Then again, if you're calling</source>
          <target state="translated">외부 프로세스를 시작하는 명령은 일반적으로 대부분의 플랫폼에서 지원됩니다 (많은 유형의 포크는 지원하지 않습니다). 그것들을 사용할 때의 문제는 당신이 그것들을 불러내는 것에서 발생합니다. 외부 도구는 종종 다른 플랫폼에서 다르게 이름이 지정되고, 동일한 위치에서 사용 가능하지 않을 수 있으며, 다른 인수를 허용하고, 다르게 동작 할 수 있으며, 결과를 플랫폼에 따라 다르게 표시 할 수 있습니다. 따라서 일관된 결과를 얻기 위해 그들에 의존하지 않아야합니다. (그러면 다시 전화하면</target>
        </trans-unit>
        <trans-unit id="26a0a093068ef00836f340c97ad91760b7593441" translate="yes" xml:space="preserve">
          <source>Commands that launch external processes are generally supported on most platforms (though many of them do not support any type of forking). The problem with using them arises from what you invoke them on. External tools are often named differently on different platforms, may not be available in the same location, might accept different arguments, can behave differently, and often present their results in a platform-dependent way. Thus, you should seldom depend on them to produce consistent results. (Then again, if you're calling &lt;code&gt;netstat -a&lt;/code&gt;, you probably don't expect it to run on both Unix and CP/M.)</source>
          <target state="translated">외부 프로세스를 시작하는 명령은 일반적으로 대부분의 플랫폼에서 지원됩니다 (대부분의 경우 어떤 유형의 분기도 지원하지 않음). 그것들을 사용할 때의 문제는 그것들을 호출하는 것에서 발생합니다. 외부 도구는 종종 다른 플랫폼에서 다른 이름으로 지정되고, 동일한 위치에서 사용 가능하지 않을 수 있으며, 다른 인수를 허용하고, 다르게 작동 할 수 있으며, 종종 플랫폼에 따라 결과를 제공합니다. 따라서 일관된 결과를 생성하기 위해 거의 의존하지 않아야합니다. (그런 다음 &lt;code&gt;netstat -a&lt;/code&gt; 를 호출하는 경우 Unix 및 CP / M 모두에서 실행될 것으로 예상하지 않을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="3f11f6a37b2bb1f46ae24400fbbec0133765dee3" translate="yes" xml:space="preserve">
          <source>Comment result token.</source>
          <target state="translated">댓글 결과 토큰.</target>
        </trans-unit>
        <trans-unit id="33cd8b27d6e79d80d7f00dae59eedee6f870da21" translate="yes" xml:space="preserve">
          <source>Comment, suggestions, and patches welcome.</source>
          <target state="translated">의견, 제안 및 패치를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="7b3b1433192b715ef8754537014125cb2e060a6c" translate="yes" xml:space="preserve">
          <source>Comments Inside the Regex</source>
          <target state="translated">정규식 내부의 주석</target>
        </trans-unit>
        <trans-unit id="bc25db6a585945c33bade839a1b9b5d00339d18f" translate="yes" xml:space="preserve">
          <source>Comments Outside the Regex</source>
          <target state="translated">정규식 외부의 주석</target>
        </trans-unit>
        <trans-unit id="a6b602c915283ace9dfdb4567ddd955a24271e51" translate="yes" xml:space="preserve">
          <source>Comments begin with &quot;#&quot;, not &quot;/*&quot; or &quot;//&quot;. Perl may interpret C/C++ comments as division operators, unterminated regular expressions or the defined-or operator.</source>
          <target state="translated">주석은 &quot;/ *&quot;또는 &quot;//&quot;가 아닌 &quot;#&quot;으로 시작합니다. Perl은 C / C ++ 주석을 나누기 연산자, 종결되지 않은 정규 표현식 또는 정의 된 연산자로 해석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a11c5627026c5647a98241784b981e03eeba67" translate="yes" xml:space="preserve">
          <source>Comments can be added to XSUBs by placing a &lt;code&gt;#&lt;/code&gt; as the first non-whitespace of a line. Care should be taken to avoid making the comment look like a C preprocessor directive, lest it be interpreted as such. The simplest way to prevent this is to put whitespace in front of the &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; 을 줄의 첫 번째 비 공백으로 배치하여 주석을 XSUB에 추가 할 수 있습니다 . 주석이 C 프리 프로세서 지시문처럼 보이게하지 않도록주의해야합니다. 이를 방지하는 가장 간단한 방법은 &lt;code&gt;#&lt;/code&gt; 앞에 공백을 두는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="073a4a30713762ae3ba246ba0ef64267b5f248ab" translate="yes" xml:space="preserve">
          <source>Comments can be added to XSUBs by placing a &lt;code&gt;#&lt;/code&gt; as the first non-whitespace of a line. Care should be taken to avoid making the comment look like a C preprocessor directive, lest it be interpreted as such. The simplest way to prevent this is to put whitespace in front of the &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">줄의 공백이 아닌 첫 번째 공백으로 &lt;code&gt;#&lt;/code&gt; 을 배치하여 XSUB에 주석을 추가 할 수 있습니다 . 주석이 C 전 처리기 지시문처럼 해석되지 않도록주의해야합니다. 이를 방지하는 가장 간단한 방법은 &lt;code&gt;#&lt;/code&gt; 앞에 공백을 두는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d3573b55c22b5f8d93f519ce02a5ac87f75d58f1" translate="yes" xml:space="preserve">
          <source>Comments can be embedded in a TEMPLATE using &lt;code&gt;#&lt;/code&gt; through the end of line. White space can separate pack codes from each other, but modifiers and repeat counts must follow immediately. Breaking complex templates into individual line-by-line components, suitably annotated, can do as much to improve legibility and maintainability of pack/unpack formats as &lt;code&gt;/x&lt;/code&gt; can for complicated pattern matches.</source>
          <target state="translated">줄 끝까지 &lt;code&gt;#&lt;/code&gt; 을 사용하여 주석을 TEMPLATE에 삽입 할 수 있습니다 . 공백은 팩 코드를 서로 분리 할 수 ​​있지만 수정 자와 반복 횟수는 즉시 따라야합니다. 복잡한 템플릿을 개별 라인 단위 구성 요소로 나누고 적절하게 주석을 달면 복잡한 패턴 일치를 위해 &lt;code&gt;/x&lt;/code&gt; 가 할 수있는 것처럼 팩 / 포장 해제 형식의 가독성과 유지 관리 성을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a223d578e07988c8679c590eaf92f0323e14f" translate="yes" xml:space="preserve">
          <source>Comments on this feature are welcome; send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">이 기능에 대한 의견은 환영합니다. &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 로 이메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="95a49c3748fed6fbb50ce01121f209c8627788a1" translate="yes" xml:space="preserve">
          <source>Comments on this feature are welcome; send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt;.</source>
          <target state="translated">이 기능에 대한 의견을 환영합니다. &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; 로 이메일을 보내 십시오 .</target>
        </trans-unit>
        <trans-unit id="66bf0dd35fe077bd96ea49557abe1254cfe3d453" translate="yes" xml:space="preserve">
          <source>Comments start with a hash symbol and run to the end of the line</source>
          <target state="translated">주석은 해시 기호로 시작하여 줄 끝까지 이어집니다.</target>
        </trans-unit>
        <trans-unit id="a0809fab0f6e5f47cada9e750c63afe1aea71d14" translate="yes" xml:space="preserve">
          <source>Comments, Comments, Comments</source>
          <target state="translated">의견, 의견, 의견</target>
        </trans-unit>
        <trans-unit id="a635957687d394ed8eb32dd7af4e9fb9ea45ae9c" translate="yes" xml:space="preserve">
          <source>Commit message</source>
          <target state="translated">커밋 메시지</target>
        </trans-unit>
        <trans-unit id="d6e2ce855e82c51f1e993ec8196fbc69c3907612" translate="yes" xml:space="preserve">
          <source>Commit your change</source>
          <target state="translated">당신의 변화를 커밋하십시오</target>
        </trans-unit>
        <trans-unit id="7f708e2508e04f33e675ebab67bfbf772b80d682" translate="yes" xml:space="preserve">
          <source>Committing to blead</source>
          <target state="translated">암울하기위한 노력</target>
        </trans-unit>
        <trans-unit id="2a41fb15f0dcdac602ddfd97f9ced6c2c1be6954" translate="yes" xml:space="preserve">
          <source>Committing to maintenance versions</source>
          <target state="translated">유지 보수 버전에 전념</target>
        </trans-unit>
        <trans-unit id="bf8186840565d9d31b1a177074576c6626b1a28e" translate="yes" xml:space="preserve">
          <source>Committing your work will save the change</source>
          <target state="translated">작업을 커밋하면 변경 사항이 저장됩니다</target>
        </trans-unit>
        <trans-unit id="7de90a65241a6cdbd9ade485d777715d99285a1e" translate="yes" xml:space="preserve">
          <source>Common</source>
          <target state="translated">Common</target>
        </trans-unit>
        <trans-unit id="faaa9dff871ab55bba961bf6bd339692067a8c79" translate="yes" xml:space="preserve">
          <source>Common Methods</source>
          <target state="translated">일반적인 방법</target>
        </trans-unit>
        <trans-unit id="c4e2c656b6c5fef568eeb67c648cc5a5db418a23" translate="yes" xml:space="preserve">
          <source>Common encodings recognized by ISO, MIME, IANA, and various other standardisation organisations are recognised; for a more detailed list see &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">ISO, MIME, IANA 및 기타 다양한 표준화 조직에서 인식하는 공통 인코딩이 인식됩니다. 자세한 목록은 &lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0160caed21fbd46d3db9b1e56d4701e45dadedf1" translate="yes" xml:space="preserve">
          <source>Common encodings recognized by ISO, MIME, IANA, and various other standardisation organisations are recognised; for a more detailed list see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">ISO, MIME, IANA 및 기타 다양한 표준화 기관에서 인정하는 공통 인코딩이 인식됩니다. 자세한 목록은 &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9506633a3b0fc3eabffeede071b59b13423caf84" translate="yes" xml:space="preserve">
          <source>Common errors and problems</source>
          <target state="translated">일반적인 오류 및 문제</target>
        </trans-unit>
        <trans-unit id="018807b11c0015b193f5d2dff14e43d55830e43d" translate="yes" xml:space="preserve">
          <source>Common questions answered.</source>
          <target state="translated">일반적인 질문에 답했습니다.</target>
        </trans-unit>
        <trans-unit id="3710bbf841f5662d9076f286b3544953fd32bcdf" translate="yes" xml:space="preserve">
          <source>Common type methods</source>
          <target state="translated">일반적인 유형 방법</target>
        </trans-unit>
        <trans-unit id="e14428073bc21b2242fa58d29decc7fd620a28cc" translate="yes" xml:space="preserve">
          <source>Common values for &lt;code&gt;$ivPartitionType&lt;/code&gt; include &lt;code&gt;PARTITION_FAT_12==1&lt;/code&gt;, &lt;code&gt;PARTITION_FAT_16==4&lt;/code&gt;, &lt;code&gt;PARTITION_EXTENDED==5&lt;/code&gt;, &lt;code&gt;PARTITION_FAT32==0xB&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$ivPartitionType&lt;/code&gt; 일반적인 값 은 &lt;code&gt;PARTITION_FAT_12==1&lt;/code&gt; , &lt;code&gt;PARTITION_FAT_16==4&lt;/code&gt; , &lt;code&gt;PARTITION_EXTENDED==5&lt;/code&gt; , &lt;code&gt;PARTITION_FAT32==0xB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8a9217a7a2833f7343523310e0806117cb02577" translate="yes" xml:space="preserve">
          <source>Compare 8-bit scalar data according to the current locale</source>
          <target state="translated">현재 로케일에 따라 8 비트 스칼라 데이터 비교</target>
        </trans-unit>
        <trans-unit id="bad80fc47f96accbfa240424529d9596aa063e4c" translate="yes" xml:space="preserve">
          <source>Compare &lt;code&gt;stat&lt;/code&gt; of filehandle with &lt;code&gt;stat&lt;/code&gt; of provided filename. This can be used to check that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by stat() are compared).</source>
          <target state="translated">비교 &lt;code&gt;stat&lt;/code&gt; 와 파일 핸들을 &lt;code&gt;stat&lt;/code&gt; 제공하는 파일 이름. 이것은 파일 이름과 파일 핸들이 처음에 동일한 파일을 가리키고 파일에 대한 링크 수가 1인지 확인하는 데 사용할 수 있습니다 (stat ()에서 반환 된 모든 필드가 비교됨).</target>
        </trans-unit>
        <trans-unit id="e77e2932b456b90db814e0a4de05c60e78fca296" translate="yes" xml:space="preserve">
          <source>Compare C</source>
          <target state="translated">C 비교</target>
        </trans-unit>
        <trans-unit id="9608a3eba277fa15d97bc5d85ad1fc9cb0be2844" translate="yes" xml:space="preserve">
          <source>Compare OBJ1 and OBJ2 and return -1, 0, or 1, if OBJ1 is less than, equal to, or larger than OBJ2, respectively.</source>
          <target state="translated">OBJ1과 OBJ2를 비교하고 OBJ1이 각각 OBJ2보다 작거나 같거나 큰 경우 -1, 0 또는 1을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="359cbf85e64382337df3ea03a1b2899954429e0b" translate="yes" xml:space="preserve">
          <source>Compare OBJ1 and OBJ2 and return -1, 0, or 1, if OBJ1 is numerically less than, equal to, or larger than OBJ2, respectively.</source>
          <target state="translated">OBJ1과 OBJ2를 비교하고 OBJ1이 숫자 적으로 각각 OBJ2보다 작거나 같거나 크면 -1, 0 또는 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ea95d1f886daac818a31006775ac3fb0265210d" translate="yes" xml:space="preserve">
          <source>Compare files or filehandles</source>
          <target state="translated">파일 또는 파일 핸들 비교</target>
        </trans-unit>
        <trans-unit id="c8f1d71cf0a936dd7f0500caee4610cd7b62576a" translate="yes" xml:space="preserve">
          <source>Compare the following to the examples in &lt;code&gt;(*PRUNE)&lt;/code&gt; ; note the string is twice as long:</source>
          <target state="translated">다음을 &lt;code&gt;(*PRUNE)&lt;/code&gt; 의 예제와 비교하십시오 . 문자열의 길이가 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="750ea7b609311ac89e3490143278d77fabe5b425" translate="yes" xml:space="preserve">
          <source>Compare the following to the examples in &lt;code&gt;(*PRUNE)&lt;/code&gt;; note the string is twice as long:</source>
          <target state="translated">다음을 &lt;code&gt;(*PRUNE)&lt;/code&gt; 의 예와 비교하십시오 . 문자열의 길이는 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="69ddd15b8d251ac3138eb554c808b81fba8e3f77" translate="yes" xml:space="preserve">
          <source>Compare this code that uses an arbitrary ID...</source>
          <target state="translated">임의의 ID를 사용하는이 코드를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="d12d96005a498c4cadff6daa5f0a0e574ae4acad" translate="yes" xml:space="preserve">
          <source>Compare this to:</source>
          <target state="translated">이것을 다음과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="7f18e1a8f5bc872f75eec509b3be6157fc03fc7a" translate="yes" xml:space="preserve">
          <source>Compare this with a similar but locale-aware program:</source>
          <target state="translated">이것을 비슷하지만 로케일 인식 프로그램과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="777b2f3ef1bbfb2e49e5cc0c311dce3b665b3d34" translate="yes" xml:space="preserve">
          <source>Compare this with the characters that you see and their order if you state explicitly that the locale should be ignored:</source>
          <target state="translated">로케일을 무시해야한다고 명시 적으로 표시 한 경우이 문자와 표시 순서를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="8989d48e5efe1cfe0a91400d8b896a2d5b0f2ac0" translate="yes" xml:space="preserve">
          <source>Compares $x with $y and takes the sign into account. Returns -1, 0, 1 or undef.</source>
          <target state="translated">$ x와 $ y를 비교하고 부호를 고려합니다. -1, 0, 1 또는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7080fdc780e08e244284eff667294f04737c6d6a" translate="yes" xml:space="preserve">
          <source>Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.</source>
          <target state="translated">부호를 무시하고 $ x와 $ y를 비교합니다. -1, 0, 1 또는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb939a704fb32544966548a9a5549dad34ca8481" translate="yes" xml:space="preserve">
          <source>Compares the sequence of characters (stored as octets) in &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;blen&lt;/code&gt; with the sequence of characters (stored as UTF-8) in &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;ulen&lt;/code&gt; . Returns 0 if they are equal, -1 or -2 if the first string is less than the second string, +1 or +2 if the first string is greater than the second string.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , &lt;code&gt;blen&lt;/code&gt; 의 문자 시퀀스 (옥텟으로 저장)를 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;ulen&lt;/code&gt; 의 문자 시퀀스 (UTF-8로 저장)와 비교 합니다. 같으면 0, 첫 번째 문자열이 두 번째 문자열보다 작 ​​으면 -1 또는 -2를, 첫 번째 문자열이 두 번째 문자열보다 큰 경우 +1 또는 +2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a34b5d5cad6074d5123e9c4323544249b1dbdf1" translate="yes" xml:space="preserve">
          <source>Compares the sequence of characters (stored as octets) in &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;blen&lt;/code&gt; with the sequence of characters (stored as UTF-8) in &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;ulen&lt;/code&gt;. Returns 0 if they are equal, -1 or -2 if the first string is less than the second string, +1 or +2 if the first string is greater than the second string.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , &lt;code&gt;blen&lt;/code&gt; 의 문자 시퀀스 (옥텟으로 저장 됨)를 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;ulen&lt;/code&gt; 의 문자 시퀀스 (UTF-8로 저장 됨)와 비교 합니다. 같으면 0을, 첫 번째 문자열이 두 번째 문자열보다 작 ​​으면 -1 또는 -2를, 첫 번째 문자열이 두 번째 문자열보다 크면 +1 또는 +2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="20da491304f6c81eaa643ddf1af11a10dab08b5e" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and 'use bytes' aware and will coerce its args to strings if necessary. If the flags contain SV_GMAGIC, it handles get magic. See also &lt;code&gt;sv_cmp_flags&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 로케일 인식 방식으로 비교합니다. UTF-8이며 '바이트 사용'을 인식하고 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 SV_GMAGIC이 포함되어 있으면 마술을 처리합니다. &lt;code&gt;sv_cmp_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14038da5801f25b5039c66301e98f0e246769198" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and 'use bytes' aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;sv_cmp&lt;/code&gt; .</source>
          <target state="translated">로케일 인식 방식으로 두 SV의 문자열을 비교합니다. UTF-8 및 '바이트 사용'을 인식하고, 핸들은 마술을 얻고, 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;sv_cmp&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="934103d51d8129add1e69c517574a3e65da500a6" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and &lt;code&gt;'use bytes'&lt;/code&gt; aware and will coerce its args to strings if necessary. If the flags contain &lt;code&gt;SV_GMAGIC&lt;/code&gt;, it handles get magic. See also &lt;code&gt;&lt;a href=&quot;#sv_cmp_flags&quot;&gt;&quot;sv_cmp_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로케일 인식 방식으로 두 SV의 문자열을 비교합니다. UTF-8이고 &lt;code&gt;'use bytes'&lt;/code&gt; 인식하며 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 이 포함되어 있으면 get magic을 처리합니다. &lt;code&gt;&lt;a href=&quot;#sv_cmp_flags&quot;&gt;&quot;sv_cmp_flags&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d140d9a3becc8051c34102ae3cf6e3675ca0845e" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs in a locale-aware manner. Is UTF-8 and &lt;code&gt;'use bytes'&lt;/code&gt; aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;&lt;a href=&quot;#sv_cmp&quot;&gt;&quot;sv_cmp&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로케일 인식 방식으로 두 SV의 문자열을 비교합니다. UTF-8이고 &lt;code&gt;'use bytes'&lt;/code&gt; 인식하고 핸들이 마법을 얻고 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;&lt;a href=&quot;#sv_cmp&quot;&gt;&quot;sv_cmp&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="810a90ac09960b8d41b487c729062ca1467528ef" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt; . Is UTF-8 and 'use bytes' aware and will coerce its args to strings if necessary. If the flags include SV_GMAGIC, it handles get magic. See also &lt;code&gt;sv_cmp_locale_flags&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 다음의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 반환 합니다. &lt;code&gt;sv2&lt;/code&gt; 리턴 합니다. UTF-8이며 '바이트 사용'을 인식하고 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 SV_GMAGIC이 포함되면 마술을 처리합니다. &lt;code&gt;sv_cmp_locale_flags&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41ea1ccdf864f6da3ab35b8196aaf20a51353014" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt; . Is UTF-8 and 'use bytes' aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;sv_cmp_locale&lt;/code&gt; .</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 &lt;code&gt;sv2&lt;/code&gt; 의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 리턴합니다. 합니다. UTF-8 및 '바이트 사용'을 인식하고, 핸들은 마술을 얻고, 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;sv_cmp_locale&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efaf59d1f742672d16d54f5f82c1ae6ba772f3f9" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt;. Is UTF-8 and &lt;code&gt;'use bytes'&lt;/code&gt; aware and will coerce its args to strings if necessary. If the flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, it handles get magic. See also &lt;code&gt;&lt;a href=&quot;#sv_cmp_locale_flags&quot;&gt;&quot;sv_cmp_locale_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 &lt;code&gt;sv2&lt;/code&gt; 의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 반환합니다 . UTF-8이고 &lt;code&gt;'use bytes'&lt;/code&gt; 인식하며 필요한 경우 인수를 문자열로 강제 변환합니다. 플래그에 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 비트가 설정되어 있으면 get magic을 처리합니다. &lt;code&gt;&lt;a href=&quot;#sv_cmp_locale_flags&quot;&gt;&quot;sv_cmp_locale_flags&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8d1c8aa85f95b7d8db6a9804343a5cb61d0da00" translate="yes" xml:space="preserve">
          <source>Compares the strings in two SVs. Returns -1, 0, or 1 indicating whether the string in &lt;code&gt;sv1&lt;/code&gt; is less than, equal to, or greater than the string in &lt;code&gt;sv2&lt;/code&gt;. Is UTF-8 and &lt;code&gt;'use bytes'&lt;/code&gt; aware, handles get magic, and will coerce its args to strings if necessary. See also &lt;code&gt;&lt;a href=&quot;#sv_cmp_locale&quot;&gt;&quot;sv_cmp_locale&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">두 SV의 문자열을 비교합니다. &lt;code&gt;sv1&lt;/code&gt; 의 문자열이 &lt;code&gt;sv2&lt;/code&gt; 의 문자열보다 작거나 같거나 큰지 여부를 나타내는 -1, 0 또는 1을 반환합니다 . UTF-8이고 &lt;code&gt;'use bytes'&lt;/code&gt; 인식하고 핸들이 마법을 얻고 필요한 경우 인수를 문자열로 강제 변환합니다. &lt;code&gt;&lt;a href=&quot;#sv_cmp_locale&quot;&gt;&quot;sv_cmp_locale&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2073b0b6864634229c2ef5bbe3cb503fd3995e43" translate="yes" xml:space="preserve">
          <source>Comparing Version Numbers</source>
          <target state="translated">버전 번호 비교</target>
        </trans-unit>
        <trans-unit id="2b4ac967a48ac38926d5bd3b00ae02344f0ba5c7" translate="yes" xml:space="preserve">
          <source>Comparing and sorting by locale is usually slower than the default sorting; slow-downs of two to four times have been observed. It will also consume more memory: once a Perl scalar variable has participated in any string comparison or sorting operation obeying the locale collation rules, it will take 3-15 times more memory than before. (The exact multiplier depends on the string's contents, the operating system and the locale.) These downsides are dictated more by the operating system's implementation of the locale system than by Perl.</source>
          <target state="translated">로케일별로 비교하고 정렬하는 것은 일반적으로 기본 정렬보다 느립니다. 2 ~ 4 배의 감속이 관찰되었습니다. 또한 더 많은 메모리를 소비합니다. Perl 스칼라 변수가 로케일 데이터 정렬 규칙을 따르는 문자열 비교 또는 정렬 작업에 참여하면 이전보다 3-15 배 더 많은 메모리가 필요합니다. (정확한 승수는 문자열의 내용, 운영 체제 및 로케일에 따라 다릅니다.) 이러한 단점은 Perl이 아닌 운영 체제의 로케일 시스템 구현에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0a71bcc03489928ee6825a22ad30e52059487a" translate="yes" xml:space="preserve">
          <source>Comparing eval'd strings with code references will give you inaccurate results: a code reference will show a slightly slower execution time than the equivalent eval'd string.</source>
          <target state="translated">eval의 문자열을 코드 참조와 비교하면 결과가 부정확합니다. 코드 참조는 동일한 eval의 문자열보다 실행 시간이 약간 느립니다.</target>
        </trans-unit>
        <trans-unit id="f5450ab03d5a67e358f58108a5ac1ca0bb60017f" translate="yes" xml:space="preserve">
          <source>Comparing numbers as strings</source>
          <target state="translated">숫자를 문자열로 비교</target>
        </trans-unit>
        <trans-unit id="07ac02349f220b342a1d6f35982d496f173f647a" translate="yes" xml:space="preserve">
          <source>Comparing or matching a string case-insensitively. In Perl, it is implemented with the &lt;code&gt;/i&lt;/code&gt; pattern modifier, the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function, and the &lt;code&gt;\F&lt;/code&gt; double-quote translation escape.</source>
          <target state="translated">대소 문자를 구분하지 않고 문자열 비교 또는 일치 Perl에서는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정 자, &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 함수 및 &lt;code&gt;\F&lt;/code&gt; 큰 따옴표 변환 이스케이프로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="03df65b79f360271dddd34aad73a2aea91a2e7a2" translate="yes" xml:space="preserve">
          <source>Comparing or matching a string case-insensitively. In Perl, it is implemented with the &lt;code&gt;/i&lt;/code&gt; pattern modifier, the &lt;code&gt;fc&lt;/code&gt; function, and the &lt;code&gt;\F&lt;/code&gt; double-quote translation escape.</source>
          <target state="translated">대소 문자를 구분하지 않고 문자열을 비교하거나 일치시킵니다. Perl에서는 &lt;code&gt;/i&lt;/code&gt; 패턴 수정 자, &lt;code&gt;fc&lt;/code&gt; 함수 및 &lt;code&gt;\F&lt;/code&gt; 큰 따옴표 변환 이스케이프로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f9a7f59a9363348686bb061b55f64413e924ab6c" translate="yes" xml:space="preserve">
          <source>Comparison methods</source>
          <target state="translated">비교 방법</target>
        </trans-unit>
        <trans-unit id="6c48f0950de03de96f47ed6f4e87e0f1b8f14ee4" translate="yes" xml:space="preserve">
          <source>Comparison of &lt;code&gt;\N{...}&lt;/code&gt; and &lt;code&gt;\p{name=...}&lt;/code&gt;</source>
          <target state="translated">비교 &lt;code&gt;\N{...}&lt;/code&gt; 와 &lt;code&gt;\p{name=...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66df9ce741070999411c890487bc1aa4586a139a" translate="yes" xml:space="preserve">
          <source>Comparison of \N{...} and \p{name=...}</source>
          <target state="translated">\ N {...}과 \ p {name = ...}의 비교</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="fa5af749029a988d4116f2f7f6796db052a52edb" translate="yes" xml:space="preserve">
          <source>Comparison operators &lt;code&gt;bcmp()&lt;/code&gt; and &lt;code&gt;bacmp()&lt;/code&gt;) return -1, 0, 1, or undef.</source>
          <target state="translated">비교 연산자 &lt;code&gt;bcmp()&lt;/code&gt; 및 &lt;code&gt;bacmp()&lt;/code&gt; )는 -1, 0, 1 또는 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80c2dde455c2c05f663d3e4f08b51ffa85278453" translate="yes" xml:space="preserve">
          <source>Compatibility functions:</source>
          <target state="translated">호환성 기능 :</target>
        </trans-unit>
        <trans-unit id="5b943666a01e98d02ba66c24633566eaaa275c3f" translate="yes" xml:space="preserve">
          <source>Compatibility with Unix compress/uncompress.</source>
          <target state="translated">유닉스 압축 / 압축 해제와의 호환성.</target>
        </trans-unit>
        <trans-unit id="aad755de429541e8ec1db943cf4102247f2bb5d3" translate="yes" xml:space="preserve">
          <source>Compilation</source>
          <target state="translated">Compilation</target>
        </trans-unit>
        <trans-unit id="61222b08840c5d756903ba61f2c94b08f72f00f1" translate="yes" xml:space="preserve">
          <source>Compilation errors will tell you the line number of the error, with an indication of the next token or token type that was to be examined. (In a script passed to Perl via &lt;b&gt;-e&lt;/b&gt; switches, each &lt;b&gt;-e&lt;/b&gt; is counted as one line.)</source>
          <target state="translated">컴파일 오류는 검사 할 다음 토큰 또는 토큰 유형을 표시하여 오류의 줄 번호를 알려줍니다. ( &lt;b&gt;-e&lt;/b&gt; 스위치 를 통해 Perl에 전달 된 스크립트 에서 각 &lt;b&gt;-e&lt;/b&gt; 는 한 줄로 계산됩니다.)</target>
        </trans-unit>
        <trans-unit id="2ec881d923168aac996989549823568de9777478" translate="yes" xml:space="preserve">
          <source>Compilation failed in require</source>
          <target state="translated">require에서 컴파일에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="acc9cabc1ceec333d13d3b9abb6ebf9a6c73a5f8" translate="yes" xml:space="preserve">
          <source>Compilation problems</source>
          <target state="translated">컴파일 문제</target>
        </trans-unit>
        <trans-unit id="e55924dc0dada3b1eb85a06e699cc43d910428cf" translate="yes" xml:space="preserve">
          <source>Compilation starts with &lt;code&gt;pregcomp()&lt;/code&gt; , which is mostly an initialisation wrapper which farms work out to two other routines for the heavy lifting: the first is &lt;code&gt;reg()&lt;/code&gt; , which is the start point for parsing; the second, &lt;code&gt;study_chunk()&lt;/code&gt; , is responsible for optimisation.</source>
          <target state="translated">컴파일은 &lt;code&gt;pregcomp()&lt;/code&gt; 시작합니다. pregcomp () 는 대부분 농장이 무거운 리프팅을 위해 두 가지 다른 루틴으로 작동하는 초기화 래퍼입니다. 첫 번째는 구문 분석의 시작점 인 &lt;code&gt;reg()&lt;/code&gt; . 두 번째, &lt;code&gt;study_chunk()&lt;/code&gt; 는 최적화를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="cb165269b6704f576e16ac1db5785d86f916c77b" translate="yes" xml:space="preserve">
          <source>Compilation starts with &lt;code&gt;pregcomp()&lt;/code&gt;, which is mostly an initialisation wrapper which farms work out to two other routines for the heavy lifting: the first is &lt;code&gt;reg()&lt;/code&gt;, which is the start point for parsing; the second, &lt;code&gt;study_chunk()&lt;/code&gt;, is responsible for optimisation.</source>
          <target state="translated">컴파일은 &lt;code&gt;pregcomp()&lt;/code&gt; 시작 하는데, 이는 대부분 농장이 무거운 작업을 위해 두 개의 다른 루틴으로 작업하는 초기화 래퍼입니다. 첫 번째는 구문 분석의 시작점 인 &lt;code&gt;reg()&lt;/code&gt; . 두 번째, &lt;code&gt;study_chunk()&lt;/code&gt; 는 최적화를 담당합니다.</target>
        </trans-unit>
        <trans-unit id="44ff6f247296e1f189e3389d776ef21cc85aecb1" translate="yes" xml:space="preserve">
          <source>Compile and execute code in restricted compartments</source>
          <target state="translated">제한된 구획에서 코드 컴파일 및 실행</target>
        </trans-unit>
        <trans-unit id="7d8b71307540ad88b5ce354792888a1fa8ac7b97" translate="yes" xml:space="preserve">
          <source>Compile and link C code for Perl modules</source>
          <target state="translated">Perl 모듈을위한 C 코드 컴파일 및 링크</target>
        </trans-unit>
        <trans-unit id="b5228203f0e6f671c5f4f6a9e10132ab1a69d71c" translate="yes" xml:space="preserve">
          <source>Compile and run:</source>
          <target state="translated">컴파일하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="527a73f377cb4327fd734d48795ab96620ea39d0" translate="yes" xml:space="preserve">
          <source>Compile as usual:</source>
          <target state="translated">평소와 같이 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="cdeeb661a0937ab7ad6e505a38d072a24f8b1609" translate="yes" xml:space="preserve">
          <source>Compile pass 1: check routines</source>
          <target state="translated">컴파일 패스 1 : 루틴 점검</target>
        </trans-unit>
        <trans-unit id="ad1d375b3a209f1d8455aec99a7200242837c043" translate="yes" xml:space="preserve">
          <source>Compile pass 1a: constant folding</source>
          <target state="translated">패스 1a 컴파일 : 일정한 폴딩</target>
        </trans-unit>
        <trans-unit id="7161db3a41fd5c2db89e47b0432b3cd9aaab4ad8" translate="yes" xml:space="preserve">
          <source>Compile pass 2: context propagation</source>
          <target state="translated">컴파일 패스 2 : 컨텍스트 전파</target>
        </trans-unit>
        <trans-unit id="87a46269fcd4885277b1fc9babaffbe09e6ff612" translate="yes" xml:space="preserve">
          <source>Compile pass 3: peephole optimization</source>
          <target state="translated">컴파일 패스 3 : 구멍 최적화</target>
        </trans-unit>
        <trans-unit id="8ca3fba27b3ae96fd6b344a588412c93d138dee1" translate="yes" xml:space="preserve">
          <source>Compile perl and extensions sources with AddressSanitizer.</source>
          <target state="translated">AddressSanitizer를 사용하여 perl 및 확장 소스를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ccda3f6fab0f60ac068c4f3c452a198cb8be6aeb" translate="yes" xml:space="preserve">
          <source>Compile related options</source>
          <target state="translated">관련 옵션 컴파일</target>
        </trans-unit>
        <trans-unit id="2a7eb3fb26758fe496c8ef17d7a22b9b540357a7" translate="yes" xml:space="preserve">
          <source>Compile the pattern stored in &lt;code&gt;pattern&lt;/code&gt; using the given &lt;code&gt;flags&lt;/code&gt; and return a pointer to a prepared &lt;code&gt;REGEXP&lt;/code&gt; structure that can perform the match. See &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;&quot;The REGEXP structure&quot;&lt;/a&gt; below for an explanation of the individual fields in the REGEXP struct.</source>
          <target state="translated">저장된 패턴 컴파일 &lt;code&gt;pattern&lt;/code&gt; 주어진 사용 &lt;code&gt;flags&lt;/code&gt; 및 제조에 대한 포인터를 리턴 &lt;code&gt;REGEXP&lt;/code&gt; 의 경기를 수행 할 수있는 구조. &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;REGEXP 구조체&lt;/a&gt; 의 개별 필드에 대한 설명은 아래 &quot;REGEXP 구조체&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9f217dff0c1cb84ca4c53ebcecee0f4ba366dbb" translate="yes" xml:space="preserve">
          <source>Compile the pattern stored in &lt;code&gt;pattern&lt;/code&gt; using the given &lt;code&gt;flags&lt;/code&gt; and return a pointer to a prepared &lt;code&gt;REGEXP&lt;/code&gt; structure that can perform the match. See &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;The REGEXP structure&lt;/a&gt; below for an explanation of the individual fields in the REGEXP struct.</source>
          <target state="translated">저장된 패턴 컴파일 &lt;code&gt;pattern&lt;/code&gt; 주어진 사용 &lt;code&gt;flags&lt;/code&gt; 및 제조에 대한 포인터를 리턴 &lt;code&gt;REGEXP&lt;/code&gt; 의 경기를 수행 할 수있는 구조. &lt;a href=&quot;#The-REGEXP-structure&quot;&gt;REGEXP 구조를&lt;/a&gt; 참조하십시오 의 개별 필드에 대한 설명은 아래 .</target>
        </trans-unit>
        <trans-unit id="52c41fd78e57b0ea9c7edd279f09324e8febcf36" translate="yes" xml:space="preserve">
          <source>Compile this wrapper into a binary executable and then make</source>
          <target state="translated">이 래퍼를 이진 실행 파일로 컴파일 한 다음</target>
        </trans-unit>
        <trans-unit id="5e2892ae20c461e25a70a7b9ce2cc0ca3e806286" translate="yes" xml:space="preserve">
          <source>Compile-time Output</source>
          <target state="translated">컴파일 타임 출력</target>
        </trans-unit>
        <trans-unit id="316b6940ee7ff98d0c91d6eed52347ec98e1cebd" translate="yes" xml:space="preserve">
          <source>Compile-time class fields</source>
          <target state="translated">컴파일 타임 클래스 필드</target>
        </trans-unit>
        <trans-unit id="b224a19e379a66e5216e1e3a4c23fb529c4ffd00" translate="yes" xml:space="preserve">
          <source>Compile-time options</source>
          <target state="translated">컴파일 타임 옵션</target>
        </trans-unit>
        <trans-unit id="f6133097eb347671ef54899d886f2ecc59f839b5" translate="yes" xml:space="preserve">
          <source>Compile-time scope hooks</source>
          <target state="translated">컴파일 시간 범위 후크</target>
        </trans-unit>
        <trans-unit id="9a1874d143fe11d6c914d3925623b8d4023c98fe" translate="yes" xml:space="preserve">
          <source>Compiled Encodings</source>
          <target state="translated">컴파일 된 인코딩</target>
        </trans-unit>
        <trans-unit id="1d91d32578293cf924d4df99dc6ed9c758663fe8" translate="yes" xml:space="preserve">
          <source>Compiled Module Source</source>
          <target state="translated">컴파일 된 모듈 소스</target>
        </trans-unit>
        <trans-unit id="d31b9f29bc6f6638bce466630ba2dd4961762067" translate="yes" xml:space="preserve">
          <source>Compiled Perl Source</source>
          <target state="translated">컴파일 된 Perl 소스</target>
        </trans-unit>
        <trans-unit id="1d37a3ea5df0706c7c9b42fdc4c2ef0fe0a0aa99" translate="yes" xml:space="preserve">
          <source>Compiled code</source>
          <target state="translated">컴파일 된 코드</target>
        </trans-unit>
        <trans-unit id="5c415c80469833c9cf270c47e731b8c7453f9dbd" translate="yes" xml:space="preserve">
          <source>Compiled program. Inlined into the structure so the entire struct can be treated as a single blob.</source>
          <target state="translated">컴파일 된 프로그램. 구조에 인라인되어 전체 구조체를 단일 얼룩으로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="208f16ae59394d8539a13277bb3ef361462a3b2b" translate="yes" xml:space="preserve">
          <source>Compiler and Related Tools on Solaris.</source>
          <target state="translated">Solaris의 컴파일러 및 관련 도구</target>
        </trans-unit>
        <trans-unit id="86fcda7fac2013d8c38d615f1d55faaff9f76a8a" translate="yes" xml:space="preserve">
          <source>Compiler/Preprocessor defines</source>
          <target state="translated">컴파일러 / 전처리 기는 다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="34f24cbbea7db0e43a9c0993c8373a846789f46b" translate="yes" xml:space="preserve">
          <source>Compiles a C source file and produces an object file. The name of the object file is returned. The source file is specified in a &lt;code&gt;source&lt;/code&gt; parameter, which is required; the other parameters listed below are optional.</source>
          <target state="translated">C 소스 파일을 컴파일하고 오브젝트 파일을 생성합니다. 오브젝트 파일의 이름이 리턴됩니다. 소스 파일은 &lt;code&gt;source&lt;/code&gt; 매개 변수에 지정되며 필수입니다. 아래에 나열된 다른 매개 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="0cf70154490ae9489a2b78a86faf4fd482f98a7c" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5</source>
          <target state="translated">Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="e24918face3ac9c1b717001b232debfe6ee36a5c" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on AIX</source>
          <target state="translated">AIX에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="c22ae861a5bf3dbdbae654f91cbd81651f885935" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on AIX 7.1.0</source>
          <target state="translated">AIX 7.1.0에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="9c229fda73fdbf38e74af7c957910e2ab6e8ac38" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on HP-UX</source>
          <target state="translated">HP-UX에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="4367b922eaae098fdd83c24f81fe1e73e3dcc108" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on Tru64</source>
          <target state="translated">Tru64에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="0ab72b58debfaa78bed9b0dabffd26a67134a0a0" translate="yes" xml:space="preserve">
          <source>Compiling Perl 5 on older AIX versions up to 4.3.3</source>
          <target state="translated">최대 4.3.3 이전 AIX 버전에서 Perl 5 컴파일</target>
        </trans-unit>
        <trans-unit id="b9b693c192dd1710f2e9e413a10dac38987acc04" translate="yes" xml:space="preserve">
          <source>Compiling Perl for OS/400 PASE</source>
          <target state="translated">OS / 400 PASE 용 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="89c4a07bdd1b063c8640e5cb7f79fc20fab27cc4" translate="yes" xml:space="preserve">
          <source>Compiling Perl on BS2000</source>
          <target state="translated">BS2000에서 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="7f945a02f351065a45ab543615ac08775ab27ccb" translate="yes" xml:space="preserve">
          <source>Compiling Perl on Symbian</source>
          <target state="translated">Symbian에서 Perl 컴파일</target>
        </trans-unit>
        <trans-unit id="cea78e017dd3458f4890e6e74a3e6990888adbfd" translate="yes" xml:space="preserve">
          <source>Compiling and saving regular expressions</source>
          <target state="translated">정규식 컴파일 및 저장</target>
        </trans-unit>
        <trans-unit id="73da9444429f3393b9a36999cf3b31965029c0e7" translate="yes" xml:space="preserve">
          <source>Compiling with threading (-Duseithreads) completely rewrites the function prototypes of Perl. You better try your changes with that. Related to this is the difference between &quot;Perl_-less&quot; and &quot;Perl_-ly&quot; APIs, for example:</source>
          <target state="translated">스레딩 (-Duseithreads)으로 컴파일하면 Perl의 함수 프로토 타입이 완전히 다시 작성됩니다. 그것으로 변경을 시도하는 것이 좋습니다. 이와 관련하여 &quot;Perl_-less&quot;및 &quot;Perl_-ly&quot;API의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce33e80de717ad8f29fa7b0d95b6100971d4a1f5" translate="yes" xml:space="preserve">
          <source>Compiling your C program</source>
          <target state="translated">C 프로그램 컴파일</target>
        </trans-unit>
        <trans-unit id="4a85048775fa0a61ab607374e9f2ae3d47a74e50" translate="yes" xml:space="preserve">
          <source>Complete Dissociation of Child from Parent</source>
          <target state="translated">부모로부터 자녀의 완전한 분리</target>
        </trans-unit>
        <trans-unit id="eaef8961c7e04657ab293b427fa61a87badc5306" translate="yes" xml:space="preserve">
          <source>Complete an action with several signals masked, they will be unmasked at the end allowing any signals that were intercepted to get handled.</source>
          <target state="translated">여러 신호가 마스킹 된 상태로 작업을 완료하면 마지막에 마스킹이 해제되어 차단 된 모든 신호를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c18b6d49a703c470c73b112b479a086dc7896837" translate="yes" xml:space="preserve">
          <source>Complete applications rarely belong in the Perl Module Library.</source>
          <target state="translated">완전한 애플리케이션은 거의 Perl 모듈 라이브러리에 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="456bc79511dda60e68fd8647231e136ce158a9de" translate="yes" xml:space="preserve">
          <source>Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in 2001-2008.</source>
          <target state="translated">2001-2008 년 Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 에서 완전히 재 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="86149d77174666ee5946cc62f0896eb40fc6c420" translate="yes" xml:space="preserve">
          <source>Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt;, 2001-2008.</source>
          <target state="translated">Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; , 2001-2008에 의해 완전히 재 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="74c1508ef341d68c6231bb4d7d525101aab30f53" translate="yes" xml:space="preserve">
          <source>Complex data structures</source>
          <target state="translated">복잡한 데이터 구조</target>
        </trans-unit>
        <trans-unit id="ffe6248574dae7c5af853909dcd998ffa5a77c65" translate="yes" xml:space="preserve">
          <source>Complex numbers and associated mathematical functions</source>
          <target state="translated">복소수 및 관련 수학 함수</target>
        </trans-unit>
        <trans-unit id="cc43311382c470cc090f7797edbba8e531a9d677" translate="yes" xml:space="preserve">
          <source>Complex numbers are numbers that have both a real part and an imaginary part, and are usually noted:</source>
          <target state="translated">복소수는 실수 부와 허수 부를 모두 갖는 숫자이며 일반적으로 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0322a4acb08783ea83a479d120598aab8a51d728" translate="yes" xml:space="preserve">
          <source>Complex regular subexpression recursion limit (%d) exceeded</source>
          <target state="translated">복잡한 정규 하위 식 재귀 제한 (% d)을 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="48b933ad5b59e3f82ebc999f039fd64112dc79e5" translate="yes" xml:space="preserve">
          <source>Compliant parsers must not treat &quot;-&amp;gt;&quot; as special.</source>
          <target state="translated">호환 파서는 &quot;-&amp;gt;&quot;를 특별하게 취급해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e13848c14cd38c0bce075ad2fa8690d5d9a71b" translate="yes" xml:space="preserve">
          <source>Complicated stuff for Win32 that I don't understand. :(</source>
          <target state="translated">이해할 수없는 Win32의 복잡한 것들. :(</target>
        </trans-unit>
        <trans-unit id="f9088d8d7c9d5789f609c18210cfd55fd0924e55" translate="yes" xml:space="preserve">
          <source>Composing regular expressions at runtime</source>
          <target state="translated">런타임에 정규식 작성</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="63df8303c717b29c266d23df163b1b18d7225c3d" translate="yes" xml:space="preserve">
          <source>Composition Exclusion Table</source>
          <target state="translated">구성 제외 표</target>
        </trans-unit>
        <trans-unit id="fb6884eb8992b62c7c1af30d600b40339c50155a" translate="yes" xml:space="preserve">
          <source>Compound Statements</source>
          <target state="translated">복합 진술</target>
        </trans-unit>
        <trans-unit id="cb80e304e865d97a907ce554d72a0176ff3f41fb" translate="yes" xml:space="preserve">
          <source>Compound form (&lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt;) tighter rules:</source>
          <target state="translated">복합 형식 ( &lt;code&gt;\p{name=value}&lt;/code&gt; 또는 &lt;code&gt;\p{name:value}&lt;/code&gt; ) 더 엄격한 규칙 :</target>
        </trans-unit>
        <trans-unit id="485ff8d4769defdc95809b50d74f993442a7e521" translate="yes" xml:space="preserve">
          <source>Compress all the DLLs with</source>
          <target state="translated">모든 DLL을 압축</target>
        </trans-unit>
        <trans-unit id="9fd56668bd5f18daaa0b667a0debd58feedac101" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Bzip2</source>
          <target state="translated">Compress::Raw::Bzip2</target>
        </trans-unit>
        <trans-unit id="18d94e1500a428c004428df46c1953161a32df03" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library</source>
          <target state="translated">Compress :: Raw :: Bzip2-bzip2 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="45bc572c9ec4512947eadc206937635681bf6c11" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib</source>
          <target state="translated">Compress::Raw::Zlib</target>
        </trans-unit>
        <trans-unit id="c076710bf2d12402a0edf3b2175c1d82039053a0" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib - Low-Level Interface to zlib compression library</source>
          <target state="translated">Compress :: Raw :: Zlib-zlib 압축 라이브러리에 대한 저수준 인터페이스</target>
        </trans-unit>
        <trans-unit id="35464ef9d0e6b29547404c53959f74fe619d2fa0" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib::Deflate</source>
          <target state="translated">Compress::Raw::Zlib::Deflate</target>
        </trans-unit>
        <trans-unit id="9da283b891dfecdc74e74f383b66cc8440ffe8da" translate="yes" xml:space="preserve">
          <source>Compress::Raw::Zlib::Inflate</source>
          <target state="translated">Compress::Raw::Zlib::Inflate</target>
        </trans-unit>
        <trans-unit id="0a6571e5bcd046dfe8f32f7d79b4f6bae3366dd5" translate="yes" xml:space="preserve">
          <source>Compress::Zlib</source>
          <target state="translated">Compress::Zlib</target>
        </trans-unit>
        <trans-unit id="96c20806a0d6c0bf54bc6c1767bdc331836742ff" translate="yes" xml:space="preserve">
          <source>Compress::Zlib - Interface to zlib compression library</source>
          <target state="translated">Compress :: Zlib-zlib 압축 라이브러리에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="b27c649ac2489267a35287d00edb05f007c3c52e" translate="yes" xml:space="preserve">
          <source>Compress::Zlib::memGunzip</source>
          <target state="translated">Compress::Zlib::memGunzip</target>
        </trans-unit>
        <trans-unit id="6729436703929444a364247fdaaf90b9905bdce6" translate="yes" xml:space="preserve">
          <source>Compress::Zlib::memGzip</source>
          <target state="translated">Compress::Zlib::memGzip</target>
        </trans-unit>
        <trans-unit id="0b0874ef0be14c295073d65fceb5dc233104edd3" translate="yes" xml:space="preserve">
          <source>Compressed files and Net::FTP</source>
          <target state="translated">압축 파일 및 Net :: FTP</target>
        </trans-unit>
        <trans-unit id="ee774a21a0a3c5ce8303c3d53424d9997d3a1a40" translate="yes" xml:space="preserve">
          <source>Compresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the compressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축 합니다 . 성공하면 압축 된 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="246d96bda2baf4885ca8d09bd481192903f46090" translate="yes" xml:space="preserve">
          <source>Compresses &lt;code&gt;$source&lt;/code&gt;. If successful it returns the compressed data. Otherwise it returns</source>
          <target state="translated">&lt;code&gt;$source&lt;/code&gt; 압축 합니다 . 성공하면 압축 된 데이터를 반환합니다. 그렇지 않으면 반환</target>
        </trans-unit>
        <trans-unit id="f4abdd87ed061063a95a2ba22a68b1517b4fb78e" translate="yes" xml:space="preserve">
          <source>Compresses and outputs the contents of the &lt;code&gt;$data&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;$data&lt;/code&gt; 매개 변수 의 내용을 압축하고 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="bae9119119ae4847de6084005870d7cd27c57d09" translate="yes" xml:space="preserve">
          <source>Compresses and outputs the contents of the &lt;code&gt;$data&lt;/code&gt; parameter. This has the same behaviour as the &lt;code&gt;&lt;a href=&quot;../../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; built-in.</source>
          <target state="translated">&lt;code&gt;$data&lt;/code&gt; 매개 변수 의 내용을 압축하고 출력합니다 . 이것은 내장 &lt;code&gt;&lt;a href=&quot;../../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6e32123e7281a4ff44543f0de8bc796cd4d7a6e5" translate="yes" xml:space="preserve">
          <source>Compresses and outputs the contents of the &lt;code&gt;$data&lt;/code&gt; parameter. This has the same behaviour as the &lt;code&gt;print&lt;/code&gt; built-in.</source>
          <target state="translated">&lt;code&gt;$data&lt;/code&gt; 매개 변수 의 내용을 압축하고 출력합니다 . 이것은 내장 된 &lt;code&gt;print&lt;/code&gt; 와 동일한 동작을합니다 .</target>
        </trans-unit>
        <trans-unit id="0cf97ac6919789eccc31a14e118827a367bafae6" translate="yes" xml:space="preserve">
          <source>Compressing a file from the filesystem</source>
          <target state="translated">파일 시스템에서 파일 압축</target>
        </trans-unit>
        <trans-unit id="3da28f95a63d279a2a5a84f79bc9657148fad8b7" translate="yes" xml:space="preserve">
          <source>Compressing multiple files</source>
          <target state="translated">여러 파일 압축</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="61322d91de1a1c9dd976decc2eac0656945186ef" translate="yes" xml:space="preserve">
          <source>Compute $x ** $y.</source>
          <target state="translated">$ x ** $ y를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="b0e6b1f79c9f3294396b346171031d6eefb80388" translate="yes" xml:space="preserve">
          <source>Computers are good at being predictable and bad at being random (despite appearances caused by bugs in your programs :-). The</source>
          <target state="translated">컴퓨터는 예측 가능하고 무작위로 나쁘다 (프로그램의 버그로 인해 발생하지만 :-). 그만큼</target>
        </trans-unit>
        <trans-unit id="08d9ea43c28304526180b5a57915a96d4c9ac81d" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;$x&lt;/code&gt; raised to the power &lt;code&gt;$exponent&lt;/code&gt; .</source>
          <target state="translated">계산하여 &lt;code&gt;$x&lt;/code&gt; 전원에 제기 &lt;code&gt;$exponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="781db4b96adbd9cb759b1b3c68ae345444d88b62" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;$x&lt;/code&gt; raised to the power &lt;code&gt;$exponent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$exponent&lt;/code&gt; 제곱 한 &lt;code&gt;$x&lt;/code&gt; 계산 합니다 .</target>
        </trans-unit>
        <trans-unit id="ea1101021b1dd709e0d39acc05a94329e8f85034" translate="yes" xml:space="preserve">
          <source>Computes the sum of the base 10 digits and assigns the result to the invocand.</source>
          <target state="translated">밑이 10 자리 숫자의 합을 계산하고 그 결과를 invocand에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="14a8d68ecf91bf24bb4de30244ff8f32e6badb57" translate="yes" xml:space="preserve">
          <source>Computes the sum of the base 10 digits and returns it.</source>
          <target state="translated">밑이 10 자리 숫자의 합을 계산하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57ac7c8e25d01d0b70814899b6ae00d4e8d209cf" translate="yes" xml:space="preserve">
          <source>Computing MROs can be expensive. The implementation provides a cache, in which you can store a single &lt;code&gt;SV *&lt;/code&gt; , or anything that can be cast to &lt;code&gt;SV *&lt;/code&gt; , such as &lt;code&gt;AV *&lt;/code&gt; . To read your private value, use the macro &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt; , passing it the &lt;code&gt;mro_meta&lt;/code&gt; structure from the stash, and a pointer to your &lt;code&gt;mro_alg&lt;/code&gt; structure:</source>
          <target state="translated">컴퓨팅 MRO는 비쌀 수 있습니다. 이 구현은 단일 &lt;code&gt;SV *&lt;/code&gt; 또는 &lt;code&gt;AV *&lt;/code&gt; 와 같이 &lt;code&gt;SV *&lt;/code&gt; 로 캐스트 할 수있는 모든 것을 저장할 수있는 캐시를 제공합니다 . 개인 값을 읽으려면 매크로 사용 &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt; 그것에게 전달 &lt;code&gt;mro_meta&lt;/code&gt; 의 숨김에서 구조를하고 포인터 &lt;code&gt;mro_alg&lt;/code&gt; 의 구조를 :</target>
        </trans-unit>
        <trans-unit id="7571a67db3db54aeda215797811564cc2a408d51" translate="yes" xml:space="preserve">
          <source>Computing MROs can be expensive. The implementation provides a cache, in which you can store a single &lt;code&gt;SV *&lt;/code&gt;, or anything that can be cast to &lt;code&gt;SV *&lt;/code&gt;, such as &lt;code&gt;AV *&lt;/code&gt;. To read your private value, use the macro &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt;, passing it the &lt;code&gt;mro_meta&lt;/code&gt; structure from the stash, and a pointer to your &lt;code&gt;mro_alg&lt;/code&gt; structure:</source>
          <target state="translated">MRO 컴퓨팅은 비용이 많이들 수 있습니다. 구현은 단일 &lt;code&gt;SV *&lt;/code&gt; 또는 &lt;code&gt;AV *&lt;/code&gt; 와 같이 &lt;code&gt;SV *&lt;/code&gt; 로 캐스트 할 수있는 모든 항목을 저장할 수있는 캐시를 제공합니다 . 개인 값을 읽으려면 &lt;code&gt;MRO_GET_PRIVATE_DATA()&lt;/code&gt; 매크로를 사용 하여 stash 의 &lt;code&gt;mro_meta&lt;/code&gt; 구조와 &lt;code&gt;mro_alg&lt;/code&gt; 구조에 대한 포인터를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="4b08cb6deaa21e440a28ee385677339af044baf5" translate="yes" xml:space="preserve">
          <source>ConTEXT</source>
          <target state="translated">ConTEXT</target>
        </trans-unit>
        <trans-unit id="cb3a0dfbaecfd882d35c67f5f3bd704631194aab" translate="yes" xml:space="preserve">
          <source>Concatenate one or more directory names and a filename to form a complete path ending with a filename</source>
          <target state="translated">하나 이상의 디렉토리 이름과 파일 이름을 연결하여 파일 이름으로 끝나는 완전한 경로를 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="047b05311f0dc34982a56cd2fb9ad1f922dcbd7c" translate="yes" xml:space="preserve">
          <source>Concatenate one or more directory names and a filename to form a complete path ending with a filename. Resulting paths are &lt;b&gt;relative&lt;/b&gt; by default, but can be forced to be absolute (but avoid this).</source>
          <target state="translated">하나 이상의 디렉토리 이름과 파일 이름을 연결하여 파일 이름으로 끝나는 완전한 경로를 형성하십시오. 결과 경로는 기본적 &lt;b&gt;으로 상대적&lt;/b&gt; 이지만 절대 경로가 되도록 강제 할 수 있습니다 (그러나이를 피하십시오).</target>
        </trans-unit>
        <trans-unit id="f35597adc56e5ce25242327211e537bda9c2f250" translate="yes" xml:space="preserve">
          <source>Concatenate the lists of ops contained directly within two list-type ops, returning the combined list.</source>
          <target state="translated">두 개의 목록 유형 op에 직접 포함 된 op 목록을 연결하여 결합 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69b693ac60538b21401c38658f295d2b74e62e3e" translate="yes" xml:space="preserve">
          <source>Concatenate the lists of ops contained directly within two list-type ops, returning the combined list. &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; are the list-type ops to concatenate. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="translated">두 개의 목록 유형 작업 내에 직접 포함 된 작업 목록을 연결하여 결합 된 목록을 반환합니다. &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 는 연결할 목록 유형 작업입니다. &lt;code&gt;optype&lt;/code&gt; 은 목록의 의도 된 opcode를 지정합니다. &lt;code&gt;first&lt;/code&gt; 또는 &lt;code&gt;last&lt;/code&gt; 가 아직 올바른 유형의 목록이 아닌 경우 하나로 업그레이드됩니다. 어느 경우 &lt;code&gt;first&lt;/code&gt; 또는 &lt;code&gt;last&lt;/code&gt; null의 경우, 다른 하나는 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="649e67e9503162d4b5271ac24839b4dd127f4a0a" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a complete path ending with a directory. But remove the trailing slash from the resulting string, because it doesn't look good, isn't necessary and confuses OS/2. Of course, if this is the root directory, don't cut off the trailing slash :-)</source>
          <target state="translated">디렉토리로 끝나는 완전한 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 그러나 결과 문자열에서 후행 슬래시를 제거하십시오. 잘 보이지 않고 필요하지 않으며 OS / 2를 혼란스럽게하기 때문입니다. 물론 이것이 루트 디렉토리라면, 후행 슬래시를 잘라 내지 마십시오 :-)</target>
        </trans-unit>
        <trans-unit id="55de8a490d5d9aa9964bf82d52f080f49c22f141" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a complete path ending with a directory. But remove the trailing slash from the resulting string, because it doesn't look good, isn't necessary and confuses OS2. Of course, if this is the root directory, don't cut off the trailing slash :-)</source>
          <target state="translated">디렉토리로 끝나는 완전한 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 그러나 결과 문자열에서 후행 슬래시를 제거하십시오. 잘 보이지 않고 필요하지 않으며 OS2를 혼동합니다. 물론 이것이 루트 디렉토리라면, 후행 슬래시를 잘라 내지 마십시오 :-)</target>
        </trans-unit>
        <trans-unit id="7d067b3996ede67611d936f0cc0594b33d12b143" translate="yes" xml:space="preserve">
          <source>Concatenate two or more directory names to form a path separated by colons (&quot;:&quot;) ending with a directory. Resulting paths are &lt;b&gt;relative&lt;/b&gt; by default, but can be forced to be absolute (but avoid this, see below). Automatically puts a trailing &quot;:&quot; on the end of the complete path, because that's what's done in MacPerl's environment and helps to distinguish a file path from a directory path.</source>
          <target state="translated">디렉토리로 끝나는 콜론 ( &quot;:&quot;)으로 구분 된 경로를 형성하기 위해 둘 이상의 디렉토리 이름을 연결하십시오. 결과 경로는 기본적 &lt;b&gt;으로 상대적&lt;/b&gt; 이지만 절대 경로가 될 수 있습니다 (그러나이를 피하십시오 (아래 참조)). MacPerl 환경에서 수행되는 파일이므로 디렉토리 경로와 파일 경로를 구별하는 데 도움이되기 때문에 전체 경로의 끝에 자동으로 &quot;:&quot;를 붙입니다.</target>
        </trans-unit>
        <trans-unit id="1f92bbd0599928bde109c94dcff53b7718e50962" translate="yes" xml:space="preserve">
          <source>Concatenates a list of directory specifications with a filename specification to build a path.</source>
          <target state="translated">디렉토리 스펙 목록을 파일 이름 스펙과 결합하여 경로를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="443b92cba56de5e426bb70ed2661bc12a7f0aa5f" translate="yes" xml:space="preserve">
          <source>Concatenates a list of file specifications, and returns the result as a native directory specification unless the Unix filename reporting feature has been enabled. No check is made for &quot;impossible&quot; cases (e.g. elements other than the first being absolute filespecs).</source>
          <target state="translated">파일 스펙 목록을 연결하고 Unix 파일 이름보고 기능을 사용하지 않는 한 결과를 기본 디렉토리 스펙으로 리턴합니다. &quot;불가능한&quot;경우에 대해서는 점검하지 않습니다 (예 : 첫 번째 이외의 요소는 절대 파일 스펙).</target>
        </trans-unit>
        <trans-unit id="a1064ed1ab12c5551a61949efb23c2a0fe5e1b5a" translate="yes" xml:space="preserve">
          <source>Concatenates all files mentioned on command line to STDOUT.</source>
          <target state="translated">명령 행에 언급 된 모든 파일을 STDOUT에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aeaf86da2ac135282bf22834043d6e62fbe3a826" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt; -terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;sv_catpv_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 'get'마법을 처리하지만 'set'마법은 처리하지 않습니다. &lt;code&gt;sv_catpv_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14b45eaa62bb9cbc2fd55f55bbeff1b25f09af1b" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt; -terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on the modified SV if appropriate.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 종료 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_set&lt;/code&gt; 수정 SV 해당되는 경우에.</target>
        </trans-unit>
        <trans-unit id="a08169d2548452ac4b1d90f272918c606737e67d" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt;-terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_catpv_mg&quot;&gt;&quot;sv_catpv_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 로 끝나는 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태가 설정된 경우 추가되는 바이트는 유효한 UTF-8이어야합니다. 'get'마술은 처리하지만 'set'마술은 처리하지 않습니다. &lt;code&gt;&lt;a href=&quot;#sv_catpv_mg&quot;&gt;&quot;sv_catpv_mg&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3222780ee3ca4127f6c3591b30760fd31f0500a" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;NUL&lt;/code&gt;-terminated string onto the end of the string which is in the SV. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on the modified SV if appropriate.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; 로 끝나는 문자열을 SV에있는 문자열의 끝에 연결합니다 . SV에 UTF-8 상태가 설정된 경우 추가되는 바이트는 유효한 UTF-8이어야합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_set&lt;/code&gt; 수정 SV 해당되는 경우에.</target>
        </trans-unit>
        <trans-unit id="eb1ee548c525e9ae72200cea308c51a15c04e05b" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt; . Handles 'get' magic on both SVs, but no 'set' magic. See &lt;code&gt;sv_catsv_mg&lt;/code&gt; and &lt;code&gt;sv_catsv_nomg&lt;/code&gt; .</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 두 SV 모두에서 'get'매직을 처리하지만 'set'매직은 처리하지 않습니다. &lt;code&gt;sv_catsv_mg&lt;/code&gt; 및 &lt;code&gt;sv_catsv_nomg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="638b5971cabc9806aa9868b5283e2415ea8bede6" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt; . If &lt;code&gt;flags&lt;/code&gt; include &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will call &lt;code&gt;mg_get&lt;/code&gt; on both SVs if appropriate. If &lt;code&gt;flags&lt;/code&gt; include &lt;code&gt;SV_SMAGIC&lt;/code&gt; , &lt;code&gt;mg_set&lt;/code&gt; will be called on the modified SV afterward, if appropriate. &lt;code&gt;sv_catsv&lt;/code&gt; , &lt;code&gt;sv_catsv_nomg&lt;/code&gt; , and &lt;code&gt;sv_catsv_mg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 이 세트 비트, 호출 &lt;code&gt;mg_get&lt;/code&gt; 을 적절한 경우 모두의 SV에. 경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 을 , &lt;code&gt;mg_set&lt;/code&gt; 이 필요한 경우, 이후에 수정 된 SV에 호출됩니다. &lt;code&gt;sv_catsv&lt;/code&gt; , &lt;code&gt;sv_catsv_nomg&lt;/code&gt; 및 &lt;code&gt;sv_catsv_mg&lt;/code&gt; 는이 기능의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ef91750225c756ce3918a5c6b5e7a51f838cca1d" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt;. If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt;. Handles 'get' magic on both SVs, but no 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_catsv_mg&quot;&gt;&quot;sv_catsv_mg&quot;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#sv_catsv_nomg&quot;&gt;&quot;sv_catsv_nomg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 두 SV 모두에서 'get'매직을 처리하지만 'set'매직은 처리하지 않습니다. &lt;code&gt;&lt;a href=&quot;#sv_catsv_mg&quot;&gt;&quot;sv_catsv_mg&quot;&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#sv_catsv_nomg&quot;&gt;&quot;sv_catsv_nomg&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbf0df56f5ba323341f510b419f1a9cbaba32495" translate="yes" xml:space="preserve">
          <source>Concatenates the string from SV &lt;code&gt;ssv&lt;/code&gt; onto the end of the string in SV &lt;code&gt;dsv&lt;/code&gt;. If &lt;code&gt;ssv&lt;/code&gt; is null, does nothing; otherwise modifies only &lt;code&gt;dsv&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will call &lt;code&gt;mg_get&lt;/code&gt; on both SVs if appropriate. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, &lt;code&gt;mg_set&lt;/code&gt; will be called on the modified SV afterward, if appropriate. &lt;code&gt;sv_catsv&lt;/code&gt;, &lt;code&gt;sv_catsv_nomg&lt;/code&gt;, and &lt;code&gt;sv_catsv_mg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">SV &lt;code&gt;ssv&lt;/code&gt; 의 문자열을 SV &lt;code&gt;dsv&lt;/code&gt; 의 문자열 끝에 연결합니다 . 경우 &lt;code&gt;ssv&lt;/code&gt; 널 (null)이, 아무것도하지 않는다; 그렇지 않으면 &lt;code&gt;dsv&lt;/code&gt; 만 수정합니다 . 경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 의 비트 세트를 호출합니다 &lt;code&gt;mg_get&lt;/code&gt; 을 적절한 경우 모두의 SV에. 경우 &lt;code&gt;flags&lt;/code&gt; 이 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 의 비트 세트를, &lt;code&gt;mg_set&lt;/code&gt; 이 필요한 경우, 이후에 수정 된 SV에 호출됩니다. &lt;code&gt;sv_catsv&lt;/code&gt; , &lt;code&gt;sv_catsv_nomg&lt;/code&gt; 및 &lt;code&gt;sv_catsv_mg&lt;/code&gt; 는이 함수 측면에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="63e76beb52ccfcc94d31960e2d42fb47a8c8faab" translate="yes" xml:space="preserve">
          <source>Concatenates the string onto the end of the string which is in the SV. &lt;code&gt;len&lt;/code&gt; indicates number of bytes to copy. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_catpvn_mg&quot;&gt;&quot;sv_catpvn_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">문자열을 SV에있는 문자열의 끝에 연결합니다. &lt;code&gt;len&lt;/code&gt; 은 복사 할 바이트 수를 나타냅니다. SV에 UTF-8 상태가 설정된 경우 추가되는 바이트는 유효한 UTF-8이어야합니다. 'get'마술은 처리하지만 'set'마술은 처리하지 않습니다. &lt;code&gt;&lt;a href=&quot;#sv_catpvn_mg&quot;&gt;&quot;sv_catpvn_mg&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32fe76b48251f7900129b9480f9210b340fdc9af" translate="yes" xml:space="preserve">
          <source>Concatenates the string onto the end of the string which is in the SV. The &lt;code&gt;len&lt;/code&gt; indicates number of bytes to copy.</source>
          <target state="translated">문자열을 SV에있는 문자열의 끝에 연결합니다. &lt;code&gt;len&lt;/code&gt; 복사 할 바이트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9552a0de5c0babf6573b77f8cdd2583744fe375e" translate="yes" xml:space="preserve">
          <source>Concatenates the string onto the end of the string which is in the SV. The &lt;code&gt;len&lt;/code&gt; indicates number of bytes to copy. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See &lt;code&gt;sv_catpvn_mg&lt;/code&gt; .</source>
          <target state="translated">문자열을 SV에있는 문자열의 끝에 연결합니다. &lt;code&gt;len&lt;/code&gt; 복사 할 바이트 수를 나타냅니다. SV에 UTF-8 상태 세트가있는 경우 추가 된 바이트는 유효한 UTF-8이어야합니다. 'get'마법을 처리하지만 'set'마법은 처리하지 않습니다. &lt;code&gt;sv_catpvn_mg&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdcfedf7534d333df8380db86be3ac2ea169364e" translate="yes" xml:space="preserve">
          <source>Conceptually, the easiest way to count the lines in a file is to simply read them and count them:</source>
          <target state="translated">개념적으로 파일에서 행을 계산하는 가장 쉬운 방법은 단순히 행을 읽고 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="0dbde46110575d19c57e331505cceacbb06fd5c7" translate="yes" xml:space="preserve">
          <source>Conditional Operator</source>
          <target state="translated">조건부 연산자</target>
        </trans-unit>
        <trans-unit id="80a3a5f034865959dc043303f8d87089be9bec1e" translate="yes" xml:space="preserve">
          <source>Conditional and looping constructs</source>
          <target state="translated">조건부 및 반복 구성</target>
        </trans-unit>
        <trans-unit id="e284587340860a550f0b325831e42317beb72781" translate="yes" xml:space="preserve">
          <source>Conditional expression. Matches</source>
          <target state="translated">조건식. 성냥</target>
        </trans-unit>
        <trans-unit id="96632c17c857e0c02d178649142fafe7584b5abf" translate="yes" xml:space="preserve">
          <source>Conditional expression. Matches &lt;code&gt;yes-pattern&lt;/code&gt; if &lt;code&gt;condition&lt;/code&gt; yields a true value, matches &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-pattern&lt;/a&gt;&lt;/code&gt; otherwise. A missing pattern always matches.</source>
          <target state="translated">조건식. 일치의 &lt;code&gt;yes-pattern&lt;/code&gt; 경우 &lt;code&gt;condition&lt;/code&gt; true 값을 산출이 일치하지 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no-pattern&lt;/a&gt;&lt;/code&gt; 달리. 누락 된 패턴은 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="a343c81c0a2492332b5fb3f41392ce89176105c4" translate="yes" xml:space="preserve">
          <source>Conditional tests</source>
          <target state="translated">조건부 테스트</target>
        </trans-unit>
        <trans-unit id="70fb129765ae9747ca77f765dc8b67e5bb6bb01d" translate="yes" xml:space="preserve">
          <source>Conditionally does &lt;code&gt;OpMORESIB_set&lt;/code&gt; or &lt;code&gt;OpLASTSIB_set&lt;/code&gt; depending on whether &lt;code&gt;sib&lt;/code&gt; is non-null. For a higher-level interface, see &lt;code&gt;&lt;a href=&quot;#op_sibling_splice&quot;&gt;&quot;op_sibling_splice&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">조건부 않습니다 &lt;code&gt;OpMORESIB_set&lt;/code&gt; 또는 &lt;code&gt;OpLASTSIB_set&lt;/code&gt; 가 있는지 여부에 따라 &lt;code&gt;sib&lt;/code&gt; 아닌 null입니다. 더 높은 수준의 인터페이스는 &lt;code&gt;&lt;a href=&quot;#op_sibling_splice&quot;&gt;&quot;op_sibling_splice&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf037e3922672487abb4fdf8a9fb64c629078717" translate="yes" xml:space="preserve">
          <source>Conditionally does &lt;code&gt;OpMORESIB_set&lt;/code&gt; or &lt;code&gt;OpLASTSIB_set&lt;/code&gt; depending on whether sib is non-null. For a higher-level interface, see &lt;code&gt;op_sibling_splice&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;OpMORESIB_set&lt;/code&gt; 가 널이 아닌지 여부에 따라 조건부로 OpMORESIB_set 또는 &lt;code&gt;OpLASTSIB_set&lt;/code&gt; 을 수행합니다. 고급 인터페이스는 &lt;code&gt;op_sibling_splice&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8851142da56fd885ce668a165b33fee7003e858d" translate="yes" xml:space="preserve">
          <source>Config</source>
          <target state="translated">Config</target>
        </trans-unit>
        <trans-unit id="ecd4bd981dd9c138dc910d68320acc6b8da803ca" translate="yes" xml:space="preserve">
          <source>Config - access Perl configuration information</source>
          <target state="translated">구성-Perl 구성 정보에 액세스</target>
        </trans-unit>
        <trans-unit id="fbb49b6e5c194d0312a905696c20f6b5d8a43c67" translate="yes" xml:space="preserve">
          <source>Config Variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="dcd72ea8d2639213962e8d738a2e737b5698b164" translate="yes" xml:space="preserve">
          <source>Config files</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="2c6df16e95af35ad3cf55abb04956aab698aea9b" translate="yes" xml:space="preserve">
          <source>Config.pm</source>
          <target state="translated">Config.pm</target>
        </trans-unit>
        <trans-unit id="3784c094667e63aa78e7304ec87ad01e622ad79e" translate="yes" xml:space="preserve">
          <source>Config.sys</source>
          <target state="translated">Config.sys</target>
        </trans-unit>
        <trans-unit id="61386747172506a6ac768b51dbad3d57554bb149" translate="yes" xml:space="preserve">
          <source>Config::Extensions</source>
          <target state="translated">Config::Extensions</target>
        </trans-unit>
        <trans-unit id="6d02f90eafa05da7a1ea66cf96ef687719ae05a5" translate="yes" xml:space="preserve">
          <source>Config::Extensions - hash lookup of which core extensions were built.</source>
          <target state="translated">Config :: Extensions-핵심 확장이 빌드 된 해시 조회.</target>
        </trans-unit>
        <trans-unit id="619638cbc1e035ad1bee860d855259292edb0fdd" translate="yes" xml:space="preserve">
          <source>Config::Perl::V</source>
          <target state="translated">Config::Perl::V</target>
        </trans-unit>
        <trans-unit id="92588fff05a98a67a63f51eca74fdf8e4b1c4d06" translate="yes" xml:space="preserve">
          <source>Config::Perl::V - Structured data retrieval of perl -V output</source>
          <target state="translated">Config :: Perl :: V-perl -V 출력의 구조화 된 데이터 검색</target>
        </trans-unit>
        <trans-unit id="fb7f1d1b07ade815b9ca8129a9e4d8f0870938dc" translate="yes" xml:space="preserve">
          <source>Configurable Options</source>
          <target state="translated">구성 가능한 옵션</target>
        </trans-unit>
        <trans-unit id="56f4add64bfc676813ad28c07cc79f57bf4381eb" translate="yes" xml:space="preserve">
          <source>Configurable error handling can be very useful to your users. Consider offering a choice of levels for warning and debug messages, an option to send messages to a separate file, a way to specify an error-handling routine, or other such features. Be sure to default all these options to the commonest use.</source>
          <target state="translated">구성 가능한 오류 처리는 사용자에게 매우 유용 할 수 있습니다. 경고 및 디버그 메시지 레벨 선택, 메시지를 별도의 파일로 보내는 옵션, 오류 처리 루틴 지정 방법 또는 기타 기능을 고려하십시오. 이러한 모든 옵션을 가장 일반적으로 사용하도록 기본 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="81fb8746ddaba4745cb47bc6c868c238d3f12698" translate="yes" xml:space="preserve">
          <source>Configuration Variables or Methods</source>
          <target state="translated">구성 변수 또는 방법</target>
        </trans-unit>
        <trans-unit id="d2fcd0c469689696cdc57b270bd37400e3e0e6c1" translate="yes" xml:space="preserve">
          <source>Configuration errors and errors in the option definitions are signalled using die() and will terminate the calling program unless the call to Getopt::Long::GetOptions() was embedded in &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; { ...
}&lt;/code&gt; , or die() was trapped using &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; .</source>
          <target state="translated">옵션 정의의 구성 오류 및 오류는 die ()를 사용하여 신호를 보내며 Getopt :: Long :: GetOptions ()에 대한 호출이 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; { ... }&lt;/code&gt; 에 포함되거나 die ()가 트랩 되지 않은 경우 호출 프로그램을 종료합니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb1a984a9026064662243e9b83df991f3daebce" translate="yes" xml:space="preserve">
          <source>Configuration errors and errors in the option definitions are signalled using die() and will terminate the calling program unless the call to Getopt::Long::GetOptions() was embedded in &lt;code&gt;eval { ... }&lt;/code&gt;, or die() was trapped using &lt;code&gt;$SIG{__DIE__}&lt;/code&gt;.</source>
          <target state="translated">옵션 정의의 구성 오류 및 오류는 die ()를 사용하여 신호를 보내고 Getopt :: Long :: GetOptions ()에 대한 호출이 &lt;code&gt;eval { ... }&lt;/code&gt; 에 포함되었거나 die ()가 다음을 사용하여 트랩 되지 않는 한 호출 프로그램을 종료합니다. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01782ddc9fc1147edd83eb2ff115b31fada6fafa" translate="yes" xml:space="preserve">
          <source>Configuration for individual distributions (</source>
          <target state="translated">개별 배포판 구성 (</target>
        </trans-unit>
        <trans-unit id="620eedd56ce9ab6e57edf826ebebcc6cc23b9756" translate="yes" xml:space="preserve">
          <source>Configuration for individual distributions (_Distroprefs_)</source>
          <target state="translated">개별 분포 구성 (_Distroprefs_)</target>
        </trans-unit>
        <trans-unit id="7623cfaab2727d5570d1fb08630a1656736866f6" translate="yes" xml:space="preserve">
          <source>Configuration methods</source>
          <target state="translated">구성 방법</target>
        </trans-unit>
        <trans-unit id="5394ae422bdb720639203760041881561ff41485" translate="yes" xml:space="preserve">
          <source>Configuration options can be passed to the constructor:</source>
          <target state="translated">구성 옵션은 생성자에게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b23d1375544f4a68ea9228188041f47459e054" translate="yes" xml:space="preserve">
          <source>Configuration variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="792c81a4cfdcb5b45d688cb03c2fd2e816f86d44" translate="yes" xml:space="preserve">
          <source>Configure</source>
          <target state="translated">Configure</target>
        </trans-unit>
        <trans-unit id="5319105d548748be6bfc04e58d097068e24ec3c4" translate="yes" xml:space="preserve">
          <source>Configure Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl 구성</target>
        </trans-unit>
        <trans-unit id="b0c13173e3ce803d77c93abfff4ea85fc8bfcd93" translate="yes" xml:space="preserve">
          <source>Configure and beyond</source>
          <target state="translated">구성 및 그 이상</target>
        </trans-unit>
        <trans-unit id="8c3578dc7c3bfda9e6cafe0a3dcc7133abe34a4d" translate="yes" xml:space="preserve">
          <source>Configure and perl need a way to invoke a C preprocessor. I have created a simple cover for cc which does the right thing. Without this, Configure will create its own wrapper which works, but it doesn't handle some of the command line arguments that perl will throw at it.</source>
          <target state="translated">구성 및 perl은 C 프리 프로세서를 호출하는 방법이 필요합니다. 올바른 일을하는 cc에 대한 간단한 표지를 만들었습니다. 이것이 없으면 Configure는 작동하는 자체 래퍼를 만들지 만 perl이 던질 명령 줄 인수는 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42f3effdfaee1be1f099b1b5ad94e5c21896a110" translate="yes" xml:space="preserve">
          <source>Configure notes: This function is called 'Perl_signbit' instead of a plain 'signbit' because it is easy to imagine a system having a signbit() function or macro that doesn't happen to work with our particular choice of NVs. We shouldn't just re-#define signbit as Perl_signbit and expect the standard system headers to be happy. Also, this is a no-context function (no pTHX_) because Perl_signbit() is usually re-#defined in perl.h as a simple macro call to the system's signbit(). Users should just always call Perl_signbit().</source>
          <target state="translated">메모 구성 :이 함수는 일반 'signbit'대신 'Perl_signbit'이라고하며, 특정 NV 선택에서 작동하지 않는 signbit () 함수 또는 매크로가있는 시스템을 쉽게 상상할 수 있기 때문입니다. 우리는 부호 비트를 Perl_signbit로 재정의하지 말고 표준 시스템 헤더가 행복 할 것으로 기대해야합니다. 또한 Perl_signbit ()는 일반적으로 시스템의 signbit ()에 대한 간단한 매크로 호출로 perl.h에서 재정의되기 때문에 컨텍스트가없는 함수 (pTHX_ 없음)입니다. 사용자는 항상 Perl_signbit ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f6173a649f1483a99a4687a3ffadbcdca70587d" translate="yes" xml:space="preserve">
          <source>Configure-time Options for Perl on Cygwin</source>
          <target state="translated">Cygwin에서 Perl의 구성 시간 옵션</target>
        </trans-unit>
        <trans-unit id="9df8ff6ed6cb175291b798f1b94a9c669317082c" translate="yes" xml:space="preserve">
          <source>Configured this way, single-character options can be bundled but long options &lt;b&gt;must&lt;/b&gt; always start with a double dash &lt;code&gt;--&lt;/code&gt; to avoid ambiguity. For example, when &lt;code&gt;vax&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">이런 식으로 구성, 단일 문자 옵션은 번들로 제공 할 수 있지만 긴 옵션은 &lt;b&gt;해야한다&lt;/b&gt; 항상 이중 대시로 시작 &lt;code&gt;--&lt;/code&gt; 피하고 모호성에. 예를 들어, &lt;code&gt;vax&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="675fefb1bda485f74416546253e30d878e69556f" translate="yes" xml:space="preserve">
          <source>Configured this way, single-character options can be bundled but long options &lt;b&gt;must&lt;/b&gt; always start with a double dash &lt;code&gt;--&lt;/code&gt; to avoid ambiguity. For example, when &lt;code&gt;vax&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">이런 식으로 구성, 단일 문자 옵션은 번들로 제공 할 수 있지만 긴 옵션은 &lt;b&gt;해야한다&lt;/b&gt; 항상 이중 대시로 시작 &lt;code&gt;--&lt;/code&gt; 피하고 모호성에. 예를 들어 &lt;code&gt;vax&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 가 모두 유효한 옵션 인 경우</target>
        </trans-unit>
        <trans-unit id="f484916b063316ec823093c0c2c489d88de5c3b7" translate="yes" xml:space="preserve">
          <source>Configured to use SDK:Local/C/perl to start standard scripts</source>
          <target state="translated">SDK : Local / C / perl을 사용하여 표준 스크립트를 시작하도록 구성됨</target>
        </trans-unit>
        <trans-unit id="95e3547b156067af12afba08b6daf72fe4ff1b22" translate="yes" xml:space="preserve">
          <source>Configuring Getopt::Long</source>
          <target state="translated">Getopt :: Long 구성</target>
        </trans-unit>
        <trans-unit id="205f634664a81d583aebe4d32b4cfaa368eaa173" translate="yes" xml:space="preserve">
          <source>Configuring lynx or ncftp for going through a firewall</source>
          <target state="translated">방화벽을 통과하도록 lynx 또는 ncftp 구성</target>
        </trans-unit>
        <trans-unit id="65dba693e41ad24c6b3cdc1ab833ca9c2ff6ff01" translate="yes" xml:space="preserve">
          <source>Conflicting storage orders make an utter mess out of the numbers. If a little-endian host (Intel, VAX) stores 0x12345678 (305419896 in decimal), a big-endian host (Motorola, Sparc, PA) reads it as 0x78563412 (2018915346 in decimal). Alpha and MIPS can be either: Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses them in big-endian mode. To avoid this problem in network (socket) connections use the &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; formats &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;, the &quot;network&quot; orders. These are guaranteed to be portable.</source>
          <target state="translated">충돌하는 스토리지 주문은 숫자를 완전히 엉망으로 만듭니다. 리틀 엔디안 호스트 (Intel, VAX)가 0x12345678 (십진수로 305419896)을 저장하는 경우 빅 엔디안 호스트 (Motorola, Sparc, PA)는이를 0x78563412 (십진수로 2018915346)로 읽습니다. Alpha 및 MIPS는 다음 중 하나 일 수 있습니다. Digital / Compaq은 리틀 엔디안 모드에서 사용 / 사용합니다. SGI / Cray는 빅 엔디안 모드에서이를 사용합니다. 네트워크 (소켓) 연결에서이 문제를 방지하려면 &quot;network&quot;순서 인 &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; 형식 &lt;code&gt;n&lt;/code&gt; 및 &lt;code&gt;N&lt;/code&gt; 을 사용하십시오. 이것들은 이식성이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="a90ca9c9438d0e03c655e7e421109dc9a2965820" translate="yes" xml:space="preserve">
          <source>Conflicting storage orders make an utter mess out of the numbers. If a little-endian host (Intel, VAX) stores 0x12345678 (305419896 in decimal), a big-endian host (Motorola, Sparc, PA) reads it as 0x78563412 (2018915346 in decimal). Alpha and MIPS can be either: Digital/Compaq used/uses them in little-endian mode; SGI/Cray uses them in big-endian mode. To avoid this problem in network (socket) connections use the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; formats &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; , the &quot;network&quot; orders. These are guaranteed to be portable.</source>
          <target state="translated">충돌하는 스토리지 주문은 숫자를 완전히 엉망으로 만듭니다. 리틀 엔디안 호스트 (Intel, VAX)가 0x12345678 (10 진수로 305419896)을 저장하면 빅 엔디안 호스트 (Motorola, Sparc, PA)는이를 0x78563412 (10 진수로 2018915346)로 읽습니다. Alpha 및 MIPS는 다음 중 하나 일 수 있습니다. Digital / Compaq은 리틀 엔디안 모드에서 사용 / 사용합니다. SGI / Cray는 빅 엔디안 모드에서 사용합니다. 네트워크 (소켓) 연결에서이 문제를 피하려면 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 형식 &lt;code&gt;n&lt;/code&gt; 및 &lt;code&gt;N&lt;/code&gt; 을 사용하십시오 ( &quot;네트워크&quot;주문). 이들은 휴대용으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5523655003f964e64fb217f9f8e4a760dcd771" translate="yes" xml:space="preserve">
          <source>Conflicts between parameters LIB, PREFIX and the various INSTALL* arguments are resolved so that:</source>
          <target state="translated">매개 변수 LIB, PREFIX 및 다양한 INSTALL * 인수 사이의 충돌은 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="b96760a7005f693ba02409c79df554ec737c71ea" translate="yes" xml:space="preserve">
          <source>Conformance Test</source>
          <target state="translated">적합성 테스트</target>
        </trans-unit>
        <trans-unit id="d58273d316d0bc21f48ecd5b6254bb29f9f6bf8e" translate="yes" xml:space="preserve">
          <source>Confused yet? It's time for an example program to show some of the things we've covered. This program finds prime numbers using threads.</source>
          <target state="translated">아직 혼란스러워? 예제 프로그램이 우리가 다룬 것들 중 일부를 보여줄 차례입니다. 이 프로그램은 스레드를 사용하여 소수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="41fa26c2e2b9f746a0f21c234644df7ecbf838c3" translate="yes" xml:space="preserve">
          <source>Congratulations! You've written your first useful test.</source>
          <target state="translated">축하합니다! 첫 번째 유용한 테스트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="e96e2cb50db9a42b686132ae3630295f7ba8934b" translate="yes" xml:space="preserve">
          <source>Connecting to the server is only the first part of the process: once you have the connection, you have to use the server's language. Each server on the network has its own little command language that it expects as input. The string that we send to the server starting with &quot;GET&quot; is in HTTP syntax. In this case, we simply request each specified document. Yes, we really are making a new connection for each document, even though it's the same host. That's the way you always used to have to speak HTTP. Recent versions of web browsers may request that the remote server leave the connection open a little while, but the server doesn't have to honor such a request.</source>
          <target state="translated">서버 연결은 프로세스의 첫 번째 부분 일뿐입니다. 일단 연결되면 서버 언어를 사용해야합니다. 네트워크의 각 서버에는 입력으로 예상되는 자체 명령 언어가 있습니다. &quot;GET&quot;으로 시작하는 서버로 보내는 문자열은 HTTP 구문입니다. 이 경우 지정된 각 문서를 요청합니다. 예, 동일한 호스트 인 경우에도 각 문서마다 새로운 연결을 만들고 있습니다. 이것이 항상 HTTP를 사용하는 방식입니다. 최신 버전의 웹 브라우저는 원격 서버가 연결을 조금 열린 상태로 유지하도록 요청할 수 있지만 서버는 그러한 요청을 받아 들일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f1cf5c4ba391e46bf3a0b6200c51a59b4e7027a" translate="yes" xml:space="preserve">
          <source>Connection closed</source>
          <target state="translated">연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="1e64457037d72f3af7e4c98e763af1778685b4a7" translate="yes" xml:space="preserve">
          <source>Consequently, if the code in the</source>
          <target state="translated">결과적으로</target>
        </trans-unit>
        <trans-unit id="2aebd1c0023adb488842327316cfbc056a8738a1" translate="yes" xml:space="preserve">
          <source>Consider a character, say &lt;code&gt;H&lt;/code&gt; . It could appear with various marks around it, such as an acute accent, or a circumflex, or various hooks, circles, arrows,</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; 라고 말하는 캐릭터를 생각해보십시오 . 급성 악센트, 곡절 악센트 또는 다양한 고리, 원, 화살표 등 주변에 다양한 표시가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cc68a61682f6d5c33a362ac0bfb35bdc7ab8f2" translate="yes" xml:space="preserve">
          <source>Consider a character, say &lt;code&gt;H&lt;/code&gt;. It could appear with various marks around it, such as an acute accent, or a circumflex, or various hooks, circles, arrows,</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; 라고하는 캐릭터를 생각해보십시오 . 예리한 악센트, 곡절 악센트 또는 다양한 고리, 원, 화살표와 같은 다양한 표시로 주변에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87b1aebc18642da43916d9c7c0029ba1587fd12" translate="yes" xml:space="preserve">
          <source>Consider a function foo() in package pkg compiled outside a compartment but shared with it. Assume the compartment has a root package called 'Root'. If foo() contains an eval statement like eval '$foo = 1' then, normally, $pkg::foo will be set to 1. If foo() is called from the compartment (by whatever means) then instead of setting $pkg::foo, the eval will actually set $Root::pkg::foo.</source>
          <target state="translated">구획 외부에서 컴파일되었지만 공유 된 패키지 pkg의 함수 foo ()를 고려하십시오. 구획에 'Root'라는 루트 패키지가 있다고 가정하십시오. foo ()에 eval '$ foo = 1'과 같은 eval 문이 포함되어 있으면 일반적으로 $ pkg :: foo가 1로 설정됩니다. pkg :: foo, eval은 실제로 $ Root :: pkg :: foo를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f8539b3e23b8860669ba36676f28cdfed0cfdde0" translate="yes" xml:space="preserve">
          <source>Consider always blessing objects in CLASSNAMEs that are mixed case. Namespaces with all lowercase names are considered reserved for Perl pragmas. Builtin types have all uppercase names. To prevent confusion, you may wish to avoid such package names as well. It is advised to avoid the class name &lt;code&gt;0&lt;/code&gt;, because much code erroneously uses the result of &lt;a href=&quot;#ref-EXPR&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; as a truth value.</source>
          <target state="translated">대소 문자가 혼합 된 CLASSNAME의 축복 오브젝트를 항상 고려하십시오. 모든 소문자 이름을 가진 네임 스페이스는 Perl pragma 용으로 예약 된 것으로 간주됩니다. 내장 유형에는 모두 대문자 이름이 있습니다. 혼동을 방지하기 위해 이러한 패키지 이름도 피하는 것이 좋습니다. 많은 코드가 &lt;a href=&quot;#ref-EXPR&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 결과를 진리 값으로 잘못 사용하므로 클래스 이름 &lt;code&gt;0&lt;/code&gt; 을 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fa0726375d47145ef9cbf1c119c720175b5cdb39" translate="yes" xml:space="preserve">
          <source>Consider always blessing objects in CLASSNAMEs that are mixed case. Namespaces with all lowercase names are considered reserved for Perl pragmata. Builtin types have all uppercase names. To prevent confusion, you may wish to avoid such package names as well. Make sure that CLASSNAME is a true value.</source>
          <target state="translated">대소 문자가 혼합 된 CLASSNAME의 객체를 항상 축복하는 것을 고려하십시오. 모든 소문자 이름을 가진 네임 스페이스는 Perl pragmata에 예약 된 것으로 간주됩니다. 내장 유형은 모두 대문자입니다. 혼동을 피하기 위해 이러한 패키지 이름도 피할 수 있습니다. CLASSNAME이 실제 값인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="54bd3e39ecc1dc0a3103a2a4bb188aab06a6068e" translate="yes" xml:space="preserve">
          <source>Consider arguments as file names; no search in directories will be performed.</source>
          <target state="translated">파일 이름으로 인수를 고려하십시오. 디렉토리에서 검색이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d06f8c1e4b99ed7ae2765d865c655719390ed0ea" translate="yes" xml:space="preserve">
          <source>Consider arguments as file names; no search in directories will be performed. Implies &lt;b&gt;-U&lt;/b&gt; if run as the superuser.</source>
          <target state="translated">인수를 파일 이름으로 고려하십시오. 디렉토리에서 검색이 수행되지 않습니다. 수퍼 유저로 실행하는 경우 &lt;b&gt;-U를&lt;/b&gt; 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3c1ca7d0060d240eb3c548aa2b30a9853452fe17" translate="yes" xml:space="preserve">
          <source>Consider our first stab at an entry in our &quot;phrasebook of functions&quot;:</source>
          <target state="translated">&quot;함수 문구 집&quot;의 항목에서 첫 번째 찌르기를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1b1d13cd5ce92e946f7ab5b33dc6419aff0f850f" translate="yes" xml:space="preserve">
          <source>Consider that &quot;division by zero&quot; of Encode :)</source>
          <target state="translated">Encode의 &quot;0으로 나누기&quot;를 고려하십시오. :)</target>
        </trans-unit>
        <trans-unit id="d4152be6d4688827906dc3492be5cd5b2716e739" translate="yes" xml:space="preserve">
          <source>Consider that sentences in a tourist phrasebook are of two types: ones like &quot;How do I get to the marketplace?&quot; that don't have any blanks to fill in, and ones like &quot;How much do these ___ cost?&quot;, where there's one or more blanks to fill in (and these are usually linked to a list of words that you can put in that blank: &quot;fish&quot;, &quot;potatoes&quot;, &quot;tomatoes&quot;, etc.). The ones with no blanks are no problem, but the fill-in-the-blank ones may not be really straightforward. If it's a Swahili phrasebook, for example, the authors probably didn't bother to tell you the complicated ways that the verb &quot;cost&quot; changes its inflectional prefix depending on the noun you're putting in the blank. The trader in the marketplace will still understand what you're saying if you say &quot;how much do these potatoes cost?&quot; with the wrong inflectional prefix on &quot;cost&quot;. After all,</source>
          <target state="translated">관광 관용구에있는 문장은 &quot;장터에 어떻게 가야하나요?&quot;와 같은 두 가지 유형으로 분류됩니다. 채울 공란이없고 &quot;이 ___ 비용은 얼마입니까?&quot;와 같은 공란을 채울 수있는 하나 이상의 공란이 있습니다 (일반적으로 여기에 입력 할 수있는 단어 목록과 연결되어 있습니다). 공백 : &quot;생선&quot;, &quot;감자&quot;, &quot;토마토&quot;등). 공백이없는 것은 문제가되지 않지만, 공백 채우기는 실제로 간단하지 않을 수 있습니다. 예를 들어 스와힐리어 관용구라면 저자는 아마도 당신이 공란에 넣는 명사에 따라 동사 &quot;비용&quot;이 굴절 접두사를 바꾸는 복잡한 방식을 말하지 않았을 것입니다. 마켓 플레이스의 상인은 &quot;이 감자의 가격은 얼마입니까? &quot;와&quot;비용 &quot;에 잘못된 굴절 접두사가 붙습니다. 결국,</target>
        </trans-unit>
        <trans-unit id="42926455b13e587b6e93dd752aad04492e788722" translate="yes" xml:space="preserve">
          <source>Consider the Perl code below</source>
          <target state="translated">아래의 Perl 코드를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="010e07e2525e9ccf7d06cb1256121da84a80d2b8" translate="yes" xml:space="preserve">
          <source>Consider the autogenerated files as skeletons only, you may invent better interfaces than what h2xs could guess.</source>
          <target state="translated">자동 생성 된 파일을 스켈레톤으로 만 고려하면 h2x가 추측 할 수있는 것보다 더 나은 인터페이스를 발명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27ba8df8e476e0af655e3a1c2591ff192fc5dc6c" translate="yes" xml:space="preserve">
          <source>Consider the case where &quot;Class::MOP&quot; 0.94 is installed. If a distribution specified &quot;Class::MOP::Class::Immutable&quot; as a prerequisite, it could result in Class-MOP-0.36.tar.gz being installed, overwriting any files from Class-MOP-0.94.tar.gz.</source>
          <target state="translated">&quot;Class :: MOP&quot;0.94가 설치된 경우를 고려하십시오. 배포판에서 &quot;Class :: MOP :: Class :: Immutable&quot;을 전제 조건으로 지정한 경우 Class-MOP-0.36.tar.gz가 설치되어 Class-MOP-0.94.tar.gz의 모든 파일을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8650ada785e6a05ab5925372ee6ad4e84e025768" translate="yes" xml:space="preserve">
          <source>Consider the following Perl code:</source>
          <target state="translated">다음 Perl 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7f74e12aabb1877452a7d53cc071e21357b26c18" translate="yes" xml:space="preserve">
          <source>Consider the following pattern. The numbers underneath show in which group the captured content will be stored.</source>
          <target state="translated">다음 패턴을 고려하십시오. 아래의 숫자는 캡처 한 콘텐츠가 저장 될 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5599b31813d52e72ab7b0f81e5b0ee2cd936fffb" translate="yes" xml:space="preserve">
          <source>Consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">다음 시나리오를 고려하십시오. 타사 C 애플리케이션과 공유해야하는 DBM 데이터베이스가 있습니다. C 애플리케이션은 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8fd75f493422859997cd7850cec39135120cb65b" translate="yes" xml:space="preserve">
          <source>Consider the implications.</source>
          <target state="translated">시사점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="72c370504fc887121d33e7c91d4e60dee9fc8d48" translate="yes" xml:space="preserve">
          <source>Consider the module &lt;code&gt;MyMod::Abc&lt;/code&gt; below.</source>
          <target state="translated">아래 의 모듈 &lt;code&gt;MyMod::Abc&lt;/code&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="91193a63d32f0407e30025add9e80a60522f7554" translate="yes" xml:space="preserve">
          <source>Consider these functions: &lt;code&gt;getusers&lt;/code&gt; returns a list of users somehow, and then &lt;code&gt;main&lt;/code&gt; throws away the first user on the list and prints the rest:</source>
          <target state="translated">이러한 기능을 고려 &lt;code&gt;getusers&lt;/code&gt; 의 다음 반환 어떻게 든 사용자의 목록 및 &lt;code&gt;main&lt;/code&gt; 목록에 첫 번째 사용자를 멀리 던져 나머지를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="a6af64455c7f7fc0377e14c06fd26c8d88bd4457" translate="yes" xml:space="preserve">
          <source>Consider this carefully</source>
          <target state="translated">이것을 신중하게 고려하십시오</target>
        </trans-unit>
        <trans-unit id="565e25b1be863570aa48357d4e37a3cb9b1014a4" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="translated">이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bfa3c3c6eb24f57753daa498c1da469254839e82" translate="yes" xml:space="preserve">
          <source>Consider this function:</source>
          <target state="translated">이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8941a9b985d7af8702f49a4f16ae94cca0faaad4" translate="yes" xml:space="preserve">
          <source>Consider this line:</source>
          <target state="translated">이 줄을 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="e6c30ae9cfc668295698d4bf00794eb1d360161b" translate="yes" xml:space="preserve">
          <source>Consider this pattern:</source>
          <target state="translated">이 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1933a50a57bf352434dc1e181b868210ee85c8c1" translate="yes" xml:space="preserve">
          <source>Consider this rather facetious example, where we have used an XS version of the call_Subtract example above inside a destructor:</source>
          <target state="translated">소멸자 안에서 위의 call_Subtract 예제의 XS 버전을 사용한이 겉보기 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6cb9a94e2bea8da922c3c19cf684a0e47677d4e9" translate="yes" xml:space="preserve">
          <source>Consider this script, which has an error you may not notice immediately.</source>
          <target state="translated">즉시 알 수없는 오류가있는이 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="221f972e292aedaaa9907f3e013cc1a6d1499997" translate="yes" xml:space="preserve">
          <source>Consider this section as a guideline only, some other options of h2xs may better suit your needs.</source>
          <target state="translated">이 섹션을 지침으로 만 고려하십시오. 다른 h2x 옵션은 사용자의 요구에 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0db76c387536ed2afa4a9fb7010f3349b86fc7d5" translate="yes" xml:space="preserve">
          <source>Consider two possible matches, &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;A'B'&lt;/code&gt;, &lt;code&gt;&quot;A&quot;&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;&quot;S&quot;&lt;/code&gt;, &lt;code&gt;&quot;B&quot;&lt;/code&gt; and &lt;code&gt;B'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;&quot;T&quot;&lt;/code&gt;.</source>
          <target state="translated">두 개의 가능한 일치를 고려하십시오. &lt;code&gt;AB&lt;/code&gt; 및 &lt;code&gt;A'B'&lt;/code&gt; , &lt;code&gt;&quot;A&quot;&lt;/code&gt; 및 &lt;code&gt;A'&lt;/code&gt; 는 &lt;code&gt;&quot;S&quot;&lt;/code&gt; 와 일치 할 수있는 하위 문자열이고 , &lt;code&gt;&quot;B&quot;&lt;/code&gt; 및 &lt;code&gt;B'&lt;/code&gt; 는 &lt;code&gt;&quot;T&quot;&lt;/code&gt; 와 일치 할 수있는 하위 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="ef89846ebcc9e55f8e16c8d6eeaf74751bcc0834" translate="yes" xml:space="preserve">
          <source>Consider two possible matches, &lt;code&gt;AB&lt;/code&gt; and &lt;code&gt;A'B'&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;B'&lt;/code&gt; are substrings which can be matched by &lt;code&gt;T&lt;/code&gt; .</source>
          <target state="translated">두 개의 가능한 일치 고려 &lt;code&gt;AB&lt;/code&gt; 와 &lt;code&gt;A'B'&lt;/code&gt; , 및 &lt;code&gt;A'&lt;/code&gt; 를 일치 될 수있는 문자열 &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;B'&lt;/code&gt; 일치 될 수있는 문자열 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9492d2cabe7fd9e4932b42a71ed433789fc97e73" translate="yes" xml:space="preserve">
          <source>Consider using &quot;real&quot; multidimensional arrays as described in &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perllol&quot;&gt;perllol에&lt;/a&gt; 설명 된대로 &quot;실제&quot;다차원 배열 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="88bf0b769dc7bb2c0aaed54218c7a09d588e237d" translate="yes" xml:space="preserve">
          <source>Consider what happens during execution of the BEGIN block. At this point the BEGIN block has already been compiled, but the body of &lt;code&gt;foo()&lt;/code&gt; is still being compiled. The new value of &lt;code&gt;$^H&lt;/code&gt; will therefore be visible only while the body of &lt;code&gt;foo()&lt;/code&gt; is being compiled.</source>
          <target state="translated">BEGIN 블록을 실행하는 동안 발생하는 상황을 고려하십시오. 이 시점에서 BEGIN 블록은 이미 컴파일되었지만 &lt;code&gt;foo()&lt;/code&gt; 본문 은 여전히 ​​컴파일되고 있습니다. 따라서 &lt;code&gt;$^H&lt;/code&gt; 의 새 값 은 &lt;code&gt;foo()&lt;/code&gt; 의 본문 동안에 만 표시됩니다. 이 컴파일되는 .</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="83e396f6992f0832c8075c73a610b8e2aaff7469" translate="yes" xml:space="preserve">
          <source>Considerations for module design and coding:</source>
          <target state="translated">모듈 설계 및 코딩에 대한 고려 사항 :</target>
        </trans-unit>
        <trans-unit id="5413348d3aaa513d685bd38624f77e878e74a24a" translate="yes" xml:space="preserve">
          <source>Consistent naming of subroutines or methods</source>
          <target state="translated">서브 루틴 또는 메소드의 일관된 이름 지정</target>
        </trans-unit>
        <trans-unit id="2d686acf592debeada13314ea153c3c8cc7487e9" translate="yes" xml:space="preserve">
          <source>Constant Folding</source>
          <target state="translated">일정한 접는</target>
        </trans-unit>
        <trans-unit id="20e7a47ab29e19ba135c447b4536a0bd6e1d82dd" translate="yes" xml:space="preserve">
          <source>Constant Functions</source>
          <target state="translated">상수 함수</target>
        </trans-unit>
        <trans-unit id="d83ebf1e43cbbe5eb7aa831bfb0f3e3251894c92" translate="yes" xml:space="preserve">
          <source>Constant Interface</source>
          <target state="translated">일정한 인터페이스</target>
        </trans-unit>
        <trans-unit id="b022d99d99ce264edc0fc7ee31184b6d330beaf3" translate="yes" xml:space="preserve">
          <source>Constant is not %s reference</source>
          <target state="translated">상수가 % s 참조가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0888531b95ae3e45c24b3838f1962f9be3527072" translate="yes" xml:space="preserve">
          <source>Constant subroutine %s redefined</source>
          <target state="translated">상수 서브 루틴 % s 재정의</target>
        </trans-unit>
        <trans-unit id="bbdc700682d72a499a9f82274524612615f5858e" translate="yes" xml:space="preserve">
          <source>Constant subroutine %s undefined</source>
          <target state="translated">상수 서브 루틴 % s 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="11e9915e8272ad657d8ce4820500bec2014310ef" translate="yes" xml:space="preserve">
          <source>Constant subs can be created with &lt;code&gt;newCONSTSUB&lt;/code&gt; or as described in &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;Constant Functions&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">상수 &lt;code&gt;newCONSTSUB&lt;/code&gt; 는 newCONSTSUB를 사용 하거나 perlsub의 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;상수 함수&quot;에&lt;/a&gt; 설명 된대로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05b0c81a6abce35ba0658d6d8b023f51626d6394" translate="yes" xml:space="preserve">
          <source>Constant subs can be created with &lt;code&gt;newCONSTSUB&lt;/code&gt; or as described in &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">상수 서브는 &lt;code&gt;newCONSTSUB&lt;/code&gt; 를 사용 하거나 perlsub의 &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;상수 함수에&lt;/a&gt; 설명 된대로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb480e143560d3a30fb5db4a62f4117bffe9a90c" translate="yes" xml:space="preserve">
          <source>Constant(%s) unknown</source>
          <target state="translated">상수 (% s) 알 수 없음</target>
        </trans-unit>
        <trans-unit id="0a600be81ca3abc160ef46f0c702a4166cf153fc" translate="yes" xml:space="preserve">
          <source>Constant(%s): $^H{%s} is not defined</source>
          <target state="translated">상수 (% s) : $ ^ H {% s}이 (가) 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f0ead88eb3e7ffcab59fb996d2604d51892b8d3f" translate="yes" xml:space="preserve">
          <source>Constant(%s): Call to &amp;amp;{$^H{%s}} did not return a defined value</source>
          <target state="translated">상수 (% s) : &amp;amp; {$ ^ H {% s}}에 대한 호출이 정의 된 값을 반환하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d5634c45dcb585d4705b83e6c898a2dc4b95df58" translate="yes" xml:space="preserve">
          <source>Constant, returns the field &lt;code&gt;foo&lt;/code&gt;'s key into the class hashref. Subclasses will also get this function as a constant, not simply a method, that means it is copied into the subclass namespace.</source>
          <target state="translated">상수, 필드 &lt;code&gt;foo&lt;/code&gt; 의 키를 클래스 hashref에 반환합니다 . 하위 클래스는 또한이 함수를 단순한 메서드가 아닌 상수로 가져옵니다. 즉, 하위 클래스 네임 스페이스에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="9e611a824a8183e220d4a7c0d0aa3bafaf2b538a" translate="yes" xml:space="preserve">
          <source>Constants belong to the package they are defined in. To refer to a constant defined in another package, specify the full package name, as in &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt; . Constants may be exported by modules, and may also be called as either class or instance methods, that is, as &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; or as &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; where &lt;code&gt;$obj&lt;/code&gt; is an instance of &lt;code&gt;Some::Package&lt;/code&gt; . Subclasses may define their own constants to override those in their base class.</source>
          <target state="translated">상수는 정의 된 패키지에 속합니다. 다른 패키지에 정의 된 상수를 참조하려면 &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt; 와 같이 전체 패키지 이름을 지정하십시오 . 상수는 모듈에 의해 익스포트 될 수 있으며 클래스 또는 인스턴스 메소드, 즉 &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; 또는 &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; 로 호출 될 수 있습니다. 여기서 &lt;code&gt;$obj&lt;/code&gt; 는 &lt;code&gt;Some::Package&lt;/code&gt; 의 인스턴스입니다 . 서브 클래스는 자신의 상수를 정의하여 기본 클래스의 상수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef7f785aecda130542da189c67c127de3be6217" translate="yes" xml:space="preserve">
          <source>Constants belong to the package they are defined in. To refer to a constant defined in another package, specify the full package name, as in &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt;. Constants may be exported by modules, and may also be called as either class or instance methods, that is, as &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; or as &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; where &lt;code&gt;$obj&lt;/code&gt; is an instance of &lt;code&gt;Some::Package&lt;/code&gt;. Subclasses may define their own constants to override those in their base class.</source>
          <target state="translated">상수는 정의 된 패키지에 속합니다. 다른 패키지에 정의 된 상수를 참조하려면 &lt;code&gt;Some::Package::CONSTANT&lt;/code&gt; 와 같이 전체 패키지 이름을 지정하십시오 . 상수는 모듈로 내보낼 수 있으며 클래스 또는 인스턴스 메서드로 호출 될 수도 있습니다. 즉, &lt;code&gt;Some::Package-&amp;gt;CONSTANT&lt;/code&gt; 또는 &lt;code&gt;$obj-&amp;gt;CONSTANT&lt;/code&gt; 로 호출 될 수 있습니다. 여기서 &lt;code&gt;$obj&lt;/code&gt; 는 &lt;code&gt;Some::Package&lt;/code&gt; 의 인스턴스입니다 . 하위 클래스는 기본 클래스의 상수를 재정의하기 위해 자체 상수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21cfbc2db87f9182c549bff7c8f35745bf20234" translate="yes" xml:space="preserve">
          <source>Constants defined using this module cannot be interpolated into strings like variables. However, concatenation works just fine:</source>
          <target state="translated">이 모듈을 사용하여 정의 된 상수는 변수와 같은 문자열로 보간 할 수 없습니다. 그러나 연결은 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aa915cf116d077e9e13787db53e2d840e88601d0" translate="yes" xml:space="preserve">
          <source>Constants describing partition types.</source>
          <target state="translated">파티션 유형을 설명하는 상수.</target>
        </trans-unit>
        <trans-unit id="8d42ecf86f91ad96dc467934b921a072fb4829bf" translate="yes" xml:space="preserve">
          <source>Constants for GetStdHandle and SetStdHandle</source>
          <target state="translated">GetStdHandle 및 SetStdHandle에 대한 상수</target>
        </trans-unit>
        <trans-unit id="8ece936e7325f2407cd17ba720f075223bee4d90" translate="yes" xml:space="preserve">
          <source>Constants for Locale codes</source>
          <target state="translated">로캘 코드의 상수</target>
        </trans-unit>
        <trans-unit id="fdda4d48863328360387da0dd1b2f5c1a042b3c9" translate="yes" xml:space="preserve">
          <source>Constants for the &lt;code&gt;$uFlags&lt;/code&gt; argument of &lt;code&gt;DefineDosDevice&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DefineDosDevice&lt;/code&gt; 의 &lt;code&gt;$uFlags&lt;/code&gt; 인수에 대한 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="d4043dad2a054f34eb0858204273e3f193fc49ba" translate="yes" xml:space="preserve">
          <source>Constants for use in &lt;code&gt;$uFlags&lt;/code&gt; arguments to &lt;code&gt;MoveFileEx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MoveFileEx&lt;/code&gt; 에 대한 &lt;code&gt;$uFlags&lt;/code&gt; 인수 에 사용되는 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="3a4f891a762c78e8f2d0c6ad9df2bc2f09ed2f2e" translate="yes" xml:space="preserve">
          <source>Constants from lexical variables potentially modified elsewhere</source>
          <target state="translated">다른 곳에서 수정 될 수있는 어휘 변수의 상수</target>
        </trans-unit>
        <trans-unit id="a81dfcd7b9da84d74e29eab61d40b4c674bb41e9" translate="yes" xml:space="preserve">
          <source>Constants from lexical variables potentially modified elsewhere are no longer permitted</source>
          <target state="translated">다른 곳에서 수정 될 수있는 어휘 변수의 상수는 더 이상 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90018db3a64f1b35ef89d41c0084cc18166e6bd9" translate="yes" xml:space="preserve">
          <source>Constants giving the special &lt;code&gt;AF_INET6&lt;/code&gt; addresses for wildcard and local loopback.</source>
          <target state="translated">와일드 카드 및 로컬 루프백에 특별한 &lt;code&gt;AF_INET6&lt;/code&gt; 주소를 제공하는 상수 .</target>
        </trans-unit>
        <trans-unit id="3f844ade6411f17a07d09e25894b5b9acfe42b33" translate="yes" xml:space="preserve">
          <source>Constants giving the special &lt;code&gt;AF_INET&lt;/code&gt; addresses for wildcard, broadcast, local loopback, and invalid addresses.</source>
          <target state="translated">와일드 카드, 브로드 캐스트, 로컬 루프백 및 유효하지 않은 주소에 대한 특수 &lt;code&gt;AF_INET&lt;/code&gt; 주소를 제공하는 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="7f1778f60074f1115e51de3d87a3332a8d7fc830" translate="yes" xml:space="preserve">
          <source>Constants may be lists of more (or less) than one value. A constant with no values evaluates to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context. Note that constants with more than one value do</source>
          <target state="translated">상수는 하나 이상의 값 목록 일 수 있습니다. 값이없는 상수 는 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 평가됩니다 . 하나 이상의 값을 가진 상수는</target>
        </trans-unit>
        <trans-unit id="ef4d2ec3b710091bb10d21130c0be09ce42219e0" translate="yes" xml:space="preserve">
          <source>Constants may be lists of more (or less) than one value. A constant with no values evaluates to &lt;code&gt;undef&lt;/code&gt; in scalar context. Note that constants with more than one value do</source>
          <target state="translated">상수는 하나보다 많거나 적은 값의 목록 일 수 있습니다. 값이없는 상수 는 스칼라 컨텍스트에서 &lt;code&gt;undef&lt;/code&gt; 로 평가됩니다 . 둘 이상의 값을 가진 상수는</target>
        </trans-unit>
        <trans-unit id="28c83bb124b6e452aac308435bc213c308476806" translate="yes" xml:space="preserve">
          <source>Constants returned by &lt;code&gt;GetDriveType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GetDriveType&lt;/code&gt; 에서 반환하는 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="a44e6d94028c8513026c57c0b7cadff35dde3a65" translate="yes" xml:space="preserve">
          <source>Constants specifying generic access permissions that are not specific to one type of object.</source>
          <target state="translated">특정 유형의 객체에만 국한되지 않는 일반 액세스 권한을 지정하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="3f633c30ca6ad47492853b293d24f861b62cec23" translate="yes" xml:space="preserve">
          <source>Constants to be used with &lt;code&gt;SetErrorMode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SetErrorMode&lt;/code&gt; 와 함께 사용할 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="621b5a362582546e5fadc9871dca00569999fdad" translate="yes" xml:space="preserve">
          <source>Construct a Perl subroutine, also performing some surrounding jobs.</source>
          <target state="translated">Perl 서브 루틴을 구성하고 주변 작업도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="355a3d53a7e14f7a729e8f91686b85505d33df33" translate="yes" xml:space="preserve">
          <source>Construct a complete filespec.</source>
          <target state="translated">완전한 파일 스펙을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="af6070027d441a6c776ba726f41b255627016312" translate="yes" xml:space="preserve">
          <source>Construct a constant subroutine, also performing some surrounding jobs. A scalar constant-valued subroutine is eligible for inlining at compile-time, and in Perl code can be created by &lt;code&gt;sub FOO () { 123 }&lt;/code&gt;. Other kinds of constant subroutine have other treatment.</source>
          <target state="translated">상수 서브 루틴을 구성하고 주변 작업도 수행합니다. 스칼라 상수 값 서브 루틴은 컴파일 타임에 인라인에 적합하며 Perl 코드에서는 &lt;code&gt;sub FOO () { 123 }&lt;/code&gt; 으로 생성 할 수 있습니다 . 다른 종류의 상수 서브 루틴에는 다른 처리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b48ef03671bbccdc92bbafe2373d3837e7ff63c2" translate="yes" xml:space="preserve">
          <source>Construct an XS subroutine, also performing some surrounding jobs.</source>
          <target state="translated">XS 서브 루틴을 구성하고 주변 작업도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="aec9f3529c9af4370344830a20d26a1ac2ddabe7" translate="yes" xml:space="preserve">
          <source>Construct and return cache object.</source>
          <target state="translated">캐시 객체를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da33e1b7e0c4eae1911ee4a15280f0990e1a6115" translate="yes" xml:space="preserve">
          <source>Construction</source>
          <target state="translated">Construction</target>
        </trans-unit>
        <trans-unit id="0c9d593aa97f6e3f26bb7e4cf664176f5ffd4019" translate="yes" xml:space="preserve">
          <source>Construction Methods</source>
          <target state="translated">건축 방법</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="ef269264e27df02b9462bb6740ca823b7e335569" translate="yes" xml:space="preserve">
          <source>Constructor Options</source>
          <target state="translated">생성자 옵션</target>
        </trans-unit>
        <trans-unit id="94b976a5ab3f62f6c26557a2c4dbf4bbae664372" translate="yes" xml:space="preserve">
          <source>Constructor and Tailoring</source>
          <target state="translated">생성자 및 조정</target>
        </trans-unit>
        <trans-unit id="40c2e52aca6cb904e8fd931282b5e338572dab1e" translate="yes" xml:space="preserve">
          <source>Constructor arguments should be passed in &lt;code&gt;Key =&amp;gt; 'Value'&lt;/code&gt; pairs.</source>
          <target state="translated">생성자 인수는 &lt;code&gt;Key =&amp;gt; 'Value'&lt;/code&gt; 쌍 으로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1cdb266c49cfa65e08d705d5557c3f3e981f374" translate="yes" xml:space="preserve">
          <source>Constructor methods</source>
          <target state="translated">생성자 메서드</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="2b71b9b81247be950268dd6ba04bdcfd449c12d9" translate="yes" xml:space="preserve">
          <source>Constructs &amp;amp; returns a new &lt;a href=&quot;TAP::Parser::Iterator::Process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; for the source. Assumes &lt;code&gt;$source-&amp;gt;raw&lt;/code&gt; contains a reference to the perl script. &lt;code&gt;croak&lt;/code&gt;s if the file could not be found.</source>
          <target state="translated">소스에 대한 새로운 &lt;a href=&quot;TAP::Parser::Iterator::Process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt; 를 생성하고 반환합니다 . &lt;code&gt;$source-&amp;gt;raw&lt;/code&gt; 에 perl 스크립트에 대한 참조가 포함되어 있다고 가정 합니다. 파일을 찾을 수없는 경우 &lt;code&gt;croak&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="c6dc7fa5fd47c9138ae444b7aed96ae65bb68d63" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Module::Metadata&lt;/code&gt; object given a module or package name. Returns undef if the module cannot be found.</source>
          <target state="translated">구성하는 &lt;code&gt;Module::Metadata&lt;/code&gt; 오브젝트는 모듈 또는 패키지 이름을 부여. 모듈을 찾을 수없는 경우 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73b359b6f69593ce623d611bf25dbeb6f9faf846" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Module::Metadata&lt;/code&gt; object given the path to a file. Returns undef if the filename does not exist.</source>
          <target state="translated">구성하는 &lt;code&gt;Module::Metadata&lt;/code&gt; 오브젝트는 파일에 대한 경로를 제공. 파일 이름이 없으면 undef를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d746fdc33e3789e1ca29174d30fb76d7df4e6835" translate="yes" xml:space="preserve">
          <source>Constructs a state op (COP). The state op is normally a &lt;code&gt;nextstate&lt;/code&gt; op, but will be a &lt;code&gt;dbstate&lt;/code&gt; op if debugging is enabled for currently-compiled code. The state op is populated from &lt;code&gt;PL_curcop&lt;/code&gt; (or &lt;code&gt;PL_compiling&lt;/code&gt; ). If</source>
          <target state="translated">상태 연산 (COP)을 구성합니다. 상태 op는 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; op이지만 현재 컴파일 된 코드에 대해 디버깅이 활성화 된 경우 &lt;code&gt;dbstate&lt;/code&gt; op가됩니다. 상태 op는 &lt;code&gt;PL_curcop&lt;/code&gt; (또는 &lt;code&gt;PL_compiling&lt;/code&gt; ) 에서 채워집니다 . 만약</target>
        </trans-unit>
        <trans-unit id="8426fab2dac4965c145d2a1bad2d85698dd51043" translate="yes" xml:space="preserve">
          <source>Constructs a state op (COP). The state op is normally a &lt;code&gt;nextstate&lt;/code&gt; op, but will be a &lt;code&gt;dbstate&lt;/code&gt; op if debugging is enabled for currently-compiled code. The state op is populated from &lt;code&gt;PL_curcop&lt;/code&gt; (or &lt;code&gt;PL_compiling&lt;/code&gt;). If &lt;code&gt;label&lt;/code&gt; is non-null, it supplies the name of a label to attach to the state op; this function takes ownership of the memory pointed at by &lt;code&gt;label&lt;/code&gt;, and will free it. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the state op.</source>
          <target state="translated">상태 작업 (COP)을 구성합니다. 상태 작업은 일반적으로 &lt;code&gt;nextstate&lt;/code&gt; 작업 이지만 현재 컴파일 된 코드에 대해 디버깅이 활성화 된 경우 &lt;code&gt;dbstate&lt;/code&gt; 작업 이됩니다 . 상태 작업은 &lt;code&gt;PL_curcop&lt;/code&gt; (또는 &lt;code&gt;PL_compiling&lt;/code&gt; ) 에서 채워집니다 . &lt;code&gt;label&lt;/code&gt; 이 널이 아닌 경우 상태 op에 첨부 할 레이블의 이름을 제공합니다. 이 함수는 &lt;code&gt;label&lt;/code&gt; 이 가리키는 메모리의 소유권을 가져 와서 해제합니다. &lt;code&gt;flags&lt;/code&gt; 는 상태 op에 대해 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="252503586ad552246e785267ad1b402b11d9c378" translate="yes" xml:space="preserve">
          <source>Constructs and returns a &lt;code&gt;range&lt;/code&gt; op, with subordinate &lt;code&gt;flip&lt;/code&gt; and &lt;code&gt;flop&lt;/code&gt; ops.</source>
          <target state="translated">종속 &lt;code&gt;flip&lt;/code&gt; 및 &lt;code&gt;flop&lt;/code&gt; 연산을 사용 하여 &lt;code&gt;range&lt;/code&gt; 연산을 구성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e46c0788a3baacd8699fc8b0ef26a2f36cb8b10a" translate="yes" xml:space="preserve">
          <source>Constructs and returns a &lt;code&gt;range&lt;/code&gt; op, with subordinate &lt;code&gt;flip&lt;/code&gt; and &lt;code&gt;flop&lt;/code&gt; ops. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the &lt;code&gt;flip&lt;/code&gt; op and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt; for both the &lt;code&gt;flip&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt; ops, except that the bit with value 1 is automatically set. &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; supply the expressions controlling the endpoints of the range; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">하위 &lt;code&gt;flip&lt;/code&gt; 및 &lt;code&gt;flop&lt;/code&gt; 연산을 사용 하여 &lt;code&gt;range&lt;/code&gt; 연산을 구성하고 반환합니다 . &lt;code&gt;flags&lt;/code&gt; 는 값이 1 인 비트가 자동으로 설정된다는 점을 제외하고 는 &lt;code&gt;flip&lt;/code&gt; 연산에 대해 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공하고, 8 비트 위로 시프트 하면 &lt;code&gt;flip&lt;/code&gt; 및 &lt;code&gt;range&lt;/code&gt; 연산 모두에 대해 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트 를 제공합니다 . &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 은 범위의 끝점을 제어하는 ​​표현식을 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="7931ff4d1b3865a020bb44b64b70244e6b1d8e26" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name.</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a20e05d8d20ed1a0a46b13c3bf3e2f73033ad864" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name. &lt;code&gt;s&lt;/code&gt; must be a UTF-8 string. Do not use this for pad names that point to outer lexicals. See &lt;code&gt;&lt;a href=&quot;#newPADNAMEouter&quot;&gt;&quot;newPADNAMEouter&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다. &lt;code&gt;s&lt;/code&gt; UTF-8 문자열이어야합니다. 외부 어휘를 가리키는 패드 이름에는 이것을 사용하지 마십시오. &lt;code&gt;&lt;a href=&quot;#newPADNAMEouter&quot;&gt;&quot;newPADNAMEouter&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36a231f7a41c3ae5c30b12441dec62718f40f242" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name. Only use this function for names that refer to outer lexicals. (See also &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;&quot;newPADNAMEpvn&quot;&lt;/a&gt;.) &lt;code&gt;outer&lt;/code&gt; is the outer pad name that this one mirrors. The returned pad name has the &lt;code&gt;PADNAMEt_OUTER&lt;/code&gt; flag already set.</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다. 이 함수는 외부 어휘를 참조하는 이름에만 사용하십시오. ( &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;&quot;newPADNAMEpvn&quot;&lt;/a&gt; 참조 ) &lt;code&gt;outer&lt;/code&gt; 는 이것이 미러링하는 외부 패드 이름입니다. 반환 된 패드 이름에는 이미 설정된 &lt;code&gt;PADNAMEt_OUTER&lt;/code&gt; 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="957cf4dcc64056248a5fc94c4f5122d5b4253099" translate="yes" xml:space="preserve">
          <source>Constructs and returns a new pad name. Only use this function for names that refer to outer lexicals. (See also &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;newPADNAMEpvn&lt;/a&gt;.)</source>
          <target state="translated">새 패드 이름을 구성하고 반환합니다. 외부 어휘를 참조하는 이름에만이 기능을 사용하십시오. ( &lt;a href=&quot;#newPADNAMEpvn&quot;&gt;newPADNAMEpvn&lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="2e65b217a955ea30db7dba5262fee4bb7d3f1ee4" translate="yes" xml:space="preserve">
          <source>Constructs and returns an op to access &lt;code&gt;$_&lt;/code&gt; , either as a lexical variable (if declared as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ) in the current scope, or the global &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">현재 범위에서 어휘 변수 ( &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; $ _ 로 선언 된 경우 ) 또는 전역 &lt;code&gt;$_&lt;/code&gt; 로 &lt;code&gt;$_&lt;/code&gt; 에 액세스하기위한 op를 구성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ae689682f7c0e04b90f758bf2d179623e2a04a1a" translate="yes" xml:space="preserve">
          <source>Constructs and returns an op to access &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; 에 액세스하기위한 op를 구성하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2a4f89b89092a94b632bbcc30495e0f779fb1b98" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a conditional-expression (&lt;code&gt;cond_expr&lt;/code&gt; ) op.</source>
          <target state="translated">조건부 표현식 ( &lt;code&gt;cond_expr&lt;/code&gt; ) op를 구성, 확인 및 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8d7f92756d7585975f06caf0ac07796b4c0804e8" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a conditional-expression (&lt;code&gt;cond_expr&lt;/code&gt;) op. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 is automatically set. &lt;code&gt;first&lt;/code&gt; supplies the expression selecting between the two branches, and &lt;code&gt;trueop&lt;/code&gt; and &lt;code&gt;falseop&lt;/code&gt; supply the branches; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">조건식 ( &lt;code&gt;cond_expr&lt;/code&gt; ) 작업을 구성, 확인 및 반환합니다 . &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공하고, 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트는 값이 1 인 비트가 자동으로 설정된다는 점을 제외하고는 제공됩니다. &lt;code&gt;first&lt;/code&gt; 두 가지 사이에서 선택하는 표현식을 제공하고, &lt;code&gt;trueop&lt;/code&gt; 과 &lt;code&gt;falseop&lt;/code&gt; 은 가지를 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="a15e166f7981a3b6de1c8fa20addbc3d348e0378" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a logical (flow control) op.</source>
          <target state="translated">논리적 인 (흐름 제어) op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e943e42031a0c4c99a8a4b816cbcdbebc24bb18d" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a logical (flow control) op. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 is automatically set. &lt;code&gt;first&lt;/code&gt; supplies the expression controlling the flow, and &lt;code&gt;other&lt;/code&gt; supplies the side (alternate) chain of ops; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">논리 (흐름 제어) 작업을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공하고, 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트는 값이 1 인 비트가 자동으로 설정된다는 점을 제외하고는 제공됩니다. &lt;code&gt;first&lt;/code&gt; 흐름을 제어하는 ​​표현식을 제공하고 &lt;code&gt;other&lt;/code&gt; 는 연산의 측면 (대체) 체인을 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="f0264af3189ddcf2b7f625626d2ac18862a78a27" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a loop-exiting op (such as &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">루프 종료 op (예 : &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; )를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c01e4a75b538d745223a82e950b9a49ee8bd9f2c" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a loop-exiting op (such as &lt;code&gt;goto&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt;). &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;label&lt;/code&gt; supplies the parameter determining the target of the op; it is consumed by this function and becomes part of the constructed op tree.</source>
          <target state="translated">루프 종료 작업 (예 : &lt;code&gt;goto&lt;/code&gt; 또는 &lt;code&gt;last&lt;/code&gt; )을 생성 , 확인 및 반환합니다 . &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;label&lt;/code&gt; 은 op의 대상을 결정하는 매개 변수를 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="30e773cac5de3784659768f91ee0dd8d9488d2fc" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns a new &lt;code&gt;stub&lt;/code&gt; op, which represents an empty list expression.</source>
          <target state="translated">빈리스트 표현을 나타내는 새로운 &lt;code&gt;stub&lt;/code&gt; op를 구축, 확인 및 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="c12d66e7978fb577b34088dcb70b91bfaa6d01da" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an &lt;code&gt;lslice&lt;/code&gt; (list slice) op.</source>
          <target state="translated">&lt;code&gt;lslice&lt;/code&gt; (목록 슬라이스) op를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="395829441207b9562343286c79a860eb298847b4" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an &lt;code&gt;lslice&lt;/code&gt; (list slice) op. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 or 2 is automatically set as required. &lt;code&gt;listval&lt;/code&gt; and &lt;code&gt;subscript&lt;/code&gt; supply the parameters of the slice; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">&lt;code&gt;lslice&lt;/code&gt; (목록 슬라이스) 작업을 구성, 확인 및 반환합니다 . &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공하고, 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트가 제공 됩니다 . 단, 값이 1 또는 2 인 비트는 필요에 따라 자동으로 설정됩니다. &lt;code&gt;listval&lt;/code&gt; 과 &lt;code&gt;subscript&lt;/code&gt; 는 슬라이스의 매개 변수를 제공합니다. 이들은이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba48f5f9a71999341342f24283dfacd3a8b711b1" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an assignment op.</source>
          <target state="translated">과제 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f0afa6802f458ac80fdedccb16a69e851765d5e6" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an assignment op. &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; supply the parameters of the assignment; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">할당 작업을 구성, 확인 및 반환합니다. &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 은 할당 매개 변수를 제공합니다. 이들은이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f565e2e42ef02d170588ec129f3ce0451ec355" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any base type (any type that has no extra fields).</source>
          <target state="translated">기본 유형 (추가 필드가없는 유형)의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="08300813a524ae236831b5817f8255511dd4aa86" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any base type (any type that has no extra fields). &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;.</source>
          <target state="translated">모든 기본 유형 (추가 필드가없는 모든 유형)의 작업을 생성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공하고 8 비트 위로 이동하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="01c70184d1741ef212b465d435e97985417a8b0c" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any binary type.</source>
          <target state="translated">모든 이진 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7868a5fcc0c6cd677c3273a23da0e26392ccfa88" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any binary type. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 or 2 is automatically set as required. &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; supply up to two ops to be the direct children of the binary op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">이진 유형의 op를 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공하고, 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트가 제공 됩니다 . 단, 값이 1 또는 2 인 비트는 필요에 따라 자동으로 설정됩니다. &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 은 이진 작업의 직접적인 자식이되기 위해 최대 두 개의 작업을 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa434ea30a23789450d348f36bdecb9028e1240" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any list type.</source>
          <target state="translated">모든 목록 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e4f396d9aec4576569dc19fe92d9454b6158211" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any list type. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically if required. &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; supply up to two ops to be direct children of the list op; they are consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">모든 목록 유형의 작업을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 필요한 경우 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공 합니다. 목록 작업의 직계 자식이되도록 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; 작업을 최대 2 개까지 공급합니다. 이들은이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e39d7609ebd71139a1fdb8c22c888dbc1b3832" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any pattern matching type.</source>
          <target state="translated">패턴 일치 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ccf69d9f4b2427a58254b1dc047369650066cd4c" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any pattern matching type. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;.</source>
          <target state="translated">패턴 일치 유형의 연산을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공하고 8 비트 위로 이동하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5458dc98c9452c937824a796bdb326f5e0961a85" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves a reference to a pad element.</source>
          <target state="translated">pad 요소에 대한 참조가 포함 된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43e954720e3291569bbb261f1571ecceba739fa2" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves a reference to a pad element. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;. A pad slot is automatically allocated, and is populated with &lt;code&gt;sv&lt;/code&gt;; this function takes ownership of one reference to it.</source>
          <target state="translated">pad 요소에 대한 참조를 포함하는 모든 유형의 op를 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공합니다 . 패드 슬롯이 자동으로 할당되고 &lt;code&gt;sv&lt;/code&gt; 로 채워집니다 . 이 함수는 하나의 참조에 대한 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="40ba5d8fe10410945734740719237761dd251d13" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded C-level pointer (PV).</source>
          <target state="translated">임베디드 C 레벨 포인터 (PV)를 포함하는 모든 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2118ce473e48343aee2d542f585bd5aebe47a744" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded C-level pointer (PV). &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;. &lt;code&gt;pv&lt;/code&gt; supplies the C-level pointer. Depending on the op type, the memory referenced by &lt;code&gt;pv&lt;/code&gt; may be freed when the op is destroyed. If the op is of a freeing type, &lt;code&gt;pv&lt;/code&gt; must have been allocated using &lt;code&gt;PerlMemShared_malloc&lt;/code&gt;.</source>
          <target state="translated">임베디드 C 레벨 포인터 (PV)를 포함하는 모든 유형의 op를 구성, 확인 및 리턴합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공합니다 . &lt;code&gt;pv&lt;/code&gt; 는 C 레벨 포인터를 제공합니다. op 유형에 따라 &lt;code&gt;pv&lt;/code&gt; 가 참조하는 메모리 는 op가 파괴 될 때 해제 될 수 있습니다. 작업이 해제 유형 인 경우 &lt;code&gt;pv&lt;/code&gt; 는 &lt;code&gt;PerlMemShared_malloc&lt;/code&gt; 을 사용하여 할당되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="97dc9643deaf81478aaf21202427a04fd76571a8" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded SV.</source>
          <target state="translated">내장 된 SV와 관련된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e68327dd670d12818a0e2e2fa0e040ec98d02330" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded SV. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;. &lt;code&gt;sv&lt;/code&gt; gives the SV to embed in the op; this function takes ownership of one reference to it.</source>
          <target state="translated">포함 된 SV를 포함하는 모든 유형의 작업을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공합니다 . &lt;code&gt;sv&lt;/code&gt; 는 연산에 포함 할 SV를 제공합니다. 이 함수는 하나의 참조에 대한 소유권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="11846120c71e3d2b822e351f27e91e0b600f0d70" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded reference to a GV.</source>
          <target state="translated">GV에 대한 참조가 포함 된 모든 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="673add21e294ce12887acf0c7f51f18eadeaed4a" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any type that involves an embedded reference to a GV. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;. &lt;code&gt;gv&lt;/code&gt; identifies the GV that the op should reference; calling this function does not transfer ownership of any reference to it.</source>
          <target state="translated">GV에 대한 포함 된 참조를 포함하는 모든 유형의 작업을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공합니다 . &lt;code&gt;gv&lt;/code&gt; 는 op가 참조해야하는 GV를 식별합니다. 이 함수를 호출해도 참조 소유권이 이전되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1d063b1956e56be8e0dab06b4dad3b2a72f8365" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any unary type.</source>
          <target state="translated">단항 유형의 op를 구성, 확인 및 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7aa233edb3302ad2f8fbd75ee51baf9384e5409" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of any unary type. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically if required, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 is automatically set. &lt;code&gt;first&lt;/code&gt; supplies an optional op to be the direct child of the unary op; it is consumed by this function and become part of the constructed op tree.</source>
          <target state="translated">모든 단항 유형의 연산을 구성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공합니다 . 단 &lt;code&gt;OPf_KIDS&lt;/code&gt; 는 필요한 경우 자동으로 설정되고 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트는 값이 1 인 비트가 자동으로 설정된다는 점을 제외하고 는 8 비트입니다 . &lt;code&gt;first&lt;/code&gt; 단항 연산의 직계 자식이 될 선택적 연산을 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="be6ef2fa148c74ce9131470cb7120ad15eeee6a2" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a constant method name.</source>
          <target state="translated">상수 메소드 이름을 사용하여 메소드 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f4f715f8028f2ee97d33f1514b330f7f389b6904" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a constant method name. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;. &lt;code&gt;const_meth&lt;/code&gt; supplies a constant method name; it must be a shared COW string. Supported optypes: &lt;code&gt;OP_METHOD_NAMED&lt;/code&gt;.</source>
          <target state="translated">상수 메서드 이름이있는 메서드 유형의 작업을 생성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공하고 8 비트 위로 이동하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트를 제공 합니다. &lt;code&gt;const_meth&lt;/code&gt; 는 상수 메소드 이름을 제공합니다. 공유 COW 문자열이어야합니다. 지원되는 optype : &lt;code&gt;OP_METHOD_NAMED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3dad86210e9b0dd94c41f8743c265b479cf1818" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a method name evaluated at runtime.</source>
          <target state="translated">런타임에 평가 된 메소드 이름을 사용하여 메소드 유형의 op를 구성, 확인 및 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="06f02e43380ba7cd38f00caa8eda5a0cd2074915" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op of method type with a method name evaluated at runtime. &lt;code&gt;type&lt;/code&gt; is the opcode. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 is automatically set. &lt;code&gt;dynamic_meth&lt;/code&gt; supplies an op which evaluates method name; it is consumed by this function and become part of the constructed op tree. Supported optypes: &lt;code&gt;OP_METHOD&lt;/code&gt;.</source>
          <target state="translated">런타임에 평가 된 메서드 이름을 사용하여 메서드 유형의 작업을 생성, 확인 및 반환합니다. &lt;code&gt;type&lt;/code&gt; 은 opcode입니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;OPf_KIDS&lt;/code&gt; 가 자동으로 설정 된다는 점을 제외하고 는 &lt;code&gt;op_flags&lt;/code&gt; 의 8 비트를 제공하고, 8 비트 위로 이동 하면 &lt;code&gt;op_private&lt;/code&gt; 의 8 비트는 값이 1 인 비트가 자동으로 설정된다는 점을 제외하고는 제공됩니다. &lt;code&gt;dynamic_meth&lt;/code&gt; 는 메소드 이름을 평가하는 op를 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다. 지원되는 optype : &lt;code&gt;OP_METHOD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ac910e3116c4e1a0b4ad7257fc6a8a1ad7ea627" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;foreach&lt;/code&gt; loop (iteration through a list of values). This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프를 표현하는 op 트리 (값 목록을 통한 반복)를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 루프를 빠져 나갈 수있는 구조를 가진 헤비급 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="02a9a03eeb4c7c60c95dbeb72b0b27f5aefe3151" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;foreach&lt;/code&gt; loop (iteration through a list of values). This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;last&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 루프 (값 목록을 통한 반복)를 표현하는 연산 트리를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;last&lt;/code&gt; 과 같은 방식으로 루프를 종료 할 수있는 구조를 가진 무거운 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="55a13424c4ba2a08e5a59cecb68e29d3affe0ee4" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 블록을 표현하는 op 트리를 구성, 확인 및 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d6c3455283830192033a7b5271a5d145aa42790" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;given&lt;/code&gt; block. &lt;code&gt;cond&lt;/code&gt; supplies the expression to whose value &lt;code&gt;$_&lt;/code&gt; will be locally aliased, and &lt;code&gt;block&lt;/code&gt; supplies the body of the &lt;code&gt;given&lt;/code&gt; construct; they are consumed by this function and become part of the constructed op tree. &lt;code&gt;defsv_off&lt;/code&gt; must be zero (it used to identity the pad slot of lexical $_).</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; 블록을 표현하는 연산 트리를 구성, 확인 및 반환합니다 . &lt;code&gt;cond&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 값 이 로컬로 별칭이 지정 될 표현식을 제공 하고 &lt;code&gt;block&lt;/code&gt; 은 &lt;code&gt;given&lt;/code&gt; 구성 의 본문을 제공합니다 . 이들은이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다. &lt;code&gt;defsv_off&lt;/code&gt; 는 0이어야합니다 (어휘 $ _의 패드 슬롯을 식별하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="fa87d1a87fb2d4ab5d631e62f196faf139c56915" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;when&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 블록을 나타내는 op 트리를 구성, 확인 및 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fbd249383a77b78396a0d1d7ae7886570bb179e5" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;when&lt;/code&gt; block. &lt;code&gt;cond&lt;/code&gt; supplies the test expression, and &lt;code&gt;block&lt;/code&gt; supplies the block that will be executed if the test evaluates to true; they are consumed by this function and become part of the constructed op tree. &lt;code&gt;cond&lt;/code&gt; will be interpreted DWIMically, often as a comparison against &lt;code&gt;$_&lt;/code&gt;, and may be null to generate a &lt;code&gt;default&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 블록을 표현하는 op 트리를 구성, 확인 및 반환합니다 . &lt;code&gt;cond&lt;/code&gt; 용품 테스트 표현하고 &lt;code&gt;block&lt;/code&gt; 공급 true로 시험 평가되면 실행될 블록; 이들은이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다. &lt;code&gt;cond&lt;/code&gt; 는 종종 &lt;code&gt;$_&lt;/code&gt; 에 대한 비교로 DWIM 적으로 해석되며 &lt;code&gt;default&lt;/code&gt; 블록 을 생성하기 위해 null 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9e325766c242f95f44aebbca8d081041fa05bdb" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;while&lt;/code&gt; loop. This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프를 나타내는 op 트리를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 루프를 빠져 나갈 수있는 구조를 가진 헤비급 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="05e4ac8f71be06feb12f71523e347e0bcf83d0af" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a &lt;code&gt;while&lt;/code&gt; loop. This is a heavyweight loop, with structure that allows exiting the loop by &lt;code&gt;last&lt;/code&gt; and suchlike.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프를 표현하는 op 트리를 구성, 확인 및 반환합니다 . 이것은 &lt;code&gt;last&lt;/code&gt; 과 같은 방식으로 루프를 종료 할 수있는 구조를 가진 무거운 루프 입니다.</target>
        </trans-unit>
        <trans-unit id="c90b8188bc17094c3efa9918fac996ca1396dace" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a loop. This is only a loop in the control flow through the op tree; it does not have the heavyweight loop structure that allows exiting the loop by &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and suchlike.</source>
          <target state="translated">루프를 표현하는 op 트리를 구성, 확인 및 반환합니다. 이것은 op 트리를 통한 제어 흐름의 루프 일뿐입니다. 루프 등을 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 나갈 수있는 헤비급 루프 구조가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e43bc240808e944d826764a6b57215fa4ebd500b" translate="yes" xml:space="preserve">
          <source>Constructs, checks, and returns an op tree expressing a loop. This is only a loop in the control flow through the op tree; it does not have the heavyweight loop structure that allows exiting the loop by &lt;code&gt;last&lt;/code&gt; and suchlike. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the top-level op, except that some bits will be set automatically as required. &lt;code&gt;expr&lt;/code&gt; supplies the expression controlling loop iteration, and &lt;code&gt;block&lt;/code&gt; supplies the body of the loop; they are consumed by this function and become part of the constructed op tree. &lt;code&gt;debuggable&lt;/code&gt; is currently unused and should always be 1.</source>
          <target state="translated">루프를 표현하는 연산 트리를 구성, 확인 및 반환합니다. 이것은 op 트리를 통한 제어 흐름의 루프 일뿐입니다. 그것은 &lt;code&gt;last&lt;/code&gt; 루프를 빠져 나갈 수있는 무거운 루프 구조를 가지고 있지 않습니다 . &lt;code&gt;flags&lt;/code&gt; 는 최상위 op에 대해 8 비트의 &lt;code&gt;op_flags&lt;/code&gt; 를 제공 하지만 일부 비트는 필요에 따라 자동으로 설정됩니다. &lt;code&gt;expr&lt;/code&gt; 은 루프 반복을 제어하는 ​​표현식을 제공하고 &lt;code&gt;block&lt;/code&gt; 은 루프의 본문을 제공합니다. 이 함수에 의해 소비되고 구성된 연산 트리의 일부가됩니다. &lt;code&gt;debuggable&lt;/code&gt; 은 현재 사용되지 않으며 항상 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c8c9bb3c9bf3bfa59be4b5278462422ffe70ce9" translate="yes" xml:space="preserve">
          <source>Consult &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; , &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 및 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c68fb29a7e2fbcaf46dc09a0ccdb31da36a628a" translate="yes" xml:space="preserve">
          <source>Consult the match table in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; for details of when overloading is invoked.</source>
          <target state="translated">오버로딩이 호출되는시기에 대한 자세한 내용은 &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop의 &quot;Smartmatch Operator&quot;에서&lt;/a&gt; 일치 테이블을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ec12aed4c398eee706a2f38aa675e4e5cfbdd63" translate="yes" xml:space="preserve">
          <source>Consult the match table in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; for details of when overloading is invoked.</source>
          <target state="translated">오버로드가 호출되는시기에 대한 세부 사항은 &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop의 Smartmatch Operator에서&lt;/a&gt; 일치 테이블을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1fd931d92d878f5d6e61e52c546fa06ca2d480c" translate="yes" xml:space="preserve">
          <source>Consume text in the lexer buffer, from &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt; up to &lt;code&gt;ptr&lt;/code&gt;. This advances &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt; to match &lt;code&gt;ptr&lt;/code&gt;, performing the correct bookkeeping whenever a newline character is passed. This is the normal way to consume lexed text.</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt; bufptr&quot;&lt;/a&gt; 에서 &lt;code&gt;ptr&lt;/code&gt; 까지 렉서 버퍼의 텍스트를 소비합니다 . 이렇게하면 &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt; bufptr&quot;&lt;/a&gt; 이 &lt;code&gt;ptr&lt;/code&gt; 과 일치하도록 발전 하여 개행 문자가 전달 될 때마다 올바른 부기 작업을 수행합니다. 이것은 어휘 텍스트를 사용하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ca43cc0a723d7c90161c4e5b539040ca4d3086b1" translate="yes" xml:space="preserve">
          <source>Consume text in the lexer buffer, from &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; up to</source>
          <target state="translated">에서, 렉서 버퍼에 텍스트를 소비 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;&amp;gt; PL_parser- bufptr&lt;/a&gt; 까지</target>
        </trans-unit>
        <trans-unit id="b4ad122fe1d7a0ae29f00402fc9b4022ca12c144" translate="yes" xml:space="preserve">
          <source>Consumers &lt;b&gt;may&lt;/b&gt; use this field to determine how to index the distribution for CPAN or other repositories in addition to or in replacement of heuristics based on version number or file name.</source>
          <target state="translated">소비자 &lt;b&gt;는&lt;/b&gt; 이 필드를 사용하여 버전 번호 또는 파일 이름을 기반으로하는 휴리스틱 스에 추가하거나 대체 할 때 CPAN 또는 기타 리포지토리에 대한 배포를 인덱싱하는 방법을 결정할 &lt;b&gt;수&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9f3385a7dff3695905eb32d60a85e4f8ba47b1" translate="yes" xml:space="preserve">
          <source>Consumers &lt;b&gt;must not&lt;/b&gt; include optional features as prerequisites without explicit instruction from users (whether via interactive prompting, a function parameter or a configuration value, etc. ).</source>
          <target state="translated">소비자 &lt;b&gt;는&lt;/b&gt; 사용자의 명시적인 지시없이 (대화 형 프롬프트, 기능 매개 변수 또는 구성 값 등을 통해) 필수 구성 요소로 선택적 기능을 포함 &lt;b&gt;해서는 안됩니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="4d4fcd544311f4c76588de2edf6e173261c9ba1d" translate="yes" xml:space="preserve">
          <source>Consumers expecting a List &lt;b&gt;must&lt;/b&gt; consider a String as equivalent to a List of length 1.</source>
          <target state="translated">목록을 예상하는 소비자 는 문자열을 길이 1의 목록에 해당하는 것으로 간주 &lt;b&gt;해야합니다.&lt;/b&gt; ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="43209a4be7cddb7bdbb52d54ef186a14e666722b" translate="yes" xml:space="preserve">
          <source>Consumers of metadata &lt;b&gt;should&lt;/b&gt; test whether prerequisites would result in installed module files being &quot;downgraded&quot; to an older version and &lt;b&gt;may&lt;/b&gt; warn users or ignore the prerequisite that would cause such a result.</source>
          <target state="translated">메타 데이터 소비자는 사전 요구 사항으로 인해 설치된 모듈 파일이 이전 버전으로 &quot;다운 그레이드&quot;되는지 여부 &lt;b&gt;를&lt;/b&gt; 테스트 &lt;b&gt;해야하며&lt;/b&gt; 사용자에게 경고하거나 그러한 결과를 초래하는 사전 요구 사항을 무시할 &lt;b&gt;수&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec0fc80e3a2fdea5d8d4635e5e800274735ed50" translate="yes" xml:space="preserve">
          <source>Consumers of metadata may ignore any or all custom keys. All other keys not described herein are invalid and should be ignored by consumers. Producers must not generate or output invalid keys.</source>
          <target state="translated">메타 데이터 소비자는 일부 또는 모든 사용자 지정 키를 무시할 수 있습니다. 여기에 설명되지 않은 다른 모든 키는 유효하지 않으며 소비자가 무시해야합니다. 생산자는 유효하지 않은 키를 생성하거나 출력해서는 안됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="7c712abfda3733cb013c9544bce09f06a6877d81" translate="yes" xml:space="preserve">
          <source>Consumers that install the distribution must ensure that</source>
          <target state="translated">배포판을 설치하는 소비자는 다음 사항을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="712ade694782b4208a7818ba8fcb3c706be82adc" translate="yes" xml:space="preserve">
          <source>Consuming all (or nearly all) available memory.</source>
          <target state="translated">사용 가능한 모든 (또는 거의 모든) 메모리를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="75e095c92e8dc2373fb8acb2c9c8c4bbc0dd91e3" translate="yes" xml:space="preserve">
          <source>Contact a system administrator (preferably your own) and report the exact error message you get, and ask them to read this same documentation you are now reading. They should be able to check whether there is something wrong with the locale configuration of the system. The &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;Finding locales&quot;&lt;/a&gt; section is unfortunately a bit vague about the exact commands and places because these things are not that standardized.</source>
          <target state="translated">시스템 관리자 (가급적이면 귀하 자신)에게 연락하여 표시되는 정확한 오류 메시지를보고하고 지금 읽고있는 동일한 문서를 읽어달라고 요청하십시오. 시스템의 로케일 구성에 문제가 있는지 확인할 수 있어야합니다. &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;찾기 로케일&quot;&lt;/a&gt; 이런 일이 표준화되지 않습니다 때문에 섹션은 불행하게도 정확한 명령과 장소에 대한 약간 모호합니다.</target>
        </trans-unit>
        <trans-unit id="bda96c5452873306650630c6976f525d6dc4916b" translate="yes" xml:space="preserve">
          <source>Contact a system administrator (preferably your own) and report the exact error message you get, and ask them to read this same documentation you are now reading. They should be able to check whether there is something wrong with the locale configuration of the system. The &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt; section is unfortunately a bit vague about the exact commands and places because these things are not that standardized.</source>
          <target state="translated">시스템 관리자 (바람직하게는 본인의 시스템 관리자)에게 연락하여 정확한 오류 메시지를보고하고 지금 읽고있는 것과 동일한 문서를 읽도록 요청하십시오. 시스템의 로케일 구성에 문제가 있는지 확인할 수 있어야합니다. &lt;a href=&quot;#Finding-locales&quot;&gt;찾기 로케일&lt;/a&gt; 이 일이 표준화되지 않습니다 때문에 섹션은 불행하게도 정확한 명령과 장소에 대한 약간 모호합니다.</target>
        </trans-unit>
        <trans-unit id="5a0be3e3d687fc1f8934755e52704c0c7e6471d4" translate="yes" xml:space="preserve">
          <source>Contact the author on &lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt; 로 저자에게 연락하십시오 .</target>
        </trans-unit>
        <trans-unit id="c364095526b17c16b7466605f96d5be4fe90017e" translate="yes" xml:space="preserve">
          <source>Contact the author on &lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rainer@mathematik.uni-bielefeld.de&lt;/code&gt; 에서 저자에게 연락하십시오 .</target>
        </trans-unit>
        <trans-unit id="12a45517b93a1913e898fe4ace7dad3444d8069a" translate="yes" xml:space="preserve">
          <source>Contained in the file specified by the first filename on the command line. (Note that systems supporting the &lt;code&gt;#!&lt;/code&gt; notation invoke interpreters this way. See &lt;a href=&quot;#Location-of-Perl&quot;&gt;&quot;Location of Perl&quot;&lt;/a&gt;.)</source>
          <target state="translated">명령 줄의 첫 번째 파일 이름에 지정된 파일에 포함됩니다. ( &lt;code&gt;#!&lt;/code&gt; 표기법을 지원하는 시스템 은 이런 방식으로 인터프리터를 호출합니다. &lt;a href=&quot;#Location-of-Perl&quot;&gt;&quot;Perl의 위치&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d62bfc367abe11a79b1d86ac7e31441eab7366c1" translate="yes" xml:space="preserve">
          <source>Contained in the file specified by the first filename on the command line. (Note that systems supporting the &lt;code&gt;#!&lt;/code&gt; notation invoke interpreters this way. See &lt;a href=&quot;#Location-of-Perl&quot;&gt;Location of Perl&lt;/a&gt;.)</source>
          <target state="translated">명령 행에서 첫 번째 파일 이름으로 지정된 파일에 포함됩니다. ( &lt;code&gt;#!&lt;/code&gt; 표기법을 지원하는 시스템 은 이러한 방식으로 인터프리터를 호출합니다. &lt;a href=&quot;#Location-of-Perl&quot;&gt;Perl의 위치를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="99db2196146f29190c8ba989fc64f822ae8e38d1" translate="yes" xml:space="preserve">
          <source>Contains a lot of useful information, especially gory details of ISO vs. vendor mappings.</source>
          <target state="translated">많은 유용한 정보, 특히 ISO 대 공급 업체 매핑에 대한 자세한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d2dc6d4567d98dfae81f4e429a6a8bb4e9a0c7" translate="yes" xml:space="preserve">
          <source>Contains flags controlling perl's behaviour on exit():</source>
          <target state="translated">exit ()에서 perl의 동작을 제어하는 ​​플래그를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="537701da726a37f50cd1190981e9266174458d7a" translate="yes" xml:space="preserve">
          <source>Contains routines that emulate low-level math functions in BigInt, e.g. optional routines the low-level math package does not provide on its own.</source>
          <target state="translated">BigInt에서 하위 수준 수학 함수를 에뮬레이트하는 루틴 (예 : 하위 수준 수학 패키지가 자체적으로 제공하지 않는 선택적 루틴)을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a8140068c6564fc99ecc142e17f391b1e09f6ccb" translate="yes" xml:space="preserve">
          <source>Contains the arguments of current subroutine, or the &lt;code&gt;@ARGV&lt;/code&gt; array if in the toplevel context.</source>
          <target state="translated">현재 서브 루틴의 인수 또는 최상위 컨텍스트에있는 경우 &lt;code&gt;@ARGV&lt;/code&gt; 배열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9f2a5da0585f47140af9323564aa8fb7d1d06cc4" translate="yes" xml:space="preserve">
          <source>Contains the name of the current file when reading from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 읽을 때 현재 파일의 이름을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f526bb75dbad569c0a45ab263184903b5cf89a" translate="yes" xml:space="preserve">
          <source>Contains the name of the current file when reading from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 에서 읽을 때 현재 파일의 이름을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="6178dce23f2a4c5ea5896dcce1de535426b55d99" translate="yes" xml:space="preserve">
          <source>Contains the name of the header to be included to get va_dcl definition. Typically one of</source>
          <target state="translated">va_dcl 정의를 얻기 위해 포함 할 헤더의 이름을 포함합니다. 일반적으로</target>
        </trans-unit>
        <trans-unit id="d1e0c34957a016a1b3c12f032cd551c8908cd506" translate="yes" xml:space="preserve">
          <source>Contains the name of the program being executed.</source>
          <target state="translated">실행중인 프로그램의 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2d63762428e57520df2f4f29a1e038ab7994558" translate="yes" xml:space="preserve">
          <source>Contains the prefix to use for tagging variable names in the output. The default is &quot;VAR&quot;.</source>
          <target state="translated">출력에서 변수 이름에 태그를 지정하는 데 사용할 접 두부를 포함합니다. 기본값은 &quot;VAR&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0e2da210cc9bb0a18aac5aab8614cb8e5b7b6dff" translate="yes" xml:space="preserve">
          <source>Contains the subpattern from the corresponding set of capturing parentheses from the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="translated">마지막으로 성공한 패턴 일치에서 해당 캡처 캡처 괄호 세트의 하위 패턴을 포함하며 이미 종료 된 중첩 블록과 일치하는 패턴은 계산하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="f443ee7926598f5cbd0be8ebdba62f74758c2b93" translate="yes" xml:space="preserve">
          <source>Context objects make it easy to wrap other tools that also use context. Once you grab a context, any tool you call before releasing your context will inherit it:</source>
          <target state="translated">컨텍스트 개체를 사용하면 컨텍스트를 사용하는 다른 도구를 쉽게 래핑 할 수 있습니다. 컨텍스트를 가져 오면 컨텍스트를 해제하기 전에 호출하는 모든 도구가이를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="9f4fead0d096994a7b9c2359f6b5eca7fb19280c" translate="yes" xml:space="preserve">
          <source>Contexts are popped using &lt;code&gt;cx_popsub()&lt;/code&gt; etc. and &lt;code&gt;cx_popblock()&lt;/code&gt;. Note however, that unlike &lt;code&gt;cx_pushblock&lt;/code&gt;, neither of these functions actually decrement the current context stack index; this is done separately using &lt;code&gt;CX_POP()&lt;/code&gt;.</source>
          <target state="translated">컨텍스트는 &lt;code&gt;cx_popsub()&lt;/code&gt; 등 및 &lt;code&gt;cx_popblock()&lt;/code&gt; 사용하여 팝됩니다 . 그러나 &lt;code&gt;cx_pushblock&lt;/code&gt; 과 달리 이러한 함수는 실제로 현재 컨텍스트 스택 인덱스를 감소시키지 않습니다. 이것은 &lt;code&gt;CX_POP()&lt;/code&gt; 사용하여 별도로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="08a4ac56da853a9305cfda31ecf842885e9d6e74" translate="yes" xml:space="preserve">
          <source>Contiguous-best-try.</source>
          <target state="translated">Contiguous-best-try.</target>
        </trans-unit>
        <trans-unit id="f6fab447918abf1777396cb39329e0055bc066fb" translate="yes" xml:space="preserve">
          <source>Contiguous.</source>
          <target state="translated">Contiguous.</target>
        </trans-unit>
        <trans-unit id="9cb23f093a42f57fb6e20b27af11bf8e322e39c5" translate="yes" xml:space="preserve">
          <source>Continent | |--&amp;gt;Country | |--&amp;gt;[state/province] | |--&amp;gt;ftp | |--&amp;gt;[http]</source>
          <target state="translated">대륙 | |-&amp;gt; 국가 | |-&amp;gt; [주 /도] | |-&amp;gt; ftp | |-&amp;gt; [http]</target>
        </trans-unit>
        <trans-unit id="5eba0b3f0a46323a9b3b38a065a8cf6fcd45e0eb" translate="yes" xml:space="preserve">
          <source>Continue until the return from the current subroutine. Dump the return value if the &lt;code&gt;PrintRet&lt;/code&gt; option is set (default).</source>
          <target state="translated">현재 서브 루틴에서 돌아올 때까지 계속하십시오. &lt;code&gt;PrintRet&lt;/code&gt; 옵션이 설정된 경우 리턴 값을 덤프하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="8cfbf2d4c02ef7cbf2f81d0785ff1541fec7f195" translate="yes" xml:space="preserve">
          <source>Continue, optionally inserting a one-time-only breakpoint at the specified line or subroutine.</source>
          <target state="translated">선택적으로 지정된 라인 또는 서브 루틴에 한 번만 중단 점을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="763f8ab2c102d571523302ea74b56499251a7bfc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, let's say that your program has completed its processing, and the results sit in an array called &lt;code&gt;@processed&lt;/code&gt;. You want to print these lines to a file called &lt;code&gt;numbered.txt&lt;/code&gt; with a neatly formatted column of line-numbers.</source>
          <target state="translated">이전 예제를 계속 진행하면서 프로그램이 처리를 완료했고 결과가 &lt;code&gt;@processed&lt;/code&gt; 라는 배열에 있다고 가정 해 보겠습니다 . 이러한 행을 깔끔한 형식의 행 번호 열이있는 &lt;code&gt;numbered.txt&lt;/code&gt; 라는 파일로 인쇄하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="8a7a39f29f66ddaa64957e3237a6a6d6ce7714c5" translate="yes" xml:space="preserve">
          <source>Contractions beginning with the specified characters are suppressed, even if those contractions are defined in &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">지정된 문자로 시작하는 수축은 수축이 &lt;code&gt;table&lt;/code&gt; 에 정의되어 있어도 억제 됩니다.</target>
        </trans-unit>
        <trans-unit id="63d7042181f2374d9c826c42bd3b5c903244afe8" translate="yes" xml:space="preserve">
          <source>Contractions beginning with the specified characters are suppressed, even if those contractions are defined in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">지정된 문자로 시작하는 축약은 해당 축약이 &lt;code&gt;table&lt;/code&gt; 에 정의되어 있어도 억제 됩니다.</target>
        </trans-unit>
        <trans-unit id="f182d17ce2e9b56202114ddc3d06d6361dea7a8d" translate="yes" xml:space="preserve">
          <source>Contrary to popular belief, Perl 6 and Perl 5 peacefully coexist with one another. Perl 6 has proven to be a fascinating source of ideas for those using Perl 5 (the &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; object system is a well-known example). There is overlap in the communities, and this overlap fosters the tradition of sharing and borrowing that have been instrumental to Perl's success. The current leading implementation of Perl 6 is Rakudo, and you can learn more about it at &lt;a href=&quot;http://rakudo.org&quot;&gt;http://rakudo.org&lt;/a&gt;.</source>
          <target state="translated">대중의 믿음과는 달리, Perl 6과 Perl 5는 서로 평화롭게 공존합니다. Perl 6은 Perl 5를 사용하는 사람들에게 매력적인 아이디어 소스로 입증되었습니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; 객체 시스템은 잘 알려진 예입니다). 지역 사회에는 중복이 있으며,이 중복은 Perl의 성공에 도움이 된 공유 및 차용의 전통을 조성합니다. 현재 Perl 6의 주요 구현은 Rakudo이며 &lt;a href=&quot;http://rakudo.org&quot;&gt;http://rakudo.org&lt;/a&gt; 에서 이에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="302edc87fdd461487f5b0300d3fa290ba8ab7362" translate="yes" xml:space="preserve">
          <source>Contrary to popular belief, Raku and Perl peacefully coexist with one another. Raku has proven to be a fascinating source of ideas for those using Perl (the &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; object system is a well-known example). There is overlap in the communities, and this overlap fosters the tradition of sharing and borrowing that have been instrumental to Perl's success.</source>
          <target state="translated">대중의 신념과는 달리 라쿠와 펄은 평화롭게 공존합니다. Raku는 Perl을 사용하는 사람들에게 매력적인 아이디어의 원천임이 입증되었습니다 ( &lt;a href=&quot;moose&quot;&gt;무스&lt;/a&gt; 객체 시스템은 잘 알려진 예입니다). 커뮤니티에는 중복이 있으며, 이러한 중복은 Perl의 성공에 중요한 도구 인 공유 및 차용의 전통을 촉진합니다.</target>
        </trans-unit>
        <trans-unit id="1cc2fb5710ee22531776c8ba9e55098e2618c67c" translate="yes" xml:space="preserve">
          <source>Contrast that with an independent subexpression:</source>
          <target state="translated">독립 하위 표현식을 사용하여 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="69735e4ec537e4e29ad052c50c3613321af3383c" translate="yes" xml:space="preserve">
          <source>Contrast this with the following make_adder() function, in which the returned anonymous function contains a reference to a lexical variable outside the scope of that function itself. Such a reference requires that Perl return a proper closure, thus locking in for all time the value that the lexical had when the function was created.</source>
          <target state="translated">이것을 다음의 make_adder () 함수와 대조하십시오. 여기에서 반환 된 익명 함수는 그 함수 자체의 범위를 벗어난 어휘 변수에 대한 참조를 포함합니다. 이러한 참조는 Perl이 적절한 클로저를 리턴해야하므로 항상 함수가 작성 될 때 어휘가 갖는 값을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="5c7685d9e7d12d06a8f7c0c062a4c8103b7f97f6" translate="yes" xml:space="preserve">
          <source>Contributors to File::Path, in alphabetical order by first name.</source>
          <target state="translated">File :: Path에 대한 기여자 (이름의 알파벳 순서).</target>
        </trans-unit>
        <trans-unit id="e16f6173d03c0c8b09cdd1d2ddfa6f13bebfd052" translate="yes" xml:space="preserve">
          <source>Control Flow Utilities (callbacks and exceptions etc)</source>
          <target state="translated">제어 흐름 유틸리티 (콜백 및 예외 등)</target>
        </trans-unit>
        <trans-unit id="d8e3def8f1fded2e3eff4c8ea59924177caf98dc" translate="yes" xml:space="preserve">
          <source>Control VMS-specific language features</source>
          <target state="translated">VMS 관련 언어 기능 제어</target>
        </trans-unit>
        <trans-unit id="bce115b0c925643288d6d66089149032ada8c603" translate="yes" xml:space="preserve">
          <source>Control characters</source>
          <target state="translated">제어 문자</target>
        </trans-unit>
        <trans-unit id="b7fe68fe8faa99ef764732f95206a72acbe672ba" translate="yes" xml:space="preserve">
          <source>Control characters can be escaped with &lt;code&gt;\c&lt;/code&gt; , so that a control-Z character would be matched with &lt;code&gt;\cZ&lt;/code&gt; . The escape sequence &lt;code&gt;\Q&lt;/code&gt; ...&lt;code&gt;\E&lt;/code&gt; quotes, or protects most non-alphabetic characters. For instance,</source>
          <target state="translated">제어 문자는 &lt;code&gt;\c&lt;/code&gt; 로 이스케이프 할 수 있으므로 제어 Z 문자는 &lt;code&gt;\cZ&lt;/code&gt; 와 일치 합니다. 이스케이프 시퀀스 &lt;code&gt;\Q&lt;/code&gt; ... &lt;code&gt;\E&lt;/code&gt; 는 대부분의 알파벳이 아닌 문자를 인용하거나 보호합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6fcc265ca1f47c38ce9b43f3e952dab2275082d9" translate="yes" xml:space="preserve">
          <source>Control characters can be escaped with &lt;code&gt;\c&lt;/code&gt;, so that a control-Z character would be matched with &lt;code&gt;\cZ&lt;/code&gt;. The escape sequence &lt;code&gt;\Q&lt;/code&gt;...&lt;code&gt;\E&lt;/code&gt; quotes, or protects most non-alphabetic characters. For instance,</source>
          <target state="translated">제어 문자는 &lt;code&gt;\c&lt;/code&gt; 로 이스케이프 될 수 있으므로 control-Z 문자는 &lt;code&gt;\cZ&lt;/code&gt; 와 일치 합니다. 이스케이프 시퀀스 &lt;code&gt;\Q&lt;/code&gt; ... &lt;code&gt;\E&lt;/code&gt; 는 대부분의 영문자가 아닌 문자를 인용하거나 보호합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="021626ea5dbee24ff07ea2691bf82bb74b7a5674" translate="yes" xml:space="preserve">
          <source>Control characters don't produce output as such, but instead usually control the terminal somehow: for example, newline and backspace are control characters. On ASCII platforms, in the ASCII range, characters whose code points are between 0 and 31 inclusive, plus 127 (&lt;code&gt;DEL&lt;/code&gt; ) are control characters; on EBCDIC platforms, their counterparts are control characters.</source>
          <target state="translated">제어 문자는 출력을 생성하지 않지만 대신 보통 터미널을 제어합니다. 예를 들어, 개행 및 백 스페이스는 제어 문자입니다. ASCII 플랫폼의 ASCII 범위에서 코드 포인트가 0에서 31 사이 인 문자에 127 ( &lt;code&gt;DEL&lt;/code&gt; )을 더한 문자는 제어 문자입니다. EBCDIC 플랫폼에서 해당 플랫폼은 제어 문자입니다.</target>
        </trans-unit>
        <trans-unit id="9f036f96d41dd05d9c964d94dae4ccdc66ebce27" translate="yes" xml:space="preserve">
          <source>Control characters don't produce output as such, but instead usually control the terminal somehow: for example, newline and backspace are control characters. On ASCII platforms, in the ASCII range, characters whose code points are between 0 and 31 inclusive, plus 127 (&lt;code&gt;DEL&lt;/code&gt;) are control characters; on EBCDIC platforms, their counterparts are control characters.</source>
          <target state="translated">제어 문자는 출력을 생성하지 않지만 대신 일반적으로 어떻게 든 터미널을 제어합니다. 예를 들어 개행 문자와 백 스페이스는 제어 문자입니다. ASCII 플랫폼에서 ASCII 범위에서 코드 포인트가 0에서 31 사이의 문자와 127 ( &lt;code&gt;DEL&lt;/code&gt; )을 더한 문자는 제어 문자입니다. EBCDIC 플랫폼에서는 대응 문자가 제어 문자입니다.</target>
        </trans-unit>
        <trans-unit id="472d5bbe2640e68243fd88fba831e600f32a78c2" translate="yes" xml:space="preserve">
          <source>Control disk logging. Little documentation for this IOCTL operation was found. It makes use of a &lt;code&gt;DISK_LOGGING&lt;/code&gt; data structure:</source>
          <target state="translated">디스크 로깅을 제어합니다. 이 IOCTL 작업에 대한 문서는 거의 발견되지 않았습니다. 그것은 사용하게 &lt;code&gt;DISK_LOGGING&lt;/code&gt; 의 데이터 구조를 :</target>
        </trans-unit>
        <trans-unit id="48c7e7313cedea865dec63d7c5b00f10bd429ad8" translate="yes" xml:space="preserve">
          <source>Control optional warnings</source>
          <target state="translated">선택적 경고 제어</target>
        </trans-unit>
        <trans-unit id="c0323bcd19431aa40d48a7a04e563e491b5de2b5" translate="yes" xml:space="preserve">
          <source>Control sort() behaviour</source>
          <target state="translated">sort () 동작 제어</target>
        </trans-unit>
        <trans-unit id="6eed236126d30fd4de8e539b1434bde859966005" translate="yes" xml:space="preserve">
          <source>Control the filetest permission operators</source>
          <target state="translated">파일 테스트 권한 연산자 제어</target>
        </trans-unit>
        <trans-unit id="1a2eedb1b60e1d8a80a133e954e55be108ac924a" translate="yes" xml:space="preserve">
          <source>Control whether the file is unlinked when the object goes out of scope. The file is removed if this value is true and $KEEP_ALL is not.</source>
          <target state="translated">객체가 범위를 벗어날 때 파일이 연결 해제되는지 여부를 제어합니다. 이 값이 true이고 $ KEEP_ALL이 아닌 경우 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e9597894a326a5dddbc5dee41019e4d31b7362ce" translate="yes" xml:space="preserve">
          <source>Controlling Warnings from the Command Line</source>
          <target state="translated">명령 줄에서 경고 제어</target>
        </trans-unit>
        <trans-unit id="68987a6a2f290ee6ca2caa6b3e7b36432344b22a" translate="yes" xml:space="preserve">
          <source>Controlling access: lock()</source>
          <target state="translated">액세스 제어 : lock ()</target>
        </trans-unit>
        <trans-unit id="a1e94cef9625b439090d57cc70615fae34127ab7" translate="yes" xml:space="preserve">
          <source>Controlling input buffering is a remarkably system-dependent matter. On many systems, you can just use the &lt;b&gt;stty&lt;/b&gt; command as shown in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;, but as you see, that's already getting you into portability snags.</source>
          <target state="translated">입력 버퍼링 제어는 시스템에 따라 크게 달라집니다. 많은 시스템 에서 &lt;a href=&quot;functions/getc&quot;&gt;getc에&lt;/a&gt; 표시된 것처럼 &lt;b&gt;stty&lt;/b&gt; 명령을 사용할 수 있지만, 이미 알 수 있듯이 이식성 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="48eebaf19635d9dd98ddb1e7bee6a3c0f045583c" translate="yes" xml:space="preserve">
          <source>Controlling input buffering is a remarkably system-dependent matter. On many systems, you can just use the &lt;b&gt;stty&lt;/b&gt; command as shown in &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt;, but as you see, that's already getting you into portability snags.</source>
          <target state="translated">입력 버퍼링을 제어하는 ​​것은 시스템에 따라 크게 달라집니다. 많은 시스템 &lt;a href=&quot;perlfunc#getc&quot;&gt;에서 perlfunc의 &quot;getc&quot;에&lt;/a&gt; 표시된대로 &lt;b&gt;stty&lt;/b&gt; 명령을 사용할 수 있지만 보시 다시피 이미 이식성 문제가 발생하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d20f10fc399adc1e8262f1893ceb51478f185a6b" translate="yes" xml:space="preserve">
          <source>Controlling where the test output goes.</source>
          <target state="translated">테스트 출력 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="07da5ac1184a4498e39e115db900514920d805cf" translate="yes" xml:space="preserve">
          <source>Controls how certain regex optimisations are applied and how much memory they utilize. This value by default is 65536 which corresponds to a 512kB temporary cache. Set this to a higher value to trade memory for speed when matching large alternations. Set it to a lower value if you want the optimisations to be as conservative of memory as possible but still occur, and set it to a negative value to prevent the optimisation and conserve the most memory. Under normal situations this variable should be of no interest to you.</source>
          <target state="translated">특정 정규식 최적화가 적용되는 방식과 이들이 사용하는 메모리 양을 제어합니다. 기본적으로이 값은 65536이며 512kB 임시 캐시에 해당합니다. 큰 교대를 일치시킬 때 속도를 위해 메모리를 교환하려면이 값을 더 높은 값으로 설정하십시오. 최적화가 가능한 한 메모리를 보존하지만 여전히 발생하게하려면 더 낮은 값으로 설정하고 최적화를 방지하고 최대 메모리를 보존하려면 음수 값으로 설정하십시오. 정상적인 상황에서이 변수는 관심이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="878f21f1789fd1d8bba78852bd19060efa986e3e" translate="yes" xml:space="preserve">
          <source>Controls the behaviour of global destruction of objects and other references. See &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;&quot;PERL_DESTRUCT_LEVEL&quot; in perlhacktips&lt;/a&gt; for more information.</source>
          <target state="translated">객체 및 기타 참조의 전역 파괴 동작을 제어합니다. 자세한 내용은 &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;perlhacktips의 &quot;PERL_DESTRUCT_LEVEL&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="554cef6ea070153a4ee1bebb92008fd6058cf45d" translate="yes" xml:space="preserve">
          <source>Controls the degree to which the output can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to recreate the supplied reference structures. Setting it to 1 will output additional perl statements that will correctly recreate nested references. The default is 0.</source>
          <target state="translated">제공된 참조 구조를 재생성하기 위해 출력을 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 수있는 정도를 제어합니다 . 1로 설정하면 중첩 된 참조를 올바르게 다시 작성하는 추가 perl 문이 출력됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="65ee2dd46953947a14b91e1acd27d68a4fa5dcee" translate="yes" xml:space="preserve">
          <source>Controls the degree to which the output can be &lt;code&gt;eval&lt;/code&gt;ed to recreate the supplied reference structures. Setting it to 1 will output additional perl statements that will correctly recreate nested references. The default is 0.</source>
          <target state="translated">제공된 참조 구조를 다시 만들기 위해 출력을 &lt;code&gt;eval&lt;/code&gt; 수있는 정도를 제어합니다 . 1로 설정하면 중첩 된 참조를 올바르게 다시 생성하는 추가 perl 문이 출력됩니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="acfa684e2caf08a3da5e3ef30109246db004e5da" translate="yes" xml:space="preserve">
          <source>Controls the lengths to which the module will go to check the safety of the temporary file or directory before proceeding. Options are:</source>
          <target state="translated">계속하기 전에 모듈이 임시 파일 또는 디렉토리의 안전성을 확인하는 데 걸리는 길이를 제어합니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ca7717f12fe26367883aafa8d3fbe334c1b18a2" translate="yes" xml:space="preserve">
          <source>Controls the style of indentation. It can be set to 0, 1, 2 or 3. Style 0 spews output without any newlines, indentation, or spaces between list items. It is the most compact format possible that can still be called valid perl. Style 1 outputs a readable form with newlines but no fancy indentation (each level in the structure is simply indented by a fixed amount of whitespace). Style 2 (the default) outputs a very readable form which takes into account the length of hash keys (so the hash value lines up). Style 3 is like style 2, but also annotates the elements of arrays with their index (but the comment is on its own line, so array output consumes twice the number of lines). Style 2 is the default.</source>
          <target state="translated">들여 쓰기 스타일을 조정합니다. 0, 1, 2 또는 3으로 설정할 수 있습니다. 스타일 0은 개행, 들여 쓰기 또는 목록 항목 사이의 공백없이 출력을 분출합니다. 여전히 유효한 perl이라고 할 수있는 가장 컴팩트 한 형식입니다. 스타일 1은 개행과 함께 읽을 수있는 형식을 출력하지만 멋진 들여 쓰기는 없습니다 (구조의 각 레벨은 고정 된 양의 공백으로 들여 쓰기됩니다). 스타일 2 (기본값)는 해시 키의 길이 (해시 값이 정렬 됨)를 고려하여 읽기 쉬운 형식을 출력합니다. 스타일 3은 스타일 2와 유사하지만 인덱스의 배열 요소에 주석을 추가합니다 (하지만 주석은 자체 행에 있으므로 배열 출력은 행 수의 두 배를 소비합니다). 스타일 2가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ec52caca26193d6a82c9598237bf4310487811f7" translate="yes" xml:space="preserve">
          <source>Controls whether a comma is added after the last element of an array or hash. Even when true, no comma is added between the last element of an array or hash and a closing bracket when they appear on the same line. The default is false.</source>
          <target state="translated">배열 또는 해시의 마지막 요소 뒤에 쉼표를 추가할지 여부를 제어합니다. true 인 경우에도 배열 또는 해시의 마지막 요소와 같은 줄에 나타날 때 닫는 대괄호 사이에 쉼표가 추가되지 않습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="22a31fdc3bd2e052c43c5ff90f54688767846776" translate="yes" xml:space="preserve">
          <source>Controls whether debugging messages should be enabled.</source>
          <target state="translated">디버깅 메시지를 사용할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e34cd6a1d6fc0675d9cf236e50c7a40d4f7e0985" translate="yes" xml:space="preserve">
          <source>Controls whether temporary files and directories should be retained regardless of any instructions in the program to remove them automatically. This is useful for debugging but should not be used in production code.</source>
          <target state="translated">프로그램의 지시 사항에 상관없이 임시 파일 및 디렉토리를 자동으로 제거할지 여부를 제어합니다. 디버깅에는 유용하지만 프로덕션 코드에서는 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7787de4ed8d37741fa377fafe5fdafa8b3011126" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzdeflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">압축 된 데이터가 &lt;code&gt;bzdeflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메소드 의 출력 버퍼에 추가되는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="03e461b079d8358eabdfc890d95bb1de4c06830c" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzdeflate&lt;/code&gt;, &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;bzdeflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메서드 의 출력 버퍼에 압축 된 데이터를 추가할지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="f221020431f51974b32a3b5e2fbd634d97908661" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzinflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">압축 된 데이터가 &lt;code&gt;bzinflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메소드 의 출력 버퍼에 추가되는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="0d43609533ae559051f0864148761f4f01ec7c5b" translate="yes" xml:space="preserve">
          <source>Controls whether the compressed data is appended to the output buffer in the &lt;code&gt;bzinflate&lt;/code&gt;, &lt;code&gt;bzflush&lt;/code&gt; and &lt;code&gt;bzclose&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;bzinflate&lt;/code&gt; , &lt;code&gt;bzflush&lt;/code&gt; 및 &lt;code&gt;bzclose&lt;/code&gt; 메서드 의 출력 버퍼에 압축 된 데이터를 추가할지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="c4245dd2343e96e7d4aa52338568c9fd8977b600" translate="yes" xml:space="preserve">
          <source>Controls which compression method is used. At present four compression methods are supported, namely Store (no compression at all), Deflate, Bzip2 and Lzma.</source>
          <target state="translated">사용되는 압축 방법을 제어합니다. 현재 4 가지 압축 방법, 즉 Store (압축 없음), Deflate, Bzip2 및 Lzma가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb06b69bb4c9f83f42cb55738cfe404434afd67" translate="yes" xml:space="preserve">
          <source>Convenience macro to get the REGEXP from a SV. This is approximately equivalent to the following snippet:</source>
          <target state="translated">SV에서 REGEXP를 가져 오는 편의 매크로 이것은 다음 스 니펫과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="197b239c74a71f263a8d75330c22e4fc91bea1ec" translate="yes" xml:space="preserve">
          <source>Convenience method for building testing functions that take regular expressions as arguments.</source>
          <target state="translated">정규식을 인수로 사용하는 테스트 함수를 작성하기위한 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1f619076858d6ded347f81f166e575080deac279" translate="yes" xml:space="preserve">
          <source>Convenience methods</source>
          <target state="translated">편의 방법</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="643e483203bf1176839f0449bd1086c5d82b2884" translate="yes" xml:space="preserve">
          <source>Conversely for &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) mapping, the function named &lt;code&gt;XS_unpack_$ntype&lt;/code&gt; is called with the input Perl scalar as argument and the return value is cast to the mapped C type and assigned to the output C variable.</source>
          <target state="translated">반대로 &lt;code&gt;INPUT&lt;/code&gt; (Perl to XSUB) 맵핑의 경우 &lt;code&gt;XS_unpack_$ntype&lt;/code&gt; 이라는 함수 가 입력 Perl 스칼라를 인수로 사용하여 호출되며 리턴 값은 맵핑 된 C 유형으로 캐스트되고 출력 C 변수에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="12d9c05ad456b2e9dfbd26729c7d5a4582ad8668" translate="yes" xml:space="preserve">
          <source>Conversely when &lt;code&gt;Append&lt;/code&gt; is not specified, or it is present and is set to false, it will operate as follows.</source>
          <target state="translated">반대로 &lt;code&gt;Append&lt;/code&gt; 가 지정되지 않았거나 존재하고 false로 설정되면 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1099367c0a33e0960cc2a79b8c82b72aa819293c" translate="yes" xml:space="preserve">
          <source>Conversely, here is a partial solution for the task of encoding such a URL in any EBCDIC code page:</source>
          <target state="translated">반대로, 다음은 EBCDIC 코드 페이지에서 이러한 URL을 인코딩하는 작업에 대한 부분 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="f8f85b8f15d0328c4cabb7c91d45f9c26048df1a" translate="yes" xml:space="preserve">
          <source>Conversely, when setting &lt;code&gt;$?&lt;/code&gt; in an END block, an attempt is made to convert the POSIX value into a native status intelligible to the operating system upon exiting Perl. What this boils down to is that setting &lt;code&gt;$?&lt;/code&gt; to zero results in the generic success value SS$_NORMAL, and setting &lt;code&gt;$?&lt;/code&gt; to a non-zero value results in the generic failure status SS$_ABORT. See also &lt;a href=&quot;perlport#exit&quot;&gt;&quot;exit&quot; in perlport&lt;/a&gt;.</source>
          <target state="translated">반대로 &lt;code&gt;$?&lt;/code&gt; END 블록에서는 Perl을 종료 할 때 POSIX 값을 운영 체제가 인식 할 수있는 기본 상태로 변환하려고 시도합니다. 이것이 무엇으로 귀결되는 것이 &lt;code&gt;$?&lt;/code&gt; 설정 입니까? 0으로 설정하면 일반 성공 값 SS $ _NORMAL이되고 &lt;code&gt;$?&lt;/code&gt; 0이 아닌 값은 일반 오류 상태 SS $ _ABORT가됩니다. &lt;a href=&quot;perlport#exit&quot;&gt;perlport의 &quot;exit&quot;&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cdc49909eca70fcdaa9911c75b9017083c28375" translate="yes" xml:space="preserve">
          <source>Conversely, when setting &lt;code&gt;$?&lt;/code&gt; in an END block, an attempt is made to convert the POSIX value into a native status intelligible to the operating system upon exiting Perl. What this boils down to is that setting &lt;code&gt;$?&lt;/code&gt; to zero results in the generic success value SS$_NORMAL, and setting &lt;code&gt;$?&lt;/code&gt; to a non-zero value results in the generic failure status SS$_ABORT. See also &lt;a href=&quot;perlport#exit&quot;&gt;exit in perlport&lt;/a&gt;.</source>
          <target state="translated">반대로 &lt;code&gt;$?&lt;/code&gt; 설정할 때 ? END 블록에서 POSIX 값을 Perl 종료시 운영 체제가 이해할 수있는 기본 상태로 변환하려고 시도합니다. 이것으로 요약하면 설정은 &lt;code&gt;$?&lt;/code&gt; 0으로 설정하면 일반 성공 값 SS $ _NORMAL이 발생하고 &lt;code&gt;$?&lt;/code&gt; 0이 아닌 값으로 설정하면 일반 실패 상태 SS $ _ABORT가 발생합니다. &lt;a href=&quot;perlport#exit&quot;&gt;perlport의 exit&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a638ea9e2e8023dcf3f6e834a6be6c36bfe69b02" translate="yes" xml:space="preserve">
          <source>Conversion from the original HTML to POD format</source>
          <target state="translated">원본 HTML에서 POD 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="e9e65ec35e7036fdf8f00963fb1d5aa8781dfc7e" translate="yes" xml:space="preserve">
          <source>Conversion proceeds through each version in turn. For example, a version 1.2 structure might be converted to 1.3 then 1.4 then finally to version 2. The conversion process attempts to clean-up simple errors and standardize data. For example, if &lt;code&gt;author&lt;/code&gt; is given as a scalar, it will converted to an array reference containing the item. (Converting a structure to its own version will also clean-up and standardize.)</source>
          <target state="translated">변환은 차례로 각 버전을 통해 진행됩니다. 예를 들어, 버전 1.2 구조는 1.3으로 변환 된 다음 1.4로 변환 된 다음 마지막으로 버전 2로 변환 될 수 있습니다. 변환 프로세스는 간단한 오류를 정리하고 데이터를 표준화하려고 시도합니다. 예를 들어 &lt;code&gt;author&lt;/code&gt; 가 스칼라로 주어지면 항목을 포함하는 배열 참조로 변환됩니다. (구조를 자체 버전으로 변환하는 것도 정리 및 표준화됩니다.)</target>
        </trans-unit>
        <trans-unit id="42f99a69b0dbcdf11a6d0337c05dbfa48ee474e9" translate="yes" xml:space="preserve">
          <source>Conversions to and from spherical and cylindrical coordinates are available. Please notice that the conversions are not necessarily reversible because of the equalities like</source>
          <target state="translated">구면 및 원통 좌표와의 변환이 가능합니다. 다음과 같은 평등으로 인해 전환이 반드시 되돌릴 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf35c8b871a1fb1996c50ba5b0b5ab5801039529" translate="yes" xml:space="preserve">
          <source>Convert CPAN distribution metadata structures</source>
          <target state="translated">CPAN 배포 메타 데이터 구조 변환</target>
        </trans-unit>
        <trans-unit id="21841a84ce705fac7522bc0e5a625ceef2574143" translate="yes" xml:space="preserve">
          <source>Convert POD data to ASCII text with format escapes</source>
          <target state="translated">형식 이스케이프를 사용하여 POD 데이터를 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="26d9ff3691abc55fd6770d630e2e5af82498a473" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted *roff input</source>
          <target state="translated">POD 데이터를 형식화 된 * roff 입력으로 변환</target>
        </trans-unit>
        <trans-unit id="04c7609219077dfc8d84b97d557ad0e72666eb9b" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted ASCII text</source>
          <target state="translated">POD 데이터를 형식이 지정된 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="db9fd6e0fab456fdc8445a16cbc6756038a981de" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted color ASCII text</source>
          <target state="translated">POD 데이터를 형식이 지정된 색상 ASCII 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="6b476a5cb99c6d07b35dfdedf3e3251b4c8aa51b" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted overstrike text</source>
          <target state="translated">POD 데이터를 형식이 지정된 오버 스트라이크 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="852d9c9da640f6cd2989689129ea988acc8fc255" translate="yes" xml:space="preserve">
          <source>Convert POD data to formatted text</source>
          <target state="translated">POD 데이터를 형식화 된 텍스트로 변환</target>
        </trans-unit>
        <trans-unit id="112d5a9d03872dcf431cd72fd930ebba527fc129" translate="yes" xml:space="preserve">
          <source>Convert Pod to HTML</source>
          <target state="translated">포드를 HTML로 변환</target>
        </trans-unit>
        <trans-unit id="0cbb869440d0cbf2c1db1db64ff336f3cdaa617a" translate="yes" xml:space="preserve">
          <source>Convert a package name to a filename.</source>
          <target state="translated">패키지 이름을 파일 이름으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1148ba82369452869eca19f02c26b0067714d03a" translate="yes" xml:space="preserve">
          <source>Convert a sole 'perl -V' text block, or list of lines, to a complete myconfig hash. All unknown entries are defaulted.</source>
          <target state="translated">단독 'perl -V'텍스트 블록 또는 줄 목록을 완전한 myconfig 해시로 변환합니다. 모든 알 수없는 항목이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="025ffb8bfa07a8087fac34adc747a7743f7ef294" translate="yes" xml:space="preserve">
          <source>Convert a string representing an unsigned decimal number to an object representing the same number. The input is normalize, i.e., it matches &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt; .</source>
          <target state="translated">부호없는 10 진수를 나타내는 문자열을 같은 숫자를 나타내는 객체로 변환합니다. 입력은 정규화됩니다. 즉, &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6db08820b1d9bc7a4c773f368dcd75b2ef03a946" translate="yes" xml:space="preserve">
          <source>Convert a string representing an unsigned decimal number to an object representing the same number. The input is normalized, i.e., it matches &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt;.</source>
          <target state="translated">부호없는 10 진수를 나타내는 문자열을 동일한 숫자를 나타내는 개체로 변환합니다. 입력은 정규화됩니다. 즉, &lt;code&gt;^(0|[1-9]\d*)$&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="1c765e62f3e179084fe5d84bf0b2c3905b911ee2" translate="yes" xml:space="preserve">
          <source>Convert all keys to lowercase</source>
          <target state="translated">모든 키를 소문자로 변환</target>
        </trans-unit>
        <trans-unit id="7fc597b2a41ac67e1656734e7eb3b3a11b24ebbf" translate="yes" xml:space="preserve">
          <source>Convert between VMS and Unix file specification syntax</source>
          <target state="translated">VMS와 Unix 파일 사양 구문 간 변환</target>
        </trans-unit>
        <trans-unit id="22551a6fa56e0b088f54f393df223d0617c9d7fd" translate="yes" xml:space="preserve">
          <source>Convert date and time information to string. Returns the string.</source>
          <target state="translated">날짜 및 시간 정보를 문자열로 변환하십시오. 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9dcc937b46bf0f95b02e92f32e357340020b79bb" translate="yes" xml:space="preserve">
          <source>Convert date/time info to a calendar time.</source>
          <target state="translated">날짜 / 시간 정보를 달력 시간으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="e522d506e48a2d1d98238f2e795a0c3fd876e384" translate="yes" xml:space="preserve">
          <source>Convert facet data to the legacy event API.</source>
          <target state="translated">패싯 데이터를 레거시 이벤트 API로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c755a3bc45c556fa5a645d889408aa48ca046b43" translate="yes" xml:space="preserve">
          <source>Convert several Pod files to several HTML files</source>
          <target state="translated">여러 포드 파일을 여러 HTML 파일로 변환</target>
        </trans-unit>
        <trans-unit id="171503852ba30aee7fafcbec8ff0ffe88983bb02" translate="yes" xml:space="preserve">
          <source>Convert the extension spec to Unix format, as that's what will match what's in the XSBUILD data structure.</source>
          <target state="translated">XSBUILD 데이터 구조의 내용과 일치하는 확장 사양을 Unix 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e36fcb46538b5f65c12d8c2a4fdc9c5ba89e1e4c" translate="yes" xml:space="preserve">
          <source>Convert the items to a normalised form. For 8 bit and Unicode values converts the item to an array of 1 or 2 items, both 8 bit and UTF-8 encoded.</source>
          <target state="translated">항목을 정규화 된 양식으로 변환하십시오. 8 비트 및 유니 코드 값의 경우 항목을 8 비트 및 UTF-8로 인코딩 된 1 또는 2 개의 항목 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6a89fde6d6a92b19247264815bcda3f0b2c24bd4" translate="yes" xml:space="preserve">
          <source>Converters</source>
          <target state="translated">Converters</target>
        </trans-unit>
        <trans-unit id="e602181f27c8b76305cde3933fa7a93bda7e1d5f" translate="yes" xml:space="preserve">
          <source>Converting a text string into an alternate but equivalent &lt;b&gt;canonical&lt;/b&gt; (or compatible) representation that can then be compared for equivalence. Unicode recognizes four different normalization forms: NFD, NFC, NFKD, and NFKC.</source>
          <target state="translated">텍스트 문자열을 대체하지만 동등한 &lt;b&gt;표준&lt;/b&gt; (또는 호환 가능한) 표현 으로 변환 한 후 동등성을 비교할 수 있습니다. 유니 코드는 NFD, NFC, NFKD 및 NFKC의 네 가지 정규화 형식을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a905d8ec528f352ed045a0e47323b3f945f63fbc" translate="yes" xml:space="preserve">
          <source>Converting data from one type to another. C permits this. Perl does not need it. Nor want it.</source>
          <target state="translated">한 유형에서 다른 유형으로 데이터 변환 C는 이것을 허용합니다. 펄은 필요하지 않습니다. 그것을 원하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff10e616cf0cab260f69d9d71be4dea1b4105184" translate="yes" xml:space="preserve">
          <source>Converting neutral double quotes to properly matched double quotes doesn't work unless there are no formatting codes between the quote marks. This only matters for troff output.</source>
          <target state="translated">따옴표 사이에 서식 코드가 없으면 중립 큰 따옴표를 올바르게 일치하는 큰 따옴표로 변환 할 수 없습니다. 이것은 troff 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="39ed30f1fb153d42aedc1603d4595d899a1c4eb9" translate="yes" xml:space="preserve">
          <source>Converting these two bytes to a string can be done with the unpack template &lt;code&gt;'b16'&lt;/code&gt; . To obtain the individual bit values from the bit string we use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; with the &quot;empty&quot; separator pattern which dissects into individual characters. Bit values from the &quot;reserved&quot; positions are simply assigned to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, a convenient notation for &quot;I don't care where this goes&quot;.</source>
          <target state="translated">압축 해제 템플릿 &lt;code&gt;'b16'&lt;/code&gt; 으로이 두 바이트를 문자열로 변환 할 수 있습니다 . 비트 문자열에서 개별 비트 값을 얻기 위해 개별 문자로 분리되는 &quot;빈&quot;구분 기호 패턴으로 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 을 사용 합니다. &quot;예약 된&quot;위치의 비트 값은 단순히 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 에 할당되며 , &quot;이것은 어디로 가는지 상관하지 않습니다&quot;라는 편리한 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="72d154b34078a0889654e3794469a6700e302e61" translate="yes" xml:space="preserve">
          <source>Converting these two bytes to a string can be done with the unpack template &lt;code&gt;'b16'&lt;/code&gt;. To obtain the individual bit values from the bit string we use &lt;code&gt;split&lt;/code&gt; with the &quot;empty&quot; separator pattern which dissects into individual characters. Bit values from the &quot;reserved&quot; positions are simply assigned to &lt;code&gt;undef&lt;/code&gt;, a convenient notation for &quot;I don't care where this goes&quot;.</source>
          <target state="translated">이 두 바이트를 문자열로 변환하는 것은 unpack 템플릿 &lt;code&gt;'b16'&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 . 비트 문자열에서 개별 비트 값을 얻으려면 개별 문자로 &lt;code&gt;split&lt;/code&gt; 되는 &quot;빈&quot;구분 기호 패턴으로 split 을 사용 합니다. &quot;reserved&quot;위치의 비트 값은 단순히 &quot;I do n't care this going&quot;에 대한 편리한 표기법 인 &lt;code&gt;undef&lt;/code&gt; 에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="872d9a7e434a3f8eac01f8a956be9ef98e1065ef" translate="yes" xml:space="preserve">
          <source>Converts</source>
          <target state="translated">Converts</target>
        </trans-unit>
        <trans-unit id="5c36855597a8c8dc72b5ec20242adc0af9679eb7" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;o&lt;/code&gt; into a list op if it is not one already, and then converts it into the specified &lt;code&gt;type&lt;/code&gt;, calling its check function, allocating a target if it needs one, and folding constants.</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; 가 아직 하나가 아닌 경우 o 를 목록 연산으로 변환 한 다음 지정된 &lt;code&gt;type&lt;/code&gt; 으로 변환 하여 check 함수를 호출하고 필요한 경우 대상을 할당하고 상수를 접습니다.</target>
        </trans-unit>
        <trans-unit id="6dd0269cc1fa76def89057e375d8613122d1590d" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;offset&lt;/code&gt; from a count of bytes from the start of the string, to a count of the equivalent number of UTF-8 chars. Handles type coercion. &lt;code&gt;flags&lt;/code&gt; is passed to &lt;code&gt;SvPV_flags&lt;/code&gt;, and usually should be &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; to handle magic.</source>
          <target state="translated">문자열 시작 부분의 바이트 수에서 해당하는 UTF-8 문자 수로 &lt;code&gt;offset&lt;/code&gt; 을 변환 합니다. 유형 강제를 처리합니다. &lt;code&gt;flags&lt;/code&gt; 는 &lt;code&gt;SvPV_flags&lt;/code&gt; 로 전달 되며 일반적으로 마법을 처리하려면 &lt;code&gt;SV_GMAGIC|SV_CONST_RETURN&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b0ff19255621f0cc44bdfb4998d413782b614b" translate="yes" xml:space="preserve">
          <source>Converts DOS and OS/2 linefeeds to Unix style recursively.</source>
          <target state="translated">DOS 및 OS / 2 줄 바꿈을 유닉스 스타일로 재귀 적으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="10562257cdade00a6b21d5534b7a854fb31311ef" translate="yes" xml:space="preserve">
          <source>Converts Perl XS code into C code</source>
          <target state="translated">Perl XS 코드를 C 코드로 변환</target>
        </trans-unit>
        <trans-unit id="c6aec2e8d6e3dde3cdaef9aaca3d6a0ac47f9491" translate="yes" xml:space="preserve">
          <source>Converts a directory specification to a path - that is, a string you can prepend to a file name to form a valid file specification. If the input file specification uses VMS syntax, the returned path does, too; likewise for Unix syntax (Unix paths are guaranteed to end with '/'). Note that this routine will insist that the input be a legal directory file specification; the file type and version, if specified, must be</source>
          <target state="translated">디렉토리 사양을 경로로 변환합니다. 즉, 파일 이름 앞에 추가하여 유효한 파일 사양을 구성 할 수있는 문자열입니다. 입력 파일 사양이 VMS 구문을 사용하는 경우 반환 된 경로도 사용됩니다. Unix 구문의 경우도 마찬가지입니다 (Unix 경로는 '/'로 끝나는 것이 보장됩니다). 이 루틴은 입력이 올바른 디렉토리 파일 사양임을 주장합니다. 파일 유형 및 버전 (지정된 경우)은</target>
        </trans-unit>
        <trans-unit id="558ea7461cd4a0f2be5157a676fa69c25752c358" translate="yes" xml:space="preserve">
          <source>Converts a directory specification to the file specification of the directory file - that is, a string you can pass to functions like &lt;code&gt;stat&lt;/code&gt; or &lt;code&gt;rmdir&lt;/code&gt; to manipulate the directory file. If the input directory specification uses VMS syntax, the returned file specification does, too; likewise for Unix syntax. As with &lt;code&gt;pathify&lt;/code&gt;, the input file specification must have a type and version of</source>
          <target state="translated">디렉토리 사양을 디렉토리 파일의 파일 사양으로 변환합니다. 즉, 디렉토리 파일 을 조작하기 위해 &lt;code&gt;stat&lt;/code&gt; 또는 &lt;code&gt;rmdir&lt;/code&gt; 과 같은 함수에 전달할 수있는 문자열 입니다. 입력 디렉토리 사양이 VMS 구문을 사용하는 경우 반환 된 파일 사양도 사용됩니다. Unix 구문도 마찬가지입니다. 와 마찬가지로 &lt;code&gt;pathify&lt;/code&gt; , 입력 파일 사양의 종류와 버전이 있어야합니다</target>
        </trans-unit>
        <trans-unit id="452c70cc155c20a233480d1511b68943f8b413fb" translate="yes" xml:space="preserve">
          <source>Converts a file specification to Unix syntax. If the file specification cannot be converted to or is already in Unix syntax, it will be passed through unchanged.</source>
          <target state="translated">파일 사양을 Unix 구문으로 변환합니다. 파일 사양을 변환 할 수 없거나 이미 Unix 구문에있는 경우 변경되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4027cb655c1703d55c619c00d83f700ca53fe105" translate="yes" xml:space="preserve">
          <source>Converts a file specification to VMS syntax. If the file specification cannot be converted to or is already in VMS syntax, it will be passed through unchanged.</source>
          <target state="translated">파일 사양을 VMS 구문으로 변환합니다. 파일 사양을 변환 할 수 없거나 이미 VMS 구문에있는 경우 변경되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4c118ffecc90a457e623e35d47e06d75541310" translate="yes" xml:space="preserve">
          <source>Converts a list into a string wrapped at approximately 80 columns.</source>
          <target state="translated">목록을 약 80 개의 열로 감싼 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="68b9e6f5ba88d84e905a481b6520ce3880c387ca" translate="yes" xml:space="preserve">
          <source>Converts a pod section specification to a suitable section specification for HTML. Note that we keep spaces and special characters except &lt;code&gt;&quot;, ?&lt;/code&gt; (Netscape problem) and the hyphen (writer's problem...).</source>
          <target state="translated">포드 섹션 사양을 HTML에 적합한 섹션 사양으로 변환합니다. &lt;code&gt;&quot;, ?&lt;/code&gt; (Netscape problem) 및 하이픈 (writer 's problem ...)을 제외한 공백과 특수 문자를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="61727984fc889133103a87d7dafaafbc6948ea75" translate="yes" xml:space="preserve">
          <source>Converts a potentially UTF-8 encoded string &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;*lenp&lt;/code&gt; into native byte encoding. On input, the boolean &lt;code&gt;*is_utf8p&lt;/code&gt; gives whether or not &lt;code&gt;s&lt;/code&gt; is actually encoded in UTF-8.</source>
          <target state="translated">길이가 &lt;code&gt;*lenp&lt;/code&gt; 인 잠재적으로 UTF-8로 인코딩 된 문자열 &lt;code&gt;s&lt;/code&gt; 를 기본 바이트 인코딩으로 변환합니다. 입력시 부울 &lt;code&gt;*is_utf8p&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 가 실제로 UTF-8로 인코딩 되었는지 여부를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="49497595bfccaed317aa3b3b73a4144bb41b64d6" translate="yes" xml:space="preserve">
          <source>Converts a relative path to an absolute path.</source>
          <target state="translated">상대 경로를 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9d892d6020931849ea5043d615d0a40eee45b982" translate="yes" xml:space="preserve">
          <source>Converts a relative path to an absolute path:</source>
          <target state="translated">상대 경로를 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0264f8db205b64be8b68b16c988d512cf7fba8e5" translate="yes" xml:space="preserve">
          <source>Converts a scalar into a typeglob. This is an incoercible typeglob; assigning a reference to it will assign to one of its slots, instead of overwriting it as happens with typeglobs created by &lt;code&gt;SvSetSV&lt;/code&gt;. Converting any scalar that is &lt;code&gt;SvOK()&lt;/code&gt; may produce unpredictable results and is reserved for perl's internal use.</source>
          <target state="translated">스칼라를 typeglob으로 변환합니다. 이것은 강제 할 수없는 typeglob입니다. 참조를 할당하면 &lt;code&gt;SvSetSV&lt;/code&gt; 에 의해 생성 된 typeglob에서 발생하는 것처럼 덮어 쓰는 대신 슬롯 중 하나에 할당됩니다 . &lt;code&gt;SvOK()&lt;/code&gt; 스칼라를 변환하면 예측할 수없는 결과가 발생할 수 있으며 perl의 내부 사용을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b5dd91e7acb7cb912818ec494442452642d20c" translate="yes" xml:space="preserve">
          <source>Converts a scalar into a typeglob. This is an incoercible typeglob; assigning a reference to it will assign to one of its slots, instead of overwriting it as happens with typeglobs created by SvSetSV. Converting any scalar that is SvOK() may produce unpredictable results and is reserved for perl's internal use.</source>
          <target state="translated">스칼라를 타입 글로브로 변환합니다. 이것은 강압 형 글로브입니다. 참조를 할당하면 SvSetSV에서 생성 한 typeglob에서 발생하는 것처럼 덮어 쓰지 않고 슬롯 중 하나에 할당됩니다. SvOK () 인 스칼라를 변환하면 예측할 수없는 결과가 생성 될 수 있으며 perl의 내부 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf47bd965a32350de298ea4a1bd9d84f13c4c78" translate="yes" xml:space="preserve">
          <source>Converts a sorting key into its representation form. If &lt;code&gt;UCA_Version&lt;/code&gt; is 8, the output is slightly different.</source>
          <target state="translated">정렬 키를 표현 형식으로 변환합니다. 경우 &lt;code&gt;UCA_Version&lt;/code&gt; 는 8, 출력은 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ae92416a20e2c4ece1763712a7e4eaf9758f2df4" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&quot;s&quot;&lt;/code&gt; of length &lt;code&gt;*lenp&lt;/code&gt; from UTF-8 into native byte encoding. Unlike &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt;, this over-writes the original string, and updates &lt;code&gt;*lenp&lt;/code&gt; to contain the new length. Returns zero on failure (leaving &lt;code&gt;&quot;s&quot;&lt;/code&gt; unchanged) setting &lt;code&gt;*lenp&lt;/code&gt; to -1.</source>
          <target state="translated">길이가 &lt;code&gt;*lenp&lt;/code&gt; 인 문자열 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 를 UTF-8에서 원시 바이트 인코딩으로 변환합니다. &lt;a href=&quot;#bytes_to_utf8&quot;&gt;&quot;bytes_to_utf8&quot;&lt;/a&gt; 과 달리 이것은 원래 문자열을 덮어 쓰고 새 길이를 포함하도록 &lt;code&gt;*lenp&lt;/code&gt; 를 업데이트합니다 . &lt;code&gt;*lenp&lt;/code&gt; 를 -1로 설정 하여 실패하면 0을 반환합니다 ( &lt;code&gt;&quot;s&quot;&lt;/code&gt; 를 변경하지 않고 그대로 둡니다 ) .</target>
        </trans-unit>
        <trans-unit id="e09251ed3a676eb23e02a6f2269b32e4facc6e9a" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; bytes from the native encoding into UTF-8. Returns a pointer to the newly-created string, and sets &lt;code&gt;len&lt;/code&gt; to reflect the new length in bytes.</source>
          <target state="translated">변환 된 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; UTF-8로 기본 인코딩 바이트. 새로 만든 문자열에 대한 포인터를 반환하고 &lt;code&gt;len&lt;/code&gt; 을 설정 하여 새 길이를 바이트 단위로 반영합니다.</target>
        </trans-unit>
        <trans-unit id="25e23f0e18e40bbf0fb5c8f36fb8ccc5209e18d9" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; from UTF-8 into native byte encoding. Unlike &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt;, this over-writes the original string, and updates &lt;code&gt;len&lt;/code&gt; to contain the new length. Returns zero on failure, setting &lt;code&gt;len&lt;/code&gt; to -1.</source>
          <target state="translated">변환 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; 네이티브 바이트 인코딩으로 UTF-8로. &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt; 과 달리 원래 문자열을 덮어 쓰고 &lt;code&gt;len&lt;/code&gt; 을 업데이트 하여 새 길이를 포함합니다. 실패시 0을 반환하고 &lt;code&gt;len&lt;/code&gt; 을 -1로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="c9aaa9139532e77f8d3100c51e3d0b848d4c571b" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; of length &lt;code&gt;len&lt;/code&gt; from UTF-8 into native byte encoding. Unlike &lt;a href=&quot;#utf8_to_bytes&quot;&gt;utf8_to_bytes&lt;/a&gt; but like &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt;, returns a pointer to the newly-created string, and updates &lt;code&gt;len&lt;/code&gt; to contain the new length. Returns the original string if no conversion occurs, &lt;code&gt;len&lt;/code&gt; is unchanged. Do nothing if &lt;code&gt;is_utf8&lt;/code&gt; points to 0. Sets &lt;code&gt;is_utf8&lt;/code&gt; to 0 if &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is converted or consisted entirely of characters that are invariant in utf8 (i.e., US-ASCII on non-EBCDIC machines).</source>
          <target state="translated">변환 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 길이 &lt;code&gt;len&lt;/code&gt; 네이티브 바이트 인코딩으로 UTF-8로. 달리 &lt;a href=&quot;#utf8_to_bytes&quot;&gt;utf8_to_bytes&lt;/a&gt; 하지만 같은 &lt;a href=&quot;#bytes_to_utf8&quot;&gt;bytes_to_utf8&lt;/a&gt; , 새로 만든 문자열에 대한 포인터를 반환하고 업데이트 &lt;code&gt;len&lt;/code&gt; 새 길이를 포함 할 수 있습니다. 변환이 발생하지 않으면 원래 문자열을 반환하고 &lt;code&gt;len&lt;/code&gt; 은 변경되지 않습니다. 경우 아무것도하지 &lt;code&gt;is_utf8&lt;/code&gt; 0으로 세트 포인트 &lt;code&gt;is_utf8&lt;/code&gt; 경우 0 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 변환 또는 완전히 UTF8에서 일정 문자로 구성되어있다 (즉, US-ASCII가 아닌 EBCDIC 기계에).</target>
        </trans-unit>
        <trans-unit id="d63b1bd54baaa2c8d55a3c40041428bd6ca3813a" translate="yes" xml:space="preserve">
          <source>Converts a string &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;*lenp&lt;/code&gt; bytes from the native encoding into UTF-8. Returns a pointer to the newly-created string, and sets &lt;code&gt;*lenp&lt;/code&gt; to reflect the new length in bytes. The caller is responsible for arranging for the memory used by this string to get freed.</source>
          <target state="translated">길이가 &lt;code&gt;*lenp&lt;/code&gt; 바이트 인 문자열 &lt;code&gt;s&lt;/code&gt; 를 기본 인코딩에서 UTF-8로 변환합니다. 새로 생성 된 문자열에 대한 포인터를 반환 하고 새 길이를 바이트 단위로 반영하도록 &lt;code&gt;*lenp&lt;/code&gt; 를 설정 합니다. 호출자는 해제하기 위해이 문자열이 사용하는 메모리를 정렬 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="adb460088c64e83557a5a8d851fa7e02c2237e5d" translate="yes" xml:space="preserve">
          <source>Converts a string into something presentable, handling escaping via &lt;code&gt;pv_escape()&lt;/code&gt; and supporting quoting and ellipses.</source>
          <target state="translated">문자열을 표현 가능한 것으로 변환하고 &lt;code&gt;pv_escape()&lt;/code&gt; 를 통해 이스케이프 처리를 처리 하고 따옴표와 줄임표를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="57ad9fed6045b19b9f737301c45af3031d5885f4" translate="yes" xml:space="preserve">
          <source>Converts a string into something presentable, handling escaping via pv_escape() and supporting quoting and ellipses.</source>
          <target state="translated">pv_escape ()를 통한 이스케이프 처리 및 인용 부호와 생략 부호를 지원하여 문자열을 표현 가능한 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0db98a90de6606abe2910c149662ac0a222aecca" translate="yes" xml:space="preserve">
          <source>Converts a string of file attribute letters into an unsigned value with the corresponding bits set. &lt;code&gt;$sAttributeLetters&lt;/code&gt; should contain zero or more letters from &lt;code&gt;&quot;achorst&quot;&lt;/code&gt;:</source>
          <target state="translated">파일 속성 문자의 문자열을 해당 비트가 설정된 부호없는 값으로 변환합니다. &lt;code&gt;$sAttributeLetters&lt;/code&gt; 에는 &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; 의 문자가 0 개 이상 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="985fbcc4acdc3a7d9cb06fa3db4de16008517d11" translate="yes" xml:space="preserve">
          <source>Converts a time as returned by the time function to a 9-element list with the time analyzed for the local time zone. Typically used as follows:</source>
          <target state="translated">시간 함수에 의해 반환 된 시간을 현지 시간대에 대해 분석 된 시간이있는 9 요소 목록으로 변환합니다. 일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df456bac0ead4ef5d6822c04fb63b24887c0fcbb" translate="yes" xml:space="preserve">
          <source>Converts die(...) to croak(...)</source>
          <target state="translated">die (...)를 croak (...)로 변환</target>
        </trans-unit>
        <trans-unit id="ab7d6db5ad0a6af07725954c367981536f9b78b6" translate="yes" xml:space="preserve">
          <source>Converts files from pod format (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) to HTML format. It can automatically generate indexes and cross-references, and it keeps a cache of things it knows how to cross-reference.</source>
          <target state="translated">파일을 포드 형식 ( &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )에서 HTML 형식 으로 변환합니다 . 인덱스와 상호 참조를 자동으로 생성 할 수 있으며 상호 참조 방법을 알고있는 것들의 캐시를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0d36251afb146d0c47c8632d04ba280e7678c879" translate="yes" xml:space="preserve">
          <source>Converts files from pod format (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) to HTML format.</source>
          <target state="translated">파일을 포드 형식 ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )에서 HTML 형식 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dfd74c889d6e099e89654c47c5263e1449534293" translate="yes" xml:space="preserve">
          <source>Converts files from pod format (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) to HTML format. It can automatically generate indexes and cross-references, and it keeps a cache of things it knows how to cross-reference.</source>
          <target state="translated">pod 형식 ( &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; 참조 )에서 HTML 형식 으로 파일을 변환합니다 . 색인과 상호 참조를 자동으로 생성 할 수 있으며 상호 참조하는 방법을 알고있는 항목의 캐시를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="c4c3911f04371bd3f5a9edcc045060266cb007b3" translate="yes" xml:space="preserve">
          <source>Converts in-place the character sequence to the corresponding octet sequence in</source>
          <target state="translated">현재 위치에서 문자 시퀀스를 해당 옥텟 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1f8d941153ff67ac1c72faf751cbeb55c8bc3ffd" translate="yes" xml:space="preserve">
          <source>Converts in-place the internal representation of the string from</source>
          <target state="translated">내부에서 문자열의 내부 표현을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d8b721335ac74a399b53a4c7b83d6d6e77dad793" translate="yes" xml:space="preserve">
          <source>Converts in-place the internal representation of the string from an octet sequence in the native encoding (Latin-1 or EBCDIC) to</source>
          <target state="translated">네이티브 인코딩 (Latin-1 또는 EBCDIC)의 옥텟 시퀀스에서 문자열의 내부 표현을 제자리로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="693d5393f2c198b06d62ba43ecdf4f6431cd33c1" translate="yes" xml:space="preserve">
          <source>Converts package specifiers from ' to ::</source>
          <target state="translated">패키지 지정자를 '에서 ::로 변환</target>
        </trans-unit>
        <trans-unit id="75d0a666542f6f624e396b88276d95cb7e5e33ef" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to UTF-8, but then turns the &lt;code&gt;SvUTF8&lt;/code&gt; flag off so that it looks like octets again.</source>
          <target state="translated">SV의 PV를 UTF-8로 변환 한 다음 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 끄고 다시 옥텟처럼 보이게합니다.</target>
        </trans-unit>
        <trans-unit id="8e31e6f885da29a23f47b2b49d056556f7053dad" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to string form if it is not already. Always sets the SvUTF8 flag to avoid future validity checks even if all the bytes are invariant in UTF-8. If &lt;code&gt;flags&lt;/code&gt; has &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate, else not.</source>
          <target state="translated">SV의 PV를 UTF-8 인코딩 형식으로 변환합니다. SV가 문자열 형식이 아닌 경우이를 강제로 문자열로 만듭니다. 모든 바이트가 UTF-8에서 변하지 않더라도 향후 유효성 검사를 피하기 위해 항상 SvUTF8 플래그를 설정합니다. 경우 &lt;code&gt;flags&lt;/code&gt; 가 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 의 비트 세트를합니다 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당하는 경우, 다른 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b78ec6a6d5c3e3e13ee70410dac93444fc75b30" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to string form if it is not already. Will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate. Always sets the &lt;code&gt;SvUTF8&lt;/code&gt; flag to avoid future validity checks even if the whole string is the same in UTF-8 as not. Returns the number of bytes in the converted string</source>
          <target state="translated">SV의 PV를 UTF-8 인코딩 형식으로 변환합니다. 아직없는 경우 SV를 문자열 형식으로 지정합니다. 윌 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당되는 경우. 전체 문자열이 UTF-8에서 동일하지 않더라도 향후 유효성 검사를 피하기 위해 항상 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 설정합니다 . 변환 된 문자열의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2eaeedbacb6754f3bf67d2ff185622d62fb661fa" translate="yes" xml:space="preserve">
          <source>Converts the PV of an SV to its UTF-8-encoded form. Forces the SV to string form if it is not already. Will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate. Always sets the SvUTF8 flag to avoid future validity checks even if the whole string is the same in UTF-8 as not. Returns the number of bytes in the converted string</source>
          <target state="translated">SV의 PV를 UTF-8 인코딩 형식으로 변환합니다. SV가 문자열 형식이 아닌 경우이를 강제로 문자열로 만듭니다. 윌 &lt;code&gt;mg_get&lt;/code&gt; 에 &lt;code&gt;sv&lt;/code&gt; 해당되는 경우. 전체 문자열이 UTF-8에서 동일하지 않더라도 향후 유효성 검사를 피하도록 항상 SvUTF8 플래그를 설정하십시오. 변환 된 문자열의 바이트 수를 반환합니다</target>
        </trans-unit>
        <trans-unit id="d858a4518b8e2b0edbb72d67957101032b8b2eb8" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 foldcase 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 접는 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="52e572e9590b1d15237c9891ad99225648f02174" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 소문자 버전으로 변환하고 UTF-8로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 소문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1a058c8fc2f6f2b47b13e70622269534e295cc45" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its titlecase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the titlecase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 제목 케이스 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 타이틀 케이스 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="fe4a9e2cd918385161f10e124e4741e692641e86" translate="yes" xml:space="preserve">
          <source>Converts the UTF-8 encoded character at &lt;code&gt;p&lt;/code&gt; to its uppercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the uppercase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 UTF-8로 인코딩 된 문자를 대문자 버전으로 변환하고 UTF-8 로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 로 , 길이를 바이트로 &lt;code&gt;lenp&lt;/code&gt; 로 저장 합니다. 대문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c3a3eb4c108a356b7fa84675b8535c22195fbd62" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 foldcase 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 접는 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d979a580aaef23727c36debd38227c49408a9b47" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 소문자 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 소문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="26f7f9dab73dba77fbe7d1b19eddf8f73d1b5671" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its titlecase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the titlecase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 제목 케이스 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트 단위로 저장 합니다. 타이틀 케이스 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="45a23ff030e1856fb80fa2a5c1977970b50af607" translate="yes" xml:space="preserve">
          <source>Converts the Unicode code point &lt;code&gt;cp&lt;/code&gt; to its uppercase version, and stores that in UTF-8 in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt; . Note that the buffer pointed to by &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the uppercase version may be longer than the original character.</source>
          <target state="translated">유니 코드 코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 대문자 버전으로 변환하고 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 에 UTF-8로 , 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 대문자 버전이 원래 문자보다 길 수 있으므로 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 가 가리키는 버퍼는 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="f8097462e85183f3c9faef5d4fec919ea319a39c" translate="yes" xml:space="preserve">
          <source>Converts the code point &lt;code&gt;cp&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. The code point is interpreted as native if less than 256; otherwise as Unicode. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 foldcase 버전으로 변환하고이를 UTF-8로 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트 단위로 저장 합니다. 코드 포인트는 256보다 작 으면 네이티브로 해석됩니다. 그렇지 않으면 유니 코드로. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼 는 foldcase 버전이 원래 문자보다 길 수 있기 때문에 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="98c279219ed2c9c77a4fae80805c92f142a82c9e" translate="yes" xml:space="preserve">
          <source>Converts the code point &lt;code&gt;cp&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. The code point is interpreted as native if less than 256; otherwise as Unicode. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 소문자 버전으로 변환하고이를 UTF-8로 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트 단위로 저장 합니다. 코드 포인트는 256보다 작 으면 네이티브로 해석됩니다. 그렇지 않으면 유니 코드로. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼 는 소문자 버전이 원래 문자보다 길 수 있으므로 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3850a49df670b959fd8174aa8194fed81fdb3b4c" translate="yes" xml:space="preserve">
          <source>Converts the code point &lt;code&gt;cp&lt;/code&gt; to its titlecase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. The code point is interpreted as native if less than 256; otherwise as Unicode. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the titlecase version may be longer than the original character.</source>
          <target state="translated">코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 타이틀 케이스 버전으로 변환하고 UTF-8로 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. 코드 포인트는 256보다 작 으면 네이티브로 해석됩니다. 그렇지 않으면 유니 코드로. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼는 최소 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다. 타이틀 케이스 버전이 원래 문자보다 길 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8c66579aeff1d471f0c33592b1adf5992873aea8" translate="yes" xml:space="preserve">
          <source>Converts the code point &lt;code&gt;cp&lt;/code&gt; to its uppercase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. The code point is interpreted as native if less than 256; otherwise as Unicode. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the uppercase version may be longer than the original character.</source>
          <target state="translated">코드 포인트 &lt;code&gt;cp&lt;/code&gt; 를 대문자 버전으로 변환하고이를 UTF-8로 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트 단위로 저장 합니다. 코드 포인트는 256보다 작 으면 네이티브로 해석됩니다. 그렇지 않으면 유니 코드로. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼 는 대문자 버전이 원래 문자보다 길 수 있으므로 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c3d6ca1c2f0c8dcb86d38412b232b00c790cee63" translate="yes" xml:space="preserve">
          <source>Converts the distdir into a shell archive.</source>
          <target state="translated">distdir을 쉘 아카이브로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e0af1756ce1d87737fd5451d001ec50660202c47" translate="yes" xml:space="preserve">
          <source>Converts the first UTF-8 encoded character in the sequence starting at &lt;code&gt;p&lt;/code&gt; and extending no further than &lt;code&gt;e - 1&lt;/code&gt; to its foldcase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the foldcase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 시작하여 &lt;code&gt;e - 1&lt;/code&gt; 이하로 확장되는 시퀀스의 첫 번째 UTF-8 인코딩 문자를 foldcase 버전으로 변환하고이를 UTF-8에 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼는 최소 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다. foldcase 버전은 원래 문자보다 길 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f99daf2bc15fda2ed7b2a7e9b9f4caeeb417a72f" translate="yes" xml:space="preserve">
          <source>Converts the first UTF-8 encoded character in the sequence starting at &lt;code&gt;p&lt;/code&gt; and extending no further than &lt;code&gt;e - 1&lt;/code&gt; to its lowercase version, and stores that in UTF-8 in &lt;code&gt;s&lt;/code&gt;, and its length in bytes in &lt;code&gt;lenp&lt;/code&gt;. Note that the buffer pointed to by &lt;code&gt;s&lt;/code&gt; needs to be at least &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; bytes since the lowercase version may be longer than the original character.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에서 시작하여 &lt;code&gt;e - 1&lt;/code&gt; 이하로 확장되는 시퀀스의 첫 번째 UTF-8 인코딩 문자를 소문자 버전으로 변환하고이를 UTF-8에 &lt;code&gt;s&lt;/code&gt; 에 저장 하고 길이를 &lt;code&gt;lenp&lt;/code&gt; 에 바이트로 저장 합니다. &lt;code&gt;s&lt;/code&gt; 가 가리키는 버퍼 는 소문자 버전이 원래 문자보다 길 수 있으므로 최소한 &lt;code&gt;UTF8_MAXBYTES_CASE+1&lt;/code&gt; 바이트 여야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
