<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="20739558e894101738b809f5961ce2ec15d5ef69" translate="yes" xml:space="preserve">
          <source>) which itself uses a C or C++ library, this probably happened:</source>
          <target state="translated">) 자체는 C 또는 C ++ 라이브러리를 사용하며 아마도 이런 일이 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="555eb93c31c2ff33a5f28e75533e9b13d5846308" translate="yes" xml:space="preserve">
          <source>) will return true but not actually set the bit. (Android)</source>
          <target state="translated">)는 true를 반환하지만 실제로 비트를 설정하지는 않습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="76964257ee68bb8fca6aa80c00dd5fc9f2ec1a64" translate="yes" xml:space="preserve">
          <source>) with a character class, and no string shorter than 7 characters can possibly match.</source>
          <target state="translated">)로 구성되며 7 자보다 짧은 문자열은 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b62adc5f8c3abd2eb86b6b1533af991c7edca58" translate="yes" xml:space="preserve">
          <source>) would otherwise terminate the loop. Again, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned only once. So if you're expecting a single value from a glob, it is much better to say</source>
          <target state="translated">그렇지 않으면 루프를 종료합니다. 다시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 한 번만 리턴됩니다. 따라서 글로브에서 단일 값을 기대하는 경우 말하는 것이 훨씬 좋습니다</target>
        </trans-unit>
        <trans-unit id="4810b75ef754b672275a3af2b5a078e21220cbc9" translate="yes" xml:space="preserve">
          <source>) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="translated">) 여전히 &lt;code&gt;PUSHMARK&lt;/code&gt; 매크로를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd68868e123f57ff7ef38ff164a231d0c0a76fe0" translate="yes" xml:space="preserve">
          <source>) you want to rebuild.</source>
          <target state="translated">)를 다시 작성하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="02a91090e67572144de2f031f1bbc5cd3c4a2837" translate="yes" xml:space="preserve">
          <source>)&quot;). They may derive from the project class. They may derive from some other class altogether. Or via multiple inheritance, it may derive from any mixture of these.</source>
          <target state="translated">) &quot;). 프로젝트 클래스에서 파생 될 수 있습니다. 다른 클래스에서 모두 파생 될 수 있습니다. 또는 다중 상속을 통해 이러한 클래스를 혼합하여 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6747b651e587fe4f0093d11936c478b09099030" translate="yes" xml:space="preserve">
          <source>), &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;</source>
          <target state="translated">), &lt;a href=&quot;perlvms&quot;&gt;perlvms&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba220f5b6e6ddf875b36f2ab6036ca1e73f1dfa8" translate="yes" xml:space="preserve">
          <source>), a binary distribution, or a non-core module (such as Tk, DBI, etc), then please see the documentation that came with that distribution to determine the correct place to report bugs.</source>
          <target state="translated">), 이진 배포 또는 비 핵심 모듈 (예 : Tk, DBI 등) 인 경우 버그를보고 할 올바른 위치를 결정하려면 해당 배포와 함께 제공된 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7bbfc61f89bcf69b7d112e66034a33a974882ccb" translate="yes" xml:space="preserve">
          <source>), and into the Perl interpreter itself. Older versions of Perl contain bugs that may manifest themselves despite using the latest version of &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; from CPAN. There is no workaround for this other than upgrading to the latest version of Perl.</source>
          <target state="translated">) 및 Perl 통역사 자체로. 이전 버전의 Perl에는 CPAN 의 최신 버전의 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 를 사용하더라도 버그가 발생할 수 있습니다 . 최신 버전의 Perl로 업그레이드하는 것 외에는 이에 대한 해결 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a812a48223447ff4a00c61dec758c7f63fc7d624" translate="yes" xml:space="preserve">
          <source>), and the Korn shell (</source>
          <target state="translated">) 및 Korn 쉘 (</target>
        </trans-unit>
        <trans-unit id="5582722a931d80faec2c2604d236f55218c4801c" translate="yes" xml:space="preserve">
          <source>), but never achieved universal adoption. The &lt;a href=&quot;http://search.cpan.org/perldoc/Object::InsideOut&quot;&gt;Object::InsideOut&lt;/a&gt; module on CPAN provides a comprehensive implementation of this technique, and you may see it or other inside-out modules in the wild.</source>
          <target state="translated">), 보편적 인 채택을 달성 한 적이 없습니다. CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/Object::InsideOut&quot;&gt;Object :: InsideOut&lt;/a&gt; 모듈은이 기술의 포괄적 인 구현을 제공하며,이 모듈이나 다른 내부 출력 모듈을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be22299e2551650ec9efe8f43bc6cd3596bc5a87" translate="yes" xml:space="preserve">
          <source>), but the literal data is in the specified encoding.</source>
          <target state="translated">)이지만 리터럴 데이터는 지정된 인코딩에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13d6f5c889dfb868a65c83873de9aa4af2cc116" translate="yes" xml:space="preserve">
          <source>), especially many little-endians do the latter. This is only useful if you have select(), naturally.</source>
          <target state="translated">), 특히 많은 리틀 엔디 언이 후자를 수행합니다. 이것은 select ()가 자연스럽게있는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e07233c7cb7d125bda9afb2d089c66b7362165d" translate="yes" xml:space="preserve">
          <source>), or &lt;code&gt;`glob a*b`&lt;/code&gt; (internal for ksh)? You need to specify your shell explicitly, like &lt;code&gt;`cmd /c copy a b`&lt;/code&gt; , since Perl cannot deduce which commands are internal to your shell.</source>
          <target state="translated">) 또는 &lt;code&gt;`glob a*b`&lt;/code&gt; (ksh의 내부)? Perl이 쉘 내부의 명령을 추론 할 수 없기 때문에 &lt;code&gt;`cmd /c copy a b`&lt;/code&gt; 와 같이 명시 적으로 쉘을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0628cf3503bf4bbbc2ce5d535a543d4ded04903a" translate="yes" xml:space="preserve">
          <source>), or in configurable location (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">) 또는 구성 가능한 위치에 있습니다 ( &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2491f48be12de5636116c5c0fd0e291876db397a" translate="yes" xml:space="preserve">
          <source>), or libdlcompat to</source>
          <target state="translated">) 또는 libdlcompat to</target>
        </trans-unit>
        <trans-unit id="b76430f0a63614c0383c191e6bda6c8b60a93154" translate="yes" xml:space="preserve">
          <source>), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="translated">)가 인식되지 않아 속성이 잘못 출력되었습니다. 이 문제를 해결할 방법이 있더라도 비 인쇄 이스케이프 시퀀스의 길이가 0임을 알지 못하고 출력 형식을 잘못 지정합니다. 색상 또는 기타 속성을 사용하여 형식화 된 출력의 경우 대신 sprintf ()를 사용하거나 formline ()을 사용한 다음 형식화 후 및 출력 전에 색상 또는 기타 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="27d4e0b75aa9979af9c60f48e50541e1084c0f21" translate="yes" xml:space="preserve">
          <source>), the C shell (</source>
          <target state="translated">), C 쉘 (</target>
        </trans-unit>
        <trans-unit id="8921d13cc2e9b0e14e6863e00a16b9ef9534ecde" translate="yes" xml:space="preserve">
          <source>), the Unicode version of normalization implemented by this module depends on your perl's version.</source>
          <target state="translated">),이 모듈에 의해 구현 된 정규화의 유니 코드 버전은 perl의 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7847189040b71cd51c130c2436b0e22235a3d864" translate="yes" xml:space="preserve">
          <source>), the remainder of the text, and the skipped prefix (if any). If a suitable delimited substring is not found, the first element of the array is the empty string, the second is the complete original text, and the prefix returned in the third element is an empty string.</source>
          <target state="translated">), 나머지 텍스트 및 건너 뛴 접두사 (있는 경우) 적절한 구분 된 하위 문자열을 찾을 수 없으면 배열의 첫 번째 요소는 빈 문자열이고 두 번째는 완전한 원본 텍스트이며 세 번째 요소에 반환 된 접두사는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f615146b0c5326d45eb59116d40a716c8d44a5d9" translate="yes" xml:space="preserve">
          <source>), while the latter is useful if $prefix is shared by many packages, e.g. if $prefix=</source>
          <target state="translated">), 후자는 많은 패키지가 $ prefix를 공유하는 경우에 유용합니다 (예 : $ prefix =</target>
        </trans-unit>
        <trans-unit id="2ddb6d2a78b2c77758ab5631f959dfe309c8ee8b" translate="yes" xml:space="preserve">
          <source>). A few platforms need to be told the location of the dependent library explicitly. Use @dl_resolve_using for this.</source>
          <target state="translated">). 일부 플랫폼에는 종속 라이브러리의 위치를 ​​명시 적으로 알려 주어야합니다. @dl_resolve_using을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6e0d8f2fab340ca3e828a3d60cdc124f6a7963fd" translate="yes" xml:space="preserve">
          <source>). Almost all internally-used routines in</source>
          <target state="translated">). 내부적으로 사용되는 거의 모든 루틴</target>
        </trans-unit>
        <trans-unit id="2e3178a172620d14bf2d6fd49572a7f8b300111a" translate="yes" xml:space="preserve">
          <source>). And it is &lt;code&gt;F&lt;/code&gt; if there is only a</source>
          <target state="translated">). 그리고는 &lt;code&gt;F&lt;/code&gt; 는 만있는 경우</target>
        </trans-unit>
        <trans-unit id="191441749ef940028953be8e584c0530088683d7" translate="yes" xml:space="preserve">
          <source>). Anyhow, this module will neither refer to</source>
          <target state="translated">). 어쨌든이 모듈은</target>
        </trans-unit>
        <trans-unit id="740873c13ba23b24200aa2080c4fd9faa64f0e57" translate="yes" xml:space="preserve">
          <source>). If necessary, run just the failing scripts again sequentially and see if the failures go away.</source>
          <target state="translated">). 필요한 경우, 실패한 스크립트 만 순차적으로 다시 실행하고 실패가 사라지는 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fa6174028d9716fdac2ed031a49f5b83d140fe" translate="yes" xml:space="preserve">
          <source>). If this Perl code makes calls into this XS code, and/or this XS code makes calls to the Perl code, one should be careful with the order of initialization.</source>
          <target state="translated">). 이 Perl 코드가이 XS 코드를 호출하거나이 XS 코드가 Perl 코드를 호출하는 경우 초기화 순서에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d00d1fa6ee0d8fc40d4a6589099f366d00ea1908" translate="yes" xml:space="preserve">
          <source>). In this model, each thread runs in its own Perl interpreter, and any data sharing between threads must be explicit. The user-level interface for</source>
          <target state="translated">). 이 모델에서 각 스레드는 고유 한 Perl 인터프리터에서 실행되며 스레드 간 데이터 공유는 명시 적이어야합니다. 에 대한 사용자 수준의 인터페이스</target>
        </trans-unit>
        <trans-unit id="7d5472f1ffe12c98e459541b4ae02160b6a93b4f" translate="yes" xml:space="preserve">
          <source>). It is &lt;code&gt;S&lt;/code&gt; if there are distinct folds,</source>
          <target state="translated">). 그것은이다 &lt;code&gt;S&lt;/code&gt; 를 별개의 주름이있는 경우,</target>
        </trans-unit>
        <trans-unit id="05a6e878bb179497ab31f32f00f95fb3899c774b" translate="yes" xml:space="preserve">
          <source>). Perl is not strictly a shell because it&amp;rsquo;s not interactive (although Perl programs can be interactive).</source>
          <target state="translated">). Perl은 대화식이 아니기 때문에 셸이 아닙니다 (Perl 프로그램은 대화식 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="f78cffbbf89f8002aea6399c7a9ddf0dfac97229" translate="yes" xml:space="preserve">
          <source>). So long as</source>
          <target state="translated">). 한</target>
        </trans-unit>
        <trans-unit id="ea5a3d55458bd648431ff33d784b7d2a42d0fac1" translate="yes" xml:space="preserve">
          <source>). The following example computes the SHA-224 digest of the 7-bit message</source>
          <target state="translated">). 다음 예제는 7 비트 메시지의 SHA-224 다이제스트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f2791a078af14b6f53c92cc496607d9ac596dc19" translate="yes" xml:space="preserve">
          <source>). These are &lt;b&gt;not&lt;/b&gt; yet available with newlib, the Cygwin libc.</source>
          <target state="translated">). 이들은 &lt;b&gt;하지&lt;/b&gt; newlib에, Cygwin에서의 libc와 아직 사용할.</target>
        </trans-unit>
        <trans-unit id="560023602febe7a40239bc4208c087508750d63d" translate="yes" xml:space="preserve">
          <source>). These ordinals can be accessed via the APIs:</source>
          <target state="translated">). 이 서수는 API를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b347823ca9f713e85046a6075137cf021c306fdd" translate="yes" xml:space="preserve">
          <source>). This is best demonstrated with this code:</source>
          <target state="translated">). 이것은이 코드로 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d6564a7c3672bec1a1bc0e927d67a7df20f8a1" translate="yes" xml:space="preserve">
          <source>). This is done, as in the examples above, by having the two components separated by an equal sign (or interchangeably, a colon), like &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt; .</source>
          <target state="translated">). 이는 위의 예와 같이 &lt;code&gt;\p{Bidi_Class: Left}&lt;/code&gt; 와 같이 등호 (또는 상호 교환 적으로 콜론)로 두 구성 요소를 분리하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="705bf65f5f48be0531b7a87c6aca35d55ff144f4" translate="yes" xml:space="preserve">
          <source>). This means that even if you do not</source>
          <target state="translated">). 이것은 당신이하지 않더라도</target>
        </trans-unit>
        <trans-unit id="d67ecb26991744a9d2868c66788af481b16bc33d" translate="yes" xml:space="preserve">
          <source>). Those flags, and others, are discussed in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">). 이러한 플래그 및 기타 플래그는 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 에서 논의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aa020a5258af192f5be7bb87b11f10731cd4d0d" translate="yes" xml:space="preserve">
          <source>). You need the latest version of</source>
          <target state="translated">). 최신 버전이 필요합니다</target>
        </trans-unit>
        <trans-unit id="53971837c357909ccaf3a6ac8079d2f764d799a4" translate="yes" xml:space="preserve">
          <source>). cereg.exe (which must be executed on a desktop pc with ActiveSync) is reported not to work on some devices. You have to create the registry entries by hand using a registry editor.</source>
          <target state="translated">). cereg.exe (ActiveSync가 설치된 데스크탑 PC에서 실행해야 함)가 일부 장치에서 작동하지 않는 것으로보고되었습니다. 레지스트리 편집기를 사용하여 수동으로 레지스트리 항목을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e0ee17e99cbf2528fa040abfe91674006a4598e" translate="yes" xml:space="preserve">
          <source>); these were automatically generated by the installation process. You may also discover files in the library directory that end in either</source>
          <target state="translated">); 이들은 설치 과정에서 자동으로 생성되었습니다. 라이브러리 디렉토리에서 다음 중 하나로 끝나는 파일을 발견 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f1ab06aabff0dd04ec2e7fdd0330f3f72717ad" translate="yes" xml:space="preserve">
          <source>* $status = $i-&amp;gt;inflate($input, $output [,$eof]) *</source>
          <target state="translated">* $ status = $ i-&amp;gt; 인플레이션 ($ input, $ output [, $ eof]) *</target>
        </trans-unit>
        <trans-unit id="711683a62464c1b947fc95a05857522c610a2052" translate="yes" xml:space="preserve">
          <source>* ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) *</source>
          <target state="translated">* ($ i, $ status) = 새로운 Compress :: Raw :: Zlib :: Inflate ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="662154abd6b12506d6af987521bf74a19afd4fd0" translate="yes" xml:space="preserve">
          <source>* &lt;a href=&quot;langtags/list&quot;&gt;I18N::LangTags::List&lt;/a&gt;</source>
          <target state="translated">* &lt;a href=&quot;langtags/list&quot;&gt;I18N :: LangTags :: 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53698d1b06e8dd4ae73bc9c6c3f72d465836ed18" translate="yes" xml:space="preserve">
          <source>* Characters regarded as CJK unified ideographs (cf. &lt;code&gt;overrideCJK&lt;/code&gt; ) depend on &lt;code&gt;UCA_Version&lt;/code&gt; .</source>
          <target state="translated">* CJK 통합 표의 문자 ( &lt;code&gt;overrideCJK&lt;/code&gt; 참조 ) 로 간주되는 문자 는 &lt;code&gt;UCA_Version&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ff54b7fd765cf7407f178535811ac43fe11764ba" translate="yes" xml:space="preserve">
          <source>* Fully ignorable characters were ignored, and would not interrupt contractions with &lt;code&gt;UCA_Version&lt;/code&gt; 9 and 11.</source>
          <target state="translated">* 무시할 수없는 문자는 무시되었으며 &lt;code&gt;UCA_Version&lt;/code&gt; 9 및 11과의 축소를 방해하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c482699ba0d9eda15c09384bf56262c0a8ead969" translate="yes" xml:space="preserve">
          <source>* ISO 639-2, &quot;Codes for the representation of names of languages&quot;, including two-letter and three-letter codes, &lt;code&gt;&lt;a href=&quot;http://www.loc.gov/standards/iso639-2/php/code_list.php&quot;&gt;http://www.loc.gov/standards/iso639-2/php/code_list.php&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* ISO 639-2, 2 자리 및 3 자리 코드를 포함한 &quot;언어 이름 표현을위한 코드&quot;, &lt;code&gt;&lt;a href=&quot;http://www.loc.gov/standards/iso639-2/php/code_list.php&quot;&gt;http://www.loc.gov/standards/iso639-2/php/code_list.php&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c970a3c0abb4e4f41ee7e5d7374c3df2f2d33f28" translate="yes" xml:space="preserve">
          <source>* Locale::Codes, in &lt;code&gt;&lt;a href=&quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;&gt;http://www.perl.com/CPAN/modules/by-module/Locale/&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* 로캘 :: 코드, &lt;code&gt;&lt;a href=&quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;&gt;http://www.perl.com/CPAN/modules/by-module/Locale/&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a89954fdb3af5eae5e55d02be3ce39795c43b97" translate="yes" xml:space="preserve">
          <source>* Many hangul jamo are assigned at &lt;code&gt;UCA_Version&lt;/code&gt; 20, that will affect &lt;code&gt;hangul_terminator&lt;/code&gt; .</source>
          <target state="translated">* 많은 한글 &lt;code&gt;UCA_Version&lt;/code&gt; 20에 할당되어 hangul_terminator에 영향을 &lt;code&gt;hangul_terminator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7cdc6678b63f68f1f731cd796dc594743e79af" translate="yes" xml:space="preserve">
          <source>* Noncharacters (e.g. U+FFFF) are not ignored, and can be overridden since &lt;code&gt;UCA_Version&lt;/code&gt; 22.</source>
          <target state="translated">* 비 문자 (예 : U + FFFF)는 무시되지 않으며 &lt;code&gt;UCA_Version&lt;/code&gt; 22 이후로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1c01b3ace60123b87b3f718dd69b661047bea89" translate="yes" xml:space="preserve">
          <source>* Out-of-range codepoints (greater than U+10FFFF) are not ignored, and can be overridden since &lt;code&gt;UCA_Version&lt;/code&gt; 22.</source>
          <target state="translated">* 범위를 벗어난 코드 포인트 (U + 10FFFF보다 큼)는 무시되지 않으며 &lt;code&gt;UCA_Version&lt;/code&gt; 22 부터 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3acf57a3122fd8676139be1b54b77e7a6c0f4419" translate="yes" xml:space="preserve">
          <source>* RFC 2231, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2231.txt&quot;&gt;http://www.ietf.org/rfc/rfc2231.txt&lt;/a&gt;&lt;/code&gt;, &quot;MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations&quot;.</source>
          <target state="translated">* RFC 2231, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2231.txt&quot;&gt;http://www.ietf.org/rfc/rfc2231.txt&lt;/a&gt;&lt;/code&gt; , &quot;MIME 매개 변수 값 및 인코딩 된 단어 확장자 : 문자 세트, 언어 및 연속&quot;.</target>
        </trans-unit>
        <trans-unit id="7a7d7dbfc55209a71c5f7e824d67a357a6a16bbc" translate="yes" xml:space="preserve">
          <source>* RFC 2277, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2277.txt&quot;&gt;http://www.ietf.org/rfc/rfc2277.txt&lt;/a&gt;&lt;/code&gt;, &quot;IETF Policy on Character Sets and Languages&quot;.</source>
          <target state="translated">* RFC 2277, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2277.txt&quot;&gt;http://www.ietf.org/rfc/rfc2277.txt&lt;/a&gt;&lt;/code&gt; , &quot;문자 세트 및 언어에 대한 IETF 정책&quot;.</target>
        </trans-unit>
        <trans-unit id="9e8c6c9d9a4f36c517c3f295833e4f6eab416286" translate="yes" xml:space="preserve">
          <source>* RFC 2482, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2482.txt&quot;&gt;http://www.ietf.org/rfc/rfc2482.txt&lt;/a&gt;&lt;/code&gt;, &quot;Language Tagging in Unicode Plain Text&quot;.</source>
          <target state="translated">* RFC 2482, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2482.txt&quot;&gt;http://www.ietf.org/rfc/rfc2482.txt&lt;/a&gt;&lt;/code&gt; , &quot;유니 코드 일반 텍스트의 언어 태깅&quot;.</target>
        </trans-unit>
        <trans-unit id="a0423bc09cf4060b0b568dded73ce94844a1cdfb" translate="yes" xml:space="preserve">
          <source>* RFC 3066, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3066.txt&quot;&gt;http://www.ietf.org/rfc/rfc3066.txt&lt;/a&gt;&lt;/code&gt;, &quot;Tags for the Identification of Languages&quot;. (Obsoletes RFC 1766)</source>
          <target state="translated">* RFC 3066, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc3066.txt&quot;&gt;http://www.ietf.org/rfc/rfc3066.txt&lt;/a&gt;&lt;/code&gt; , &quot;언어 식별 태그&quot;. (RFC 1766 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0d995187844c913f0fc72fa490ae73510b255678" translate="yes" xml:space="preserve">
          <source>* See below &lt;code&gt;long_contraction&lt;/code&gt; with &lt;code&gt;UCA_Version&lt;/code&gt; 22 and 24.</source>
          <target state="translated">* &lt;code&gt;UCA_Version&lt;/code&gt; 22 및 24의 &lt;code&gt;long_contraction&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9659d778014dc9fe8cc992c94d2c75debd111108" translate="yes" xml:space="preserve">
          <source>* The IANA list of registered languages (hopefully up-to-date), &lt;code&gt;&lt;a href=&quot;http://www.iana.org/assignments/language-tags&quot;&gt;http://www.iana.org/assignments/language-tags&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">* 등록 된 언어의 IANA 목록 (최신 업데이트), &lt;code&gt;&lt;a href=&quot;http://www.iana.org/assignments/language-tags&quot;&gt;http://www.iana.org/assignments/language-tags&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc59265402b2bcf12a045f141f3c84d1ac00a64c" translate="yes" xml:space="preserve">
          <source>* There are two exceptions to a bracketed character class matching a single character only. Each requires special handling by Perl to make things work:</source>
          <target state="translated">* 단일 문자 만 일치하는 대괄호 문자 클래스에는 두 가지 예외가 있습니다. 각각은 작업을 수행하기 위해 Perl의 특별한 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="897931bec8a15698dae5c444e1fbf89e322d1e04" translate="yes" xml:space="preserve">
          <source>* Treatment of ignorables after variables and some behaviors were changed at &lt;code&gt;UCA_Version&lt;/code&gt; 9.</source>
          <target state="translated">* &lt;code&gt;UCA_Version&lt;/code&gt; 9 에서 변수 및 일부 동작이 변경된 후 무시할 수있는 처리</target>
        </trans-unit>
        <trans-unit id="eb19d00dbb35076b2cfb43afaaa8a44bc7567ca5" translate="yes" xml:space="preserve">
          <source>* an encoding of a formally valid language tag always is a string value that is defined, has length, and is true if considered as a boolean.</source>
          <target state="translated">* 형식적으로 유효한 언어 태그의 인코딩은 항상 정의되고 길이가 있으며 부울로 간주되는 경우 true 인 문자열 값입니다.</target>
        </trans-unit>
        <trans-unit id="cb89de7628537cdbcdcd2d5c31607dcd65d29209" translate="yes" xml:space="preserve">
          <source>* tags representing different languages never get the same encoding.</source>
          <target state="translated">* 다른 언어를 나타내는 태그는 동일한 인코딩을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="cfc914db0008bc5c5328a3a2456a7e925514bb85" translate="yes" xml:space="preserve">
          <source>* tags representing the same language always get the same encoding.</source>
          <target state="translated">* 같은 언어를 나타내는 태그는 항상 같은 인코딩을받습니다.</target>
        </trans-unit>
        <trans-unit id="f632df7964dda121448ae6e5ca4eb877ed15fde2" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;adler32()*</source>
          <target state="translated">*$d-&amp;gt;adler32()*</target>
        </trans-unit>
        <trans-unit id="c35eaa4aaa4b0b36d04700f984d9950b54e08112" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;crc32()*</source>
          <target state="translated">*$d-&amp;gt;crc32()*</target>
        </trans-unit>
        <trans-unit id="0c971c521366bf298521a0d1cb12de8653928b4d" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;dict_adler()*</source>
          <target state="translated">*$d-&amp;gt;dict_adler()*</target>
        </trans-unit>
        <trans-unit id="64629fc19b2eab3d05adbf52fc5e32abcf625962" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_BufSize()*</source>
          <target state="translated">*$d-&amp;gt;get_BufSize()*</target>
        </trans-unit>
        <trans-unit id="56aed9950c73a350f4bbada6fc3d5abe3158462a" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_Level()*</source>
          <target state="translated">*$d-&amp;gt;get_Level()*</target>
        </trans-unit>
        <trans-unit id="3bf087cdc68f5ef42e9bbc91a4a61bc60dd22717" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;get_Strategy()*</source>
          <target state="translated">*$d-&amp;gt;get_Strategy()*</target>
        </trans-unit>
        <trans-unit id="6a81c6c52f16a8d6923233b258116bbaae34938f" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;msg()*</source>
          <target state="translated">*$d-&amp;gt;msg()*</target>
        </trans-unit>
        <trans-unit id="b63a3f7f425b1954a977386ef5d279e257384ce4" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;total_in()*</source>
          <target state="translated">*$d-&amp;gt;total_in()*</target>
        </trans-unit>
        <trans-unit id="7be11abe1a981cdfe5c58e90cbe56c74620650fb" translate="yes" xml:space="preserve">
          <source>*$d-&amp;gt;total_out()*</source>
          <target state="translated">*$d-&amp;gt;total_out()*</target>
        </trans-unit>
        <trans-unit id="d80a4fc42d0165881aa2fa21601335f6a5b174f7" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;adler32()*</source>
          <target state="translated">*$i-&amp;gt;adler32()*</target>
        </trans-unit>
        <trans-unit id="68674a7b4388b0adebddc415278aa8a461b56203" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;crc32()*</source>
          <target state="translated">*$i-&amp;gt;crc32()*</target>
        </trans-unit>
        <trans-unit id="1660d213fb0cf4bed038244acbc0c77e58a9ffde" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;dict_adler()*</source>
          <target state="translated">*$i-&amp;gt;dict_adler()*</target>
        </trans-unit>
        <trans-unit id="ed00afb6796ebd2d75d5fb6836b1271979dc5acd" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;msg()*</source>
          <target state="translated">*$i-&amp;gt;msg()*</target>
        </trans-unit>
        <trans-unit id="2b2b2852d7c10fd41b04fd33545a78d54c94f1e6" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;total_in()*</source>
          <target state="translated">*$i-&amp;gt;total_in()*</target>
        </trans-unit>
        <trans-unit id="a00928e02457981385f8e4dd086f63b3c7d4708f" translate="yes" xml:space="preserve">
          <source>*$i-&amp;gt;total_out()*</source>
          <target state="translated">*$i-&amp;gt;total_out()*</target>
        </trans-unit>
        <trans-unit id="04bb5391ea5a418de25822f423a009711407d686" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflate($input, $output)*</source>
          <target state="translated">* $ status = $ d-&amp;gt; delate ($ input, $ output) *</target>
        </trans-unit>
        <trans-unit id="c0ba780f9e7693de09966236201daf25c2601f99" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateParams([OPT])*</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateParams ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="254a6aafb8b04918fd23639de431468d8ff29ccd" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateReset() *</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateReset () *</target>
        </trans-unit>
        <trans-unit id="d497a45f9cb78ca6b50b3a7e156fd6b9c7fb384d" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;deflateTune($good_length, $max_lazy, $nice_length, $max_chain)*</source>
          <target state="translated">* $ status = $ d-&amp;gt; deflateTune ($ good_length, $ max_lazy, $ nice_length, $ max_chain) *</target>
        </trans-unit>
        <trans-unit id="141b772af4aeeaea008ed027db1ed7bde5ce5676" translate="yes" xml:space="preserve">
          <source>*$status = $d-&amp;gt;flush($output [, $flush_type]) *</source>
          <target state="translated">* $ status = $ d-&amp;gt; flush ($ output [, $ flush_type]) *</target>
        </trans-unit>
        <trans-unit id="74f8a4eb98878730ef2f86aea42e666e1ee160bc" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateReset() *</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateReset () *</target>
        </trans-unit>
        <trans-unit id="9db33bbf75bca37e8376afc3d73136b2ed6357e1" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateSync($buffer)*</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateSync ($ 버퍼) *</target>
        </trans-unit>
        <trans-unit id="112c6b855140730d98a28cbfad625ebe4443a357" translate="yes" xml:space="preserve">
          <source>*$status = $i-&amp;gt;inflateSync($input)*</source>
          <target state="translated">* $ status = $ i-&amp;gt; inflateSync ($ 입력) *</target>
        </trans-unit>
        <trans-unit id="ac1cc2e7b1d14736f7f3c26c35c1e7b862a74263" translate="yes" xml:space="preserve">
          <source>*($d, $status) = deflateInit( [OPT] )*</source>
          <target state="translated">* ($ d, $ status) = deflateInit ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="a1e0d6d4dfa07bb414b033b626ca0cac87b1dd85" translate="yes" xml:space="preserve">
          <source>*($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) *</source>
          <target state="translated">* ($ d, $ status) = new Compress :: Raw :: Zlib :: Deflate ([OPT]) *</target>
        </trans-unit>
        <trans-unit id="3374bc8edae5ea56b3cf3599aae276d721728d25" translate="yes" xml:space="preserve">
          <source>*($i, $status) = inflateInit()*</source>
          <target state="translated">* ($ i, $ status) = 인플레이션 초기화 () *</target>
        </trans-unit>
        <trans-unit id="10ad095b48dbd0069e2864202f1242314d07a5ef" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $d-&amp;gt;deflate($buffer)*</source>
          <target state="translated">* ($ out, $ status) = $ d-&amp;gt; delate ($ buffer) *</target>
        </trans-unit>
        <trans-unit id="abc6e06c1d13c4e3bda0992462832a237f5a44c8" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $d-&amp;gt;flush()* =head2 *($out, $status) = $d-&amp;gt;flush($flush_type)*</source>
          <target state="translated">* ($ out, $ status) = $ d-&amp;gt; flush () * = head2 * ($ out, $ status) = $ d-&amp;gt; flush ($ flush_type) *</target>
        </trans-unit>
        <trans-unit id="3c4770a854a915518ba1ea48502e3961a3be7950" translate="yes" xml:space="preserve">
          <source>*($out, $status) = $i-&amp;gt;inflate($buffer)*</source>
          <target state="translated">* ($ out, $ status) = $ i-&amp;gt; 인플레이션 ($ buffer) *</target>
        </trans-unit>
        <trans-unit id="0d672a53a05ad4df9358326135542cc74a9d72d5" translate="yes" xml:space="preserve">
          <source>** If you are unfamiliar with testing &lt;b&gt;read &lt;a href=&quot;tutorial&quot;&gt;Test::Tutorial&lt;/a&gt; first!&lt;/b&gt; **</source>
          <target state="translated">** 테스트에 익숙하지 않은 경우 &lt;b&gt;&lt;a href=&quot;tutorial&quot;&gt;Test :: Tutorial을&lt;/a&gt;&lt;/b&gt;&lt;b&gt; 먼저 &lt;/b&gt;&lt;b&gt;읽으십시오 ! &lt;/b&gt;**</target>
        </trans-unit>
        <trans-unit id="5c455cfeca9fc61305db058d5b67796ca3d8f994" translate="yes" xml:space="preserve">
          <source>*.t</source>
          <target state="translated">*.t</target>
        </trans-unit>
        <trans-unit id="e06fa715f3e3bd676f73309b058b71ea1c00418c" translate="yes" xml:space="preserve">
          <source>*/man/</source>
          <target state="translated">*/man/</target>
        </trans-unit>
        <trans-unit id="030b7462745046bec4a3476bbbd9b7c622cb263d" translate="yes" xml:space="preserve">
          <source>*AutoLoader* vs. *SelfLoader*</source>
          <target state="translated">* AutoLoader * 대 * SelfLoader *</target>
        </trans-unit>
        <trans-unit id="b6da558cc8e40a9588c5a25bffee14e91b6e21e0" translate="yes" xml:space="preserve">
          <source>*Blocks versus Scripts*</source>
          <target state="translated">* 블록 대 스크립트 *</target>
        </trans-unit>
        <trans-unit id="6a49ec15388c609953d1dfeb20a9de1712f85c3d" translate="yes" xml:space="preserve">
          <source>*Matching Scripts and Blocks*</source>
          <target state="translated">* 매칭 스크립트 및 블록 *</target>
        </trans-unit>
        <trans-unit id="4dbc7db62720fd7c360f08690c42352d5d4fde10" translate="yes" xml:space="preserve">
          <source>*Pod::InteriorSequence*</source>
          <target state="translated">*Pod::InteriorSequence*</target>
        </trans-unit>
        <trans-unit id="bd484e6a3fa2a69cf1b2fa912e8c64e369203cf3" translate="yes" xml:space="preserve">
          <source>*Pod::Paragraph*</source>
          <target state="translated">*Pod::Paragraph*</target>
        </trans-unit>
        <trans-unit id="f6118e75f44bd9c2e2e7a4dbaf8b93141735b0c7" translate="yes" xml:space="preserve">
          <source>*Pod::ParseTree*</source>
          <target state="translated">*Pod::ParseTree*</target>
        </trans-unit>
        <trans-unit id="a839f625dd453146a9ced9341bbff5ba4836fc73" translate="yes" xml:space="preserve">
          <source>*Warning*</source>
          <target state="translated">*Warning*</target>
        </trans-unit>
        <trans-unit id="39c05f977c871385cfb2ac67c7071d2d0749325c" translate="yes" xml:space="preserve">
          <source>*add_selection()*</source>
          <target state="translated">*add_selection()*</target>
        </trans-unit>
        <trans-unit id="22677ec6b58cd6de560696c1281301c8215b2261" translate="yes" xml:space="preserve">
          <source>*all_casefolds()*</source>
          <target state="translated">*all_casefolds()*</target>
        </trans-unit>
        <trans-unit id="495bb86a56fbdcbecef4efb0a07e0fb5a52d90bb" translate="yes" xml:space="preserve">
          <source>*begin_input()*</source>
          <target state="translated">*begin_input()*</target>
        </trans-unit>
        <trans-unit id="21491eaf691d94ff4dc5e18150f5741423ca33f3" translate="yes" xml:space="preserve">
          <source>*begin_pod()*</source>
          <target state="translated">*begin_pod()*</target>
        </trans-unit>
        <trans-unit id="e63f038d7ccfb8b7ed87a3e9a94136cc3acbaa84" translate="yes" xml:space="preserve">
          <source>*bidi_types()*</source>
          <target state="translated">*bidi_types()*</target>
        </trans-unit>
        <trans-unit id="3323378f9f296b7e09bbde8389f91b3f2e90a612" translate="yes" xml:space="preserve">
          <source>*casefold()*</source>
          <target state="translated">*casefold()*</target>
        </trans-unit>
        <trans-unit id="a382525e3184f3292d70ce3e64c30b550c9d60ca" translate="yes" xml:space="preserve">
          <source>*casespec()*</source>
          <target state="translated">*casespec()*</target>
        </trans-unit>
        <trans-unit id="2acb520d2f999e48e1e23f31071debab4019805a" translate="yes" xml:space="preserve">
          <source>*charblock()*</source>
          <target state="translated">*charblock()*</target>
        </trans-unit>
        <trans-unit id="5a1a95773194bbecc12f391b4130725b29ef1d4a" translate="yes" xml:space="preserve">
          <source>*charblocks()*</source>
          <target state="translated">*charblocks()*</target>
        </trans-unit>
        <trans-unit id="892910658fd4f7c8f9957928bae7464e9f794524" translate="yes" xml:space="preserve">
          <source>*charinfo()*</source>
          <target state="translated">*charinfo()*</target>
        </trans-unit>
        <trans-unit id="298c43cb9d5cbe40f064250a448e61dd4cb8783e" translate="yes" xml:space="preserve">
          <source>*charinrange()*</source>
          <target state="translated">*charinrange()*</target>
        </trans-unit>
        <trans-unit id="98a743c2f5c3d0d1a69423f01cff293fd38d8edb" translate="yes" xml:space="preserve">
          <source>*charprop()*</source>
          <target state="translated">*charprop()*</target>
        </trans-unit>
        <trans-unit id="aff3e7777f49ee087b89c8a05dbee3af17a26546" translate="yes" xml:space="preserve">
          <source>*charprops_all()*</source>
          <target state="translated">*charprops_all()*</target>
        </trans-unit>
        <trans-unit id="2096c542c885e6ff5b205d9c49075754580714c3" translate="yes" xml:space="preserve">
          <source>*charscript()*</source>
          <target state="translated">*charscript()*</target>
        </trans-unit>
        <trans-unit id="95242ddcdfaf5eacd2a726f8aaa11d7bc03daf57" translate="yes" xml:space="preserve">
          <source>*charscripts()*</source>
          <target state="translated">*charscripts()*</target>
        </trans-unit>
        <trans-unit id="e4821a2674ad1d26afcb87813851f804da9f5ead" translate="yes" xml:space="preserve">
          <source>*ckfun_p</source>
          <target state="translated">*ckfun_p</target>
        </trans-unit>
        <trans-unit id="0b5ab6a4a90ff2c6437322fa15586407ef2b4d11" translate="yes" xml:space="preserve">
          <source>*ckobj_p</source>
          <target state="translated">*ckobj_p</target>
        </trans-unit>
        <trans-unit id="5f7f65bb7d96d645f65805f5d460c10a6f06b354" translate="yes" xml:space="preserve">
          <source>*clear_selections()*</source>
          <target state="translated">*clear_selections()*</target>
        </trans-unit>
        <trans-unit id="5d9dc7c769c9e8f4cbeee5398ed00b6384904253" translate="yes" xml:space="preserve">
          <source>*command()*</source>
          <target state="translated">*command()*</target>
        </trans-unit>
        <trans-unit id="a139e96d8189b5a55d4a4e8e2d33902d4d0c5b9d" translate="yes" xml:space="preserve">
          <source>*compexcl()*</source>
          <target state="translated">*compexcl()*</target>
        </trans-unit>
        <trans-unit id="1b540946e2151155f214582cd243507ba7640019" translate="yes" xml:space="preserve">
          <source>*curr_headings()*</source>
          <target state="translated">*curr_headings()*</target>
        </trans-unit>
        <trans-unit id="b44c1e16cdabb8e05ed00563725662b1898a3124" translate="yes" xml:space="preserve">
          <source>*cutting()*</source>
          <target state="translated">*cutting()*</target>
        </trans-unit>
        <trans-unit id="1ddba136bdb0a3b6dbf3f58b0168d4a9181d08fc" translate="yes" xml:space="preserve">
          <source>*end_input()*</source>
          <target state="translated">*end_input()*</target>
        </trans-unit>
        <trans-unit id="a5f7375fd2de061c65ad2bf50ef73effa4294574" translate="yes" xml:space="preserve">
          <source>*end_pod()*</source>
          <target state="translated">*end_pod()*</target>
        </trans-unit>
        <trans-unit id="1d38830083f7ab5197ea4473920fe3ec232e92e5" translate="yes" xml:space="preserve">
          <source>*errorsub()*</source>
          <target state="translated">*errorsub()*</target>
        </trans-unit>
        <trans-unit id="83ae438f6c5d4adfa7da1a2ac708671df372b4bb" translate="yes" xml:space="preserve">
          <source>*filter() and anonymous sub*</source>
          <target state="translated">* filter () 및 익명 하위 *</target>
        </trans-unit>
        <trans-unit id="c5d36b4a9ac4410d0011698855500ff129fe6378" translate="yes" xml:space="preserve">
          <source>*filter_add()*</source>
          <target state="translated">*filter_add()*</target>
        </trans-unit>
        <trans-unit id="c590fd9b9ee4cb77f8c87dcc99cff21706f50d16" translate="yes" xml:space="preserve">
          <source>*flags</source>
          <target state="translated">*flags</target>
        </trans-unit>
        <trans-unit id="87bf87677970cfb50487269d83b12971442cad62" translate="yes" xml:space="preserve">
          <source>*general_categories()*</source>
          <target state="translated">*general_categories()*</target>
        </trans-unit>
        <trans-unit id="c8093d60d704e74fc21bb32d9a8ddd7a40063485" translate="yes" xml:space="preserve">
          <source>*import()*</source>
          <target state="translated">*import()*</target>
        </trans-unit>
        <trans-unit id="4af0e2a6bb704b69c7748e25de2a62d813d13313" translate="yes" xml:space="preserve">
          <source>*initialize()*</source>
          <target state="translated">*initialize()*</target>
        </trans-unit>
        <trans-unit id="a26c0f1de05a3c3080ce231702af1d37d1ffdcef" translate="yes" xml:space="preserve">
          <source>*input_file()*</source>
          <target state="translated">*input_file()*</target>
        </trans-unit>
        <trans-unit id="7b32820eda1a4cbba59b3c51ef02fe178f80b148" translate="yes" xml:space="preserve">
          <source>*input_handle()*</source>
          <target state="translated">*input_handle()*</target>
        </trans-unit>
        <trans-unit id="37cf554dca7439d60a53244dbe9a6f6f66666dbc" translate="yes" xml:space="preserve">
          <source>*interior_sequence()*</source>
          <target state="translated">*interior_sequence()*</target>
        </trans-unit>
        <trans-unit id="c16b57ca8bb2b15c81ee7888fb0cc3c088fd5605" translate="yes" xml:space="preserve">
          <source>*interpolate()*</source>
          <target state="translated">*interpolate()*</target>
        </trans-unit>
        <trans-unit id="1c763b56009fbad09ca114bbc6ad819659ad6849" translate="yes" xml:space="preserve">
          <source>*is_selected()*</source>
          <target state="translated">*is_selected()*</target>
        </trans-unit>
        <trans-unit id="950f1ac016fdc438a26ebe09acd34140f5d0a0b3" translate="yes" xml:space="preserve">
          <source>*len</source>
          <target state="translated">*len</target>
        </trans-unit>
        <trans-unit id="beaf32cf7b2e540d90a96b6fc45fac3a314cd55f" translate="yes" xml:space="preserve">
          <source>*len_p</source>
          <target state="translated">*len_p</target>
        </trans-unit>
        <trans-unit id="d670fa291475b584f9b4236a8ddfefd0211dcd71" translate="yes" xml:space="preserve">
          <source>*match_section()*</source>
          <target state="translated">*match_section()*</target>
        </trans-unit>
        <trans-unit id="159da2978736cbc50e92916d4ff2e95e3a6a3290" translate="yes" xml:space="preserve">
          <source>*namedseq()*</source>
          <target state="translated">*namedseq()*</target>
        </trans-unit>
        <trans-unit id="6523eee7c8959f955cebf19b0aaf21b556b5b09d" translate="yes" xml:space="preserve">
          <source>*new()*</source>
          <target state="translated">*new()*</target>
        </trans-unit>
        <trans-unit id="999e9b24506786f32dd08362c3037e9728f69c8e" translate="yes" xml:space="preserve">
          <source>*num()*</source>
          <target state="translated">*num()*</target>
        </trans-unit>
        <trans-unit id="7834a1138a40b68be0feedf680b5fc18cc6f66fd" translate="yes" xml:space="preserve">
          <source>*old_checker_p</source>
          <target state="translated">*old_checker_p</target>
        </trans-unit>
        <trans-unit id="3f69d68aed17e619c04ffa05320c5c7f0a776f85" translate="yes" xml:space="preserve">
          <source>*output_file()*</source>
          <target state="translated">*output_file()*</target>
        </trans-unit>
        <trans-unit id="068f4b4b0837c6d09f198f53062edaca42ca04da" translate="yes" xml:space="preserve">
          <source>*output_handle()*</source>
          <target state="translated">*output_handle()*</target>
        </trans-unit>
        <trans-unit id="e31580f4b34415c38c50584a8776797a08860c70" translate="yes" xml:space="preserve">
          <source>*parse_from_file()*</source>
          <target state="translated">*parse_from_file()*</target>
        </trans-unit>
        <trans-unit id="0e4cafcb90bfc690fd27784f3955de4a3db5693b" translate="yes" xml:space="preserve">
          <source>*parse_from_filehandle()*</source>
          <target state="translated">*parse_from_filehandle()*</target>
        </trans-unit>
        <trans-unit id="d75b3a0e94d1dfb9614e94eb5cd073abcca5f774" translate="yes" xml:space="preserve">
          <source>*parse_text()*</source>
          <target state="translated">*parse_text()*</target>
        </trans-unit>
        <trans-unit id="7e9078f3ae0ce35ce16daab81c0d4418d0c4ed4f" translate="yes" xml:space="preserve">
          <source>*parseopts()*</source>
          <target state="translated">*parseopts()*</target>
        </trans-unit>
        <trans-unit id="3da2f47adeba78e93b545821850c23066406dbeb" translate="yes" xml:space="preserve">
          <source>*podselect()*</source>
          <target state="translated">*podselect()*</target>
        </trans-unit>
        <trans-unit id="78275badea2a77aee3c8465d83cc3c29a208ed8e" translate="yes" xml:space="preserve">
          <source>*preprocess_line()*</source>
          <target state="translated">*preprocess_line()*</target>
        </trans-unit>
        <trans-unit id="e7392b32b770b3c307b1ac3aae8f31c9a2750031" translate="yes" xml:space="preserve">
          <source>*preprocess_paragraph()*</source>
          <target state="translated">*preprocess_paragraph()*</target>
        </trans-unit>
        <trans-unit id="1e0522e99f043488d01967be6bf4f6d936d08801" translate="yes" xml:space="preserve">
          <source>*prop_aliases()*</source>
          <target state="translated">*prop_aliases()*</target>
        </trans-unit>
        <trans-unit id="d5d69a3ec3326224cb4550ade7aa539c5fb45f01" translate="yes" xml:space="preserve">
          <source>*prop_invlist()*</source>
          <target state="translated">*prop_invlist()*</target>
        </trans-unit>
        <trans-unit id="234f2ef007831363f45ef51c92f38d945d0737d9" translate="yes" xml:space="preserve">
          <source>*prop_invmap()*</source>
          <target state="translated">*prop_invmap()*</target>
        </trans-unit>
        <trans-unit id="df3580135f73b64d1d0f62af129b6dd0b45e63bb" translate="yes" xml:space="preserve">
          <source>*prop_value_aliases()*</source>
          <target state="translated">*prop_value_aliases()*</target>
        </trans-unit>
        <trans-unit id="c188181d7f65501ad8b99f693c9e5ec20c1820a3" translate="yes" xml:space="preserve">
          <source>*prop_values()*</source>
          <target state="translated">*prop_values()*</target>
        </trans-unit>
        <trans-unit id="3f4b3903dff14b7e8a38a7f6ff8d3b0fa7159477" translate="yes" xml:space="preserve">
          <source>*result</source>
          <target state="translated">*result</target>
        </trans-unit>
        <trans-unit id="e290a8472581248e50ff3784a40db196f11140bd" translate="yes" xml:space="preserve">
          <source>*roff</source>
          <target state="translated">*roff</target>
        </trans-unit>
        <trans-unit id="ac8814bb7facb31b6ba9ea89e4e2f1de11aa27af" translate="yes" xml:space="preserve">
          <source>*search_invlist()*</source>
          <target state="translated">*search_invlist()*</target>
        </trans-unit>
        <trans-unit id="f3dfb0ed0691863c50f58061da07cc12a0958750" translate="yes" xml:space="preserve">
          <source>*select()*</source>
          <target state="translated">*select()*</target>
        </trans-unit>
        <trans-unit id="ae2a6aae4f89e2c4aba8b451b3f1c9a851c4e28e" translate="yes" xml:space="preserve">
          <source>*textblock()*</source>
          <target state="translated">*textblock()*</target>
        </trans-unit>
        <trans-unit id="35292c70accf6e1bc4a136d07d88e046e56f7fe0" translate="yes" xml:space="preserve">
          <source>*use Filter::Util::Call*</source>
          <target state="translated">* 필터 사용 :: 유틸리티 :: 전화 *</target>
        </trans-unit>
        <trans-unit id="90337027d7a839db57d3cb410b0b9d7721ba0b7c" translate="yes" xml:space="preserve">
          <source>*verbatim()*</source>
          <target state="translated">*verbatim()*</target>
        </trans-unit>
        <trans-unit id="5c10b5b2cd673a0616d529aa5234b12ee7153808" translate="yes" xml:space="preserve">
          <source>,</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="9834fcb181aba28c7b6e23e1a30b0012fd3c7711" translate="yes" xml:space="preserve">
          <source>, &quot;Creating a Perl Debugger&quot;, &lt;a href=&quot;http://www.ddj.com/184404522&quot;&gt;http://www.ddj.com/184404522&lt;/a&gt; , and &quot;Profiling in Perl&quot; &lt;a href=&quot;http://www.ddj.com/184404580&quot;&gt;http://www.ddj.com/184404580&lt;/a&gt; .</source>
          <target state="translated">, &quot;펄 디버거 만들기&quot; &lt;a href=&quot;http://www.ddj.com/184404522&quot;&gt;http://www.ddj.com/184404522&lt;/a&gt; 하고, &quot;펄 프로파일&quot; &lt;a href=&quot;http://www.ddj.com/184404580&quot;&gt;http://www.ddj.com/184404580을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ee9b85d69a1a45808d43e30360a8f9162ce4c12" translate="yes" xml:space="preserve">
          <source>, (abbreviated NFC), and the sequence &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; followed by &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; represents the same character in</source>
          <target state="translated">, (약식 NFC) 및 시퀀스 &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; 와 뒤에 &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; 가 같은 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="730ddc40c82a93777903d7aac75c47f7ae79794b" translate="yes" xml:space="preserve">
          <source>, (places where the code seems to run slowly), change the code with the intention of making it run faster. Using version control software, like &lt;code&gt;subversion&lt;/code&gt; , will ensure no changes are irreversible. It's too easy to fiddle here and fiddle there - don't change too much at any one time or you might not discover which piece of code &lt;b&gt;really&lt;/b&gt; was the slow bit.</source>
          <target state="translated">, (코드가 느리게 실행되는 것처럼 보이는 곳) 더 빠르게 실행되도록 코드를 변경하십시오. &lt;code&gt;subversion&lt;/code&gt; 과 같은 버전 제어 소프트웨어를 사용하면 변경 사항을 되돌릴 수 없습니다. 여기에서 바이올린을 피우는 것은 너무 쉽습니다. 한 번에 너무 많이 변경하지 마십시오 . &lt;b&gt;실제로&lt;/b&gt; 어떤 코드가 &lt;b&gt;실제로&lt;/b&gt; 느린 비트 &lt;b&gt;인지&lt;/b&gt; 발견하지 못할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b189223f9e086284fb9e5a2d4ce238755de8f49e" translate="yes" xml:space="preserve">
          <source>, ...parameters...) and there's no</source>
          <target state="translated">, ... 매개 변수 ...)</target>
        </trans-unit>
        <trans-unit id="7d9c9fe99988b3556a05480d92acc265eff93ca8" translate="yes" xml:space="preserve">
          <source>, ...parameters...), and there's no entry</source>
          <target state="translated">, ... parameters ...) 및 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="91498e567e65fc55ee351426beca20dc70eece67" translate="yes" xml:space="preserve">
          <source>, ...parameters...), which should return a string that is generally meant for be used for &quot;output&quot; to the user -- regardless of whether this actually means printing to STDOUT, writing to a file, or putting into a GUI widget.</source>
          <target state="translated">, ... parameters ...)는 실제로 STDOUT에 인쇄하는지, 파일에 쓰거나, GUI 위젯.</target>
        </trans-unit>
        <trans-unit id="68cb9c38401d32e374d45576d1fe16f98edccd5c" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, &lt;a href=&quot;select&quot;&gt;IO::Select&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt; , &lt;a href=&quot;select&quot;&gt;IO :: 선택&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f38c4631f06af453e92ba616992751a1a1e31124" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://lexington.pm.org/meetings/022001.html&quot;&gt;http://lexington.pm.org/meetings/022001.html&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;http://lexington.pm.org/meetings/022001.html&quot;&gt;http://lexington.pm.org/meetings/022001.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="007315ce711051c2a3299693a5a40842913289dd" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3164.html&quot;&gt;http://www.faqs.org/rfcs/rfc3164.html&lt;/a&gt; -- Please note that this is an informational RFC, and therefore does not specify a standard of any kind.</source>
          <target state="translated">, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3164.html&quot;&gt;http://www.faqs.org/rfcs/rfc3164.html-&lt;/a&gt; 정보 용 RFC이므로 어떤 종류의 표준도 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3b3dad532b1f051eeb3fba0becc6bea982f5b86" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3195.html&quot;&gt;http://www.faqs.org/rfcs/rfc3195.html&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc3195.html&quot;&gt;http://www.faqs.org/rfcs/rfc3195.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d9e0f29d4fed3c7ae0a33dd19ec98ac2183348" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&quot;&gt;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&lt;/a&gt; .</source>
          <target state="translated">, &lt;a href=&quot;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&quot;&gt;http://www.stonehenge.com/merlyn/LinuxMag/col75.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b47d0918c2a38bd4e2af6702ab10cf50ebd2add8" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;http://www.stonehenge.com/merlyn/UnixReview/col49.html&quot;&gt;http://www.stonehenge.com/merlyn/UnixReview/col49.html&lt;/a&gt; , and &quot;Profiling in Template Toolkit via Overriding&quot; for</source>
          <target state="translated">, &lt;a href=&quot;http://www.stonehenge.com/merlyn/UnixReview/col49.html&quot;&gt;http://www.stonehenge.com/merlyn/UnixReview/col49.html&lt;/a&gt; 및 '재정의를 통한 템플릿 툴킷 프로파일 링'</target>
        </trans-unit>
        <trans-unit id="c492919f48867530188fb7d22191a67fbb7c3fa3" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e96b82193d3adc8ae90d1b6a1d39c967eceb5aec" translate="yes" xml:space="preserve">
          <source>, &lt;a href=&quot;spec&quot;&gt;File::Spec&lt;/a&gt;</source>
          <target state="translated">, &lt;a href=&quot;spec&quot;&gt;파일 :: 사양&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="48c993c3ad6fdcd73107b423983292a0b10d7d43" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;AutoLoader&lt;/b&gt; will look for perl subroutines &lt;b&gt;POSIX&lt;/b&gt; in</source>
          <target state="translated">, &lt;b&gt;자동로드는&lt;/b&gt; 펄 서브 루틴을 찾을 것이다 &lt;b&gt;POSIX&lt;/b&gt; 에서</target>
        </trans-unit>
        <trans-unit id="38f2da13d7f63c25ad1931eef771da2bdb146cd3" translate="yes" xml:space="preserve">
          <source>, &lt;b&gt;Tgetent&lt;/b&gt; searches the files</source>
          <target state="translated">, &lt;b&gt;Tgetent&lt;/b&gt; 가 파일을 검색합니다</target>
        </trans-unit>
        <trans-unit id="1e03ac4e29872e2c267670242061f02f12f57063" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;$self&lt;/code&gt; , is the same reference that was passed to &lt;code&gt;filter_add&lt;/code&gt; blessed into the filter's package. See the example filters later on for details of using &lt;code&gt;$self&lt;/code&gt; .</source>
          <target state="translated">, &lt;code&gt;$self&lt;/code&gt; 는 필터 패키지에 축복 된 &lt;code&gt;filter_add&lt;/code&gt; 에 전달 된 것과 동일한 참조입니다 . &lt;code&gt;$self&lt;/code&gt; 사용에 대한 자세한 내용은 나중에 필터 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae56078784168c372862d15f35078dd7477dd624" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt; ) into one switch (</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;a &amp;ndash;b &amp;ndash;c&lt;/code&gt; )를 하나의 스위치 (</target>
        </trans-unit>
        <trans-unit id="2809b44d364e51b37846cda09da4d124638daab2" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;&amp;ndash;abc&lt;/code&gt; ). Any switch with an additional &lt;b&gt;argument&lt;/b&gt; must be the last switch in a cluster.</source>
          <target state="translated">, &lt;code&gt;&amp;ndash;abc&lt;/code&gt; ). 추가 &lt;b&gt;인수가&lt;/b&gt; 있는 스위치는 클러스터의 마지막 스위치 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0ad542fba4a49b259c0748e429b369dce74c977b" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;Encode::FB_DEFAULT&lt;/code&gt; (== 0) is assumed.</source>
          <target state="translated">, &lt;code&gt;Encode::FB_DEFAULT&lt;/code&gt; (== 0)로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d4b64e63a3c0223fd25236e90f27d457472226a1" translate="yes" xml:space="preserve">
          <source>, &lt;code&gt;code-style&lt;/code&gt; , &lt;a href=&quot;perlfaq&quot;&gt;hyperlinks&lt;/a&gt;, and more. Such codes are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">, &lt;code&gt;code-style&lt;/code&gt; , &lt;a href=&quot;perlfaq&quot;&gt;하이퍼 링크&lt;/a&gt; 등이 있습니다. 이러한 코드는 아래 의 &quot; &lt;a href=&quot;#Formatting-Codes&quot;&gt;포맷 코드&lt;/a&gt; &quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2357bd7f4335eff8d8daf0fa1da32b05aadee0e0" translate="yes" xml:space="preserve">
          <source>, C</source>
          <target state="translated">, 씨</target>
        </trans-unit>
        <trans-unit id="4a3b6b54a01d06829186977454076430f1593339" translate="yes" xml:space="preserve">
          <source>, Copyright &amp;copy; 2012 Tom Christiansen &amp;lt;et al.&amp;gt;, 2012-02-13 by O&amp;rsquo;Reilly Media. The code itself is freely redistributable, and you are encouraged to transplant, fold, spindle, and mutilate any of the examples in this manpage however you please for inclusion into your own programs without any encumbrance whatsoever. Acknowledgement via code comment is polite but not required.</source>
          <target state="translated">, 저작권 &amp;copy; 2012 Tom Christiansen &amp;lt;et al.&amp;gt;, 2012-02-13 O'Reilly Media. 코드 자체는 자유롭게 재배포 할 수 있으며이 맨 페이지의 예제를 이식, 접기, 스핀들 및 절단하는 것이 좋습니다. 그러나 어떠한 문제도없이 자신의 프로그램에 포함 시키십시오. 코드 주석을 통한 승인은 정중하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="283d166baa4da2433ea6b8c5023e0c5383a472d9" translate="yes" xml:space="preserve">
          <source>, Fourth Edition, by Tom Christiansen, brian d foy, Larry Wall, &amp;amp; Jon Orwant. Copyright (c) 2000, 1996, 1991, 2012 O'Reilly Media, Inc. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">, 제 4 판, Tom Christiansen, brian d foy, Larry Wall 및 Jon Orwant. Copyright (c) 2000, 1996, 1991, 2012 O'Reilly Media, Inc.이 문서는 Perl과 동일한 조건으로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4710510ddd5139b0d57b1444caca5a0e1dbc934" translate="yes" xml:space="preserve">
          <source>, Fourth Edition. Words or phrases in bold are defined elsewhere in this glossary.</source>
          <target state="translated">, 제 4 판. 굵게 표시된 단어 나 문구는이 용어집의 다른 곳에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3f1d4a19fa8c41000422fe5f0f14f333cda54d" translate="yes" xml:space="preserve">
          <source>, I hesitate to make 10 ways to do something&quot;. This is a tricky heuristic to navigate, though--one man's essential addition is another man's pointless cruft.</source>
          <target state="translated">, 나는 무언가를 할 수있는 10 가지 방법을 만드는 것을 망설이고있다.&amp;rdquo;이것은 탐색하기 까다로운 휴리스틱이지만, 한 사람의 필수 추가는 다른 사람의 무의미한 주름이다.</target>
        </trans-unit>
        <trans-unit id="ad45c1c8eec7555ccd92edae836e62ba22314f7b" translate="yes" xml:space="preserve">
          <source>, I used something like this:</source>
          <target state="translated">, 나는 이것을 다음과 같이 사용했다 :</target>
        </trans-unit>
        <trans-unit id="c65991634f6aa7daad894716fa3515f707c0dcd9" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt; ) is given in years since 1900,</source>
          <target state="translated">1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후의 연도 단위 로 주어집니다.</target>
        </trans-unit>
        <trans-unit id="278251f0cd32cd452e601bfc7f4ba837feb500cf" translate="yes" xml:space="preserve">
          <source>, January is 0, not 1; Sunday is 0, not 1; January 1st is 0, not 1. The year (&lt;code&gt;year&lt;/code&gt; ) is given in years since 1900;</source>
          <target state="translated">1 월은 1이 아니라 0입니다. 일요일은 1이 아니라 0입니다. 1 월 1 일은 1이 아니라 0입니다. 연도 ( &lt;code&gt;year&lt;/code&gt; )는 1900 년 이후의 연도 입니다.</target>
        </trans-unit>
        <trans-unit id="dd182ebc9d81517e21729c826fb7210f389d7052" translate="yes" xml:space="preserve">
          <source>, L</source>
          <target state="translated">, L</target>
        </trans-unit>
        <trans-unit id="7fbf5c6d0f24b18219afd1efb585538657616790" translate="yes" xml:space="preserve">
          <source>, L&amp;lt;:spec&amp;gt;, L&amp;lt;:path&amp;gt;</source>
          <target state="translated">, L &amp;lt;: spec&amp;gt;, L &amp;lt;: path&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cff6989687fa00c2222ce15a90a800a548dbd994" translate="yes" xml:space="preserve">
          <source>, Perl uses the same algorithm as</source>
          <target state="translated">Perl은 다음과 같은 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df8f77da47481a5590b158d0835c14c3d411493e" translate="yes" xml:space="preserve">
          <source>, Recipe 13.12).</source>
          <target state="translated">레시피 13.12).</target>
        </trans-unit>
        <trans-unit id="6a45be8c0a733008fda1873b6942b65ae06a110b" translate="yes" xml:space="preserve">
          <source>, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb's Journal, Issue 295, January 1999, pp 34-41</source>
          <target state="translated">, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb 's Journal, Issue 295, 1999 년 1 월, pp 34-41</target>
        </trans-unit>
        <trans-unit id="2a5671053104bfa65fdb1b845e8f918f200dbaad" translate="yes" xml:space="preserve">
          <source>, Volume 2, Section 3.4.2, by Donald E. Knuth.</source>
          <target state="translated">, 제 2 권, 3.4.2 절 (Donald E. Knuth).</target>
        </trans-unit>
        <trans-unit id="633875e12973ea9004215c69c80143c016eb22c8" translate="yes" xml:space="preserve">
          <source>, a German magazine dedicated to Perl, at ( &lt;a href=&quot;http://www.foo-magazin.de&quot;&gt;http://www.foo-magazin.de&lt;/a&gt; ). The</source>
          <target state="translated">, Perl 전용 독일 잡지 ( &lt;a href=&quot;http://www.foo-magazin.de&quot;&gt;http://www.foo-magazin.de&lt;/a&gt; ). 그만큼</target>
        </trans-unit>
        <trans-unit id="14297948b11112ed3c840f341ffecd330757f94c" translate="yes" xml:space="preserve">
          <source>, a Perl script which uses the &lt;code&gt;MakeMaker&lt;/code&gt; library modules supplied with Perl to generate a</source>
          <target state="translated">, Perl 과 함께 제공되는 &lt;code&gt;MakeMaker&lt;/code&gt; 라이브러리 모듈을 사용하여</target>
        </trans-unit>
        <trans-unit id="855e80b07db61e1b1fac17edd36f618a095e2b73" translate="yes" xml:space="preserve">
          <source>, a collator via &lt;code&gt;Unicode::Collate-&amp;gt;new( )&lt;/code&gt; should be used; for</source>
          <target state="translated">&lt;code&gt;Unicode::Collate-&amp;gt;new( )&lt;/code&gt; 를 통한 collator를 사용해야합니다. ...에 대한</target>
        </trans-unit>
        <trans-unit id="337354a63807d72c18305c9618bef7795ca2d6b6" translate="yes" xml:space="preserve">
          <source>, a collator via &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; .</source>
          <target state="translated">, &lt;code&gt;Unicode::Collate-&amp;gt;new(variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 통한 콜 레이터 .</target>
        </trans-unit>
        <trans-unit id="181354d61db1393a6d43dac9c961eb59f80b38ac" translate="yes" xml:space="preserve">
          <source>, a crude but sufficient utility to check the integrity of a UCM file. Check under the Encode/bin directory for this.</source>
          <target state="translated">, UCM 파일의 무결성을 검사하기위한 조잡하지만 충분한 유틸리티입니다. Encode / bin 디렉토리에서이를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ee470b6f82053958faf72f7660a0d296d09184d4" translate="yes" xml:space="preserve">
          <source>, a debug aid which allowed callers to identify themselves. This aid has been superseded by a new build option, PERL_MEM_LOG (see &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;PERL_MEM_LOG in perlhacktips&lt;/a&gt;). The older API is still there for use in XS modules supporting older perls.</source>
          <target state="translated">호출자가 자신을 식별 할 수 있도록하는 디버그 지원 이 지원은 새로운 빌드 옵션 PERL_MEM_LOG로 대체되었습니다 ( &lt;a href=&quot;perlhacktips#PERL_MEM_LOG&quot;&gt;perlhacktips의 PERL_MEM_LOG&lt;/a&gt; 참조 ). 이전 API는 이전 perls를 지원하는 XS 모듈에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be95971fca9604306918e6af9caf54dadcd9baea" translate="yes" xml:space="preserve">
          <source>, a non-UTF-8 one), a multi-byte character was encountered. Perl considers this character to be the specified Unicode code point. Combining non-UTF-8 locales and Unicode is dangerous. Almost certainly some characters will have two different representations. For example, in the ISO 8859-7 (Greek) locale, the code point 0xC3 represents a Capital Gamma. But so also does 0x393. This will make string comparisons unreliable.</source>
          <target state="translated">, 비 UTF-8 문자) 멀티 바이트 문자가 발생했습니다. Perl은이 문자를 지정된 유니 코드 코드 포인트로 간주합니다. 비 UTF-8 로케일과 유니 코드를 결합하면 위험합니다. 거의 확실하게 일부 문자에는 두 가지 다른 표현이 있습니다. 예를 들어 ISO 8859-7 (Greek) 로캘에서 코드 포인트 0xC3은 대문자 감마를 나타냅니다. 그러나 0x393도 마찬가지입니다. 이렇게하면 문자열 비교를 신뢰할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8a9cd0090598c42711026e8b2bedbe13afa859" translate="yes" xml:space="preserve">
          <source>, a scalar variable containing a filehandle. You can use it the same way you would a normal filehandle. For example, you can read one line from it this way:</source>
          <target state="translated">파일 핸들을 포함하는 스칼라 변수 일반적인 파일 핸들과 같은 방식으로 사용할 수 있습니다. 예를 들어 다음과 같이 한 줄을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87346f4ea924d98273903e7b08eb5bb50fb07524" translate="yes" xml:space="preserve">
          <source>, a standard for representing the alphabets from virtually all of the world's written languages, and a host of symbols. Perl's text strings are Unicode strings, so they can contain characters with a value (codepoint or character number) higher than 255.</source>
          <target state="translated">세계 거의 모든 언어로 작성된 알파벳과 다양한 기호를 나타내는 표준입니다. Perl의 텍스트 문자열은 유니 코드 문자열이므로 값 (코드 포인트 또는 문자 번호)이 255보다 큰 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ff749a1a77a1bd6de5d5980b0e406d37de2a87" translate="yes" xml:space="preserve">
          <source>, a utility to extract named sections from documents written in POD. For instance, while utilities have &quot;USAGE&quot; sections, Perl modules usually have &quot;SYNOPSIS&quot; sections: &lt;code&gt;podselect -s &quot;SYNOPSIS&quot; ...&lt;/code&gt; will extract this section for a given file.</source>
          <target state="translated">POD로 작성된 문서에서 명명 된 섹션을 추출하는 유틸리티입니다. 예를 들어 유틸리티에 &quot;USAGE&quot;섹션이 있지만 Perl 모듈에는 일반적으로 &quot;SYNOPSIS&quot;섹션이 있습니다. &lt;code&gt;podselect -s &quot;SYNOPSIS&quot; ...&lt;/code&gt; 은 주어진 파일에 대해이 섹션을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="db014a48cc1ae20706ba0b5682336d456105e57c" translate="yes" xml:space="preserve">
          <source>, above, below, to one side or the other,</source>
          <target state="translated">위, 아래, 한쪽 또는 다른쪽으로</target>
        </trans-unit>
        <trans-unit id="5bf0fa78a7fe771f1c10ae24e95162b1b6bb2a45" translate="yes" xml:space="preserve">
          <source>, albeit fairly useless ones. All they does is filter the source stream without modifying it at all.</source>
          <target state="translated">비록 쓸모없는 것은 아니지만. 그들이하는 것은 소스 스트림을 전혀 수정하지 않고 필터링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5362fe8d34331626858b75f7fc5b14ff4d9fc4ab" translate="yes" xml:space="preserve">
          <source>, all IN UPPER CASE. Some control-type code points do not have names. This field will be empty for &lt;code&gt;Surrogate&lt;/code&gt; and &lt;code&gt;Private Use&lt;/code&gt; code points, and for the others without a name, it will contain a description enclosed in angle brackets, like &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">모두 대문자로되어 있습니다. 일부 제어 유형 코드 포인트에는 이름이 없습니다. 이 필드는 &lt;code&gt;Surrogate&lt;/code&gt; 및 &lt;code&gt;Private Use&lt;/code&gt; 코드 포인트의 경우 비어 있으며 이름이없는 다른 경우에는 &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; 과 같이 꺾쇠 괄호로 묶은 설명이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f664646812299a02b0171f588d3e3b25b20c386d" translate="yes" xml:space="preserve">
          <source>, all but the first posthumously assembled by CJRT. But</source>
          <target state="translated">CJRT가 사후에 처음으로 모은 것을 제외하고는 그러나</target>
        </trans-unit>
        <trans-unit id="bc5ed6d6260771787075622eea22b930d5fe4a65" translate="yes" xml:space="preserve">
          <source>, along with the header files</source>
          <target state="translated">헤더 파일과 함께</target>
        </trans-unit>
        <trans-unit id="1c56ef602b07cce67c23c54f38c6850a343a4ce2" translate="yes" xml:space="preserve">
          <source>, although you're better off reading the original YACC input in</source>
          <target state="translated">, 원본 YACC 입력을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8278d2adba7612cf98a492d21a4ac4c78acb1202" translate="yes" xml:space="preserve">
          <source>, and</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="0010f4c714dfcbbc2cef143cc9657ab05ffac473" translate="yes" xml:space="preserve">
          <source>, and &lt;b&gt;pod2usage()&lt;/b&gt; adheres to this philosophy. If you are interested in seeing a number of different ways to invoke &lt;b&gt;pod2usage&lt;/b&gt; (although by no means exhaustive), please refer to &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;.</source>
          <target state="translated">및 &lt;b&gt;예문 ()&lt;/b&gt; 이 철학에 부착. &lt;b&gt;pod2usage&lt;/b&gt; 를 호출하는 여러 가지 방법을보고 싶은 경우 (완전히 철저하지는 않지만) &lt;a href=&quot;#EXAMPLES&quot;&gt;예&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9e2024ba8a9984c63410d51fe1a587ce82acdf" translate="yes" xml:space="preserve">
          <source>, and &lt;code&gt;S_mro_get_linear_isa_dfs()&lt;/code&gt; in</source>
          <target state="translated">및 &lt;code&gt;S_mro_get_linear_isa_dfs()&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="7965adffe1bd5d2a5ae6fef9ed74cb1e415855b5" translate="yes" xml:space="preserve">
          <source>, and Perl will then dispatch the program to the correct interpreter for them.</source>
          <target state="translated">그런 다음 Perl은 해당 프로그램을 해당 언어로 올바른 통역사에게 발송합니다.</target>
        </trans-unit>
        <trans-unit id="d17b3bf1e5023500587f0bcfd04e502c3bc08dca" translate="yes" xml:space="preserve">
          <source>, and a type of</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="11eff2ad6b0924ed9a9167101ce0e3ec0461d9bb" translate="yes" xml:space="preserve">
          <source>, and all standard-fearing programs ought to follow this convention. (This is, of course, a stern backing for one of the Lilliputian parties and may well influence the political development there.) So, if the protocol expects you to send a message by sending the length first, followed by just so many bytes, you could write:</source>
          <target state="translated">모든 표준 무시 프로그램은이 규칙을 따라야합니다. (물론 이것은 Lilliputian 당사자 중 하나에 대한 엄격한 후원이며 정치 발전에 영향을 줄 수 있습니다.) 따라서 프로토콜이 길이를 먼저 보내고 메시지를 보내면 바이트가 많을 것입니다. 당신은 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="09f5aea40a8a98f4ed0812b20a5158126d6be5b5" translate="yes" xml:space="preserve">
          <source>, and an SV argument for it is returned in</source>
          <target state="translated">에 대한 SV 인수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="907df61a5a10c19d07f5b25bb871f858cdf3aedb" translate="yes" xml:space="preserve">
          <source>, and an SV argument for it is supplied in</source>
          <target state="translated">에 대한 SV 인수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="07578e4d2c674557fed4e3b460e007cddc507081" translate="yes" xml:space="preserve">
          <source>, and appends that data to the current state. The return value is the updated object itself.</source>
          <target state="translated">, 해당 데이터를 현재 상태에 추가합니다. 반환 값은 업데이트 된 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="47d93ebc28ad85bac43459b74d7c9dbb3a691abc" translate="yes" xml:space="preserve">
          <source>, and arrange for some changes to be automatically undone at the end of it, either explicit, or via a non-local exit (via die()). A</source>
          <target state="translated">, 명시 적 또는 로컬이 아닌 종료 (die ()를 통해) 종료시 일부 변경 사항이 자동으로 취소되도록 정렬합니다. ㅏ</target>
        </trans-unit>
        <trans-unit id="9662074e67662b5481a257ab591d1bcd6cd373a7" translate="yes" xml:space="preserve">
          <source>, and choose &lt;code&gt;Link
object modules&lt;/code&gt; in</source>
          <target state="translated">에서 &lt;code&gt;Link object modules&lt;/code&gt; 선택 합니다 .</target>
        </trans-unit>
        <trans-unit id="110d41533f5d3ce6a781ca76529c953253c32c91" translate="yes" xml:space="preserve">
          <source>, and do not want to hand-edit thousands of your scripts, the long-term solution proposed on p5-p is to have a directive</source>
          <target state="translated">p5-p에 제안 된 장기적인 해결책은 지시어를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc9709da02255267935725dadd4e4f1b5070af04" translate="yes" xml:space="preserve">
          <source>, and even a blessed hash reference uses &quot;HASH&quot; as its</source>
          <target state="translated">축복받은 해시 참조조차도 &quot;HASH&quot;를</target>
        </trans-unit>
        <trans-unit id="5ef9d3e35d5e919080f798270609eb087c92e72c" translate="yes" xml:space="preserve">
          <source>, and executables go in</source>
          <target state="translated">실행 파일이 들어갑니다</target>
        </trans-unit>
        <trans-unit id="e99a7bbd8a62347c5bce742eeae839d4eb74e152" translate="yes" xml:space="preserve">
          <source>, and for a detailed look at the semantics of regular expressions. In particular, all modifiers except the largely obsolete &lt;code&gt;/o&lt;/code&gt; are further explained in &lt;a href=&quot;perlre#Modifiers&quot;&gt;Modifiers in perlre&lt;/a&gt;. &lt;code&gt;/o&lt;/code&gt; is described in the next section.</source>
          <target state="translated">정규 표현식의 의미를 자세히 살펴보십시오. 특히, 더 이상 사용되지 않는 &lt;code&gt;/o&lt;/code&gt; 를 제외한 모든 수정자는 &lt;a href=&quot;perlre#Modifiers&quot;&gt;perlre의 수정 자에&lt;/a&gt; 자세히 설명되어 있습니다. &lt;code&gt;/o&lt;/code&gt; 는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fea8f1839cc7e75e58025f40c960d342144ecc35" translate="yes" xml:space="preserve">
          <source>, and have Perl create &lt;code&gt;#define&lt;/code&gt; 's for you, based on the current platform.</source>
          <target state="translated">현재 플랫폼을 기반으로 Perl이 &lt;code&gt;#define&lt;/code&gt; 을 만들도록 합니다.</target>
        </trans-unit>
        <trans-unit id="900068e92f1192efacbc29ee3e1d53428f88cdd9" translate="yes" xml:space="preserve">
          <source>, and is initialized whenever Perl is invoked. In the &lt;b&gt;dynamic&lt;/b&gt; configuration, the extension's machine code is placed into a separate shareable image, which is mapped by Perl's DynaLoader when the extension is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d in your script. This allows you to maintain the extension as a separate entity, at the cost of keeping track of the additional shareable image. Most extensions can be set up as either static or dynamic.</source>
          <target state="translated">Perl이 호출 될 때마다 초기화됩니다. 에서 &lt;b&gt;동적&lt;/b&gt; 구성, 확장의 기계 코드의 확장자는 펄의 DynaLoader에 의해 매핑 된 별도의 공유 이미지에 배치되어 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d 또는 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 스크립트에서 거라고. 이렇게하면 추가 공유 가능 이미지를 추적하는 대신 확장을 별도의 엔티티로 유지할 수 있습니다. 대부분의 확장은 정적 또는 동적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b914301e3b694e04eb4c8f6d66927ba02c63ec35" translate="yes" xml:space="preserve">
          <source>, and is mainly used if</source>
          <target state="translated">그리고 주로 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="5131123bb887b411a05999cb591c474e9daf98b5" translate="yes" xml:space="preserve">
          <source>, and is noted with a horizontal bar above the number, or &lt;code&gt;~z&lt;/code&gt; here.</source>
          <target state="translated">, 숫자 위에 가로 막대 또는 &lt;code&gt;~z&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f3befe3ecdb52c3422eb6f93dd78d5aaedf3fabd" translate="yes" xml:space="preserve">
          <source>, and loaded by SWASHNEW, using</source>
          <target state="translated">을 사용하여 SWASHNEW에서로드</target>
        </trans-unit>
        <trans-unit id="1787c9612788394f8950dccec477064ff47cc618" translate="yes" xml:space="preserve">
          <source>, and located either in the wired-in-during-compile locations (usually</source>
          <target state="translated">, 유선 컴파일 중 위치 (일반적으로</target>
        </trans-unit>
        <trans-unit id="3f5db2f6d9247a04a8fdbc30fe1efcc305bcdcc0" translate="yes" xml:space="preserve">
          <source>, and many ops have their own optimizing functions.</source>
          <target state="translated">, 많은 작전에는 자체 최적화 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5edcae719ec7875f046ff91c0210af5ff89c2790" translate="yes" xml:space="preserve">
          <source>, and on Windows it would result in</source>
          <target state="translated">, Windows에서는</target>
        </trans-unit>
        <trans-unit id="744cb0990a11cbc554e464fe23863d4a00b4136e" translate="yes" xml:space="preserve">
          <source>, and returns one reference to the new &lt;code&gt;refcounted_he&lt;/code&gt; .</source>
          <target state="translated">, 새로운 &lt;code&gt;refcounted_he&lt;/code&gt; 에 대한 하나의 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0f2f2fac6d25d7ba621ec4876ee490192080dccc" translate="yes" xml:space="preserve">
          <source>, and returns the modified hash. The returned hash pointer is in general not the same as the hash pointer that was passed in. The input hash is consumed by the function, and the pointer to it must not be subsequently used. Use &lt;a href=&quot;#cophh_copy&quot;&gt;cophh_copy&lt;/a&gt; if you need both hashes.</source>
          <target state="translated">수정 된 해시를 반환합니다. 반환 된 해시 포인터는 일반적으로 전달 된 해시 포인터와 동일하지 않습니다. 입력 해시는 함수에 의해 소비되며 이후에 포인터를 사용해서는 안됩니다. 두 해시가 모두 필요한 경우 &lt;a href=&quot;#cophh_copy&quot;&gt;cophh_copy를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="def96a3fb64ab61d8b47c5c7c69ce7251de754fe" translate="yes" xml:space="preserve">
          <source>, and run</source>
          <target state="translated">실행</target>
        </trans-unit>
        <trans-unit id="910d0b04d2f7ed13b6c81acf52dcf3b2185353b5" translate="yes" xml:space="preserve">
          <source>, and so we make a copy of</source>
          <target state="translated">그래서 우리는</target>
        </trans-unit>
        <trans-unit id="52cab3ae12ab735a21d73b832e20e1fc668ffa87" translate="yes" xml:space="preserve">
          <source>, and splits it up into chunks separated by lines of equal signs, which are placed in &lt;code&gt;@Fields&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@Fields&lt;/code&gt; 에 배치 된 등호로 구분 된 청크로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="34ecfa8acd326d9d67e3ffa2f086f02a68db8dfb" translate="yes" xml:space="preserve">
          <source>, and start it by typing</source>
          <target state="translated">을 입력하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2df22aba65ded74733f8217023fc9a2c713a5813" translate="yes" xml:space="preserve">
          <source>, and that &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; cannot and do not attempt to emulate the reverse mapping. Other &lt;code&gt;.&lt;/code&gt;'s in filenames are translated to &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">, 그 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 을 하고 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 할 수 없습니다와 역 매핑을 모방하지 마십시오. 기타 &lt;code&gt;.&lt;/code&gt; 의 파일 이름은 &lt;code&gt;/&lt;/code&gt; 로 번역됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3d815d4e6d0e0bf7a5070acb067a435d89afd9c" translate="yes" xml:space="preserve">
          <source>, and the</source>
          <target state="translated">, 그리고</target>
        </trans-unit>
        <trans-unit id="b3a5f939ce328cd3a253a4971e69a804f33e67d5" translate="yes" xml:space="preserve">
          <source>, and the Gulf of Guinea (think of the missing big chunk of Africa)</source>
          <target state="translated">기니 만 (아프리카의 잃어버린 큰 덩어리를 생각하십시오)</target>
        </trans-unit>
        <trans-unit id="49678bf28719f40cbc47bf372671fcd223bd7354" translate="yes" xml:space="preserve">
          <source>, and the error message will include the line and file where the failed request happened.</source>
          <target state="translated">오류 메시지에 실패한 요청이 발생한 행과 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c64023a04906dd729256ff3e0c07dcfe556d4b78" translate="yes" xml:space="preserve">
          <source>, and the rest of the things in the lexicon class as things that we know how to</source>
          <target state="translated">어휘 수업의 나머지 부분은 우리가</target>
        </trans-unit>
        <trans-unit id="6c2c13f1fd18de7a45c45c3b6d611d0fa6d993db" translate="yes" xml:space="preserve">
          <source>, and the second being the</source>
          <target state="translated">그리고 두 번째는</target>
        </trans-unit>
        <trans-unit id="10948b5578036f5ad32a0ed831bfc6d104fae454" translate="yes" xml:space="preserve">
          <source>, and the semaphore's count remains unchanged. Otherwise, the semaphore's count is decremented and this method returns</source>
          <target state="translated">세마포어 수는 변경되지 않습니다. 그렇지 않으면 세마포어 수가 감소하고이 메소드는</target>
        </trans-unit>
        <trans-unit id="73b36d5071f4b2d6973b107a88cccdf62d2e436d" translate="yes" xml:space="preserve">
          <source>, and the true value in the fourth argument means</source>
          <target state="translated">네 번째 인수의 실제 값은</target>
        </trans-unit>
        <trans-unit id="759ee7d0b93dff6747c3fbd234956c01b3c8260a" translate="yes" xml:space="preserve">
          <source>, and then the CRTL &lt;code&gt;environ&lt;/code&gt; array. This default order is reversed when the logical name</source>
          <target state="translated">그런 다음 CRTL &lt;code&gt;environ&lt;/code&gt; 배열입니다. 논리적 이름이이 기본 순서로 바뀌면</target>
        </trans-unit>
        <trans-unit id="4c771b3606fdd622281d6b0976acb1e8b29c8ab9" translate="yes" xml:space="preserve">
          <source>, and they will therefore all hold whatever was last in @array! It's similar to the problem demonstrated in the following C program:</source>
          <target state="translated">그러므로 그들은 모두 @array에서 마지막으로 있던 것을 잡아 줄 것입니다! 다음 C 프로그램에서 설명한 문제와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="ea985a0949a3673c272b8e0d49f54e041583c6c4" translate="yes" xml:space="preserve">
          <source>, and will be examined later.</source>
          <target state="translated">나중에 검토 할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c060f0c42881559e0dd3ac792535e84bb4d41c37" translate="yes" xml:space="preserve">
          <source>, and will free it.</source>
          <target state="translated">그리고 그것을 풀어줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="88f40c683f759884090876f282199945cd762ea4" translate="yes" xml:space="preserve">
          <source>, and with dynamic CRT DLL. This executable is a VIO application.</source>
          <target state="translated">동적 CRT DLL 이 실행 파일은 VIO 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="f5ffc67dd22fb19007fd6dce315aac48234ca530" translate="yes" xml:space="preserve">
          <source>, and writes change the value. In both cases the position in</source>
          <target state="translated">, 쓰기는 값을 변경합니다. 두 경우 모두</target>
        </trans-unit>
        <trans-unit id="4aa138eb7154eb226a5d7af0b04c19ffd9e3302e" translate="yes" xml:space="preserve">
          <source>, and you want the perl module be named as &lt;code&gt;Ext::Ension&lt;/code&gt; . If you need some preprocessor directives and/or linking with external libraries, see the flags &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; in &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt;.</source>
          <target state="translated">perl 모듈의 이름을 &lt;code&gt;Ext::Ension&lt;/code&gt; 으로 지정 하려고 합니다. 전 처리기 지시문이 필요하거나 외부 라이브러리와 연결해야하는 경우 &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt; 의 플래그 &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-L&lt;/code&gt; 및 &lt;code&gt;-l&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3432a5b49b7c2d6b8db782af36b21ccbf7c42da" translate="yes" xml:space="preserve">
          <source>, and you want to install the library in</source>
          <target state="translated">에 라이브러리를 설치하려고합니다.</target>
        </trans-unit>
        <trans-unit id="548642e975a7aad08e0815d9a988055ad22fd668" translate="yes" xml:space="preserve">
          <source>, api_revision is the &lt;code&gt;5&lt;/code&gt; . Prior to 5.5.640, the format was a floating point number, like 5.00563.</source>
          <target state="translated">api_revision은 &lt;code&gt;5&lt;/code&gt; 입니다. 5.5.640 이전의 형식은 5.00563과 같은 부동 소수점 수였습니다.</target>
        </trans-unit>
        <trans-unit id="188a87e7240228ac91dcd0c1a6be3953445dc39d" translate="yes" xml:space="preserve">
          <source>, api_subversion is the &lt;code&gt;1&lt;/code&gt; . See api_revision for full details.</source>
          <target state="translated">api_subversion은 &lt;code&gt;1&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a73dc0145a278edd9b0c16fb3b9861e0ad5e4534" translate="yes" xml:space="preserve">
          <source>, api_version is the &lt;code&gt;6&lt;/code&gt; . See api_revision for full details. As a special case, 5.5.0 is rendered in the old-style as 5.005. (In the 5.005_0x maintenance series, this was the only versioned directory in $sitelib.)</source>
          <target state="translated">api_version은 &lt;code&gt;6&lt;/code&gt; 입니다. 자세한 내용은 api_revision을 참조하십시오. 특별한 경우 5.5.0은 이전 스타일에서 5.005로 렌더링됩니다. (5.005_0x 유지 보수 시리즈에서이 디렉토리는 $ sitelib의 유일한 버전 디렉토리였습니다.)</target>
        </trans-unit>
        <trans-unit id="7a97d37b678b945a449c7d36a99037c11f17aab4" translate="yes" xml:space="preserve">
          <source>, are generated when</source>
          <target state="translated">때 생성됩니다</target>
        </trans-unit>
        <trans-unit id="1677c7c3fc729a817e4acfa05dba2ce6dccfb2e7" translate="yes" xml:space="preserve">
          <source>, are reserved for use in regexp notation. The metacharacters are</source>
          <target state="translated">는 정규 표현식 표기법으로 사용하도록 예약되어 있습니다. 메타 문자는</target>
        </trans-unit>
        <trans-unit id="5cb6624450c0504e407388bb9dd4d65ed8a21177" translate="yes" xml:space="preserve">
          <source>, are three-dimensional coordinates which define a point in three-dimensional space. They are based on a cylinder surface. The radius of the cylinder is &lt;b&gt;rho&lt;/b&gt;, also known as the</source>
          <target state="translated">는 3 차원 공간에서 점을 정의하는 3 차원 좌표입니다. 그들은 실린더 표면을 기반으로합니다. 실린더의 반경이고 &lt;b&gt;, &amp;rho;&lt;/b&gt; 또한라고도</target>
        </trans-unit>
        <trans-unit id="08ae511c03da62c55bc28f08c497a5cd99f011a3" translate="yes" xml:space="preserve">
          <source>, are three-dimensional coordinates which define a point in three-dimensional space. They are based on a sphere surface. The radius of the sphere is &lt;b&gt;rho&lt;/b&gt;, also known as the</source>
          <target state="translated">는 3 차원 공간에서 점을 정의하는 3 차원 좌표입니다. 그들은 구 표면을 기반으로합니다. 구의 반지름은 &lt;b&gt;rho&lt;/b&gt; 이며</target>
        </trans-unit>
        <trans-unit id="f21c678c3b392bc1e40f88b091f81477c570711c" translate="yes" xml:space="preserve">
          <source>, as at &lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc3066.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc3066.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://sunsite.dk/RFC/rfc/rfc3066.html&quot;&gt;http://sunsite.dk/RFC/rfc/rfc3066.html&lt;/a&gt; 과 같이</target>
        </trans-unit>
        <trans-unit id="66ae827ead4750ffe3370a29e9f62b3a997007cd" translate="yes" xml:space="preserve">
          <source>, as described in the next paragraph. Or, if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; is used with script name arguments, then for &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; the name</source>
          <target state="translated">다음 단락에 설명 된대로 또는 스크립트 이름 인수와 함께 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용을 사용&lt;/a&gt; 하는 경우 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 경우 이름</target>
        </trans-unit>
        <trans-unit id="8a69d8284e4806cb3167c85fd84978d404a739e1" translate="yes" xml:space="preserve">
          <source>, as if the chain of unbroken output somehow ensures the survival of the program. If speed is in any way an issue, this approach is wrong.</source>
          <target state="translated">마치 끊임없는 출력 체인이 어떻게 든 프로그램의 생존을 보장하는 것처럼 말입니다. 속도가 문제라면,이 방법은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2447a9b3daed4b590f24d0dda264bc7a27cfb571" translate="yes" xml:space="preserve">
          <source>, as in &lt;code&gt;nstore&lt;/code&gt; and &lt;code&gt;nstore_fd&lt;/code&gt; . At retrieval time, your data will be correctly restored so you don't have to know whether you're restoring from native or network ordered data. Double values are stored stringified to ensure portability as well, at the slight risk of loosing some precision in the last decimals.</source>
          <target state="translated">,에서와 같이 &lt;code&gt;nstore&lt;/code&gt; 및 &lt;code&gt;nstore_fd&lt;/code&gt; . 검색시 데이터가 올바르게 복원되므로 기본 또는 네트워크 순서 데이터에서 복원 중인지 알 필요가 없습니다. 마지막 10 진수의 정밀도를 약간 잃을 위험이 있지만 이식성을 보장하기 위해 이중 값이 문자열로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="44e9ce8f895c605d8b566ef8add0326c89ba8c44" translate="yes" xml:space="preserve">
          <source>, as many platforms have case-insensitive (or at least case-forgiving) filenames. Also, try not to have non-word characters (except for &lt;code&gt;.&lt;/code&gt;) in the names, and keep them to the 8.3 convention, for maximum portability, onerous a burden though this may appear.</source>
          <target state="translated">많은 플랫폼에서 대소 문자를 구분하지 않거나 최소한 대소 문자를 구분하는 파일 이름을 갖습니다. 또한, (제외 단어가 아닌 문자를하지 않으려 고 &lt;code&gt;.&lt;/code&gt; 이름에서), 그리고이 나타날 수 있지만 부담 부담, 최대 휴대 성, 8.3 규칙에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="86c4b8b976d7fe73a2f1d8c81c5d4231eab338d9" translate="yes" xml:space="preserve">
          <source>, as the other binaries are found relative to the perl binary.</source>
          <target state="translated">다른 바이너리는 perl 바이너리와 관련하여 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="66215e5d0d7fcdf3b23116101a903820fe1c82b9" translate="yes" xml:space="preserve">
          <source>, as we set the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in perl_destruct.</source>
          <target state="translated">perl_destruct에서 END 블록을 실행하는 PL_exit_flag PERL_EXIT_DESTRUCT_END를 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="f844aaaf402bacab2d52c88c71153b6f22ec5daa" translate="yes" xml:space="preserve">
          <source>, as well as make Perl the best language to use under OS/2. The secondary target is to try to make this work under DOS and Win* as well (but not &lt;b&gt;too&lt;/b&gt; hard).</source>
          <target state="translated">Perl을 OS / 2에서 사용하기에 가장 적합한 언어로 만듭니다. 두 번째 목표는 DOS 및 Win *에서도이 작업을 수행하는 것입니다 (그러나 &lt;b&gt;너무&lt;/b&gt; 어렵지는 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="246b91b96e62d4665dc1c91df63b1c10f4839a54" translate="yes" xml:space="preserve">
          <source>, as you'll need to understand the &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; API. A good place to start is by understanding how &lt;a href=&quot;#aggregate_tests&quot;&gt;aggregate_tests&lt;/a&gt; works.</source>
          <target state="translated">&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; API 를 이해해야합니다 . 시작하기 좋은 곳은 &lt;a href=&quot;#aggregate_tests&quot;&gt;aggregation_tests의&lt;/a&gt; 작동 방식을 이해하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="883a2167578552cc32e56e34c60f2a72656b4d09" translate="yes" xml:space="preserve">
          <source>, assumed to be a sequence of octets in</source>
          <target state="translated">의 옥텟 시퀀스로 가정</target>
        </trans-unit>
        <trans-unit id="e751512716d9aa9f5b3c28259b944c1f3b0c56d1" translate="yes" xml:space="preserve">
          <source>, attempts to bring some of the newer Perl API features to older versions of Perl, so that you can worry less about keeping track of old releases, but users can still reap the benefit.</source>
          <target state="translated">, 이전 버전의 Perl에 새로운 Perl API 기능 중 일부를 가져 오려고 시도하므로 이전 릴리스를 추적하는 것에 대해 걱정할 필요가 없지만 사용자는 여전히 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf124669e071fb32c507b660ca8a45e10a33382" translate="yes" xml:space="preserve">
          <source>, because the $1 variable is magical and read-only :</source>
          <target state="translated">$ 1 변수는 마술적이고 읽기 전용이기 때문에 :</target>
        </trans-unit>
        <trans-unit id="24f1b41d67d203257d6ce62a6d577842a88809d7" translate="yes" xml:space="preserve">
          <source>, because the reduced pollution of newer Perl versions is an important thing. It's so important that the old polluting ways of original Perl modules will not be supported very far into the future, and your module will almost certainly break! By adapting to it now, you'll gain compatibility and a sense of having done the electronic ecology some good.</source>
          <target state="translated">최신 Perl 버전의 오염 감소가 중요한 것이기 때문입니다. 오리지널 Perl 모듈의 오래된 오염 방법이 미래에 아주 멀리 지원되지 않을 것이며 모듈이 거의 확실하게 깨질 것입니다! 지금 적응함으로써, 당신은 호환성과 전자 생태학을 어느 정도 잘 해냈다는 느낌을 얻게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd35ebaf87e878605763ba0f4d65f6bf7f75dcc8" translate="yes" xml:space="preserve">
          <source>, because you were accidentally accessing &lt;code&gt;@aref&lt;/code&gt; , an undeclared variable, and it would thereby remind you to write instead:</source>
          <target state="translated">실수로 선언되지 않은 변수 인 &lt;code&gt;@aref&lt;/code&gt; 에 액세스했기 때문에 대신 작성하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fc90bbfbb3e4cc7f9f2ca2bbceaeebbd891dbeb9" translate="yes" xml:space="preserve">
          <source>, below takes 2 parameters and increments each directly.</source>
          <target state="translated">아래에서 2 개의 매개 변수를 사용하고 각각 직접 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a6beabe044ad8f9d1627ed533c6a9c88995aa997" translate="yes" xml:space="preserve">
          <source>, but $siteprefix might be</source>
          <target state="translated">이지만 $ siteprefix는</target>
        </trans-unit>
        <trans-unit id="6fce1e601c1523c8b2526a111e9e136024aa2709" translate="yes" xml:space="preserve">
          <source>, but are no longer available with</source>
          <target state="translated">으로 더 이상 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="64ad796371383427b4cd0ba4371e73bd89ebb1b2" translate="yes" xml:space="preserve">
          <source>, but because &lt;code&gt;Foo&lt;/code&gt; defines a symbol (the &lt;code&gt;exclaim&lt;/code&gt; subroutine), &lt;code&gt;base&lt;/code&gt; will not die when the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; fails to load</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 가 심볼 ( &lt;code&gt;exclaim&lt;/code&gt; 서브 루틴)을 정의 하기 때문에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 가로드 되지 않으면 &lt;code&gt;base&lt;/code&gt; 가 죽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61e7380af3179cca867b3885f99b22e74a3249cf" translate="yes" xml:space="preserve">
          <source>, but because you access them via the &lt;code&gt;maketext&lt;/code&gt; method, which looks for entries across all the &lt;code&gt;%Lexicon&lt;/code&gt; hashes in a language class</source>
          <target state="translated">언어 클래스의 모든 &lt;code&gt;%Lexicon&lt;/code&gt; 해시에서 항목을 찾는 &lt;code&gt;maketext&lt;/code&gt; 메소드 를 통해 액세스하기 때문에</target>
        </trans-unit>
        <trans-unit id="a42a597d11c292d0f56cbf1684a5eac6028a67a1" translate="yes" xml:space="preserve">
          <source>, but can also be</source>
          <target state="translated">이지만</target>
        </trans-unit>
        <trans-unit id="7909130b18300cbb98ea4bbe9e66d49642019dec" translate="yes" xml:space="preserve">
          <source>, but cannot come at the end of a string, because the backslash would be parsed as escaping the end quote.</source>
          <target state="translated">백 슬래시는 끝 따옴표를 이스케이프하는 것으로 구문 분석되므로 문자열 끝에 올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="42948efb81aca3fb2bd97534710c99990f79587a" translate="yes" xml:space="preserve">
          <source>, but from line 4.</source>
          <target state="translated">, 그러나 4 행부터.</target>
        </trans-unit>
        <trans-unit id="bd1670f6de47acc9c9b7267ab71cba06c196ce25" translate="yes" xml:space="preserve">
          <source>, but it causes no harm.)</source>
          <target state="translated">하지만 해를 끼치 지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="37120fa0734b652eb610ce4ae8b5f1bcc7d622f5" translate="yes" xml:space="preserve">
          <source>, but it does not contain all the characters from those blocks. It does not, for example, contain the digits 0-9, because those digits are shared across many scripts, and hence are in the &lt;code&gt;Common&lt;/code&gt; script.</source>
          <target state="translated">하지만 해당 블록의 모든 문자를 포함하지는 않습니다. 예를 들어 숫자는 0-9를 포함하지 않습니다. 그 숫자는 많은 스크립트에서 공유되므로 &lt;code&gt;Common&lt;/code&gt; 스크립트에 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1f2db577fa7893e92367cf784603b9d9d657f707" translate="yes" xml:space="preserve">
          <source>, but it has no problem linking to symbols in the</source>
          <target state="translated">이지만 기호의 링크에 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfb0016f55f0d3d559ba19fb54ebc0f455007395" translate="yes" xml:space="preserve">
          <source>, but it is a PM application.</source>
          <target state="translated">하지만 PM 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="bbe2c80423e439b3e4c161c99b0cea935717fc61" translate="yes" xml:space="preserve">
          <source>, but it is a very bad idea for two reasons.</source>
          <target state="translated">그러나 두 가지 이유로 매우 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="cdd23309b99a536c1f9d3df8a7c3d7430cce3c6b" translate="yes" xml:space="preserve">
          <source>, but it's really a 2D plane). The number</source>
          <target state="translated">하지만 실제로는 2D 평면입니다). 수</target>
        </trans-unit>
        <trans-unit id="b1b91a2c92813f244d7d492decf11786f03248cc" translate="yes" xml:space="preserve">
          <source>, but parameter order has been &quot;tidied up a little&quot;.</source>
          <target state="translated">그러나 매개 변수 순서는 &quot;약간 정리되었습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="114efd0755f2064562435a7b7db5cf78b23a339b" translate="yes" xml:space="preserve">
          <source>, but that the meaning of the code point has been</source>
          <target state="translated">코드 포인트의 의미는</target>
        </trans-unit>
        <trans-unit id="e48be256548eb3d87af3b99e921dd4b6fcf05890" translate="yes" xml:space="preserve">
          <source>, but the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; module was unable to locate this library. See &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;.</source>
          <target state="translated">하지만 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader의&lt;/a&gt; 모듈은이 라이브러리를 찾을 수 없습니다. &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bec967278894f864c70eea888e73e74018b65bcb" translate="yes" xml:space="preserve">
          <source>, but the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt; module will do both part</source>
          <target state="translated">이지만 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; 모듈은 두 부분을 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7536c70955b6a15d5f19153fc86efe49d7b1220b" translate="yes" xml:space="preserve">
          <source>, but the latter parts after</source>
          <target state="translated">하지만 후자의 부분은</target>
        </trans-unit>
        <trans-unit id="6b70056cdd55185377fa7fb36dcc37e7dfcc656b" translate="yes" xml:space="preserve">
          <source>, but there are legitimate cases where the polar style</source>
          <target state="translated">그러나 극지방 스타일의 합법적 인 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="083b89b36ef467b16cb732332b28ca7c58c02c6f" translate="yes" xml:space="preserve">
          <source>, but these are also sufficiently generic that the actual version of perl probably doesn't matter too much.)</source>
          <target state="translated">그러나 실제 버전의 perl은 그다지 중요하지 않을 정도로 충분히 일반적입니다.)</target>
        </trans-unit>
        <trans-unit id="440fbd28d07d5c795b6c02a88a168111c4c2b6d4" translate="yes" xml:space="preserve">
          <source>, but they are &quot;shared in the private address space of the process&quot;; this is possible because the address at which different sections of the</source>
          <target state="translated">그러나 &quot;프로세스의 개인 주소 공간에서 공유됩니다&quot;; 이것은 다른 섹션의 주소가</target>
        </trans-unit>
        <trans-unit id="e5d0a0fe8de2f9a20207b5984a8a5c6b03dfd271" translate="yes" xml:space="preserve">
          <source>, but those are both created with customizable</source>
          <target state="translated">하지만 모두 사용자 정의 가능</target>
        </trans-unit>
        <trans-unit id="30f76102144f22e473a3819c08962f84a35f7781" translate="yes" xml:space="preserve">
          <source>, but without any arguments at all, meaning it was called as &lt;code&gt;&amp;amp;infested&lt;/code&gt; . The next stack frame shows that the function &lt;code&gt;Ambulation::legs&lt;/code&gt; was called in list context from the</source>
          <target state="translated">그러나 인수가 전혀 없으므로 &lt;code&gt;&amp;amp;infested&lt;/code&gt; 라고 합니다. 다음 스택 프레임은 &lt;code&gt;Ambulation::legs&lt;/code&gt; 함수 가 목록 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="72ba937cc0e16bb306ca2b4bf857c5037ec4cf2e" translate="yes" xml:space="preserve">
          <source>, but you can also find it with &lt;code&gt;(get&lt;/code&gt;&lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt; . (Some platforms do not have a concept of a home directory.)</source>
          <target state="translated">그러나 &lt;code&gt;(get&lt;/code&gt; &lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt; 찾을 수도 있습니다 . (일부 플랫폼에는 홈 디렉토리 개념이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="d30cbc2585551375d5776769096b997571f847fa" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien and published posthumously by his son and literary executor, C.J.R. Tolkien, being the 3rd of the 12 volumes in Christopher's mammoth</source>
          <target state="translated">, JRR Tolkien에 의해 그의 아들과 문학적 집행 인 CJR Tolkien에 의해 사후에 출판되어 크리스토퍼의 매머드에서 12 권 3 위</target>
        </trans-unit>
        <trans-unit id="20a4c36993cdadf5b45a96ba6612a7047ca32e20" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien. The hardcover, 50th-anniversary edition of 2004 was used, published in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.</source>
          <target state="translated">JRR 톨킨 2004 년 50 주년 기념판 인 하드 커버는 영국에서 Harper Collins Publishers와 미국에서 Houghton Mifflin Company에 의해 출판되었습니다.</target>
        </trans-unit>
        <trans-unit id="efffb220c955e443cccb58c8907e329a0175c1d5" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien. The hardcover, 70th-anniversary edition of 2007 was used, published in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.</source>
          <target state="translated">JRR 톨킨 영국에서 Harper Collins Publishers와 Houghton Mifflin Company가 출판 한 2007 년 70 주년 기념 양 장본이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="074cc72ccfc535a7fd2e5dfd0338a00ba7d4e394" translate="yes" xml:space="preserve">
          <source>, by default. The format of the file looks like this:</source>
          <target state="translated">, 기본적으로. 파일 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15848886de9254fb610ee7af8ef183ea5520e125" translate="yes" xml:space="preserve">
          <source>, calling its check function, allocating a target if it needs one, and folding constants.</source>
          <target state="translated">확인 기능을 호출하고 필요한 경우 대상을 할당하고 상수를 접습니다.</target>
        </trans-unit>
        <trans-unit id="f1dcc83c1274d4f418815f27c4f79fd6d2c788ff" translate="yes" xml:space="preserve">
          <source>, chapter 20, or</source>
          <target state="translated">, 20 장 또는</target>
        </trans-unit>
        <trans-unit id="8ad183a82720f028dc83a25268edf18aae60bbed" translate="yes" xml:space="preserve">
          <source>, chapter 5.</source>
          <target state="translated">, 5 장.</target>
        </trans-unit>
        <trans-unit id="8ae0b48133bb856879ab9974c904d27120fd6b88" translate="yes" xml:space="preserve">
          <source>, consisting of a first and last name (no middle initial). The name class has four methods:</source>
          <target state="translated">, 성으로 구성됩니다 (중간 이니셜 없음). 이름 클래스에는 네 가지 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7deb52a5ffa60ddf7faa0bfee1739d2eee5281b4" translate="yes" xml:space="preserve">
          <source>, depending on the operating system. The variable &lt;code&gt;&quot;_exe&quot;&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; module holds the executable suffix, if any. Third, the VMS port carefully sets up &lt;code&gt;$^X&lt;/code&gt; and &lt;code&gt;$Config{perlpath}&lt;/code&gt; so that no further processing is required. This is just as well, because the matching regular expression used below would then have to deal with a possible trailing version number in the VMS file name.</source>
          <target state="translated">운영 체제에 따라 다릅니다. &lt;code&gt;Config&lt;/code&gt; 모듈 의 &lt;code&gt;&quot;_exe&quot;&lt;/code&gt; 변수 는 실행 가능 접미어가있는 경우이를 보유합니다. 셋째, VMS 포트는 &lt;code&gt;$^X&lt;/code&gt; 및 &lt;code&gt;$Config{perlpath}&lt;/code&gt; 신중하게 설정 하므로 추가 처리가 필요하지 않습니다. 아래에 사용되는 일치하는 정규식은 VMS 파일 이름에서 가능한 후행 버전 번호를 처리해야하기 때문에 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="da5a4498d5cd3fe648547701b8b083a3ff8ca97c" translate="yes" xml:space="preserve">
          <source>, described in &lt;a href=&quot;util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;util/fieldhash&quot;&gt;Hash :: Util :: FieldHash에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="191488e37062f1a4cf41a5aeb9e53d937285dc2f" translate="yes" xml:space="preserve">
          <source>, didn't find it, and set &lt;code&gt;$?&lt;/code&gt; to a non-zero value indicating failure.</source>
          <target state="translated">그것을 찾지 못하고 &lt;code&gt;$?&lt;/code&gt; 설정 했습니까? 실패를 나타내는 0이 아닌 값으로.</target>
        </trans-unit>
        <trans-unit id="bffed554a4db53bd8f296b3affa5430997fc3de5" translate="yes" xml:space="preserve">
          <source>, do</source>
          <target state="translated">, 하다</target>
        </trans-unit>
        <trans-unit id="94c2dbf1b9eb9f81052b5cb53ad3879e10f289ae" translate="yes" xml:space="preserve">
          <source>, do not fit into any of the other directories, but which, in addition, cannot use</source>
          <target state="translated">, 다른 디렉토리에 맞지 않지만 추가로 사용할 수없는 디렉토리</target>
        </trans-unit>
        <trans-unit id="aa0a59da47187262d9d4bfa48199c7bce6f4c216" translate="yes" xml:space="preserve">
          <source>, does the opposite of the</source>
          <target state="translated">반대의</target>
        </trans-unit>
        <trans-unit id="8fcd667169652690ef5e54800f7ff7538897e19e" translate="yes" xml:space="preserve">
          <source>, e.g. once you created a number under the influence of &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt; , all results from math operations with that number will also be rounded.</source>
          <target state="translated">예를 들어 &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt; 의 영향을 받아 숫자를 생성하면 해당 숫자를 사용한 수학 연산의 모든 결과도 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="5d483da9af92e1cedaee73a77b0f92e783cee701" translate="yes" xml:space="preserve">
          <source>, encountering an 8 or 9 will also trigger a warning. On return</source>
          <target state="translated">, 8 또는 9가 발생하면 경고가 트리거됩니다. 돌아올 때</target>
        </trans-unit>
        <trans-unit id="d2f5d265b5802df06743d0d56f8ee6faa03ca24f" translate="yes" xml:space="preserve">
          <source>, encountering an invalid character will also trigger a warning. On return</source>
          <target state="translated">잘못된 문자가 표시되면 경고가 트리거됩니다. 돌아올 때</target>
        </trans-unit>
        <trans-unit id="04677f3fac90b98f6c1dae663782f13b8cbddc16" translate="yes" xml:space="preserve">
          <source>, et al.) for your machine: &lt;code&gt;perl -MConfig -e 'print $Config{cc}'&lt;/code&gt; will tell you what to use.</source>
          <target state="translated">등) : 귀하의 컴퓨터 : &lt;code&gt;perl -MConfig -e 'print $Config{cc}'&lt;/code&gt; 가 무엇을 사용해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cad820714976d3b25c5367f0c02ee50a22785739" translate="yes" xml:space="preserve">
          <source>, etc) determined by &lt;b&gt;Configure&lt;/b&gt; (&lt;code&gt;$Config{'libpth'}&lt;/code&gt; ). This should ensure portability across a wide range of platforms.</source>
          <target state="translated">등)는 &lt;b&gt;Configure&lt;/b&gt; ( &lt;code&gt;$Config{'libpth'}&lt;/code&gt; )에 의해 결정됩니다 . 이를 통해 광범위한 플랫폼에서 이식성을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a212453865c3ae5d769c013e9814daf8f2a214a4" translate="yes" xml:space="preserve">
          <source>, etc.</source>
          <target state="translated">등</target>
        </trans-unit>
        <trans-unit id="b565fb66bcacd3184f91a476fa76a2a7c0432910" translate="yes" xml:space="preserve">
          <source>, etc. It is only used to set defaults for things in</source>
          <target state="translated">등의 항목에 대한 기본값을 설정하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="547884f80573a30a2c1775d0d189f35232800ed1" translate="yes" xml:space="preserve">
          <source>, etc.) show examples of general tied hashes, as does the &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; module. While these do not utilize &lt;b&gt;Tie::Hash&lt;/b&gt;, they serve as good working examples.</source>
          <target state="translated">등)은 &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 모듈 과 마찬가지로 일반적인 묶음 해시의 예를 보여줍니다 . 이들은 &lt;b&gt;Tie :: Hash를&lt;/b&gt; 사용하지 않지만 좋은 예제로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f1210937e081e362e85df120171033ff4b61361" translate="yes" xml:space="preserve">
          <source>, etc., not keeping separate files for each little release.</source>
          <target state="translated">각 작은 릴리스마다 별도의 파일을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="800135a8cf871bdccfdf925e7c9f67cb8dbd1d91" translate="yes" xml:space="preserve">
          <source>, even if the old Unicode string used EBCDIC.</source>
          <target state="translated">이전 유니 코드 문자열이 EBCDIC을 사용한 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7ae4a1230d3f708e9962358a9ef97eda0e7da8ca" translate="yes" xml:space="preserve">
          <source>, executes three Perl strings, extracting an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; from the first, a &lt;code&gt;float&lt;/code&gt; from the second, and a &lt;code&gt;char *&lt;/code&gt; from the third.</source>
          <target state="translated">, 세 개의 Perl 문자열을 실행 하여 첫 번째에서 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 를 추출 하고 두 번째에서 &lt;code&gt;float&lt;/code&gt; 을 추출 하고 &lt;code&gt;char *&lt;/code&gt; 세 번째에서 추출합니다.</target>
        </trans-unit>
        <trans-unit id="8592f41382d4e5c2d5d57b842dd51b103596cdc2" translate="yes" xml:space="preserve">
          <source>, first two will be issued to make the prompt standout, last two to make the input line standout.</source>
          <target state="translated">, 처음 두 개는 프롬프트를 돋보이게하고 마지막 두 개는 입력 라인을 돋보이게합니다.</target>
        </trans-unit>
        <trans-unit id="e326c61927837140eb9a99bc562c35954b12ff00" translate="yes" xml:space="preserve">
          <source>, followed by &quot;.&quot;, to represent the current directory. (&quot;.&quot; will not be appended if taint checks are enabled, either by &lt;code&gt;-T&lt;/code&gt; or by &lt;code&gt;-t&lt;/code&gt; .) If you need to modify this at runtime, you should use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; pragma to get the machine-dependent library properly loaded also:</source>
          <target state="translated">&quot;.&quot;다음에 현재 디렉토리를 나타냅니다. ( &lt;code&gt;-T&lt;/code&gt; 또는 &lt;code&gt;-t&lt;/code&gt; 에 의해 오염 검사가 활성화되어 있으면 &quot;&quot;. &quot;가 추가되지 않습니다 .) 런타임에이를 수정해야하는 경우, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 시스템 종속 라이브러리도 올바르게로드해야합니다. :</target>
        </trans-unit>
        <trans-unit id="e47c6b2622df17cb9ac51798532485ad11e9ba2e" translate="yes" xml:space="preserve">
          <source>, for &quot;interpreter threads&quot;.</source>
          <target state="translated">&quot;통역사 스레드&quot;의 경우</target>
        </trans-unit>
        <trans-unit id="3da21179cff23cf6f4725a6914c2f3067c8f2e68" translate="yes" xml:space="preserve">
          <source>, for example &lt;code&gt;constant_5&lt;/code&gt; for names 5 characters long. The default</source>
          <target state="translated">, 예를 들어 &lt;code&gt;constant_5&lt;/code&gt; 이름이 5자인 경우 입니다. 기본</target>
        </trans-unit>
        <trans-unit id="2fee34f87618999ee14e21bb687483c9271ed175" translate="yes" xml:space="preserve">
          <source>, for example).</source>
          <target state="translated">예를 들어).</target>
        </trans-unit>
        <trans-unit id="28da9ec75c809bccb5f08bba4f669c3533c7ba7b" translate="yes" xml:space="preserve">
          <source>, for example, this would include</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7c331f0b5befe1a82f2eeb7e08fd9a086e46b9f4" translate="yes" xml:space="preserve">
          <source>, for example, which is usually in</source>
          <target state="translated">예를 들어 일반적으로</target>
        </trans-unit>
        <trans-unit id="1611b180f41bef969e37c18e79566f4a39e16c29" translate="yes" xml:space="preserve">
          <source>, for instance, have been placed there rather than in</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="56372a1dac8b69b17464e5a00569b03f0872fcdf" translate="yes" xml:space="preserve">
          <source>, freeing all resources associated with it.</source>
          <target state="translated">, 관련 리소스를 모두 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f4b8256a6099f4e144fd62a3869c42ca7b38c688" translate="yes" xml:space="preserve">
          <source>, greater-than. Or Pod parsers may offer the alternative option of processing such unknown &quot;E&amp;lt;</source>
          <target state="translated">, 보다 큰. 또는 포드 파서는 알 수없는 &quot;E &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e7f34752016620eedb00a8cbd6624ed4757364db" translate="yes" xml:space="preserve">
          <source>, handing it NULL for the second argument:</source>
          <target state="translated">두 번째 인수에 대해 NULL을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="13918e9d4ee7ed5a5b531e3ce1c4548f829845bb" translate="yes" xml:space="preserve">
          <source>, has very helpful pictures:</source>
          <target state="translated">매우 유용한 사진이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2d144fe487b3bdc6b5822c043f233ce157080f" translate="yes" xml:space="preserve">
          <source>, have aliases</source>
          <target state="translated">, 별칭이 있습니다</target>
        </trans-unit>
        <trans-unit id="4f6137d9065b22f545ac392077aa91739c927e9e" translate="yes" xml:space="preserve">
          <source>, however, a module under</source>
          <target state="translated">그러나 아래 모듈</target>
        </trans-unit>
        <trans-unit id="fa65a22e2f2e07e3150f049e4c966e6fcd3df9ae" translate="yes" xml:space="preserve">
          <source>, if any. If it returns the empty string, use &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">, 만약에 어떠한. 빈 문자열을 반환하면 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8b8da23653cf06debe3b23d1da5fd0c356db27" translate="yes" xml:space="preserve">
          <source>, if any. If it returns the empty string, use &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">, 만약에 어떠한. 빈 문자열을 반환하면 &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6769873a1cbe047b8a844d6fbd4ad589c9faed9" translate="yes" xml:space="preserve">
          <source>, if given, is the file to which to write the formatted output. If</source>
          <target state="translated">지정된 경우 형식화 된 출력을 쓸 파일입니다. 만약</target>
        </trans-unit>
        <trans-unit id="77eafd03fdb7f9d16237f45a4ce317d87b94c553" translate="yes" xml:space="preserve">
          <source>, if non-null, provides a string (in SV form) containing code to be parsed. A copy of the string is made, so subsequent modification of</source>
          <target state="translated">null이 아닌 경우 구문 분석 할 코드가 포함 된 문자열 (SV 형식)을 제공합니다. 문자열의 사본이 만들어 지므로 이후의 수정</target>
        </trans-unit>
        <trans-unit id="030106d2304ec93f9cf5e7c3317d1e0cb410b3da" translate="yes" xml:space="preserve">
          <source>, if non-null, provides an input stream from which code will be read to be parsed. If both are non-null, the code in</source>
          <target state="translated">null이 아닌 경우, 구문 분석을 위해 코드를 읽을 입력 스트림을 제공합니다. 둘 다 null이 아닌 경우 코드</target>
        </trans-unit>
        <trans-unit id="6cbeb9fe895f728ef42c186aa976bba1c9ce0104" translate="yes" xml:space="preserve">
          <source>, if you're running setgid.</source>
          <target state="translated">setgid를 실행중인 경우</target>
        </trans-unit>
        <trans-unit id="0dbb5d893ddb3b24557057bead5ebb8bfe161473" translate="yes" xml:space="preserve">
          <source>, if you're running setuid.</source>
          <target state="translated">setuid를 실행중인 경우</target>
        </trans-unit>
        <trans-unit id="359ce93de57e677d41e4feae3db26ccadd5f4602" translate="yes" xml:space="preserve">
          <source>, in that order, unless the environment variable</source>
          <target state="translated">환경 변수가 아닌 한 순서대로</target>
        </trans-unit>
        <trans-unit id="790ae18f398610e33985ad234301f212b618f615" translate="yes" xml:space="preserve">
          <source>, in that order.</source>
          <target state="translated">, 그와 같은 순서로.</target>
        </trans-unit>
        <trans-unit id="a9ca71fd641028e60feb39e0200097fbb26b663e" translate="yes" xml:space="preserve">
          <source>, in the mode value it returns, if you need an approximation of the file's protections.</source>
          <target state="translated">파일 보호의 근사값이 필요한 경우 모드 값에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba423002f3a8458818555c6df33df9999f3fd327" translate="yes" xml:space="preserve">
          <source>, in which case it does a sendto(2) syscall. Returns the number of characters sent, or the undefined value on error. The sendmsg(2) syscall is currently unimplemented. See &lt;a href=&quot;../perlipc#UDP%3a-Message-Passing&quot;&gt;UDP: Message Passing in perlipc&lt;/a&gt; for examples.</source>
          <target state="translated">이 경우 sendto (2) syscall을 수행합니다. 전송 된 문자 수 또는 오류시 정의되지 않은 값을 반환합니다. sendmsg (2) syscall은 현재 구현되어 있지 않습니다. 예를 보려면 &lt;a href=&quot;../perlipc#UDP%3a-Message-Passing&quot;&gt;UDP : perlipc에서 메시지 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adc9b471306d3e563016072b65846bf606376045" translate="yes" xml:space="preserve">
          <source>, in which case it does a sendto(2) syscall. Returns the number of characters sent, or the undefined value on error. The sendmsg(2) syscall is currently unimplemented. See &lt;a href=&quot;perlipc#UDP%3a-Message-Passing&quot;&gt;UDP: Message Passing in perlipc&lt;/a&gt; for examples.</source>
          <target state="translated">이 경우 sendto (2) syscall을 수행합니다. 전송 된 문자 수 또는 오류시 정의되지 않은 값을 반환합니다. sendmsg (2) syscall은 현재 구현되어 있지 않습니다. 예를 보려면 &lt;a href=&quot;perlipc#UDP%3a-Message-Passing&quot;&gt;UDP : perlipc에서 메시지 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8770c2665fa7656dfe5c162a8df3a289203cc335" translate="yes" xml:space="preserve">
          <source>, included in the source distribution. Here's a bastardized, non-portable version of</source>
          <target state="translated">소스 배포에 포함됩니다. 다음은 개자식이며 휴대 할 수없는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="eb5f00bc57f8a74444c521b49f19146de255153e" translate="yes" xml:space="preserve">
          <source>, included with Perl 3.0. It was converted as a module with Perl 5.0, but had a version number only starting with Perl 5.6. Here is a small table with the matching Perl and &lt;code&gt;Sys::Syslog&lt;/code&gt; versions.</source>
          <target state="translated">Perl 3.0에 포함되어 있습니다. Perl 5.0이 포함 된 모듈로 변환되었지만 Perl 5.6으로 시작하는 버전 번호 만있었습니다. 다음은 Perl 및 &lt;code&gt;Sys::Syslog&lt;/code&gt; 버전 이 일치하는 작은 테이블입니다 .</target>
        </trans-unit>
        <trans-unit id="8ea24d1d602be3c931482d6a832964fc845b16f4" translate="yes" xml:space="preserve">
          <source>, instructs &lt;code&gt;autosplit&lt;/code&gt; to check the module currently being split to ensure that it includes a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; specification for the AutoLoader module, and skips the module if AutoLoader is not detected. $check defaults to 1.</source>
          <target state="translated">, instructs &lt;code&gt;autosplit&lt;/code&gt; to check the module currently being split to ensure that it includes a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; specification for the AutoLoader module, and skips the module if AutoLoader is not detected. $check defaults to 1.</target>
        </trans-unit>
        <trans-unit id="e6083d57ec1ee8a0d3d6d5459b1cec9032efce60" translate="yes" xml:space="preserve">
          <source>, intended for debugging or generating backtraces, and should not be relied upon. In particular, as &lt;code&gt;@_&lt;/code&gt; contains aliases to the caller's arguments, Perl does not take a copy of &lt;code&gt;@_&lt;/code&gt; , so &lt;code&gt;@DB::args&lt;/code&gt; will contain modifications the subroutine makes to &lt;code&gt;@_&lt;/code&gt; or its contents, not the original values at call time. &lt;code&gt;@DB::args&lt;/code&gt; , like &lt;code&gt;@_&lt;/code&gt; , does not hold explicit references to its elements, so under certain cases its elements may have become freed and reallocated for other variables or temporary values. Finally, a side effect of the current implementation is that the effects of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; can</source>
          <target state="translated">, 백 트레이스 디버깅 또는 생성을위한 것으로, 의존해서는 안됩니다. 로 특히, &lt;code&gt;@_&lt;/code&gt; 가 호출자의 주장에 별칭을 포함, 펄의 사본을지지 않습니다 &lt;code&gt;@_&lt;/code&gt; 있도록 &lt;code&gt;@DB::args&lt;/code&gt; 서브 루틴가 있습니다 수정이 포함됩니다 &lt;code&gt;@_&lt;/code&gt; 통화 시간이나 내용이 아니라 원래 값을. &lt;code&gt;@_&lt;/code&gt; 와 같이 &lt;code&gt;@DB::args&lt;/code&gt; 는 해당 요소에 대한 명시 적 참조를 보유하지 않으므로 특정 경우 해당 요소가 다른 변수 또는 임시 값에 대해 해제되고 재 할당 될 수 있습니다. 마지막으로, 현재 구현의 부작용의 효과 인 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; @_ CAN</target>
        </trans-unit>
        <trans-unit id="d6fb9ba10623dfd1aded621d9ddedd7e1c61500b" translate="yes" xml:space="preserve">
          <source>, intended for debugging or generating backtraces, and should not be relied upon. In particular, as &lt;code&gt;@_&lt;/code&gt; contains aliases to the caller's arguments, Perl does not take a copy of &lt;code&gt;@_&lt;/code&gt; , so &lt;code&gt;@DB::args&lt;/code&gt; will contain modifications the subroutine makes to &lt;code&gt;@_&lt;/code&gt; or its contents, not the original values at call time. &lt;code&gt;@DB::args&lt;/code&gt; , like &lt;code&gt;@_&lt;/code&gt; , does not hold explicit references to its elements, so under certain cases its elements may have become freed and reallocated for other variables or temporary values. Finally, a side effect of the current implementation is that the effects of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; can</source>
          <target state="translated">, 백 트레이스 디버깅 또는 생성을위한 것으로, 의존해서는 안됩니다. 로 특히, &lt;code&gt;@_&lt;/code&gt; 가 호출자의 주장에 별칭을 포함, 펄의 사본을지지 않습니다 &lt;code&gt;@_&lt;/code&gt; 있도록 &lt;code&gt;@DB::args&lt;/code&gt; 서브 루틴가 있습니다 수정이 포함됩니다 &lt;code&gt;@_&lt;/code&gt; 통화 시간이나 내용이 아니라 원래 값을. &lt;code&gt;@_&lt;/code&gt; 와 같이 &lt;code&gt;@DB::args&lt;/code&gt; 는 해당 요소에 대한 명시 적 참조를 보유하지 않으므로 특정 경우 해당 요소가 다른 변수 또는 임시 값에 대해 해제되고 재 할당 될 수 있습니다. 마지막으로, 현재 구현의 부작용의 효과 인 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; @_ CAN</target>
        </trans-unit>
        <trans-unit id="13eb87bdfb3a3624e2f9e8a8d87bc78f8db7280d" translate="yes" xml:space="preserve">
          <source>, into Perl's internal form. As with encode(),</source>
          <target state="translated">펄의 내부 형식으로. encode ()와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cfa0115c245a8b3ea3252178af8759b7405c3a1b" translate="yes" xml:space="preserve">
          <source>, is copied under</source>
          <target state="translated">아래에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6135a1a196ba8c00d8ec8b4a64ca9d1706801d" translate="yes" xml:space="preserve">
          <source>, is false, then any pre-existing &lt;code&gt;*.al&lt;/code&gt; files in the autoload directory are removed if they are no longer part of the module (obsoleted functions). $keep defaults to 0.</source>
          <target state="translated">, false이면 기존 &lt;code&gt;*.al&lt;/code&gt; 경우 autoload 디렉토리에있는 파일이 더 이상 모듈의 일부가 아닌 경우 제거됩니다 (폐기 된 기능). $ keep의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="51eed46bc6e5b10c08d79ee20d1f1a587cafafba" translate="yes" xml:space="preserve">
          <source>, is similar to</source>
          <target state="translated">, 비슷하다</target>
        </trans-unit>
        <trans-unit id="79817a35af4a945dfd5b54b07a8db380c4bf6155" translate="yes" xml:space="preserve">
          <source>, is the op type. It's an addition operator, so we want the type to be &lt;code&gt;ADDOP&lt;/code&gt; . We could specify this directly, but it's right there as the second token in the input, so we use &lt;code&gt;$2&lt;/code&gt; . The second parameter is the op's flags: 0 means &quot;nothing special&quot;. Then the things to add: the left and right hand side of our expression, in scalar context.</source>
          <target state="translated">, op 유형입니다. 덧셈 연산자이므로 타입이 &lt;code&gt;ADDOP&lt;/code&gt; 가되기를 원합니다 . 이것을 직접 지정할 수는 있지만 입력의 두 번째 토큰으로 바로 &lt;code&gt;$2&lt;/code&gt; 합니다. 두 번째 매개 변수는 op의 플래그입니다. 0은 &quot;특별 함 없음&quot;을 의미합니다. 그런 다음 추가 할 사항은 스칼라 컨텍스트에서 표현의 왼쪽과 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="c0080e719ea6b38d68de4ba8b7693bc8dba72e5a" translate="yes" xml:space="preserve">
          <source>, it doesn't redirect stderr to stdout.</source>
          <target state="translated">stderr을 stdout으로 리디렉션하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="664f4ea1afd52b971da3d2f089f2511da29b2351" translate="yes" xml:space="preserve">
          <source>, it is enough to have them on your path. One does not need to specify them explicitly (though this</source>
          <target state="translated">당신의 길에 그것들을 갖기에 충분합니다. 명시 적으로 지정할 필요는 없습니다 (이것에도 불구하고)</target>
        </trans-unit>
        <trans-unit id="01bd8dd935a29b3fddd9c06ac4b13a42b2abe139" translate="yes" xml:space="preserve">
          <source>, it is not necessarily the case that any output will be produced by this method. So don't rely on the fact that &lt;code&gt;$out&lt;/code&gt; is empty for an error test.</source>
          <target state="translated">반드시이 방법으로 출력이 생성되는 것은 아닙니다. 따라서 &lt;code&gt;$out&lt;/code&gt; 사실에 의존하지 마십시오 오류 테스트를 위해 이 비어 .</target>
        </trans-unit>
        <trans-unit id="9b3b34697471a7e2dc56c68064b05288c536a237" translate="yes" xml:space="preserve">
          <source>, it is still good practice to check the return code from</source>
          <target state="translated">, 여전히 리턴 코드를 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d91455e8d254597cb96fe4e096fe840d6a39837b" translate="yes" xml:space="preserve">
          <source>, it is substituted with</source>
          <target state="translated">으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bef723cdeef4c4aad0269573935dc64dcabf73" translate="yes" xml:space="preserve">
          <source>, just type:</source>
          <target state="translated">을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="ec7445398596752b90e13adb72725edcb5f55fb9" translate="yes" xml:space="preserve">
          <source>, left justified to fill</source>
          <target state="translated">, 채울 왼쪽 정렬</target>
        </trans-unit>
        <trans-unit id="58977f34d6981ce10f380c393153c619fec7c3b0" translate="yes" xml:space="preserve">
          <source>, library stuff in</source>
          <target state="translated">도서관 자료</target>
        </trans-unit>
        <trans-unit id="481f764300170b8cc2c8ab1fea2d90f4659012a0" translate="yes" xml:space="preserve">
          <source>, man pages in</source>
          <target state="translated">, 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="c1eff063fa64539df3525a8920a33c120431c1d5" translate="yes" xml:space="preserve">
          <source>, man pages into</source>
          <target state="translated">, 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="9a7745ab1fa8731e058fe3471019aec70206d842" translate="yes" xml:space="preserve">
          <source>, meaning it exposes several</source>
          <target state="translated">, 그것은 여러 노출을 의미</target>
        </trans-unit>
        <trans-unit id="23ecae591165a2e14c8b3c0c33e4b172cfbcd078" translate="yes" xml:space="preserve">
          <source>, meaning that functions and subroutines altered with &lt;code&gt;autodie&lt;/code&gt; will only change their behaviour until the end of the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;autodie&lt;/code&gt; 로 변경된 기능 및 서브 루틴 은 둘러싸는 블록, 파일 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 끝날 때까지만 동작을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="93ecb4223ec353ce10e70829975cf221b865ce31" translate="yes" xml:space="preserve">
          <source>, namely</source>
          <target state="translated">즉</target>
        </trans-unit>
        <trans-unit id="f22a8444b47d43b843adb69f4a032eaa8696f19f" translate="yes" xml:space="preserve">
          <source>, normally via</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="48a0cd2493fd04c9f828dcacdd2caee749e13027" translate="yes" xml:space="preserve">
          <source>, not</source>
          <target state="translated">아니</target>
        </trans-unit>
        <trans-unit id="c7bd8970e5dd3c5d725e534ee2e953570f617caa" translate="yes" xml:space="preserve">
          <source>, not byte.)</source>
          <target state="translated">바이트가 아닌)</target>
        </trans-unit>
        <trans-unit id="11afc5e199c01f78460727b395aceca036378181" translate="yes" xml:space="preserve">
          <source>, not its line. So in the examples below, you can see that every command needs the blank line after it, to end its paragraph. (And some older Pod translators may require the &lt;code&gt;=encoding&lt;/code&gt; line to have a following blank line as well, even though it should be legal to omit.)</source>
          <target state="translated">그 줄이 아닙니다. 따라서 아래 예에서 단락을 끝내려면 모든 명령 뒤에 빈 줄이 필요하다는 것을 알 수 있습니다. (그리고 일부 구형 포드 번역가는 &lt;code&gt;=encoding&lt;/code&gt; 생략해야하는 경우에도 행에 다음 빈 줄이 있어야 할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="da92391795f61ed6c37622d31636bf92df08886e" translate="yes" xml:space="preserve">
          <source>, not programs. For programs, use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; API.</source>
          <target state="translated">프로그램이 아닙니다. 프로그램의 경우 &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; API를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43dff97702ab1cbd05f2458bbf9136c2e78c118d" translate="yes" xml:space="preserve">
          <source>, of which</source>
          <target state="translated">그 중</target>
        </trans-unit>
        <trans-unit id="731aa264d48130cd3456e01ac07965045097c74f" translate="yes" xml:space="preserve">
          <source>, one pair per line. Strings used as values must be quoted. Barewords are treated as numbers.</source>
          <target state="translated">, 한 줄에 한 쌍. 값으로 사용 된 문자열은 인용해야합니다. 베어 워드는 숫자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="ba34082476e7f40b29ef9dab02566944508fe137" translate="yes" xml:space="preserve">
          <source>, one should call these API via a dynamic linking API. There is a subsystem in Perl to simplify such type of calls. A large number of entry points available for such linking is provided (see &lt;code&gt;entries_ordinals&lt;/code&gt; - and also &lt;code&gt;PMWIN_entries&lt;/code&gt; - in</source>
          <target state="translated">동적 연결 API를 통해 이러한 API를 호출해야합니다. 이러한 유형의 호출을 단순화하기 위해 Perl에 서브 시스템이 있습니다. 이러한 연결에 사용할 진입 점 많은 수의 (참조 제공 &lt;code&gt;entries_ordinals&lt;/code&gt; 도 - &lt;code&gt;PMWIN_entries&lt;/code&gt; 을 -에</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="942f527c84fd76c3bdcee70a53190e472c342844" translate="yes" xml:space="preserve">
          <source>, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba229fbb681a07aa0e4294378d9012aef942cf" translate="yes" xml:space="preserve">
          <source>, or Perl, such as the following:</source>
          <target state="translated">또는 Perl (예 : 다음) :</target>
        </trans-unit>
        <trans-unit id="55bfcc1de58da3cf74a6ff01324919bf5c853ff5" translate="yes" xml:space="preserve">
          <source>, or code, the &lt;code&gt;Rr&lt;/code&gt; are</source>
          <target state="translated">또는 코드, &lt;code&gt;Rr&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="ffbadeb5936aabdc02bac70dff1ebf6c39606cc2" translate="yes" xml:space="preserve">
          <source>, or editing</source>
          <target state="translated">또는 수정</target>
        </trans-unit>
        <trans-unit id="54a2f6c3e0bbeef4006390919d7b396d9e2b4da3" translate="yes" xml:space="preserve">
          <source>, or even</source>
          <target state="translated">, 또는</target>
        </trans-unit>
        <trans-unit id="579214064014c46082b00e9396995d722bdba307" translate="yes" xml:space="preserve">
          <source>, or even something such as D:</source>
          <target state="translated">또는 D와 같은 것 :</target>
        </trans-unit>
        <trans-unit id="dd3dabc0fe007ede17230bb03b9e7e04c79af333" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, calls the</source>
          <target state="translated">콜백이없는 경우</target>
        </trans-unit>
        <trans-unit id="00c06bb9d1dbbcd4ab3b41b1fd0ea954aed36a82" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, set errno to EINVAL. Or if the f is invalid, set errno to EBADF and return</source>
          <target state="translated">콜백이 없거나 errno를 EINVAL로 설정하십시오. 또는 f가 유효하지 않은 경우, errno를 EBADF로 설정하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1db68edf4d518c843f678ca5c930a828630ad1ff" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, set errno to EINVAL. Or if the f is invalid, set errno to EBADF.</source>
          <target state="translated">콜백이 없거나 errno를 EINVAL로 설정하십시오. 또는 f가 유효하지 않으면 errno를 EBADF로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3748c8a3236d4aa94aa312fa69d106a59ad85b20" translate="yes" xml:space="preserve">
          <source>, or if they compare equal with &lt;code&gt;eq&lt;/code&gt; .</source>
          <target state="translated">또는 &lt;code&gt;eq&lt;/code&gt; 와 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="5b8290ca58e4b337d2e457234b98a169d325bc21" translate="yes" xml:space="preserve">
          <source>, or printing using</source>
          <target state="translated">또는 다음을 사용하여 인쇄</target>
        </trans-unit>
        <trans-unit id="b97bcf82807eb070d0f663f018d630dbd84dfcb4" translate="yes" xml:space="preserve">
          <source>, or supply the stack size to &lt;code&gt;CreateThread()&lt;/code&gt;</source>
          <target state="translated">또는 스택 크기를 &lt;code&gt;CreateThread()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="345ba69cc2fea67ce22656b09e83f149b6b96534" translate="yes" xml:space="preserve">
          <source>, or the</source>
          <target state="translated">, 아니면 그</target>
        </trans-unit>
        <trans-unit id="fb2724928018abae8bc9e57d76c637373cc20ea5" translate="yes" xml:space="preserve">
          <source>, or to restore &lt;code&gt;$!&lt;/code&gt; to a meaningful state.</source>
          <target state="translated">또는 &lt;code&gt;$!&lt;/code&gt; 를 복원하십시오 ! 의미있는 상태로.</target>
        </trans-unit>
        <trans-unit id="e7d923ba957c225be8a72ed7a758380976e4b860" translate="yes" xml:space="preserve">
          <source>, or using a separate</source>
          <target state="translated">또는 별도의 사용</target>
        </trans-unit>
        <trans-unit id="9d0d91ae0fa92bac5f7cd8243e072cd7aef018d9" translate="yes" xml:space="preserve">
          <source>, or you could change certain filenames as needed:</source>
          <target state="translated">필요에 따라 특정 파일 이름을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9173cbefc36581419831ce91b8068d884c10958" translate="yes" xml:space="preserve">
          <source>, otherwise nothing.</source>
          <target state="translated">그렇지 않으면 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7f26ed799fd2c4c11b462f3e47d17d2a8c2c4ca" translate="yes" xml:space="preserve">
          <source>, overwriting the file with the new contents. With the &lt;code&gt;-p&lt;/code&gt; switch, Perl wraps a &lt;code&gt;while&lt;/code&gt; loop around the code you specify with &lt;code&gt;-e&lt;/code&gt; , and &lt;code&gt;-i&lt;/code&gt; turns on in-place editing. The current line is in &lt;code&gt;$_&lt;/code&gt; . With &lt;code&gt;-p&lt;/code&gt; , Perl automatically prints the value of &lt;code&gt;$_&lt;/code&gt; at the end of the loop. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more details.</source>
          <target state="translated">파일을 새 내용으로 덮어 씁니다. &lt;code&gt;-p&lt;/code&gt; 스위치를 사용하면 Perl 은 &lt;code&gt;-e&lt;/code&gt; 로 지정한 코드 주위에 &lt;code&gt;while&lt;/code&gt; 루프를 래핑 하고 &lt;code&gt;-i&lt;/code&gt; 는 전체 편집을 켭니다. 현재 줄은 &lt;code&gt;$_&lt;/code&gt; 입니다. &lt;code&gt;-p&lt;/code&gt; 를 사용하면 Perl 은 루프의 끝에서 &lt;code&gt;$_&lt;/code&gt; 값을 자동으로 인쇄합니다 . &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f8d0c96d2d2b2aafa291574fbf6087350a9988db" translate="yes" xml:space="preserve">
          <source>, performing the correct bookkeeping whenever a newline character is passed. This is the normal way to consume lexed text.</source>
          <target state="translated">개행 문자가 전달 될 때마다 올바른 부기를 수행합니다. 이것은 어휘 텍스트를 소비하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="70ef65c7d96d2bd885c5b7612ef8e3946ac09c5f" translate="yes" xml:space="preserve">
          <source>, period.) If the &lt;code&gt;/s&lt;/code&gt; modifier is specified, sequences of characters that were transliterated to the same character are squashed down to a single instance of the character.</source>
          <target state="translated">기간.)이 경우 &lt;code&gt;/s&lt;/code&gt; 수정이 지정된 동일한 문자 음역 된 문자 시퀀스가 문자의 단일 인스턴스로 내려 눌려있다.</target>
        </trans-unit>
        <trans-unit id="60007a5d7f11a8090fc943b98a4327b72a97056b" translate="yes" xml:space="preserve">
          <source>, pointing up from the &lt;b&gt;theta&lt;/b&gt;-plane.</source>
          <target state="translated">&lt;b&gt;세타&lt;/b&gt; 에서 가리키는&lt;b&gt;&lt;/b&gt; 평면 .</target>
        </trans-unit>
        <trans-unit id="c4604eaf3d1d886deab27e44f9f084a7eebe60a8" translate="yes" xml:space="preserve">
          <source>, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to C</source>
          <target state="translated">아마도 자동 플러시를 사용할 때에도 캐싱 문제로 인해 (일반적으로 C를 시도하기 전에 임시 파일에 쓴 후 잠시 기다려서 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="700f9b2825afd309ca4619c11e0d2d9e2e77290a" translate="yes" xml:space="preserve">
          <source>, provides access to the following elements of the Perl API that is not available in older Perl releases:</source>
          <target state="translated">, 이전 Perl 릴리스에서 사용할 수없는 다음 Perl API 요소에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65e4734d8fbb856132be8332b98473e9a6090b22" translate="yes" xml:space="preserve">
          <source>, rather than something that it</source>
          <target state="translated">, 뭔가가 아니라</target>
        </trans-unit>
        <trans-unit id="f4e7af1322b9da55c415c39f9e7ff17666928572" translate="yes" xml:space="preserve">
          <source>, regardless of where STDOUT may be redirected to.</source>
          <target state="translated">STDOUT을 리디렉션 할 수있는 위치에 관계없이</target>
        </trans-unit>
        <trans-unit id="778526e92b1eabba1ba99018f377d78629f31fa4" translate="yes" xml:space="preserve">
          <source>, respectively. &lt;code&gt;Re&lt;/code&gt; , &lt;code&gt;Im&lt;/code&gt; , &lt;code&gt;arg&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;rho&lt;/code&gt; , and &lt;code&gt;theta&lt;/code&gt; can be used also as mutators. The &lt;code&gt;cbrt&lt;/code&gt; returns only one of the solutions: if you want all three, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="translated">각각. &lt;code&gt;Re&lt;/code&gt; , &lt;code&gt;Im&lt;/code&gt; , &lt;code&gt;arg&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;rho&lt;/code&gt; 및 &lt;code&gt;theta&lt;/code&gt; 는 뮤 테이터로도 사용할 수 있습니다. &lt;code&gt;cbrt&lt;/code&gt; 반환 솔루션의 하나 : 당신이 세 가지를 모두 원하는 경우 사용 &lt;code&gt;root&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="c7afdf070db2b17186b849dea9ccbae8490266d4" translate="yes" xml:space="preserve">
          <source>, returns false; otherwise returns true.</source>
          <target state="translated">, false를 반환합니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="294f1e85971ddf3faffa14fe9c113e1fb49247ca" translate="yes" xml:space="preserve">
          <source>, run</source>
          <target state="translated">, 운영</target>
        </trans-unit>
        <trans-unit id="405cbdde629a3d6806c42e7498957799c0c7e735" translate="yes" xml:space="preserve">
          <source>, run:</source>
          <target state="translated">, 운영:</target>
        </trans-unit>
        <trans-unit id="bbe01f117bad48eb679b7748a19ed0966f1fba4d" translate="yes" xml:space="preserve">
          <source>, same with</source>
          <target state="translated">, 와 같다</target>
        </trans-unit>
        <trans-unit id="f3e57458037c62794ca5968e5d5cd43577521d99" translate="yes" xml:space="preserve">
          <source>, say, by issuing a command like</source>
          <target state="translated">예를 들어 다음과 같은 명령을 실행하여</target>
        </trans-unit>
        <trans-unit id="5cc91dd4b05c40ee3836cd8a51b18923b0309266" translate="yes" xml:space="preserve">
          <source>, says which packages are</source>
          <target state="translated">어떤 패키지인지</target>
        </trans-unit>
        <trans-unit id="42b0061f7d598e9846a6cb4198408f6e62c1c966" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;잘못된 데이터 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d832948372c398a9280338201f9092bcd809e94" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Making&quot;&gt;Making&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Making&quot;&gt;만들기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b3e32c9f4e25b163e62562a312fffb640ca872c" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee0c1ad5d5b448bff9df5b0bab0d2210c95e514e" translate="yes" xml:space="preserve">
          <source>, see below.</source>
          <target state="translated">아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4165c20cc560175b963da6bc4d77312447940a05" translate="yes" xml:space="preserve">
          <source>, setting &lt;code&gt;IS_NUMBER_TRAILING&lt;/code&gt; on the result.</source>
          <target state="translated">결과에 &lt;code&gt;IS_NUMBER_TRAILING&lt;/code&gt; 을 설정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2c6475f8f940fb92ea77b169a003790260386a" translate="yes" xml:space="preserve">
          <source>, shows how you can make use of</source>
          <target state="translated">를 활용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4dd3298c6d1bd33b1bddecc4419b76b21ac63113" translate="yes" xml:space="preserve">
          <source>, so G_DISCARD is specified. Even if</source>
          <target state="translated">이므로 G_DISCARD가 지정됩니다. 설사</target>
        </trans-unit>
        <trans-unit id="74317a6fb7a862910bba2f815752e8625fde38fb" translate="yes" xml:space="preserve">
          <source>, so here's some opportunity for some patching.</source>
          <target state="translated">패치가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="99d2a210f65f1b750acbf3003b2617a271c06034" translate="yes" xml:space="preserve">
          <source>, so that it does not create a link between a VIO session and the session of &lt;code&gt;pm_porg&lt;/code&gt; . (Such a link closes the VIO window.) E.g., this works with</source>
          <target state="translated">VIO 세션과 &lt;code&gt;pm_porg&lt;/code&gt; 세션간에 링크를 만들지 않습니다 . (이러한 링크는 VIO 창을 닫습니다.) 예를 들어</target>
        </trans-unit>
        <trans-unit id="8075e1a34058df98200120ef8d7277ea339786f0" translate="yes" xml:space="preserve">
          <source>, so the directories are searched through for linkable libraries again.</source>
          <target state="translated">디렉토리에서 링크 가능한 라이브러리를 다시 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2a07866af21835710bc9a6f54723c0b9d52d41d7" translate="yes" xml:space="preserve">
          <source>, so there is no special &quot;test_harness&quot; target.</source>
          <target state="translated">따라서 특별한 &quot;test_harness&quot;대상이 없습니다.</target>
        </trans-unit>
        <trans-unit id="39d37d1b4683a3fb66c0c9cb4ab07337524f0bd5" translate="yes" xml:space="preserve">
          <source>, so we may ignore them. The following list shows our errors, your results may differ:</source>
          <target state="translated">따라서 무시해도됩니다. 다음 목록은 우리의 오류를 보여줍니다, 결과는 다를 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cf90afd63e53252a0999bd1484eafacffe771fa0" translate="yes" xml:space="preserve">
          <source>, so you can't set sh with a &lt;code&gt;-D&lt;/code&gt; option, though you can override this (and startsh) with &lt;code&gt;-O -Dsh=&lt;i&gt;/bin/whatever&lt;/i&gt; -Dstartsh=whatever&lt;/code&gt;</source>
          <target state="translated">따라서 &lt;code&gt;-D&lt;/code&gt; 옵션으로 sh를 설정할 수는 없지만 &lt;code&gt;-O -Dsh=&lt;i&gt;/bin/whatever&lt;/i&gt; -Dstartsh=whatever&lt;/code&gt; &lt;i&gt;/ bin / whatever&lt;/i&gt; -Dstartsh = whatever 로이 (및 startsh)를 재정의 할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="f6d839faa6ea4a6b5e97b5d7bc7e2a56a2c58137" translate="yes" xml:space="preserve">
          <source>, so you might examine them if your console has only a limited number of cols.</source>
          <target state="translated">콘솔에 제한된 수의 직원 만있는 경우이를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2276c8b5c561790372b3ca4478529f74cf3b1e94" translate="yes" xml:space="preserve">
          <source>, some systems may have to replace the &lt;code&gt;#!&lt;/code&gt; line with a line containing just a colon, which will be politely ignored by Perl. Other systems can't control that, and need a totally devious construct that will work under any of</source>
          <target state="translated">, 일부 시스템은 &lt;code&gt;#!&lt;/code&gt; 를 교체해야 할 수도 있습니다 . 콜론 만 포함하는 줄이있는 줄은 Perl에 의해 정중하게 무시됩니다. 다른 시스템은 그것을 제어 할 수 없으며, 어떤 시스템에서도 작동하는 완전히 악의적 인 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a23e4409511836342736b9f02167e4000d6c659b" translate="yes" xml:space="preserve">
          <source>, sorcery, or wonder working. [From Middle English.]</source>
          <target state="translated">, 마술, 또는 궁금해하는 일. [중간 영어에서.]</target>
        </trans-unit>
        <trans-unit id="fd25e4b237d0de2bbe9c20b33a4bfd410153bc18" translate="yes" xml:space="preserve">
          <source>, specifically a listing of functions, macros, flags, and variables that may be used by extension writers. &lt;a href=&quot;#Undocumented-functions&quot;&gt;At the end&lt;/a&gt; is a list of functions which have yet to be documented. The interfaces of those are subject to change without notice. Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="translated">확장 기능 작성자가 사용할 수있는 함수, 매크로, 플래그 및 변수의 목록입니다. &lt;a href=&quot;#Undocumented-functions&quot;&gt;마지막&lt;/a&gt; 에는 아직 문서화되지 않은 기능 목록이 있습니다. 이들의 인터페이스는 예고없이 변경 될 수 있습니다. 여기에 나열되지 않은 것은 공개 API의 일부가 아니며 확장 작성자가 전혀 사용하지 않아야합니다. 이러한 이유로 확장 프로그램을 작성할 때는 proto.h에 나열된 기능을 맹목적으로 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3eace3842ea85c92144047677156c458ddf9586e" translate="yes" xml:space="preserve">
          <source>, standard input (</source>
          <target state="translated">표준 입력 (</target>
        </trans-unit>
        <trans-unit id="dacd7df5d67e86f62828aca14d84822ce104e1a0" translate="yes" xml:space="preserve">
          <source>, stripped of their leading &quot;pw_&quot; parts, namely &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; , &lt;code&gt;gid&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;quota&lt;/code&gt; , &lt;code&gt;comment&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;shell&lt;/code&gt; , and &lt;code&gt;expire&lt;/code&gt; . The &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , and &lt;code&gt;shell&lt;/code&gt; fields are tainted when running in taint mode.</source>
          <target state="translated">, &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; , &lt;code&gt;gid&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;quota&lt;/code&gt; , &lt;code&gt;comment&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;shell&lt;/code&gt; 및 &lt;code&gt;expire&lt;/code&gt; 와 같은 주요 &quot;pw_&quot;부분을 제거했습니다 . &lt;code&gt;passwd&lt;/code&gt; 를 , &lt;code&gt;gecos&lt;/code&gt; 및 &lt;code&gt;shell&lt;/code&gt; 더러운 모드에서 실행할 때 필드가 오염된다.</target>
        </trans-unit>
        <trans-unit id="957091e96ecfa54157cc0d4139600a9a7f9d62d7" translate="yes" xml:space="preserve">
          <source>, such as having $x run from 4..8 and $y run from 7 to 12? Hmm... here's the simple way:</source>
          <target state="translated">예를 들어 $ x는 4..8에서 실행되고 $ y는 7에서 12로 실행됩니다. 흠 ... 여기 간단한 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="656da3fea3006661322b08824becf92984dd0aa9" translate="yes" xml:space="preserve">
          <source>, such as within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file, even though the statements aren&amp;rsquo;t delimited by braces.</source>
          <target state="translated">문이 중괄호로 구분되지 않더라도 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 파일 내에서와 같이</target>
        </trans-unit>
        <trans-unit id="e08e5efec9e9e043f2abcc148b97927bd245fcae" translate="yes" xml:space="preserve">
          <source>, terminated by a newline.)</source>
          <target state="translated">개행 문자로 종료됩니다.)</target>
        </trans-unit>
        <trans-unit id="56e9bba4a207b86aa8dee08a4810ed2206bed901" translate="yes" xml:space="preserve">
          <source>, that is, a string beginning with a letter or underscore, and containing letters, underscores, and digits. In some cases, it may be a chain of identifiers, separated by &lt;code&gt;::&lt;/code&gt; (or by the slightly archaic &lt;code&gt;'&lt;/code&gt;); all but the last are interpreted as names of packages, to locate the namespace in which to look up the final identifier (see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt; for details). For a more in-depth discussion on identifiers, see &lt;a href=&quot;#Identifier-parsing&quot;&gt;Identifier parsing&lt;/a&gt;. It's possible to substitute for a simple identifier, an expression that produces a reference to the value at runtime. This is described in more detail below and in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">즉, 문자 또는 밑줄로 시작하고 문자, 밑줄 및 숫자를 포함하는 문자열입니다. 경우에 따라 &lt;code&gt;::&lt;/code&gt; 로 구분되는 식별자 체인 일 수 있습니다 (또는 약간 오래된 &lt;code&gt;'&lt;/code&gt; ). 마지막 식별자를 제외한 모든 이름은 패키지 이름으로 해석되어 최종 식별자를 찾을 네임 스페이스를 찾습니다 (자세한 내용 &lt;a href=&quot;perlmod#Packages&quot;&gt;은 perlmod의 패키지&lt;/a&gt; 참조). 식별자에 대한 자세한 내용은 &lt;a href=&quot;#Identifier-parsing&quot;&gt;식별자 구문 분석을&lt;/a&gt; 참조하십시오 . 런타임시 값에 대한 참조를 생성하는 표현식 인 간단한 식별자를 대체 할 수 있습니다. 이것은 아래와 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ebe898ca0c994ef13e630acb20dae497030f2a1" translate="yes" xml:space="preserve">
          <source>, that is, all elements in either A or in B but not in both. Think of it as an xor operation.</source>
          <target state="translated">즉, A 또는 B의 모든 요소 (둘 다의 요소는 아님)입니다. 그것을 xor 연산으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="fb1f30a577a9e343978298cf00190fde48358aaf" translate="yes" xml:space="preserve">
          <source>, that is, visible. This class consists of all alphanumeric characters and all punctuation characters.</source>
          <target state="translated">즉, 눈에.니다. 이 클래스는 모든 영숫자와 구두점으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="066c5c23cfa29a9ad5d5bae17b8dc8aeb40e3312" translate="yes" xml:space="preserve">
          <source>, that takes 2 integer parameters and simply returns their sum.</source>
          <target state="translated">즉, 2 개의 정수 매개 변수를 가져 와서 단순히 합계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72fb706cc8e6bb54ff9e026e88c6735beb29bae1" translate="yes" xml:space="preserve">
          <source>, that uses all three (long lines have been wrapped here):</source>
          <target state="translated">, 그것은 세 가지를 모두 사용합니다 (긴 줄은 여기에 싸여 있습니다).</target>
        </trans-unit>
        <trans-unit id="c4ff75230dcb5fc1cf1b33f194533921c76a1f94" translate="yes" xml:space="preserve">
          <source>, that was introduced in release 5.005. That model was deprecated, and has been removed in version 5.10.</source>
          <target state="translated">릴리스 5.005에서 도입되었습니다. 해당 모델은 더 이상 사용되지 않으며 버전 5.10에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a9bcafc2113daaac812f1518346b8bb3f4ad5920" translate="yes" xml:space="preserve">
          <source>, the</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="bbc14ad4bef82ce943fa383c1ed92a04f35ae9a8" translate="yes" xml:space="preserve">
          <source>, the C function required to call it is now a bit more complex.</source>
          <target state="translated">이를 호출하는 데 필요한 C 함수는 이제 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="4f74cf35d928e36b23641e736801a45580f16870" translate="yes" xml:space="preserve">
          <source>, the Perl library module for the extension, and</source>
          <target state="translated">확장을위한 Perl 라이브러리 모듈</target>
        </trans-unit>
        <trans-unit id="97438a08eda84c3bfc06c55a3bea0450b5e8f958" translate="yes" xml:space="preserve">
          <source>, the YACC grammar. Let's take the piece we need to construct the tree for &lt;code&gt;$a = $b + $c&lt;/code&gt;</source>
          <target state="translated">, YACC 문법. &lt;code&gt;$a = $b + $c&lt;/code&gt; 대한 트리를 구성하는 데 필요한 조각을 보자.</target>
        </trans-unit>
        <trans-unit id="d3a75d4660639ffe74acee5e5672e890c4814fdd" translate="yes" xml:space="preserve">
          <source>, the character used to separate elements in the command shell search &lt;code&gt;PATH&lt;/code&gt; .</source>
          <target state="translated">명령 쉘에서 &lt;code&gt;PATH&lt;/code&gt; 요소를 구분하는 데 사용되는 문자 .</target>
        </trans-unit>
        <trans-unit id="855214b2662c5c1d8b850e9feee34272d5af2679" translate="yes" xml:space="preserve">
          <source>, the file</source>
          <target state="translated">, 파일</target>
        </trans-unit>
        <trans-unit id="b1abcc10b694dd0025270a3db184b16a0fa38af6" translate="yes" xml:space="preserve">
          <source>, the final character is replicated till it is long enough. If the</source>
          <target state="translated">, 최종 캐릭터는 충분히 길어질 때까지 복제됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="dc1c5f98cffb439007008844e3a20f10ba40b400" translate="yes" xml:space="preserve">
          <source>, the first 16-bit unit being the</source>
          <target state="translated">첫 번째 16 비트 단위는</target>
        </trans-unit>
        <trans-unit id="cc0e409bb9bfdd351b146c8736f3bc9ef0f9e327" translate="yes" xml:space="preserve">
          <source>, the offset is relative to the start of the</source>
          <target state="translated">, 오프셋은</target>
        </trans-unit>
        <trans-unit id="f8c58b0bde45ddae936256535fca27e27919543c" translate="yes" xml:space="preserve">
          <source>, the process</source>
          <target state="translated">, 과정</target>
        </trans-unit>
        <trans-unit id="03d7028c2014dc1d6e04f06a4cda352756b2fdc6" translate="yes" xml:space="preserve">
          <source>, the reference can be used to store context information. The reference will be</source>
          <target state="translated">참조는 컨텍스트 정보를 저장하는 데 사용될 수 있습니다. 참조는</target>
        </trans-unit>
        <trans-unit id="503654fe46496135690eb6d481b68797ec8a3d06" translate="yes" xml:space="preserve">
          <source>, the resulting UTF8 flag is &lt;b&gt;on&lt;/b&gt;--</source>
          <target state="translated">, 결과 UTF8 플래그는 &lt;b&gt;에&lt;/b&gt; -</target>
        </trans-unit>
        <trans-unit id="3421355fa3000d28b30b10777add4df0ffdfb58a" translate="yes" xml:space="preserve">
          <source>, the resulting UTF8 flag is always &lt;b&gt;off&lt;/b&gt;.</source>
          <target state="translated">결과 UTF8 플래그는 항상 &lt;b&gt;꺼져&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c1b175b8542016c468fb6ae172829284030bdd" translate="yes" xml:space="preserve">
          <source>, the second requests a</source>
          <target state="translated">, 두 번째 요청은</target>
        </trans-unit>
        <trans-unit id="d0bac92aa165b5fcbe5d15dd2a3c4caac7ecba0a" translate="yes" xml:space="preserve">
          <source>, the table file is searched as</source>
          <target state="translated">테이블 파일은 다음과 같이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="80701e28ff7424b803181d8d7ce930f56b53f8c9" translate="yes" xml:space="preserve">
          <source>, the year 1995 is 95; the year 2001 is 101. Consult your system's &lt;code&gt;mktime()&lt;/code&gt; manpage for details about these and the other arguments.</source>
          <target state="translated">1995 년은 95 년입니다. 2001 년은 101입니다. 이러한 인수 및 기타 인수에 대한 자세한 내용은 시스템의 &lt;code&gt;mktime()&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9aea9e329eab2b9adcc970b72067fd0793c21cb5" translate="yes" xml:space="preserve">
          <source>, the year 1995 is 95; the year 2001 is 101. Consult your system's &lt;code&gt;strftime()&lt;/code&gt; manpage for details about these and the other arguments.</source>
          <target state="translated">1995 년은 95 년입니다. 2001 년은 101입니다. 이러한 인수 및 기타 인수에 대한 자세한 내용은 시스템의 &lt;code&gt;strftime()&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e189049326051591313d1c5688fafbf491aeaf0f" translate="yes" xml:space="preserve">
          <source>, then</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="2d7357221c057e21e0603b99d486d8d01e9f1d7b" translate="yes" xml:space="preserve">
          <source>, then each cached data item will be discarded and looked up afresh after the</source>
          <target state="translated">캐시 된 각 데이터 항목은 삭제되고</target>
        </trans-unit>
        <trans-unit id="0664c5508add1cbceda996e5b9d179cefd229787" translate="yes" xml:space="preserve">
          <source>, then extraction continues until</source>
          <target state="translated">을 추출 할 때까지 추출이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e9be5594e1731bd928c54113aa6bba78d9d10daa" translate="yes" xml:space="preserve">
          <source>, then the above system() is translated to</source>
          <target state="translated">위의 system ()은</target>
        </trans-unit>
        <trans-unit id="56ed743dadd72fa853ae506be49d8e7ef23c11ba" translate="yes" xml:space="preserve">
          <source>, then the verbose level will default to 1 if the exit status is less than 2 and will default to 0 otherwise.</source>
          <target state="translated">종료 상태가 2보다 작 으면 상세 수준은 기본적으로 1로 설정되고 그렇지 않으면 상세하게 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f388bd8ed28d6ec5148837e6886a6224018735fc" translate="yes" xml:space="preserve">
          <source>, then this is a no-op. Returns the number of octets necessary to represent the string as</source>
          <target state="translated">, 그러면 이것은 no-op입니다. 문자열을 다음과 같이 나타내는 데 필요한 옥텟 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3e93eac954f44cb11630b056721e2f26edaf81c2" translate="yes" xml:space="preserve">
          <source>, then we actually define $Lexicon{</source>
          <target state="translated">우리는 실제로 $ Lexicon {</target>
        </trans-unit>
        <trans-unit id="981255f700628f4a04da30c05e1f1345be156be9" translate="yes" xml:space="preserve">
          <source>, then we need to tell the &lt;code&gt;perl&lt;/code&gt; executable where it will be able to find the installed</source>
          <target state="translated">&lt;code&gt;perl&lt;/code&gt; 실행 파일에 설치된 곳을 찾을 수있는 곳 을 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="a97f83b483632edd32d7566630fdf0b16cc8ac52" translate="yes" xml:space="preserve">
          <source>, then you need to change the path following the &lt;code&gt;-L&lt;/code&gt; . If it complains that it can't find</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 다음에 오는 경로를 변경해야합니다 . 찾을 수 없다고 불평하면</target>
        </trans-unit>
        <trans-unit id="8911f644fb0560e46f52310cd354bac6558884ff" translate="yes" xml:space="preserve">
          <source>, there is no upper bound to the number of argument values taken.</source>
          <target state="translated">인수 값의 수에는 상한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8da1ee6882503c12e13b4824907fc0653955992a" translate="yes" xml:space="preserve">
          <source>, there is the entry:</source>
          <target state="translated">항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17e4f4b7efc3bfddeaaec858218e98d597284597" translate="yes" xml:space="preserve">
          <source>, there's no sense in being able to enable() or disable() processing.</source>
          <target state="translated">, enable () 또는 disable () 처리 기능은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5fc8a5e02b68374b799d5535dec84e053e8816a" translate="yes" xml:space="preserve">
          <source>, this directory contains modules which are only released as part of the core. Unlike</source>
          <target state="translated">이 디렉토리에는 코어의 일부로 만 릴리스 된 모듈이 포함되어 있습니다. 같지 않은</target>
        </trans-unit>
        <trans-unit id="133358768c237ba7c13e2e36ef10a76ee918db2a" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_REVISION&lt;/code&gt; .</source>
          <target state="translated">이를 &lt;code&gt;PERL_REVISION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5a14e004f2bf1eeac71229fa7540bd21823c5b" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; . This is unique to perl.</source>
          <target state="translated">이를 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; 이라고합니다 . 이것은 perl에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="714cd1f92b0d5db09f723a91ae82e2d32331d86e" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_VERSION&lt;/code&gt; .</source>
          <target state="translated">이를 &lt;code&gt;PERL_VERSION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba8cba024fa50efc2185c250a93c4684f50f8b2" translate="yes" xml:space="preserve">
          <source>, this method is a read-once operation. Call</source>
          <target state="translated">이 방법은 한 번의 읽기 작업입니다. 요구</target>
        </trans-unit>
        <trans-unit id="c5419160a5194a27a2e9670569f35b7ce53eec75" translate="yes" xml:space="preserve">
          <source>, this pragma looks in the table of standard Unicode names for the names</source>
          <target state="translated">이 pragma는 표준 유니 코드 이름 표에서 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b0263513f039c38507b3d70b68ab4c5b60dd7020" translate="yes" xml:space="preserve">
          <source>, though it simply delegates to the</source>
          <target state="translated">, 그것은 단순히</target>
        </trans-unit>
        <trans-unit id="18f1b111c2282bb1d52143843bb53f0e42f90748" translate="yes" xml:space="preserve">
          <source>, though it's possible that some systems will have</source>
          <target state="translated">일부 시스템은</target>
        </trans-unit>
        <trans-unit id="2399ea48546f62dda016b66c915a33efba5ece8f" translate="yes" xml:space="preserve">
          <source>, to check use</source>
          <target state="translated">사용 확인</target>
        </trans-unit>
        <trans-unit id="426b172db6893b6e9657e6e9162888abed4f4794" translate="yes" xml:space="preserve">
          <source>, to handle these for us. He suggests (assuming your string is contained in &lt;code&gt;$text&lt;/code&gt; ):</source>
          <target state="translated">우리를 위해 이것을 처리합니다. 그는 제안합니다 (문자열이 &lt;code&gt;$text&lt;/code&gt; 에 있다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="06a97e60b438c8a77e2cd328d323df609691a533" translate="yes" xml:space="preserve">
          <source>, to print out the UID of the process.</source>
          <target state="translated">프로세스의 UID를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="faee7867e8ebfc988e6546f4dcbe9ad6cb8c536a" translate="yes" xml:space="preserve">
          <source>, use a name recognized by the &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; module. Some pod formatters may try to guess between a Latin-1 or CP-1252 versus UTF-8 encoding, but they may guess wrong. It's best to be explicit if you use anything besides strict ASCII. Examples:</source>
          <target state="translated">&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 모듈 에서 인식되는 이름을 사용하십시오 . 일부 포드 포맷터는 라틴 -1 또는 CP-1252와 UTF-8 인코딩 사이를 추측하려고 시도하지만 잘못 추측 할 수 있습니다. 엄격한 ASCII 이외의 것을 사용하는 경우 명시 적으로하는 것이 가장 좋습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2a7de5b14d2a34b3272730993fe2dee6018ff3fd" translate="yes" xml:space="preserve">
          <source>, using embedded whitespace as the word delimiters. It can be understood as being roughly equivalent to:</source>
          <target state="translated">단어 구분 기호로 포함 된 공백을 사용합니다. 대략 다음과 같은 것으로 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e169e875a0353d0299dee5c8ba5ef4c88de61df4" translate="yes" xml:space="preserve">
          <source>, when it detects its program running with differing real and effective user or group IDs. The setuid bit in Unix permissions is mode 04000, the setgid bit mode 02000; either or both may be set. You can also enable taint mode explicitly by using the &lt;b&gt;-T&lt;/b&gt; command line flag. This flag is</source>
          <target state="translated">실제적이고 효과적인 사용자 또는 그룹 ID로 실행중인 프로그램을 감지 한 경우. Unix 권한의 setuid 비트는 mode 04000, setgid 비트 모드 02000입니다. 둘 중 하나 또는 둘 다 설정 될 수 있습니다. &lt;b&gt;-T&lt;/b&gt; 명령 행 플래그를 사용하여 오염 모드를 명시 적으로 활성화 할 수도 있습니다 . 이 깃발은</target>
        </trans-unit>
        <trans-unit id="a8fbd0202d5d59bb16abfc27a4a724fcbb5feb8c" translate="yes" xml:space="preserve">
          <source>, where</source>
          <target state="translated">, 어디</target>
        </trans-unit>
        <trans-unit id="8924bb9dd1f684020a4cba15af279a4d0d20f15e" translate="yes" xml:space="preserve">
          <source>, where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; is in effect, addition operations are forced to integer, whereas by default they are not, with the default behaviour being restored via &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 사실상, 더하기 연산은 정수로 강제되는 반면, 디폴트 동작은 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 복원 된다.</target>
        </trans-unit>
        <trans-unit id="9f41ab59091bd1f06b31a77ab9df95b2bc91cbcd" translate="yes" xml:space="preserve">
          <source>, where the &lt;code&gt;.al&lt;/code&gt; file has the same name as the subroutine, sans package. If such a file exists, AUTOLOAD will read and evaluate it, thus (presumably) defining the needed subroutine. AUTOLOAD will then &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; the newly defined subroutine.</source>
          <target state="translated">를 Where, &lt;code&gt;.al&lt;/code&gt; 파일이 서브 루틴 같은 이름을 가진, SAN은 패키지. 이러한 파일이 존재하면 AUTOLOAD는 파일을 읽고 평가하므로 필요한 서브 루틴을 정의합니다. AUTOLOAD는 것이다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 새로 정의 된 서브 루틴을.</target>
        </trans-unit>
        <trans-unit id="6aea3fc4b54551faf648d0b392baddc5ecb694ab" translate="yes" xml:space="preserve">
          <source>, whereas</source>
          <target state="translated">반면에</target>
        </trans-unit>
        <trans-unit id="26c934aa9a989416f6aadbafbbddd8e4c4e1b0e5" translate="yes" xml:space="preserve">
          <source>, which are abstract numbers. To use these numbers, various encodings are needed.</source>
          <target state="translated">추상 숫자입니다. 이 숫자를 사용하려면 다양한 인코딩이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="03649386e3bc4e7a816e4620f028cf88bdb23bf9" translate="yes" xml:space="preserve">
          <source>, which are actually the same program but behave differently depending on how they are called, provide another way of getting at C with Perl - they'll convert C structures and union declarations to Perl code. This is deprecated in favour of</source>
          <target state="translated">실제로 동일한 프로그램이지만 호출 방식에 따라 다르게 동작하는 Perl을 사용하여 C를 얻는 또 다른 방법을 제공합니다. C 구조와 공용체 선언을 Perl 코드로 변환합니다. 이것은 더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="0b151974aee7344a268313e90f86adde43defa23" translate="yes" xml:space="preserve">
          <source>, which creates a Perl counterpart for each of the extension's XSUBs. Don't worry about this part; leave that to the</source>
          <target state="translated">확장의 각 XSUB에 대해 Perl 대응을 작성합니다. 이 부분에 대해 걱정하지 마십시오. 그에게 맡겨</target>
        </trans-unit>
        <trans-unit id="0e4ba048b9a7447e52c228c8f75341de76908cb5" translate="yes" xml:space="preserve">
          <source>, which is always a good idea to supply if the number is known.</source>
          <target state="translated">숫자를 알고있는 경우 항상 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="17829fa2132953972da0914ccd97c3e350358fce" translate="yes" xml:space="preserve">
          <source>, which is currently used (when needed) by all regular non-possessive expression quantifiers, namely &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}&lt;/code&gt;, and &lt;code&gt;{n,m}?&lt;/code&gt;. Backtracking is often optimized internally, but the general principle outlined here is valid.</source>
          <target state="translated">, 모든 정규 비 포지 셔 티브 표현식 정량 자, 즉 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; 의해 현재 사용되고있는 (필요한 경우) ? , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}&lt;/code&gt; 및 &lt;code&gt;{n,m}?&lt;/code&gt; . 역 추적은 종종 내부적으로 최적화되지만 여기에 요약 된 일반적인 원칙은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="03d1757cccf78573ee0182fd5b28a73a2d407dd6" translate="yes" xml:space="preserve">
          <source>, which is either a decimal or a hexadecimal scalar designating a code point in the platform's native character set (extended to Unicode), or a string containing &lt;code&gt;U+&lt;/code&gt; followed by hexadecimals designating a Unicode code point. A leading 0 will force a hexadecimal interpretation, as will a hexadecimal digit that isn't a decimal digit.</source>
          <target state="translated">이는 플랫폼의 기본 문자 세트에서 코드 포인트를 지정하는 10 진수 또는 16 진 스칼라이거나 (유니 코드로 확장 됨) &lt;code&gt;U+&lt;/code&gt; 그 뒤에 16 진수가 유니 코드 코드 포인트를 지정하는 문자열 입니다. 선행 0은 10 진수가 아닌 16 진 숫자와 마찬가지로 16 진 해석을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="baf38326329741523715bffba499968b7d0e87ce" translate="yes" xml:space="preserve">
          <source>, which is not the winpid. Use &lt;code&gt;Cygwin::pid_to_winpid()&lt;/code&gt; and &lt;code&gt;Cygwin::winpid_to_pid()&lt;/code&gt; to translate between them.</source>
          <target state="translated">, 그것은 winpid가 아닙니다. 사용 &lt;code&gt;Cygwin::pid_to_winpid()&lt;/code&gt; 와 &lt;code&gt;Cygwin::winpid_to_pid()&lt;/code&gt; 그들 사이에 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0c16c9a97ba5ea538f1979d7f7d2fb2c51566d3a" translate="yes" xml:space="preserve">
          <source>, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">대괄호 안에있는 문자를 제외한 모든 문자와 일치합니다. 모두 &lt;code&gt;[...]&lt;/code&gt; 와 &lt;code&gt;[^...]&lt;/code&gt; 문자와 일치해야하며, 일치에 실패합니다. 그때</target>
        </trans-unit>
        <trans-unit id="b4454811042a626c864b08d42e1e9fe1a6f89db8" translate="yes" xml:space="preserve">
          <source>, which means it's going to be false in any sane context.</source>
          <target state="translated">이는 모든 상황에서 잘못 될 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86643bdbf232568e22729fc55a9633ebd6eca7bc" translate="yes" xml:space="preserve">
          <source>, which must be an encoding name that &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; recognizes. (Encode's list of supported encodings, in &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;, is useful here.) If the Pod parser cannot decode the declared encoding, it should emit a warning and may abort parsing the document altogether.</source>
          <target state="translated">인코딩 이름으로 &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 해야합니다 . (Encode &lt;a href=&quot;encode/supported&quot;&gt;:: Supported의 인코딩&lt;/a&gt; 지원 인코딩 목록은 여기서 유용합니다.) 포드 파서가 선언 된 인코딩을 디코딩 할 수없는 경우 경고가 발생하고 문서 파싱이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6946244e23fae74ad07a1325f15207b7d2a7623a" translate="yes" xml:space="preserve">
          <source>, which must be of type &lt;code&gt;STRLEN&lt;/code&gt; . Evaluates</source>
          <target state="translated">&lt;code&gt;STRLEN&lt;/code&gt; 유형이어야합니다 . 평가</target>
        </trans-unit>
        <trans-unit id="d6c4d6b2342d9336a15bff4441fdc806ef9f1dda" translate="yes" xml:space="preserve">
          <source>, which proceeds to try to execute the Perl program as a shell script. The shell executes the second line as a normal shell command, and thus starts up the Perl interpreter. On some systems $0 doesn't always contain the full pathname, so the &lt;b&gt;-S&lt;/b&gt; tells Perl to search for the program if necessary. After Perl locates the program, it parses the lines and ignores them because the variable $running_under_some_shell is never true. If the program will be interpreted by csh, you will need to replace &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; with &lt;code&gt;$*&lt;/code&gt; , even though that doesn't understand embedded spaces (and such) in the argument list. To start up</source>
          <target state="translated">Perl 프로그램을 쉘 스크립트로 실행하려고합니다. 쉘은 두 번째 행을 일반 쉘 명령으로 실행하여 Perl 인터프리터를 시작합니다. 일부 시스템에서는 $ 0에 항상 전체 경로 이름이 포함되지 않으므로 &lt;b&gt;-S&lt;/b&gt; 는 필요한 경우 프로그램을 검색하도록 Perl에 지시합니다. Perl이 프로그램을 찾은 후 $ running_under_some_shell 변수가 true가 아니므로 행을 구문 분석하고 무시합니다. 프로그램이 csh에 의해 해석 될 경우 인수 목록에 포함 된 공백 (및 기타)을 이해하지 못하더라도 &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; 를 &lt;code&gt;$*&lt;/code&gt; 로 바꿔야 합니다. 시작하려면</target>
        </trans-unit>
        <trans-unit id="d03971d8e8f6aae96dc846db2bbccfa1c43aa02c" translate="yes" xml:space="preserve">
          <source>, which processes the command line options, sets up any statically linked XS modules, opens the program and calls &lt;code&gt;yyparse&lt;/code&gt; to parse it.</source>
          <target state="translated">명령 행 옵션을 처리하고 정적으로 링크 된 XS 모듈을 설정하고 프로그램을 열고 &lt;code&gt;yyparse&lt;/code&gt; 를 호출 하여 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d38a80b5f16db8cd8592888fcbc6ecb5cbfb16e6" translate="yes" xml:space="preserve">
          <source>, which provides a core to which the Perl executable image and all Perl extensions are linked. It is generally located via the logical name</source>
          <target state="translated">이는 Perl 실행 가능 이미지와 모든 Perl 확장이 링크되는 코어를 제공합니다. 일반적으로 논리적 이름을 통해 위치합니다</target>
        </trans-unit>
        <trans-unit id="5d983c580d2a071fc02ee59631c5c9b624e3d132" translate="yes" xml:space="preserve">
          <source>, which requires that all applications use its LSP but which is not IFS-compatible, because clearly Perl will normally avoid using such an LSP.</source>
          <target state="translated">Perl은 일반적으로 그러한 LSP 사용을 피하기 때문에 모든 응용 프로그램은 LSP를 사용해야하지만 IFS와 호환되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ae6e3dda98fae8d31622d67dcd619e9e43cefbe" translate="yes" xml:space="preserve">
          <source>, which shall not modify any input argument, and</source>
          <target state="translated">입력 인수를 수정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b3cd0cd1142152776fc2bac2a2e89c7f139dc35e" translate="yes" xml:space="preserve">
          <source>, which should be a full pathname found amongst the %INC values.</source>
          <target state="translated">% INC 값에서 찾은 전체 경로 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9149915d9aff75a334b3f754d9220c360d8f395f" translate="yes" xml:space="preserve">
          <source>, which will be open in a manner compatible with the supplied mode string, the call is thus equivalent to &lt;code&gt;PerlIO_fdopen&lt;/code&gt; . In this case</source>
          <target state="translated">제공된 모드 문자열과 호환되는 방식으로 열리므로 호출은 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 과 같습니다 . 이 경우</target>
        </trans-unit>
        <trans-unit id="e29affdf4265c07a24e87380ae0fc86e7811b273" translate="yes" xml:space="preserve">
          <source>, which you'll also need) will reside in a directory that looks like this:</source>
          <target state="translated">), 다음과 같은 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b91b3346b580b5a72bcf19156716e69a40617494" translate="yes" xml:space="preserve">
          <source>, whichever is writable.</source>
          <target state="translated">쓰기 가능한 것 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1521c3e5024fb9d201b1510098752e0fbfadaa8f" translate="yes" xml:space="preserve">
          <source>, whichever is writable. For example Solaris and IRIX system may prefer &lt;code&gt;&quot;stream&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;unix&quot;&lt;/code&gt; .</source>
          <target state="translated">쓰기 가능한 것 중 하나입니다. 예를 들어 Solaris 및 IRIX 시스템은 &lt;code&gt;&quot;unix&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;stream&quot;&lt;/code&gt; 을 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af1e6ea7c63a016f19ff1f20a75d322ca9d606dc" translate="yes" xml:space="preserve">
          <source>, will copy the files onto the NetWare server.</source>
          <target state="translated">파일을 NetWare 서버에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="542c63558f82cc60301de087610ae8d702c1444e" translate="yes" xml:space="preserve">
          <source>, will the expression be treated as boolean. Otherwise, smartmatching is used.</source>
          <target state="translated">, 표현식이 부울로 처리됩니다. 그렇지 않으면 스마트 매칭이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="434f72658ad0db42fd472dfe71b1d976ec669e77" translate="yes" xml:space="preserve">
          <source>, with a function</source>
          <target state="translated">기능과 함께</target>
        </trans-unit>
        <trans-unit id="22b8ca3ac41e774d45998884fc92354c868b6717" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a Base64 string. Multiple</source>
          <target state="translated">결과는 Base64 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="677a292feedbf48a082a00acc87c06021be08f63" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a binary string. Multiple</source>
          <target state="translated">결과는 이진 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="2a314e18b1b4fa535233316b8d18d5a2b276138b" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a hexadecimal string. Multiple</source>
          <target state="translated">결과는 16 진 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="b99d3c828cce13fde4656fc0fc0105ea617a8091" translate="yes" xml:space="preserve">
          <source>, yet another utility under Encode/bin directory.</source>
          <target state="translated">Encode / bin 디렉토리의 또 다른 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="51f521f34eb9dfa708aba7876dbcd25e0b33259e" translate="yes" xml:space="preserve">
          <source>, you are encouraged to use &lt;code&gt;catpath()&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;catpath()&lt;/code&gt; 를 사용하는 것이 좋습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="50c611f29a4f4c3132ca368f4ed25bf3706ad044" translate="yes" xml:space="preserve">
          <source>, you are encouraged to use &lt;code&gt;catpath()&lt;/code&gt; to concatenate</source>
          <target state="translated">&lt;code&gt;catpath()&lt;/code&gt; 를 사용 하여 연결 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e0466cebd730e6f201e1dc3e0fa65a5e7288ff5" translate="yes" xml:space="preserve">
          <source>, you can often gain a 10-25% performance benefit by rebuilding it to link with a static libc.a instead. This will make a bigger perl executable, but your Perl programs (and programmers) may thank you for it. See the</source>
          <target state="translated">정적 libc.a와 연결되도록 다시 빌드하면 성능이 10-25 % 향상되는 경우가 많습니다. 이렇게하면 더 큰 perl을 실행할 수 있지만 Perl 프로그램 (및 프로그래머)이이를 감사하게 생각할 수 있습니다. 참조</target>
        </trans-unit>
        <trans-unit id="1d331b88bfc2c65e1619a12d857298426cd92d30" translate="yes" xml:space="preserve">
          <source>, you can recompile with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , which will cause the addresses of all those leaked SVs to be dumped along with details as to where each SV was originally allocated. This information is also displayed by Devel::Peek. Note that the extra details recorded with each SV increases memory usage, so it shouldn't be used in production environments. It also converts &lt;code&gt;new_SV()&lt;/code&gt; from a macro into a real function, so you can use your favourite debugger to discover where those pesky SVs were allocated.</source>
          <target state="translated">&lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 를 사용 하여 다시 컴파일 할 수 있습니다. 이렇게하면 유출 된 모든 SV의 주소가 각 SV가 원래 할당 된 위치에 대한 세부 정보와 함께 덤프됩니다. 이 정보는 Devel :: Peek에서도 표시됩니다. 각 SV에 기록 된 추가 정보는 메모리 사용량을 증가 시키므로 프로덕션 환경에서는 사용하지 않아야합니다. 또한 &lt;code&gt;new_SV()&lt;/code&gt; 를 매크로에서 실제 함수로 변환 하므로 선호하는 디버거를 사용하여 성가신 SV가 할당 된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3880ec30cc2d5ebf349c1017f97c2cb7881519a" translate="yes" xml:space="preserve">
          <source>, you do not need to change anything. However, for perl to find the library if you use a different path, you need to &lt;code&gt;set PERLLIB_PREFIX&lt;/code&gt; in</source>
          <target state="translated">, 아무것도 변경할 필요가 없습니다. 그러나 다른 경로를 사용하는 경우 perl이 라이브러리를 찾으려면 &lt;code&gt;set PERLLIB_PREFIX&lt;/code&gt; 를 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="022efe6a8ac93e208088ce727015f5bc2ef4dbd9" translate="yes" xml:space="preserve">
          <source>, you may need to be extra careful when running Configure to not to confuse Configure and Perl about which libraries to use. Being confused will show up for example as &quot;dyld&quot; errors about symbol problems, for example during &quot;make test&quot;. The safest bet is to run Configure as</source>
          <target state="translated">사용할 라이브러리에 대해 Configure 및 Perl을 혼동하지 않도록 Configure를 실행할 때 특히주의해야합니다. 혼동되면 예를 들어 &quot;make test&quot;와 같이 심볼 문제에 대한 &quot;dyld&quot;오류로 표시됩니다. 가장 안전한 방법은 다음으로 구성을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="021d52a6c6807f7976d981e9998715c511d43a0f" translate="yes" xml:space="preserve">
          <source>, you may need to reboot in between. Check EMX runtime by running</source>
          <target state="translated">사이에 재부팅해야 할 수도 있습니다. 다음을 실행하여 EMX 런타임을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a357b8113a9e22a3eef60456621417078f84daeb" translate="yes" xml:space="preserve">
          <source>, you must explicitly &lt;code&gt;share()&lt;/code&gt; variables between the threads.</source>
          <target state="translated">스레드간에 변수를 명시 적으로 &lt;code&gt;share()&lt;/code&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a4cfad2d578d98a081e5b91f17f3d149edfc150" translate="yes" xml:space="preserve">
          <source>, you need to change the path following the &lt;code&gt;-I&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-I&lt;/code&gt; 다음에 경로를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a08a1ac95983f38539380ed39b4f27bf1fbb7125" translate="yes" xml:space="preserve">
          <source>, you probably don't expect it to run on both Unix and CP/M.)</source>
          <target state="translated">, 아마도 유닉스와 CP / M 모두에서 실행될 것으로 기대하지는 않을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="a2d62578b1a9440577c8f95b2ea11ee98fbc944b" translate="yes" xml:space="preserve">
          <source>, you should always try to use</source>
          <target state="translated">, 당신은 항상 사용하려고합니다</target>
        </trans-unit>
        <trans-unit id="80d72f99e8c254f3d7a046575ea8e94531af8c78" translate="yes" xml:space="preserve">
          <source>, you should expect a bit of whimsy.</source>
          <target state="translated">약간의 기발한 기대를해야합니다.</target>
        </trans-unit>
        <trans-unit id="87c1c3490c4a0eecd8de20c3cc69883c07b4ba2e" translate="yes" xml:space="preserve">
          <source>, you will need to run &lt;code&gt;make regen_headers&lt;/code&gt; to force a rebuild of</source>
          <target state="translated">, &lt;code&gt;make regen_headers&lt;/code&gt; 를 실행해야합니다. 를</target>
        </trans-unit>
        <trans-unit id="1d419e3c5bc7f5ea63240258fff8fb0654e4cb8f" translate="yes" xml:space="preserve">
          <source>, you'll have to rebuild Perl to incorporate a new extension. You should edit the main</source>
          <target state="translated">새 확장을 통합하려면 Perl을 다시 빌드해야합니다. 메인을 편집해야합니다</target>
        </trans-unit>
        <trans-unit id="fdf357edc958470810c296ee519d97c4d17b676d" translate="yes" xml:space="preserve">
          <source>, you'll probably need to subclass &lt;a href=&quot;grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; too, or else it'll never get used.</source>
          <target state="translated">&lt;a href=&quot;grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 도 서브 클래 싱해야합니다. 그렇지 않으면 절대 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ce53fda25a5521f4426b98fc34aff8c177f37f2" translate="yes" xml:space="preserve">
          <source>, you'll see the results of using</source>
          <target state="translated">, 사용 결과가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="3085b957b5d3ec5b39e504d18f16596194b3898c" translate="yes" xml:space="preserve">
          <source>, your issue is likely to receive more attention. You may want to start with &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for pointers to common traps that new (and experienced) Perl programmers run into.</source>
          <target state="translated">, 문제가 더 많은 관심을받을 것으로 보입니다. 새로운 Perl 프로그래머가 경험하는 일반적인 트랩에 대한 포인터를 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; 으로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="001b22edb2fbe2a87d8cf96a1c82ed43978ed889" translate="yes" xml:space="preserve">
          <source>,...) was.</source>
          <target state="translated">,...) 였다.</target>
        </trans-unit>
        <trans-unit id="ad72be5c0d7fc1b8f77fe6354bc971428558be05" translate="yes" xml:space="preserve">
          <source>,...params...) can give up with:</source>
          <target state="translated">, ... params ...)는 다음을 포기할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec37b4898d8fa711d06edd7a451aef6a2e60168" translate="yes" xml:space="preserve">
          <source>,...params...) gives up and calls:</source>
          <target state="translated">, ... params ...) 포기하고 호출 :</target>
        </trans-unit>
        <trans-unit id="722cba868d267a82e7010bf92e684897c598bb02" translate="yes" xml:space="preserve">
          <source>,as that program depends on functionality which the test file itself is testing.</source>
          <target state="translated">이 프로그램은 테스트 파일 자체가 테스트하는 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="92ec08014ef6e3572ce18cd210390b5494877bb0" translate="yes" xml:space="preserve">
          <source>- Home directory.</source>
          <target state="translated">-홈 디렉토리.</target>
        </trans-unit>
        <trans-unit id="bc43692f24635fad130f4c0b7605b093da1c6edc" translate="yes" xml:space="preserve">
          <source>- Root for accessing some special files, i.e.</source>
          <target state="translated">-일부 특수 파일에 액세스하기위한 루트, 즉</target>
        </trans-unit>
        <trans-unit id="3173574745b2a94d3ecbd9aad3aac008e1c75cf4" translate="yes" xml:space="preserve">
          <source>- Rows/cols for console.</source>
          <target state="translated">-콘솔 용 행 / 콜.</target>
        </trans-unit>
        <trans-unit id="2a8384c45900eafb56b7372e12c87d95403210dd" translate="yes" xml:space="preserve">
          <source>- Size for console font.</source>
          <target state="translated">-콘솔 글꼴의 크기.</target>
        </trans-unit>
        <trans-unit id="ec35a1fcb1bf308cd068a9bee9a8176d037f75a7" translate="yes" xml:space="preserve">
          <source>- Tempdir.</source>
          <target state="translated">-Tempdir.</target>
        </trans-unit>
        <trans-unit id="a58249eb112a301215e90f4449910a61cde2399f" translate="yes" xml:space="preserve">
          <source>- may fail on recent cygwin installs.</source>
          <target state="translated">-최근 cygwin 설치에서 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa47440f5821f7fcd42136d522f634642510d036" translate="yes" xml:space="preserve">
          <source>- most probably RSX - decided to implement.</source>
          <target state="translated">-아마도 RSX-구현하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="586ed566ba05975ffadf370f1c6ecf01acb6d01a" translate="yes" xml:space="preserve">
          <source>- non-zero if the current XSUB has any aliases declared with &lt;code&gt;ALIAS&lt;/code&gt; .</source>
          <target state="translated">-현재 XSUB에 &lt;code&gt;ALIAS&lt;/code&gt; 로 선언 된 별칭이 있으면 0이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c30b5265745c008d5265e386cbdf1dab87c47bde" translate="yes" xml:space="preserve">
          <source>- or with Perl!</source>
          <target state="translated">-아니면 펄!</target>
        </trans-unit>
        <trans-unit id="6a5e7bde75d15d42f045f6c58b079f3857fc8edd" translate="yes" xml:space="preserve">
          <source>- see &lt;a href=&quot;https://rt.perl.org/Ticket/Display.html?id=78502&quot;&gt;https://rt.perl.org/Ticket/Display.html?id=78502&lt;/a&gt;</source>
          <target state="translated">- 참조 &lt;a href=&quot;https://rt.perl.org/Ticket/Display.html?id=78502&quot;&gt;https://rt.perl.org/Ticket/Display.html?id=78502&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eb095bd84343fa039df7c15c40c25123fcea513" translate="yes" xml:space="preserve">
          <source>- the argument stack offset of the argument. ie. 0 for the first argument, etc.</source>
          <target state="translated">-인수의 인수 스택 오프셋 즉. 첫 번째 인수 등의 경우 0</target>
        </trans-unit>
        <trans-unit id="b6fd27381e71b1b032ec8f7e7eff0c7d9ea88d03" translate="yes" xml:space="preserve">
          <source>- the full name of the XSUB, with including the &lt;code&gt;PACKAGE&lt;/code&gt; name, with any &lt;code&gt;PREFIX&lt;/code&gt; stripped. This is the non-ALIAS name.</source>
          <target state="translated">- 포함와 XSUB의 전체 이름, &lt;code&gt;PACKAGE&lt;/code&gt; 하나와, 이름을 &lt;code&gt;PREFIX&lt;/code&gt; 제거. 이것은 별칭이 아닌 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac306b045d6143c752e53a46375c4935a0210024" translate="yes" xml:space="preserve">
          <source>- the name of the input or output variable, eg. RETVAL for return values.</source>
          <target state="translated">-입력 또는 출력 변수의 이름 (예 : 리턴 값에 대한 RETVAL</target>
        </trans-unit>
        <trans-unit id="98a3328bb076d8bd2503f9a31ae579ee61669de1" translate="yes" xml:space="preserve">
          <source>- the package specified by the most recent &lt;code&gt;PACKAGE&lt;/code&gt; keyword.</source>
          <target state="translated">-가장 최근의 &lt;code&gt;PACKAGE&lt;/code&gt; 키워드로 지정된 패키지 .</target>
        </trans-unit>
        <trans-unit id="f124ed3063522cd2ff8b8f4829e2a95edb5ad519" translate="yes" xml:space="preserve">
          <source>- the raw C type of the parameter, any &lt;code&gt;:&lt;/code&gt; replaced with &lt;code&gt;_&lt;/code&gt; . e.g. for a type of &lt;code&gt;Foo::Bar&lt;/code&gt; ,</source>
          <target state="translated">- 매개 변수의 원시 C 타입은, 어떤이 &lt;code&gt;:&lt;/code&gt; 로 대체 &lt;code&gt;_&lt;/code&gt; . 예를 들어 &lt;code&gt;Foo::Bar&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="76a588dc109d4b97adb8746f1e4fa8bce8a72431" translate="yes" xml:space="preserve">
          <source>- the stack entry, that the parameter is input from or output to, e.g. &lt;code&gt;ST(0)&lt;/code&gt;</source>
          <target state="translated">-스택 엔트리, 매개 변수가 입력 또는 출력되는 것, 예 : &lt;code&gt;ST(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9cef40f084c3c3cb1207d8771f055a5a821202e" translate="yes" xml:space="preserve">
          <source>- the supplied type with &lt;code&gt;*&lt;/code&gt; replaced with &lt;code&gt;Ptr&lt;/code&gt; . e.g. for a type of &lt;code&gt;Foo*&lt;/code&gt; ,</source>
          <target state="translated">- &lt;code&gt;*&lt;/code&gt; 가 &lt;code&gt;Ptr&lt;/code&gt; 로 대체 된 제공된 유형 . 예를 들어 &lt;code&gt;Foo*&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="a3d0e64f62d0aa67fc64844708eb009021bf6273" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Bless(</source>
          <target state="translated">-&amp;gt;Bless(</target>
        </trans-unit>
        <trans-unit id="f0722d974b50edb39d61682893cf91b3ae50c4aa" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Deepcopy(</source>
          <target state="translated">-&amp;gt;Deepcopy(</target>
        </trans-unit>
        <trans-unit id="5c0edfb04a76d90d803deb5fa319ba2663d74d18" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Deparse(</source>
          <target state="translated">-&amp;gt;Deparse(</target>
        </trans-unit>
        <trans-unit id="dba6f17f00a3608b5502035af168005f1d2e47c7" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Freezer(</source>
          <target state="translated">-&amp;gt;Freezer(</target>
        </trans-unit>
        <trans-unit id="f1b9e5eef8b3fe06ef615011915677eb670538c6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Indent(</source>
          <target state="translated">-&amp;gt;Indent(</target>
        </trans-unit>
        <trans-unit id="31b6bc539e0d7c7b5901a7311b172dd6898b322b" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Maxdepth(</source>
          <target state="translated">-&amp;gt;Maxdepth(</target>
        </trans-unit>
        <trans-unit id="2d566bc2e1d524d8205bee44364bc31e0a8e9197" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Maxrecurse(</source>
          <target state="translated">-&amp;gt;Maxrecurse(</target>
        </trans-unit>
        <trans-unit id="413ec10070e2ce7e4378ffb0f5cbabab43709ca5" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Pad(</source>
          <target state="translated">-&amp;gt;Pad(</target>
        </trans-unit>
        <trans-unit id="e06d02c9fdb1747ec2039cea96f30fea04b5b25b" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Pair(</source>
          <target state="translated">-&amp;gt;Pair(</target>
        </trans-unit>
        <trans-unit id="7e25804050e4aa77c61e8ee63bad263c485c56c6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Purity(</source>
          <target state="translated">-&amp;gt;Purity(</target>
        </trans-unit>
        <trans-unit id="56a023253cf1c514dba0cbce82b8b3814335f445" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Quotekeys(</source>
          <target state="translated">-&amp;gt;Quotekeys(</target>
        </trans-unit>
        <trans-unit id="c1f9dd12120a54d49e86f3d8be13375c987724d2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Sortkeys(</source>
          <target state="translated">-&amp;gt;Sortkeys(</target>
        </trans-unit>
        <trans-unit id="d589d85ec436baef14dce8d2143c792a949aba0d" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Sparseseen(</source>
          <target state="translated">-&amp;gt;Sparseseen(</target>
        </trans-unit>
        <trans-unit id="0057fcbaafc36dc5c0f396e5d6075530bfac1848" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Terse(</source>
          <target state="translated">-&amp;gt;Terse(</target>
        </trans-unit>
        <trans-unit id="71b97fccb0554a000a087174f590ad69f5d41fc2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Toaster(</source>
          <target state="translated">-&amp;gt;Toaster(</target>
        </trans-unit>
        <trans-unit id="b282f78e8ba680fc5f27fc13dba94b8c3b531e79" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Useperl(</source>
          <target state="translated">-&amp;gt;Useperl(</target>
        </trans-unit>
        <trans-unit id="4c7197d6a5caad4a177ca1b9e2de81de03660a61" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Useqq(</source>
          <target state="translated">-&amp;gt;Useqq(</target>
        </trans-unit>
        <trans-unit id="36470c86321f280aefd62b4ed122aaace7e7a771" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Varname(</source>
          <target state="translated">-&amp;gt;Varname(</target>
        </trans-unit>
        <trans-unit id="fa657bcce0cc7fe5acc50debb5fcfb4b7bdb8fc4" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new().</source>
          <target state="translated">-&amp;gt;new().</target>
        </trans-unit>
        <trans-unit id="2d61ca753759230bedde8cc40a1707eb6fef4cc2" translate="yes" xml:space="preserve">
          <source>-&amp;tau;&amp;omicron;&amp;mu;&amp;omicron;&amp;sigmaf;</source>
          <target state="translated">-&amp;tau;&amp;omicron;&amp;mu;&amp;omicron;&amp;sigmaf;</target>
        </trans-unit>
        <trans-unit id="585f1706ae18bcdc63ca722b491c6df4f0dde510" translate="yes" xml:space="preserve">
          <source>-- see 3.2.2 Alternate Weighting, version 8 of UTS #10</source>
          <target state="translated">-UTS # 10의 3.2.2 대체 가중치 버전 8 참조</target>
        </trans-unit>
        <trans-unit id="3a8cc74f261c3d51571350ca2868bd10ef52769b" translate="yes" xml:space="preserve">
          <source>-- see 3.4 Backward Accents, UTS #10.</source>
          <target state="translated">-3.4 백 워드 악센트, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="07d3a1d428fe3461f8d9c80032441d87278b9654" translate="yes" xml:space="preserve">
          <source>-- see 3.5 Rearrangement, UTS #10.</source>
          <target state="translated">-3.5 재 배열, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="5ee3edd6f51f1ea7fa47e8f98453c7d17eaea820" translate="yes" xml:space="preserve">
          <source>-- see 3.6 Variable Weighting, UTS #10.</source>
          <target state="translated">-3.6 가변 가중치, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="cd9a420c85ac25af87c2565ef4416f3f6d6ba5b1" translate="yes" xml:space="preserve">
          <source>-- see 3.8 Default Unicode Collation Element Table, UTS #10.</source>
          <target state="translated">-3.8 기본 유니 코드 데이터 정렬 요소 표, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a697b3f4a09d78b35f6bcaf2e5ac4b9c059bb5f9" translate="yes" xml:space="preserve">
          <source>-- see 3.8.2 Well-Formedness of the DUCET, 4.2 Produce Array, UTS #10.</source>
          <target state="translated">-3.8.2 DUCET의 잘 형성됨, 4.2 생산 배열, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="7b4d0507deac646ef7351b3ecb3ba07f748dfa61" translate="yes" xml:space="preserve">
          <source>-- see 4.1 Normalize, UTS #10.</source>
          <target state="translated">-4.1 정규화, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="1cb743acecb2ab375f527cbafc47c0bbe3cabad0" translate="yes" xml:space="preserve">
          <source>-- see 4.3 Form Sort Key, UTS #10.</source>
          <target state="translated">-4.3 양식 정렬 키, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cdabeb0028ef19f65abe871e2f9a75ea7690910d" translate="yes" xml:space="preserve">
          <source>-- see 5 Tailoring; 9.1 Allkeys File Format, UTS #10.</source>
          <target state="translated">-5 재봉 참조; 9.1 Allkeys 파일 형식, UTS # 10.</target>
        </trans-unit>
        <trans-unit id="5974db4d3861eb1b0da28b6b74de30e8c4d8e699" translate="yes" xml:space="preserve">
          <source>-- see 5.1 Parametric Tailoring, UTS #10.</source>
          <target state="translated">5.1 파라 메트릭 테일러링, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="3269e638f6b6a348970d76d447ba7f62ead918d9" translate="yes" xml:space="preserve">
          <source>-- see 5.14 Collation Elements, UTS #35.</source>
          <target state="translated">-5.14 데이터 정렬 요소, UTS # 35를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba76558f052a895590fcc20803249a87f4f1a0f2" translate="yes" xml:space="preserve">
          <source>-- see 5.4 Preprocessing, UTS #10.</source>
          <target state="translated">-5.4 전처리, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="a41b8036c6ccf65060a4662dca1e11556455fd38" translate="yes" xml:space="preserve">
          <source>-- see 6.3.4 Reducing the Repertoire, UTS #10.</source>
          <target state="translated">-6.3.4 레퍼토리 감소, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="0e79a7c892b3daf587f7a8b3225aabd06c6a3025" translate="yes" xml:space="preserve">
          <source>-- see 6.5 Avoiding Normalization, UTS #10.</source>
          <target state="translated">-6.5 정규화 방지, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7a49b0b256e287ad6547d96d0e85e9098bf1e7" translate="yes" xml:space="preserve">
          <source>-- see 6.6 Case Comparisons, UTS #10.</source>
          <target state="translated">-6.6 사례 비교, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="921de278b720df4682ccde20a8a07d16048240f4" translate="yes" xml:space="preserve">
          <source>-- see 7.1 Derived Collation Elements, UTS #10.</source>
          <target state="translated">7.1 파생 데이터 정렬 요소, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6189b5fe4e700972d5d0c46522002017f4b74b4" translate="yes" xml:space="preserve">
          <source>-- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.</source>
          <target state="translated">-7.1.1 잘못된 형식의 코드 단위 시퀀스 처리, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9b914c66e4ecd398f8a0454a4abbd3845ef4cdf" translate="yes" xml:space="preserve">
          <source>-- see 7.1.4 Trailing Weights, UTS #10.</source>
          <target state="translated">-7.1.4 후행 무게, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="152aade877325529ccd0de6317a273f029c69056" translate="yes" xml:space="preserve">
          <source>-- see 7.2 Tertiary Weight Table, UTS #10.</source>
          <target state="translated">-7.2 3 차 중량 표, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="800fd8691cb7a6b6fe172573590fed9e2fc75f8f" translate="yes" xml:space="preserve">
          <source>-- see A.3 Deterministic Comparison, UTS #10.</source>
          <target state="translated">-A.3 결정 론적 비교, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="70594be556b0b2420c5652817454d7573669880a" translate="yes" xml:space="preserve">
          <source>-- see suppress contractions in 5.14.11 Special-Purpose Commands, UTS #35 (LDML).</source>
          <target state="translated">-5.14.11 특수 목적 명령, UTS # 35 (LDML)의 수축 억제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a3b88931de0f8a1585b737f1744b827120ed7e3" translate="yes" xml:space="preserve">
          <source>-- they are NOT used for</source>
          <target state="translated">-그들은 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="afe09f38de5b8547467dba38b00faf6ea82e1825" translate="yes" xml:space="preserve">
          <source>-----8&amp;lt;-----/usr/local/bin/yacc-----8&amp;lt;----- #! /usr/bin/sh</source>
          <target state="translated">----- 8 &amp;lt;----- / usr / local / bin / yacc ----- 8 &amp;lt;----- #! / usr / bin / sh</target>
        </trans-unit>
        <trans-unit id="4c145d5d792c0de7497818416a3583ddc4ef3aed" translate="yes" xml:space="preserve">
          <source>--exec</source>
          <target state="translated">--exec</target>
        </trans-unit>
        <trans-unit id="1080c2b75030b9db6089441c365cd2e618af5b72" translate="yes" xml:space="preserve">
          <source>--help and --version</source>
          <target state="translated">--help와 --version</target>
        </trans-unit>
        <trans-unit id="de00e86b4b1adf7de42f72b04311752a53fdd076" translate="yes" xml:space="preserve">
          <source>--merge</source>
          <target state="translated">--merge</target>
        </trans-unit>
        <trans-unit id="85bf17ebe87204a1c560eec7e29e5131edbd78fb" translate="yes" xml:space="preserve">
          <source>--no dangling statements allowed. If you want to write conditionals without curly brackets, there are several other ways to do it. The following all do the same thing:</source>
          <target state="translated">-매달린 문장은 허용되지 않습니다. 중괄호없이 조건을 쓰려면 몇 가지 다른 방법이 있습니다. 다음은 모두 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="180267a3a01343dd30c8a524372d694ddfbee330" translate="yes" xml:space="preserve">
          <source>--or--</source>
          <target state="translated">--or--</target>
        </trans-unit>
        <trans-unit id="5f9031d8f64ccf1adae3a5bad83b3f0e15a74b6b" translate="yes" xml:space="preserve">
          <source>--rules</source>
          <target state="translated">--rules</target>
        </trans-unit>
        <trans-unit id="1c4f9522981e50119882c53cf2d78fbc6dacf356" translate="yes" xml:space="preserve">
          <source>--rules Glob-style pattern matching</source>
          <target state="translated">-글로브 스타일 패턴 일치 규칙</target>
        </trans-unit>
        <trans-unit id="b8de924ed5d19fde35d5385ab4502ea63fe9053a" translate="yes" xml:space="preserve">
          <source>--rules examples</source>
          <target state="translated">-규칙 예</target>
        </trans-unit>
        <trans-unit id="b82e47ebb1972aa0b6e7d7ff1370d40055cb198c" translate="yes" xml:space="preserve">
          <source>--rules resolution</source>
          <target state="translated">-규칙 해결</target>
        </trans-unit>
        <trans-unit id="c60ab85f89bb24a2195d98fc15206ae225307de2" translate="yes" xml:space="preserve">
          <source>--state</source>
          <target state="translated">--state</target>
        </trans-unit>
        <trans-unit id="f102bd60a1627e203f05c569bd70be2475447fb4" translate="yes" xml:space="preserve">
          <source>--trap</source>
          <target state="translated">--trap</target>
        </trans-unit>
        <trans-unit id="6ec1cf6284eb5ed1401a0fa4abb8cf38b2067e4a" translate="yes" xml:space="preserve">
          <source>-1 or +1 is returned if the shorter string was identical to the start of the longer string. -2 or +2 is returned if there was a difference between characters within the strings.</source>
          <target state="translated">짧은 문자열이 긴 문자열의 시작과 동일하면 -1 또는 +1이 반환됩니다. 문자열 내 문자 사이에 차이가 있으면 -2 또는 +2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ad9aee0e02aa7df5696f88c33c3f5b0003d54711" translate="yes" xml:space="preserve">
          <source>-D</source>
          <target state="translated">-D</target>
        </trans-unit>
        <trans-unit id="332ec780f224383a9f30f4660fe42ecd1206e248" translate="yes" xml:space="preserve">
          <source>-T</source>
          <target state="translated">-T</target>
        </trans-unit>
        <trans-unit id="66445fecf3db004bb006e432cfd80e60057aed1e" translate="yes" xml:space="preserve">
          <source>-Unicode bytes is not necessarily obvious. Probably only the first of these is what you want:</source>
          <target state="translated">-유니 코드 바이트가 반드시 명확한 것은 아닙니다. 아마도 이것들 중 첫 번째 만이 당신이 원하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="7241f5aad8466e538eb18ce72bac37865cce783f" translate="yes" xml:space="preserve">
          <source>-X</source>
          <target state="translated">-X</target>
        </trans-unit>
        <trans-unit id="f02421666194942fbfd487a0b89bc8e62902d2fe" translate="yes" xml:space="preserve">
          <source>-X DIRHANDLE</source>
          <target state="translated">-X DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="2ab1b601b35fe8f8841c979e875fa9193b77c019" translate="yes" xml:space="preserve">
          <source>-X EXPR</source>
          <target state="translated">-X EXPR</target>
        </trans-unit>
        <trans-unit id="bc19678a7061febac0619b2e971988a6337acd07" translate="yes" xml:space="preserve">
          <source>-X FILEHANDLE</source>
          <target state="translated">-X 파일 핸들</target>
        </trans-unit>
        <trans-unit id="f1141527e901e4fc62f73312648aa01ec2a552d5" translate="yes" xml:space="preserve">
          <source>-axis is &lt;b&gt;phi&lt;/b&gt;, also known as the</source>
          <target state="translated">축은 &lt;b&gt;phi&lt;/b&gt; 이며</target>
        </trans-unit>
        <trans-unit id="60c94d22393c772d0f184d991bea821b935b05c4" translate="yes" xml:space="preserve">
          <source>-axis) is &lt;b&gt;theta&lt;/b&gt;, also known as the</source>
          <target state="translated">축)은 &lt;b&gt;theta&lt;/b&gt; 라고도하며</target>
        </trans-unit>
        <trans-unit id="a9dbc90b755d775e7f6bcfa29813702306e16afa" translate="yes" xml:space="preserve">
          <source>-based) logarithm of the numerical argument, see &lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;.</source>
          <target state="translated">숫자 인수의 로그 기반 로그는 &lt;a href=&quot;functions/log&quot;&gt;log를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7abb535a243486c680796806de8db55fd67e96f" translate="yes" xml:space="preserve">
          <source>-based) of the numerical argument, see &lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;.</source>
          <target state="translated">숫자 인수에 대해서는 &lt;a href=&quot;functions/exp&quot;&gt;exp를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a878f037fdf80e6f7650a48c7b4019c798e1bf" translate="yes" xml:space="preserve">
          <source>-coordinates.</source>
          <target state="translated">-coordinates.</target>
        </trans-unit>
        <trans-unit id="ae22cd44cab421b74b9cb1b713b21791222034bd" translate="yes" xml:space="preserve">
          <source>-equivalent suffix.</source>
          <target state="translated">동등한 접미사.</target>
        </trans-unit>
        <trans-unit id="f9734ee333a629165fa782b725db07885fb85d5a" translate="yes" xml:space="preserve">
          <source>-expansion done.</source>
          <target state="translated">확장이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="814937af05964f89600befa6ae3bfe386bb151b0" translate="yes" xml:space="preserve">
          <source>-ish meanings:</source>
          <target state="translated">-ish 의미 :</target>
        </trans-unit>
        <trans-unit id="d913657d8a33916405c4c67553ab3a2992d6c95e" translate="yes" xml:space="preserve">
          <source>-like construct is created by a pair of &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; macros (see &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;Returning a Scalar in perlcall&lt;/a&gt;). Such a construct may be created specially for some important localized task, or an existing one (like boundaries of enclosing Perl subroutine/block, or an existing pair for freeing TMPs) may be used. (In the second case the overhead of additional localization must be almost negligible.) Note that any XSUB is automatically enclosed in an &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair.</source>
          <target state="translated">-like 구성은 한 쌍의 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 매크로에 의해 작성됩니다 ( &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;perlcall에서 스칼라 리턴&lt;/a&gt; 참조 ). 이러한 구조는 일부 중요한 국부 화 된 태스크를 위해 특별히 생성 될 수 있거나, 기존의 태스크 (외부 Perl 서브 루틴 / 블록의 경계 또는 TMP를 해제하기위한 기존의 쌍과 같은)가 사용될 수있다. (두 번째 경우 추가 지역화의 오버 헤드는 거의 무시할 수 있어야합니다.) 모든 XSUB는 자동으로 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 쌍 으로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="a98c9dc82b0940ee66ebaf6b3ab25db4d7a0b7ee" translate="yes" xml:space="preserve">
          <source>-lperl</source>
          <target state="translated">-lperl</target>
        </trans-unit>
        <trans-unit id="00a354ab6ba325dfea1f93fc702984e336b57ca9" translate="yes" xml:space="preserve">
          <source>-pi</source>
          <target state="translated">-pi</target>
        </trans-unit>
        <trans-unit id="d0ab9098221f275f405a3db51c04c836d2cd668f" translate="yes" xml:space="preserve">
          <source>-plane (around the</source>
          <target state="translated">비행기 (주변</target>
        </trans-unit>
        <trans-unit id="fe06637685c925d5eec8bbd543cd92c006d957fa" translate="yes" xml:space="preserve">
          <source>-removal would give you. If you want to do this kind of processing, you probably want &lt;code&gt;Cwd&lt;/code&gt; 's &lt;code&gt;realpath()&lt;/code&gt; function to actually traverse the filesystem cleaning up paths like this.</source>
          <target state="translated">제거는 당신에게 줄 것입니다. 이런 종류의 처리를 원한다면 &lt;code&gt;Cwd&lt;/code&gt; 의 &lt;code&gt;realpath()&lt;/code&gt; 함수가 실제로 파일 시스템을 통과하여 이와 같은 경로를 정리하기를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1a8854d13cc7eda216c70c1e5b536a20cbd2d0a9" translate="yes" xml:space="preserve">
          <source>-style format specifier (without the leading '%') to use to print the times. It defaults to '5.2f'.</source>
          <target state="translated">시간을 인쇄하는 데 사용하는 -style 형식 지정자 (앞의 '%'없음) 기본값은 '5.2f'입니다.</target>
        </trans-unit>
        <trans-unit id="39757b603166b52e1a1e2021e629c21418eee11a" translate="yes" xml:space="preserve">
          <source>-th subpattern, or undef if the subpattern did not match.</source>
          <target state="translated">-번째 하위 패턴이거나 하위 패턴이 일치하지 않으면 undef입니다.</target>
        </trans-unit>
        <trans-unit id="aaf1e4f6a10d49a5901590bb3b8c0dba1ef3ca8c" translate="yes" xml:space="preserve">
          <source>-utilities on path manually. They are installed in &lt;code&gt;$prefix/bin&lt;/code&gt; , here &lt;code&gt;$prefix&lt;/code&gt; is what you gave to</source>
          <target state="translated">-경로의 수동 유틸리티. &lt;code&gt;$prefix/bin&lt;/code&gt; 설치되어 있습니다. &lt;code&gt;$prefix&lt;/code&gt; 는 당신이 준 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="46b9ed05b810c35c030b14df53138c9f8fb2464a" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;&lt;a href=&quot;../functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">. ( &lt;code&gt;&lt;a href=&quot;../functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="b8d281ef9104c2b48d48df2a7cf5ddced0cf7e72" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt;). For example:</source>
          <target state="translated">. ( &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 와 동일 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="694f35049a7ec5dc2b360d57bd881a28fa07da34" translate="yes" xml:space="preserve">
          <source>. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="translated">. (CLEANUP 플래그가 설정 될 때 프로그램 종료시 정리를 위해, 이것은 자동으로 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="15693b683bd6294eb09618d3328be4ea6360e2ed" translate="yes" xml:space="preserve">
          <source>. (If you interrupt it, you would better reset &lt;code&gt;LineInfo&lt;/code&gt; to something &quot;interactive&quot;!)</source>
          <target state="translated">. (중단하면 &lt;code&gt;LineInfo&lt;/code&gt; 를 &quot;대화식&quot;으로 재설정하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="181e9a15b21b5b303a16988869863732a3c74ac2" translate="yes" xml:space="preserve">
          <source>. (If you interrupt it, you'd better reset &lt;code&gt;LineInfo&lt;/code&gt; to</source>
          <target state="translated">. (중단하면 &lt;code&gt;LineInfo&lt;/code&gt; 를 다음으로 재설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4f2dc4447c7e1cbcca5316cceaa252e9049281ff" translate="yes" xml:space="preserve">
          <source>. (Perhaps, in retrospect, the &lt;code&gt;lib&lt;/code&gt; style should never have been supported, but it did seem like a nice idea at the time.)</source>
          <target state="translated">. 아마도 돌이켜 보면 &lt;code&gt;lib&lt;/code&gt; 스타일은 지원되지 않았지만 당시에는 좋은 생각처럼 보였습니다.</target>
        </trans-unit>
        <trans-unit id="9f0b8aeca7daf268ae4d3b7f58d2547cb18964da" translate="yes" xml:space="preserve">
          <source>. (Setting BEGINLIBPATH to just &lt;code&gt;.&lt;/code&gt; is ignored by the OS/2 kernel.)</source>
          <target state="translated">. (단지에 BEGINLIBPATH을 설정 &lt;code&gt;.&lt;/code&gt; 운영 체제 / 2 커널에 의해 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="ebbcb028023ba5ec4bf990fcf6eb37768723056e" translate="yes" xml:space="preserve">
          <source>. (There is a Perl script called &lt;b&gt;h2ph&lt;/b&gt; that comes with the Perl kit that may help you in this, but it's nontrivial.) SCALAR will be read and/or written depending on the FUNCTION; a C pointer to the string value of SCALAR will be passed as the third argument of the actual &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; call. (If SCALAR has no string value but does have a numeric value, that value will be passed rather than a pointer to the string value. To guarantee this to be true, add a &lt;code&gt;0&lt;/code&gt; to the scalar before using it.) The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; functions may be needed to manipulate the values of structures used by &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">. (이에 도움이 될 수있는 Perl 키트와 함께 제공되는 &lt;b&gt;h2ph&lt;/b&gt; 라는 Perl 스크립트 가 있지만 사소한 것은 아닙니다.) SCALAR는 FUNCTION에 따라 읽거나 쓸 것입니다. SCALAR의 문자열 값에 대한 C 포인터는 실제 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 호출 의 세 번째 인수로 전달됩니다 . (SCALAR 더 문자열 값이 없지만 숫자 값을 가질 경우, 그 값은 문자열 값에 대한 포인터보다는 전달됩니다. 추가,이 사실을 보장하기 위해 &lt;code&gt;0&lt;/code&gt; 을 사용하기 전에 스칼라로하십시오.) &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 이 사용하는 구조의 값을 조작하기 위해 함수가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf29a1e7711e856247e88a22d78403cd4097d96" translate="yes" xml:space="preserve">
          <source>. (There is a Perl script called &lt;b&gt;h2ph&lt;/b&gt; that comes with the Perl kit that may help you in this, but it's nontrivial.) SCALAR will be read and/or written depending on the FUNCTION; a C pointer to the string value of SCALAR will be passed as the third argument of the actual &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; call. (If SCALAR has no string value but does have a numeric value, that value will be passed rather than a pointer to the string value. To guarantee this to be true, add a &lt;code&gt;0&lt;/code&gt; to the scalar before using it.) The &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; functions may be needed to manipulate the values of structures used by &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">. (이에 도움이 될 수있는 Perl 키트와 함께 제공되는 &lt;b&gt;h2ph&lt;/b&gt; 라는 Perl 스크립트 가 있지만 사소한 것은 아닙니다.) SCALAR는 FUNCTION에 따라 읽거나 쓸 것입니다. SCALAR의 문자열 값에 대한 C 포인터는 실제 &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 호출 의 세 번째 인수로 전달됩니다 . (SCALAR 더 문자열 값이 없지만 숫자 값을 가질 경우, 그 값은 문자열 값에 대한 포인터보다는 전달됩니다. 추가,이 사실을 보장하기 위해 &lt;code&gt;0&lt;/code&gt; 을 사용하기 전에 스칼라로하십시오.) &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 이 사용하는 구조의 값을 조작하기 위해 함수가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc82a4dc120028594b84107495cbc0deaebe016c" translate="yes" xml:space="preserve">
          <source>. (Yes, Virginia, there &lt;b&gt;is&lt;/b&gt; a YACC grammar for Perl!) The job of the parser is to take your code and &quot;understand&quot; it, splitting it into sentences, deciding which operands go with which operators and so on.</source>
          <target state="translated">. (예, 버지니아, 거기에 &lt;b&gt;있다&lt;/b&gt; 펄의 YACC 문법!) 파서의 작업은 피연산자가있는 사업자 등으로 이동하는 결정, 그것을 문장으로, 분할 코드를 가지고 그것을 &quot;이해&quot;하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cac2ef42eac4291ce9782faa9a407fa44d35265d" translate="yes" xml:space="preserve">
          <source>. (or</source>
          <target state="translated">. (또는</target>
        </trans-unit>
        <trans-unit id="236152725d137990a457e4cd09f9fd7d5e6c1e40" translate="yes" xml:space="preserve">
          <source>. &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; explain the</source>
          <target state="translated">. &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 와 &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="0b97909f09c9f763ca3dc7911d0df0016488e3ca" translate="yes" xml:space="preserve">
          <source>. &lt;b&gt;It is especially important to do this in modules to avoid penalizing all applications which use them.&lt;/b&gt;</source>
          <target state="translated">. &lt;b&gt;모듈을 사용하는 모든 응용 프로그램에 불이익을주지 않도록 모듈에서이 작업을 수행하는 것이 특히 중요합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c84bd932de16eb29265e3c78e34c63425be61866" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;$&lt;/code&gt; is a shell prompt.</source>
          <target state="translated">. &lt;code&gt;$&lt;/code&gt; 는 쉘 프롬프트입니다.</target>
        </trans-unit>
        <trans-unit id="a872501bd8eee376a90e33fd1da5d7ad22e00ebc" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;$Config{d_setlocale}&lt;/code&gt; is &lt;code&gt;'define'&lt;/code&gt; on OS/390 or z/OS.</source>
          <target state="translated">. &lt;code&gt;$Config{d_setlocale}&lt;/code&gt; 은 OS / 390 또는 z / OS에서 &lt;code&gt;'define'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="689f2d81347c4e95450de6a6b67d57924dc6366c" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords indicate that the C subroutine does not inspect the memory pointed by this parameter, but will write through this pointer to provide additional return values.</source>
          <target state="translated">. &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 키워드는 C 서브 루틴이이 매개 변수가 가리키는 메모리를 검사하지 않지만 추가 포인터 값을 제공하기 위해이 포인터를 통해 씁니다.</target>
        </trans-unit>
        <trans-unit id="88901232fc748fdea60269bc910d226f97e1cb4d" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;Perl_runops_debug&lt;/code&gt; is used with DEBUGGING and &lt;code&gt;Perl_runops_standard&lt;/code&gt; is used otherwise. For fine control over the execution of the compile tree it is possible to provide your own runops function.</source>
          <target state="translated">. &lt;code&gt;Perl_runops_debug&lt;/code&gt; 는 DEBUGGING 과 함께 사용되며 그렇지 않으면 &lt;code&gt;Perl_runops_standard&lt;/code&gt; 가 사용됩니다. 컴파일 트리 실행을 정밀하게 제어하기 위해 자체 Runops 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c7eee973f32ff4607b490bd51cf94d26808c4a" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;STDIN =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; turns the I/O transcoding completely off for that filehandle.</source>
          <target state="translated">. &lt;code&gt;STDIN =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 해당 파일 핸들에 대한 I / O 트랜스 코딩을 완전히 끕니다.</target>
        </trans-unit>
        <trans-unit id="22e9affa2bbc7ae84004e12265378a617db34fa8" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;special&lt;/code&gt; (usually, but not always, a multicharacter mapping), is tried first.</source>
          <target state="translated">. &lt;code&gt;special&lt;/code&gt; (보통 항상 다중 문자 매핑은 아님)가 먼저 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="34b205465f826019a73312394da64a5166d0e847" translate="yes" xml:space="preserve">
          <source>. A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; just gives temporary values to global (meaning package) variables. It does</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 단지 지구 (의미 패키지) 변수에 임시 값을 제공합니다. 그렇습니다</target>
        </trans-unit>
        <trans-unit id="20d7984adc37598924d34162f803580d6f8e4473" translate="yes" xml:space="preserve">
          <source>. A character class allows a set of possible characters, rather than just a single character, to match at a particular point in a regexp. You can define your own custom character classes. These are denoted by brackets &lt;code&gt;[...]&lt;/code&gt; , with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="translated">. 문자 클래스를 사용하면 단일 문자가 아닌 가능한 문자 세트를 정규식의 특정 지점에서 일치시킬 수 있습니다. 고유 한 사용자 정의 문자 클래스를 정의 할 수 있습니다. 이것들은 대괄호 &lt;code&gt;[...]&lt;/code&gt; 로 표시되며 , 문자 세트와 일치 할 가능성이 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="b629a81173e8b0555a45f0a8eab5759b801c2a12" translate="yes" xml:space="preserve">
          <source>. A code point is essentially the position of the character within the set of all possible Unicode characters, and thus in Perl, the term</source>
          <target state="translated">. 코드 포인트는 기본적으로 가능한 모든 유니 코드 문자 집합 내에서 문자의 위치이므로 Perl에서</target>
        </trans-unit>
        <trans-unit id="6967b877b0a6419ec120bcf48175f4179b1d1c97" translate="yes" xml:space="preserve">
          <source>. A module can install custom translations (inside the scope which &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;s the module) with the following magic incantation:</source>
          <target state="translated">. 모듈은 다음과 같은 마법의 주문과 함께 사용자 정의 번역을 ( 모듈 을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하는 범위 내에서) 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="654c9133d804ea9801de6c352e63b0d752c4c7a2" translate="yes" xml:space="preserve">
          <source>. A source stream is created when the Perl parser opens a file, it continues to exist as the source code is read into memory, and it is destroyed when Perl is finished parsing the file. If the parser encounters a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement in a source stream, a new and distinct stream is created just for that file.</source>
          <target state="translated">. 소스 스트림은 Perl 구문 분석기가 파일을 열 때 작성되며 소스 코드를 메모리로 읽을 때 계속 존재하며 Perl이 파일 구문 분석을 마치면 소멸됩니다. 파서가 소스 스트림에서 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문을 발견하면 해당 파일에 대해서만 새롭고 고유 한 스트림이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1be7e388b24fed423d29f693852a90533c3dce34" translate="yes" xml:space="preserve">
          <source>. All regex engines must be able to correctly build such a structure in their &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">. 모든 정규식 엔진은 &lt;a href=&quot;#comp&quot;&gt;컴프&lt;/a&gt; 루틴 에서 이러한 구조를 올바르게 구축 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0eb8ffacada74d7b0728dd1325a7888884aee218" translate="yes" xml:space="preserve">
          <source>. All the other functions are fairly simple wrappers which make it easier to call Perl subroutines in special cases. At the end of the day they will all call</source>
          <target state="translated">. 다른 모든 함수는 특별한 경우에 Perl 서브 루틴을보다 쉽게 ​​호출 할 수있는 상당히 간단한 랩퍼입니다. 하루가 끝나면 그들은 모두 전화 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="27da16d87cc57fa070324d863cd8cedd53811405" translate="yes" xml:space="preserve">
          <source>. All versions of Berkeley DB are available there.</source>
          <target state="translated">. Berkeley DB의 모든 버전을 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233b57b3e77bae0ead5a8a30677ef0a77a1edf99" translate="yes" xml:space="preserve">
          <source>. And since the extension DLLs link with the Perl DLL, extension DLLs for older versions would load an older Perl DLL, and would most probably segfault (since the data in this DLL is not properly initialized).</source>
          <target state="translated">. 그리고 확장 DLL은 Perl DLL과 연결되기 때문에, 이전 버전의 확장 DLL은 이전 Perl DLL을로드하며, 아마도이 DLL의 데이터가 제대로 초기화되지 않았기 때문에 segfault 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="de259bd11ae330f9c68f383ed85ba6c2e159b450" translate="yes" xml:space="preserve">
          <source>. Any XS code should be in</source>
          <target state="translated">. 모든 XS 코드는</target>
        </trans-unit>
        <trans-unit id="75671be154b9c3d8b51b585074c5b9061967b6d3" translate="yes" xml:space="preserve">
          <source>. Any type of bracket not in the delimiter list is treated as an ordinary character.</source>
          <target state="translated">. 구분 기호 목록에없는 모든 유형의 대괄호는 일반 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bdcf75e96f17cc2c4c3a8be735b514fb9c36ef" translate="yes" xml:space="preserve">
          <source>. As a binary operator, it has two children: the add operator, providing the result of &lt;code&gt;$b+$c&lt;/code&gt; , is uppermost on line 5, and the left hand side is on line 10.</source>
          <target state="translated">. 이항 연산자로서 두 개의 하위 요소가 있습니다. &lt;code&gt;$b+$c&lt;/code&gt; 의 결과를 제공하는 add 연산자 는 5 행에서 가장 위쪽에 있고 왼쪽은 10 행에 있습니다.</target>
        </trans-unit>
        <trans-unit id="53d4b5ccec1621f068b34a98df82654fe06d0665" translate="yes" xml:space="preserve">
          <source>. As a corollary, though the actual tree contains more nodes than our simplified example, the execution order is the same as in our example.</source>
          <target state="translated">. 실제 트리에는 단순화 된 예제보다 많은 노드가 포함되어 있지만 실행 순서는 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c525726c99728c892ca019d38a86d797ed1a27e8" translate="yes" xml:space="preserve">
          <source>. As yet there is nothing useful you can do with the object at the perl level.</source>
          <target state="translated">. 그럼에도 불구하고 펄 수준에서 객체로 할 수있는 유용한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a1ba0a96e2cd6c9d394a4472d471f9ff7cd31bc" translate="yes" xml:space="preserve">
          <source>. Assuming such an entry is found, various things then happen, depending on the value found:</source>
          <target state="translated">. 그러한 항목이 발견되면 발견 된 값에 따라 다양한 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da93ec95ac544504e474beee8e0bb9e569ea1865" translate="yes" xml:space="preserve">
          <source>. Basic blocks are sections of code that are entered only in the beginning and exited only at the end. For example, a conditional jump starts a basic block. Basic block profiling usually works by</source>
          <target state="translated">. 기본 블록은 처음에만 입력되고 끝에서만 종료되는 코드 섹션입니다. 예를 들어, 조건부 점프는 기본 블록을 시작합니다. 기본 블록 프로파일 링은 일반적으로</target>
        </trans-unit>
        <trans-unit id="922dde6fe40fcfb9ac9ff6d274634cfcd6f24ba2" translate="yes" xml:space="preserve">
          <source>. Because we want the program to continue after detecting this error, it is essential that the stack be tidied up by removing the</source>
          <target state="translated">. 이 오류를 감지 한 후 프로그램을 계속 진행하려면 스택을 제거하여 스택을 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="38b8a4a88265debcef2bc8e73467237aa68e829c" translate="yes" xml:space="preserve">
          <source>. Both &lt;code&gt;sub1()&lt;/code&gt; and &lt;code&gt;sub2()&lt;/code&gt; access the global variable &lt;code&gt;$x&lt;/code&gt; , once to read and once to write. Depending on factors ranging from your thread implementation's scheduling algorithm to the phase of the moon, &lt;code&gt;$x&lt;/code&gt; can be 2 or 3.</source>
          <target state="translated">. 두 &lt;code&gt;sub1()&lt;/code&gt; 및 &lt;code&gt;sub2()&lt;/code&gt; 액세스 전역 변수 &lt;code&gt;$x&lt;/code&gt; 한 번 읽기 및 쓰기에 한 번합니다. 스레드 구현의 스케줄링 알고리즘에서 달의 위상에 이르기까지 다양한 요인에 따라 &lt;code&gt;$x&lt;/code&gt; 는 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998a439013a873f26870288508560a8fdb5f11eb" translate="yes" xml:space="preserve">
          <source>. But because of the nature of Macintosh paths, some additional possibilities are allowed to make using this routine give reasonable results for some common situations. In other words, you are also allowed to concatenate</source>
          <target state="translated">. 그러나 Macintosh 경로의 특성으로 인해이 루틴을 사용하면 몇 가지 일반적인 상황에서 합리적인 결과를 얻을 수있는 추가 가능성이 있습니다. 다시 말해, 당신은 또한 연결할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bd199e23140531c836914088d48f55487bf7e65c" translate="yes" xml:space="preserve">
          <source>. Can be used to make sure that the UTF-8 flag is on, so that &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; work as Unicode on strings containing characters in the range 0x80-0xFF (on ASCII and derivatives).</source>
          <target state="translated">. UTF-8 플래그가 켜져 있는지 확인하여 &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 0x80-0xFF 범위의 문자 (ASCII 및 파생어)를 포함하는 문자열에서 유니 코드로 작동하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b8d29b7aaa3a46be9be50380ab1ce3e867db600" translate="yes" xml:space="preserve">
          <source>. Chapters and page numbers are given using the following editions:</source>
          <target state="translated">. 장과 페이지 번호는 다음 판을 사용하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="995d80ebe5e9c631b25033fd42a932b6fa61b6b7" translate="yes" xml:space="preserve">
          <source>. Child subroutines have &lt;code&gt;_&lt;/code&gt; and the name length appended, so constants with 10 character names would be in &lt;code&gt;constant_10&lt;/code&gt; with the default</source>
          <target state="translated">. 하위 서브 루틴에는 &lt;code&gt;_&lt;/code&gt; 와 이름 길이가 추가되므로 10 개의 문자 이름을 가진 &lt;code&gt;constant_10&lt;/code&gt; 는 기본값과 함께 constant_10 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63971449e6c29f2a08f74ad23883b2558d36606" translate="yes" xml:space="preserve">
          <source>. Choice of American/British/Other spellings is left as an exercise for the author of each bit of documentation. When patching documentation, try to emulate the documentation around you, rather than changing the existing prose.</source>
          <target state="translated">. 미국 / 영국 / 기타 철자의 선택은 각 문서의 저자를위한 연습으로 남습니다. 문서를 패치 할 때는 기존 산문을 변경하지 말고 문서를 에뮬레이션하십시오.</target>
        </trans-unit>
        <trans-unit id="58ab3092f216e58d0241856d21b4fdcc0acc1fa6" translate="yes" xml:space="preserve">
          <source>. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, &lt;code&gt;\r&lt;/code&gt; for a carriage return and &lt;code&gt;\a&lt;/code&gt; for a bell (or alert). If your string is better thought of as a sequence of arbitrary bytes, the octal escape sequence, e.g., &lt;code&gt;\033&lt;/code&gt; , or hexadecimal escape sequence, e.g., &lt;code&gt;\x1B&lt;/code&gt; may be a more natural representation for your bytes. Here are some examples of escapes:</source>
          <target state="translated">. 일반적인 예는 탭의 경우 &lt;code&gt;\t&lt;/code&gt; , 줄 바꾸기의 경우 &lt;code&gt;\n&lt;/code&gt; , 캐리지 리턴의 경우 &lt;code&gt;\r&lt;/code&gt; , 종소리 (또는 경고)의 경우 &lt;code&gt;\a&lt;/code&gt; 입니다. 문자열이 임의의 바이트 시퀀스로 더 잘 생각되면 8 진 이스케이프 시퀀스 (예 : &lt;code&gt;\033&lt;/code&gt; ) 또는 16 진 이스케이프 시퀀스 (예 : &lt;code&gt;\x1B&lt;/code&gt; 가 바이트에 대한보다 자연스러운 표현 일 수 있습니다. 탈출의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d7e30195a0de047a3242c04e44600623627b182" translate="yes" xml:space="preserve">
          <source>. Copy or link</source>
          <target state="translated">. 복사 또는 링크</target>
        </trans-unit>
        <trans-unit id="79825b16c77c06b44977118fac4eea014741e249" translate="yes" xml:space="preserve">
          <source>. Currently OS/2 support of threads is very preliminary.</source>
          <target state="translated">. 현재 스레드에 대한 OS / 2 지원은 매우 예비 적입니다.</target>
        </trans-unit>
        <trans-unit id="135c9f2f36a34ddc0a2893c23665c762d2104afc" translate="yes" xml:space="preserve">
          <source>. Currently the maximum possible number of distinct regops is restricted to 256, with about a quarter already used.</source>
          <target state="translated">. 현재 최대 가능한 개별 레포 수는 256 개로 제한되며 약 1/4이 이미 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a874263e45933953bf0ed324a58df137c7e708" translate="yes" xml:space="preserve">
          <source>. Currently, there are only two styles: &lt;code&gt;lib&lt;/code&gt; and</source>
          <target state="translated">. 현재는 두 가지 스타일이 있습니다 : &lt;code&gt;lib&lt;/code&gt; 와</target>
        </trans-unit>
        <trans-unit id="53e5505050f1982d7363ce9cde826d9f92f57a58" translate="yes" xml:space="preserve">
          <source>. Decoding will terminate when $terminator (a string) appears in output.</source>
          <target state="translated">. $ terminator (문자열)가 출력에 나타나면 디코딩이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="59c539a141527ad47946cca8b46d791f7d164400" translate="yes" xml:space="preserve">
          <source>. Do not disturb that installation unless you really know what you are doing. If you remove the perl supplied with the OS, you will render some bits of your system inoperable. If you wish to install a newer version of perl, install it under a different prefix from /usr/perl5. Common prefixes to use are /usr/local and /opt/perl.</source>
          <target state="translated">. 당신이하고있는 일을 정말로 모른다면 그 설치를 방해하지 마십시오. OS와 함께 제공된 perl을 제거하면 시스템의 일부 비트가 작동하지 않게됩니다. 최신 버전의 perl을 설치하려면 / usr / perl5와 다른 접두사로 설치하십시오. 사용할 일반적인 접두사는 / usr / local 및 / opt / perl입니다.</target>
        </trans-unit>
        <trans-unit id="93b36a13a574d58a76b40f626c241af718c19914" translate="yes" xml:space="preserve">
          <source>. Don't use them in production code. Yet.</source>
          <target state="translated">. 프로덕션 코드에서는 사용하지 마십시오. 아직.</target>
        </trans-unit>
        <trans-unit id="7fd37bab10468d9938f078309153e9437be5450a" translate="yes" xml:space="preserve">
          <source>. E.g.</source>
          <target state="translated">. 예 :</target>
        </trans-unit>
        <trans-unit id="25ce36fbbb17f8d1b0a4109d1371fa2f34186024" translate="yes" xml:space="preserve">
          <source>. Each has at least four hexdigits.</source>
          <target state="translated">. 각각에는 최소한 4 개의 16 진수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4404b6be911fb9ccd359c1128f3d94cffa4c329" translate="yes" xml:space="preserve">
          <source>. Each has at least four hexdigits. The codes may be preceded by a word enclosed in angle brackets, then a space, like &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt; , giving the type of decomposition</source>
          <target state="translated">. 각각에는 최소한 4 개의 16 진수가 있습니다. 코드 앞에는 꺾쇠 괄호로 묶은 단어가 붙은 다음 &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt; 와 같이 공백 이있어 분해 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63141e3b2c36400b64267234149999ae2c55ef9a" translate="yes" xml:space="preserve">
          <source>. Either because it doesn't make sense to back-port that part of the API, or simply because it hasn't been implemented yet. Patches welcome!</source>
          <target state="translated">. API의 해당 부분을 백 포트하는 것이 타당하지 않거나 아직 구현되지 않았기 때문입니다. 패치 환영합니다!</target>
        </trans-unit>
        <trans-unit id="103da34daa28d7627bfd7c2b3ec90e61135c836c" translate="yes" xml:space="preserve">
          <source>. Finally, the &quot;.&quot; metacharacter matches any character except &quot;\n&quot; (unless you use &lt;code&gt;/s&lt;/code&gt;).</source>
          <target state="translated">. 마지막으로 &quot;.&quot; 메타 문자는 &quot;\ n&quot;을 제외한 모든 문자와 일치합니다 ( &lt;code&gt;/s&lt;/code&gt; 를 사용하지 않는 경우 ).</target>
        </trans-unit>
        <trans-unit id="b3d2c0dfaacb26c7f33418797db935878bbdde14" translate="yes" xml:space="preserve">
          <source>. For example,</source>
          <target state="translated">. 예를 들어</target>
        </trans-unit>
        <trans-unit id="740611fcdc6870a843c2364c8e58c7ed97b112e4" translate="yes" xml:space="preserve">
          <source>. For example, a Korean Hangul syllable is considered a single logical character, but most often consists of three actual Unicode characters: a leading consonant followed by an interior vowel followed by a trailing consonant.</source>
          <target state="translated">. 예를 들어 한국어 한글 음절은 하나의 논리 문자로 간주되지만 대부분 3 개의 실제 유니 코드 문자로 구성됩니다. 선행 자음, 내부 모음, 뒤에 자음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="042727f423f9fa6f93e1e3706fb37670c040c890" translate="yes" xml:space="preserve">
          <source>. For example, if your code would normally go into</source>
          <target state="translated">. 예를 들어 코드가 일반적으로</target>
        </trans-unit>
        <trans-unit id="4f3f25bc941622e7175e3969043f856eeb61133e" translate="yes" xml:space="preserve">
          <source>. For example, they may crash the Perl interpreter during execution, or may dump core on termination. Depending on the module and the requirements of your application, it may be possible to work around such difficulties.</source>
          <target state="translated">. 예를 들어, 실행 중에 Perl 인터프리터가 충돌하거나 종료시 코어를 덤프 할 수 있습니다. 모듈과 응용 프로그램 요구 사항에 따라 이러한 어려움을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17ecac96b1adb18dd520ee9c0b9bae11aca3ab3" translate="yes" xml:space="preserve">
          <source>. For example:</source>
          <target state="translated">. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fddca2af68b08afcb09b50d2195be9684be0734" translate="yes" xml:space="preserve">
          <source>. For exploring Unicode character names and character properties, see its</source>
          <target state="translated">. 유니 코드 문자 이름 및 문자 속성을 살펴 보려면</target>
        </trans-unit>
        <trans-unit id="547c378c2449b9e81e8aa82ca93843bb7c621101" translate="yes" xml:space="preserve">
          <source>. For other data types, or to examine return values, you'll need to manipulate the Perl stack. That's demonstrated in &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;Fiddling with the Perl stack from your C program&lt;/a&gt;.</source>
          <target state="translated">. 다른 데이터 형식이나 반환 값을 확인하려면 Perl 스택을 조작해야합니다. 그것은 &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;C 프로그램의 Perl 스택&lt;/a&gt; 으로 Fiddling 에서 시연됩니다 .</target>
        </trans-unit>
        <trans-unit id="9acfc198f0b2223d41f4211f848b117ef3bae556" translate="yes" xml:space="preserve">
          <source>. FreeBSD 7 and earlier has a bug where either approach sometimes returns an incorrect value (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&lt;/a&gt; ). In these cases perl will fall back to the old behaviour of using C's argv[0] value for &lt;code&gt;$^X&lt;/code&gt; .</source>
          <target state="translated">. FreeBSD 7 및 이전 버전은 두 가지 방법 중 하나가 때때로 잘못된 값을 반환하는 버그가 있습니다 ( &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 참조&lt;/a&gt; ). 이 경우 perl은 &lt;code&gt;$^X&lt;/code&gt; C의 argv [0] 값을 사용하는 이전 동작으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2b60383e9beeed5eccc01696d85bb58945bce4" translate="yes" xml:space="preserve">
          <source>. Given the amount of time between releases of Perl the version that ships with Perl is quite likely to be out of date, so the most recent version can always be found on CPAN (see &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;CPAN in perlmodlib&lt;/a&gt; for details), in the directory</source>
          <target state="translated">. Perl 릴리스 사이의 시간이 주어지면 Perl과 함께 제공되는 버전이 최신 버전이 아닐 수 있으므로 최신 버전은 항상 CPAN ( &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;perlmodlib의 CPAN&lt;/a&gt; 참조) 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f9e68beb7f0b151bc8fceae81cb1b8ad5d7794e" translate="yes" xml:space="preserve">
          <source>. Having perl build itself would be impossible with</source>
          <target state="translated">. 펄 빌드 자체를 갖는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="e70c7aa2494034e63eb8b4f2b22846a01d30041b" translate="yes" xml:space="preserve">
          <source>. However, it is possible to</source>
          <target state="translated">. 그러나</target>
        </trans-unit>
        <trans-unit id="c7a0e55016332e0c5271c0854d6a9c26c89598fb" translate="yes" xml:space="preserve">
          <source>. However, your host system and Cygwin configuration will affect Perl's runtime behavior (see &lt;a href=&quot;#TEST&quot;&gt;TEST&lt;/a&gt;).</source>
          <target state="translated">. 그러나 호스트 시스템 및 Cygwin 구성은 Perl의 런타임 동작에 영향을 미칩니다 ( &lt;a href=&quot;#TEST&quot;&gt;테스트&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>. If</source>
          <target state="translated">. 만약</target>
        </trans-unit>
        <trans-unit id="7f0c2910442f1f0b575ce98071a1f0ff5753a782" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;quoteHighBit&lt;/code&gt; is set, they will be quoted.</source>
          <target state="translated">. 경우 &lt;code&gt;quoteHighBit&lt;/code&gt; 가 설정되어, 그들은 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="d44fe27c9789df6d9edbedc8e0441cfadb796292" translate="yes" xml:space="preserve">
          <source>. If all that fails it &lt;code&gt;croak&lt;/code&gt; s.</source>
          <target state="translated">. 모든 것이 실패하면 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbe4ccac3b5962271b48921e81142f21abf8b496" translate="yes" xml:space="preserve">
          <source>. If an object is a noun, then methods are its verbs (save, print, open).</source>
          <target state="translated">. 객체가 명사 인 경우 메소드는 동사 (저장, 인쇄, 열기)입니다.</target>
        </trans-unit>
        <trans-unit id="d6d823fabc5313d54be7c53757154c9b35bde3e3" translate="yes" xml:space="preserve">
          <source>. If called as a class method, a new object is created; if called as an instance method, the object is reset to the state contained in</source>
          <target state="translated">. 클래스 메소드로 호출되면 새 오브젝트가 작성됩니다. 인스턴스 메소드로 호출되면 객체가 포함 된 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2be741d48d441b8c30f1f1c49c12f9fc308d28a8" translate="yes" xml:space="preserve">
          <source>. If defined, it should be a search list, each element of which specifies a location for &lt;code&gt;%ENV&lt;/code&gt; elements. If you tell Perl to read or set the element &lt;code&gt;$ENV{&lt;/code&gt;</source>
          <target state="translated">. 정의 된 경우 검색 목록이어야하며 각 요소는 &lt;code&gt;%ENV&lt;/code&gt; 요소 의 위치를 ​​지정합니다 . Perl에게 &lt;code&gt;$ENV{&lt;/code&gt; 요소를 읽거나 설정하도록 지시하면</target>
        </trans-unit>
        <trans-unit id="cb88233b9470d06775dbd0f8abd50e567ad6f88f" translate="yes" xml:space="preserve">
          <source>. If found, Perl checks the start of the file for magic strings &lt;code&gt;&quot;#!&quot;&lt;/code&gt; and &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; . If found, Perl uses the rest of the first line as the beginning of the command line to run this script. The only mangling done to the first line is extraction of arguments (currently up to 3), and ignoring of the path-part of the &quot;interpreter&quot; name if it can't be found using the full path.</source>
          <target state="translated">. 발견되면, Perl은 파일의 시작 부분에서 매직 문자열 &lt;code&gt;&quot;#!&quot;&lt;/code&gt; 를 확인합니다.그리고 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; . 발견되면 Perl은 나머지 첫 번째 행을 명령 행의 시작으로 사용하여이 스크립트를 실행합니다. 첫 번째 행에서 수행되는 유일한 문제는 인수를 추출하고 (현재 최대 3 개) &quot;통역사&quot;이름의 경로 부분을 전체 경로를 사용하여 찾을 수없는 경우 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7968febd03fe8bde1f86e5757cb445071be1de4f" translate="yes" xml:space="preserve">
          <source>. If it does not give an error -- wrong</source>
          <target state="translated">. 오류가 발생하지 않으면 잘못</target>
        </trans-unit>
        <trans-unit id="3246f36b641961e96375e555d041b988c40cef52" translate="yes" xml:space="preserve">
          <source>. If it has no repeat count or uses a '*', the number of available items is used.</source>
          <target state="translated">. 반복 횟수가 없거나 '*'를 사용하면 사용 가능한 항목 수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd29a6866d7877a8bab1f7946635ac6580b7bf2" translate="yes" xml:space="preserve">
          <source>. If successful, the instance</source>
          <target state="translated">. 성공하면 인스턴스</target>
        </trans-unit>
        <trans-unit id="c4f93a6d580968e7afb023f127bdef8253516411" translate="yes" xml:space="preserve">
          <source>. If the &lt;code&gt;/a&lt;/code&gt; regular expression modifier is in effect, it matches [0-9]. Otherwise, it matches anything that is matched by &lt;code&gt;\p{Digit}&lt;/code&gt; , which includes [0-9]. (An unlikely possible exception is that under locale matching rules, the current locale might not have &lt;code&gt;[0-9]&lt;/code&gt; matched by &lt;code&gt;\d&lt;/code&gt; , and/or might match other characters whose code point is less than 256. The only such locale definitions that are legal would be to match &lt;code&gt;[0-9]&lt;/code&gt; plus another set of 10 consecutive digit characters; anything else would be in violation of the C language standard, but Perl doesn't currently assume anything in regard to this.)</source>
          <target state="translated">. 는 IF &lt;code&gt;/a&lt;/code&gt; 정규식 개질제 사실상, 그것은 [0-9]와 일치한다. 그렇지 않으면 &lt;code&gt;\p{Digit}&lt;/code&gt; 과 일치하는 항목 ( [0-9] 포함 )과 일치합니다 . 로케일 일치 규칙에서 현재 로케일이 &lt;code&gt;\d&lt;/code&gt; 와 일치하는 &lt;code&gt;[0-9]&lt;/code&gt; 를 갖지 않거나 코드 포인트가 256보다 작은 다른 문자와 일치 할 수 있습니다. 합법적 인 것은 &lt;code&gt;[0-9]&lt;/code&gt; 와 10 개의 연속 숫자 문자를 추가하는 것입니다. 다른 언어는 C 언어 표준을 위반하지만, Perl은 현재 이것과 관련하여 어떤 것도 가정하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="ed7f56f814a53f5d8a3417d988acd289ad7a8311" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, or equal to the empty string, the state information will be read from STDIN.</source>
          <target state="translated">. 인수가 없거나 빈 문자열과 같으면 STDIN에서 상태 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5824b191dbb77148d2f73c4545651fad0017e95b" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, or equal to the empty string, the state information will be written to STDOUT.</source>
          <target state="translated">. 인수가 없거나 빈 문자열과 같으면 상태 정보가 STDOUT에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="86c19918bb0e315fb37ff3bcb89d4d1d00e53177" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, the object will continue using the same algorithm that was selected at creation.</source>
          <target state="translated">. 인수가 누락되면 객체는 생성시 선택한 것과 동일한 알고리즘을 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad394d00d49595ece3375d873bc65795f9a2a320" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_bin&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값이&amp;gt; UV_MAX의 경우 &lt;code&gt;grok_bin&lt;/code&gt; 의 반환 UV_MAX, 설정 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="340acc0c90a3ff630e29f3732ec436ada4a5d8ab" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_hex&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값이&amp;gt; UV_MAX 경우 &lt;code&gt;grok_hex&lt;/code&gt; 반환 UV_MAX, 설정 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="d2fe051154b3bd8b24a4c3334242986da9165e62" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_oct&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값 인 경우&amp;gt; UV_MAX의 &lt;code&gt;grok_oct&lt;/code&gt; 는 설정, UV_MAX를 반환 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="206aba5c7d9a84ce157c9a5e9c114a73d70137fc" translate="yes" xml:space="preserve">
          <source>. If there is no single code point folding defined for</source>
          <target state="translated">. 단일 코드 포인트 폴딩이 정의되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="1844efc2f3254e2a8d6a689f5eb6ab9ff69cba74" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3aca0699f7236e45654ffe7027a808f1c3c2b60" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions. If the array becomes smaller then entries beyond count should be deleted.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다. 배열이 작아지면 개수를 초과하는 항목을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="08fb67d65bc5a9b5387592c9b07f875d13efe0ce" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions. If the array becomes smaller then entries beyond count should be deleted.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다. 배열이 작아지면 개수를 초과하는 항목을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="42dfc7aa5f4468ffdf4e181f7b588d8c5857bc31" translate="yes" xml:space="preserve">
          <source>. If you get into link386 prompts, press &lt;code&gt;Ctrl-C&lt;/code&gt; to exit.</source>
          <target state="translated">. link386 프롬프트가 표시되면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 눌러 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7886d9569f9834e6bdaa9aa8eb1f34132432b7" translate="yes" xml:space="preserve">
          <source>. If you have such data then you should set &lt;code&gt;$Storable::interwork_56_64bit&lt;/code&gt; to a true value to make this Storable read and write files with the old header. You should also migrate your data, or any older perl you are communicating with, to this current version of Storable.</source>
          <target state="translated">. 이러한 데이터가있는 경우 &lt;code&gt;$Storable::interwork_56_64bit&lt;/code&gt; 를 true로 설정하여이 Storable이 기존 헤더로 파일을 읽고 쓸 수있게하십시오. 또한 데이터 또는 통신중인 이전 펄을이 현재 버전의 Storable로 마이그레이션해야합니다.</target>
        </trans-unit>
        <trans-unit id="d408ab7cf188c609a4c4840fba41a06a381a4651" translate="yes" xml:space="preserve">
          <source>. If your input lines might end in backslashes to indicate continuation, you want to skip ahead and get the next record.</source>
          <target state="translated">. 연속을 나타 내기 위해 입력 행이 백 슬래시로 끝나는 경우 계속 건너 뛰고 다음 레코드를 얻으려고합니다.</target>
        </trans-unit>
        <trans-unit id="1e5ca4130c539ef91a8bd43fde83a107301c6560" translate="yes" xml:space="preserve">
          <source>. If your platform doesn't support &lt;code&gt;NaN&lt;/code&gt; 's then &lt;code&gt;NaN&lt;/code&gt; is just a string with numeric value 0.</source>
          <target state="translated">. 플랫폼이 지원하지 않는 경우 &lt;code&gt;NaN&lt;/code&gt; 이 다음의를 &lt;code&gt;NaN&lt;/code&gt; 이는 숫자 값 0 단지 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a4ca80b61fe20e9969c2abb733817edd354f5d14" translate="yes" xml:space="preserve">
          <source>. In 2010, version 2 of the &lt;a href=&quot;../cpan/meta/spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; was released, which mandates JSON format for the metadata in order to overcome certain compatibility issues between YAML serializers and to avoid breaking older clients unable to handle a new version of the spec. The &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; library is now standard for accessing old and new-style Meta files.</source>
          <target state="translated">. 2010 년에 &lt;a href=&quot;../cpan/meta/spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt; 버전 2 가 릴리스되었습니다.이 버전은 YAML 시리얼 라이저 간의 특정 호환성 문제를 극복하고 새로운 버전의 사양을 처리 할 수없는 이전 클라이언트의 중단을 피하기 위해 메타 데이터에 대한 JSON 형식을 요구합니다. &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: 메타&lt;/a&gt; 도서관은 이제 과거와 새로운 스타일의 메타 파일에 액세스하기위한 표준이다.</target>
        </trans-unit>
        <trans-unit id="d1c4b644424154ce3fe835b9230b290135cb482a" translate="yes" xml:space="preserve">
          <source>. In addition, if none of the functions in a list begin with the string &lt;b&gt;boot_&lt;/b&gt;, &lt;code&gt;Mksymlists&lt;/code&gt; will add a bootstrap function for that package, just as xsubpp does. (If a &lt;b&gt;boot_&amp;lt;pkg&amp;gt;&lt;/b&gt; function is present in the list, it is passed through unchanged.) If DL_FUNCS is not specified, it defaults to the bootstrap function for the extension specified in NAME.</source>
          <target state="translated">. 또한,리스트의 어떤 함수도 문자열 &lt;b&gt;boot_로&lt;/b&gt; 시작하지 &lt;b&gt;않으면&lt;/b&gt; , &lt;code&gt;Mksymlists&lt;/code&gt; 는 xsubpp와 마찬가지로 해당 패키지에 대한 부트 스트랩 함수를 추가합니다. (a 경우 &lt;b&gt;boot_ &amp;lt;PKG&amp;gt;&lt;/b&gt; 기능 목록에 존재하고, 그것은 그대로 통과한다.) DL_FUNCS 지정하지 않으면, 디폴트 NAME에 지정된 내선 부트 스트랩 기능.</target>
        </trans-unit>
        <trans-unit id="c632e42e7e1458b43dc1ad99933142821a596870" translate="yes" xml:space="preserve">
          <source>. In fact,</source>
          <target state="translated">. 사실로,</target>
        </trans-unit>
        <trans-unit id="bce9b2b9f8142db7d9ce85b3fc070c1b985539e3" translate="yes" xml:space="preserve">
          <source>. In geographical terms</source>
          <target state="translated">. 지리적으로</target>
        </trans-unit>
        <trans-unit id="87c6ca62a4ff7bfc3de8b73b2cb60e71a538d7f6" translate="yes" xml:space="preserve">
          <source>. In the unlikely case this is not the correct root, it is possible to override this with a hint value or command line option. This will be used in subsequent tests for AFSness in the configure and test process.</source>
          <target state="translated">. 드문 경우이지만 이것이 올바른 루트가 아닌 경우 힌트 값 또는 명령 행 옵션으로이를 대체 할 수 있습니다. 이는 구성 및 테스트 프로세스에서 AFSness에 대한 후속 테스트에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbd585e38f590ba194a3793f06f22dab045cf12" translate="yes" xml:space="preserve">
          <source>. In this case all the above are true (but very simple) functions which call the underlying implementation.</source>
          <target state="translated">. 이 경우 위의 모든 것은 기본 구현을 호출하는 참 (그러나 매우 간단한) 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d360c3eb53a832cf7747d52bf236e2b0eebf4a3e" translate="yes" xml:space="preserve">
          <source>. In those cases when you &lt;b&gt;require&lt;/b&gt; a &lt;b&gt;.ph&lt;/b&gt; file containing syntax errors, instead of the cryptic</source>
          <target state="translated">. 이 경우 암호 대신 구문 오류가 포함 된 &lt;b&gt;.ph&lt;/b&gt; 파일 이 &lt;b&gt;필요한&lt;/b&gt; 경우&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7b376a04246f5e00596e857391b316083a63b99d" translate="yes" xml:space="preserve">
          <source>. In turn, this hooks into an XSUB,</source>
          <target state="translated">. 차례로 이것은 XSUB에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3420f60f0bca96a2a73c405a1a85c20704cb3bc5" translate="yes" xml:space="preserve">
          <source>. Individual modules in</source>
          <target state="translated">. 개별 모듈</target>
        </trans-unit>
        <trans-unit id="a59f10c336a81d1ca73f037a2b8c92f6334418a6" translate="yes" xml:space="preserve">
          <source>. Inspect the &lt;code&gt;install&lt;/code&gt; logs (in the example above</source>
          <target state="translated">. 위의 예에서 &lt;code&gt;install&lt;/code&gt; 로그를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="25184bf63945467203d08f0de2a23c0f6dd54c05" translate="yes" xml:space="preserve">
          <source>. Instead, it will localize perl's notion of which filehandle &lt;code&gt;$.&lt;/code&gt; is currently aliased to.</source>
          <target state="translated">. 대신, 어떤 파일 핸들 &lt;code&gt;$.&lt;/code&gt; 대한 펄의 개념을 현지화 합니다. 현재 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="99f7f86480d4ea94cae9f5397fe0142ca2f2d10b" translate="yes" xml:space="preserve">
          <source>. It cannot be cleared or deleted; attempts to do so are silently ignored.</source>
          <target state="translated">. 지우거나 삭제할 수 없습니다. 그렇게하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f2139db1ad9c91528643fba773777f505b8d50" translate="yes" xml:space="preserve">
          <source>. It has the values &quot;unsigned char&quot; or &lt;code&gt;char&lt;/code&gt; .</source>
          <target state="translated">. &quot;unsigned char&quot;또는 &lt;code&gt;char&lt;/code&gt; 값이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f17a09d380724a3716b787a41ebd4613a73ee6f" translate="yes" xml:space="preserve">
          <source>. It is a plain '' if this is not the &lt;code&gt;GNU&lt;/code&gt; C library, or if the version is unknown.</source>
          <target state="translated">. 이것이 &lt;code&gt;GNU&lt;/code&gt; C 라이브러리 가 아니 거나 버전을 알 수없는 경우 '' 입니다.</target>
        </trans-unit>
        <trans-unit id="d9968fc8b94f6a056c1a481b9936f565e393c904" translate="yes" xml:space="preserve">
          <source>. It is also used instead of explicit</source>
          <target state="translated">. 명시 적 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d96c04f9a51ab5f437bd463e742a0003313be347" translate="yes" xml:space="preserve">
          <source>. It is conventionally invoked using the driver script &lt;b&gt;pod2man&lt;/b&gt;, but it can also be used directly.</source>
          <target state="translated">. 일반적으로 드라이버 스크립트 &lt;b&gt;pod2man을&lt;/b&gt; 사용하여 호출 되지만 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f513dd8d11fda24e9b49a220d530308d617cc39e" translate="yes" xml:space="preserve">
          <source>. It is defined primarily for backwards compatibility.</source>
          <target state="translated">. 기본적으로 이전 버전과의 호환성을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e2436b894ff16e0565f80d082127a7c7776b277b" translate="yes" xml:space="preserve">
          <source>. It is mainly used by other Configure units.</source>
          <target state="translated">. 주로 다른 구성 단위에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb63e0a589c7c79183e0aee5a650e0d846db99ab" translate="yes" xml:space="preserve">
          <source>. It is unrelated to English</source>
          <target state="translated">. 영어와 관련이 없습니다</target>
        </trans-unit>
        <trans-unit id="b38290ed6629f0ba79cc60e3f039d22be0b31883" translate="yes" xml:space="preserve">
          <source>. It will always be 0.</source>
          <target state="translated">. 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="c8ebeb64dfaf88dcb282fb968e8e06bb8fcc9b5f" translate="yes" xml:space="preserve">
          <source>. It will use the following search path to find default typemaps, with the rightmost typemap taking precedence.</source>
          <target state="translated">. 다음 검색 경로를 사용하여 가장 오른쪽의 유형 맵이 우선하는 기본 유형 맵을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="47b5a45699abc71afa96d3e0e904645134ffab28" translate="yes" xml:space="preserve">
          <source>. It works similar to the result of the Unix command</source>
          <target state="translated">. 유닉스 명령의 결과와 비슷하게 작동합니다</target>
        </trans-unit>
        <trans-unit id="4cf942d7c5a7a7cc8b5f51dca65695a4b4f21342" translate="yes" xml:space="preserve">
          <source>. It's an alternative to &lt;code&gt;make test&lt;/code&gt; .</source>
          <target state="translated">. &lt;code&gt;make test&lt;/code&gt; 대체하는 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="f65c423102d4b2bb387d6ce7ac29cea0b802bdc1" translate="yes" xml:space="preserve">
          <source>. Just follow the instructions, and 99% of the installation blues would go away.</source>
          <target state="translated">. 지침을 따르기 만하면 설치 블루스의 99 %가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="f878690035ca0e58b744826cf63a8295cfc9f70e" translate="yes" xml:space="preserve">
          <source>. Later we'll see that this specification can contain more than just the option name. The reference to the variable is called the option</source>
          <target state="translated">. 나중에 우리는이 스펙이 옵션 이름 이상의 것을 포함 할 수 있음을 알게 될 것입니다. 변수에 대한 참조를 옵션이라고합니다</target>
        </trans-unit>
        <trans-unit id="c4bea9eaa9bee5e3756e1d73231b1234be2ae6f1" translate="yes" xml:space="preserve">
          <source>. Mac OS support by Paul Schinder &amp;lt;schinder@pobox.com&amp;gt; and Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;.</source>
          <target state="translated">. Paul Schinder &amp;lt;schinder@pobox.com&amp;gt; 및 Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;의 Mac OS 지원</target>
        </trans-unit>
        <trans-unit id="d2af23a9a799aeb1d6f76fd39a5251808a1a50e8" translate="yes" xml:space="preserve">
          <source>. More information on how to write good perldelta entries is available in the &lt;code&gt;Style&lt;/code&gt; section of</source>
          <target state="translated">. 좋은 perldelta 항목을 작성하는 방법에 대한 자세한 내용은 &lt;code&gt;Style&lt;/code&gt; 섹션 에서 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5fa79d5fe358db59b924db9e3afc91c8c4c97989" translate="yes" xml:space="preserve">
          <source>. None of the other processing of &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;pad_add_name_pvn in perlapi&lt;/a&gt; is done. Returns the offset of the allocated pad slot.</source>
          <target state="translated">. &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;perlapi에서 pad_add_name_pvn&lt;/a&gt; 의 다른 처리 는 수행되지 않습니다. 할당 된 패드 슬롯의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7039f806afb4a2ecb55b3bcaacedf3640a4cd77" translate="yes" xml:space="preserve">
          <source>. Note that all names passed to the user's</source>
          <target state="translated">. 모든 이름은 사용자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="15bf0a4269dea3ad18ee10b385dbdaef11b74bf4" translate="yes" xml:space="preserve">
          <source>. Note that before these macros were added, Perl internals used to directly use character literals, so you may occasionally come across old code or documentation referring to 'U' magic rather than &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; for example.</source>
          <target state="translated">. 이러한 매크로가 추가되기 전에 Perl 내부는 문자 리터럴을 직접 사용하는 데 사용 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; , 예를 들어 PERL_MAGIC_uvar 가 아닌 'U'매직을 참조하는 오래된 코드 나 문서가 종종 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d06789deb8b5a7ca71d14547a85c1b9baded3394" translate="yes" xml:space="preserve">
          <source>. Note that extension code should</source>
          <target state="translated">. 확장 코드는</target>
        </trans-unit>
        <trans-unit id="12457e722ccfc654c8bad69405188c5af0f50ae7" translate="yes" xml:space="preserve">
          <source>. Now we can add our tests to the end. First, we'll test that the &lt;code&gt;U&lt;/code&gt; does indeed create Unicode strings.</source>
          <target state="translated">. 이제 테스트를 끝에 추가 할 수 있습니다. 먼저 &lt;code&gt;U&lt;/code&gt; 가 실제로 유니 코드 문자열을 생성 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="95d8b82e403a24e94a8215ff5138e9129ce71d0a" translate="yes" xml:space="preserve">
          <source>. Of course, it'll need to be executable first, so &lt;code&gt;chmod 755 script.pl&lt;/code&gt; (under Unix).</source>
          <target state="translated">. 물론, 먼저 실행 가능해야하므로 &lt;code&gt;chmod 755 script.pl&lt;/code&gt; (Unix 아래).</target>
        </trans-unit>
        <trans-unit id="537b462bbd527cd649466c0e0e150e64a30e9e53" translate="yes" xml:space="preserve">
          <source>. On operating systems which do not require a specific extension for executable files, this variable is empty.</source>
          <target state="translated">. 실행 파일에 특정 확장자가 필요없는 운영 체제에서이 변수는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55026f126a81b220971a849c6c2cb68bb628095e" translate="yes" xml:space="preserve">
          <source>. Once the enclosing &quot;&amp;lt; ... &amp;gt;&quot; is removed, this is passed (more or less) unchanged to &lt;code&gt;File::Glob&lt;/code&gt; to carry out a file match.</source>
          <target state="translated">. 둘러싸는 &quot;&amp;lt;...&amp;gt;&quot;가 제거되면 파일 일치를 수행하기 위해 &lt;code&gt;File::Glob&lt;/code&gt; 에 변경없이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="96e2b5e9bec44f8daa5c9f8eb8f20596cf31be4b" translate="yes" xml:space="preserve">
          <source>. One more rule is needed to understand how a match is determined for the whole regular expression: a match at an earlier position is always better than a match at a later position.</source>
          <target state="translated">. 전체 정규식에 대해 일치가 결정되는 방식을 이해하려면 규칙이 하나 더 필요합니다. 이전 위치의 일치는 항상 이후 위치의 일치보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="4160bde3f72822338469aa8433b4b5304c3dcc97" translate="yes" xml:space="preserve">
          <source>. One way to do this on some systems is to set the environment variable &lt;code&gt;LD_RUN_PATH&lt;/code&gt; to the directory that will be the final location of the shared</source>
          <target state="translated">. 일부 시스템에서이를 수행하는 한 가지 방법은 환경 변수 &lt;code&gt;LD_RUN_PATH&lt;/code&gt; 를 공유의 최종 위치가 될 디렉토리로 설정하는 것입니다</target>
        </trans-unit>
        <trans-unit id="7be1ea0808dfeddc5a5ce7a2663e5bdfc11b4e99" translate="yes" xml:space="preserve">
          <source>. Otherwise it matches any character but &lt;code&gt;\n&lt;/code&gt; .</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;\n&lt;/code&gt; 이외의 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d6969174e97789c0a8cbd61099ffc2a91dee5f32" translate="yes" xml:space="preserve">
          <source>. Otherwise, if the</source>
          <target state="translated">. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="41e0e8c07d38f87111e8a525a5b3f67ff5e752ad" translate="yes" xml:space="preserve">
          <source>. Otherwise, it returns the value of &lt;code&gt;$@&lt;/code&gt; associated with the thread's execution status in its &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; context.</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 컨텍스트 에서 스레드의 실행 상태와 관련된 &lt;code&gt;$@&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b1e71ea4d22f53b2eb30fcb146b06118897444ae" translate="yes" xml:space="preserve">
          <source>. Over the years, it has become standard to keep this information in one or more CPAN Meta files distributed with each distribution.</source>
          <target state="translated">. 수년에 걸쳐이 정보를 각 배포와 함께 배포 된 하나 이상의 CPAN 메타 파일에 보관하는 것이 표준이되었습니다.</target>
        </trans-unit>
        <trans-unit id="06cf8affd89236a0eecaaa78bccddd732862b6d8" translate="yes" xml:space="preserve">
          <source>. Page numbers derive from the hardcover edition, first published in 1983 by George Allen &amp;amp; Unwin; no page numbers changed for the special 3-volume omnibus edition of 2002 or the various trade-paper editions, all again now by Harper Collins or Houghton Mifflin.</source>
          <target state="translated">. 페이지 번호는 1983 년 George Allen &amp;amp; Unwin이 처음 출판 한 하드 커버 에디션에서 파생됩니다. Harper Collins 또는 Houghton Mifflin에 의해 2002 년의 특수한 3 권 옴니버스 판이나 다양한 무역 용지 판에 대한 페이지 번호는 바뀌지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d4f4aa3da68de58187b7c018e5336cbc71134a54" translate="yes" xml:space="preserve">
          <source>. People who are interested in how to localize things in the containing scope should take a look there too.</source>
          <target state="translated">. 포함하는 범위에서 사물을 현지화하는 방법에 관심이있는 사람들도 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="c2b14d3f3d78674e56bc67813f86b24d2db0c711" translate="yes" xml:space="preserve">
          <source>. Perhaps what we ought to do is take the hard-wired value from</source>
          <target state="translated">. 아마도 우리가해야 할 일은 고정 된 가치를</target>
        </trans-unit>
        <trans-unit id="1bb197e77339ac738cd4c23655f60abef9ee8faa" translate="yes" xml:space="preserve">
          <source>. Perl does not do this for you. The &lt;code&gt;passwd&lt;/code&gt; is one-way hashed garble, not clear text, and may not be unhashed save by brute-force guessing. Secure systems use more a more secure hashing than DES. On systems supporting shadow password systems, Perl automatically returns the shadow password entry when called by a suitably empowered user, even if your underlying vendor-provided C library was too short-sighted to realize it should do this.</source>
          <target state="translated">. 펄은 당신을 위해 이것을하지 않습니다. &lt;code&gt;passwd&lt;/code&gt; 파일은 편도가 제대로 해석하지 일반 텍스트를 해시하고 추측 무차별로 저장 해시되지되지 않을 수 있습니다. 보안 시스템은 DES보다 더 안전한 해싱을 사용합니다. 섀도 암호 시스템을 지원하는 시스템에서 Perl은 기본 공급 업체 제공 C 라이브러리가 너무 짧아도이를 수행 할 수없는 경우에도 적절한 권한을 가진 사용자가 호출하면 섀도 암호 항목을 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c2d4fd11e3c3c2ef4d3668c3eb6e94ff499b67de" translate="yes" xml:space="preserve">
          <source>. Perl isn't much like other computer languages; it's highly context sensitive at times, it can be tricky to work out what sort of token something is, or where a token ends. As such, there's a lot of interplay between the tokeniser and the parser, which can get pretty frightening if you're not used to it.</source>
          <target state="translated">. 펄은 다른 컴퓨터 언어와 크게 다르지 않다. 때로는 문맥에 매우 민감하기 때문에 어떤 종류의 토큰인지 또는 토큰이 끝나는 곳을 해결하는 것이 까다로울 수 있습니다. 따라서 토큰 화기와 파서 사이에는 많은 상호 작용이 있으므로 익숙하지 않으면 상당히 무섭습니다.</target>
        </trans-unit>
        <trans-unit id="cba1355f82c45a8fef21484f747404a76ae86f23" translate="yes" xml:space="preserve">
          <source>. Please remove this variable and put &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">. 이 변수를 제거하고 대신 &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; 을 넣으 십시오 .</target>
        </trans-unit>
        <trans-unit id="3f1457da5e48adfeddc76831c3066a31d1b57f2e" translate="yes" xml:space="preserve">
          <source>. Pod processors should warn about this being deprecated syntax.</source>
          <target state="translated">. 포드 프로세서는이 사용되지 않는 구문에 대해 경고해야합니다.</target>
        </trans-unit>
        <trans-unit id="78d896e0ef56e1d24740ae6e5074e45f9bb5ff12" translate="yes" xml:space="preserve">
          <source>. Programs must be prepared to deal with</source>
          <target state="translated">. 처리 할 프로그램을 준비해야합니다</target>
        </trans-unit>
        <trans-unit id="46be1dc32b301883ac9f960a586983088faefae1" translate="yes" xml:space="preserve">
          <source>. Programs using this variable must be prepared to deal with</source>
          <target state="translated">. 이 변수를 사용하는 프로그램은 처리 할 준비가되어 있어야합니다</target>
        </trans-unit>
        <trans-unit id="cd020a4f288e77d95d879b2ff99123114284aae5" translate="yes" xml:space="preserve">
          <source>. Programs using this variable must be prepared to deal with filename expansion.</source>
          <target state="translated">. 파일 이름 확장을 처리하려면이 변수를 사용하는 프로그램을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="16f0fa2c6457ccd5a1bef736f8b2f051584ca655" translate="yes" xml:space="preserve">
          <source>. Rarely needed.</source>
          <target state="translated">. 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab6a7d315e0a4101b03879bac7a3a3c3731c445f" translate="yes" xml:space="preserve">
          <source>. Returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no matching</source>
          <target state="translated">. 일치하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="17bd24a798e55f262ddde9c7e4ea74e8f691a79b" translate="yes" xml:space="preserve">
          <source>. Returns the new file position, or -1 if an error occurs.</source>
          <target state="translated">. 새 파일 위치를 반환하거나 오류가 발생하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4717fd7dfaf37fd66e5c1a6c2440f1a17feb75b" translate="yes" xml:space="preserve">
          <source>. Roles are relatively new to Perl, but have become rather popular. Roles are &lt;b&gt;applied&lt;/b&gt; to classes. Sometimes we say that classes &lt;b&gt;consume&lt;/b&gt; roles.</source>
          <target state="translated">. 역할은 Perl에 비교적 새로운 것이지만 다소 인기가 있습니다. 역할은 수업 에 &lt;b&gt;적용&lt;/b&gt; 됩니다. 때때로 우리는 클래스가 &lt;b&gt;소비&lt;/b&gt; 한다고 말합니다&lt;b&gt;&lt;/b&gt; 역할을 .</target>
        </trans-unit>
        <trans-unit id="85adbd9d6de0bb6d69a95e5ac09cd801db6ef4b2" translate="yes" xml:space="preserve">
          <source>. Running the profiled version of Perl will create an output file called</source>
          <target state="translated">. 프로파일 링 된 Perl 버전을 실행하면 다음과 같은 출력 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e550a655605c6f097b311744bc2ad2d1f7e02cd4" translate="yes" xml:space="preserve">
          <source>. Save your work and repeat...</source>
          <target state="translated">. 작업을 저장하고 반복하십시오 ...</target>
        </trans-unit>
        <trans-unit id="7143f409794e5396a72f2a6b101a534fc0b07928" translate="yes" xml:space="preserve">
          <source>. See</source>
          <target state="translated">. 보다</target>
        </trans-unit>
        <trans-unit id="0dc553c5d634355fec3724ccd2a074361b8ba50a" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-(%40INC)-at-runtime%3f&quot;&gt;How do I add a directory to my include path (@INC) at runtime?&lt;/a&gt; for details on how to run your newly installed modules.</source>
          <target state="translated">. &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-(%40INC)-at-runtime%3f&quot;&gt;런타임에 포함 경로 (@INC)에 디렉토리를 추가하는 방법을&lt;/a&gt; 참조하십시오 . 새로 설치된 모듈을 실행하는 방법에 대한 자세한 내용.</target>
        </trans-unit>
        <trans-unit id="ba073e24f104c94d46d8d40d53b310f205b091a4" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="108cb27bf7c8d7031e4a5603b633fe94497e91da" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#sv_magic&quot;&gt;sv_magic&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#sv_magic&quot;&gt;sv_magic을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1981f0c642c0f907ef847d7c17536d36f0ee8920" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;../../perlref&quot;&gt;perlref&lt;/a&gt; for more details on the mechanics of</source>
          <target state="translated">. 역학에 대한 자세한 내용 은 &lt;a href=&quot;../../perlref&quot;&gt;perlref&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10889f2e8189c79b1f86ade1e2c38e0b8038ce1d" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="065f520588be974c5594d0397ea3e63f2dce18b1" translate="yes" xml:space="preserve">
          <source>. See AUTHORS for a full list of people involved. For any questions, send mail to</source>
          <target state="translated">. 관련된 사람들의 전체 목록은 저자를 참조하십시오. 질문이 있으시면 메일을 보내주십시오</target>
        </trans-unit>
        <trans-unit id="1da2f25ee6e37cb910fd70d32927a95fc37e978b" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="526666d33c6dd6f0edce27a1b78dfa10ea26ace5" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269fb40594ac38479767dd170994fea4ce252e54" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73ed177a1496b0ffabfd429dcad99a1b5e86269c" translate="yes" xml:space="preserve">
          <source>. See man1dir.</source>
          <target state="translated">. man1dir을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="37f30b22c5af4841496858a795207dcf79c50797" translate="yes" xml:space="preserve">
          <source>. See man3dir.</source>
          <target state="translated">. man3dir을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c34835277b46e71de0c02bf6cf0f02eefcb4f7c6" translate="yes" xml:space="preserve">
          <source>. See the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">. Camel 5 장, &quot;패턴 일치&quot; 의 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="532cefe5f4e0e07491434bf06b22de1364858a22" translate="yes" xml:space="preserve">
          <source>. Sigh!</source>
          <target state="translated">. 한숨!</target>
        </trans-unit>
        <trans-unit id="15721d069cd060fbc46f89e07bfe13ca468f8232" translate="yes" xml:space="preserve">
          <source>. Similarly, \x</source>
          <target state="translated">. 마찬가지로 \ x</target>
        </trans-unit>
        <trans-unit id="e7f91a5e70762d437d2b010c7f3894adf3f22e05" translate="yes" xml:space="preserve">
          <source>. Since we're going to be altering this file, let's copy it to</source>
          <target state="translated">. 이 파일을 변경할 것이므로 복사 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a4b19e5f2af8ac1ad558abf4f3e809cbb78dad50" translate="yes" xml:space="preserve">
          <source>. Some non-western languages require more complicated models, so Unicode created the</source>
          <target state="translated">. 서구 이외의 일부 언어에는 더 복잡한 모델이 필요하므로 유니 코드는</target>
        </trans-unit>
        <trans-unit id="924583291a21ac53f389c53cb7d36575da128db8" translate="yes" xml:space="preserve">
          <source>. Sometimes confused with &lt;code&gt;PATH&lt;/code&gt; .</source>
          <target state="translated">. 때때로 &lt;code&gt;PATH&lt;/code&gt; 와 혼동 .</target>
        </trans-unit>
        <trans-unit id="f60154f92db701fa8dfa7c281d9f6dd872168811" translate="yes" xml:space="preserve">
          <source>. Source filters alter the program text of a module before Perl sees it, much as a C preprocessor alters the source text of a C program before the compiler sees it. This article tells you more about what source filters are, how they work, and how to write your own.</source>
          <target state="translated">. C 프리 프로세서가 C 프로그램의 소스 텍스트를 컴파일러가보기 전에 변경하는 것처럼 소스 필터는 Perl이보기 전에 모듈의 프로그램 텍스트를 변경합니다. 이 기사에서는 소스 필터의 정의, 작동 방식 및 직접 작성하는 방법에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c5324fa1cfeb6989f1cc904db6d96f2b5cf34a5f" translate="yes" xml:space="preserve">
          <source>. Specifically, the function is applied to an &lt;code&gt;entersub&lt;/code&gt; op tree for a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time as</source>
          <target state="translated">. 특히,이 함수는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 표시되지 않은 서브 루틴 호출 을위한 &lt;code&gt;entersub&lt;/code&gt; op 트리에 적용되며 , 여기서 호출 수신자는 다음과 같이 컴파일 시간에 식별 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719bbeb528773685892fbb466263ed7992f1ef35" translate="yes" xml:space="preserve">
          <source>. Stratus &lt;code&gt;VOS&lt;/code&gt; uses</source>
          <target state="translated">. Stratus &lt;code&gt;VOS&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="74794f3a0f64eaaac38d6eec10e61e0bb7ca4ab9" translate="yes" xml:space="preserve">
          <source>. Subpatterns are numbered based on the left to right order of their opening parenthesis. A backreference matches whatever actually matched the subpattern in the string being examined, not the rules for that subpattern. Therefore, &lt;code&gt;(0|0x)\d*\s\g1\d*&lt;/code&gt; will match &quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;, because subpattern 1 matched &quot;0x&quot;, even though the rule &lt;code&gt;0|0x&lt;/code&gt; could potentially match the leading 0 in the second number.</source>
          <target state="translated">. 하위 패턴은 여는 괄호의 왼쪽에서 오른쪽 순서에 따라 번호가 매겨집니다. 역 참조는 검사중인 문자열에서 하위 패턴과 실제로 일치하는 항목과 일치하며 해당 하위 패턴의 규칙은 아닙니다. 따라서, &lt;code&gt;(0|0x)\d*\s\g1\d*&lt;/code&gt; 1 서브 패턴은 &quot;0X&quot;를 일치하기 때문에 심지어 규칙 불구하고,하지 &quot;0x1234 01234&quot;를 &quot;0x1234 0x4321&quot;와 일치하지만 것 &lt;code&gt;0|0x&lt;/code&gt; 잠재적으로 일치 할 수있는 두 번째 숫자에서 선행 0입니다.</target>
        </trans-unit>
        <trans-unit id="0bd33c43194e6d65ba167a5061ae6b129a64b1cb" translate="yes" xml:space="preserve">
          <source>. Such discretionary locks are more flexible, but offer fewer guarantees. This means that files locked with flock() may be modified by programs that do not also use flock(). Cars that stop for red lights get on well with each other, but not with cars that don't stop for red lights. See the perlport manpage, your port's specific documentation, or your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (If you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 즉, flock ()을 사용하지 않는 프로그램은 flock ()으로 잠겨있는 파일을 수정할 수 있습니다. 빨간불로 멈춘 차들은 서로 잘 어울리지 만 빨간불로 멈추지 않는 차들에는 맞지 않습니다. 자세한 내용은 perlport 맨 페이지, 포트 별 설명서 또는 시스템 별 로컬 맨 페이지를 참조하십시오. 이식 가능한 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않은 경우, 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 성실한 준수가 업무 수행에 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="0219e78f15e9d632ec155375033bbb1f75756ae3" translate="yes" xml:space="preserve">
          <source>. Test::More will output special ok's which Test::Harness interprets as skipped, but passing, tests.</source>
          <target state="translated">. Test :: More는 특별한 ok를 출력합니다. Test :: Harness는 건너 뛰지 만 통과하는 테스트로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="509fc989a8df02d181de3abd4b07ad24cc68349f" translate="yes" xml:space="preserve">
          <source>. Text following</source>
          <target state="translated">. 다음 텍스트</target>
        </trans-unit>
        <trans-unit id="96afc36fdc9cac6d245d493ea1697bcf23f65cf9" translate="yes" xml:space="preserve">
          <source>. That is, every (possibly wide) character gets replaced with a sequence of one or more characters that represent the individual</source>
          <target state="translated">. 즉, 모든 (아마도 넓은) 문자는 개인을 나타내는 하나 이상의 문자 시퀀스로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ee68fda4cc70d1e9047807e735452ddfef368e" translate="yes" xml:space="preserve">
          <source>. That means that if $fred is a lexical variable created with my() in the above example, the code wouldn't work at all: you'd accidentally access the global and skip right over the private lexical altogether. Global variables are bad because they can easily collide accidentally and in general make for non-scalable and confusing code.</source>
          <target state="translated">. 즉, $ fred가 위 예제에서 my ()로 만든 어휘 변수 인 경우 코드가 전혀 작동하지 않습니다. 실수로 전역에 액세스하고 개인 어휘를 건너 뛸 수 있습니다. 전역 변수는 실수로 쉽게 충돌 할 수 있고 일반적으로 확장 불가능하고 혼란스러운 코드를 만들 수 있기 때문에 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71cc74e6abc0852795fc00a102b3c6afa72a3049" translate="yes" xml:space="preserve">
          <source>. That way, the longer-lived variable will contain the expected reference until it goes out of scope.</source>
          <target state="translated">. 이렇게하면 수명이 긴 변수에 범위를 벗어날 때까지 예상 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="338bcb0d0b4f6443c09736e45408c62579701cfd" translate="yes" xml:space="preserve">
          <source>. The</source>
          <target state="translated">. 그만큼</target>
        </trans-unit>
        <trans-unit id="fe300fb39c3e404963696de90c5f2b8fb1f4b10d" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma can be used to establish default I/O layers. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마는 기본 I / O 레이어를 설정하는 데 사용할 수 있습니다. &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b7a7d48b732a7b49c73edd40605094cd605257" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operator assumes this so you don't have to spell out &quot;</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 당신이 &quot;밖으로 철자 할 필요가 없습니다 연산자는이 가정</target>
        </trans-unit>
        <trans-unit id="1d02d641b2daae8c8291ce30497232a482994b97" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma can be used to establish default I/O layers. See &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마는 기본 I / O 레이어를 설정하는 데 사용할 수 있습니다. &lt;a href=&quot;../open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d34046a75c4b4b70cb801b77ce3dd9d1f648ec86" translate="yes" xml:space="preserve">
          <source>. The C subroutine it calls defaults to the name of the perl visible subroutine, unless you give the parameter</source>
          <target state="translated">. 매개 변수를 제공하지 않는 한, 호출하는 C 서브 루틴은 기본적으로 perl visible 서브 루틴의 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9397ab7f8e9744e2e3279022e0ab86d9f126e59f" translate="yes" xml:space="preserve">
          <source>. The amount of data in the read cache will not exceed the value you specified for &lt;code&gt;memory&lt;/code&gt; . If &lt;code&gt;Tie::File&lt;/code&gt; wants to cache a new record, but the read cache is full, it will make room by expiring the least-recently visited records from the read cache.</source>
          <target state="translated">. 읽기 캐시의 데이터 양은 &lt;code&gt;memory&lt;/code&gt; 지정한 값을 초과하지 않습니다 . 경우 &lt;code&gt;Tie::File&lt;/code&gt; 새 레코드를 캐시 싶어하지만 읽기 캐시가 가득, 그것은 읽기 캐시에서 가장 최근에 방문한 기록을 만료하여 공간을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="79601f5e82d6d993fd5c764e5bd99eacf802094f" translate="yes" xml:space="preserve">
          <source>. The arrow operator (&lt;code&gt;-&amp;gt;&lt;/code&gt; ) tells Perl that we are calling a method.</source>
          <target state="translated">. 화살표 연산자 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )는 Perl에게 메소드를 호출하고 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4ce742f8603278d1cc939bb3c2667ef58a5b743a" translate="yes" xml:space="preserve">
          <source>. The base64 encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used, enabling 6 bits to be represented per printable character.</source>
          <target state="translated">. base64 인코딩은 사람이 읽을 수없는 형태로 임의의 8 진수 시퀀스를 나타내도록 설계되었습니다. US-ASCII의 65 자 서브셋 ([A-Za-z0-9 + / =])이 사용되어 인쇄 가능한 문자 당 6 비트를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="132df5e01ce9879e06e9a0bb9623693b913390a1" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;lex_stuff_sv&lt;/a&gt; function is more convenient.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열을 Perl 스칼라로 사용할 수 &lt;a href=&quot;#lex_stuff_sv&quot;&gt;있으면 lex_stuff_sv&lt;/a&gt; 함수가 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d893afc509f6379c799028f22bba6115198b3dd0" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열이 아직 Perl 스칼라가 아닌 경우 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; 함수는 스칼라를 구성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee8a3d9771584b9a4ccf95284b3a8174d3f9cca7" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; function is more appropriate.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열을 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;널&lt;/a&gt; 종료하는 것이 편리하지 않은 경우 lex_stuff_pvn 함수가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="09b2a2d176e198b26fa708993e686fdffc215703" translate="yes" xml:space="preserve">
          <source>. The declaration &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; disables this feature, which can cause all sorts of trouble if you use it by accident.</source>
          <target state="translated">. 선언의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; 실수로 그것을 사용하는 경우 문제의 모든 종류를 일으킬 수있는이 기능을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1f924a7620bcb58b87a1f9d9dd3fdfe4c62ff669" translate="yes" xml:space="preserve">
          <source>. The default is &quot;User Contributed Perl Documentation&quot;, but also see &lt;b&gt;--official&lt;/b&gt; below.</source>
          <target state="translated">. 기본값은 &quot;User Contributed Perl Documentation&quot;이지만 아래의 &lt;b&gt;--official&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="618c078508491fbfb47de5b8a07926b3458d7d8d" translate="yes" xml:space="preserve">
          <source>. The default library locations (e.g. privlib, sitelib) are either</source>
          <target state="translated">. 기본 라이브러리 위치 (예 : privlib, sitelib)는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="632ab13141757f9e687de51db78b780c50b12aa3" translate="yes" xml:space="preserve">
          <source>. The directory tree is left untouched.</source>
          <target state="translated">. 디렉토리 트리는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a378991e2ff9bbc4e73fa61ee57c00bdd052b15d" translate="yes" xml:space="preserve">
          <source>. The equivalent test can be made in C by using the &lt;code&gt;GIMME_V&lt;/code&gt; macro, which returns &lt;code&gt;G_ARRAY&lt;/code&gt; if you have been called in a list context, &lt;code&gt;G_SCALAR&lt;/code&gt; if in a scalar context, or &lt;code&gt;G_VOID&lt;/code&gt; if in a void context (i.e., the return value will not be used). An older version of this macro is called &lt;code&gt;GIMME&lt;/code&gt; ; in a void context it returns &lt;code&gt;G_SCALAR&lt;/code&gt; instead of &lt;code&gt;G_VOID&lt;/code&gt; . An example of using the &lt;code&gt;GIMME_V&lt;/code&gt; macro is shown in section</source>
          <target state="translated">. 목록 컨텍스트에서 &lt;code&gt;G_SCALAR&lt;/code&gt; 경우 G_ARRAY , 스칼라 컨텍스트 인 경우 &lt;code&gt;G_VOID&lt;/code&gt; 또는 void 컨텍스트 인 경우 &lt;code&gt;G_ARRAY&lt;/code&gt; 를 리턴 하는 &lt;code&gt;GIMME_V&lt;/code&gt; 매크로 를 사용하여 C에서 동등한 테스트를 수행 할 수 있습니다 (예 : 리턴 값이 익숙한). 이 매크로의 이전 버전을 &lt;code&gt;GIMME&lt;/code&gt; 라고 합니다 . 무효 맥락에서 반환 &lt;code&gt;G_SCALAR&lt;/code&gt; 대신 &lt;code&gt;G_VOID&lt;/code&gt; 을 . &lt;code&gt;GIMME_V&lt;/code&gt; 매크로 를 사용하는 예는 섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd333b30838b1fdef268a889fd4cb7c1f09da13" translate="yes" xml:space="preserve">
          <source>. The expression \c</source>
          <target state="translated">. 표현 \ c</target>
        </trans-unit>
        <trans-unit id="ef482f58ec037bafd28af56e419d7d82b45dc684" translate="yes" xml:space="preserve">
          <source>. The facility must be enabled first by a pragmatic declaration, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; , and it will produce a warning unless the &quot;experimental::signatures&quot; warnings category is disabled.</source>
          <target state="translated">. 이 기능은 실용적 선언으로 기능을 먼저 활성화하고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하며 &quot;experimental :: signatures&quot;경고 범주를 비활성화하지 않으면 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="993996ea1755cbddf6e3835d13a493c47b042aa6" translate="yes" xml:space="preserve">
          <source>. The failures are caused by bugs in the CRT in VC++ 2013 which will be fixed in future releases of VC++, as explained by Microsoft here: &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&lt;/a&gt;. In the meantime, if you need fixed &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt; functions then have a look at the CPAN distribution Win32::UTCFileTime.</source>
          <target state="translated">. 이 오류는 Microsoft에서 설명하는 &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-&lt;/a&gt; VC ++ 2013의 CRT 버그로 인해 향후 VC ++ 릴리스에서 수정 될 예정입니다. -실시간 c-2013에서 올바른 파일 시간을 설정하지 못했습니다 . 그 동안 고정 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt; 기능 이 필요한 경우 CPAN 분포 Win32 :: UTCFileTime을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="209db736727fc0813e037a50d64ce2c4cb62c7c1" translate="yes" xml:space="preserve">
          <source>. The following table shows them, along with their ASCII code points (in decimal and hex), their ASCII name, the control escape on ASCII platforms and a short description. (For EBCDIC platforms, see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt;.)</source>
          <target state="translated">. 다음 표는 ASCII 코드 포인트 (10 진수 및 16 진수), ASCII 이름, ASCII 플랫폼의 제어 이스케이프 및 간단한 설명과 함께 이들을 보여줍니다. EBCDIC 플랫폼의 경우 &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic의 운영자 차이점을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb9b603496778c52c1a2d77f91cb20b3c0e09316" translate="yes" xml:space="preserve">
          <source>. The format of</source>
          <target state="translated">. 형식</target>
        </trans-unit>
        <trans-unit id="98bd86fe1138202f1f9439203697d2e6ccc0c1d1" translate="yes" xml:space="preserve">
          <source>. The former is useful if $prefix is a directory dedicated to perl (e.g.</source>
          <target state="translated">. 전자는 $ prefix가 perl 전용 디렉토리 인 경우에 유용합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="52456eda920c313c016ecbba8397c6a142320751" translate="yes" xml:space="preserve">
          <source>. The function is intended to be called in this manner:</source>
          <target state="translated">. 이 기능은 다음과 같은 방식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a592425b2e38798803c52cbd4beb0cd4ab9e044b" translate="yes" xml:space="preserve">
          <source>. The function should be defined like this:</source>
          <target state="translated">. 함수는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b277cb2a54f819af8bf29778d7360ede4ccd6c6" translate="yes" xml:space="preserve">
          <source>. The initializer value for a scalar element is just a scalar value. The initializer for an array element is an array reference. The initializer for a hash is a hash reference.</source>
          <target state="translated">. 스칼라 요소의 이니셜 라이저 값은 단지 스칼라 값입니다. 배열 요소의 이니셜 라이저는 배열 참조입니다. 해시의 이니셜 라이저는 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="afbe09239c4b0b80310b301635f392f6bbc5a351" translate="yes" xml:space="preserve">
          <source>. The input is the list of files that match the fileglob.</source>
          <target state="translated">. 입력은 fileglob와 일치하는 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="352aab7b2d0eaa0bc5aa9fc494beb1975384b34a" translate="yes" xml:space="preserve">
          <source>. The key field in the database is the location string and the value field is the time the location was last visited stored as a 4 byte binary value.</source>
          <target state="translated">. 데이터베이스의 키 필드는 위치 문자열이고 값 필드는 위치를 마지막으로 방문한 시간으로 4 바이트 이진 값으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="95555a38b0d0fdd7e883cd86b3b46ad68f807768" translate="yes" xml:space="preserve">
          <source>. The latter is most probably already fixed, if you see it and can trace where the latter spurious warning comes from, please inform me.</source>
          <target state="translated">. 후자는 아마도 이미 수정되었을 것입니다. 보시고 후자의 가짜 경고의 출처를 추적 할 수 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="92fd66a748779ee3429954e90cf1b31a9766b03d" translate="yes" xml:space="preserve">
          <source>. The latter means that if you just installed EMX, and made all the needed changes to</source>
          <target state="translated">. 후자는 EMX를 방금 설치하고 필요한 모든 사항을 변경 한 경우</target>
        </trans-unit>
        <trans-unit id="7e4c4954b32c854b5ebec7089c4678970bb9dad2" translate="yes" xml:space="preserve">
          <source>. The logical character sequence itself is unchanged. If</source>
          <target state="translated">. 논리 문자 순서 자체는 변경되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="cd29714c2a33b9f7328510e6da296e4c8f1474ee" translate="yes" xml:space="preserve">
          <source>. The makefile can use this with something like $shrpenv $(&lt;code&gt;CC&lt;/code&gt; ) -o perl</source>
          <target state="translated">. makefile은 이것을 $ shrpenv $ ( &lt;code&gt;CC&lt;/code&gt; ) -o perl 과 같은 것으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d28baca6170ca62229fafab754ab3c6019b0a96c" translate="yes" xml:space="preserve">
          <source>. The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the FILE * is opened in same mode as the PerlIO *.</source>
          <target state="translated">. 모드 인수는 fopen / PerlIO_open에 전달 될 문자열이어야합니다. NULL 인 경우-레거시 지원의 경우 FILE *는 PerlIO *와 동일한 모드에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="d127834d1054b17ba75249e4716d18cafb707bc6" translate="yes" xml:space="preserve">
          <source>. The name information can be used for POD translators.</source>
          <target state="translated">. 이름 정보는 POD 변환기에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e41d71ac7eded037c4670d30d4568b8d18ea55e" translate="yes" xml:space="preserve">
          <source>. The name of a feature bundle is prefixed with a colon, to distinguish it from an actual feature.</source>
          <target state="translated">. 기능 번들의 이름은 콜론으로 시작하여 실제 기능과 구별합니다.</target>
        </trans-unit>
        <trans-unit id="84b15d4f04c91fed2b935cf88259b619f7e87100" translate="yes" xml:space="preserve">
          <source>. The newly-allocated hash table may now have data stored and retrieved. Efforts to store more than &lt;code&gt;$table_size&lt;/code&gt; elements will result in a fatal error, as will efforts to store a value not exactly &lt;code&gt;$value_len&lt;/code&gt; characters in length, or reference through a key not exactly &lt;code&gt;$key_len&lt;/code&gt; characters in length. While these constraints may seem excessive, the result is a hash table using much less internal memory than an equivalent freely-allocated hash table.</source>
          <target state="translated">. 새로 할당 된 해시 테이블에 데이터를 저장하고 검색 할 수 있습니다. &lt;code&gt;$table_size&lt;/code&gt; 보다 많은 요소 를 저장 하려고 하면 치명적인 오류가 발생합니다. 정확히 &lt;code&gt;$value_len&lt;/code&gt; 문자 길이가 아닌 값을 저장 하거나 정확히 &lt;code&gt;$key_len&lt;/code&gt; 문자 길이가 아닌 키를 참조 하면 오류가 발생 합니다. 이러한 제약 조건이 과도하게 보일 수 있지만 결과적으로 자유롭게 할당되는 해시 테이블보다 훨씬 적은 내부 메모리를 사용하는 해시 테이블이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="90f2a0f7f26f9ff04e556e24ec0e5a3e66bc88a2" translate="yes" xml:space="preserve">
          <source>. The object should provide the interface described in &lt;a href=&quot;encode/encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. If more than two arguments are provided, additional arguments are considered aliases for</source>
          <target state="translated">. 객체는 &lt;a href=&quot;encode/encoding&quot;&gt;Encode :: Encoding에&lt;/a&gt; 설명 된 인터페이스를 제공해야합니다 . 둘 이상의 인수가 제공되는 경우 추가 인수는에 대한 별명으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="96a94934114bd87c528984fa35f3cbd286f4a6de" translate="yes" xml:space="preserve">
          <source>. The old way was to declare it as &quot;int (*signal(...))()&quot;.</source>
          <target state="translated">. 오래된 방법은 &quot;int (* signal (...)) ()&quot;로 선언하는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="af4d0c63d60ebd8bd921063f1610ae5b1868cae0" translate="yes" xml:space="preserve">
          <source>. The outlier &lt;code&gt;\c?&lt;/code&gt; on ASCII, which yields a non-C0 control &lt;code&gt;DEL&lt;/code&gt; , yields the outlier control &lt;code&gt;APC&lt;/code&gt; on EBCDIC, the one that isn't in the block of contiguous controls. Note that a subtlety of this is that &lt;code&gt;\c?&lt;/code&gt; on ASCII platforms is an ASCII character, while it isn't equivalent to any ASCII character in EBCDIC platforms.</source>
          <target state="translated">. 특이 치 &lt;code&gt;\c?&lt;/code&gt; 비 C0 제어 &lt;code&gt;DEL&lt;/code&gt; 을 생성하는 ASCII에서는 연속 제어 블록에없는 EBCDIC 에서 이상치 제어 &lt;code&gt;APC&lt;/code&gt; 를 생성 합니다. 이것의 미묘함은 &lt;code&gt;\c?&lt;/code&gt; ASCII 플랫폼의 ASCII 문자는 EBCDIC 플랫폼의 ASCII 문자와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bd4f959347af60366084a6b999d2b4170409fa5" translate="yes" xml:space="preserve">
          <source>. The output is the list of files that match the fileglob.</source>
          <target state="translated">. 출력은 fileglob와 일치하는 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3a753f8f2e7a43103d1ff1824cd727b6ecbdb4ec" translate="yes" xml:space="preserve">
          <source>. The pattern code expression is like a regular code expression, except that the result of the code evaluation is treated as a regular expression and matched immediately. A simple example is</source>
          <target state="translated">. 패턴 코드 표현식은 코드 평가 결과가 정규 표현식으로 처리되고 즉시 일치된다는 점을 제외하면 일반 코드 표현식과 같습니다. 간단한 예는</target>
        </trans-unit>
        <trans-unit id="a244cd3187379cc2fe2c070c785808570854282b" translate="yes" xml:space="preserve">
          <source>. The people with little desire to understand Perl can just rename main(), and do necessary modification in a custom main() which calls the renamed function in appropriate time.</source>
          <target state="translated">. Perl을 이해하고 싶지 않은 사람들은 main ()의 이름을 바꾸고 적절한 시간에 이름이 변경된 함수를 호출하는 사용자 정의 main ()에서 필요한 수정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201d8370b36c2e56d7351b01de7f62376c175f87" translate="yes" xml:space="preserve">
          <source>. The perl headers (in particular &quot;perlio.h&quot;) will &lt;code&gt;#define&lt;/code&gt; them to the I/O mechanism selected at Configure time.</source>
          <target state="translated">. perl 헤더 (특히 &quot;perlio.h&quot;)는 구성시 선택된 I / O 메커니즘에 따라 &lt;code&gt;#define&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac04dd22ec2d3883b78a8c65c848b91a67ea61d0" translate="yes" xml:space="preserve">
          <source>. The quoted-printable encoding is intended to represent data that largely consists of bytes that correspond to printable characters in the ASCII character set. Each non-printable character (as defined by English Americans) is represented by a triplet consisting of the character &quot;=&quot; followed by two hexadecimal digits.</source>
          <target state="translated">. 인용 인쇄 가능 인코딩은 ASCII 문자 세트의 인쇄 가능 문자에 해당하는 바이트로 크게 구성된 데이터를 나타 내기위한 것입니다. 인쇄 할 수없는 각 문자 (영어 미국인에 의해 정의 됨)는 문자 &quot;=&quot;와 두 개의 16 진수로 구성되는 삼중 항으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="500581814351c949b94b39e4cb44f6f66856596f" translate="yes" xml:space="preserve">
          <source>. The remaining content of the buffer will be moved, and all pointers into the buffer updated appropriately.</source>
          <target state="translated">. 버퍼의 나머지 내용이 이동하고 버퍼의 모든 포인터가 적절하게 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="22430eb3a8c28a42cd2b9e57521a0c62f976ab90" translate="yes" xml:space="preserve">
          <source>. The repository contains many Perl revisions from Perl 1 onwards and all the revisions from Perforce, the previous version control system.</source>
          <target state="translated">. 저장소에는 Perl 1 이후의 많은 Perl 개정판과 이전 버전 제어 시스템 인 Perforce의 모든 개정판이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb3d7ca2967ce75e740e5fdec318eba71ce3dd4" translate="yes" xml:space="preserve">
          <source>. The rules for this are different for lower-level loops given by the greedy quantifiers &lt;code&gt;*+{}&lt;/code&gt; , and for higher-level ones like the &lt;code&gt;/g&lt;/code&gt; modifier or split() operator.</source>
          <target state="translated">. 이에 대한 규칙은 욕심 많은 수량 자 &lt;code&gt;*+{}&lt;/code&gt; 에 의해 주어진 하위 레벨 루프 와 &lt;code&gt;/g&lt;/code&gt; 수정 자 또는 split () 연산자 와 같은 상위 레벨 루프에 대해 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="03aa66011823d9de16726ea950dd95ac9e1fd5d9" translate="yes" xml:space="preserve">
          <source>. The simple pipeline command below runs the script without needing to create a temporary file to hold the uncompressed file.</source>
          <target state="translated">. 아래의 간단한 파이프 라인 명령은 압축되지 않은 파일을 보관하기 위해 임시 파일을 만들 필요없이 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27721e0ebedbef76f0308d9d0eabaae4fcdb33f6" translate="yes" xml:space="preserve">
          <source>. The string pointed to by &lt;code&gt;key&lt;/code&gt; is Safefree()ed. If one has a</source>
          <target state="translated">. &lt;code&gt;key&lt;/code&gt; 가 가리키는 문자열 은 Safefree ()입니다. 하나 있다면</target>
        </trans-unit>
        <trans-unit id="67287b42e112f78aab0082dd4f95584b4f318556" translate="yes" xml:space="preserve">
          <source>. The term 'backtracking' comes from the idea that matching a regexp is like a walk in the woods. Successfully matching a regexp is like arriving at a destination. There are many possible trailheads, one for each string position, and each one is tried in order, left to right. From each trailhead there may be many paths, some of which get you there, and some which are dead ends. When you walk along a trail and hit a dead end, you have to backtrack along the trail to an earlier point to try another trail. If you hit your destination, you stop immediately and forget about trying all the other trails. You are persistent, and only if you have tried all the trails from all the trailheads and not arrived at your destination, do you declare failure. To be concrete, here is a step-by-step analysis of what Perl does when it tries to match the regexp</source>
          <target state="translated">. '역 추적'이라는 용어는 정규 표현식과 일치하는 것이 숲 속의 산책과 같다는 생각에서 비롯됩니다. 정규 표현식을 성공적으로 일치시키는 것은 목적지에 도착하는 것과 같습니다. 각 현 위치마다 하나씩 많은 트레일 헤드가 있으며, 각각 왼쪽에서 오른쪽으로 순서대로 시도됩니다. 각 트레일 헤드에는 많은 경로가있을 수 있으며, 그 중 일부는 도착할 수 있고 일부는 막 다른 길입니다. 트레일을 따라 걸을 때 막 다른 길을 가면 트레일을 따라 이전 지점으로 역 추적하여 다른 트레일을 시도해야합니다. 목적지에 도착하면 즉시 멈추고 다른 길을 모두 시도하는 것을 잊어 버리십시오. 귀하는 지속적이며 모든 트레일 헤드에서 모든 트레일을 시도했지만 목적지에 도착하지 않은 경우에만 실패를 선언합니까? 구체적으로, Perexp가 정규 표현식과 일치하려고 할 때 수행하는 작업에 대한 단계별 분석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1199d660ecd25075f0cdf9eb332edd41306fb5d2" translate="yes" xml:space="preserve">
          <source>. The tiny</source>
          <target state="translated">. 작은</target>
        </trans-unit>
        <trans-unit id="f827c6257f988b2cfbe83fce3e73ddf1d0943d59" translate="yes" xml:space="preserve">
          <source>. The undef third argument means:</source>
          <target state="translated">. undef 세 번째 인수는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff757407b18554327da61107241354758c27a9bd" translate="yes" xml:space="preserve">
          <source>. The use of &lt;code&gt;autodie&lt;/code&gt; with block eval is considered good practice.</source>
          <target state="translated">. 블록 평가와 함께 &lt;code&gt;autodie&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a2e85546ff1b49b5a3d548ca91cc9bb13a0aea4" translate="yes" xml:space="preserve">
          <source>. The value will be stored with the specified key in the hash.</source>
          <target state="translated">. 값은 지정된 키와 함께 해시에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2849d1607b0f29dbd3fdbc14fdf69cbd91b077" translate="yes" xml:space="preserve">
          <source>. Then you can use the modules from your Perl programs with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; or sometimes just &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &quot;/my/perl_directory&quot;;&lt;/code&gt; . If you're on a system that requires superuser/root access to install modules into the directories you see when you type &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; , you'll want to install them into a local directory (such as your home directory) and use this approach.</source>
          <target state="translated">. 그런 다음 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 Perl 프로그램의 모듈을 사용할 수 있습니다 . 또는 때로는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &quot;/my/perl_directory&quot;;&lt;/code&gt; . &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 를 입력 할 때 표시되는 디렉토리에 모듈을 설치하기 위해 수퍼 유저 / 루트 액세스가 필요한 시스템에있는 경우 로컬 디렉토리 (예 : 홈 디렉토리)와이 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41e2d95e78f178f418e712b7eaca32286569001d" translate="yes" xml:space="preserve">
          <source>. There are many possibilities among the world's languages. The number of combinations is astronomical, and if there were a character for each combination, it would soon exhaust Unicode's more than a million possible characters. So Unicode took a different approach: there is a character for the base &lt;code&gt;H&lt;/code&gt; , and a character for each of the possible marks, and these can be variously combined to get a final logical character. So a logical character--what appears to be a single character--can be a sequence of more than one individual characters. The Unicode standard calls these &quot;extended grapheme clusters&quot; (which is an improved version of the no-longer much used &quot;grapheme cluster&quot;); Perl furnishes the &lt;code&gt;\X&lt;/code&gt; regular expression construct to match such sequences in their entirety.</source>
          <target state="translated">. 세계 언어들에는 많은 가능성이 있습니다. 조합의 수는 천문학적이며 각 조합에 대한 문자가 있으면 곧 유니 코드의 가능한 백만 개 이상의 문자를 사용할 수 있습니다. 따라서 유니 코드는 다른 접근 방식을 취했습니다. 기본 &lt;code&gt;H&lt;/code&gt; 문자와 가능한 각 마크 문자가 있으며 최종 논리 문자를 얻기 위해 다양하게 결합 할 수 있습니다. 따라서 논리 문자 (단일 문자로 표시됨)는 둘 이상의 개별 문자 시퀀스 일 수 있습니다. 유니 코드 표준은 이러한 &quot;확장 된 grapheme 클러스터&quot;(더 이상 사용되지 않는 &quot;grapheme 클러스터&quot;의 개선 된 버전)를 호출합니다. Perl은 &lt;code&gt;\X&lt;/code&gt; 정규 표현식 구조를 제공하여 이러한 서열을 전체적으로 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="1eadc7716975de872df1e240fa5e27efd9843f58" translate="yes" xml:space="preserve">
          <source>. There are quite a few result types available; choosing which class to use is the responsibility of the</source>
          <target state="translated">. 사용 가능한 결과 유형이 꽤 있습니다. 사용할 수업을 선택하는 것은</target>
        </trans-unit>
        <trans-unit id="fc1d774c15da48c7b41ed72cf330c112b7557d27" translate="yes" xml:space="preserve">
          <source>. There is no expectation that a module under</source>
          <target state="translated">. 아래에 모듈이있을 것으로 예상되지 않습니다</target>
        </trans-unit>
        <trans-unit id="f07748882481b43ba802e33458c4f0da3c02f2d4" translate="yes" xml:space="preserve">
          <source>. There is no limit to the number of captured substrings that you may use. Groups are numbered with the leftmost open parenthesis being number 1, etc. If a group did not match, the associated backreference won't match either. (This can happen if the group is optional, or in a different branch of an alternation.) You can omit the &lt;code&gt;&quot;g&quot;&lt;/code&gt; , and write &lt;code&gt;&quot;\1&quot;&lt;/code&gt; , etc, but there are some issues with this form, described below.</source>
          <target state="translated">. 사용할 수있는 캡처 된 부분 문자열의 수에는 제한이 없습니다. 그룹은 가장 왼쪽에있는 괄호가 숫자 1 등으로 번호가 매겨집니다. 그룹이 일치하지 않으면 연관된 역 참조도 일치하지 않습니다. (이 옵션은 그룹이 선택 사항이거나 교대의 다른 분기에있는 경우 발생할 수 있습니다.) &lt;code&gt;&quot;g&quot;&lt;/code&gt; 를 생략하고 &lt;code&gt;&quot;\1&quot;&lt;/code&gt; 등을 쓸 수 있지만 아래에 설명 된이 양식에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3ae656b3d4dccde9a6b843783f9804004492bc" translate="yes" xml:space="preserve">
          <source>. There is some naming convention which allows Perl to distinguish correct lines from wrong ones. The above names are almost the only names allowed by this convention which do not contain digits (which have absolutely different semantics).</source>
          <target state="translated">. Perl이 올바른 행과 잘못된 행을 구별 할 수있는 명명 규칙이 있습니다. 위의 이름은이 규칙에서 허용하는 거의 유일한 이름이며 숫자를 포함하지 않습니다 (절대적으로 의미가 다름).</target>
        </trans-unit>
        <trans-unit id="70ae579c941e1b2af83331b8b0575b24042dac0b" translate="yes" xml:space="preserve">
          <source>. Therefore data in these fields should NOT be used for dynamic (user-side) configuration.</source>
          <target state="translated">. 따라서이 필드의 데이터는 동적 (사용자측) 구성에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="df7a4d889790cf742e680d4d6efa4fd1ee3dd47f" translate="yes" xml:space="preserve">
          <source>. These are extensions to the traditional regular expression syntax that provide powerful new tools for pattern matching. We have already seen extensions in the form of the minimal matching constructs &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}?&lt;/code&gt;, and &lt;code&gt;{n,}?&lt;/code&gt;. Most of the extensions below have the form &lt;code&gt;(?char...)&lt;/code&gt;, where the &lt;code&gt;char&lt;/code&gt; is a character that determines the type of extension.</source>
          <target state="translated">. 이것들은 패턴 매칭을위한 강력하고 새로운 도구를 제공하는 전통적인 정규 표현식 구문의 확장입니다. 우리는 이미 최소 일치 구문의 형태로 확장을 보았습니다 &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}?&lt;/code&gt; 및 &lt;code&gt;{n,}?&lt;/code&gt; . 아래의 대부분의 확장자는 &lt;code&gt;(?char...)&lt;/code&gt; 이며, 여기서 &lt;code&gt;char&lt;/code&gt; 은 확장자의 유형을 결정하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="d0fe671376fe423873e5083176cea32f8c57ff41" translate="yes" xml:space="preserve">
          <source>. These are old libraries supplied so that old programs that use them still run. The</source>
          <target state="translated">. 이것들은 그것들을 사용하는 오래된 프로그램이 여전히 실행되도록 제공된 오래된 라이브러리입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="8364539299fc6e8e877e8a93bec948c2c56a9805" translate="yes" xml:space="preserve">
          <source>. These days, your best bet is to look at the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module available from CPAN, which also requires two other modules from CPAN, &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Stty&quot;&gt;IO::Stty&lt;/a&gt;.</source>
          <target state="translated">. 요즘 CPAN에서 사용 가능한 &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; 모듈 을 살펴 보는 것이 가장 좋습니다. CPAN의 다른 두 모듈 인 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Pty&quot;&gt;IO :: Pty&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Stty&quot;&gt;IO :: Stty&lt;/a&gt; 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ba6b2c48d03193d3763913a4f9e3d93618b2d213" translate="yes" xml:space="preserve">
          <source>. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in</source>
          <target state="translated">. 이 8 진수는 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 플래그 설정 여부에 따라 UTF-8 또는 Latin-1로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="6319b650504012b1b53a50eecb57429c0a9dcfe4" translate="yes" xml:space="preserve">
          <source>. They are almost like subclasses in that they have the same fields as &lt;code&gt;regnode&lt;/code&gt; , with possibly additional fields following in the structure, and in some cases the specific meaning (and name) of some of base fields are overridden. The following is a more complete description.</source>
          <target state="translated">. 그것들은 &lt;code&gt;regnode&lt;/code&gt; 와 동일한 필드를 가지고 있다는 점에서 서브 클래스와 거의 같습니다 . 구조에서 추가 필드가 이어질 수 있으며 경우에 따라 일부 기본 필드의 특정 의미 (및 이름)가 무시됩니다. 다음은보다 자세한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="57272a6cda3a773fa9ad5fcdc0dbe778246cc48b" translate="yes" xml:space="preserve">
          <source>. They need the braces, so are written as &lt;code&gt;/\p{Ll}/&lt;/code&gt; or &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt; , or &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (the underscores are optional). &lt;code&gt;/\pLl/&lt;/code&gt; is valid, but means something different. It matches a two character string: a letter (Unicode property &lt;code&gt;\pL&lt;/code&gt; ), followed by a lowercase &lt;code&gt;l&lt;/code&gt; .</source>
          <target state="translated">. 중괄호가 필요하므로 &lt;code&gt;/\p{Ll}/&lt;/code&gt; 또는 &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt; 또는 &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (밑줄은 선택 사항)로 작성됩니다. &lt;code&gt;/\pLl/&lt;/code&gt; 은 유효하지만 다른 의미입니다. 문자 (유니 코드 특성 &lt;code&gt;\pL&lt;/code&gt; )와 소문자 &lt;code&gt;l&lt;/code&gt; 이 오는 두 개의 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c18a582b7f92b4f78c23e95b1cf02accd986e21b" translate="yes" xml:space="preserve">
          <source>. This C code is places at the start of a block, so you can declare variables in it.</source>
          <target state="translated">. 이 C 코드는 블록 시작 부분에 있으므로 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f4d13b8729ed274f6a8a631317728de1b0336d" translate="yes" xml:space="preserve">
          <source>. This advances &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; to match</source>
          <target state="translated">. 이것은 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; 을 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b35fcf8a74bd022a9580104a744f0bdc08475a29" translate="yes" xml:space="preserve">
          <source>. This affects Perl's &lt;code&gt;\w&lt;/code&gt; regular expression metanotation, which stands for alphanumeric characters--that is, alphabetic, numeric, and the platform's native underscore. (Consult &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for more information about regular expressions.) Thanks to &lt;code&gt;LC_CTYPE&lt;/code&gt; , depending on your locale setting, characters like &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;, and &quot;&amp;oslash;&quot; may be understood as &lt;code&gt;\w&lt;/code&gt; characters. It also affects things like &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt; , and the POSIX character classes, like &lt;code&gt;[[:graph:]]&lt;/code&gt; . (See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for more information on all these.)</source>
          <target state="translated">. 이것은 Perl의 &lt;code&gt;\w&lt;/code&gt; 정규 표현식 메타 노테이션에 영향을 미칩니다. 이는 알파벳, 숫자 및 플랫폼의 기본 밑줄을 의미합니다. ( 정규 표현식에 대한 자세한 정보는 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 를 참조하십시오 .) &lt;code&gt;LC_CTYPE&lt;/code&gt; 덕분에 로케일 설정에 따라 &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;및 &quot;&amp;oslash;&quot;와 같은 문자 는 &lt;code&gt;\w&lt;/code&gt; 문자 로 이해 될 수 있습니다 . 또한 &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; 및 &lt;code&gt;[[:graph:]]&lt;/code&gt; 와 같은 POSIX 문자 클래스 에도 영향을줍니다 . ( 이 모든 &lt;a href=&quot;perlrecharclass&quot;&gt;것에&lt;/a&gt; 대한 자세한 정보는 perlrecharclass 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="50585be931797e352a16a31cff946364d2998523" translate="yes" xml:space="preserve">
          <source>. This construct is useful for optimizations of what would otherwise be &quot;eternal&quot; matches, because it will not backtrack (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). It may also be useful in places where the &quot;grab all you can, and do not give anything back&quot; semantic is desirable.</source>
          <target state="translated">. 이 구문은 역 추적하지 않기 때문에 &quot;영원한&quot;일치 항목을 최적화하는 데 유용합니다 ( &lt;a href=&quot;#Backtracking&quot;&gt;역 추적&lt;/a&gt; 참조 ). 또한 &quot;의미 할 수있는 모든 것을 잡아 내고 아무것도 돌려주지 않는&quot;의미가 바람직한 곳에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbb5bbf55288455005a9b2624554c934ac032cd" translate="yes" xml:space="preserve">
          <source>. This entered computer lingo via the paper &quot;On Holy Wars and a Plea for Peace&quot; by Danny Cohen, USC/ISI IEN 137, April 1, 1980.</source>
          <target state="translated">. 이것은 1980 년 4 월 1 일 USC / ISI IEN 137 대니 코헨 (Danny Cohen)의 &quot;성스러운 전쟁과 평화를위한기도&quot;라는 논문을 통해 컴퓨터 용어로 들어갔다.</target>
        </trans-unit>
        <trans-unit id="3809e0e62de48ea8f912fa229a3b1c19f17c36c5" translate="yes" xml:space="preserve">
          <source>. This file acts as both forward declaration of all package routines, and as timestamp for the last update of the hierarchy.</source>
          <target state="translated">. 이 파일은 모든 패키지 루틴의 순방향 선언 및 계층의 마지막 업데이트에 대한 타임 스탬프 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="47f0695b79e4a62f046bf4d6a56dc69b6e31a2b7" translate="yes" xml:space="preserve">
          <source>. This file resides somewhere deep in the location you installed your perl library, find it out by</source>
          <target state="translated">. 이 파일은 펄 라이브러리를 설치 한 위치의 어딘가에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2be3d4dab06ff8de1c3af65b87672a1f250c96" translate="yes" xml:space="preserve">
          <source>. This gives one an access to EMX's</source>
          <target state="translated">. 이를 통해 EMX에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="46aab4ac7dc98f7e211f64d569ae1ce3a7b4af8a" translate="yes" xml:space="preserve">
          <source>. This includes methods inherited or imported by &lt;code&gt;$obj&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; , or &lt;code&gt;VAL&lt;/code&gt; .</source>
          <target state="translated">. 여기에는 &lt;code&gt;$obj&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; 또는 &lt;code&gt;VAL&lt;/code&gt; 이 상속하거나 가져온 메소드가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d85307dde9a09b32449c60a5313b98a5973ff2c7" translate="yes" xml:space="preserve">
          <source>. This is a private hash where every object is stored. An &quot;object&quot; in this sense is any reference (blessed or unblessed) that has been used as a field hash key.</source>
          <target state="translated">. 이것은 모든 객체가 저장되는 개인 해시입니다. 이러한 의미에서 &quot;객체&quot;는 필드 해시 키로 사용 된 참조 (축복 또는 비 축복)입니다.</target>
        </trans-unit>
        <trans-unit id="a2cdaa392edbf49e429fe1dc9214079db19f181c" translate="yes" xml:space="preserve">
          <source>. This is a special file already opened on the script, so that there can be no race condition for evil scripts to exploit. On these systems, Perl should be compiled with &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; . The</source>
          <target state="translated">. 이것은 스크립트에서 이미 열린 특수 파일이므로 악의적 인 스크립트가 악용 할 수있는 경쟁 조건이 없습니다. 이러한 시스템에서 Perl은 &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 로 컴파일해야합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="a2864f51e0809a4502605d91af0e78f8003a6b91" translate="yes" xml:space="preserve">
          <source>. This is because 66 code points will always be unassigned, and so the &lt;code&gt;Age&lt;/code&gt; for them is the Unicode version in which the decision to make them so was made. For example, &lt;code&gt;U+FDD0&lt;/code&gt; is to be permanently unassigned to a character, and the decision to do that was made in version 3.1, so &lt;code&gt;\p{Age=3.1}&lt;/code&gt; matches this character, as also does &lt;code&gt;\p{Present_In: 3.1}&lt;/code&gt; and up.</source>
          <target state="translated">. 이는 66 개의 코드 포인트가 항상 할당 해제되어 있기 때문에이를위한 &lt;code&gt;Age&lt;/code&gt; 는이를 결정하는 유니 코드 버전입니다. 예를 들어, &lt;code&gt;U+FDD0&lt;/code&gt; 은 문자에 영구적으로 할당 해제되며 버전 3.1에서 수행 된 결정은 &lt;code&gt;\p{Age=3.1}&lt;/code&gt; 이이 문자와 일치하며 &lt;code&gt;\p{Present_In: 3.1}&lt;/code&gt; 및 쪽으로.</target>
        </trans-unit>
        <trans-unit id="bdf07babd3552a309bc961c0381ffe7de7e8f022" translate="yes" xml:space="preserve">
          <source>. This is because the makefile by default sets the drive letter to</source>
          <target state="translated">. 기본적으로 makefile은 드라이브 문자를</target>
        </trans-unit>
        <trans-unit id="fc454fe001d6d36df58e092c61a2198720958a66" translate="yes" xml:space="preserve">
          <source>. This is because there is a conflict with a similarly-named file</source>
          <target state="translated">. 비슷한 이름의 파일과 충돌하기 때문입니다</target>
        </trans-unit>
        <trans-unit id="2a6af843b3f9c3758afa449207e6300ed8332e2a" translate="yes" xml:space="preserve">
          <source>. This is by design. If</source>
          <target state="translated">. 이것은 의도적으로 설계된 동작입니다. 만약</target>
        </trans-unit>
        <trans-unit id="93f5f59e9c411bf2b79d7d72c3b74942de22a532" translate="yes" xml:space="preserve">
          <source>. This is copied under the</source>
          <target state="translated">. 이것은 아래에 복사됩니다</target>
        </trans-unit>
        <trans-unit id="4dd3c68fa5c32e16e123eaa693e773f653650f36" translate="yes" xml:space="preserve">
          <source>. This is currently only supported for &lt;code&gt;GNU&lt;/code&gt; ld on &lt;code&gt;ELF&lt;/code&gt; in dynamic loading builds.</source>
          <target state="translated">. 이것은 현재 동적 로딩 빌드 에서 &lt;code&gt;ELF&lt;/code&gt; 의 &lt;code&gt;GNU&lt;/code&gt; ld에 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7af8025fe87d5aab31b7a47c749ea1a87fce0d6" translate="yes" xml:space="preserve">
          <source>. This is done at run-time, so is called dynamic scoping. local() always affects global variables, also called package variables or dynamic variables.</source>
          <target state="translated">. 이 작업은 런타임에 수행되므로 동적 범위 지정이라고합니다. local ()은 항상 전역 변수 (패키지 변수 또는 동적 변수라고도 함)에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4c25e02bad7d2cac773965d696d2c2a687ad78e4" translate="yes" xml:space="preserve">
          <source>. This is done from</source>
          <target state="translated">. 이것은에서 이루어집니다</target>
        </trans-unit>
        <trans-unit id="b27ee6639c423265aa7d8874b0268983c66fc9bf" translate="yes" xml:space="preserve">
          <source>. This is installed again by running &lt;code&gt;cpan Bundle::Snapshot_2012_05_21_00&lt;/code&gt; , or installing &lt;code&gt;Bundle::Snapshot_2012_05_21_00&lt;/code&gt; from the CPAN shell.</source>
          <target state="translated">. &lt;code&gt;cpan Bundle::Snapshot_2012_05_21_00&lt;/code&gt; 을 실행 하거나 CPAN 쉘에서 &lt;code&gt;Bundle::Snapshot_2012_05_21_00&lt;/code&gt; 을 설치 하여 다시 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="3823ddaf1238d01760d00a61d4a308fff63739d8" translate="yes" xml:space="preserve">
          <source>. This is normal and expected. (There is a conflict with a similarly-named file</source>
          <target state="translated">. 이것은 정상이며 예상됩니다. (유사한 이름의 파일과 충돌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c655d0e38e80b9ecc3fca4e245f5ce10c2d9a2" translate="yes" xml:space="preserve">
          <source>. This is probably OK, as most perl scripts shipped with Solaris use an explicit path. (There are a few exceptions, such as</source>
          <target state="translated">. Solaris와 함께 제공되는 대부분의 perl 스크립트는 명시적인 경로를 사용하기 때문에 이것은 아마도 괜찮습니다. (예를 들어 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e883175469b1c783e8a78114606c2d561139be6" translate="yes" xml:space="preserve">
          <source>. This is rarely needed, as Perl manages its memory quite well. But the option exists, should a class wish to perform specific actions upon the destruction of an instance.</source>
          <target state="translated">. Perl이 메모리를 잘 관리하기 때문에 이것은 거의 필요하지 않습니다. 그러나 클래스가 인스턴스 파괴시 특정 조치를 수행하려는 경우 옵션이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="333093d5d5321fc34ce46ed78526668442668aef" translate="yes" xml:space="preserve">
          <source>. This is similar to &lt;code&gt;sv_2mortal&lt;/code&gt; in that it is also a mechanism for doing a delayed &lt;code&gt;SvREFCNT_dec&lt;/code&gt; . However, while &lt;code&gt;sv_2mortal&lt;/code&gt; extends the lifetime of &lt;code&gt;sv&lt;/code&gt; until the beginning of the next statement, &lt;code&gt;SAVEFREESV&lt;/code&gt; extends it until the end of the enclosing scope. These lifetimes can be wildly different.</source>
          <target state="translated">. 이것은 지연된 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 을 수행하기위한 메커니즘이라는 점에서 &lt;code&gt;sv_2mortal&lt;/code&gt; 과 유사합니다 . 반면 그러나 &lt;code&gt;sv_2mortal&lt;/code&gt; 가 의 수명 연장 &lt;code&gt;sv&lt;/code&gt; 다음 문장의 시작 부분까지 &lt;code&gt;SAVEFREESV&lt;/code&gt; 는 바깥 쪽 범위의 끝 부분까지 확장합니다. 이 수명은 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6926c3ac4d7edc58bc3ea380b4d2d54d9f28838f" translate="yes" xml:space="preserve">
          <source>. This macro evaluates its arguments more than once. If you are using &lt;code&gt;Perl_custom_op_xop&lt;/code&gt; to retreive a &lt;code&gt;XOP *&lt;/code&gt; from a &lt;code&gt;OP *&lt;/code&gt; , use the more efficient &lt;a href=&quot;#XopENTRYCUSTOM&quot;&gt;XopENTRYCUSTOM&lt;/a&gt; instead.</source>
          <target state="translated">. 이 매크로는 인수를 두 번 이상 평가합니다. &lt;code&gt;Perl_custom_op_xop&lt;/code&gt; 를 사용하여 &lt;code&gt;OP *&lt;/code&gt; 에서 &lt;code&gt;XOP *&lt;/code&gt; 를 검색하는 경우보다 효율적인 &lt;a href=&quot;#XopENTRYCUSTOM&quot;&gt;XopENTRYCUSTOM을&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca414c709e1a90a43e4a8b465a788e53c69235fb" translate="yes" xml:space="preserve">
          <source>. This may be useful e.g., if you need to run the installer many times and do not want to make many interactive changes in the GUI.</source>
          <target state="translated">. 예를 들어 설치 프로그램을 여러 번 실행해야하고 GUI에서 많은 대화식 변경을 원하지 않는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3776f3fabf7ab606cceb1e6f3f63ecb05da2010" translate="yes" xml:space="preserve">
          <source>. This means that if you have already detected the error by checking &lt;code&gt;$@&lt;/code&gt; and you want the program to continue, you must remember to pop the</source>
          <target state="translated">. 즉, &lt;code&gt;$@&lt;/code&gt; 를 확인하여 이미 오류를 감지 하고 프로그램을 계속하려면 프로그램을 계속 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c905e3737670dc0a16e9b65486ea71a8080a95" translate="yes" xml:space="preserve">
          <source>. This means that in &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x = 1 + $x&lt;/code&gt; the second $x refers to one declared previously.</source>
          <target state="translated">. 이것은 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x = 1 + $x&lt;/code&gt; 에서 두 번째 $ x는 이전에 선언 된 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="509c15e768544bbfe8e2f5cd7ea999c647b19bd3" translate="yes" xml:space="preserve">
          <source>. This means that the my() variable is remade afresh each time through the loop. So even though it</source>
          <target state="translated">. 이는 루프를 통해 매번 my () 변수가 새로 고쳐 짐을 의미합니다. 그래도</target>
        </trans-unit>
        <trans-unit id="fe09c13d6e77d9b5618869e0a4e90a8dc9147143" translate="yes" xml:space="preserve">
          <source>. This means that when the scope of the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; ends, the saved value will be restored to the hash element whose key was named in the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;, or the array element whose index was named in the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. If that element was deleted while the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; was in effect (e.g. by a &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete()&lt;/a&gt;&lt;/code&gt; from a hash or a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift()&lt;/a&gt;&lt;/code&gt; of an array), it will spring back into existence, possibly extending an array and filling in the skipped elements with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For instance, if you say</source>
          <target state="translated">. 즉, &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 범위가 끝나면 저장된 값이 키가 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 로 지정된 해시 요소 또는 색인이 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 에서 명명 된 배열 요소로 복원됩니다 . &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 이 적용 되는 동안 해당 요소가 삭제 된 경우 (예 : 해시 또는 배열 의 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift()&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete()&lt;/a&gt;&lt;/code&gt; 로 ) 배열이 확장되어 생략 된 요소가 채워질 수 있습니다. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 와 함께 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="2a5686773a218be3c431ba0259971d1df05369e0" translate="yes" xml:space="preserve">
          <source>. This means that you do not have</source>
          <target state="translated">. 이것은 당신이 가지고 있지 않다는 것을 의미합니다</target>
        </trans-unit>
        <trans-unit id="3bc3229b9fe446d29363a15b982307c27bf373f3" translate="yes" xml:space="preserve">
          <source>. This means you can say</source>
          <target state="translated">. 이것은 당신이 말할 수 있음을 의미합니다</target>
        </trans-unit>
        <trans-unit id="8a96e246a31c1137abbe0058f53817db4b0cfdb5" translate="yes" xml:space="preserve">
          <source>. This option may be given multiple times on the command line.</source>
          <target state="translated">. 이 옵션은 명령 행에서 여러 번 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f21c464f22992c54b3a847db0212c469aa75655" translate="yes" xml:space="preserve">
          <source>. This parameter operates just like the replacement part of a substitute command. The difference is that the &lt;code&gt;#1&lt;/code&gt; syntax is used to reference sub-patterns matched in the input fileglob, rather than the &lt;code&gt;$1&lt;/code&gt; syntax that is used with perl regular expressions. In this case &lt;code&gt;#1&lt;/code&gt; is used to refer to the text matched by the &lt;code&gt;*&lt;/code&gt; in the Input File Glob. This makes it easier to use this module where the parameters to &lt;code&gt;globmap&lt;/code&gt; are typed at the command line.</source>
          <target state="translated">. 이 매개 변수는 대체 명령의 교체 부분과 동일하게 작동합니다. 차이점은 &lt;code&gt;#1&lt;/code&gt; 구문은 perl 정규식과 함께 사용되는 &lt;code&gt;$1&lt;/code&gt; 구문이 아니라 입력 파일 글로브에서 일치하는 하위 패턴을 참조하는 데 사용된다는 것 입니다. 이 경우 &lt;code&gt;#1&lt;/code&gt; 은 Input File Glob에서 &lt;code&gt;*&lt;/code&gt; 와 일치하는 텍스트를 나타내는 데 사용됩니다 . 이를 통해 &lt;code&gt;globmap&lt;/code&gt; 에 대한 매개 변수가 명령 행에 입력 되는 경우이 모듈을보다 쉽게 ​​사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b35f1876404589d6fbdcdf4d784638b587a2f0e" translate="yes" xml:space="preserve">
          <source>. This port was based on contents of</source>
          <target state="translated">. 이 포트는</target>
        </trans-unit>
        <trans-unit id="3121446ddb40369e1367ab1574d37848cdafd685" translate="yes" xml:space="preserve">
          <source>. This represents a &quot;logical character&quot;: what appears to be a single character, but may be represented internally by more than one. As an example, using the Unicode full names, e.g., &lt;code&gt;A + COMBINING
RING&lt;/code&gt; is a grapheme cluster with base character &lt;code&gt;A&lt;/code&gt; and combining character &lt;code&gt;COMBINING RING&lt;/code&gt; , which translates in Danish to A with the circle atop it, as in the word &amp;Aring;ngstrom.</source>
          <target state="translated">. 이것은 &quot;논리적 특성&quot;을 나타냅니다. 단일 문자 인 것처럼 보이지만 둘 이상의 내부적으로 표현 될 수 있습니다. 예를 들어, 유니 코드 전체 이름 (예 : &lt;code&gt;A + COMBINING RING&lt;/code&gt; )을 사용하면 기본 문자 &lt;code&gt;A&lt;/code&gt; 와 문자 &lt;code&gt;COMBINING RING&lt;/code&gt; 을 결합한 그라 핀 클러스터이며, &amp;Aring;ngstrom이라는 단어와 같이 덴마크어로 A를 원으로 그 위에 원으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f186a667f9cbb4f0ff8bf9acb24964ca740a0ce7" translate="yes" xml:space="preserve">
          <source>. This should be set to the number of gigabytes of memory available for testing, eg. &lt;code&gt;PERL_TEST_MEMORY=4&lt;/code&gt; indicates that tests that require 4GiB of available memory can be run safely.</source>
          <target state="translated">. 예를 들어 테스트에 사용할 수있는 기가 바이트 메모리 수로 설정해야합니다. &lt;code&gt;PERL_TEST_MEMORY=4&lt;/code&gt; 는 4GiB의 사용 가능한 메모리가 필요한 테스트를 안전하게 실행할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe1d3c4eb3ad243fd160d1a59490970dd0104a15" translate="yes" xml:space="preserve">
          <source>. This unit comes before</source>
          <target state="translated">. 이 단위는 전에 온다</target>
        </trans-unit>
        <trans-unit id="86ececb0158a7a68e96b05ebdb48374eef85420b" translate="yes" xml:space="preserve">
          <source>. This will be misleading if &lt;code&gt;FLAGS &amp;amp; SVf_IVisUV&lt;/code&gt; . Perhaps you want the &lt;code&gt;int_value&lt;/code&gt; method instead?</source>
          <target state="translated">. &lt;code&gt;FLAGS &amp;amp; SVf_IVisUV&lt;/code&gt; 인 경우 오해의 소지가 있습니다 . 아마도 당신은 대신 &lt;code&gt;int_value&lt;/code&gt; 메소드를 원하십니까?</target>
        </trans-unit>
        <trans-unit id="994a1e67d1470d3f00c9b8744c3f70f33aeecd2f" translate="yes" xml:space="preserve">
          <source>. This will match one of the keys in the hash returned by &lt;a href=&quot;#bidi_types()&quot;&gt;bidi_types()&lt;/a&gt;.</source>
          <target state="translated">. 이것은 &lt;a href=&quot;#bidi_types()&quot;&gt;bidi_types ()가&lt;/a&gt; 반환 한 해시의 키 중 하나와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="7f5b2cd03cbc625e84164ab17288c6ed1f4a26da" translate="yes" xml:space="preserve">
          <source>. This will match one of the keys in the hash returned by &lt;a href=&quot;#general_categories()&quot;&gt;general_categories()&lt;/a&gt;.</source>
          <target state="translated">. 이것은 &lt;a href=&quot;#general_categories()&quot;&gt;general_categories ()가&lt;/a&gt; 반환 한 해시의 키 중 하나와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="de138c9795e8525fb580319005864dcc2d56600a" translate="yes" xml:space="preserve">
          <source>. This works well when you have multiple modules to work with. It also ensures that the module goes through its full installation process which may modify it.</source>
          <target state="translated">. 여러 모듈로 작업 할 때 잘 작동합니다. 또한 모듈이 전체 설치 프로세스를 거쳐 수정 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c1c277971953cbe2cdf771f2279dd9ed07df47ea" translate="yes" xml:space="preserve">
          <source>. Thus the accessor expression &lt;code&gt;$$foo-&amp;gt;[$ind]&lt;/code&gt; involves no overloaded operations.</source>
          <target state="translated">. 따라서 접근 자 식 &lt;code&gt;$$foo-&amp;gt;[$ind]&lt;/code&gt; 에는 오버로드 된 작업이 없습니다.</target>
        </trans-unit>
        <trans-unit id="376ae4142275d20cee208841b1851cc5450412ed" translate="yes" xml:space="preserve">
          <source>. To check derivation at the Perl level, call &lt;code&gt;isa()&lt;/code&gt; as a normal Perl method.</source>
          <target state="translated">. Perl 레벨에서 파생을 확인하려면 일반 Perl 메소드로 &lt;code&gt;isa()&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2afe698aa7faacc5ec799e7275adcb5987ccef15" translate="yes" xml:space="preserve">
          <source>. To decode, you have to know what encoding was used during the encoding phase. And most of all, it must be something decodable. It doesn't make much sense to decode a PNG image into a text string.</source>
          <target state="translated">. 디코딩하려면 인코딩 단계에서 어떤 인코딩이 사용되었는지 알아야합니다. 그리고 무엇보다도, 그것은 해독 할 수있는 것이어야합니다. PNG 이미지를 텍스트 문자열로 디코딩하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="98e9ceac44f5e5ada5b2cc667998516912128c21" translate="yes" xml:space="preserve">
          <source>. To encode, you have to supply the target encoding, for example &lt;code&gt;iso-8859-1&lt;/code&gt; or &lt;code&gt;UTF-8&lt;/code&gt; . Some encodings, like the &lt;code&gt;iso-8859&lt;/code&gt; (&quot;latin&quot;) range, do not support the full Unicode standard; characters that can't be represented are lost in the conversion.</source>
          <target state="translated">. 인코딩하려면 대상 인코딩을 제공해야합니다 (예 : &lt;code&gt;iso-8859-1&lt;/code&gt; 또는 &lt;code&gt;UTF-8&lt;/code&gt; ) . &lt;code&gt;iso-8859&lt;/code&gt; ( &quot;latin&quot;) 범위 와 같은 일부 인코딩 은 전체 유니 코드 표준을 지원하지 않습니다. 표현할 수없는 문자는 변환시 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c13046b9d8e816b17632bdae397e4cabc4ff99" translate="yes" xml:space="preserve">
          <source>. To explain why we made it so, I quote from page 402 of</source>
          <target state="translated">. 왜 그렇게했는지 설명하기 위해 402 페이지에서 인용합니다.</target>
        </trans-unit>
        <trans-unit id="a642717c0a7bd1553f08f955b5e1a98b9614944d" translate="yes" xml:space="preserve">
          <source>. To reflect its enhanced role, the filter is called &lt;code&gt;Subst&lt;/code&gt; .</source>
          <target state="translated">. 강화 된 역할을 반영하기 &lt;code&gt;Subst&lt;/code&gt; 필터를 Subst 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="d3f01500276b8b64e9b93faad15a87228988964c" translate="yes" xml:space="preserve">
          <source>. Type</source>
          <target state="translated">. 유형</target>
        </trans-unit>
        <trans-unit id="293d96ef1af5df6e9a25f434c724eaa7d617b1a7" translate="yes" xml:space="preserve">
          <source>. Using &lt;code&gt;PREREQ_FATAL&lt;/code&gt; breaks this. That's bad.</source>
          <target state="translated">. &lt;code&gt;PREREQ_FATAL&lt;/code&gt; 을 사용하면이 문제 가 해결됩니다. 그 나쁜.</target>
        </trans-unit>
        <trans-unit id="23f91c0ba1e361cffc5fab5e3a44cd400b9fc5ad" translate="yes" xml:space="preserve">
          <source>. Value can be &quot;&quot; or</source>
          <target state="translated">. 값은 &quot;&quot;또는</target>
        </trans-unit>
        <trans-unit id="231d3dbe354e5fa106e42fb41037db896ce22d5c" translate="yes" xml:space="preserve">
          <source>. We originally forgot the extra</source>
          <target state="translated">. 우리는 원래 여분을 잊었다</target>
        </trans-unit>
        <trans-unit id="96ed60476229df2a07cbee9344c86b1bf229527f" translate="yes" xml:space="preserve">
          <source>. What then happens in these failure conditions, depends on the $lh object's &quot;fail&quot; attribute.</source>
          <target state="translated">. 이 실패 조건에서 발생하는 것은 $ lh 오브젝트의 &quot;실패&quot;속성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bd400ca1ce95a5dc0f047f0b1aec57f47b38a4c2" translate="yes" xml:space="preserve">
          <source>. What's that, you ask? Perl is itself written in C; the perl library is the collection of compiled C programs that were used to create your perl executable (</source>
          <target state="translated">. 그게 뭐야? Perl 자체는 C로 작성되었습니다. perl 라이브러리는 perl 실행 파일을 만드는 데 사용 된 컴파일 된 C 프로그램의 모음입니다 (</target>
        </trans-unit>
        <trans-unit id="4dd3f5efe1f95b600d00881eb6c9596353497a30" translate="yes" xml:space="preserve">
          <source>. When a surrogate pair is encountered during decode(), its place is filled with \x{FFFD} if</source>
          <target state="translated">. decode () 중에 서로 게이트 쌍이 발견되면 해당 위치는 \ x {FFFD}로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0274262026ff4daab22f506deff822c9bff4d353" translate="yes" xml:space="preserve">
          <source>. When it encounters a high surrogate (0xD800-0xDBFF), it fetches the following low surrogate (0xDC00-0xDFFF) and &lt;code&gt;desurrogate&lt;/code&gt; s them to form a character. Bogus surrogates result in death. When \x{10000} or above is encountered during encode(), it &lt;code&gt;ensurrogate&lt;/code&gt; s them and pushes the surrogate pair to the output stream.</source>
          <target state="translated">. 그것은 높은 대리 (0xD800-0xDBFF)를 발견하면 하위 대리 (0xDC00-0xDFFF) 및 다음 가져 &lt;code&gt;desurrogate&lt;/code&gt; 문자를 형성하도록이야. 가짜 대리모는 사망을 초래합니다. encode () 중에 \ x {10000} 이상이 발생하면이를 &lt;code&gt;ensurrogate&lt;/code&gt; 하고 대리 쌍을 출력 스트림으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="ea023ffcde1e861a026a8f936e5d329dad6f499c" translate="yes" xml:space="preserve">
          <source>. When perl exits, cleanly or not, the original</source>
          <target state="translated">. 펄이 깨끗하게 종료 될 때, 원본</target>
        </trans-unit>
        <trans-unit id="62e9134eebcb776632e22e8c2f0f31421f73f61a" translate="yes" xml:space="preserve">
          <source>. When using a delimiter character valid in an identifier, whitespace is required after the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">. 식별자에 유효한 구분 문자를 사용하는 경우 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 뒤에 공백이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="2991c5c2aabb888a3252817b3e6b994e23bac220" translate="yes" xml:space="preserve">
          <source>. When using a hash to store options, the key will always be the primary name.</source>
          <target state="translated">. 해시를 사용하여 옵션을 저장하는 경우 키는 항상 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7929cfa2bae05685d9a96bfd0b2ce0636b21e809" translate="yes" xml:space="preserve">
          <source>. When you encode,</source>
          <target state="translated">. 인코딩 할 때</target>
        </trans-unit>
        <trans-unit id="2c33b2cf8be422451d2c79b44382899c032db18c" translate="yes" xml:space="preserve">
          <source>. While it's possible to put the image in</source>
          <target state="translated">. 이미지를 넣을 수는 있지만</target>
        </trans-unit>
        <trans-unit id="b6eff3deb0f158948019f15b9ed96ddaede3980f" translate="yes" xml:space="preserve">
          <source>. While the command is running, a $SIG{INT} exits the loop after displaying the current item.</source>
          <target state="translated">. 명령이 실행되는 동안 $ SIG {INT}는 현재 항목을 표시 한 후 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="fac11c14e9cfa1dd621203398341128a51774857" translate="yes" xml:space="preserve">
          <source>. Without a BLOCK it's just a forward declaration. Without a NAME, it's an anonymous function declaration, so does return a value: the CODE ref of the closure just created.</source>
          <target state="translated">. 블록이 없으면 그냥 선언입니다. NAME이 없으면 익명 함수 선언이므로 값을 반환합니다. 방금 생성 한 클로저의 CODE 참조.</target>
        </trans-unit>
        <trans-unit id="84c0c40278d089a43554ff57b285f3f877a690b4" translate="yes" xml:space="preserve">
          <source>. Without this option, the manual name is set to the uppercased base name of the file being converted unless the manual section is 3, in which case the path is parsed to see if it is a Perl module path. If it is, a path like &lt;code&gt;.../lib/Pod/Man.pm&lt;/code&gt; is converted into a name like &lt;code&gt;Pod::Man&lt;/code&gt; . This option, if given, overrides any automatic determination of the name.</source>
          <target state="translated">. 이 옵션을 사용하지 않으면 매뉴얼 섹션이 3이 아닌 경우 매뉴얼 이름이 변환중인 파일의 대문자 기본 이름으로 설정됩니다.이 경우 경로가 구문 분석되어 Perl 모듈 경로인지 확인합니다. 그렇다면 &lt;code&gt;.../lib/Pod/Man.pm&lt;/code&gt; 과 같은 경로 는 &lt;code&gt;Pod::Man&lt;/code&gt; 과 같은 이름으로 변환됩니다 . 이 옵션이 제공되면 이름의 자동 결정을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ef3fb2dc3b8ce0d3b61795b7d246a387effb6099" translate="yes" xml:space="preserve">
          <source>. You can build a profiled version of</source>
          <target state="translated">. 당신은 프로파일 버전을 구축 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4af4aa3082581b91fbccc276303d5e0e695fe0af" translate="yes" xml:space="preserve">
          <source>. You can configure them and load custom handlers using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">. &lt;code&gt;sources&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;#new&quot;&gt;new를&lt;/a&gt; 구성하고 사용자 정의 핸들러를로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc3ecab6f4d3bd8009f72e7ec3770026656b25a2" translate="yes" xml:space="preserve">
          <source>. You can load custom formatters by using the &lt;code&gt;formatter_class&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;. To configure a formatter, you currently need to instantiate it outside of &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; and pass it in with the &lt;code&gt;formatter&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;. This</source>
          <target state="translated">. &lt;code&gt;formatter_class&lt;/code&gt; 매개 변수를 사용하여 사용자 정의 포맷터 를 &lt;a href=&quot;#new&quot;&gt;new로&lt;/a&gt; 로드 할 수 있습니다 . 포맷터를 구성하려면 현재 &lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt; 외부 에서 해당 &lt;code&gt;formatter&lt;/code&gt; 를 인스턴스화 하고 formatter 매개 변수 와 함께 &lt;a href=&quot;#new&quot;&gt;new로&lt;/a&gt; 전달해야합니다 . 이</target>
        </trans-unit>
        <trans-unit id="7142228fad3a350d4ddbe84b65098ef6c9f3c82d" translate="yes" xml:space="preserve">
          <source>. You can't actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; and &lt;code&gt;&quot;N&lt;/code&gt; &quot; in them.</source>
          <target state="translated">. 실제로는 &lt;code&gt;&quot;Y&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;N&lt;/code&gt; &quot;을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8649ddb5400406511f244299543a6403cfccc8a3" translate="yes" xml:space="preserve">
          <source>. You may discover compiled library files (usually ending in</source>
          <target state="translated">. 컴파일 된 라이브러리 파일을 발견 할 수 있습니다 (보통 끝나는</target>
        </trans-unit>
        <trans-unit id="ffbebd700d3eb9227807825c379b6d6206d37f0f" translate="yes" xml:space="preserve">
          <source>. You may not like the colors I've chosen and I haven't yet provided an easy way to override them.</source>
          <target state="translated">. 내가 선택한 색상이 마음에 들지 않고 아직 색상을 재정의하는 쉬운 방법을 제공하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2c9db0590acbab3da6c3b486f032903e6c187508" translate="yes" xml:space="preserve">
          <source>. You probably won't need to do this.</source>
          <target state="translated">. 아마 이것을 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c3214c77b19e989a43565fb9196ac768952f000" translate="yes" xml:space="preserve">
          <source>. You will be notified automatically of any progress on your issue.</source>
          <target state="translated">. 문제 진행 상황을 자동으로 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b9e7d26642ff7b2d3481e00117ed3a228cbd5970" translate="yes" xml:space="preserve">
          <source>. Your system administrator needs to do the updating of the</source>
          <target state="translated">. 시스템 관리자가 업데이트를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b94d932529ef0982db39280d52d9d6b0ed70565c" translate="yes" xml:space="preserve">
          <source>. [This may change in the future.]</source>
          <target state="translated">. [향후 변경 될 수 있습니다.]</target>
        </trans-unit>
        <trans-unit id="773261a82823f6262ce3d345b08189a976ee3539" translate="yes" xml:space="preserve">
          <source>. for older directories back to the limit specified by these api_ variables. This is only useful if you have a perl library directory tree structured like the default one. See &lt;code&gt;INSTALL&lt;/code&gt; for how this works. The versioned site_perl directory was introduced in 5.005, so that is the lowest possible value. The version list appropriate for the current system is determined in</source>
          <target state="translated">. 이전 디렉토리의 경우 이러한 api_ 변수로 지정된 한계로 돌아갑니다. 이것은 펄 라이브러리 디렉토리 트리가 기본 디렉토리 구조와 같이 구조화 된 경우에만 유용합니다. 작동 방법 은 &lt;code&gt;INSTALL&lt;/code&gt; 를 참조하십시오 . 버전이 지정된 site_perl 디렉토리는 5.005에 도입되었으므로 가능한 가장 낮은 값입니다. 현재 시스템에 적합한 버전 목록은</target>
        </trans-unit>
        <trans-unit id="94d64aa5e8ac2979b7183532e7251cb47f0120e5" translate="yes" xml:space="preserve">
          <source>. machine dependent floating point values.</source>
          <target state="translated">. 기계 의존 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="2832b9a686e025a915af1c2fdddf8eeaf1e95af9" translate="yes" xml:space="preserve">
          <source>. suitable for starting sentences.</source>
          <target state="translated">. 문장을 시작하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="7dc33a4eee36533c54545a241123074cb3566ee0" translate="yes" xml:space="preserve">
          <source>.) (The sum of user time and system time is known as the</source>
          <target state="translated">.) (사용자 시간과 시스템 시간의 합을</target>
        </trans-unit>
        <trans-unit id="00de140a7abe853d3f1dc175478e343bd14b372b" translate="yes" xml:space="preserve">
          <source>.) &lt;code&gt;SIGPROF&lt;/code&gt; is delivered when the timer expires. &lt;code&gt;SIGPROF&lt;/code&gt; can interrupt system calls.</source>
          <target state="translated">.) 타이머가 만료되면 &lt;code&gt;SIGPROF&lt;/code&gt; 가 전달됩니다. &lt;code&gt;SIGPROF&lt;/code&gt; 는 시스템 호출을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b31054f5704230a5bec08949d15eb068845e4a0" translate="yes" xml:space="preserve">
          <source>.) &lt;code&gt;SIGVTALRM&lt;/code&gt; is delivered when the timer expires.</source>
          <target state="translated">.) 타이머가 만료되면 &lt;code&gt;SIGVTALRM&lt;/code&gt; 이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7d4cb879abd948fd8f6f6ec2ac52e70b75438395" translate="yes" xml:space="preserve">
          <source>.) Consider this example of a processor for responses to French &quot;oui/non&quot; questions:</source>
          <target state="translated">.) 프랑스어 &quot;oui / non&quot;질문에 대한 응답을위한이 프로세서 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="55c96f5da895d355dfe91bda682a5d356859a660" translate="yes" xml:space="preserve">
          <source>.) Perl lingo for implicit conversion into a number; the related verb is</source>
          <target state="translated">.) 숫자로의 암시 적 변환을위한 Perl 용어; 관련 동사는</target>
        </trans-unit>
        <trans-unit id="b93475399b9cb0b16773d996788214eaf0b681e3" translate="yes" xml:space="preserve">
          <source>.) Will raise a fatal exception if used on a machine that doesn't implement getpriority(2).</source>
          <target state="translated">.) getpriority (2)를 구현하지 않는 머신에서 사용하면 치명적인 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7dd6e7fd8f9b5f85e01ec4e5265654e1001e224b" translate="yes" xml:space="preserve">
          <source>., are tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, and the subpattern regular expression contains a locale-dependent construct. These constructs include &lt;code&gt;\w&lt;/code&gt; (to match an alphanumeric character), &lt;code&gt;\W&lt;/code&gt; (non-alphanumeric character), &lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; (word-boundary and non-boundardy, which depend on what &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; match), &lt;code&gt;\s&lt;/code&gt; (whitespace character), &lt;code&gt;\S&lt;/code&gt; (non whitespace character), &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; (digits and non-digits), and the POSIX character classes, such as &lt;code&gt;[:alpha:]&lt;/code&gt; (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 을 포함 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 양식이 적용되고 서브 패턴 정규 표현식에 로케일 종속 구문 이 포함 된 경우.가 오염됩니다 . 이러한 구성에는 &lt;code&gt;\w&lt;/code&gt; (영숫자 문자와 일치), &lt;code&gt;\W&lt;/code&gt; (영숫자 이외 문자), &lt;code&gt;\b&lt;/code&gt; 및 &lt;code&gt;\B&lt;/code&gt; (단어 및 비 경계, &lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\W&lt;/code&gt; 일치 항목 에 따라 다름 ), &lt;code&gt;\s&lt;/code&gt; (공백 문자), &lt;code&gt;\S&lt;/code&gt; (공백 문자가 아닌 문자), &lt;code&gt;\d&lt;/code&gt; 및 &lt;code&gt;\D&lt;/code&gt; (숫자 및 숫자가 아닌 문자) 및 POSIX 문자 클래스 (예 : &lt;code&gt;[:alpha:]&lt;/code&gt; (참조 :&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass의 POSIX 문자 클래스&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e59a1ab03cde47262e6c27971e4743e9af22f1e" translate="yes" xml:space="preserve">
          <source>... 1 10e004812:0082 Perl_croak util.c:1716 /usr/bin/perl 2 10df8d6d2:1d72 perl_parse perl.c:3975 /usr/bin/perl ...</source>
          <target state="translated">... 1 10e004812 : 0082 Perl_croak util.c : 1716 / usr / bin / perl 2 10df8d6d2 : 1d72 perl_parse perl.c : 3975 / usr / bin / perl ...</target>
        </trans-unit>
        <trans-unit id="364594d0431ef65e113f6cebf4b5cbc7c01e5c5b" translate="yes" xml:space="preserve">
          <source>... and run the script as</source>
          <target state="translated">... 그리고 스크립트를 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d26f70a15839ea2f8c72c06151ad7587807c32dd" translate="yes" xml:space="preserve">
          <source>... except inside quoted strings:</source>
          <target state="translated">... 인용 된 문자열을 제외하고 :</target>
        </trans-unit>
        <trans-unit id="df0638782775a5ef38d469ff31aa8ebb7627c212" translate="yes" xml:space="preserve">
          <source>... than to have a long list of unnamed parameters like this:</source>
          <target state="translated">... 다음과 같이 이름없는 매개 변수의 긴 목록을 갖는 것보다 :</target>
        </trans-unit>
        <trans-unit id="9e84afc2259e2c0a8b14385093616bc8417a02b4" translate="yes" xml:space="preserve">
          <source>...]</source>
          <target state="translated">...]</target>
        </trans-unit>
        <trans-unit id="4ab0a9790c00e729a4b45f232d5bba12449d6c2c" translate="yes" xml:space="preserve">
          <source>...]]</source>
          <target state="translated">...]]</target>
        </trans-unit>
        <trans-unit id="109254dd4bd8f76ba5dbc86501465c6e439045dd" translate="yes" xml:space="preserve">
          <source>...and start_/end_ methods for whatever other events you want to catch.</source>
          <target state="translated">... 및 잡으려는 다른 이벤트에 대한 start_ / end_ 메소드.</target>
        </trans-unit>
        <trans-unit id="504c7fa4112a565c2cf84d1f2a407fe70455f0df" translate="yes" xml:space="preserve">
          <source>...and then set the PERL5LIB environment variable to point at the blib/lib and blib/arch directories.</source>
          <target state="translated">... 그리고 나서 PERL5LIB 환경 변수가 blib / lib 및 blib / arch 디렉토리를 가리 키도록 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="84f613d3f84815f94455470937ac7ad2bf4d0a09" translate="yes" xml:space="preserve">
          <source>...before you call one of the &lt;code&gt;$parser-&amp;gt;parse_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods.</source>
          <target state="translated">... 당신이 중 하나를 호출하기 전에 &lt;code&gt;$parser-&amp;gt;parse_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="cedc2cb71ea42e91547d5115a44db3cb21d773d0" translate="yes" xml:space="preserve">
          <source>...classes...</source>
          <target state="translated">...classes...</target>
        </trans-unit>
        <trans-unit id="9c06d968e1ccdd60b03d3bb98823d723427575b7" translate="yes" xml:space="preserve">
          <source>...emits the right text for this language. If the object in &lt;code&gt;$lh&lt;/code&gt; belongs to class &quot;TkBocciBall::Localize::fr&quot; and %TkBocciBall::Localize::fr::Lexicon contains &lt;code&gt;(&quot;You won!&quot;
=&amp;gt; &quot;Tu as gagn&amp;eacute;!&quot;)&lt;/code&gt; , then the above code happily tells the user &quot;Tu as gagn&amp;eacute;!&quot;.</source>
          <target state="translated">...이 언어에 적합한 텍스트를 가지고 있습니다. 에서 개체 경우 &lt;code&gt;$lh&lt;/code&gt; 클래스에 속하는 &quot;TkBocciBall :: 로컬 라이즈 : FR&quot;및 % TkBocciBall :: 로컬 라이즈 :: 프랑스 :: 어휘 포함 &lt;code&gt;(&quot;You won!&quot; =&amp;gt; &quot;Tu as gagn&amp;eacute;!&quot;)&lt;/code&gt; , 다음 위 코드는 행복하게 사용자에게 &quot;Tu as gagn&amp;eacute;!&quot;를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="712b26d21316d47220b94f84a7da8b2fb7a09b62" translate="yes" xml:space="preserve">
          <source>...except that the &lt;code&gt;ok(1)&lt;/code&gt; emits not just &quot;&lt;code&gt;ok &lt;i&gt;testnum&lt;/i&gt;&lt;/code&gt;&quot; but actually &quot;&lt;code&gt;ok &lt;i&gt;testnum&lt;/i&gt; # &lt;i&gt;skip_if_true_value&lt;/i&gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">... &lt;code&gt;ok(1)&lt;/code&gt; 는 &quot; &lt;code&gt;ok &lt;i&gt;testnum&lt;/i&gt;&lt;/code&gt; &quot;뿐만 아니라 실제로 &quot; &lt;code&gt;ok &lt;i&gt;testnum&lt;/i&gt; # &lt;i&gt;skip_if_true_value&lt;/i&gt;&lt;/code&gt; &quot;를 방출 한다는 점을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="dea7efd8b01b4bf297abf9354d989e9166dfea78" translate="yes" xml:space="preserve">
          <source>...must</source>
          <target state="translated">...must</target>
        </trans-unit>
        <trans-unit id="2a2a1f8d28f7cd2a5a4c4c11b72844a03f1f37b7" translate="yes" xml:space="preserve">
          <source>...or specify whichever of those functions you want to import, like so:</source>
          <target state="translated">... 또는 다음과 같이 가져올 함수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="43b677d161683ebdb1b28c026a49a7bd08793e8a" translate="yes" xml:space="preserve">
          <source>...then all are exported. (This saves you from having to use something less obvious like &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; I18N::LangTags qw(/./)&lt;/code&gt; .)</source>
          <target state="translated">... 모두 내 보냅니다. (이것은 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; I18N::LangTags qw(/./)&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 과 같이 덜 분명한 것을 사용하지 않아도됩니다 .)</target>
        </trans-unit>
        <trans-unit id="e33c1ec514bde82733b90f7f247929125d6b8078" translate="yes" xml:space="preserve">
          <source>...to this code that uses a key-as-value:</source>
          <target state="translated">... 값으로 키를 사용하는이 코드에 :</target>
        </trans-unit>
        <trans-unit id="db7e5c4fcf2d46cb0f6d02fa12cbdd838b0329a2" translate="yes" xml:space="preserve">
          <source>...which is almost definitely not going to work as a hyperlink (assuming this formatter outputs a format supporting hypertext).</source>
          <target state="translated">... 거의 확실히 하이퍼 링크로 작동하지 않을 것입니다 (이 포맷터가 하이퍼 텍스트를 지원하는 형식을 출력한다고 가정).</target>
        </trans-unit>
        <trans-unit id="99973db96ec1c293f28ff50ded17820d42b78f45" translate="yes" xml:space="preserve">
          <source>...which works exactly as if you'd done this:</source>
          <target state="translated">...이 작업을 수행 한 것처럼 정확하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4bf5c672e8aea68d29c24806b8df46739e047857" translate="yes" xml:space="preserve">
          <source>...which you'd then call in a construct like this:</source>
          <target state="translated">... 다음과 같은 구문을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="30c1b8cea3328ab077a48a704fe806c461511bdd" translate="yes" xml:space="preserve">
          <source>...will make such Pod translators completely fail to see the Pod block at all.</source>
          <target state="translated">... 그러한 포드 번역가들이 포드 블록을 전혀 보지 못하게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4da46934b906c13860d2b11dba8d32b5047444a3" translate="yes" xml:space="preserve">
          <source>../xlib/$(CROSS_NAME)</source>
          <target state="translated">../xlib/$(CROSS_NAME)</target>
        </trans-unit>
        <trans-unit id="9cfaf6885341224ca2a61f3f0d06b8ec7ae71810" translate="yes" xml:space="preserve">
          <source>./.perldb</source>
          <target state="translated">./.perldb</target>
        </trans-unit>
        <trans-unit id="31005ee63fa684fe5166e538dfacdd891d18ff38" translate="yes" xml:space="preserve">
          <source>./.proverc</source>
          <target state="translated">./.proverc</target>
        </trans-unit>
        <trans-unit id="e282f6a3db8ec1dda906cf6c0b42a08f8a612af0" translate="yes" xml:space="preserve">
          <source>./Configure</source>
          <target state="translated">./Configure</target>
        </trans-unit>
        <trans-unit id="c3139af2547eef32e8e266aa15c05437ce219e33" translate="yes" xml:space="preserve">
          <source>./baz/</source>
          <target state="translated">./baz/</target>
        </trans-unit>
        <trans-unit id="710dfdeac8c932afa29f9e91db1a84b32d9176f6" translate="yes" xml:space="preserve">
          <source>./baz/epsilon</source>
          <target state="translated">./baz/epsilon</target>
        </trans-unit>
        <trans-unit id="15e6eb3e9ae05be7477fa620759790da42381570" translate="yes" xml:space="preserve">
          <source>./config.sh</source>
          <target state="translated">./config.sh</target>
        </trans-unit>
        <trans-unit id="299c5c55222e99d7c9fd57befa2b18ee584041a5" translate="yes" xml:space="preserve">
          <source>./ext</source>
          <target state="translated">./ext</target>
        </trans-unit>
        <trans-unit id="c22382ed6431bc8ca6ce395e95a56c68ad135b34" translate="yes" xml:space="preserve">
          <source>./hints/os2.sh</source>
          <target state="translated">./hints/os2.sh</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
