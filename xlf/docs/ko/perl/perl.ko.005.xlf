<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="246b91b96e62d4665dc1c91df63b1c10f4839a54" translate="yes" xml:space="preserve">
          <source>, as you'll need to understand the &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; API. A good place to start is by understanding how &lt;a href=&quot;#aggregate_tests&quot;&gt;aggregate_tests&lt;/a&gt; works.</source>
          <target state="translated">&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; API 를 이해해야합니다 . 시작하기 좋은 곳은 &lt;a href=&quot;#aggregate_tests&quot;&gt;aggregation_tests의&lt;/a&gt; 작동 방식을 이해하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="883a2167578552cc32e56e34c60f2a72656b4d09" translate="yes" xml:space="preserve">
          <source>, assumed to be a sequence of octets in</source>
          <target state="translated">의 옥텟 시퀀스로 가정</target>
        </trans-unit>
        <trans-unit id="97655fb802994ecc260e5ef2fb866ce517a9c299" translate="yes" xml:space="preserve">
          <source>, at least once</source>
          <target state="translated">, 한 번 이상</target>
        </trans-unit>
        <trans-unit id="f734969a140ce2aea92a8a6a21bc618d5f511646" translate="yes" xml:space="preserve">
          <source>, at least once, but as few times as possible</source>
          <target state="translated">, 최소 한 번, 가능한 한 적은 횟수</target>
        </trans-unit>
        <trans-unit id="e751512716d9aa9f5b3c28259b944c1f3b0c56d1" translate="yes" xml:space="preserve">
          <source>, attempts to bring some of the newer Perl API features to older versions of Perl, so that you can worry less about keeping track of old releases, but users can still reap the benefit.</source>
          <target state="translated">, 이전 버전의 Perl에 새로운 Perl API 기능 중 일부를 가져 오려고 시도하므로 이전 릴리스를 추적하는 것에 대해 걱정할 필요가 없지만 사용자는 여전히 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcf124669e071fb32c507b660ca8a45e10a33382" translate="yes" xml:space="preserve">
          <source>, because the $1 variable is magical and read-only :</source>
          <target state="translated">$ 1 변수는 마술적이고 읽기 전용이기 때문에 :</target>
        </trans-unit>
        <trans-unit id="24f1b41d67d203257d6ce62a6d577842a88809d7" translate="yes" xml:space="preserve">
          <source>, because the reduced pollution of newer Perl versions is an important thing. It's so important that the old polluting ways of original Perl modules will not be supported very far into the future, and your module will almost certainly break! By adapting to it now, you'll gain compatibility and a sense of having done the electronic ecology some good.</source>
          <target state="translated">최신 Perl 버전의 오염 감소가 중요한 것이기 때문입니다. 오리지널 Perl 모듈의 오래된 오염 방법이 미래에 아주 멀리 지원되지 않을 것이며 모듈이 거의 확실하게 깨질 것입니다! 지금 적응함으로써, 당신은 호환성과 전자 생태학을 어느 정도 잘 해냈다는 느낌을 얻게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd35ebaf87e878605763ba0f4d65f6bf7f75dcc8" translate="yes" xml:space="preserve">
          <source>, because you were accidentally accessing &lt;code&gt;@aref&lt;/code&gt; , an undeclared variable, and it would thereby remind you to write instead:</source>
          <target state="translated">실수로 선언되지 않은 변수 인 &lt;code&gt;@aref&lt;/code&gt; 에 액세스했기 때문에 대신 작성하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d0ee637a4d76e416584c4c77f040993c430048a2" translate="yes" xml:space="preserve">
          <source>, because you were accidentally accessing &lt;code&gt;@aref&lt;/code&gt;, an undeclared variable, and it would thereby remind you to write instead:</source>
          <target state="translated">, 선언되지 않은 변수 인 &lt;code&gt;@aref&lt;/code&gt; 에 실수로 액세스했기 때문에 대신 작성하도록 상기시켜줍니다.</target>
        </trans-unit>
        <trans-unit id="fc90bbfbb3e4cc7f9f2ca2bbceaeebbd891dbeb9" translate="yes" xml:space="preserve">
          <source>, below takes 2 parameters and increments each directly.</source>
          <target state="translated">아래에서 2 개의 매개 변수를 사용하고 각각 직접 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a6beabe044ad8f9d1627ed533c6a9c88995aa997" translate="yes" xml:space="preserve">
          <source>, but $siteprefix might be</source>
          <target state="translated">이지만 $ siteprefix는</target>
        </trans-unit>
        <trans-unit id="6fce1e601c1523c8b2526a111e9e136024aa2709" translate="yes" xml:space="preserve">
          <source>, but are no longer available with</source>
          <target state="translated">으로 더 이상 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="64ad796371383427b4cd0ba4371e73bd89ebb1b2" translate="yes" xml:space="preserve">
          <source>, but because &lt;code&gt;Foo&lt;/code&gt; defines a symbol (the &lt;code&gt;exclaim&lt;/code&gt; subroutine), &lt;code&gt;base&lt;/code&gt; will not die when the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; fails to load</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 가 심볼 ( &lt;code&gt;exclaim&lt;/code&gt; 서브 루틴)을 정의 하기 때문에 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 가로드 되지 않으면 &lt;code&gt;base&lt;/code&gt; 가 죽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c525aea4fc6dee1fd7c69c615565d059f44dd5dd" translate="yes" xml:space="preserve">
          <source>, but because &lt;code&gt;Foo&lt;/code&gt; defines a symbol (the &lt;code&gt;exclaim&lt;/code&gt; subroutine), &lt;code&gt;base&lt;/code&gt; will not die when the &lt;code&gt;require&lt;/code&gt; fails to load</source>
          <target state="translated">, 그러나 &lt;code&gt;Foo&lt;/code&gt; 가 심볼 ( &lt;code&gt;exclaim&lt;/code&gt; 서브 루틴)을 정의 하기 때문에 , &lt;code&gt;require&lt;/code&gt; 가로드에 실패 하더라도 &lt;code&gt;base&lt;/code&gt; 는 죽지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="61e7380af3179cca867b3885f99b22e74a3249cf" translate="yes" xml:space="preserve">
          <source>, but because you access them via the &lt;code&gt;maketext&lt;/code&gt; method, which looks for entries across all the &lt;code&gt;%Lexicon&lt;/code&gt; hashes in a language class</source>
          <target state="translated">언어 클래스의 모든 &lt;code&gt;%Lexicon&lt;/code&gt; 해시에서 항목을 찾는 &lt;code&gt;maketext&lt;/code&gt; 메소드 를 통해 액세스하기 때문에</target>
        </trans-unit>
        <trans-unit id="a42a597d11c292d0f56cbf1684a5eac6028a67a1" translate="yes" xml:space="preserve">
          <source>, but can also be</source>
          <target state="translated">이지만</target>
        </trans-unit>
        <trans-unit id="7909130b18300cbb98ea4bbe9e66d49642019dec" translate="yes" xml:space="preserve">
          <source>, but cannot come at the end of a string, because the backslash would be parsed as escaping the end quote.</source>
          <target state="translated">백 슬래시는 끝 따옴표를 이스케이프하는 것으로 구문 분석되므로 문자열 끝에 올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="42948efb81aca3fb2bd97534710c99990f79587a" translate="yes" xml:space="preserve">
          <source>, but from line 4.</source>
          <target state="translated">, 그러나 4 행부터.</target>
        </trans-unit>
        <trans-unit id="bd1670f6de47acc9c9b7267ab71cba06c196ce25" translate="yes" xml:space="preserve">
          <source>, but it causes no harm.)</source>
          <target state="translated">하지만 해를 끼치 지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="37120fa0734b652eb610ce4ae8b5f1bcc7d622f5" translate="yes" xml:space="preserve">
          <source>, but it does not contain all the characters from those blocks. It does not, for example, contain the digits 0-9, because those digits are shared across many scripts, and hence are in the &lt;code&gt;Common&lt;/code&gt; script.</source>
          <target state="translated">하지만 해당 블록의 모든 문자를 포함하지는 않습니다. 예를 들어 숫자는 0-9를 포함하지 않습니다. 그 숫자는 많은 스크립트에서 공유되므로 &lt;code&gt;Common&lt;/code&gt; 스크립트에 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1f2db577fa7893e92367cf784603b9d9d657f707" translate="yes" xml:space="preserve">
          <source>, but it has no problem linking to symbols in the</source>
          <target state="translated">이지만 기호의 링크에 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfb0016f55f0d3d559ba19fb54ebc0f455007395" translate="yes" xml:space="preserve">
          <source>, but it is a PM application.</source>
          <target state="translated">하지만 PM 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="bbe2c80423e439b3e4c161c99b0cea935717fc61" translate="yes" xml:space="preserve">
          <source>, but it is a very bad idea for two reasons.</source>
          <target state="translated">그러나 두 가지 이유로 매우 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="cdd23309b99a536c1f9d3df8a7c3d7430cce3c6b" translate="yes" xml:space="preserve">
          <source>, but it's really a 2D plane). The number</source>
          <target state="translated">하지만 실제로는 2D 평면입니다). 수</target>
        </trans-unit>
        <trans-unit id="b1b91a2c92813f244d7d492decf11786f03248cc" translate="yes" xml:space="preserve">
          <source>, but parameter order has been &quot;tidied up a little&quot;.</source>
          <target state="translated">그러나 매개 변수 순서는 &quot;약간 정리되었습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="14b0058af4ca943727004b79d41d8ab59c3a8dd9" translate="yes" xml:space="preserve">
          <source>, but should prefer</source>
          <target state="translated">,하지만 선호해야 함</target>
        </trans-unit>
        <trans-unit id="114efd0755f2064562435a7b7db5cf78b23a339b" translate="yes" xml:space="preserve">
          <source>, but that the meaning of the code point has been</source>
          <target state="translated">코드 포인트의 의미는</target>
        </trans-unit>
        <trans-unit id="75a1a26b1e5fe270ec7a97baa5b4e4135475611b" translate="yes" xml:space="preserve">
          <source>, but the &lt;a href=&quot;Email::Valid&quot;&gt;Email::Valid&lt;/a&gt; module will do both part</source>
          <target state="translated">, 그러나 &lt;a href=&quot;Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; 모듈은 두 부분을 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e48be256548eb3d87af3b99e921dd4b6fcf05890" translate="yes" xml:space="preserve">
          <source>, but the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; module was unable to locate this library. See &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;.</source>
          <target state="translated">하지만 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader의&lt;/a&gt; 모듈은이 라이브러리를 찾을 수 없습니다. &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bec967278894f864c70eea888e73e74018b65bcb" translate="yes" xml:space="preserve">
          <source>, but the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt; module will do both part</source>
          <target state="translated">이지만 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; 모듈은 두 부분을 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7536c70955b6a15d5f19153fc86efe49d7b1220b" translate="yes" xml:space="preserve">
          <source>, but the latter parts after</source>
          <target state="translated">하지만 후자의 부분은</target>
        </trans-unit>
        <trans-unit id="6b70056cdd55185377fa7fb36dcc37e7dfcc656b" translate="yes" xml:space="preserve">
          <source>, but there are legitimate cases where the polar style</source>
          <target state="translated">그러나 극지방 스타일의 합법적 인 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b30d41b915336fadcad5858b5a1e924cedc04255" translate="yes" xml:space="preserve">
          <source>, but there are some issues with this form, described below.</source>
          <target state="translated">이지만이 양식에는 아래에 설명 된 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="083b89b36ef467b16cb732332b28ca7c58c02c6f" translate="yes" xml:space="preserve">
          <source>, but these are also sufficiently generic that the actual version of perl probably doesn't matter too much.)</source>
          <target state="translated">그러나 실제 버전의 perl은 그다지 중요하지 않을 정도로 충분히 일반적입니다.)</target>
        </trans-unit>
        <trans-unit id="440fbd28d07d5c795b6c02a88a168111c4c2b6d4" translate="yes" xml:space="preserve">
          <source>, but they are &quot;shared in the private address space of the process&quot;; this is possible because the address at which different sections of the</source>
          <target state="translated">그러나 &quot;프로세스의 개인 주소 공간에서 공유됩니다&quot;; 이것은 다른 섹션의 주소가</target>
        </trans-unit>
        <trans-unit id="e5d0a0fe8de2f9a20207b5984a8a5c6b03dfd271" translate="yes" xml:space="preserve">
          <source>, but those are both created with customizable</source>
          <target state="translated">하지만 모두 사용자 정의 가능</target>
        </trans-unit>
        <trans-unit id="8a1d6fa8427fbb9da10acb5f650733e9aa4df3f0" translate="yes" xml:space="preserve">
          <source>, but unicode-strings are downgraded with UTF-8 encoding. This happens because the first 256 codepoints in Unicode happens to agree with Latin-1.</source>
          <target state="translated">하지만 유니 코드 문자열은 UTF-8 인코딩으로 다운 그레이드됩니다. 이것은 유니 코드의 처음 256 개의 코드 포인트가 Latin-1과 일치하기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30f76102144f22e473a3819c08962f84a35f7781" translate="yes" xml:space="preserve">
          <source>, but without any arguments at all, meaning it was called as &lt;code&gt;&amp;amp;infested&lt;/code&gt; . The next stack frame shows that the function &lt;code&gt;Ambulation::legs&lt;/code&gt; was called in list context from the</source>
          <target state="translated">그러나 인수가 전혀 없으므로 &lt;code&gt;&amp;amp;infested&lt;/code&gt; 라고 합니다. 다음 스택 프레임은 &lt;code&gt;Ambulation::legs&lt;/code&gt; 함수 가 목록 컨텍스트에서</target>
        </trans-unit>
        <trans-unit id="ae798928c9d09a028636501055f75aa984c26a2d" translate="yes" xml:space="preserve">
          <source>, but without any arguments at all, meaning it was called as &lt;code&gt;&amp;amp;infested&lt;/code&gt;. The next stack frame shows that the function &lt;code&gt;Ambulation::legs&lt;/code&gt; was called in list context from the</source>
          <target state="translated">, 그러나 인수가 전혀 없으므로 &lt;code&gt;&amp;amp;infested&lt;/code&gt; 로 호출되었습니다 . 다음 스택 프레임은 &lt;code&gt;Ambulation::legs&lt;/code&gt; 함수 가</target>
        </trans-unit>
        <trans-unit id="72ba937cc0e16bb306ca2b4bf857c5037ec4cf2e" translate="yes" xml:space="preserve">
          <source>, but you can also find it with &lt;code&gt;(get&lt;/code&gt;&lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt; . (Some platforms do not have a concept of a home directory.)</source>
          <target state="translated">그러나 &lt;code&gt;(get&lt;/code&gt; &lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt; 찾을 수도 있습니다 . (일부 플랫폼에는 홈 디렉토리 개념이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="66bf2d68f3062e2f5b926174869b8b87c1d69bb9" translate="yes" xml:space="preserve">
          <source>, but you can also find it with &lt;code&gt;(get&lt;/code&gt;&lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt;. (Some platforms do not have a concept of a home directory.)</source>
          <target state="translated">,하지만 &lt;code&gt;(get&lt;/code&gt; &lt;code&gt;pwuid($&amp;lt;))[7]&lt;/code&gt; 로도 찾을 수 있습니다 . (일부 플랫폼에는 홈 디렉토리 개념이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="d30cbc2585551375d5776769096b997571f847fa" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien and published posthumously by his son and literary executor, C.J.R. Tolkien, being the 3rd of the 12 volumes in Christopher's mammoth</source>
          <target state="translated">, JRR Tolkien에 의해 그의 아들과 문학적 집행 인 CJR Tolkien에 의해 사후에 출판되어 크리스토퍼의 매머드에서 12 권 3 위</target>
        </trans-unit>
        <trans-unit id="20a4c36993cdadf5b45a96ba6612a7047ca32e20" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien. The hardcover, 50th-anniversary edition of 2004 was used, published in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.</source>
          <target state="translated">JRR 톨킨 2004 년 50 주년 기념판 인 하드 커버는 영국에서 Harper Collins Publishers와 미국에서 Houghton Mifflin Company에 의해 출판되었습니다.</target>
        </trans-unit>
        <trans-unit id="efffb220c955e443cccb58c8907e329a0175c1d5" translate="yes" xml:space="preserve">
          <source>, by J.R.R. Tolkien. The hardcover, 70th-anniversary edition of 2007 was used, published in the UK by Harper Collins Publishers and in the US by the Houghton Mifflin Company.</source>
          <target state="translated">JRR 톨킨 영국에서 Harper Collins Publishers와 Houghton Mifflin Company가 출판 한 2007 년 70 주년 기념 양 장본이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="074cc72ccfc535a7fd2e5dfd0338a00ba7d4e394" translate="yes" xml:space="preserve">
          <source>, by default. The format of the file looks like this:</source>
          <target state="translated">, 기본적으로. 파일 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15848886de9254fb610ee7af8ef183ea5520e125" translate="yes" xml:space="preserve">
          <source>, calling its check function, allocating a target if it needs one, and folding constants.</source>
          <target state="translated">확인 기능을 호출하고 필요한 경우 대상을 할당하고 상수를 접습니다.</target>
        </trans-unit>
        <trans-unit id="f1dcc83c1274d4f418815f27c4f79fd6d2c788ff" translate="yes" xml:space="preserve">
          <source>, chapter 20, or</source>
          <target state="translated">, 20 장 또는</target>
        </trans-unit>
        <trans-unit id="8ad183a82720f028dc83a25268edf18aae60bbed" translate="yes" xml:space="preserve">
          <source>, chapter 5.</source>
          <target state="translated">, 5 장.</target>
        </trans-unit>
        <trans-unit id="1757193dd1ff5a7e70ef0ab65fa059299037848a" translate="yes" xml:space="preserve">
          <source>, characters in the target string that match a character in</source>
          <target state="translated">, 대상 문자열의 문자와 일치하는 문자</target>
        </trans-unit>
        <trans-unit id="8ae0b48133bb856879ab9974c904d27120fd6b88" translate="yes" xml:space="preserve">
          <source>, consisting of a first and last name (no middle initial). The name class has four methods:</source>
          <target state="translated">, 성으로 구성됩니다 (중간 이니셜 없음). 이름 클래스에는 네 가지 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="13383455434bc33fbc4b94aaa1a7d28b9e8cf222" translate="yes" xml:space="preserve">
          <source>, depending on the operating system. The variable &lt;a href=&quot;config#_exe&quot;&gt;&lt;code&gt;$Config{_exe}&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module holds the executable suffix, if any. Third, the VMS port carefully sets up &lt;a href=&quot;perlvar#%24%5EX&quot;&gt;&lt;code&gt;$^X&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;config#perlpath&quot;&gt;&lt;code&gt;$Config{perlpath}&lt;/code&gt;&lt;/a&gt; so that no further processing is required. This is just as well, because the matching regular expression used below would then have to deal with a possible trailing version number in the VMS file name.</source>
          <target state="translated">, 운영 체제에 따라 다릅니다. 변수 &lt;a href=&quot;config#_exe&quot;&gt; &lt;code&gt;$Config{_exe}&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 있는 경우 모듈은 실행 접미사를 보유하고 있습니다. 셋째, VMS 포트는 &lt;a href=&quot;perlvar#%24%5EX&quot;&gt; &lt;code&gt;$^X&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;config#perlpath&quot;&gt; &lt;code&gt;$Config{perlpath}&lt;/code&gt; &lt;/a&gt; 신중하게 설정 하므로 추가 처리가 필요하지 않습니다. 아래에 사용 된 일치하는 정규식이 VMS 파일 이름의 가능한 후행 버전 번호를 처리해야하기 때문에 이것도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7deb52a5ffa60ddf7faa0bfee1739d2eee5281b4" translate="yes" xml:space="preserve">
          <source>, depending on the operating system. The variable &lt;code&gt;&quot;_exe&quot;&lt;/code&gt; in the &lt;code&gt;Config&lt;/code&gt; module holds the executable suffix, if any. Third, the VMS port carefully sets up &lt;code&gt;$^X&lt;/code&gt; and &lt;code&gt;$Config{perlpath}&lt;/code&gt; so that no further processing is required. This is just as well, because the matching regular expression used below would then have to deal with a possible trailing version number in the VMS file name.</source>
          <target state="translated">운영 체제에 따라 다릅니다. &lt;code&gt;Config&lt;/code&gt; 모듈 의 &lt;code&gt;&quot;_exe&quot;&lt;/code&gt; 변수 는 실행 가능 접미어가있는 경우이를 보유합니다. 셋째, VMS 포트는 &lt;code&gt;$^X&lt;/code&gt; 및 &lt;code&gt;$Config{perlpath}&lt;/code&gt; 신중하게 설정 하므로 추가 처리가 필요하지 않습니다. 아래에 사용되는 일치하는 정규식은 VMS 파일 이름에서 가능한 후행 버전 번호를 처리해야하기 때문에 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="641474390807c65a1ea8e6d8031b0ad22844d890" translate="yes" xml:space="preserve">
          <source>, described in &lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt;.</source>
          <target state="translated">, &lt;a href=&quot;Hash::Util::FieldHash&quot;&gt;Hash :: Util :: FieldHash에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="da5a4498d5cd3fe648547701b8b083a3ff8ca97c" translate="yes" xml:space="preserve">
          <source>, described in &lt;a href=&quot;util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;util/fieldhash&quot;&gt;Hash :: Util :: FieldHash에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd04308b32b6687d7bf86d16ef25fad4d5ae88a" translate="yes" xml:space="preserve">
          <source>, didn't find it, and set &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; to a non-zero value indicating failure.</source>
          <target state="translated">, 찾지 못해 &lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;실패를 나타내는 0이 아닌 값으로.</target>
        </trans-unit>
        <trans-unit id="191488e37062f1a4cf41a5aeb9e53d937285dc2f" translate="yes" xml:space="preserve">
          <source>, didn't find it, and set &lt;code&gt;$?&lt;/code&gt; to a non-zero value indicating failure.</source>
          <target state="translated">그것을 찾지 못하고 &lt;code&gt;$?&lt;/code&gt; 설정 했습니까? 실패를 나타내는 0이 아닌 값으로.</target>
        </trans-unit>
        <trans-unit id="bffed554a4db53bd8f296b3affa5430997fc3de5" translate="yes" xml:space="preserve">
          <source>, do</source>
          <target state="translated">, 하다</target>
        </trans-unit>
        <trans-unit id="94c2dbf1b9eb9f81052b5cb53ad3879e10f289ae" translate="yes" xml:space="preserve">
          <source>, do not fit into any of the other directories, but which, in addition, cannot use</source>
          <target state="translated">, 다른 디렉토리에 맞지 않지만 추가로 사용할 수없는 디렉토리</target>
        </trans-unit>
        <trans-unit id="c65676655ea7406a8fc174f69430a531377ea940" translate="yes" xml:space="preserve">
          <source>, documented above, &lt;a href=&quot;#events-with-an-element_name-of-over-empty&quot;&gt;&quot;events with an element_name of over-empty&quot;&lt;/a&gt;.</source>
          <target state="translated">, 위에 설명 된 &lt;a href=&quot;#events-with-an-element_name-of-over-empty&quot;&gt;&quot;element_name이 초과 된 이벤트&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0a59da47187262d9d4bfa48199c7bce6f4c216" translate="yes" xml:space="preserve">
          <source>, does the opposite of the</source>
          <target state="translated">반대의</target>
        </trans-unit>
        <trans-unit id="8fcd667169652690ef5e54800f7ff7538897e19e" translate="yes" xml:space="preserve">
          <source>, e.g. once you created a number under the influence of &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt; , all results from math operations with that number will also be rounded.</source>
          <target state="translated">예를 들어 &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt; 의 영향을 받아 숫자를 생성하면 해당 숫자를 사용한 수학 연산의 모든 결과도 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="95f1a8ea281395023f3212b3e7fe5e8e678b9f23" translate="yes" xml:space="preserve">
          <source>, e.g. once you created a number under the influence of &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt;, all results from math operations with that number will also be rounded.</source>
          <target state="translated">예를 들어 &lt;code&gt;CLASS-&amp;gt;accuracy($A)&lt;/code&gt; 의 영향을 받아 숫자를 생성하면 해당 숫자를 사용한 수학 연산의 모든 결과도 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="5d483da9af92e1cedaee73a77b0f92e783cee701" translate="yes" xml:space="preserve">
          <source>, encountering an 8 or 9 will also trigger a warning. On return</source>
          <target state="translated">, 8 또는 9가 발생하면 경고가 트리거됩니다. 돌아올 때</target>
        </trans-unit>
        <trans-unit id="d2f5d265b5802df06743d0d56f8ee6faa03ca24f" translate="yes" xml:space="preserve">
          <source>, encountering an invalid character will also trigger a warning. On return</source>
          <target state="translated">잘못된 문자가 표시되면 경고가 트리거됩니다. 돌아올 때</target>
        </trans-unit>
        <trans-unit id="04677f3fac90b98f6c1dae663782f13b8cbddc16" translate="yes" xml:space="preserve">
          <source>, et al.) for your machine: &lt;code&gt;perl -MConfig -e 'print $Config{cc}'&lt;/code&gt; will tell you what to use.</source>
          <target state="translated">등) : 귀하의 컴퓨터 : &lt;code&gt;perl -MConfig -e 'print $Config{cc}'&lt;/code&gt; 가 무엇을 사용해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cad820714976d3b25c5367f0c02ee50a22785739" translate="yes" xml:space="preserve">
          <source>, etc) determined by &lt;b&gt;Configure&lt;/b&gt; (&lt;code&gt;$Config{'libpth'}&lt;/code&gt; ). This should ensure portability across a wide range of platforms.</source>
          <target state="translated">등)는 &lt;b&gt;Configure&lt;/b&gt; ( &lt;code&gt;$Config{'libpth'}&lt;/code&gt; )에 의해 결정됩니다 . 이를 통해 광범위한 플랫폼에서 이식성을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="f468a305e52e41fabae609fe5a43188262dfd717" translate="yes" xml:space="preserve">
          <source>, etc) determined by &lt;b&gt;Configure&lt;/b&gt; (&lt;code&gt;$Config{'libpth'}&lt;/code&gt;). This should ensure portability across a wide range of platforms.</source>
          <target state="translated">등) &lt;b&gt;구성&lt;/b&gt; ( &lt;code&gt;$Config{'libpth'}&lt;/code&gt; )에 의해 결정됩니다 . 이것은 광범위한 플랫폼에서 이식성을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a212453865c3ae5d769c013e9814daf8f2a214a4" translate="yes" xml:space="preserve">
          <source>, etc.</source>
          <target state="translated">등</target>
        </trans-unit>
        <trans-unit id="f74d93dc922dc52c2fedf5e569c92696750decef" translate="yes" xml:space="preserve">
          <source>, etc. Have your top-level &lt;code&gt;WriteMakefile&lt;/code&gt; set the variable &lt;code&gt;XSMULTI&lt;/code&gt; to a true value.</source>
          <target state="translated">등. 최상위 &lt;code&gt;WriteMakefile&lt;/code&gt; 이 변수 &lt;code&gt;XSMULTI&lt;/code&gt; 를 참 값으로 설정하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="b565fb66bcacd3184f91a476fa76a2a7c0432910" translate="yes" xml:space="preserve">
          <source>, etc. It is only used to set defaults for things in</source>
          <target state="translated">등의 항목에 대한 기본값을 설정하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="254162fca7c5d2117d855ce88363b775777d261a" translate="yes" xml:space="preserve">
          <source>, etc. Unfortunately, sometimes these filenames won't even work if you include an explicit directory prefix. It is best to avoid such filenames, if you want your code to be portable to DOS and its derivatives. It's hard to know what these all are, unfortunately.</source>
          <target state="translated">, 등. 안타깝게도 경우에 따라 명시적인 디렉토리 접두사를 포함하면 이러한 파일 이름이 작동하지 않을 수도 있습니다. 코드를 DOS 및 그 파생물로 이식하려면 이러한 파일 이름을 사용하지 않는 것이 가장 좋습니다. 불행히도이 모든 것이 무엇인지 알기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="2a688c0b28a7df2e9a7d253a82e6c6e84a3330b9" translate="yes" xml:space="preserve">
          <source>, etc. Windows and VMS have their own Configure-like scripts, in their respective directories.</source>
          <target state="translated">, 등등. Windows와 VMS는 각각의 디렉토리에 자신의 Configure와 유사한 스크립트를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="547884f80573a30a2c1775d0d189f35232800ed1" translate="yes" xml:space="preserve">
          <source>, etc.) show examples of general tied hashes, as does the &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; module. While these do not utilize &lt;b&gt;Tie::Hash&lt;/b&gt;, they serve as good working examples.</source>
          <target state="translated">등)은 &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 모듈 과 마찬가지로 일반적인 묶음 해시의 예를 보여줍니다 . 이들은 &lt;b&gt;Tie :: Hash를&lt;/b&gt; 사용하지 않지만 좋은 예제로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14799a215b2ab9755e0f596823ecf4dbc0d72f12" translate="yes" xml:space="preserve">
          <source>, etc.) show examples of general tied hashes, as does the &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; module. While these do not utilize &lt;b&gt;Tie::Hash&lt;/b&gt;, they serve as good working examples.</source>
          <target state="translated">등)은 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 모듈 과 마찬가지로 일반적인 연결 해시의 예를 보여줍니다 . 이들은 &lt;b&gt;Tie :: Hash를&lt;/b&gt; 사용하지 않지만 좋은 작업 예제로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f1210937e081e362e85df120171033ff4b61361" translate="yes" xml:space="preserve">
          <source>, etc., not keeping separate files for each little release.</source>
          <target state="translated">각 작은 릴리스마다 별도의 파일을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="800135a8cf871bdccfdf925e7c9f67cb8dbd1d91" translate="yes" xml:space="preserve">
          <source>, even if the old Unicode string used EBCDIC.</source>
          <target state="translated">이전 유니 코드 문자열이 EBCDIC을 사용한 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="727fb7fe0065fed08079bab1144d37e69c258b0f" translate="yes" xml:space="preserve">
          <source>, except that under &lt;code&gt;/s&lt;/code&gt;, the 2nd and following characters are squeezed out in a sequence of characters in a row that all translate to the same character. If</source>
          <target state="translated">단, &lt;code&gt;/s&lt;/code&gt; 아래 에있는 두 번째 및 다음 문자는 모두 동일한 문자로 변환되는 연속 문자 순서로 압축됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="7ae4a1230d3f708e9962358a9ef97eda0e7da8ca" translate="yes" xml:space="preserve">
          <source>, executes three Perl strings, extracting an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; from the first, a &lt;code&gt;float&lt;/code&gt; from the second, and a &lt;code&gt;char *&lt;/code&gt; from the third.</source>
          <target state="translated">, 세 개의 Perl 문자열을 실행 하여 첫 번째에서 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 를 추출 하고 두 번째에서 &lt;code&gt;float&lt;/code&gt; 을 추출 하고 &lt;code&gt;char *&lt;/code&gt; 세 번째에서 추출합니다.</target>
        </trans-unit>
        <trans-unit id="787d143c6cf0b043068fb80fa8b4344c2a645b40" translate="yes" xml:space="preserve">
          <source>, executes three Perl strings, extracting an &lt;code&gt;int&lt;/code&gt; from the first, a &lt;code&gt;float&lt;/code&gt; from the second, and a &lt;code&gt;char *&lt;/code&gt; from the third.</source>
          <target state="translated">, 세 개의 Perl 문자열을 실행 하여 첫 번째에서 &lt;code&gt;int&lt;/code&gt; , 두 번째에서 &lt;code&gt;float&lt;/code&gt; , 세 번째에서 &lt;code&gt;char *&lt;/code&gt; 를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="8592f41382d4e5c2d5d57b842dd51b103596cdc2" translate="yes" xml:space="preserve">
          <source>, first two will be issued to make the prompt standout, last two to make the input line standout.</source>
          <target state="translated">, 처음 두 개는 프롬프트를 돋보이게하고 마지막 두 개는 입력 라인을 돋보이게합니다.</target>
        </trans-unit>
        <trans-unit id="e326c61927837140eb9a99bc562c35954b12ff00" translate="yes" xml:space="preserve">
          <source>, followed by &quot;.&quot;, to represent the current directory. (&quot;.&quot; will not be appended if taint checks are enabled, either by &lt;code&gt;-T&lt;/code&gt; or by &lt;code&gt;-t&lt;/code&gt; .) If you need to modify this at runtime, you should use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; pragma to get the machine-dependent library properly loaded also:</source>
          <target state="translated">&quot;.&quot;다음에 현재 디렉토리를 나타냅니다. ( &lt;code&gt;-T&lt;/code&gt; 또는 &lt;code&gt;-t&lt;/code&gt; 에 의해 오염 검사가 활성화되어 있으면 &quot;&quot;. &quot;가 추가되지 않습니다 .) 런타임에이를 수정해야하는 경우, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; pragma를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 시스템 종속 라이브러리도 올바르게로드해야합니다. :</target>
        </trans-unit>
        <trans-unit id="e47c6b2622df17cb9ac51798532485ad11e9ba2e" translate="yes" xml:space="preserve">
          <source>, for &quot;interpreter threads&quot;.</source>
          <target state="translated">&quot;통역사 스레드&quot;의 경우</target>
        </trans-unit>
        <trans-unit id="3da21179cff23cf6f4725a6914c2f3067c8f2e68" translate="yes" xml:space="preserve">
          <source>, for example &lt;code&gt;constant_5&lt;/code&gt; for names 5 characters long. The default</source>
          <target state="translated">, 예를 들어 &lt;code&gt;constant_5&lt;/code&gt; 이름이 5자인 경우 입니다. 기본</target>
        </trans-unit>
        <trans-unit id="2fee34f87618999ee14e21bb687483c9271ed175" translate="yes" xml:space="preserve">
          <source>, for example).</source>
          <target state="translated">예를 들어).</target>
        </trans-unit>
        <trans-unit id="28da9ec75c809bccb5f08bba4f669c3533c7ba7b" translate="yes" xml:space="preserve">
          <source>, for example, this would include</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7c331f0b5befe1a82f2eeb7e08fd9a086e46b9f4" translate="yes" xml:space="preserve">
          <source>, for example, which is usually in</source>
          <target state="translated">예를 들어 일반적으로</target>
        </trans-unit>
        <trans-unit id="1611b180f41bef969e37c18e79566f4a39e16c29" translate="yes" xml:space="preserve">
          <source>, for instance, have been placed there rather than in</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="56372a1dac8b69b17464e5a00569b03f0872fcdf" translate="yes" xml:space="preserve">
          <source>, freeing all resources associated with it.</source>
          <target state="translated">, 관련 리소스를 모두 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f4b8256a6099f4e144fd62a3869c42ca7b38c688" translate="yes" xml:space="preserve">
          <source>, greater-than. Or Pod parsers may offer the alternative option of processing such unknown &quot;E&amp;lt;</source>
          <target state="translated">, 보다 큰. 또는 포드 파서는 알 수없는 &quot;E &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e7f34752016620eedb00a8cbd6624ed4757364db" translate="yes" xml:space="preserve">
          <source>, handing it NULL for the second argument:</source>
          <target state="translated">두 번째 인수에 대해 NULL을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="13918e9d4ee7ed5a5b531e3ce1c4548f829845bb" translate="yes" xml:space="preserve">
          <source>, has very helpful pictures:</source>
          <target state="translated">매우 유용한 사진이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2d144fe487b3bdc6b5822c043f233ce157080f" translate="yes" xml:space="preserve">
          <source>, have aliases</source>
          <target state="translated">, 별칭이 있습니다</target>
        </trans-unit>
        <trans-unit id="4f6137d9065b22f545ac392077aa91739c927e9e" translate="yes" xml:space="preserve">
          <source>, however, a module under</source>
          <target state="translated">그러나 아래 모듈</target>
        </trans-unit>
        <trans-unit id="9205ef8665795fce8cf05345636ac2832fbc1a01" translate="yes" xml:space="preserve">
          <source>, if any. If it returns the empty string, use &lt;a href=&quot;#getpwuid-UID&quot;&gt;&lt;code&gt;getpwuid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">, 만약에 어떠한. 빈 문자열을 반환하면 &lt;a href=&quot;#getpwuid-UID&quot;&gt; &lt;code&gt;getpwuid&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa65a22e2f2e07e3150f049e4c966e6fcd3df9ae" translate="yes" xml:space="preserve">
          <source>, if any. If it returns the empty string, use &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">, 만약에 어떠한. 빈 문자열을 반환하면 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb8b8da23653cf06debe3b23d1da5fd0c356db27" translate="yes" xml:space="preserve">
          <source>, if any. If it returns the empty string, use &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">, 만약에 어떠한. 빈 문자열을 반환하면 &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6769873a1cbe047b8a844d6fbd4ad589c9faed9" translate="yes" xml:space="preserve">
          <source>, if given, is the file to which to write the formatted output. If</source>
          <target state="translated">지정된 경우 형식화 된 출력을 쓸 파일입니다. 만약</target>
        </trans-unit>
        <trans-unit id="77eafd03fdb7f9d16237f45a4ce317d87b94c553" translate="yes" xml:space="preserve">
          <source>, if non-null, provides a string (in SV form) containing code to be parsed. A copy of the string is made, so subsequent modification of</source>
          <target state="translated">null이 아닌 경우 구문 분석 할 코드가 포함 된 문자열 (SV 형식)을 제공합니다. 문자열의 사본이 만들어 지므로 이후의 수정</target>
        </trans-unit>
        <trans-unit id="030106d2304ec93f9cf5e7c3317d1e0cb410b3da" translate="yes" xml:space="preserve">
          <source>, if non-null, provides an input stream from which code will be read to be parsed. If both are non-null, the code in</source>
          <target state="translated">null이 아닌 경우, 구문 분석을 위해 코드를 읽을 입력 스트림을 제공합니다. 둘 다 null이 아닌 경우 코드</target>
        </trans-unit>
        <trans-unit id="6cbeb9fe895f728ef42c186aa976bba1c9ce0104" translate="yes" xml:space="preserve">
          <source>, if you're running setgid.</source>
          <target state="translated">setgid를 실행중인 경우</target>
        </trans-unit>
        <trans-unit id="0dbb5d893ddb3b24557057bead5ebb8bfe161473" translate="yes" xml:space="preserve">
          <source>, if you're running setuid.</source>
          <target state="translated">setuid를 실행중인 경우</target>
        </trans-unit>
        <trans-unit id="359ce93de57e677d41e4feae3db26ccadd5f4602" translate="yes" xml:space="preserve">
          <source>, in that order, unless the environment variable</source>
          <target state="translated">환경 변수가 아닌 한 순서대로</target>
        </trans-unit>
        <trans-unit id="790ae18f398610e33985ad234301f212b618f615" translate="yes" xml:space="preserve">
          <source>, in that order.</source>
          <target state="translated">, 그와 같은 순서로.</target>
        </trans-unit>
        <trans-unit id="a9ca71fd641028e60feb39e0200097fbb26b663e" translate="yes" xml:space="preserve">
          <source>, in the mode value it returns, if you need an approximation of the file's protections.</source>
          <target state="translated">파일 보호의 근사값이 필요한 경우 모드 값에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4a46a8b425bb0176ffac49f9bb0407a8c91faaf3" translate="yes" xml:space="preserve">
          <source>, in which case it does a &lt;a href=&quot;http://man.he.net/man2/sendto&quot;&gt;sendto(2)&lt;/a&gt; syscall. Returns the number of characters sent, or the undefined value on error. The &lt;a href=&quot;http://man.he.net/man2/sendmsg&quot;&gt;sendmsg(2)&lt;/a&gt; syscall is currently unimplemented. See &lt;a href=&quot;perlipc#UDP%3A-Message-Passing&quot;&gt;&quot;UDP: Message Passing&quot; in perlipc&lt;/a&gt; for examples.</source>
          <target state="translated">,이 경우 &lt;a href=&quot;http://man.he.net/man2/sendto&quot;&gt;sendto (2)&lt;/a&gt; syscall을 수행합니다. 전송 된 문자 수 또는 오류시 정의되지 않은 값을 반환합니다. &lt;a href=&quot;http://man.he.net/man2/sendmsg&quot;&gt;sendmsg (2)&lt;/a&gt; 시스템 콜은 현재 구현되지 않습니다. 예제 &lt;a href=&quot;perlipc#UDP%3A-Message-Passing&quot;&gt;는 perlipc의 &quot;UDP : 메시지 전달&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba423002f3a8458818555c6df33df9999f3fd327" translate="yes" xml:space="preserve">
          <source>, in which case it does a sendto(2) syscall. Returns the number of characters sent, or the undefined value on error. The sendmsg(2) syscall is currently unimplemented. See &lt;a href=&quot;../perlipc#UDP%3a-Message-Passing&quot;&gt;UDP: Message Passing in perlipc&lt;/a&gt; for examples.</source>
          <target state="translated">이 경우 sendto (2) syscall을 수행합니다. 전송 된 문자 수 또는 오류시 정의되지 않은 값을 반환합니다. sendmsg (2) syscall은 현재 구현되어 있지 않습니다. 예를 보려면 &lt;a href=&quot;../perlipc#UDP%3a-Message-Passing&quot;&gt;UDP : perlipc에서 메시지 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adc9b471306d3e563016072b65846bf606376045" translate="yes" xml:space="preserve">
          <source>, in which case it does a sendto(2) syscall. Returns the number of characters sent, or the undefined value on error. The sendmsg(2) syscall is currently unimplemented. See &lt;a href=&quot;perlipc#UDP%3a-Message-Passing&quot;&gt;UDP: Message Passing in perlipc&lt;/a&gt; for examples.</source>
          <target state="translated">이 경우 sendto (2) syscall을 수행합니다. 전송 된 문자 수 또는 오류시 정의되지 않은 값을 반환합니다. sendmsg (2) syscall은 현재 구현되어 있지 않습니다. 예를 보려면 &lt;a href=&quot;perlipc#UDP%3a-Message-Passing&quot;&gt;UDP : perlipc에서 메시지 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8770c2665fa7656dfe5c162a8df3a289203cc335" translate="yes" xml:space="preserve">
          <source>, included in the source distribution. Here's a bastardized, non-portable version of</source>
          <target state="translated">소스 배포에 포함됩니다. 다음은 개자식이며 휴대 할 수없는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="eb5f00bc57f8a74444c521b49f19146de255153e" translate="yes" xml:space="preserve">
          <source>, included with Perl 3.0. It was converted as a module with Perl 5.0, but had a version number only starting with Perl 5.6. Here is a small table with the matching Perl and &lt;code&gt;Sys::Syslog&lt;/code&gt; versions.</source>
          <target state="translated">Perl 3.0에 포함되어 있습니다. Perl 5.0이 포함 된 모듈로 변환되었지만 Perl 5.6으로 시작하는 버전 번호 만있었습니다. 다음은 Perl 및 &lt;code&gt;Sys::Syslog&lt;/code&gt; 버전 이 일치하는 작은 테이블입니다 .</target>
        </trans-unit>
        <trans-unit id="8ea24d1d602be3c931482d6a832964fc845b16f4" translate="yes" xml:space="preserve">
          <source>, instructs &lt;code&gt;autosplit&lt;/code&gt; to check the module currently being split to ensure that it includes a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; specification for the AutoLoader module, and skips the module if AutoLoader is not detected. $check defaults to 1.</source>
          <target state="translated">, instructs &lt;code&gt;autosplit&lt;/code&gt; to check the module currently being split to ensure that it includes a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; specification for the AutoLoader module, and skips the module if AutoLoader is not detected. $check defaults to 1.</target>
        </trans-unit>
        <trans-unit id="968584f650e6dedd255b15fa43ea5c603f1d972b" translate="yes" xml:space="preserve">
          <source>, instructs &lt;code&gt;autosplit&lt;/code&gt; to check the module currently being split to ensure that it includes a &lt;code&gt;use&lt;/code&gt; specification for the AutoLoader module, and skips the module if AutoLoader is not detected. $check defaults to 1.</source>
          <target state="translated">, &lt;code&gt;autosplit&lt;/code&gt; 은 현재 분할중인 모듈에 AutoLoader 모듈에 대한 &lt;code&gt;use&lt;/code&gt; 사양 이 포함되어 있는지 확인하도록 지시 하고 AutoLoader가 감지되지 않으면 모듈을 건너 뜁니다. $ check 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f3d83a3f144336c31c776a79a37fb93513e38ad4" translate="yes" xml:space="preserve">
          <source>, intended for debugging or generating backtraces, and should not be relied upon. In particular, as &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; contains aliases to the caller's arguments, Perl does not take a copy of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, so &lt;code&gt;@DB::args&lt;/code&gt; will contain modifications the subroutine makes to &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; or its contents, not the original values at call time. &lt;code&gt;@DB::args&lt;/code&gt;, like &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, does not hold explicit references to its elements, so under certain cases its elements may have become freed and reallocated for other variables or temporary values. Finally, a side effect of the current implementation is that the effects of &lt;code&gt;shift @_&lt;/code&gt; can</source>
          <target state="translated">, 디버깅 또는 역 추적 생성 용이며 신뢰할 수 없습니다. 로 특히, &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; 가&lt;/a&gt; 호출자의 주장에 별칭을 포함, 펄의 사본을지지 않습니다 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 있도록 &lt;code&gt;@DB::args&lt;/code&gt; 서브 루틴가 있습니다 수정이 포함됩니다 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 통화 시간이나 내용이 아니라 원래 값을. &lt;code&gt;@DB::args&lt;/code&gt; 는 &lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt; 와 같이 해당 요소에 대한 명시 적 참조를 보유하지 않으므로 특정 경우 요소가 다른 변수 또는 임시 값에 대해 해제되고 재 할당 될 수 있습니다. 마지막으로 현재 구현의 부작용은 &lt;code&gt;shift @_&lt;/code&gt; 의 효과 가</target>
        </trans-unit>
        <trans-unit id="e6083d57ec1ee8a0d3d6d5459b1cec9032efce60" translate="yes" xml:space="preserve">
          <source>, intended for debugging or generating backtraces, and should not be relied upon. In particular, as &lt;code&gt;@_&lt;/code&gt; contains aliases to the caller's arguments, Perl does not take a copy of &lt;code&gt;@_&lt;/code&gt; , so &lt;code&gt;@DB::args&lt;/code&gt; will contain modifications the subroutine makes to &lt;code&gt;@_&lt;/code&gt; or its contents, not the original values at call time. &lt;code&gt;@DB::args&lt;/code&gt; , like &lt;code&gt;@_&lt;/code&gt; , does not hold explicit references to its elements, so under certain cases its elements may have become freed and reallocated for other variables or temporary values. Finally, a side effect of the current implementation is that the effects of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; can</source>
          <target state="translated">, 백 트레이스 디버깅 또는 생성을위한 것으로, 의존해서는 안됩니다. 로 특히, &lt;code&gt;@_&lt;/code&gt; 가 호출자의 주장에 별칭을 포함, 펄의 사본을지지 않습니다 &lt;code&gt;@_&lt;/code&gt; 있도록 &lt;code&gt;@DB::args&lt;/code&gt; 서브 루틴가 있습니다 수정이 포함됩니다 &lt;code&gt;@_&lt;/code&gt; 통화 시간이나 내용이 아니라 원래 값을. &lt;code&gt;@_&lt;/code&gt; 와 같이 &lt;code&gt;@DB::args&lt;/code&gt; 는 해당 요소에 대한 명시 적 참조를 보유하지 않으므로 특정 경우 해당 요소가 다른 변수 또는 임시 값에 대해 해제되고 재 할당 될 수 있습니다. 마지막으로, 현재 구현의 부작용의 효과 인 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; @_ CAN</target>
        </trans-unit>
        <trans-unit id="d6fb9ba10623dfd1aded621d9ddedd7e1c61500b" translate="yes" xml:space="preserve">
          <source>, intended for debugging or generating backtraces, and should not be relied upon. In particular, as &lt;code&gt;@_&lt;/code&gt; contains aliases to the caller's arguments, Perl does not take a copy of &lt;code&gt;@_&lt;/code&gt; , so &lt;code&gt;@DB::args&lt;/code&gt; will contain modifications the subroutine makes to &lt;code&gt;@_&lt;/code&gt; or its contents, not the original values at call time. &lt;code&gt;@DB::args&lt;/code&gt; , like &lt;code&gt;@_&lt;/code&gt; , does not hold explicit references to its elements, so under certain cases its elements may have become freed and reallocated for other variables or temporary values. Finally, a side effect of the current implementation is that the effects of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; can</source>
          <target state="translated">, 백 트레이스 디버깅 또는 생성을위한 것으로, 의존해서는 안됩니다. 로 특히, &lt;code&gt;@_&lt;/code&gt; 가 호출자의 주장에 별칭을 포함, 펄의 사본을지지 않습니다 &lt;code&gt;@_&lt;/code&gt; 있도록 &lt;code&gt;@DB::args&lt;/code&gt; 서브 루틴가 있습니다 수정이 포함됩니다 &lt;code&gt;@_&lt;/code&gt; 통화 시간이나 내용이 아니라 원래 값을. &lt;code&gt;@_&lt;/code&gt; 와 같이 &lt;code&gt;@DB::args&lt;/code&gt; 는 해당 요소에 대한 명시 적 참조를 보유하지 않으므로 특정 경우 해당 요소가 다른 변수 또는 임시 값에 대해 해제되고 재 할당 될 수 있습니다. 마지막으로, 현재 구현의 부작용의 효과 인 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt; @_&lt;/code&gt; @_ CAN</target>
        </trans-unit>
        <trans-unit id="13eb87bdfb3a3624e2f9e8a8d87bc78f8db7280d" translate="yes" xml:space="preserve">
          <source>, into Perl's internal form. As with encode(),</source>
          <target state="translated">펄의 내부 형식으로. encode ()와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cfa0115c245a8b3ea3252178af8759b7405c3a1b" translate="yes" xml:space="preserve">
          <source>, is copied under</source>
          <target state="translated">아래에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6135a1a196ba8c00d8ec8b4a64ca9d1706801d" translate="yes" xml:space="preserve">
          <source>, is false, then any pre-existing &lt;code&gt;*.al&lt;/code&gt; files in the autoload directory are removed if they are no longer part of the module (obsoleted functions). $keep defaults to 0.</source>
          <target state="translated">, false이면 기존 &lt;code&gt;*.al&lt;/code&gt; 경우 autoload 디렉토리에있는 파일이 더 이상 모듈의 일부가 아닌 경우 제거됩니다 (폐기 된 기능). $ keep의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="51eed46bc6e5b10c08d79ee20d1f1a587cafafba" translate="yes" xml:space="preserve">
          <source>, is similar to</source>
          <target state="translated">, 비슷하다</target>
        </trans-unit>
        <trans-unit id="79817a35af4a945dfd5b54b07a8db380c4bf6155" translate="yes" xml:space="preserve">
          <source>, is the op type. It's an addition operator, so we want the type to be &lt;code&gt;ADDOP&lt;/code&gt; . We could specify this directly, but it's right there as the second token in the input, so we use &lt;code&gt;$2&lt;/code&gt; . The second parameter is the op's flags: 0 means &quot;nothing special&quot;. Then the things to add: the left and right hand side of our expression, in scalar context.</source>
          <target state="translated">, op 유형입니다. 덧셈 연산자이므로 타입이 &lt;code&gt;ADDOP&lt;/code&gt; 가되기를 원합니다 . 이것을 직접 지정할 수는 있지만 입력의 두 번째 토큰으로 바로 &lt;code&gt;$2&lt;/code&gt; 합니다. 두 번째 매개 변수는 op의 플래그입니다. 0은 &quot;특별 함 없음&quot;을 의미합니다. 그런 다음 추가 할 사항은 스칼라 컨텍스트에서 표현의 왼쪽과 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="0d4e379c51b0a4ee2a90ac03f59a5e363e730701" translate="yes" xml:space="preserve">
          <source>, is the op type. It's an addition operator, so we want the type to be &lt;code&gt;ADDOP&lt;/code&gt;. We could specify this directly, but it's right there as the second token in the input, so we use &lt;code&gt;$2&lt;/code&gt;. The second parameter is the op's flags: 0 means &quot;nothing special&quot;. Then the things to add: the left and right hand side of our expression, in scalar context.</source>
          <target state="translated">는 op 유형입니다. 더하기 연산자이므로 유형이 &lt;code&gt;ADDOP&lt;/code&gt; 이길 원합니다 . 이것을 직접 지정할 수 있지만 입력의 두 번째 토큰으로 바로 거기에 있으므로 &lt;code&gt;$2&lt;/code&gt; 사용 합니다. 두 번째 매개 변수는 op의 플래그입니다. 0은 &quot;특별한 것이 없음&quot;을 의미합니다. 다음으로 추가 할 것 : 스칼라 컨텍스트에서 표현식의 왼쪽과 오른쪽.</target>
        </trans-unit>
        <trans-unit id="c0080e719ea6b38d68de4ba8b7693bc8dba72e5a" translate="yes" xml:space="preserve">
          <source>, it doesn't redirect stderr to stdout.</source>
          <target state="translated">stderr을 stdout으로 리디렉션하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="664f4ea1afd52b971da3d2f089f2511da29b2351" translate="yes" xml:space="preserve">
          <source>, it is enough to have them on your path. One does not need to specify them explicitly (though this</source>
          <target state="translated">당신의 길에 그것들을 갖기에 충분합니다. 명시 적으로 지정할 필요는 없습니다 (이것에도 불구하고)</target>
        </trans-unit>
        <trans-unit id="01bd8dd935a29b3fddd9c06ac4b13a42b2abe139" translate="yes" xml:space="preserve">
          <source>, it is not necessarily the case that any output will be produced by this method. So don't rely on the fact that &lt;code&gt;$out&lt;/code&gt; is empty for an error test.</source>
          <target state="translated">반드시이 방법으로 출력이 생성되는 것은 아닙니다. 따라서 &lt;code&gt;$out&lt;/code&gt; 사실에 의존하지 마십시오 오류 테스트를 위해 이 비어 .</target>
        </trans-unit>
        <trans-unit id="9b3b34697471a7e2dc56c68064b05288c536a237" translate="yes" xml:space="preserve">
          <source>, it is still good practice to check the return code from</source>
          <target state="translated">, 여전히 리턴 코드를 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d91455e8d254597cb96fe4e096fe840d6a39837b" translate="yes" xml:space="preserve">
          <source>, it is substituted with</source>
          <target state="translated">으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="651848b5afecc31a5c38cd73df7324f50c74618a" translate="yes" xml:space="preserve">
          <source>, it passes &lt;code&gt;&lt;a href=&quot;perlapi#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot; in perlapi&lt;/a&gt;&lt;/code&gt;. Surrogates, non-character code points, and non-Unicode code points are allowed.</source>
          <target state="translated">, &lt;code&gt;&lt;a href=&quot;perlapi#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot; in perlapi&lt;/a&gt;&lt;/code&gt; 합니다. 서로 게이트, 비 문자 코드 포인트 및 비 유니 코드 코드 포인트가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bef723cdeef4c4aad0269573935dc64dcabf73" translate="yes" xml:space="preserve">
          <source>, just type:</source>
          <target state="translated">을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="ec7445398596752b90e13adb72725edcb5f55fb9" translate="yes" xml:space="preserve">
          <source>, left justified to fill</source>
          <target state="translated">, 채울 왼쪽 정렬</target>
        </trans-unit>
        <trans-unit id="58977f34d6981ce10f380c393153c619fec7c3b0" translate="yes" xml:space="preserve">
          <source>, library stuff in</source>
          <target state="translated">도서관 자료</target>
        </trans-unit>
        <trans-unit id="ba5ebce04882b3b845e0e11a0351a954b9d067f9" translate="yes" xml:space="preserve">
          <source>, lowest-to-highest.</source>
          <target state="translated">, 최저에서 최고로.</target>
        </trans-unit>
        <trans-unit id="481f764300170b8cc2c8ab1fea2d90f4659012a0" translate="yes" xml:space="preserve">
          <source>, man pages in</source>
          <target state="translated">, 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="c1eff063fa64539df3525a8920a33c120431c1d5" translate="yes" xml:space="preserve">
          <source>, man pages into</source>
          <target state="translated">, 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="8377baa929d3123ee7913b5c12c57a279c130a4b" translate="yes" xml:space="preserve">
          <source>, may crash the phone, causing it to turn itself off once, and then back on again.</source>
          <target state="translated">, 전화가 충돌하여 한 번 꺼졌다가 다시 켜질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a7745ab1fa8731e058fe3471019aec70206d842" translate="yes" xml:space="preserve">
          <source>, meaning it exposes several</source>
          <target state="translated">, 그것은 여러 노출을 의미</target>
        </trans-unit>
        <trans-unit id="23ecae591165a2e14c8b3c0c33e4b172cfbcd078" translate="yes" xml:space="preserve">
          <source>, meaning that functions and subroutines altered with &lt;code&gt;autodie&lt;/code&gt; will only change their behaviour until the end of the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;autodie&lt;/code&gt; 로 변경된 기능 및 서브 루틴 은 둘러싸는 블록, 파일 또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 이 끝날 때까지만 동작을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="eddeb78a7e3264256b6a8045f7a56faf717a121d" translate="yes" xml:space="preserve">
          <source>, meaning that functions and subroutines altered with &lt;code&gt;autodie&lt;/code&gt; will only change their behaviour until the end of the enclosing block, file, or &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;autodie&lt;/code&gt; 로 변경된 함수 및 서브 루틴 은 둘러싸는 블록, 파일 또는 &lt;code&gt;eval&lt;/code&gt; 이 끝날 때까지만 동작을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="93ecb4223ec353ce10e70829975cf221b865ce31" translate="yes" xml:space="preserve">
          <source>, namely</source>
          <target state="translated">즉</target>
        </trans-unit>
        <trans-unit id="59fec1966dbdc2d3f0c4d7aede4a65102f1621b8" translate="yes" xml:space="preserve">
          <source>, nor does it allow executables in the sdcard, we need to find somewhere in the device for Configure to put some files in, as well as for the tests to run in. If your device is rooted, then you're good. Try running these:</source>
          <target state="translated">, sdcard의 실행 파일을 허용하지도 않습니다. Configure에서 일부 파일을 넣을 수있는 장치와 테스트를 실행할 수있는 곳을 찾아야합니다. 장치가 루팅 된 경우 괜찮습니다. 다음을 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="f22a8444b47d43b843adb69f4a032eaa8696f19f" translate="yes" xml:space="preserve">
          <source>, normally via</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="48a0cd2493fd04c9f828dcacdd2caee749e13027" translate="yes" xml:space="preserve">
          <source>, not</source>
          <target state="translated">아니</target>
        </trans-unit>
        <trans-unit id="c7bd8970e5dd3c5d725e534ee2e953570f617caa" translate="yes" xml:space="preserve">
          <source>, not byte.)</source>
          <target state="translated">바이트가 아닌)</target>
        </trans-unit>
        <trans-unit id="11afc5e199c01f78460727b395aceca036378181" translate="yes" xml:space="preserve">
          <source>, not its line. So in the examples below, you can see that every command needs the blank line after it, to end its paragraph. (And some older Pod translators may require the &lt;code&gt;=encoding&lt;/code&gt; line to have a following blank line as well, even though it should be legal to omit.)</source>
          <target state="translated">그 줄이 아닙니다. 따라서 아래 예에서 단락을 끝내려면 모든 명령 뒤에 빈 줄이 필요하다는 것을 알 수 있습니다. (그리고 일부 구형 포드 번역가는 &lt;code&gt;=encoding&lt;/code&gt; 생략해야하는 경우에도 행에 다음 빈 줄이 있어야 할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="77cbf0d5e9d48924c33742650619cd201e79e361" translate="yes" xml:space="preserve">
          <source>, not programs. For programs, use the &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt; API.</source>
          <target state="translated">, 프로그램이 아닙니다. 프로그램의 경우 &lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList&lt;/a&gt; API를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="da92391795f61ed6c37622d31636bf92df08886e" translate="yes" xml:space="preserve">
          <source>, not programs. For programs, use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; API.</source>
          <target state="translated">프로그램이 아닙니다. 프로그램의 경우 &lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt; API를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43dff97702ab1cbd05f2458bbf9136c2e78c118d" translate="yes" xml:space="preserve">
          <source>, of which</source>
          <target state="translated">그 중</target>
        </trans-unit>
        <trans-unit id="731aa264d48130cd3456e01ac07965045097c74f" translate="yes" xml:space="preserve">
          <source>, one pair per line. Strings used as values must be quoted. Barewords are treated as numbers.</source>
          <target state="translated">, 한 줄에 한 쌍. 값으로 사용 된 문자열은 인용해야합니다. 베어 워드는 숫자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="ba34082476e7f40b29ef9dab02566944508fe137" translate="yes" xml:space="preserve">
          <source>, one should call these API via a dynamic linking API. There is a subsystem in Perl to simplify such type of calls. A large number of entry points available for such linking is provided (see &lt;code&gt;entries_ordinals&lt;/code&gt; - and also &lt;code&gt;PMWIN_entries&lt;/code&gt; - in</source>
          <target state="translated">동적 연결 API를 통해 이러한 API를 호출해야합니다. 이러한 유형의 호출을 단순화하기 위해 Perl에 서브 시스템이 있습니다. 이러한 연결에 사용할 진입 점 많은 수의 (참조 제공 &lt;code&gt;entries_ordinals&lt;/code&gt; 도 - &lt;code&gt;PMWIN_entries&lt;/code&gt; 을 -에</target>
        </trans-unit>
        <trans-unit id="b366d1a229ec84d93ba42e7ecafb33db5b7b9b39" translate="yes" xml:space="preserve">
          <source>, or</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="942f527c84fd76c3bdcee70a53190e472c342844" translate="yes" xml:space="preserve">
          <source>, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">또는 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0d8ec5c736f2db07e822b274ee99f50708b0284" translate="yes" xml:space="preserve">
          <source>, or &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="translated">, 또는 &lt;code&gt;eval&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba229fbb681a07aa0e4294378d9012aef942cf" translate="yes" xml:space="preserve">
          <source>, or Perl, such as the following:</source>
          <target state="translated">또는 Perl (예 : 다음) :</target>
        </trans-unit>
        <trans-unit id="55bfcc1de58da3cf74a6ff01324919bf5c853ff5" translate="yes" xml:space="preserve">
          <source>, or code, the &lt;code&gt;Rr&lt;/code&gt; are</source>
          <target state="translated">또는 코드, &lt;code&gt;Rr&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="ffbadeb5936aabdc02bac70dff1ebf6c39606cc2" translate="yes" xml:space="preserve">
          <source>, or editing</source>
          <target state="translated">또는 수정</target>
        </trans-unit>
        <trans-unit id="54a2f6c3e0bbeef4006390919d7b396d9e2b4da3" translate="yes" xml:space="preserve">
          <source>, or even</source>
          <target state="translated">, 또는</target>
        </trans-unit>
        <trans-unit id="579214064014c46082b00e9396995d722bdba307" translate="yes" xml:space="preserve">
          <source>, or even something such as D:</source>
          <target state="translated">또는 D와 같은 것 :</target>
        </trans-unit>
        <trans-unit id="dd3dabc0fe007ede17230bb03b9e7e04c79af333" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, calls the</source>
          <target state="translated">콜백이없는 경우</target>
        </trans-unit>
        <trans-unit id="00c06bb9d1dbbcd4ab3b41b1fd0ea954aed36a82" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, set errno to EINVAL. Or if the f is invalid, set errno to EBADF and return</source>
          <target state="translated">콜백이 없거나 errno를 EINVAL로 설정하십시오. 또는 f가 유효하지 않은 경우, errno를 EBADF로 설정하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1db68edf4d518c843f678ca5c930a828630ad1ff" translate="yes" xml:space="preserve">
          <source>, or if there is no such callback, set errno to EINVAL. Or if the f is invalid, set errno to EBADF.</source>
          <target state="translated">콜백이 없거나 errno를 EINVAL로 설정하십시오. 또는 f가 유효하지 않으면 errno를 EBADF로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3748c8a3236d4aa94aa312fa69d106a59ad85b20" translate="yes" xml:space="preserve">
          <source>, or if they compare equal with &lt;code&gt;eq&lt;/code&gt; .</source>
          <target state="translated">또는 &lt;code&gt;eq&lt;/code&gt; 와 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="e15eaa1b8fa5c1f2a044cb1df03bafea1f454eca" translate="yes" xml:space="preserve">
          <source>, or if they compare equal with &lt;code&gt;eq&lt;/code&gt;.</source>
          <target state="translated">, 또는 &lt;code&gt;eq&lt;/code&gt; 과 동등하게 비교되는 경우 .</target>
        </trans-unit>
        <trans-unit id="5b8290ca58e4b337d2e457234b98a169d325bc21" translate="yes" xml:space="preserve">
          <source>, or printing using</source>
          <target state="translated">또는 다음을 사용하여 인쇄</target>
        </trans-unit>
        <trans-unit id="b97bcf82807eb070d0f663f018d630dbd84dfcb4" translate="yes" xml:space="preserve">
          <source>, or supply the stack size to &lt;code&gt;CreateThread()&lt;/code&gt;</source>
          <target state="translated">또는 스택 크기를 &lt;code&gt;CreateThread()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="345ba69cc2fea67ce22656b09e83f149b6b96534" translate="yes" xml:space="preserve">
          <source>, or the</source>
          <target state="translated">, 아니면 그</target>
        </trans-unit>
        <trans-unit id="9a264e54b25fdd7cfde7bd05762f5bc9a49c0c3a" translate="yes" xml:space="preserve">
          <source>, or the pattern contained by capture group</source>
          <target state="translated">또는 캡처 그룹에 포함 된 패턴</target>
        </trans-unit>
        <trans-unit id="62689d1cb8a9641695ea27a2f748331b9e8bf893" translate="yes" xml:space="preserve">
          <source>, or the type and version must be omitted.</source>
          <target state="translated">또는 유형 및 버전을 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb2724928018abae8bc9e57d76c637373cc20ea5" translate="yes" xml:space="preserve">
          <source>, or to restore &lt;code&gt;$!&lt;/code&gt; to a meaningful state.</source>
          <target state="translated">또는 &lt;code&gt;$!&lt;/code&gt; 를 복원하십시오 ! 의미있는 상태로.</target>
        </trans-unit>
        <trans-unit id="e7d923ba957c225be8a72ed7a758380976e4b860" translate="yes" xml:space="preserve">
          <source>, or using a separate</source>
          <target state="translated">또는 별도의 사용</target>
        </trans-unit>
        <trans-unit id="9d0d91ae0fa92bac5f7cd8243e072cd7aef018d9" translate="yes" xml:space="preserve">
          <source>, or you could change certain filenames as needed:</source>
          <target state="translated">필요에 따라 특정 파일 이름을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9173cbefc36581419831ce91b8068d884c10958" translate="yes" xml:space="preserve">
          <source>, otherwise nothing.</source>
          <target state="translated">그렇지 않으면 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7f26ed799fd2c4c11b462f3e47d17d2a8c2c4ca" translate="yes" xml:space="preserve">
          <source>, overwriting the file with the new contents. With the &lt;code&gt;-p&lt;/code&gt; switch, Perl wraps a &lt;code&gt;while&lt;/code&gt; loop around the code you specify with &lt;code&gt;-e&lt;/code&gt; , and &lt;code&gt;-i&lt;/code&gt; turns on in-place editing. The current line is in &lt;code&gt;$_&lt;/code&gt; . With &lt;code&gt;-p&lt;/code&gt; , Perl automatically prints the value of &lt;code&gt;$_&lt;/code&gt; at the end of the loop. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more details.</source>
          <target state="translated">파일을 새 내용으로 덮어 씁니다. &lt;code&gt;-p&lt;/code&gt; 스위치를 사용하면 Perl 은 &lt;code&gt;-e&lt;/code&gt; 로 지정한 코드 주위에 &lt;code&gt;while&lt;/code&gt; 루프를 래핑 하고 &lt;code&gt;-i&lt;/code&gt; 는 전체 편집을 켭니다. 현재 줄은 &lt;code&gt;$_&lt;/code&gt; 입니다. &lt;code&gt;-p&lt;/code&gt; 를 사용하면 Perl 은 루프의 끝에서 &lt;code&gt;$_&lt;/code&gt; 값을 자동으로 인쇄합니다 . &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2beb40374d1ba6b830b11c24eadb2a2464d618a5" translate="yes" xml:space="preserve">
          <source>, overwriting the file with the new contents. With the &lt;code&gt;-p&lt;/code&gt; switch, Perl wraps a &lt;code&gt;while&lt;/code&gt; loop around the code you specify with &lt;code&gt;-e&lt;/code&gt;, and &lt;code&gt;-i&lt;/code&gt; turns on in-place editing. The current line is in &lt;code&gt;$_&lt;/code&gt;. With &lt;code&gt;-p&lt;/code&gt;, Perl automatically prints the value of &lt;code&gt;$_&lt;/code&gt; at the end of the loop. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more details.</source>
          <target state="translated">, 파일을 새 내용으로 덮어 씁니다. &lt;code&gt;-p&lt;/code&gt; 스위치를 사용하면 Perl 은 &lt;code&gt;-e&lt;/code&gt; 로 지정한 코드 주위에 &lt;code&gt;while&lt;/code&gt; 루프를 래핑 하고 &lt;code&gt;-i&lt;/code&gt; 는 내부 편집을 켭니다. 현재 줄은 &lt;code&gt;$_&lt;/code&gt; 있습니다. &lt;code&gt;-p&lt;/code&gt; 를 사용하면 Perl 은 루프 끝에 &lt;code&gt;$_&lt;/code&gt; 값을 자동으로 인쇄합니다 . 자세한 내용은 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f8d0c96d2d2b2aafa291574fbf6087350a9988db" translate="yes" xml:space="preserve">
          <source>, performing the correct bookkeeping whenever a newline character is passed. This is the normal way to consume lexed text.</source>
          <target state="translated">개행 문자가 전달 될 때마다 올바른 부기를 수행합니다. 이것은 어휘 텍스트를 소비하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="75a085778831d29e999e10d1d80353eeb630cc4b" translate="yes" xml:space="preserve">
          <source>, period.)</source>
          <target state="translated">, 마침표.)</target>
        </trans-unit>
        <trans-unit id="70ef65c7d96d2bd885c5b7612ef8e3946ac09c5f" translate="yes" xml:space="preserve">
          <source>, period.) If the &lt;code&gt;/s&lt;/code&gt; modifier is specified, sequences of characters that were transliterated to the same character are squashed down to a single instance of the character.</source>
          <target state="translated">기간.)이 경우 &lt;code&gt;/s&lt;/code&gt; 수정이 지정된 동일한 문자 음역 된 문자 시퀀스가 문자의 단일 인스턴스로 내려 눌려있다.</target>
        </trans-unit>
        <trans-unit id="60007a5d7f11a8090fc943b98a4327b72a97056b" translate="yes" xml:space="preserve">
          <source>, pointing up from the &lt;b&gt;theta&lt;/b&gt;-plane.</source>
          <target state="translated">&lt;b&gt;세타&lt;/b&gt; 에서 가리키는&lt;b&gt;&lt;/b&gt; 평면 .</target>
        </trans-unit>
        <trans-unit id="c4604eaf3d1d886deab27e44f9f084a7eebe60a8" translate="yes" xml:space="preserve">
          <source>, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to C</source>
          <target state="translated">아마도 자동 플러시를 사용할 때에도 캐싱 문제로 인해 (일반적으로 C를 시도하기 전에 임시 파일에 쓴 후 잠시 기다려서 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f167a172a1e8be32df955ad41d6bc58487f037" translate="yes" xml:space="preserve">
          <source>, provides access to the following elements of the Perl API that are not otherwise available in Perl releases older than when the elements were first introduced. (Note that many of these are not supported all the way back to 5.003_07, but it may be that they are supported back as far as you need; see &lt;a href=&quot;#Supported-Perl-API%2C-sorted-by-version&quot;&gt;&quot;Supported Perl API, sorted by version&quot;&lt;/a&gt; for that information.)</source>
          <target state="translated">에서는 요소가 처음 도입되었을 때보 다 이전 버전의 Perl에서 사용할 수없는 Perl API의 다음 요소에 대한 액세스를 제공합니다. (이 중 대부분은 5.003_07까지 지원되지는 않지만 필요한만큼 다시 지원 될 수 있습니다. 해당 정보는 &lt;a href=&quot;#Supported-Perl-API%2C-sorted-by-version&quot;&gt;&quot;지원되는 Perl API, 버전별로 정렬&quot;&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="700f9b2825afd309ca4619c11e0d2d9e2e77290a" translate="yes" xml:space="preserve">
          <source>, provides access to the following elements of the Perl API that is not available in older Perl releases:</source>
          <target state="translated">, 이전 Perl 릴리스에서 사용할 수없는 다음 Perl API 요소에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65e4734d8fbb856132be8332b98473e9a6090b22" translate="yes" xml:space="preserve">
          <source>, rather than something that it</source>
          <target state="translated">, 뭔가가 아니라</target>
        </trans-unit>
        <trans-unit id="f4e7af1322b9da55c415c39f9e7ff17666928572" translate="yes" xml:space="preserve">
          <source>, regardless of where STDOUT may be redirected to.</source>
          <target state="translated">STDOUT을 리디렉션 할 수있는 위치에 관계없이</target>
        </trans-unit>
        <trans-unit id="778526e92b1eabba1ba99018f377d78629f31fa4" translate="yes" xml:space="preserve">
          <source>, respectively. &lt;code&gt;Re&lt;/code&gt; , &lt;code&gt;Im&lt;/code&gt; , &lt;code&gt;arg&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;rho&lt;/code&gt; , and &lt;code&gt;theta&lt;/code&gt; can be used also as mutators. The &lt;code&gt;cbrt&lt;/code&gt; returns only one of the solutions: if you want all three, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="translated">각각. &lt;code&gt;Re&lt;/code&gt; , &lt;code&gt;Im&lt;/code&gt; , &lt;code&gt;arg&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;rho&lt;/code&gt; 및 &lt;code&gt;theta&lt;/code&gt; 는 뮤 테이터로도 사용할 수 있습니다. &lt;code&gt;cbrt&lt;/code&gt; 반환 솔루션의 하나 : 당신이 세 가지를 모두 원하는 경우 사용 &lt;code&gt;root&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="1432aa0361b53e3a3db3eff5fece905dc02f63c0" translate="yes" xml:space="preserve">
          <source>, respectively. &lt;code&gt;Re&lt;/code&gt;, &lt;code&gt;Im&lt;/code&gt;, &lt;code&gt;arg&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;rho&lt;/code&gt;, and &lt;code&gt;theta&lt;/code&gt; can be used also as mutators. The &lt;code&gt;cbrt&lt;/code&gt; returns only one of the solutions: if you want all three, use the &lt;code&gt;root&lt;/code&gt; function.</source>
          <target state="translated">, 각각. &lt;code&gt;Re&lt;/code&gt; , &lt;code&gt;Im&lt;/code&gt; , &lt;code&gt;arg&lt;/code&gt; , &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;rho&lt;/code&gt; 및 &lt;code&gt;theta&lt;/code&gt; 는 mutator로도 사용할 수 있습니다. &lt;code&gt;cbrt&lt;/code&gt; 반환 솔루션의 하나 : 당신이 세 가지를 모두 원하는 경우 사용 &lt;code&gt;root&lt;/code&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="c7afdf070db2b17186b849dea9ccbae8490266d4" translate="yes" xml:space="preserve">
          <source>, returns false; otherwise returns true.</source>
          <target state="translated">, false를 반환합니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff419dfd1490efd2af497c9629d6cd9180c57c34" translate="yes" xml:space="preserve">
          <source>, right? But, the submitter's email address had changed since the last of their submissions, and this caused other tests to fail. Running the test target given in the next item would have caught this problem.</source>
          <target state="translated">, 권리? 그러나 제출자의 이메일 주소가 마지막 제출 이후 변경되어 다른 테스트가 실패했습니다. 다음 항목에 제공된 테스트 대상을 실행하면이 문제가 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="613c35a1e740b0c235d0f18f6677ec6eca7c3e11" translate="yes" xml:space="preserve">
          <source>, rounded towards zero. Division by zero generates an exception.</source>
          <target state="translated">, 0으로 반올림됩니다. 0으로 나누면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="294f1e85971ddf3faffa14fe9c113e1fb49247ca" translate="yes" xml:space="preserve">
          <source>, run</source>
          <target state="translated">, 운영</target>
        </trans-unit>
        <trans-unit id="405cbdde629a3d6806c42e7498957799c0c7e735" translate="yes" xml:space="preserve">
          <source>, run:</source>
          <target state="translated">, 운영:</target>
        </trans-unit>
        <trans-unit id="bbe01f117bad48eb679b7748a19ed0966f1fba4d" translate="yes" xml:space="preserve">
          <source>, same with</source>
          <target state="translated">, 와 같다</target>
        </trans-unit>
        <trans-unit id="f3e57458037c62794ca5968e5d5cd43577521d99" translate="yes" xml:space="preserve">
          <source>, say, by issuing a command like</source>
          <target state="translated">예를 들어 다음과 같은 명령을 실행하여</target>
        </trans-unit>
        <trans-unit id="5cc91dd4b05c40ee3836cd8a51b18923b0309266" translate="yes" xml:space="preserve">
          <source>, says which packages are</source>
          <target state="translated">어떤 패키지인지</target>
        </trans-unit>
        <trans-unit id="7bea033bd7bdaed455f219df3563798009d97e30" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot;&lt;/a&gt;.</source>
          <target state="translated">, &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;잘못된 형식의 데이터 처리&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b0061f7d598e9846a6cb4198408f6e62c1c966" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;잘못된 데이터 처리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5cf1b7b60bc751870d9bee94d589e7e13b098d6" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Making&quot;&gt;&quot;Making&quot;&lt;/a&gt;.</source>
          <target state="translated">, &lt;a href=&quot;#Making&quot;&gt;&quot;만들기&quot;&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="8d832948372c398a9280338201f9092bcd809e94" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#Making&quot;&gt;Making&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Making&quot;&gt;만들기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6de0215f7a739d4e3e3822c99e1d1856c89071b2" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot;&lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot; &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; &quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b3e32c9f4e25b163e62562a312fffb640ca872c" translate="yes" xml:space="preserve">
          <source>, see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee0c1ad5d5b448bff9df5b0bab0d2210c95e514e" translate="yes" xml:space="preserve">
          <source>, see below.</source>
          <target state="translated">아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4165c20cc560175b963da6bc4d77312447940a05" translate="yes" xml:space="preserve">
          <source>, setting &lt;code&gt;IS_NUMBER_TRAILING&lt;/code&gt; on the result.</source>
          <target state="translated">결과에 &lt;code&gt;IS_NUMBER_TRAILING&lt;/code&gt; 을 설정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2c6475f8f940fb92ea77b169a003790260386a" translate="yes" xml:space="preserve">
          <source>, shows how you can make use of</source>
          <target state="translated">를 활용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9c021cd1028629354df63a6c9de35015825f27c6" translate="yes" xml:space="preserve">
          <source>, since they work on similar inter-process communication principles as Unix pipelines. Such a filehandle has an active program instead of a static file on its external end, but in every other sense it works just like a more typical file-based filehandle, with all the techniques discussed earlier in this article just as applicable.</source>
          <target state="translated">, Unix 파이프 라인과 유사한 프로세스 간 통신 원칙에서 작동하기 때문입니다. 이러한 파일 핸들은 외부에 정적 파일 대신 활성 프로그램이 있지만 다른 모든 의미에서이 문서의 앞부분에서 설명한 모든 기술을 적용 할 수있는 일반적인 파일 기반 파일 핸들처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4dd3298c6d1bd33b1bddecc4419b76b21ac63113" translate="yes" xml:space="preserve">
          <source>, so G_DISCARD is specified. Even if</source>
          <target state="translated">이므로 G_DISCARD가 지정됩니다. 설사</target>
        </trans-unit>
        <trans-unit id="74317a6fb7a862910bba2f815752e8625fde38fb" translate="yes" xml:space="preserve">
          <source>, so here's some opportunity for some patching.</source>
          <target state="translated">패치가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="99d2a210f65f1b750acbf3003b2617a271c06034" translate="yes" xml:space="preserve">
          <source>, so that it does not create a link between a VIO session and the session of &lt;code&gt;pm_porg&lt;/code&gt; . (Such a link closes the VIO window.) E.g., this works with</source>
          <target state="translated">VIO 세션과 &lt;code&gt;pm_porg&lt;/code&gt; 세션간에 링크를 만들지 않습니다 . (이러한 링크는 VIO 창을 닫습니다.) 예를 들어</target>
        </trans-unit>
        <trans-unit id="b431b99c75fdc1f8394d149668a8cc3e91aa8961" translate="yes" xml:space="preserve">
          <source>, so that it does not create a link between a VIO session and the session of &lt;code&gt;pm_porg&lt;/code&gt;. (Such a link closes the VIO window.) E.g., this works with</source>
          <target state="translated">, 따라서 VIO 세션과 &lt;code&gt;pm_porg&lt;/code&gt; 세션 사이에 링크를 만들지 않습니다 . (이러한 링크는 VIO 창을 닫습니다.)</target>
        </trans-unit>
        <trans-unit id="8075e1a34058df98200120ef8d7277ea339786f0" translate="yes" xml:space="preserve">
          <source>, so the directories are searched through for linkable libraries again.</source>
          <target state="translated">디렉토리에서 링크 가능한 라이브러리를 다시 검색합니다.</target>
        </trans-unit>
        <trans-unit id="2a07866af21835710bc9a6f54723c0b9d52d41d7" translate="yes" xml:space="preserve">
          <source>, so there is no special &quot;test_harness&quot; target.</source>
          <target state="translated">따라서 특별한 &quot;test_harness&quot;대상이 없습니다.</target>
        </trans-unit>
        <trans-unit id="39d37d1b4683a3fb66c0c9cb4ab07337524f0bd5" translate="yes" xml:space="preserve">
          <source>, so we may ignore them. The following list shows our errors, your results may differ:</source>
          <target state="translated">따라서 무시해도됩니다. 다음 목록은 우리의 오류를 보여줍니다, 결과는 다를 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="04d17676d801558b107d5b7f04560aca2950977f" translate="yes" xml:space="preserve">
          <source>, so you also pay a price for each pattern that contains capturing parentheses. (To avoid this cost while retaining the grouping behaviour, use the extended regular expression &lt;code&gt;(?: ... )&lt;/code&gt; instead.) But if you never use &lt;code&gt;$&amp;amp;&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt;, then patterns</source>
          <target state="translated">, 캡처 괄호가 포함 된 각 패턴에 대한 가격도 지불합니다. (그룹화 동작을 유지하면서이 비용을 피하려면 대신 확장 정규식 &lt;code&gt;(?: ... )&lt;/code&gt; 사용하십시오.) 그러나 &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; 또는 &lt;code&gt;$'&lt;/code&gt; 사용하지 않는 경우 패턴</target>
        </trans-unit>
        <trans-unit id="cf90afd63e53252a0999bd1484eafacffe771fa0" translate="yes" xml:space="preserve">
          <source>, so you can't set sh with a &lt;code&gt;-D&lt;/code&gt; option, though you can override this (and startsh) with &lt;code&gt;-O -Dsh=&lt;i&gt;/bin/whatever&lt;/i&gt; -Dstartsh=whatever&lt;/code&gt;</source>
          <target state="translated">따라서 &lt;code&gt;-D&lt;/code&gt; 옵션으로 sh를 설정할 수는 없지만 &lt;code&gt;-O -Dsh=&lt;i&gt;/bin/whatever&lt;/i&gt; -Dstartsh=whatever&lt;/code&gt; &lt;i&gt;/ bin / whatever&lt;/i&gt; -Dstartsh = whatever 로이 (및 startsh)를 재정의 할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="f6d839faa6ea4a6b5e97b5d7bc7e2a56a2c58137" translate="yes" xml:space="preserve">
          <source>, so you might examine them if your console has only a limited number of cols.</source>
          <target state="translated">콘솔에 제한된 수의 직원 만있는 경우이를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2276c8b5c561790372b3ca4478529f74cf3b1e94" translate="yes" xml:space="preserve">
          <source>, some systems may have to replace the &lt;code&gt;#!&lt;/code&gt; line with a line containing just a colon, which will be politely ignored by Perl. Other systems can't control that, and need a totally devious construct that will work under any of</source>
          <target state="translated">, 일부 시스템은 &lt;code&gt;#!&lt;/code&gt; 를 교체해야 할 수도 있습니다 . 콜론 만 포함하는 줄이있는 줄은 Perl에 의해 정중하게 무시됩니다. 다른 시스템은 그것을 제어 할 수 없으며, 어떤 시스템에서도 작동하는 완전히 악의적 인 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a23e4409511836342736b9f02167e4000d6c659b" translate="yes" xml:space="preserve">
          <source>, sorcery, or wonder working. [From Middle English.]</source>
          <target state="translated">, 마술, 또는 궁금해하는 일. [중간 영어에서.]</target>
        </trans-unit>
        <trans-unit id="fd25e4b237d0de2bbe9c20b33a4bfd410153bc18" translate="yes" xml:space="preserve">
          <source>, specifically a listing of functions, macros, flags, and variables that may be used by extension writers. &lt;a href=&quot;#Undocumented-functions&quot;&gt;At the end&lt;/a&gt; is a list of functions which have yet to be documented. The interfaces of those are subject to change without notice. Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="translated">확장 기능 작성자가 사용할 수있는 함수, 매크로, 플래그 및 변수의 목록입니다. &lt;a href=&quot;#Undocumented-functions&quot;&gt;마지막&lt;/a&gt; 에는 아직 문서화되지 않은 기능 목록이 있습니다. 이들의 인터페이스는 예고없이 변경 될 수 있습니다. 여기에 나열되지 않은 것은 공개 API의 일부가 아니며 확장 작성자가 전혀 사용하지 않아야합니다. 이러한 이유로 확장 프로그램을 작성할 때는 proto.h에 나열된 기능을 맹목적으로 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bd6869e59a3a41f4025ac1776272a94fc706f68e" translate="yes" xml:space="preserve">
          <source>, specify where your tests are located with the &lt;code&gt;test&lt;/code&gt; directive:</source>
          <target state="translated">, &lt;code&gt;test&lt;/code&gt; 지시문을 사용하여 테스트 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3eace3842ea85c92144047677156c458ddf9586e" translate="yes" xml:space="preserve">
          <source>, standard input (</source>
          <target state="translated">표준 입력 (</target>
        </trans-unit>
        <trans-unit id="dacd7df5d67e86f62828aca14d84822ce104e1a0" translate="yes" xml:space="preserve">
          <source>, stripped of their leading &quot;pw_&quot; parts, namely &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; , &lt;code&gt;gid&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;quota&lt;/code&gt; , &lt;code&gt;comment&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;shell&lt;/code&gt; , and &lt;code&gt;expire&lt;/code&gt; . The &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , and &lt;code&gt;shell&lt;/code&gt; fields are tainted when running in taint mode.</source>
          <target state="translated">, &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; , &lt;code&gt;gid&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;quota&lt;/code&gt; , &lt;code&gt;comment&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;shell&lt;/code&gt; 및 &lt;code&gt;expire&lt;/code&gt; 와 같은 주요 &quot;pw_&quot;부분을 제거했습니다 . &lt;code&gt;passwd&lt;/code&gt; 를 , &lt;code&gt;gecos&lt;/code&gt; 및 &lt;code&gt;shell&lt;/code&gt; 더러운 모드에서 실행할 때 필드가 오염된다.</target>
        </trans-unit>
        <trans-unit id="c572293c3193296a30f83f937ead06ce5f40aaae" translate="yes" xml:space="preserve">
          <source>, stripped of their leading &quot;pw_&quot; parts, namely &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;passwd&lt;/code&gt;, &lt;code&gt;uid&lt;/code&gt;, &lt;code&gt;gid&lt;/code&gt;, &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;quota&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;gecos&lt;/code&gt;, &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;shell&lt;/code&gt;, and &lt;code&gt;expire&lt;/code&gt;. The &lt;code&gt;passwd&lt;/code&gt;, &lt;code&gt;gecos&lt;/code&gt;, and &lt;code&gt;shell&lt;/code&gt; fields are tainted when running in taint mode.</source>
          <target state="translated">, &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;passwd&lt;/code&gt; , &lt;code&gt;uid&lt;/code&gt; , &lt;code&gt;gid&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;quota&lt;/code&gt; , &lt;code&gt;comment&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , &lt;code&gt;dir&lt;/code&gt; , &lt;code&gt;shell&lt;/code&gt; 및 &lt;code&gt;expire&lt;/code&gt; 와 같은 선행 &quot;pw_&quot;부분을 제거했습니다 . &lt;code&gt;passwd&lt;/code&gt; 를 , &lt;code&gt;gecos&lt;/code&gt; 및 &lt;code&gt;shell&lt;/code&gt; 더러운 모드에서 실행할 때 필드가 오염된다.</target>
        </trans-unit>
        <trans-unit id="957091e96ecfa54157cc0d4139600a9a7f9d62d7" translate="yes" xml:space="preserve">
          <source>, such as having $x run from 4..8 and $y run from 7 to 12? Hmm... here's the simple way:</source>
          <target state="translated">예를 들어 $ x는 4..8에서 실행되고 $ y는 7에서 12로 실행됩니다. 흠 ... 여기 간단한 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="656da3fea3006661322b08824becf92984dd0aa9" translate="yes" xml:space="preserve">
          <source>, such as within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or a file, even though the statements aren&amp;rsquo;t delimited by braces.</source>
          <target state="translated">문이 중괄호로 구분되지 않더라도 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 또는 파일 내에서와 같이</target>
        </trans-unit>
        <trans-unit id="9aed239505bdee24ade4401579d4e55a499648de" translate="yes" xml:space="preserve">
          <source>, such as within an &lt;code&gt;eval&lt;/code&gt; or a file, even though the statements aren&amp;rsquo;t delimited by braces.</source>
          <target state="translated">, &lt;code&gt;eval&lt;/code&gt; 또는 파일 내 에서 명령문이 중괄호로 구분되지 않더라도.</target>
        </trans-unit>
        <trans-unit id="1146b3e5752905896b7897a3617a9463f973fcbf" translate="yes" xml:space="preserve">
          <source>, such that &lt;code&gt;Foo::Bar&lt;/code&gt; is in</source>
          <target state="translated">, &lt;code&gt;Foo::Bar&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="e08e5efec9e9e043f2abcc148b97927bd245fcae" translate="yes" xml:space="preserve">
          <source>, terminated by a newline.)</source>
          <target state="translated">개행 문자로 종료됩니다.)</target>
        </trans-unit>
        <trans-unit id="4cc374921dd851c3d7f16bd01a5e82be341ff39e" translate="yes" xml:space="preserve">
          <source>, that is, a string beginning with a letter or underscore, and containing letters, underscores, and digits. In some cases, it may be a chain of identifiers, separated by &lt;code&gt;::&lt;/code&gt; (or by the slightly archaic &lt;code&gt;'&lt;/code&gt;); all but the last are interpreted as names of packages, to locate the namespace in which to look up the final identifier (see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt; for details). For a more in-depth discussion on identifiers, see &lt;a href=&quot;#Identifier-parsing&quot;&gt;&quot;Identifier parsing&quot;&lt;/a&gt;. It's possible to substitute for a simple identifier, an expression that produces a reference to the value at runtime. This is described in more detail below and in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">즉, 문자 또는 밑줄로 시작하고 문자, 밑줄 및 숫자를 포함하는 문자열입니다. 어떤 경우에는 &lt;code&gt;::&lt;/code&gt; :( 또는 약간 오래된 &lt;code&gt;'&lt;/code&gt; )로 구분 된 식별자 체인 일 수 있습니다 . 마지막 식별자를 제외하고는 모두 패키지 이름으로 해석되어 최종 식별자를 찾을 네임 스페이스를 찾습니다 ( 자세한 내용 &lt;a href=&quot;perlmod#Packages&quot;&gt;은 perlmod의 &quot;패키지&quot;&lt;/a&gt; 참조). 식별자에 대한 자세한 내용은 &lt;a href=&quot;#Identifier-parsing&quot;&gt;&quot;식별자 구문 분석&quot;을&lt;/a&gt; 참조하십시오 . 런타임에 값에 대한 참조를 생성하는 표현식 인 간단한 식별자로 대체 할 수 있습니다. 이것은 아래와 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56e9bba4a207b86aa8dee08a4810ed2206bed901" translate="yes" xml:space="preserve">
          <source>, that is, a string beginning with a letter or underscore, and containing letters, underscores, and digits. In some cases, it may be a chain of identifiers, separated by &lt;code&gt;::&lt;/code&gt; (or by the slightly archaic &lt;code&gt;'&lt;/code&gt;); all but the last are interpreted as names of packages, to locate the namespace in which to look up the final identifier (see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt; for details). For a more in-depth discussion on identifiers, see &lt;a href=&quot;#Identifier-parsing&quot;&gt;Identifier parsing&lt;/a&gt;. It's possible to substitute for a simple identifier, an expression that produces a reference to the value at runtime. This is described in more detail below and in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">즉, 문자 또는 밑줄로 시작하고 문자, 밑줄 및 숫자를 포함하는 문자열입니다. 경우에 따라 &lt;code&gt;::&lt;/code&gt; 로 구분되는 식별자 체인 일 수 있습니다 (또는 약간 오래된 &lt;code&gt;'&lt;/code&gt; ). 마지막 식별자를 제외한 모든 이름은 패키지 이름으로 해석되어 최종 식별자를 찾을 네임 스페이스를 찾습니다 (자세한 내용 &lt;a href=&quot;perlmod#Packages&quot;&gt;은 perlmod의 패키지&lt;/a&gt; 참조). 식별자에 대한 자세한 내용은 &lt;a href=&quot;#Identifier-parsing&quot;&gt;식별자 구문 분석을&lt;/a&gt; 참조하십시오 . 런타임시 값에 대한 참조를 생성하는 표현식 인 간단한 식별자를 대체 할 수 있습니다. 이것은 아래와 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ebe898ca0c994ef13e630acb20dae497030f2a1" translate="yes" xml:space="preserve">
          <source>, that is, all elements in either A or in B but not in both. Think of it as an xor operation.</source>
          <target state="translated">즉, A 또는 B의 모든 요소 (둘 다의 요소는 아님)입니다. 그것을 xor 연산으로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="ef6731e3871cff7ef7e6cb224e37d6e60b555955" translate="yes" xml:space="preserve">
          <source>, that is, it is complemented. If &lt;code&gt;/d&lt;/code&gt; and/or &lt;code&gt;/s&lt;/code&gt; are also specified, they apply to the complemented</source>
          <target state="translated">즉, 보완됩니다. 만약 &lt;code&gt;/d&lt;/code&gt; 및 / 또는 &lt;code&gt;/s&lt;/code&gt; 는 도 지정되어, 그들은 보완에 적용</target>
        </trans-unit>
        <trans-unit id="fb1f30a577a9e343978298cf00190fde48358aaf" translate="yes" xml:space="preserve">
          <source>, that is, visible. This class consists of all alphanumeric characters and all punctuation characters.</source>
          <target state="translated">즉, 눈에.니다. 이 클래스는 모든 영숫자와 구두점으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3e5dd609a84255a29408216ee64e75b7eda290c6" translate="yes" xml:space="preserve">
          <source>, that returns the token type, among other things). And &lt;code&gt;+&lt;/code&gt;:</source>
          <target state="translated">, 이는 무엇보다도 토큰 유형을 반환합니다). 그리고 &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="066c5c23cfa29a9ad5d5bae17b8dc8aeb40e3312" translate="yes" xml:space="preserve">
          <source>, that takes 2 integer parameters and simply returns their sum.</source>
          <target state="translated">즉, 2 개의 정수 매개 변수를 가져 와서 단순히 합계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72fb706cc8e6bb54ff9e026e88c6735beb29bae1" translate="yes" xml:space="preserve">
          <source>, that uses all three (long lines have been wrapped here):</source>
          <target state="translated">, 그것은 세 가지를 모두 사용합니다 (긴 줄은 여기에 싸여 있습니다).</target>
        </trans-unit>
        <trans-unit id="c4ff75230dcb5fc1cf1b33f194533921c76a1f94" translate="yes" xml:space="preserve">
          <source>, that was introduced in release 5.005. That model was deprecated, and has been removed in version 5.10.</source>
          <target state="translated">릴리스 5.005에서 도입되었습니다. 해당 모델은 더 이상 사용되지 않으며 버전 5.10에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c76a9f1c0aa51a13c1e721f68f5b80a4fdeaee7" translate="yes" xml:space="preserve">
          <source>, that would involve ensuring any &lt;code&gt;lib/&lt;/code&gt; in front of the module location were removed.</source>
          <target state="translated">, 모듈 위치 앞의 &lt;code&gt;lib/&lt;/code&gt; 가 제거 되었는지 확인하는 것이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a9bcafc2113daaac812f1518346b8bb3f4ad5920" translate="yes" xml:space="preserve">
          <source>, the</source>
          <target state="translated">,</target>
        </trans-unit>
        <trans-unit id="bbc14ad4bef82ce943fa383c1ed92a04f35ae9a8" translate="yes" xml:space="preserve">
          <source>, the C function required to call it is now a bit more complex.</source>
          <target state="translated">이를 호출하는 데 필요한 C 함수는 이제 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="4f74cf35d928e36b23641e736801a45580f16870" translate="yes" xml:space="preserve">
          <source>, the Perl library module for the extension, and</source>
          <target state="translated">확장을위한 Perl 라이브러리 모듈</target>
        </trans-unit>
        <trans-unit id="83dee3890eb5dca0adacf7473711167c68e17275" translate="yes" xml:space="preserve">
          <source>, the YACC grammar. Let's look at the code that constructs the tree for &lt;code&gt;$a = $b + $c&lt;/code&gt;.</source>
          <target state="translated">, YACC 문법. &lt;code&gt;$a = $b + $c&lt;/code&gt; 대한 트리를 구성하는 코드를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="97438a08eda84c3bfc06c55a3bea0450b5e8f958" translate="yes" xml:space="preserve">
          <source>, the YACC grammar. Let's take the piece we need to construct the tree for &lt;code&gt;$a = $b + $c&lt;/code&gt;</source>
          <target state="translated">, YACC 문법. &lt;code&gt;$a = $b + $c&lt;/code&gt; 대한 트리를 구성하는 데 필요한 조각을 보자.</target>
        </trans-unit>
        <trans-unit id="d3a75d4660639ffe74acee5e5672e890c4814fdd" translate="yes" xml:space="preserve">
          <source>, the character used to separate elements in the command shell search &lt;code&gt;PATH&lt;/code&gt; .</source>
          <target state="translated">명령 쉘에서 &lt;code&gt;PATH&lt;/code&gt; 요소를 구분하는 데 사용되는 문자 .</target>
        </trans-unit>
        <trans-unit id="bd63bb9f2cda3373d022c883344f5c3faec730a6" translate="yes" xml:space="preserve">
          <source>, the character used to separate elements in the command shell search &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">, 명령 셸 검색 &lt;code&gt;PATH&lt;/code&gt; 의 요소를 구분하는 데 사용되는 문자 입니다.</target>
        </trans-unit>
        <trans-unit id="855214b2662c5c1d8b850e9feee34272d5af2679" translate="yes" xml:space="preserve">
          <source>, the file</source>
          <target state="translated">, 파일</target>
        </trans-unit>
        <trans-unit id="b1abcc10b694dd0025270a3db184b16a0fa38af6" translate="yes" xml:space="preserve">
          <source>, the final character is replicated till it is long enough. If the</source>
          <target state="translated">, 최종 캐릭터는 충분히 길어질 때까지 복제됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="806b344895d4421bd236f5401f77d9edb8ff3fd2" translate="yes" xml:space="preserve">
          <source>, the final character, if any, is replicated until it is long enough. There won't be a final character if and only if the</source>
          <target state="translated">, 최종 문자 (있는 경우)는 충분히 길 때까지 복제됩니다. 최종 캐릭터는 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc1c5f98cffb439007008844e3a20f10ba40b400" translate="yes" xml:space="preserve">
          <source>, the first 16-bit unit being the</source>
          <target state="translated">첫 번째 16 비트 단위는</target>
        </trans-unit>
        <trans-unit id="59d3c2b1e7a8f0fbf1d7438a5d2e3652d3735b95" translate="yes" xml:space="preserve">
          <source>, the lexer, and</source>
          <target state="translated">, 어휘 분석기 및</target>
        </trans-unit>
        <trans-unit id="2eeefd53f32ac80210e3e0524fe0f5c1cfb2e5e7" translate="yes" xml:space="preserve">
          <source>, the number of matches.</source>
          <target state="translated">, 일치 수입니다.</target>
        </trans-unit>
        <trans-unit id="cc0e409bb9bfdd351b146c8736f3bc9ef0f9e327" translate="yes" xml:space="preserve">
          <source>, the offset is relative to the start of the</source>
          <target state="translated">, 오프셋은</target>
        </trans-unit>
        <trans-unit id="f8c58b0bde45ddae936256535fca27e27919543c" translate="yes" xml:space="preserve">
          <source>, the process</source>
          <target state="translated">, 과정</target>
        </trans-unit>
        <trans-unit id="b71ad629342bbdad0ed5613b27effd49a287ff4b" translate="yes" xml:space="preserve">
          <source>, the quote (&lt;code&gt;'&quot;'&lt;/code&gt;) is used as a delimiter, the forward slash &lt;code&gt;'/'&lt;/code&gt; becomes an ordinary character and can be used in this regexp without trouble.</source>
          <target state="translated">, 따옴표 ( &lt;code&gt;'&quot;'&lt;/code&gt; )는 구분 기호로 사용되며 슬래시 &lt;code&gt;'/'&lt;/code&gt; 는 일반 문자가되며이 정규 표현식에서 문제없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d7028c2014dc1d6e04f06a4cda352756b2fdc6" translate="yes" xml:space="preserve">
          <source>, the reference can be used to store context information. The reference will be</source>
          <target state="translated">참조는 컨텍스트 정보를 저장하는 데 사용될 수 있습니다. 참조는</target>
        </trans-unit>
        <trans-unit id="8bcb5240076feedf18abb68075e1dc6583b4d7fb" translate="yes" xml:space="preserve">
          <source>, the regexp matches the whole string. Consider</source>
          <target state="translated">, 정규 표현식은 전체 문자열과 일치합니다. 중히 여기다</target>
        </trans-unit>
        <trans-unit id="91072da43b1733feac0b5401a10be38a14e4f911" translate="yes" xml:space="preserve">
          <source>, the result of subtracting</source>
          <target state="translated">, 빼기 결과</target>
        </trans-unit>
        <trans-unit id="bceccdaca653d534a67528d8ff70abcd0789f20d" translate="yes" xml:space="preserve">
          <source>, the result of the last statement) is used to determine truth or falsehood. If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable &lt;code&gt;$^R&lt;/code&gt;. The variable &lt;code&gt;$^R&lt;/code&gt; can then be used in code expressions later in the regexp. Here are some silly examples:</source>
          <target state="translated">, 마지막 진술의 결과)는 진실 또는 거짓을 결정하는 데 사용됩니다. 코드 표현식이 조건부로 사용되지 않으면 어설 션은 항상 참으로 평가되고 결과는 특수 변수 &lt;code&gt;$^R&lt;/code&gt; 됩니다. &lt;code&gt;$^R&lt;/code&gt; 변수 는 나중에 regexp의 코드 표현식에서 사용할 수 있습니다. 다음은 몇 가지 어리석은 예입니다.</target>
        </trans-unit>
        <trans-unit id="503654fe46496135690eb6d481b68797ec8a3d06" translate="yes" xml:space="preserve">
          <source>, the resulting UTF8 flag is &lt;b&gt;on&lt;/b&gt;--</source>
          <target state="translated">, 결과 UTF8 플래그는 &lt;b&gt;에&lt;/b&gt; -</target>
        </trans-unit>
        <trans-unit id="3421355fa3000d28b30b10777add4df0ffdfb58a" translate="yes" xml:space="preserve">
          <source>, the resulting UTF8 flag is always &lt;b&gt;off&lt;/b&gt;.</source>
          <target state="translated">결과 UTF8 플래그는 항상 &lt;b&gt;꺼져&lt;/b&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c1b175b8542016c468fb6ae172829284030bdd" translate="yes" xml:space="preserve">
          <source>, the second requests a</source>
          <target state="translated">, 두 번째 요청은</target>
        </trans-unit>
        <trans-unit id="5099e16a5fb708a04487a027b0394f0a1a320dc4" translate="yes" xml:space="preserve">
          <source>, the substring &lt;code&gt;GTT GAA&lt;/code&gt; gives a match. A better solution is</source>
          <target state="translated">, 하위 문자열 &lt;code&gt;GTT GAA&lt;/code&gt; 는 일치를 제공합니다. 더 나은 해결책은</target>
        </trans-unit>
        <trans-unit id="d0bac92aa165b5fcbe5d15dd2a3c4caac7ecba0a" translate="yes" xml:space="preserve">
          <source>, the table file is searched as</source>
          <target state="translated">테이블 파일은 다음과 같이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="80701e28ff7424b803181d8d7ce930f56b53f8c9" translate="yes" xml:space="preserve">
          <source>, the year 1995 is 95; the year 2001 is 101. Consult your system's &lt;code&gt;mktime()&lt;/code&gt; manpage for details about these and the other arguments.</source>
          <target state="translated">1995 년은 95 년입니다. 2001 년은 101입니다. 이러한 인수 및 기타 인수에 대한 자세한 내용은 시스템의 &lt;code&gt;mktime()&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9aea9e329eab2b9adcc970b72067fd0793c21cb5" translate="yes" xml:space="preserve">
          <source>, the year 1995 is 95; the year 2001 is 101. Consult your system's &lt;code&gt;strftime()&lt;/code&gt; manpage for details about these and the other arguments.</source>
          <target state="translated">1995 년은 95 년입니다. 2001 년은 101입니다. 이러한 인수 및 기타 인수에 대한 자세한 내용은 시스템의 &lt;code&gt;strftime()&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e189049326051591313d1c5688fafbf491aeaf0f" translate="yes" xml:space="preserve">
          <source>, then</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="2d7357221c057e21e0603b99d486d8d01e9f1d7b" translate="yes" xml:space="preserve">
          <source>, then each cached data item will be discarded and looked up afresh after the</source>
          <target state="translated">캐시 된 각 데이터 항목은 삭제되고</target>
        </trans-unit>
        <trans-unit id="0664c5508add1cbceda996e5b9d179cefd229787" translate="yes" xml:space="preserve">
          <source>, then extraction continues until</source>
          <target state="translated">을 추출 할 때까지 추출이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e9be5594e1731bd928c54113aa6bba78d9d10daa" translate="yes" xml:space="preserve">
          <source>, then the above system() is translated to</source>
          <target state="translated">위의 system ()은</target>
        </trans-unit>
        <trans-unit id="56ed743dadd72fa853ae506be49d8e7ef23c11ba" translate="yes" xml:space="preserve">
          <source>, then the verbose level will default to 1 if the exit status is less than 2 and will default to 0 otherwise.</source>
          <target state="translated">종료 상태가 2보다 작 으면 상세 수준은 기본적으로 1로 설정되고 그렇지 않으면 상세하게 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f388bd8ed28d6ec5148837e6886a6224018735fc" translate="yes" xml:space="preserve">
          <source>, then this is a no-op. Returns the number of octets necessary to represent the string as</source>
          <target state="translated">, 그러면 이것은 no-op입니다. 문자열을 다음과 같이 나타내는 데 필요한 옥텟 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3e93eac954f44cb11630b056721e2f26edaf81c2" translate="yes" xml:space="preserve">
          <source>, then we actually define $Lexicon{</source>
          <target state="translated">우리는 실제로 $ Lexicon {</target>
        </trans-unit>
        <trans-unit id="981255f700628f4a04da30c05e1f1345be156be9" translate="yes" xml:space="preserve">
          <source>, then we need to tell the &lt;code&gt;perl&lt;/code&gt; executable where it will be able to find the installed</source>
          <target state="translated">&lt;code&gt;perl&lt;/code&gt; 실행 파일에 설치된 곳을 찾을 수있는 곳 을 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="a97f83b483632edd32d7566630fdf0b16cc8ac52" translate="yes" xml:space="preserve">
          <source>, then you need to change the path following the &lt;code&gt;-L&lt;/code&gt; . If it complains that it can't find</source>
          <target state="translated">&lt;code&gt;-L&lt;/code&gt; 다음에 오는 경로를 변경해야합니다 . 찾을 수 없다고 불평하면</target>
        </trans-unit>
        <trans-unit id="35f0f0578043f1ce353b282bba5a6f6dd3502f20" translate="yes" xml:space="preserve">
          <source>, then you need to change the path following the &lt;code&gt;-L&lt;/code&gt;. If it complains that it can't find</source>
          <target state="translated">, 그런 다음 &lt;code&gt;-L&lt;/code&gt; 다음에 경로를 변경해야합니다 . 찾을 수 없다고 불평하는 경우</target>
        </trans-unit>
        <trans-unit id="8911f644fb0560e46f52310cd354bac6558884ff" translate="yes" xml:space="preserve">
          <source>, there is no upper bound to the number of argument values taken.</source>
          <target state="translated">인수 값의 수에는 상한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8da1ee6882503c12e13b4824907fc0653955992a" translate="yes" xml:space="preserve">
          <source>, there is the entry:</source>
          <target state="translated">항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17e4f4b7efc3bfddeaaec858218e98d597284597" translate="yes" xml:space="preserve">
          <source>, there's no sense in being able to enable() or disable() processing.</source>
          <target state="translated">, enable () 또는 disable () 처리 기능은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5fc8a5e02b68374b799d5535dec84e053e8816a" translate="yes" xml:space="preserve">
          <source>, this directory contains modules which are only released as part of the core. Unlike</source>
          <target state="translated">이 디렉토리에는 코어의 일부로 만 릴리스 된 모듈이 포함되어 있습니다. 같지 않은</target>
        </trans-unit>
        <trans-unit id="133358768c237ba7c13e2e36ef10a76ee918db2a" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_REVISION&lt;/code&gt; .</source>
          <target state="translated">이를 &lt;code&gt;PERL_REVISION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="3cfc59cfaeff38d725334bbe1d5ea2b1ff52b207" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_REVISION&lt;/code&gt;.</source>
          <target state="translated">,이를 &lt;code&gt;PERL_REVISION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5a14e004f2bf1eeac71229fa7540bd21823c5b" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; . This is unique to perl.</source>
          <target state="translated">이를 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; 이라고합니다 . 이것은 perl에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="248a9ab41d2f9ab16a0738c6bed505d36cb3c82c" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_SUBVERSION&lt;/code&gt;. This is unique to perl.</source>
          <target state="translated">,이를 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; 이라고합니다 . 이것은 perl에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="714cd1f92b0d5db09f723a91ae82e2d32331d86e" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_VERSION&lt;/code&gt; .</source>
          <target state="translated">이를 &lt;code&gt;PERL_VERSION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="41e73dd1f9ca8349934ee78ba9a50704f4b426d9" translate="yes" xml:space="preserve">
          <source>, this is referred to as &lt;code&gt;PERL_VERSION&lt;/code&gt;.</source>
          <target state="translated">,이를 &lt;code&gt;PERL_VERSION&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba8cba024fa50efc2185c250a93c4684f50f8b2" translate="yes" xml:space="preserve">
          <source>, this method is a read-once operation. Call</source>
          <target state="translated">이 방법은 한 번의 읽기 작업입니다. 요구</target>
        </trans-unit>
        <trans-unit id="c5419160a5194a27a2e9670569f35b7ce53eec75" translate="yes" xml:space="preserve">
          <source>, this pragma looks in the table of standard Unicode names for the names</source>
          <target state="translated">이 pragma는 표준 유니 코드 이름 표에서 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="96d19878d35455aef11308cd825aac00f74c2c5b" translate="yes" xml:space="preserve">
          <source>, those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside &lt;code&gt;$re&lt;/code&gt;):</source>
          <target state="translated">, 런타임 변수 보간이없는 것. &lt;a href=&quot;overload&quot;&gt;overload에&lt;/a&gt; 설명 된 대로이 변환은 정규식의 리터럴 부분에서만 작동합니다. 를 들어 &lt;code&gt;\Y|$re\Y|&lt;/code&gt; 이 정규식의 변수 부분은 명시 적으로 변환해야합니다 (단, &lt;code&gt;$re&lt;/code&gt; 내부 에서 &lt;code&gt;\Y|&lt;/code&gt; 의 특별한 의미를 활성화해야하는 경우에만 해당 ).</target>
        </trans-unit>
        <trans-unit id="b0263513f039c38507b3d70b68ab4c5b60dd7020" translate="yes" xml:space="preserve">
          <source>, though it simply delegates to the</source>
          <target state="translated">, 그것은 단순히</target>
        </trans-unit>
        <trans-unit id="18f1b111c2282bb1d52143843bb53f0e42f90748" translate="yes" xml:space="preserve">
          <source>, though it's possible that some systems will have</source>
          <target state="translated">일부 시스템은</target>
        </trans-unit>
        <trans-unit id="2399ea48546f62dda016b66c915a33efba5ece8f" translate="yes" xml:space="preserve">
          <source>, to check use</source>
          <target state="translated">사용 확인</target>
        </trans-unit>
        <trans-unit id="426b172db6893b6e9657e6e9162888abed4f4794" translate="yes" xml:space="preserve">
          <source>, to handle these for us. He suggests (assuming your string is contained in &lt;code&gt;$text&lt;/code&gt; ):</source>
          <target state="translated">우리를 위해 이것을 처리합니다. 그는 제안합니다 (문자열이 &lt;code&gt;$text&lt;/code&gt; 에 있다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="6f2a786ff4175338fb515aef2c29bd307cd29baa" translate="yes" xml:space="preserve">
          <source>, to handle these for us. He suggests (assuming your string is contained in &lt;code&gt;$text&lt;/code&gt;):</source>
          <target state="translated">, 우리를 위해 처리합니다. 그는 다음과 같이 제안합니다 (문자열이 &lt;code&gt;$text&lt;/code&gt; 포함되어 있다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="78af069883ae74a128985778bc16fd41b2d43bde" translate="yes" xml:space="preserve">
          <source>, to have the effect of:</source>
          <target state="translated">, 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a97e60b438c8a77e2cd328d323df609691a533" translate="yes" xml:space="preserve">
          <source>, to print out the UID of the process.</source>
          <target state="translated">프로세스의 UID를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5263066869df6bcc590c2451eb837a61c2634447" translate="yes" xml:space="preserve">
          <source>, typing</source>
          <target state="translated">, 입력</target>
        </trans-unit>
        <trans-unit id="1cbd4041e99913f2cfa30fb2cec88d030e327667" translate="yes" xml:space="preserve">
          <source>, use a name recognized by the &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt; module. Some pod formatters may try to guess between a Latin-1 or CP-1252 versus UTF-8 encoding, but they may guess wrong. It's best to be explicit if you use anything besides strict ASCII. Examples:</source>
          <target state="translated">, &lt;a href=&quot;Encode::Supported&quot;&gt;Encode :: Supported&lt;/a&gt; 모듈 에서 인식하는 이름을 사용하십시오 . 일부 포드 포맷터는 Latin-1 또는 CP-1252와 UTF-8 인코딩 사이에서 추측을 시도 할 수 있지만 잘못 추측 할 수 있습니다. 엄격한 ASCII 이외의 것을 사용하는 경우 명시하는 것이 가장 좋습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="faee7867e8ebfc988e6546f4dcbe9ad6cb8c536a" translate="yes" xml:space="preserve">
          <source>, use a name recognized by the &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; module. Some pod formatters may try to guess between a Latin-1 or CP-1252 versus UTF-8 encoding, but they may guess wrong. It's best to be explicit if you use anything besides strict ASCII. Examples:</source>
          <target state="translated">&lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; 모듈 에서 인식되는 이름을 사용하십시오 . 일부 포드 포맷터는 라틴 -1 또는 CP-1252와 UTF-8 인코딩 사이를 추측하려고 시도하지만 잘못 추측 할 수 있습니다. 엄격한 ASCII 이외의 것을 사용하는 경우 명시 적으로하는 것이 가장 좋습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2a7de5b14d2a34b3272730993fe2dee6018ff3fd" translate="yes" xml:space="preserve">
          <source>, using embedded whitespace as the word delimiters. It can be understood as being roughly equivalent to:</source>
          <target state="translated">단어 구분 기호로 포함 된 공백을 사용합니다. 대략 다음과 같은 것으로 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e169e875a0353d0299dee5c8ba5ef4c88de61df4" translate="yes" xml:space="preserve">
          <source>, when it detects its program running with differing real and effective user or group IDs. The setuid bit in Unix permissions is mode 04000, the setgid bit mode 02000; either or both may be set. You can also enable taint mode explicitly by using the &lt;b&gt;-T&lt;/b&gt; command line flag. This flag is</source>
          <target state="translated">실제적이고 효과적인 사용자 또는 그룹 ID로 실행중인 프로그램을 감지 한 경우. Unix 권한의 setuid 비트는 mode 04000, setgid 비트 모드 02000입니다. 둘 중 하나 또는 둘 다 설정 될 수 있습니다. &lt;b&gt;-T&lt;/b&gt; 명령 행 플래그를 사용하여 오염 모드를 명시 적으로 활성화 할 수도 있습니다 . 이 깃발은</target>
        </trans-unit>
        <trans-unit id="a8fbd0202d5d59bb16abfc27a4a724fcbb5feb8c" translate="yes" xml:space="preserve">
          <source>, where</source>
          <target state="translated">, 어디</target>
        </trans-unit>
        <trans-unit id="8924bb9dd1f684020a4cba15af279a4d0d20f15e" translate="yes" xml:space="preserve">
          <source>, where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; is in effect, addition operations are forced to integer, whereas by default they are not, with the default behaviour being restored via &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하십시오. 사실상, 더하기 연산은 정수로 강제되는 반면, 디폴트 동작은 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; myint;&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;없이&lt;/a&gt; 복원 된다.</target>
        </trans-unit>
        <trans-unit id="c021dacf080e62f8123f183415639c30e95ffabe" translate="yes" xml:space="preserve">
          <source>, where &lt;code&gt;use myint;&lt;/code&gt; is in effect, addition operations are forced to integer, whereas by default they are not, with the default behaviour being restored via &lt;code&gt;no myint;&lt;/code&gt;</source>
          <target state="translated">, 어디에 &lt;code&gt;use myint;&lt;/code&gt; 실제로 더하기 연산은 정수로 강제 적용되지만 기본적으로는 그렇지 않습니다. 기본 동작은 &lt;code&gt;no myint;&lt;/code&gt; 를 통해 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c470a8a84cae4c6227806e7867bd89a887b344e3" translate="yes" xml:space="preserve">
          <source>, where each member has an associated filename, known as the</source>
          <target state="translated">, 여기서 각 구성원은</target>
        </trans-unit>
        <trans-unit id="9f41ab59091bd1f06b31a77ab9df95b2bc91cbcd" translate="yes" xml:space="preserve">
          <source>, where the &lt;code&gt;.al&lt;/code&gt; file has the same name as the subroutine, sans package. If such a file exists, AUTOLOAD will read and evaluate it, thus (presumably) defining the needed subroutine. AUTOLOAD will then &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; the newly defined subroutine.</source>
          <target state="translated">를 Where, &lt;code&gt;.al&lt;/code&gt; 파일이 서브 루틴 같은 이름을 가진, SAN은 패키지. 이러한 파일이 존재하면 AUTOLOAD는 파일을 읽고 평가하므로 필요한 서브 루틴을 정의합니다. AUTOLOAD는 것이다 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 새로 정의 된 서브 루틴을.</target>
        </trans-unit>
        <trans-unit id="ded3ee142ecb7daceaf87b1f95d3c198051ca123" translate="yes" xml:space="preserve">
          <source>, where the &lt;code&gt;.al&lt;/code&gt; file has the same name as the subroutine, sans package. If such a file exists, AUTOLOAD will read and evaluate it, thus (presumably) defining the needed subroutine. AUTOLOAD will then &lt;code&gt;goto&lt;/code&gt; the newly defined subroutine.</source>
          <target state="translated">, 여기서 &lt;code&gt;.al&lt;/code&gt; 파일은 서브 루틴 sans 패키지와 동일한 이름을 갖습니다. 그러한 파일이 존재하면 AUTOLOAD는이를 읽고 평가하므로 (아마도) 필요한 서브 루틴을 정의합니다. AUTOLOAD는 것이다 &lt;code&gt;goto&lt;/code&gt; 새로 정의 된 서브 루틴을.</target>
        </trans-unit>
        <trans-unit id="6aea3fc4b54551faf648d0b392baddc5ecb694ab" translate="yes" xml:space="preserve">
          <source>, whereas</source>
          <target state="translated">반면에</target>
        </trans-unit>
        <trans-unit id="26c934aa9a989416f6aadbafbbddd8e4c4e1b0e5" translate="yes" xml:space="preserve">
          <source>, which are abstract numbers. To use these numbers, various encodings are needed.</source>
          <target state="translated">추상 숫자입니다. 이 숫자를 사용하려면 다양한 인코딩이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="03649386e3bc4e7a816e4620f028cf88bdb23bf9" translate="yes" xml:space="preserve">
          <source>, which are actually the same program but behave differently depending on how they are called, provide another way of getting at C with Perl - they'll convert C structures and union declarations to Perl code. This is deprecated in favour of</source>
          <target state="translated">실제로 동일한 프로그램이지만 호출 방식에 따라 다르게 동작하는 Perl을 사용하여 C를 얻는 또 다른 방법을 제공합니다. C 구조와 공용체 선언을 Perl 코드로 변환합니다. 이것은 더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="39b81ba625528bfbfbdeb767e8a690b6857a169b" translate="yes" xml:space="preserve">
          <source>, which attempts to simplify as much as possible, making bisecting as simple as running a Perl one-liner. For example, if you want to know when this became an error:</source>
          <target state="translated">, 가능한 한 단순화하려고 시도하여 Perl 한 줄짜리를 실행하는 것만 큼 간단하게 이등분을 만듭니다. 예를 들어, 이것이 언제 오류가되었는지 알고 싶다면 :</target>
        </trans-unit>
        <trans-unit id="0b151974aee7344a268313e90f86adde43defa23" translate="yes" xml:space="preserve">
          <source>, which creates a Perl counterpart for each of the extension's XSUBs. Don't worry about this part; leave that to the</source>
          <target state="translated">확장의 각 XSUB에 대해 Perl 대응을 작성합니다. 이 부분에 대해 걱정하지 마십시오. 그에게 맡겨</target>
        </trans-unit>
        <trans-unit id="5a5edb1a67afcdce7292393be6ccd46e15cc154a" translate="yes" xml:space="preserve">
          <source>, which describes the distribution, its contents, and the requirements for building and installing the distribution. The data structure stored in the</source>
          <target state="translated">, 배포, 콘텐츠, 배포 빌드 및 설치 요구 사항을 설명합니다. 에 저장된 데이터 구조</target>
        </trans-unit>
        <trans-unit id="0e4ba048b9a7447e52c228c8f75341de76908cb5" translate="yes" xml:space="preserve">
          <source>, which is always a good idea to supply if the number is known.</source>
          <target state="translated">숫자를 알고있는 경우 항상 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="77693f9b1b48d8ec17c40b859e5d00f6c499c0e5" translate="yes" xml:space="preserve">
          <source>, which is currently used (when needed) by all regular non-possessive expression quantifiers, namely &lt;code&gt;&quot;*&quot;&lt;/code&gt;, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;&quot;+&quot;&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}&lt;/code&gt;, and &lt;code&gt;{n,m}?&lt;/code&gt;. Backtracking is often optimized internally, but the general principle outlined here is valid.</source>
          <target state="translated">, 모든 정규 비소 유식 한정자, 즉 &lt;code&gt;&quot;*&quot;&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;&quot;+&quot;&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}&lt;/code&gt; 및 &lt;code&gt;{n,m}?&lt;/code&gt; . 역 추적은 종종 내부적으로 최적화되지만 여기에 설명 된 일반 원칙은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="17829fa2132953972da0914ccd97c3e350358fce" translate="yes" xml:space="preserve">
          <source>, which is currently used (when needed) by all regular non-possessive expression quantifiers, namely &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}&lt;/code&gt;, and &lt;code&gt;{n,m}?&lt;/code&gt;. Backtracking is often optimized internally, but the general principle outlined here is valid.</source>
          <target state="translated">, 모든 정규 비 포지 셔 티브 표현식 정량 자, 즉 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; 의해 현재 사용되고있는 (필요한 경우) ? , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}&lt;/code&gt; 및 &lt;code&gt;{n,m}?&lt;/code&gt; . 역 추적은 종종 내부적으로 최적화되지만 여기에 요약 된 일반적인 원칙은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="03d1757cccf78573ee0182fd5b28a73a2d407dd6" translate="yes" xml:space="preserve">
          <source>, which is either a decimal or a hexadecimal scalar designating a code point in the platform's native character set (extended to Unicode), or a string containing &lt;code&gt;U+&lt;/code&gt; followed by hexadecimals designating a Unicode code point. A leading 0 will force a hexadecimal interpretation, as will a hexadecimal digit that isn't a decimal digit.</source>
          <target state="translated">이는 플랫폼의 기본 문자 세트에서 코드 포인트를 지정하는 10 진수 또는 16 진 스칼라이거나 (유니 코드로 확장 됨) &lt;code&gt;U+&lt;/code&gt; 그 뒤에 16 진수가 유니 코드 코드 포인트를 지정하는 문자열 입니다. 선행 0은 10 진수가 아닌 16 진 숫자와 마찬가지로 16 진 해석을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="baf38326329741523715bffba499968b7d0e87ce" translate="yes" xml:space="preserve">
          <source>, which is not the winpid. Use &lt;code&gt;Cygwin::pid_to_winpid()&lt;/code&gt; and &lt;code&gt;Cygwin::winpid_to_pid()&lt;/code&gt; to translate between them.</source>
          <target state="translated">, 그것은 winpid가 아닙니다. 사용 &lt;code&gt;Cygwin::pid_to_winpid()&lt;/code&gt; 와 &lt;code&gt;Cygwin::winpid_to_pid()&lt;/code&gt; 그들 사이에 변환합니다.</target>
        </trans-unit>
        <trans-unit id="32dea819029bc45dc941d184378ae2d614b06ad7" translate="yes" xml:space="preserve">
          <source>, which is the common case for most CPAN distributions with their</source>
          <target state="translated">, 이는 대부분의 CPAN 배포에 대한 일반적인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="0c16c9a97ba5ea538f1979d7f7d2fb2c51566d3a" translate="yes" xml:space="preserve">
          <source>, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">대괄호 안에있는 문자를 제외한 모든 문자와 일치합니다. 모두 &lt;code&gt;[...]&lt;/code&gt; 와 &lt;code&gt;[^...]&lt;/code&gt; 문자와 일치해야하며, 일치에 실패합니다. 그때</target>
        </trans-unit>
        <trans-unit id="3d38775c49ebe935515da064eb664cbc8495f661" translate="yes" xml:space="preserve">
          <source>, which may also backtrack as necessary; however, should B not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.</source>
          <target state="translated">, 필요에 따라 역 추적 할 수도 있습니다. 그러나 B가 일치하지 않으면 더 이상 역 추적이 발생하지 않으며 패턴은 현재 시작 위치에서 완전히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b4454811042a626c864b08d42e1e9fe1a6f89db8" translate="yes" xml:space="preserve">
          <source>, which means it's going to be false in any sane context.</source>
          <target state="translated">이는 모든 상황에서 잘못 될 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a89b512ac155f333bc1a9e0edf340080f66fee9a" translate="yes" xml:space="preserve">
          <source>, which must be an encoding name that &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; recognizes. (Encode's list of supported encodings, in &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt;, is useful here.) If the Pod parser cannot decode the declared encoding, it should emit a warning and may abort parsing the document altogether.</source>
          <target state="translated">, &lt;a href=&quot;encode&quot;&gt;Encode가&lt;/a&gt; 인식 하는 인코딩 이름이어야합니다 . (Encode &lt;a href=&quot;Encode::Supported&quot;&gt;:: Supported에&lt;/a&gt; 있는 Encode 의 지원되는 인코딩 목록이 여기에 유용합니다.) Pod 파서가 선언 된 인코딩을 디코딩 할 수없는 경우 경고를 내고 문서 파싱을 모두 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86643bdbf232568e22729fc55a9633ebd6eca7bc" translate="yes" xml:space="preserve">
          <source>, which must be an encoding name that &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; recognizes. (Encode's list of supported encodings, in &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;, is useful here.) If the Pod parser cannot decode the declared encoding, it should emit a warning and may abort parsing the document altogether.</source>
          <target state="translated">인코딩 이름으로 &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 해야합니다 . (Encode &lt;a href=&quot;encode/supported&quot;&gt;:: Supported의 인코딩&lt;/a&gt; 지원 인코딩 목록은 여기서 유용합니다.) 포드 파서가 선언 된 인코딩을 디코딩 할 수없는 경우 경고가 발생하고 문서 파싱이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6946244e23fae74ad07a1325f15207b7d2a7623a" translate="yes" xml:space="preserve">
          <source>, which must be of type &lt;code&gt;STRLEN&lt;/code&gt; . Evaluates</source>
          <target state="translated">&lt;code&gt;STRLEN&lt;/code&gt; 유형이어야합니다 . 평가</target>
        </trans-unit>
        <trans-unit id="1b3bfca1e6560c4b294dd00bf14e384c23b6db35" translate="yes" xml:space="preserve">
          <source>, which proceeds to try to execute the Perl program as a shell script. The shell executes the second line as a normal shell command, and thus starts up the Perl interpreter. On some systems $0 doesn't always contain the full pathname, so the &lt;a href=&quot;#-S&quot;&gt;&quot;-S&quot;&lt;/a&gt; tells Perl to search for the program if necessary. After Perl locates the program, it parses the lines and ignores them because the variable $running_under_some_shell is never true. If the program will be interpreted by csh, you will need to replace &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; with &lt;code&gt;$*&lt;/code&gt;, even though that doesn't understand embedded spaces (and such) in the argument list. To start up</source>
          <target state="translated">, Perl 프로그램을 쉘 스크립트로 실행합니다. 쉘은 일반 쉘 명령으로 두 번째 행을 실행하므로 Perl 인터프리터를 시작합니다. 일부 시스템에서 $ 0은 항상 전체 경로 이름을 포함하지 않으므로 &lt;a href=&quot;#-S&quot;&gt;&quot;-S&quot;&lt;/a&gt; 는 Perl에게 필요한 경우 프로그램을 검색하도록 지시합니다. Perl이 프로그램을 찾은 후에는 $ running_under_some_shell 변수가 true가 아니기 때문에 행을 구문 분석하고 무시합니다. 프로그램이 csh로 해석되는 경우 인수 목록에 포함 된 공백 (등)을 이해하지 못하더라도 &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; 를 &lt;code&gt;$*&lt;/code&gt; 로 바꿔야 합니다. 시작하려면</target>
        </trans-unit>
        <trans-unit id="d6c4d6b2342d9336a15bff4441fdc806ef9f1dda" translate="yes" xml:space="preserve">
          <source>, which proceeds to try to execute the Perl program as a shell script. The shell executes the second line as a normal shell command, and thus starts up the Perl interpreter. On some systems $0 doesn't always contain the full pathname, so the &lt;b&gt;-S&lt;/b&gt; tells Perl to search for the program if necessary. After Perl locates the program, it parses the lines and ignores them because the variable $running_under_some_shell is never true. If the program will be interpreted by csh, you will need to replace &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; with &lt;code&gt;$*&lt;/code&gt; , even though that doesn't understand embedded spaces (and such) in the argument list. To start up</source>
          <target state="translated">Perl 프로그램을 쉘 스크립트로 실행하려고합니다. 쉘은 두 번째 행을 일반 쉘 명령으로 실행하여 Perl 인터프리터를 시작합니다. 일부 시스템에서는 $ 0에 항상 전체 경로 이름이 포함되지 않으므로 &lt;b&gt;-S&lt;/b&gt; 는 필요한 경우 프로그램을 검색하도록 Perl에 지시합니다. Perl이 프로그램을 찾은 후 $ running_under_some_shell 변수가 true가 아니므로 행을 구문 분석하고 무시합니다. 프로그램이 csh에 의해 해석 될 경우 인수 목록에 포함 된 공백 (및 기타)을 이해하지 못하더라도 &lt;code&gt;${1+&quot;$@&quot;}&lt;/code&gt; 를 &lt;code&gt;$*&lt;/code&gt; 로 바꿔야 합니다. 시작하려면</target>
        </trans-unit>
        <trans-unit id="d03971d8e8f6aae96dc846db2bbccfa1c43aa02c" translate="yes" xml:space="preserve">
          <source>, which processes the command line options, sets up any statically linked XS modules, opens the program and calls &lt;code&gt;yyparse&lt;/code&gt; to parse it.</source>
          <target state="translated">명령 행 옵션을 처리하고 정적으로 링크 된 XS 모듈을 설정하고 프로그램을 열고 &lt;code&gt;yyparse&lt;/code&gt; 를 호출 하여 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="d38a80b5f16db8cd8592888fcbc6ecb5cbfb16e6" translate="yes" xml:space="preserve">
          <source>, which provides a core to which the Perl executable image and all Perl extensions are linked. It is generally located via the logical name</source>
          <target state="translated">이는 Perl 실행 가능 이미지와 모든 Perl 확장이 링크되는 코어를 제공합니다. 일반적으로 논리적 이름을 통해 위치합니다</target>
        </trans-unit>
        <trans-unit id="5d983c580d2a071fc02ee59631c5c9b624e3d132" translate="yes" xml:space="preserve">
          <source>, which requires that all applications use its LSP but which is not IFS-compatible, because clearly Perl will normally avoid using such an LSP.</source>
          <target state="translated">Perl은 일반적으로 그러한 LSP 사용을 피하기 때문에 모든 응용 프로그램은 LSP를 사용해야하지만 IFS와 호환되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ae6e3dda98fae8d31622d67dcd619e9e43cefbe" translate="yes" xml:space="preserve">
          <source>, which shall not modify any input argument, and</source>
          <target state="translated">입력 인수를 수정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b3cd0cd1142152776fc2bac2a2e89c7f139dc35e" translate="yes" xml:space="preserve">
          <source>, which should be a full pathname found amongst the %INC values.</source>
          <target state="translated">% INC 값에서 찾은 전체 경로 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9149915d9aff75a334b3f754d9220c360d8f395f" translate="yes" xml:space="preserve">
          <source>, which will be open in a manner compatible with the supplied mode string, the call is thus equivalent to &lt;code&gt;PerlIO_fdopen&lt;/code&gt; . In this case</source>
          <target state="translated">제공된 모드 문자열과 호환되는 방식으로 열리므로 호출은 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 과 같습니다 . 이 경우</target>
        </trans-unit>
        <trans-unit id="dd6c0f5b6ad990f4eef424bfc58e42542222405e" translate="yes" xml:space="preserve">
          <source>, which will be open in a manner compatible with the supplied mode string, the call is thus equivalent to &lt;code&gt;PerlIO_fdopen&lt;/code&gt;. In this case</source>
          <target state="translated">제공된 모드 문자열과 호환되는 방식으로 열리므로 호출은 &lt;code&gt;PerlIO_fdopen&lt;/code&gt; 과 동일합니다 . 이 경우</target>
        </trans-unit>
        <trans-unit id="bfd3b2c159dbde7db4131aab3fae489835bc0cb5" translate="yes" xml:space="preserve">
          <source>, which you should copy &lt;b&gt;outside&lt;/b&gt; of the repository, as the bisect process will reset the state to a clean checkout as it runs. The instructions below assume that you copied it as</source>
          <target state="translated">, bisect 프로세스가 실행될 때 상태를 깨끗한 체크 아웃으로 재설정하므로 저장소 &lt;b&gt;외부&lt;/b&gt; 에서 복사해야 합니다. 아래 지침에서는 다음과 같이 복사했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e29affdf4265c07a24e87380ae0fc86e7811b273" translate="yes" xml:space="preserve">
          <source>, which you'll also need) will reside in a directory that looks like this:</source>
          <target state="translated">), 다음과 같은 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b91b3346b580b5a72bcf19156716e69a40617494" translate="yes" xml:space="preserve">
          <source>, whichever is writable.</source>
          <target state="translated">쓰기 가능한 것 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1521c3e5024fb9d201b1510098752e0fbfadaa8f" translate="yes" xml:space="preserve">
          <source>, whichever is writable. For example Solaris and IRIX system may prefer &lt;code&gt;&quot;stream&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;unix&quot;&lt;/code&gt; .</source>
          <target state="translated">쓰기 가능한 것 중 하나입니다. 예를 들어 Solaris 및 IRIX 시스템은 &lt;code&gt;&quot;unix&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;stream&quot;&lt;/code&gt; 을 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df4fa17a3a3ee864c8ff01e92b96136a59a67d85" translate="yes" xml:space="preserve">
          <source>, whichever is writable. For example Solaris and IRIX system may prefer &lt;code&gt;&quot;stream&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;unix&quot;&lt;/code&gt;.</source>
          <target state="translated">, 어느 것이 든 쓸 수 있습니다. 예를 들어 Solaris 및 IRIX 시스템은 &lt;code&gt;&quot;unix&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;stream&quot;&lt;/code&gt; 을 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af1e6ea7c63a016f19ff1f20a75d322ca9d606dc" translate="yes" xml:space="preserve">
          <source>, will copy the files onto the NetWare server.</source>
          <target state="translated">파일을 NetWare 서버에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="542c63558f82cc60301de087610ae8d702c1444e" translate="yes" xml:space="preserve">
          <source>, will the expression be treated as boolean. Otherwise, smartmatching is used.</source>
          <target state="translated">, 표현식이 부울로 처리됩니다. 그렇지 않으면 스마트 매칭이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="434f72658ad0db42fd472dfe71b1d976ec669e77" translate="yes" xml:space="preserve">
          <source>, with a function</source>
          <target state="translated">기능과 함께</target>
        </trans-unit>
        <trans-unit id="ff76a65744d509bad3b866f1e9b378a7560d811c" translate="yes" xml:space="preserve">
          <source>, with one command (and no other files) it's easy to find out</source>
          <target state="translated">, 하나의 명령으로 (다른 파일없이) 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b8ca3ac41e774d45998884fc92354c868b6717" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a Base64 string. Multiple</source>
          <target state="translated">결과는 Base64 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="677a292feedbf48a082a00acc87c06021be08f63" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a binary string. Multiple</source>
          <target state="translated">결과는 이진 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="2a314e18b1b4fa535233316b8d18d5a2b276138b" translate="yes" xml:space="preserve">
          <source>, with the result encoded as a hexadecimal string. Multiple</source>
          <target state="translated">결과는 16 진 문자열로 인코딩됩니다. 배수</target>
        </trans-unit>
        <trans-unit id="b99d3c828cce13fde4656fc0fc0105ea617a8091" translate="yes" xml:space="preserve">
          <source>, yet another utility under Encode/bin directory.</source>
          <target state="translated">Encode / bin 디렉토리의 또 다른 유틸리티입니다.</target>
        </trans-unit>
        <trans-unit id="51f521f34eb9dfa708aba7876dbcd25e0b33259e" translate="yes" xml:space="preserve">
          <source>, you are encouraged to use &lt;code&gt;catpath()&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;catpath()&lt;/code&gt; 를 사용하는 것이 좋습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="50c611f29a4f4c3132ca368f4ed25bf3706ad044" translate="yes" xml:space="preserve">
          <source>, you are encouraged to use &lt;code&gt;catpath()&lt;/code&gt; to concatenate</source>
          <target state="translated">&lt;code&gt;catpath()&lt;/code&gt; 를 사용 하여 연결 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6e0466cebd730e6f201e1dc3e0fa65a5e7288ff5" translate="yes" xml:space="preserve">
          <source>, you can often gain a 10-25% performance benefit by rebuilding it to link with a static libc.a instead. This will make a bigger perl executable, but your Perl programs (and programmers) may thank you for it. See the</source>
          <target state="translated">정적 libc.a와 연결되도록 다시 빌드하면 성능이 10-25 % 향상되는 경우가 많습니다. 이렇게하면 더 큰 perl을 실행할 수 있지만 Perl 프로그램 (및 프로그래머)이이를 감사하게 생각할 수 있습니다. 참조</target>
        </trans-unit>
        <trans-unit id="1d331b88bfc2c65e1619a12d857298426cd92d30" translate="yes" xml:space="preserve">
          <source>, you can recompile with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , which will cause the addresses of all those leaked SVs to be dumped along with details as to where each SV was originally allocated. This information is also displayed by Devel::Peek. Note that the extra details recorded with each SV increases memory usage, so it shouldn't be used in production environments. It also converts &lt;code&gt;new_SV()&lt;/code&gt; from a macro into a real function, so you can use your favourite debugger to discover where those pesky SVs were allocated.</source>
          <target state="translated">&lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 를 사용 하여 다시 컴파일 할 수 있습니다. 이렇게하면 유출 된 모든 SV의 주소가 각 SV가 원래 할당 된 위치에 대한 세부 정보와 함께 덤프됩니다. 이 정보는 Devel :: Peek에서도 표시됩니다. 각 SV에 기록 된 추가 정보는 메모리 사용량을 증가 시키므로 프로덕션 환경에서는 사용하지 않아야합니다. 또한 &lt;code&gt;new_SV()&lt;/code&gt; 를 매크로에서 실제 함수로 변환 하므로 선호하는 디버거를 사용하여 성가신 SV가 할당 된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ff7a955490d6c2be94e15abefb85a6178673401" translate="yes" xml:space="preserve">
          <source>, you can recompile with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, (&lt;code&gt;Configure -Accflags=-DDEBUG_LEAKING_SCALARS&lt;/code&gt;), which will cause the addresses of all those leaked SVs to be dumped along with details as to where each SV was originally allocated. This information is also displayed by Devel::Peek. Note that the extra details recorded with each SV increases memory usage, so it shouldn't be used in production environments. It also converts &lt;code&gt;new_SV()&lt;/code&gt; from a macro into a real function, so you can use your favourite debugger to discover where those pesky SVs were allocated.</source>
          <target state="translated">, &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , ( &lt;code&gt;Configure -Accflags=-DDEBUG_LEAKING_SCALARS&lt;/code&gt; )를 사용 하여 다시 컴파일 할 수 있습니다. 그러면 유출 된 모든 SV의 주소가 각 SV가 원래 할당 된 위치에 대한 세부 정보와 함께 덤프됩니다. 이 정보는 Devel :: Peek에서도 표시됩니다. 각 SV와 함께 기록 된 추가 세부 정보는 메모리 사용량을 증가 시키므로 프로덕션 환경에서 사용해서는 안됩니다. 또한 &lt;code&gt;new_SV()&lt;/code&gt; 를 매크로에서 실제 함수로 변환 하므로 좋아하는 디버거를 사용하여 성가신 SV가 할당 된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c36a989390f694a86b3a7b319006e18a55b93a" translate="yes" xml:space="preserve">
          <source>, you could offload all that merging and sorting into your operating system's own &lt;code&gt;sort&lt;/code&gt; command by opening a pipe directly into its output, and get to work that much faster.</source>
          <target state="translated">, 파이프를 출력으로 직접 열어 운영 체제의 자체 &lt;code&gt;sort&lt;/code&gt; 명령으로 모든 병합 및 정렬을 오프로드 하고 훨씬 빠르게 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3880ec30cc2d5ebf349c1017f97c2cb7881519a" translate="yes" xml:space="preserve">
          <source>, you do not need to change anything. However, for perl to find the library if you use a different path, you need to &lt;code&gt;set PERLLIB_PREFIX&lt;/code&gt; in</source>
          <target state="translated">, 아무것도 변경할 필요가 없습니다. 그러나 다른 경로를 사용하는 경우 perl이 라이브러리를 찾으려면 &lt;code&gt;set PERLLIB_PREFIX&lt;/code&gt; 를 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="022efe6a8ac93e208088ce727015f5bc2ef4dbd9" translate="yes" xml:space="preserve">
          <source>, you may need to be extra careful when running Configure to not to confuse Configure and Perl about which libraries to use. Being confused will show up for example as &quot;dyld&quot; errors about symbol problems, for example during &quot;make test&quot;. The safest bet is to run Configure as</source>
          <target state="translated">사용할 라이브러리에 대해 Configure 및 Perl을 혼동하지 않도록 Configure를 실행할 때 특히주의해야합니다. 혼동되면 예를 들어 &quot;make test&quot;와 같이 심볼 문제에 대한 &quot;dyld&quot;오류로 표시됩니다. 가장 안전한 방법은 다음으로 구성을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="021d52a6c6807f7976d981e9998715c511d43a0f" translate="yes" xml:space="preserve">
          <source>, you may need to reboot in between. Check EMX runtime by running</source>
          <target state="translated">사이에 재부팅해야 할 수도 있습니다. 다음을 실행하여 EMX 런타임을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5e7e307de07db29b07b1256c40e790d188182a74" translate="yes" xml:space="preserve">
          <source>, you may prefer to read &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">, 당신은 &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; 를 읽는 것을 선호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a357b8113a9e22a3eef60456621417078f84daeb" translate="yes" xml:space="preserve">
          <source>, you must explicitly &lt;code&gt;share()&lt;/code&gt; variables between the threads.</source>
          <target state="translated">스레드간에 변수를 명시 적으로 &lt;code&gt;share()&lt;/code&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a4cfad2d578d98a081e5b91f17f3d149edfc150" translate="yes" xml:space="preserve">
          <source>, you need to change the path following the &lt;code&gt;-I&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-I&lt;/code&gt; 다음에 경로를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35017a6e3c131f7bdfef6a610d63fbd565947e16" translate="yes" xml:space="preserve">
          <source>, you need to change the path following the &lt;code&gt;-I&lt;/code&gt;.</source>
          <target state="translated">, &lt;code&gt;-I&lt;/code&gt; 다음에 경로를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a08a1ac95983f38539380ed39b4f27bf1fbb7125" translate="yes" xml:space="preserve">
          <source>, you probably don't expect it to run on both Unix and CP/M.)</source>
          <target state="translated">, 아마도 유닉스와 CP / M 모두에서 실행될 것으로 기대하지는 않을 것입니다.)</target>
        </trans-unit>
        <trans-unit id="a2d62578b1a9440577c8f95b2ea11ee98fbc944b" translate="yes" xml:space="preserve">
          <source>, you should always try to use</source>
          <target state="translated">, 당신은 항상 사용하려고합니다</target>
        </trans-unit>
        <trans-unit id="80d72f99e8c254f3d7a046575ea8e94531af8c78" translate="yes" xml:space="preserve">
          <source>, you should expect a bit of whimsy.</source>
          <target state="translated">약간의 기발한 기대를해야합니다.</target>
        </trans-unit>
        <trans-unit id="87c1c3490c4a0eecd8de20c3cc69883c07b4ba2e" translate="yes" xml:space="preserve">
          <source>, you will need to run &lt;code&gt;make regen_headers&lt;/code&gt; to force a rebuild of</source>
          <target state="translated">, &lt;code&gt;make regen_headers&lt;/code&gt; 를 실행해야합니다. 를</target>
        </trans-unit>
        <trans-unit id="fe63382b1e40b321c4efec02e51e7ac510a9674a" translate="yes" xml:space="preserve">
          <source>, you will see that it returns an &lt;code&gt;ADDOP&lt;/code&gt; token.</source>
          <target state="translated">, &lt;code&gt;ADDOP&lt;/code&gt; 토큰을 반환하는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d419e3c5bc7f5ea63240258fff8fb0654e4cb8f" translate="yes" xml:space="preserve">
          <source>, you'll have to rebuild Perl to incorporate a new extension. You should edit the main</source>
          <target state="translated">새 확장을 통합하려면 Perl을 다시 빌드해야합니다. 메인을 편집해야합니다</target>
        </trans-unit>
        <trans-unit id="ce52b2b3c8d31f579675006498299716435e428b" translate="yes" xml:space="preserve">
          <source>, you'll probably need to subclass &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; too, or else it'll never get used.</source>
          <target state="translated">, 당신은 아마도 &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 를 서브 클래스해야 할 것입니다. 그렇지 않으면 결코 사용되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fdf357edc958470810c296ee519d97c4d17b676d" translate="yes" xml:space="preserve">
          <source>, you'll probably need to subclass &lt;a href=&quot;grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; too, or else it'll never get used.</source>
          <target state="translated">&lt;a href=&quot;grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt; 도 서브 클래 싱해야합니다. 그렇지 않으면 절대 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ce53fda25a5521f4426b98fc34aff8c177f37f2" translate="yes" xml:space="preserve">
          <source>, you'll see the results of using</source>
          <target state="translated">, 사용 결과가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="3085b957b5d3ec5b39e504d18f16596194b3898c" translate="yes" xml:space="preserve">
          <source>, your issue is likely to receive more attention. You may want to start with &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for pointers to common traps that new (and experienced) Perl programmers run into.</source>
          <target state="translated">, 문제가 더 많은 관심을받을 것으로 보입니다. 새로운 Perl 프로그래머가 경험하는 일반적인 트랩에 대한 포인터를 &lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; 으로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="001b22edb2fbe2a87d8cf96a1c82ed43978ed889" translate="yes" xml:space="preserve">
          <source>,...) was.</source>
          <target state="translated">,...) 였다.</target>
        </trans-unit>
        <trans-unit id="ad72be5c0d7fc1b8f77fe6354bc971428558be05" translate="yes" xml:space="preserve">
          <source>,...params...) can give up with:</source>
          <target state="translated">, ... params ...)는 다음을 포기할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ec37b4898d8fa711d06edd7a451aef6a2e60168" translate="yes" xml:space="preserve">
          <source>,...params...) gives up and calls:</source>
          <target state="translated">, ... params ...) 포기하고 호출 :</target>
        </trans-unit>
        <trans-unit id="722cba868d267a82e7010bf92e684897c598bb02" translate="yes" xml:space="preserve">
          <source>,as that program depends on functionality which the test file itself is testing.</source>
          <target state="translated">이 프로그램은 테스트 파일 자체가 테스트하는 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3bc15c8aae3e4124dd409035f32ea2fd6835efc9" translate="yes" xml:space="preserve">
          <source>-</source>
          <target state="translated">-</target>
        </trans-unit>
        <trans-unit id="92ec08014ef6e3572ce18cd210390b5494877bb0" translate="yes" xml:space="preserve">
          <source>- Home directory.</source>
          <target state="translated">-홈 디렉토리.</target>
        </trans-unit>
        <trans-unit id="bc43692f24635fad130f4c0b7605b093da1c6edc" translate="yes" xml:space="preserve">
          <source>- Root for accessing some special files, i.e.</source>
          <target state="translated">-일부 특수 파일에 액세스하기위한 루트, 즉</target>
        </trans-unit>
        <trans-unit id="3173574745b2a94d3ecbd9aad3aac008e1c75cf4" translate="yes" xml:space="preserve">
          <source>- Rows/cols for console.</source>
          <target state="translated">-콘솔 용 행 / 콜.</target>
        </trans-unit>
        <trans-unit id="2a8384c45900eafb56b7372e12c87d95403210dd" translate="yes" xml:space="preserve">
          <source>- Size for console font.</source>
          <target state="translated">-콘솔 글꼴의 크기.</target>
        </trans-unit>
        <trans-unit id="ec35a1fcb1bf308cd068a9bee9a8176d037f75a7" translate="yes" xml:space="preserve">
          <source>- Tempdir.</source>
          <target state="translated">-Tempdir.</target>
        </trans-unit>
        <trans-unit id="46c7d034edab58069ac51b4607fbe57881cd6eda" translate="yes" xml:space="preserve">
          <source>- make official location for installed *distributions*, which can contain tests, etc.</source>
          <target state="translated">-테스트 등을 포함 할 수있는 설치된 * 배포 물 *의 공식 위치를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a58249eb112a301215e90f4449910a61cde2399f" translate="yes" xml:space="preserve">
          <source>- may fail on recent cygwin installs.</source>
          <target state="translated">-최근 cygwin 설치에서 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa47440f5821f7fcd42136d522f634642510d036" translate="yes" xml:space="preserve">
          <source>- most probably RSX - decided to implement.</source>
          <target state="translated">-아마도 RSX-구현하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="586ed566ba05975ffadf370f1c6ecf01acb6d01a" translate="yes" xml:space="preserve">
          <source>- non-zero if the current XSUB has any aliases declared with &lt;code&gt;ALIAS&lt;/code&gt; .</source>
          <target state="translated">-현재 XSUB에 &lt;code&gt;ALIAS&lt;/code&gt; 로 선언 된 별칭이 있으면 0이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="36721d3a2a547695d4793029011114667064f57d" translate="yes" xml:space="preserve">
          <source>- non-zero if the current XSUB has any aliases declared with &lt;code&gt;ALIAS&lt;/code&gt;.</source>
          <target state="translated">-현재 XSUB에 &lt;code&gt;ALIAS&lt;/code&gt; 로 선언 된 별칭이있는 경우 0이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c30b5265745c008d5265e386cbdf1dab87c47bde" translate="yes" xml:space="preserve">
          <source>- or with Perl!</source>
          <target state="translated">-아니면 펄!</target>
        </trans-unit>
        <trans-unit id="4e30556a5f49da4f43234bec9f7aaab8f8cf28e1" translate="yes" xml:space="preserve">
          <source>- possibly separate out test-time prereqs, complications include: can tests be meaningfully preserved for later running? are test-time prereqs in addition to build-time, or exclusive?</source>
          <target state="translated">-테스트 시간 전제 조건을 분리 할 수 ​​있습니다. 합병증에는 다음이 포함됩니다. 테스트를 나중에 실행하기 위해 의미있게 보존 할 수 있습니까? 빌드 시간에 추가로 테스트 시간 전제 조건이 있습니까, 아니면 독점입니까?</target>
        </trans-unit>
        <trans-unit id="6681529bb3ccd36ba6275ff29adce31783c01d2c" translate="yes" xml:space="preserve">
          <source>- see &lt;a href=&quot;#Indexing-distributions-a-la-PAUSE&quot;&gt;&quot;Indexing distributions a la PAUSE&quot;&lt;/a&gt; in the implementors notes for more information.</source>
          <target state="translated">- 자세한 정보는 구현 자 노트의 &lt;a href=&quot;#Indexing-distributions-a-la-PAUSE&quot;&gt;&quot;인덱싱 배포 a la PAUSE&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a10b5776a842eeeedbba99e8e17c5c9a17237c7" translate="yes" xml:space="preserve">
          <source>- see &lt;a href=&quot;https://github.com/Perl/perl5/issues/10750&quot;&gt;https://github.com/Perl/perl5/issues/10750&lt;/a&gt;</source>
          <target state="translated">- 참조 &lt;a href=&quot;https://github.com/Perl/perl5/issues/10750&quot;&gt;https://github.com/Perl/perl5/issues/10750&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a5e7bde75d15d42f045f6c58b079f3857fc8edd" translate="yes" xml:space="preserve">
          <source>- see &lt;a href=&quot;https://rt.perl.org/Ticket/Display.html?id=78502&quot;&gt;https://rt.perl.org/Ticket/Display.html?id=78502&lt;/a&gt;</source>
          <target state="translated">- 참조 &lt;a href=&quot;https://rt.perl.org/Ticket/Display.html?id=78502&quot;&gt;https://rt.perl.org/Ticket/Display.html?id=78502&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eb095bd84343fa039df7c15c40c25123fcea513" translate="yes" xml:space="preserve">
          <source>- the argument stack offset of the argument. ie. 0 for the first argument, etc.</source>
          <target state="translated">-인수의 인수 스택 오프셋 즉. 첫 번째 인수 등의 경우 0</target>
        </trans-unit>
        <trans-unit id="b6fd27381e71b1b032ec8f7e7eff0c7d9ea88d03" translate="yes" xml:space="preserve">
          <source>- the full name of the XSUB, with including the &lt;code&gt;PACKAGE&lt;/code&gt; name, with any &lt;code&gt;PREFIX&lt;/code&gt; stripped. This is the non-ALIAS name.</source>
          <target state="translated">- 포함와 XSUB의 전체 이름, &lt;code&gt;PACKAGE&lt;/code&gt; 하나와, 이름을 &lt;code&gt;PREFIX&lt;/code&gt; 제거. 이것은 별칭이 아닌 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ac306b045d6143c752e53a46375c4935a0210024" translate="yes" xml:space="preserve">
          <source>- the name of the input or output variable, eg. RETVAL for return values.</source>
          <target state="translated">-입력 또는 출력 변수의 이름 (예 : 리턴 값에 대한 RETVAL</target>
        </trans-unit>
        <trans-unit id="98a3328bb076d8bd2503f9a31ae579ee61669de1" translate="yes" xml:space="preserve">
          <source>- the package specified by the most recent &lt;code&gt;PACKAGE&lt;/code&gt; keyword.</source>
          <target state="translated">-가장 최근의 &lt;code&gt;PACKAGE&lt;/code&gt; 키워드로 지정된 패키지 .</target>
        </trans-unit>
        <trans-unit id="f124ed3063522cd2ff8b8f4829e2a95edb5ad519" translate="yes" xml:space="preserve">
          <source>- the raw C type of the parameter, any &lt;code&gt;:&lt;/code&gt; replaced with &lt;code&gt;_&lt;/code&gt; . e.g. for a type of &lt;code&gt;Foo::Bar&lt;/code&gt; ,</source>
          <target state="translated">- 매개 변수의 원시 C 타입은, 어떤이 &lt;code&gt;:&lt;/code&gt; 로 대체 &lt;code&gt;_&lt;/code&gt; . 예를 들어 &lt;code&gt;Foo::Bar&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="ff9ef50c9a5f15c75392db11b12752cdcd7f93a8" translate="yes" xml:space="preserve">
          <source>- the raw C type of the parameter, any &lt;code&gt;:&lt;/code&gt; replaced with &lt;code&gt;_&lt;/code&gt;. e.g. for a type of &lt;code&gt;Foo::Bar&lt;/code&gt;,</source>
          <target state="translated">-매개 변수의 원시 C 유형, any &lt;code&gt;:&lt;/code&gt; &lt;code&gt;_&lt;/code&gt; 로 대체 . 예를 들어 &lt;code&gt;Foo::Bar&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="76a588dc109d4b97adb8746f1e4fa8bce8a72431" translate="yes" xml:space="preserve">
          <source>- the stack entry, that the parameter is input from or output to, e.g. &lt;code&gt;ST(0)&lt;/code&gt;</source>
          <target state="translated">-스택 엔트리, 매개 변수가 입력 또는 출력되는 것, 예 : &lt;code&gt;ST(0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9cef40f084c3c3cb1207d8771f055a5a821202e" translate="yes" xml:space="preserve">
          <source>- the supplied type with &lt;code&gt;*&lt;/code&gt; replaced with &lt;code&gt;Ptr&lt;/code&gt; . e.g. for a type of &lt;code&gt;Foo*&lt;/code&gt; ,</source>
          <target state="translated">- &lt;code&gt;*&lt;/code&gt; 가 &lt;code&gt;Ptr&lt;/code&gt; 로 대체 된 제공된 유형 . 예를 들어 &lt;code&gt;Foo*&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="a2658124eb09e0e6dbc56f97854aaa96beef3464" translate="yes" xml:space="preserve">
          <source>- the supplied type with &lt;code&gt;*&lt;/code&gt; replaced with &lt;code&gt;Ptr&lt;/code&gt;. e.g. for a type of &lt;code&gt;Foo*&lt;/code&gt;,</source>
          <target state="translated">-제공된 유형은 &lt;code&gt;*&lt;/code&gt; 가 &lt;code&gt;Ptr&lt;/code&gt; 로 대체됩니다 . 예를 들어 &lt;code&gt;Foo*&lt;/code&gt; 유형의 경우</target>
        </trans-unit>
        <trans-unit id="c85eb1c4ce6755d438f46363a51bca99a55296fd" translate="yes" xml:space="preserve">
          <source>-%s is not implemented on a File::stat object</source>
          <target state="translated">-% s는 File :: stat 개체에 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="66bb4d83c0add62ff40fbc7293cb0e0652fe9572" translate="yes" xml:space="preserve">
          <source>-%s on unopened filehandle %s</source>
          <target state="translated">-% s (열리지 않은 파일 핸들 % s)</target>
        </trans-unit>
        <trans-unit id="a3d0e64f62d0aa67fc64844708eb009021bf6273" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Bless(</source>
          <target state="translated">-&amp;gt;Bless(</target>
        </trans-unit>
        <trans-unit id="f0722d974b50edb39d61682893cf91b3ae50c4aa" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Deepcopy(</source>
          <target state="translated">-&amp;gt;Deepcopy(</target>
        </trans-unit>
        <trans-unit id="5c0edfb04a76d90d803deb5fa319ba2663d74d18" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Deparse(</source>
          <target state="translated">-&amp;gt;Deparse(</target>
        </trans-unit>
        <trans-unit id="46853692fb69fcc992b6b4ff256e26998ad6aad6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Dump</source>
          <target state="translated">-&amp;gt;Dump</target>
        </trans-unit>
        <trans-unit id="5784853989f6ebd5b873dce937c9d73bd2876587" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Dump(</source>
          <target state="translated">-&amp;gt;Dump(</target>
        </trans-unit>
        <trans-unit id="dba6f17f00a3608b5502035af168005f1d2e47c7" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Freezer(</source>
          <target state="translated">-&amp;gt;Freezer(</target>
        </trans-unit>
        <trans-unit id="f1b9e5eef8b3fe06ef615011915677eb670538c6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Indent(</source>
          <target state="translated">-&amp;gt;Indent(</target>
        </trans-unit>
        <trans-unit id="31b6bc539e0d7c7b5901a7311b172dd6898b322b" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Maxdepth(</source>
          <target state="translated">-&amp;gt;Maxdepth(</target>
        </trans-unit>
        <trans-unit id="2d566bc2e1d524d8205bee44364bc31e0a8e9197" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Maxrecurse(</source>
          <target state="translated">-&amp;gt;Maxrecurse(</target>
        </trans-unit>
        <trans-unit id="30c7c29da8a4c244b680992630d60ee9fd854104" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Names(</source>
          <target state="translated">-&amp;gt;Names(</target>
        </trans-unit>
        <trans-unit id="413ec10070e2ce7e4378ffb0f5cbabab43709ca5" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Pad(</source>
          <target state="translated">-&amp;gt;Pad(</target>
        </trans-unit>
        <trans-unit id="e06d02c9fdb1747ec2039cea96f30fea04b5b25b" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Pair(</source>
          <target state="translated">-&amp;gt;Pair(</target>
        </trans-unit>
        <trans-unit id="7e25804050e4aa77c61e8ee63bad263c485c56c6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Purity(</source>
          <target state="translated">-&amp;gt;Purity(</target>
        </trans-unit>
        <trans-unit id="56a023253cf1c514dba0cbce82b8b3814335f445" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Quotekeys(</source>
          <target state="translated">-&amp;gt;Quotekeys(</target>
        </trans-unit>
        <trans-unit id="d0e96e7ee3eaa848b0019dd15c7b0898915ebead" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Reset</source>
          <target state="translated">-&amp;gt;Reset</target>
        </trans-unit>
        <trans-unit id="f6e1d3513dca6e864199d6f50d923904e922a65d" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Seen(</source>
          <target state="translated">-&amp;gt;Seen(</target>
        </trans-unit>
        <trans-unit id="c1f9dd12120a54d49e86f3d8be13375c987724d2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Sortkeys(</source>
          <target state="translated">-&amp;gt;Sortkeys(</target>
        </trans-unit>
        <trans-unit id="d589d85ec436baef14dce8d2143c792a949aba0d" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Sparseseen(</source>
          <target state="translated">-&amp;gt;Sparseseen(</target>
        </trans-unit>
        <trans-unit id="0057fcbaafc36dc5c0f396e5d6075530bfac1848" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Terse(</source>
          <target state="translated">-&amp;gt;Terse(</target>
        </trans-unit>
        <trans-unit id="71b97fccb0554a000a087174f590ad69f5d41fc2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Toaster(</source>
          <target state="translated">-&amp;gt;Toaster(</target>
        </trans-unit>
        <trans-unit id="73a061c2d64a288ee13a8c231396eeb85d92a7ce" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Trailingcomma(</source>
          <target state="translated">-&amp;gt;Trailingcomma(</target>
        </trans-unit>
        <trans-unit id="b282f78e8ba680fc5f27fc13dba94b8c3b531e79" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Useperl(</source>
          <target state="translated">-&amp;gt;Useperl(</target>
        </trans-unit>
        <trans-unit id="4c7197d6a5caad4a177ca1b9e2de81de03660a61" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Useqq(</source>
          <target state="translated">-&amp;gt;Useqq(</target>
        </trans-unit>
        <trans-unit id="52bbdbdc2d57eba80469c834be7d9a9ff43f4fd6" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Values(</source>
          <target state="translated">-&amp;gt;Values(</target>
        </trans-unit>
        <trans-unit id="36470c86321f280aefd62b4ed122aaace7e7a771" translate="yes" xml:space="preserve">
          <source>-&amp;gt;Varname(</source>
          <target state="translated">-&amp;gt;Varname(</target>
        </trans-unit>
        <trans-unit id="35fb17f9530c86268b78d97fdb827f559bc940eb" translate="yes" xml:space="preserve">
          <source>-&amp;gt;cat_decode($destination, $octets, $offset, $terminator [,$check])</source>
          <target state="translated">-&amp;gt;cat_decode($destination, $octets, $offset, $terminator [,$check])</target>
        </trans-unit>
        <trans-unit id="fb9daddffd9b981f6281405c1c04027e176594b0" translate="yes" xml:space="preserve">
          <source>-&amp;gt;decode($octets [,$check])</source>
          <target state="translated">-&amp;gt;decode($octets [,$check])</target>
        </trans-unit>
        <trans-unit id="acdd1abb9e34c25319ad5264ae027ffa2daac48c" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue()</source>
          <target state="translated">-&amp;gt;dequeue()</target>
        </trans-unit>
        <trans-unit id="4d7aefbfbe740bd78dd5d84db5e40f6cd5e76192" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue(COUNT)</source>
          <target state="translated">-&amp;gt;dequeue(COUNT)</target>
        </trans-unit>
        <trans-unit id="cea351acb884a2f074f92c6120b147de295f77ef" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue_nb()</source>
          <target state="translated">-&amp;gt;dequeue_nb()</target>
        </trans-unit>
        <trans-unit id="43a7e952ee08d9bccce1e2571162cd37a77f0862" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue_nb(COUNT)</source>
          <target state="translated">-&amp;gt;dequeue_nb(COUNT)</target>
        </trans-unit>
        <trans-unit id="d3cf565d010a4937dada68e1d74e0bb9e9dbd97e" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue_timed(TIMEOUT)</source>
          <target state="translated">-&amp;gt;dequeue_timed(TIMEOUT)</target>
        </trans-unit>
        <trans-unit id="d9c7bc7b9adebf5460dce967ce74b1f2ff09e645" translate="yes" xml:space="preserve">
          <source>-&amp;gt;dequeue_timed(TIMEOUT, COUNT)</source>
          <target state="translated">-&amp;gt;dequeue_timed(TIMEOUT, COUNT)</target>
        </trans-unit>
        <trans-unit id="f8ec4a2aaa5d89ee457c079d620114c01cedc119" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down()</source>
          <target state="translated">-&amp;gt;down()</target>
        </trans-unit>
        <trans-unit id="e280be72b096fcafbbcb6c26f34f8ec25ebec1f5" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down(NUMBER)</source>
          <target state="translated">-&amp;gt;down(NUMBER)</target>
        </trans-unit>
        <trans-unit id="959fcbb597f256ca764340b992b42a780d9b10eb" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_force()</source>
          <target state="translated">-&amp;gt;down_force()</target>
        </trans-unit>
        <trans-unit id="d35de91fc5b908072b3cc1e653b4c1130a10f5bc" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_force(NUMBER)</source>
          <target state="translated">-&amp;gt;down_force(NUMBER)</target>
        </trans-unit>
        <trans-unit id="54a3c00e26ade542b380f6fb5438c5d24a049741" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_nb()</source>
          <target state="translated">-&amp;gt;down_nb()</target>
        </trans-unit>
        <trans-unit id="47efab5e5fdd527498b687a2c89c75cfe4286391" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_nb(NUMBER)</source>
          <target state="translated">-&amp;gt;down_nb(NUMBER)</target>
        </trans-unit>
        <trans-unit id="baca2a6a08394e245be94c0cffcbeb363c878eeb" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_timed(TIMEOUT)</source>
          <target state="translated">-&amp;gt;down_timed(TIMEOUT)</target>
        </trans-unit>
        <trans-unit id="0670ccbb5cb182c387c366ac98bb22a66cd4c593" translate="yes" xml:space="preserve">
          <source>-&amp;gt;down_timed(TIMEOUT, NUMBER)</source>
          <target state="translated">-&amp;gt; 다운 타임 (TIMEOUT, NUMBER)</target>
        </trans-unit>
        <trans-unit id="bcacd24e0c5e07cc196ddcc04c77b538245a1e7c" translate="yes" xml:space="preserve">
          <source>-&amp;gt;encode($string [,$check])</source>
          <target state="translated">-&amp;gt;encode($string [,$check])</target>
        </trans-unit>
        <trans-unit id="a9594b538714946f3a717ab42bd21d5b9f5f9da1" translate="yes" xml:space="preserve">
          <source>-&amp;gt;end()</source>
          <target state="translated">-&amp;gt;end()</target>
        </trans-unit>
        <trans-unit id="9506efffd1fa092e7f0ef9285a047d84fe11f0fb" translate="yes" xml:space="preserve">
          <source>-&amp;gt;enqueue(LIST)</source>
          <target state="translated">-&amp;gt;enqueue(LIST)</target>
        </trans-unit>
        <trans-unit id="13d2304da8edb26745fca41a477e98754d871cc0" translate="yes" xml:space="preserve">
          <source>-&amp;gt;extract()</source>
          <target state="translated">-&amp;gt;extract()</target>
        </trans-unit>
        <trans-unit id="6a1f138b6ed0a54949392a723847801722030479" translate="yes" xml:space="preserve">
          <source>-&amp;gt;extract(INDEX)</source>
          <target state="translated">-&amp;gt;extract(INDEX)</target>
        </trans-unit>
        <trans-unit id="88e68114691d92bba226890e6c606ea2bb77adf0" translate="yes" xml:space="preserve">
          <source>-&amp;gt;extract(INDEX, COUNT)</source>
          <target state="translated">-&amp;gt; 추출 (INDEX, COUNT)</target>
        </trans-unit>
        <trans-unit id="d2af4afeef504e2df2e4aec2276c4e54268215a3" translate="yes" xml:space="preserve">
          <source>-&amp;gt;insert(INDEX, LIST)</source>
          <target state="translated">-&amp;gt; 삽입 (INDEX, LIST)</target>
        </trans-unit>
        <trans-unit id="162565272f324c21e5dc34632217143c2c4d7582" translate="yes" xml:space="preserve">
          <source>-&amp;gt;limit</source>
          <target state="translated">-&amp;gt;limit</target>
        </trans-unit>
        <trans-unit id="6ef6b7dd1a5dafda1e37fde8e3e49c89a09bc0fa" translate="yes" xml:space="preserve">
          <source>-&amp;gt;mime_name</source>
          <target state="translated">-&amp;gt;mime_name</target>
        </trans-unit>
        <trans-unit id="973c06c03cb669af5e35f7d4dc026750fa74ebed" translate="yes" xml:space="preserve">
          <source>-&amp;gt;name</source>
          <target state="translated">-&amp;gt;name</target>
        </trans-unit>
        <trans-unit id="f18662b6b65a2a3a5333aaa90290cd700c1cbf21" translate="yes" xml:space="preserve">
          <source>-&amp;gt;needs_lines()</source>
          <target state="translated">-&amp;gt;needs_lines()</target>
        </trans-unit>
        <trans-unit id="f766e349e601c262c2ca67b30ebb9b52181666d2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new(</source>
          <target state="translated">-&amp;gt;new(</target>
        </trans-unit>
        <trans-unit id="842d04ade7a944de7b63fb54f6e1728efbe69fc7" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new()</source>
          <target state="translated">-&amp;gt;new()</target>
        </trans-unit>
        <trans-unit id="fa657bcce0cc7fe5acc50debb5fcfb4b7bdb8fc4" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new().</source>
          <target state="translated">-&amp;gt;new().</target>
        </trans-unit>
        <trans-unit id="ca35a1a50210567070c4cfbf08aae7e9cce265b2" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new(LIST)</source>
          <target state="translated">-&amp;gt;new(LIST)</target>
        </trans-unit>
        <trans-unit id="d1bb77b97b0ebcefb9cde8c53c5e6317ebcb3cee" translate="yes" xml:space="preserve">
          <source>-&amp;gt;new(NUMBER)</source>
          <target state="translated">-&amp;gt;new(NUMBER)</target>
        </trans-unit>
        <trans-unit id="f16847bb22747fb7d3af10183f0cc2affeeec244" translate="yes" xml:space="preserve">
          <source>-&amp;gt;peek()</source>
          <target state="translated">-&amp;gt;peek()</target>
        </trans-unit>
        <trans-unit id="94046a4fbdc442bc7514e1de57b7ec0410d9595b" translate="yes" xml:space="preserve">
          <source>-&amp;gt;peek(INDEX)</source>
          <target state="translated">-&amp;gt;peek(INDEX)</target>
        </trans-unit>
        <trans-unit id="f4415914a21aacf867626430495be4c2a6f7745d" translate="yes" xml:space="preserve">
          <source>-&amp;gt;pending()</source>
          <target state="translated">-&amp;gt;pending()</target>
        </trans-unit>
        <trans-unit id="9e3cb4581bccdebf2e3e87af880d0d8f9663f1e5" translate="yes" xml:space="preserve">
          <source>-&amp;gt;perlio_ok()</source>
          <target state="translated">-&amp;gt;perlio_ok()</target>
        </trans-unit>
        <trans-unit id="03822a827b55f1cf6d57bfec6366994a07686513" translate="yes" xml:space="preserve">
          <source>-&amp;gt;renew</source>
          <target state="translated">-&amp;gt;renew</target>
        </trans-unit>
        <trans-unit id="ba668c651ef8229684bda7d2a29d614b424db530" translate="yes" xml:space="preserve">
          <source>-&amp;gt;renewed</source>
          <target state="translated">-&amp;gt;renewed</target>
        </trans-unit>
        <trans-unit id="5065a3018b9da2ea1d8c8103d02620427dcbdeba" translate="yes" xml:space="preserve">
          <source>-&amp;gt;up()</source>
          <target state="translated">-&amp;gt;up()</target>
        </trans-unit>
        <trans-unit id="77d9721fba7632668a4b6dd2e5d9907ce2faf9c3" translate="yes" xml:space="preserve">
          <source>-&amp;gt;up(NUMBER)</source>
          <target state="translated">-&amp;gt;up(NUMBER)</target>
        </trans-unit>
        <trans-unit id="2d61ca753759230bedde8cc40a1707eb6fef4cc2" translate="yes" xml:space="preserve">
          <source>-&amp;tau;&amp;omicron;&amp;mu;&amp;omicron;&amp;sigmaf;</source>
          <target state="translated">-&amp;tau;&amp;omicron;&amp;mu;&amp;omicron;&amp;sigmaf;</target>
        </trans-unit>
        <trans-unit id="c73415d27a902ee544cc97c1b064046aa369c3f6" translate="yes" xml:space="preserve">
          <source>-- First Networking Truth, RFC 1925</source>
          <target state="translated">-- First Networking Truth, RFC 1925</target>
        </trans-unit>
        <trans-unit id="d7ca49c228dda32aff593d5c4091da8d43e4d365" translate="yes" xml:space="preserve">
          <source>-- Harald Tveit Alvestrand, in RFC 1766, &quot;Tags for the Identification of Languages&quot;</source>
          <target state="translated">-Harald Tveit Alvestrand, RFC 1766, &quot;언어 식별을위한 태그&quot;</target>
        </trans-unit>
        <trans-unit id="7237e0004144ef0ea4f5752d2e69f5cec1dfdcf5" translate="yes" xml:space="preserve">
          <source>-- The Eighth Networking Truth, from RFC 1925</source>
          <target state="translated">-RFC 1925의 여덟 번째 네트워킹 진실</target>
        </trans-unit>
        <trans-unit id="99ad6b1974639a6ad49066e89047b76e4ed28ab6" translate="yes" xml:space="preserve">
          <source>-- merits special attention. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&quot;&quot;&lt;/code&gt; and the entire file is read in with that setting, any sequence of consecutive newlines &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; at the beginning of the file is discarded. With the exception of the final record in the file, each sequence of characters ending in two or more newlines is treated as one record and is read in to end in exactly two newlines. If the last record in the file ends in zero or one consecutive newlines, that record is read in with that number of newlines. If the last record ends in two or more consecutive newlines, it is read in with two newlines like all preceding records.</source>
          <target state="translated">-특별한주의가 필요합니다. 때 &lt;code&gt;$/&lt;/code&gt; 로 설정 &lt;code&gt;&quot;&quot;&lt;/code&gt; 전체 파일이 해당 설정과에서 읽기, 연속 개행 문자의 시퀀스는 &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 파일의 시작 부분에 삭제됩니다. 파일의 최종 레코드를 제외하고 두 개 이상의 줄 바꿈으로 끝나는 각 문자 시퀀스는 하나의 레코드로 처리되고 정확히 두 줄 바꿈으로 끝날 때까지 읽혀집니다. 파일의 마지막 레코드가 0 개 또는 1 개의 연속 된 줄 바꿈으로 끝나는 경우 해당 레코드는 해당 줄 바꿈 수로 읽혀집니다. 마지막 레코드가 두 개 이상의 연속 된 줄 바꿈으로 끝나는 경우 모든 이전 레코드와 마찬가지로 두 줄 바꿈으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8e840705228b64bcf8b19330a928bbb3f1a9bf97" translate="yes" xml:space="preserve">
          <source>-- see 1.1.1 U+FFFE, UTS #35 (LDML) Part 5: Collation.</source>
          <target state="translated">-1.1.1 U + FFFE, UTS # 35 (LDML) 파트 5 : 데이터 정렬 참조.</target>
        </trans-unit>
        <trans-unit id="3a6343e91df97da6c3ef931cb12700fb150ca898" translate="yes" xml:space="preserve">
          <source>-- see 2.4 Tailored noncharacter weights, UTS #35 (LDML) Part 5: Collation.</source>
          <target state="translated">-2.4 맞춤형 비 문자 가중치, UTS # 35 (LDML) 파트 5 : 데이터 정렬을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05b2af8bbbc3b7f147e3e677dc52ca28d10188c3" translate="yes" xml:space="preserve">
          <source>-- see 3.12 Special-Purpose Commands, UTS #35 (LDML) Part 5: Collation.</source>
          <target state="translated">-3.12 특수 목적 명령, UTS # 35 (LDML) 파트 5 : 데이터 정렬 참조.</target>
        </trans-unit>
        <trans-unit id="585f1706ae18bcdc63ca722b491c6df4f0dde510" translate="yes" xml:space="preserve">
          <source>-- see 3.2.2 Alternate Weighting, version 8 of UTS #10</source>
          <target state="translated">-UTS # 10의 3.2.2 대체 가중치 버전 8 참조</target>
        </trans-unit>
        <trans-unit id="3a8cc74f261c3d51571350ca2868bd10ef52769b" translate="yes" xml:space="preserve">
          <source>-- see 3.4 Backward Accents, UTS #10.</source>
          <target state="translated">-3.4 백 워드 악센트, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="07d3a1d428fe3461f8d9c80032441d87278b9654" translate="yes" xml:space="preserve">
          <source>-- see 3.5 Rearrangement, UTS #10.</source>
          <target state="translated">-3.5 재 배열, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="5ee3edd6f51f1ea7fa47e8f98453c7d17eaea820" translate="yes" xml:space="preserve">
          <source>-- see 3.6 Variable Weighting, UTS #10.</source>
          <target state="translated">-3.6 가변 가중치, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="cd9a420c85ac25af87c2565ef4416f3f6d6ba5b1" translate="yes" xml:space="preserve">
          <source>-- see 3.8 Default Unicode Collation Element Table, UTS #10.</source>
          <target state="translated">-3.8 기본 유니 코드 데이터 정렬 요소 표, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a697b3f4a09d78b35f6bcaf2e5ac4b9c059bb5f9" translate="yes" xml:space="preserve">
          <source>-- see 3.8.2 Well-Formedness of the DUCET, 4.2 Produce Array, UTS #10.</source>
          <target state="translated">-3.8.2 DUCET의 잘 형성됨, 4.2 생산 배열, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="7b4d0507deac646ef7351b3ecb3ba07f748dfa61" translate="yes" xml:space="preserve">
          <source>-- see 4.1 Normalize, UTS #10.</source>
          <target state="translated">-4.1 정규화, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="1cb743acecb2ab375f527cbafc47c0bbe3cabad0" translate="yes" xml:space="preserve">
          <source>-- see 4.3 Form Sort Key, UTS #10.</source>
          <target state="translated">-4.3 양식 정렬 키, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cdabeb0028ef19f65abe871e2f9a75ea7690910d" translate="yes" xml:space="preserve">
          <source>-- see 5 Tailoring; 9.1 Allkeys File Format, UTS #10.</source>
          <target state="translated">-5 재봉 참조; 9.1 Allkeys 파일 형식, UTS # 10.</target>
        </trans-unit>
        <trans-unit id="5974db4d3861eb1b0da28b6b74de30e8c4d8e699" translate="yes" xml:space="preserve">
          <source>-- see 5.1 Parametric Tailoring, UTS #10.</source>
          <target state="translated">5.1 파라 메트릭 테일러링, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="3269e638f6b6a348970d76d447ba7f62ead918d9" translate="yes" xml:space="preserve">
          <source>-- see 5.14 Collation Elements, UTS #35.</source>
          <target state="translated">-5.14 데이터 정렬 요소, UTS # 35를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba76558f052a895590fcc20803249a87f4f1a0f2" translate="yes" xml:space="preserve">
          <source>-- see 5.4 Preprocessing, UTS #10.</source>
          <target state="translated">-5.4 전처리, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="e1aeb46917eaf8a02e52c345b2ef987cc9482829" translate="yes" xml:space="preserve">
          <source>-- see 6.3.3 Reducing the Repertoire, UTS #10.</source>
          <target state="translated">-6.3.3 Reducing the Repertoire, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="a41b8036c6ccf65060a4662dca1e11556455fd38" translate="yes" xml:space="preserve">
          <source>-- see 6.3.4 Reducing the Repertoire, UTS #10.</source>
          <target state="translated">-6.3.4 레퍼토리 감소, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="0e79a7c892b3daf587f7a8b3225aabd06c6a3025" translate="yes" xml:space="preserve">
          <source>-- see 6.5 Avoiding Normalization, UTS #10.</source>
          <target state="translated">-6.5 정규화 방지, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7a49b0b256e287ad6547d96d0e85e9098bf1e7" translate="yes" xml:space="preserve">
          <source>-- see 6.6 Case Comparisons, UTS #10.</source>
          <target state="translated">-6.6 사례 비교, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="921de278b720df4682ccde20a8a07d16048240f4" translate="yes" xml:space="preserve">
          <source>-- see 7.1 Derived Collation Elements, UTS #10.</source>
          <target state="translated">7.1 파생 데이터 정렬 요소, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e6189b5fe4e700972d5d0c46522002017f4b74b4" translate="yes" xml:space="preserve">
          <source>-- see 7.1.1 Handling Ill-Formed Code Unit Sequences, UTS #10.</source>
          <target state="translated">-7.1.1 잘못된 형식의 코드 단위 시퀀스 처리, UTS # 10을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9b914c66e4ecd398f8a0454a4abbd3845ef4cdf" translate="yes" xml:space="preserve">
          <source>-- see 7.1.4 Trailing Weights, UTS #10.</source>
          <target state="translated">-7.1.4 후행 무게, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="152aade877325529ccd0de6317a273f029c69056" translate="yes" xml:space="preserve">
          <source>-- see 7.2 Tertiary Weight Table, UTS #10.</source>
          <target state="translated">-7.2 3 차 중량 표, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="800fd8691cb7a6b6fe172573590fed9e2fc75f8f" translate="yes" xml:space="preserve">
          <source>-- see A.3 Deterministic Comparison, UTS #10.</source>
          <target state="translated">-A.3 결정 론적 비교, UTS # 10 참조.</target>
        </trans-unit>
        <trans-unit id="70594be556b0b2420c5652817454d7573669880a" translate="yes" xml:space="preserve">
          <source>-- see suppress contractions in 5.14.11 Special-Purpose Commands, UTS #35 (LDML).</source>
          <target state="translated">-5.14.11 특수 목적 명령, UTS # 35 (LDML)의 수축 억제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a3b88931de0f8a1585b737f1744b827120ed7e3" translate="yes" xml:space="preserve">
          <source>-- they are NOT used for</source>
          <target state="translated">-그들은 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="afe09f38de5b8547467dba38b00faf6ea82e1825" translate="yes" xml:space="preserve">
          <source>-----8&amp;lt;-----/usr/local/bin/yacc-----8&amp;lt;----- #! /usr/bin/sh</source>
          <target state="translated">----- 8 &amp;lt;----- / usr / local / bin / yacc ----- 8 &amp;lt;----- #! / usr / bin / sh</target>
        </trans-unit>
        <trans-unit id="928eb328085d5dd1ea864cbc7fa6fcd93239323f" translate="yes" xml:space="preserve">
          <source>--bringing things to life automatically. Perl saw that the key wasn't in the hash, so it created a new hash entry automatically. Perl saw that you wanted to use the hash value as an array, so it created a new empty array and installed a reference to it in the hash automatically. And as usual, Perl made the array one element longer to hold the new city name.</source>
          <target state="translated">-자동으로 생명을 불어 넣습니다. Perl은 키가 해시에 없다는 것을 알았으므로 새 해시 항목을 자동으로 생성했습니다. Perl은 해시 값을 배열로 사용하기를 원했기 때문에 새로운 빈 배열을 만들고 해시에 대한 참조를 자동으로 설치했습니다. 그리고 평소처럼 Perl은 새 도시 이름을 유지하기 위해 배열을 한 요소 더 길게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="d2ee483d8885043b1d86e8f54b300cc2d0d8aa5d" translate="yes" xml:space="preserve">
          <source>--diff</source>
          <target state="translated">--diff</target>
        </trans-unit>
        <trans-unit id="4c145d5d792c0de7497818416a3583ddc4ef3aed" translate="yes" xml:space="preserve">
          <source>--exec</source>
          <target state="translated">--exec</target>
        </trans-unit>
        <trans-unit id="e69ab1b6739dbe6687f9d0fa8d25e100eaff418c" translate="yes" xml:space="preserve">
          <source>--feature, -f</source>
          <target state="translated">-기능, -f</target>
        </trans-unit>
        <trans-unit id="1080c2b75030b9db6089441c365cd2e618af5b72" translate="yes" xml:space="preserve">
          <source>--help and --version</source>
          <target state="translated">--help와 --version</target>
        </trans-unit>
        <trans-unit id="63e664f3c0b161a2cbf63173f5e4286a40b94c51" translate="yes" xml:space="preserve">
          <source>--htmlcref</source>
          <target state="translated">--htmlcref</target>
        </trans-unit>
        <trans-unit id="02f5609e10ee7026f1e54d036cb62940935a9c3e" translate="yes" xml:space="preserve">
          <source>--libpods in Pod::Html</source>
          <target state="translated">-Pod :: Html의 libpods</target>
        </trans-unit>
        <trans-unit id="de00e86b4b1adf7de42f72b04311752a53fdd076" translate="yes" xml:space="preserve">
          <source>--merge</source>
          <target state="translated">--merge</target>
        </trans-unit>
        <trans-unit id="85bf17ebe87204a1c560eec7e29e5131edbd78fb" translate="yes" xml:space="preserve">
          <source>--no dangling statements allowed. If you want to write conditionals without curly brackets, there are several other ways to do it. The following all do the same thing:</source>
          <target state="translated">-매달린 문장은 허용되지 않습니다. 중괄호없이 조건을 쓰려면 몇 가지 다른 방법이 있습니다. 다음은 모두 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="180267a3a01343dd30c8a524372d694ddfbee330" translate="yes" xml:space="preserve">
          <source>--or--</source>
          <target state="translated">--or--</target>
        </trans-unit>
        <trans-unit id="5f9031d8f64ccf1adae3a5bad83b3f0e15a74b6b" translate="yes" xml:space="preserve">
          <source>--rules</source>
          <target state="translated">--rules</target>
        </trans-unit>
        <trans-unit id="1c4f9522981e50119882c53cf2d78fbc6dacf356" translate="yes" xml:space="preserve">
          <source>--rules Glob-style pattern matching</source>
          <target state="translated">-글로브 스타일 패턴 일치 규칙</target>
        </trans-unit>
        <trans-unit id="b8de924ed5d19fde35d5385ab4502ea63fe9053a" translate="yes" xml:space="preserve">
          <source>--rules examples</source>
          <target state="translated">-규칙 예</target>
        </trans-unit>
        <trans-unit id="b82e47ebb1972aa0b6e7d7ff1370d40055cb198c" translate="yes" xml:space="preserve">
          <source>--rules resolution</source>
          <target state="translated">-규칙 해결</target>
        </trans-unit>
        <trans-unit id="c60ab85f89bb24a2195d98fc15206ae225307de2" translate="yes" xml:space="preserve">
          <source>--state</source>
          <target state="translated">--state</target>
        </trans-unit>
        <trans-unit id="f102bd60a1627e203f05c569bd70be2475447fb4" translate="yes" xml:space="preserve">
          <source>--trap</source>
          <target state="translated">--trap</target>
        </trans-unit>
        <trans-unit id="1c943333bd1bb515c4452598c745fa2120f0f81c" translate="yes" xml:space="preserve">
          <source>--upstream, -u</source>
          <target state="translated">-업스트림, -u</target>
        </trans-unit>
        <trans-unit id="be41ad7a4148c9611162eaff167e30cd14981272" translate="yes" xml:space="preserve">
          <source>--utils</source>
          <target state="translated">--utils</target>
        </trans-unit>
        <trans-unit id="60701558636e9ff7e4e4a5391e29bda4c6ef2db8" translate="yes" xml:space="preserve">
          <source>--xmlcref</source>
          <target state="translated">--xmlcref</target>
        </trans-unit>
        <trans-unit id="6ec1cf6284eb5ed1401a0fa4abb8cf38b2067e4a" translate="yes" xml:space="preserve">
          <source>-1 or +1 is returned if the shorter string was identical to the start of the longer string. -2 or +2 is returned if there was a difference between characters within the strings.</source>
          <target state="translated">짧은 문자열이 긴 문자열의 시작과 동일하면 -1 또는 +1이 반환됩니다. 문자열 내 문자 사이에 차이가 있으면 -2 또는 +2가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bd7373f38ce34820b3e621b28cd4de8215e371f8" translate="yes" xml:space="preserve">
          <source>-8 locale.</source>
          <target state="translated">-8 로케일.</target>
        </trans-unit>
        <trans-unit id="556591f45bb0ffdc476da93680ff2e9343566fc5" translate="yes" xml:space="preserve">
          <source>-? or -help</source>
          <target state="translated">-? 또는 -help</target>
        </trans-unit>
        <trans-unit id="e5439c619dbb3b08873b649d979d89875a271f4f" translate="yes" xml:space="preserve">
          <source>-A module [ module ... ]</source>
          <target state="translated">-모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="8be3f07d6ecc59410e75ba068c300b83155bed03" translate="yes" xml:space="preserve">
          <source>-Accflags=-fsanitize=address</source>
          <target state="translated">-Accflags=-fsanitize=address</target>
        </trans-unit>
        <trans-unit id="bf6cc6c5525e05c78a90bb8dd8ce302a6fde9f46" translate="yes" xml:space="preserve">
          <source>-Alddlflags=-shared\ -fsanitize=address</source>
          <target state="translated">-Alddlflags =-공유 \ -fsanitize = 주소</target>
        </trans-unit>
        <trans-unit id="30c63d44edc0c1509106ffb2dcafcd19ce1d4e52" translate="yes" xml:space="preserve">
          <source>-Aldflags=-fsanitize=address</source>
          <target state="translated">-Aldflags=-fsanitize=address</target>
        </trans-unit>
        <trans-unit id="7db9de3fe8117d6a6778bcc8f88e7690eec078b4" translate="yes" xml:space="preserve">
          <source>-C module [ module ... ]</source>
          <target state="translated">-C 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="691bdf37190984a4fe90d8640f5e52f09bb33010" translate="yes" xml:space="preserve">
          <source>-C,--check</source>
          <target state="translated">-C,--check</target>
        </trans-unit>
        <trans-unit id="ad9aee0e02aa7df5696f88c33c3f5b0003d54711" translate="yes" xml:space="preserve">
          <source>-D</source>
          <target state="translated">-D</target>
        </trans-unit>
        <trans-unit id="1d1f99fc093e5e1ae8d544e1d9a06037f841d2ae" translate="yes" xml:space="preserve">
          <source>-D module [ module ... ]</source>
          <target state="translated">-D 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="aeacf3e5a9f96831b5805fd75e3e1221c5f5ee22" translate="yes" xml:space="preserve">
          <source>-D,--debug</source>
          <target state="translated">-D,--debug</target>
        </trans-unit>
        <trans-unit id="f455830ea22636b94e2621cba89906b9cf086ace" translate="yes" xml:space="preserve">
          <source>-Dcc=clang</source>
          <target state="translated">-Dcc=clang</target>
        </trans-unit>
        <trans-unit id="ccdf319fc9b8ab52413c4b1c6ce664c414d5cf27" translate="yes" xml:space="preserve">
          <source>-F</source>
          <target state="translated">-F</target>
        </trans-unit>
        <trans-unit id="dc1da24059fac98482b02ebc06841c689eaca7b4" translate="yes" xml:space="preserve">
          <source>-G module [ module ... ]</source>
          <target state="translated">-G 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="f71e105f8a133b9bda2f781740d497e34f38d669" translate="yes" xml:space="preserve">
          <source>-I</source>
          <target state="translated">-I</target>
        </trans-unit>
        <trans-unit id="3768ddf11606c0d712122f6d7cf70de7821c62b5" translate="yes" xml:space="preserve">
          <source>-J</source>
          <target state="translated">-J</target>
        </trans-unit>
        <trans-unit id="7a443de8d05c259afd05cb6941e512eadbc81ec9" translate="yes" xml:space="preserve">
          <source>-L author [ author ... ]</source>
          <target state="translated">-L 저자 [저자 ...]</target>
        </trans-unit>
        <trans-unit id="b046afcc916bed407dbbdb049d502fceb08d96a3" translate="yes" xml:space="preserve">
          <source>-Level</source>
          <target state="translated">-Level</target>
        </trans-unit>
        <trans-unit id="a865f5c84febf7bb127859a28c7f9921091e23e9" translate="yes" xml:space="preserve">
          <source>-M</source>
          <target state="translated">-M</target>
        </trans-unit>
        <trans-unit id="286442bdb595d2f8d281251d800e0353042699bc" translate="yes" xml:space="preserve">
          <source>-M mirror1,mirror2,...</source>
          <target state="translated">-M 미러 1, 미러 2, ...</target>
        </trans-unit>
        <trans-unit id="baef33bc876a687b961751394c8f81f05f3e79c2" translate="yes" xml:space="preserve">
          <source>-O</source>
          <target state="translated">-O</target>
        </trans-unit>
        <trans-unit id="5bb32e12d567b52d9769dd6d1b502cbafaf5b407" translate="yes" xml:space="preserve">
          <source>-P</source>
          <target state="translated">-P</target>
        </trans-unit>
        <trans-unit id="6422eedc12255e6b5d4e04ab2b26ee196c74c4c7" translate="yes" xml:space="preserve">
          <source>-Q</source>
          <target state="translated">-Q</target>
        </trans-unit>
        <trans-unit id="3e0eab9f94000d4317af98881d10968930b431a1" translate="yes" xml:space="preserve">
          <source>-S</source>
          <target state="translated">-S</target>
        </trans-unit>
        <trans-unit id="f1b7687a81f3bfab61c7281767bf9051e13659d3" translate="yes" xml:space="preserve">
          <source>-S,--scheme</source>
          <target state="translated">-S,--scheme</target>
        </trans-unit>
        <trans-unit id="67648e47a5435ce1e50f56fbe845fa12a5cdb381" translate="yes" xml:space="preserve">
          <source>-Strategy</source>
          <target state="translated">-Strategy</target>
        </trans-unit>
        <trans-unit id="332ec780f224383a9f30f4660fe42ecd1206e248" translate="yes" xml:space="preserve">
          <source>-T</source>
          <target state="translated">-T</target>
        </trans-unit>
        <trans-unit id="66445fecf3db004bb006e432cfd80e60057aed1e" translate="yes" xml:space="preserve">
          <source>-Unicode bytes is not necessarily obvious. Probably only the first of these is what you want:</source>
          <target state="translated">-유니 코드 바이트가 반드시 명확한 것은 아닙니다. 아마도 이것들 중 첫 번째 만이 당신이 원하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="6bfad0cb61ec04c8e83fbc02d3e02c478a1f6e49" translate="yes" xml:space="preserve">
          <source>-V</source>
          <target state="translated">-V</target>
        </trans-unit>
        <trans-unit id="7241f5aad8466e538eb18ce72bac37865cce783f" translate="yes" xml:space="preserve">
          <source>-X</source>
          <target state="translated">-X</target>
        </trans-unit>
        <trans-unit id="f02421666194942fbfd487a0b89bc8e62902d2fe" translate="yes" xml:space="preserve">
          <source>-X DIRHANDLE</source>
          <target state="translated">-X DIRHANDLE</target>
        </trans-unit>
        <trans-unit id="2ab1b601b35fe8f8841c979e875fa9193b77c019" translate="yes" xml:space="preserve">
          <source>-X EXPR</source>
          <target state="translated">-X EXPR</target>
        </trans-unit>
        <trans-unit id="bc19678a7061febac0619b2e971988a6337acd07" translate="yes" xml:space="preserve">
          <source>-X FILEHANDLE</source>
          <target state="translated">-X 파일 핸들</target>
        </trans-unit>
        <trans-unit id="6db1fada730596c747bd0e1cc542c04190614170" translate="yes" xml:space="preserve">
          <source>-a</source>
          <target state="translated">-a</target>
        </trans-unit>
        <trans-unit id="f1141527e901e4fc62f73312648aa01ec2a552d5" translate="yes" xml:space="preserve">
          <source>-axis is &lt;b&gt;phi&lt;/b&gt;, also known as the</source>
          <target state="translated">축은 &lt;b&gt;phi&lt;/b&gt; 이며</target>
        </trans-unit>
        <trans-unit id="60c94d22393c772d0f184d991bea821b935b05c4" translate="yes" xml:space="preserve">
          <source>-axis) is &lt;b&gt;theta&lt;/b&gt;, also known as the</source>
          <target state="translated">축)은 &lt;b&gt;theta&lt;/b&gt; 라고도하며</target>
        </trans-unit>
        <trans-unit id="e48240bfde6ac93310ae055c2eebf9ff6e622f84" translate="yes" xml:space="preserve">
          <source>-b</source>
          <target state="translated">-b</target>
        </trans-unit>
        <trans-unit id="a9dbc90b755d775e7f6bcfa29813702306e16afa" translate="yes" xml:space="preserve">
          <source>-based) logarithm of the numerical argument, see &lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;.</source>
          <target state="translated">숫자 인수의 로그 기반 로그는 &lt;a href=&quot;functions/log&quot;&gt;log를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c18479c603e32fac5be9dbd6c1629662d5b9853e" translate="yes" xml:space="preserve">
          <source>-based) logarithm of the numerical argument, see &lt;a href=&quot;perlfunc#log&quot;&gt;&quot;log&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">기반) 숫자 인수의 &lt;a href=&quot;perlfunc#log&quot;&gt;로그, perlfunc의 &quot;log&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7abb535a243486c680796806de8db55fd67e96f" translate="yes" xml:space="preserve">
          <source>-based) of the numerical argument, see &lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;.</source>
          <target state="translated">숫자 인수에 대해서는 &lt;a href=&quot;functions/exp&quot;&gt;exp를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9f25adb346a99ee88bddd351c93c06e02471293" translate="yes" xml:space="preserve">
          <source>-based) of the numerical argument, see &lt;a href=&quot;perlfunc#exp&quot;&gt;&quot;exp&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">기반) 숫자 인수의 경우 &lt;a href=&quot;perlfunc#exp&quot;&gt;perlfunc의 &quot;exp&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbfe46d29072725b61a3ee03c6abfefa0973acd" translate="yes" xml:space="preserve">
          <source>-c</source>
          <target state="translated">-c</target>
        </trans-unit>
        <trans-unit id="8226f9320a58094195bd2b8e654e97c627118403" translate="yes" xml:space="preserve">
          <source>-c (--color) requires Term::ANSIColor be installed</source>
          <target state="translated">-c (--color)를 사용하려면 Term :: ANSIColor가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b9d31753faa1f5c2566df806d8aa964dd978fe8" translate="yes" xml:space="preserve">
          <source>-c module</source>
          <target state="translated">-c 모듈</target>
        </trans-unit>
        <trans-unit id="94a878f037fdf80e6f7650a48c7b4019c798e1bf" translate="yes" xml:space="preserve">
          <source>-coordinates.</source>
          <target state="translated">-coordinates.</target>
        </trans-unit>
        <trans-unit id="d5537351313df4188977a7d2a773daedb94d0b26" translate="yes" xml:space="preserve">
          <source>-d</source>
          <target state="translated">-d</target>
        </trans-unit>
        <trans-unit id="392e2d4e9f5cba19f45990bd08bafb3b6c76ad53" translate="yes" xml:space="preserve">
          <source>-d destination_dir</source>
          <target state="translated">-d 목적지 _ 디렉터리</target>
        </trans-unit>
        <trans-unit id="2360917b9377a0f8f526499aa422e769e1252d5b" translate="yes" xml:space="preserve">
          <source>-e</source>
          <target state="translated">-e</target>
        </trans-unit>
        <trans-unit id="238695a38c232937a8a6d11443d7b294962357c5" translate="yes" xml:space="preserve">
          <source>-e routine</source>
          <target state="translated">-e 루틴</target>
        </trans-unit>
        <trans-unit id="ae22cd44cab421b74b9cb1b713b21791222034bd" translate="yes" xml:space="preserve">
          <source>-equivalent suffix.</source>
          <target state="translated">동등한 접미사.</target>
        </trans-unit>
        <trans-unit id="f9734ee333a629165fa782b725db07885fb85d5a" translate="yes" xml:space="preserve">
          <source>-expansion done.</source>
          <target state="translated">확장이 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="0abbcbcbe6d61abda4c58f24b76e0809f7c8b425" translate="yes" xml:space="preserve">
          <source>-f</source>
          <target state="translated">-f</target>
        </trans-unit>
        <trans-unit id="d1aab55443fd6d41c1821fb0098c28a59834c83c" translate="yes" xml:space="preserve">
          <source>-f routine</source>
          <target state="translated">-f 루틴</target>
        </trans-unit>
        <trans-unit id="40ced84e4352580b814a3c831d005fc7fe42bbe3" translate="yes" xml:space="preserve">
          <source>-f,--from</source>
          <target state="translated">-f,--from</target>
        </trans-unit>
        <trans-unit id="9768b3fca97bf2d2b773d639aae85af5d3472b58" translate="yes" xml:space="preserve">
          <source>-foo</source>
          <target state="translated">-foo</target>
        </trans-unit>
        <trans-unit id="1a7928193ef3f3d9bf22f22d8e56318d501a71bd" translate="yes" xml:space="preserve">
          <source>-fsanitize-blacklist=`pwd`/asan_ignore</source>
          <target state="translated">-fsanitize-blacklist=`pwd`/asan_ignore</target>
        </trans-unit>
        <trans-unit id="908ef382f902c5e030db6c76a3e6446bcc9e5ec4" translate="yes" xml:space="preserve">
          <source>-g module [ module ... ]</source>
          <target state="translated">-g 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="3c3003f7f0bedaf2a7334f932c515378a93f1402" translate="yes" xml:space="preserve">
          <source>-h</source>
          <target state="translated">-h</target>
        </trans-unit>
        <trans-unit id="13164925a0cd22470235c5e8907dc7dc055dab88" translate="yes" xml:space="preserve">
          <source>-h,--help</source>
          <target state="translated">-h,--help</target>
        </trans-unit>
        <trans-unit id="91edc8362c7518c1b0e4a9a4a7bcb6c02d8e498b" translate="yes" xml:space="preserve">
          <source>-i</source>
          <target state="translated">-i</target>
        </trans-unit>
        <trans-unit id="051fa67f29f2a258f11d9c26669bfd28448cd877" translate="yes" xml:space="preserve">
          <source>-i module [ module ... ]</source>
          <target state="translated">-i 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="ad8f3e5cba188512d6d65a4a9cf410c33f086158" translate="yes" xml:space="preserve">
          <source>-i used with no filenames on the command line, reading from STDIN</source>
          <target state="translated">-i 명령 줄에 파일 이름없이 사용되며 STDIN에서 읽음</target>
        </trans-unit>
        <trans-unit id="814937af05964f89600befa6ae3bfe386bb151b0" translate="yes" xml:space="preserve">
          <source>-ish meanings:</source>
          <target state="translated">-ish 의미 :</target>
        </trans-unit>
        <trans-unit id="89343dccabe72d08e1c4b86cd111151ff113e89e" translate="yes" xml:space="preserve">
          <source>-j Config.pm</source>
          <target state="translated">-j Config.pm</target>
        </trans-unit>
        <trans-unit id="41ecbf5c742a07d94719d70cfc27033de855195e" translate="yes" xml:space="preserve">
          <source>-l</source>
          <target state="translated">-l</target>
        </trans-unit>
        <trans-unit id="3c4a5714426402e6a879069c8235ce5a2796770b" translate="yes" xml:space="preserve">
          <source>-l,--list</source>
          <target state="translated">-l,--list</target>
        </trans-unit>
        <trans-unit id="d913657d8a33916405c4c67553ab3a2992d6c95e" translate="yes" xml:space="preserve">
          <source>-like construct is created by a pair of &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; macros (see &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;Returning a Scalar in perlcall&lt;/a&gt;). Such a construct may be created specially for some important localized task, or an existing one (like boundaries of enclosing Perl subroutine/block, or an existing pair for freeing TMPs) may be used. (In the second case the overhead of additional localization must be almost negligible.) Note that any XSUB is automatically enclosed in an &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair.</source>
          <target state="translated">-like 구성은 한 쌍의 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 매크로에 의해 작성됩니다 ( &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;perlcall에서 스칼라 리턴&lt;/a&gt; 참조 ). 이러한 구조는 일부 중요한 국부 화 된 태스크를 위해 특별히 생성 될 수 있거나, 기존의 태스크 (외부 Perl 서브 루틴 / 블록의 경계 또는 TMP를 해제하기위한 기존의 쌍과 같은)가 사용될 수있다. (두 번째 경우 추가 지역화의 오버 헤드는 거의 무시할 수 있어야합니다.) 모든 XSUB는 자동으로 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 쌍 으로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="d764287429ae69a6b55559d0da992c92cd681258" translate="yes" xml:space="preserve">
          <source>-like construct is created by a pair of &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; macros (see &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;&quot;Returning a Scalar&quot; in perlcall&lt;/a&gt;). Such a construct may be created specially for some important localized task, or an existing one (like boundaries of enclosing Perl subroutine/block, or an existing pair for freeing TMPs) may be used. (In the second case the overhead of additional localization must be almost negligible.) Note that any XSUB is automatically enclosed in an &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pair.</source>
          <target state="translated">유사 구조는 한 쌍의 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 매크로에 의해 생성됩니다 ( &lt;a href=&quot;perlcall#Returning-a-Scalar&quot;&gt;perlcall의 &quot;스칼라 반환&quot;&lt;/a&gt; 참조 ). 이러한 구성은 일부 중요한 지역화 된 작업을 위해 특별히 생성되거나 기존 작업 (예 : Perl 서브 루틴 / 블록을 둘러싸는 경계 또는 TMP 해제를위한 기존 쌍)이 사용될 수 있습니다. (두 번째 경우 추가 현지화의 오버 헤드는 거의 무시할 수 있어야합니다.) 모든 XSUB는 자동으로 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 쌍 으로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98c9dc82b0940ee66ebaf6b3ab25db4d7a0b7ee" translate="yes" xml:space="preserve">
          <source>-lperl</source>
          <target state="translated">-lperl</target>
        </trans-unit>
        <trans-unit id="8cc195760cf823702a9c3a4e38316c503826cf72" translate="yes" xml:space="preserve">
          <source>-m</source>
          <target state="translated">-m</target>
        </trans-unit>
        <trans-unit id="7d457e0ddd706b0631c75d46533797809ea7a042" translate="yes" xml:space="preserve">
          <source>-man</source>
          <target state="translated">-man</target>
        </trans-unit>
        <trans-unit id="d868a680affb6ad2c7e2392566b6adc4e3201dea" translate="yes" xml:space="preserve">
          <source>-n</source>
          <target state="translated">-n</target>
        </trans-unit>
        <trans-unit id="f768616ef823e7864962e05cfb8231fce774193d" translate="yes" xml:space="preserve">
          <source>-p</source>
          <target state="translated">-p</target>
        </trans-unit>
        <trans-unit id="653332e9ad9ed292b475028118162353cc479d16" translate="yes" xml:space="preserve">
          <source>-p,--perlqq</source>
          <target state="translated">-p,--perlqq</target>
        </trans-unit>
        <trans-unit id="00a354ab6ba325dfea1f93fc702984e336b57ca9" translate="yes" xml:space="preserve">
          <source>-pi</source>
          <target state="translated">-pi</target>
        </trans-unit>
        <trans-unit id="d0ab9098221f275f405a3db51c04c836d2cd668f" translate="yes" xml:space="preserve">
          <source>-plane (around the</source>
          <target state="translated">비행기 (주변</target>
        </trans-unit>
        <trans-unit id="90cdb7ea49538fa14a6fddf9d2eb1811417d042f" translate="yes" xml:space="preserve">
          <source>-r</source>
          <target state="translated">-r</target>
        </trans-unit>
        <trans-unit id="3c1161c663136dd9f9b6a603933f75e4defae1c1" translate="yes" xml:space="preserve">
          <source>-r,--resolve</source>
          <target state="translated">-r,--resolve</target>
        </trans-unit>
        <trans-unit id="e6ab9816305be2242bcc92ac5c609d4a088fd6f8" translate="yes" xml:space="preserve">
          <source>-re LIST OF PATTERNS</source>
          <target state="translated">-re 패턴 목록</target>
        </trans-unit>
        <trans-unit id="c4c647df34524053914b0fa32a75ea6b3ed9a1e0" translate="yes" xml:space="preserve">
          <source>-re=PATTERN</source>
          <target state="translated">-re=PATTERN</target>
        </trans-unit>
        <trans-unit id="fe06637685c925d5eec8bbd543cd92c006d957fa" translate="yes" xml:space="preserve">
          <source>-removal would give you. If you want to do this kind of processing, you probably want &lt;code&gt;Cwd&lt;/code&gt; 's &lt;code&gt;realpath()&lt;/code&gt; function to actually traverse the filesystem cleaning up paths like this.</source>
          <target state="translated">제거는 당신에게 줄 것입니다. 이런 종류의 처리를 원한다면 &lt;code&gt;Cwd&lt;/code&gt; 의 &lt;code&gt;realpath()&lt;/code&gt; 함수가 실제로 파일 시스템을 통과하여 이와 같은 경로를 정리하기를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="91953f3be86960dbb0426f033ce652ec6a050ab6" translate="yes" xml:space="preserve">
          <source>-removal would give you. If you want to do this kind of processing, you probably want &lt;code&gt;Cwd&lt;/code&gt;'s &lt;code&gt;realpath()&lt;/code&gt; function to actually traverse the filesystem cleaning up paths like this.</source>
          <target state="translated">-제거는 당신을 줄 것입니다. 이런 종류의 처리를 원한다면 &lt;code&gt;Cwd&lt;/code&gt; 의 &lt;code&gt;realpath()&lt;/code&gt; 함수가 실제로 이와 같은 경로를 정리하는 파일 시스템을 순회하기를 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="840c8c1b085e301c44de24e07c1100e2497b9568" translate="yes" xml:space="preserve">
          <source>-s</source>
          <target state="translated">-s</target>
        </trans-unit>
        <trans-unit id="1ca3d40459b0228ae087f3489d216f8db272fba3" translate="yes" xml:space="preserve">
          <source>-s,--string</source>
          <target state="translated">-s,--string</target>
        </trans-unit>
        <trans-unit id="1a8854d13cc7eda216c70c1e5b536a20cbd2d0a9" translate="yes" xml:space="preserve">
          <source>-style format specifier (without the leading '%') to use to print the times. It defaults to '5.2f'.</source>
          <target state="translated">시간을 인쇄하는 데 사용하는 -style 형식 지정자 (앞의 '%'없음) 기본값은 '5.2f'입니다.</target>
        </trans-unit>
        <trans-unit id="bdc6cf8c21c664c9faf3b4b838269f152cd31578" translate="yes" xml:space="preserve">
          <source>-t module [ module ... ]</source>
          <target state="translated">-t 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="e5d2e9e72dce0fabd51e5cb93cdb7743931a2d19" translate="yes" xml:space="preserve">
          <source>-t,--to</source>
          <target state="translated">-t,--to</target>
        </trans-unit>
        <trans-unit id="39757b603166b52e1a1e2021e629c21418eee11a" translate="yes" xml:space="preserve">
          <source>-th subpattern, or undef if the subpattern did not match.</source>
          <target state="translated">-번째 하위 패턴이거나 하위 패턴이 일치하지 않으면 undef입니다.</target>
        </trans-unit>
        <trans-unit id="66000995bef80f7fce654adc5353777229997bce" translate="yes" xml:space="preserve">
          <source>-torture</source>
          <target state="translated">-torture</target>
        </trans-unit>
        <trans-unit id="2c2dcf44f1bc9aa15d180db1d30d26a50922272d" translate="yes" xml:space="preserve">
          <source>-u</source>
          <target state="translated">-u</target>
        </trans-unit>
        <trans-unit id="aaf1e4f6a10d49a5901590bb3b8c0dba1ef3ca8c" translate="yes" xml:space="preserve">
          <source>-utilities on path manually. They are installed in &lt;code&gt;$prefix/bin&lt;/code&gt; , here &lt;code&gt;$prefix&lt;/code&gt; is what you gave to</source>
          <target state="translated">-경로의 수동 유틸리티. &lt;code&gt;$prefix/bin&lt;/code&gt; 설치되어 있습니다. &lt;code&gt;$prefix&lt;/code&gt; 는 당신이 준 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b057029c4063bde864f6f94434aed99cf91301c" translate="yes" xml:space="preserve">
          <source>-utilities on path manually. They are installed in &lt;code&gt;$prefix/bin&lt;/code&gt;, here &lt;code&gt;$prefix&lt;/code&gt; is what you gave to</source>
          <target state="translated">-수동으로 경로의 유틸리티. &lt;code&gt;$prefix/bin&lt;/code&gt; 설치됩니다 . 여기서 &lt;code&gt;$prefix&lt;/code&gt; 는 사용자가 제공 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="75262c839fe7bdce825dee598401d72dc8394722" translate="yes" xml:space="preserve">
          <source>-v</source>
          <target state="translated">-v</target>
        </trans-unit>
        <trans-unit id="55b84beaebd3dd9ce3fdbc2382374c7a228132cc" translate="yes" xml:space="preserve">
          <source>-w</source>
          <target state="translated">-w</target>
        </trans-unit>
        <trans-unit id="04728bd7fc7483a16ca722feb0ed8c18f1fc301a" translate="yes" xml:space="preserve">
          <source>-x module [ module ... ]</source>
          <target state="translated">-x 모듈 [모듈 ...]</target>
        </trans-unit>
        <trans-unit id="43fe7418deee5c61282eab45e5fe930c1cf1ab80" translate="yes" xml:space="preserve">
          <source>-z</source>
          <target state="translated">-z</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="46b9ed05b810c35c030b14df53138c9f8fb2464a" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;&lt;a href=&quot;../functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">. ( &lt;code&gt;&lt;a href=&quot;../functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="b8d281ef9104c2b48d48df2a7cf5ddced0cf7e72" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt;). For example:</source>
          <target state="translated">. ( &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 와 동일 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94c582d1658acfd4933003032c4471f9c701f1c4" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;scalar(@array)&lt;/code&gt;).</source>
          <target state="translated">. ( &lt;code&gt;scalar(@array)&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="3a996d62cf71fd6ebf46de7b113603888dc7060a" translate="yes" xml:space="preserve">
          <source>. (Equivalent to &lt;code&gt;scalar(@array)&lt;/code&gt;). For example:</source>
          <target state="translated">. ( &lt;code&gt;scalar(@array)&lt;/code&gt; 와 동일 ). 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="694f35049a7ec5dc2b360d57bd881a28fa07da34" translate="yes" xml:space="preserve">
          <source>. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="translated">. (CLEANUP 플래그가 설정 될 때 프로그램 종료시 정리를 위해, 이것은 자동으로 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="15693b683bd6294eb09618d3328be4ea6360e2ed" translate="yes" xml:space="preserve">
          <source>. (If you interrupt it, you would better reset &lt;code&gt;LineInfo&lt;/code&gt; to something &quot;interactive&quot;!)</source>
          <target state="translated">. (중단하면 &lt;code&gt;LineInfo&lt;/code&gt; 를 &quot;대화식&quot;으로 재설정하는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="181e9a15b21b5b303a16988869863732a3c74ac2" translate="yes" xml:space="preserve">
          <source>. (If you interrupt it, you'd better reset &lt;code&gt;LineInfo&lt;/code&gt; to</source>
          <target state="translated">. (중단하면 &lt;code&gt;LineInfo&lt;/code&gt; 를 다음으로 재설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4f2dc4447c7e1cbcca5316cceaa252e9049281ff" translate="yes" xml:space="preserve">
          <source>. (Perhaps, in retrospect, the &lt;code&gt;lib&lt;/code&gt; style should never have been supported, but it did seem like a nice idea at the time.)</source>
          <target state="translated">. 아마도 돌이켜 보면 &lt;code&gt;lib&lt;/code&gt; 스타일은 지원되지 않았지만 당시에는 좋은 생각처럼 보였습니다.</target>
        </trans-unit>
        <trans-unit id="9f0b8aeca7daf268ae4d3b7f58d2547cb18964da" translate="yes" xml:space="preserve">
          <source>. (Setting BEGINLIBPATH to just &lt;code&gt;.&lt;/code&gt; is ignored by the OS/2 kernel.)</source>
          <target state="translated">. (단지에 BEGINLIBPATH을 설정 &lt;code&gt;.&lt;/code&gt; 운영 체제 / 2 커널에 의해 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="3cc75d93f4261d9260f179d2d05bf50125a26b04" translate="yes" xml:space="preserve">
          <source>. (The usage below indicates it is for integers, but it works for any type.) Use instead of these, since the C library ones force their argument to be what it is expecting, potentially leading to disaster. But also beware that this evaluates its argument twice, so no &lt;code&gt;x++&lt;/code&gt;.</source>
          <target state="translated">. (아래 사용법은 정수용임을 나타내지 만 모든 유형에 대해 작동합니다.) C 라이브러리의 인수가 예상대로 강제로 적용되어 잠재적으로 재난을 초래할 수 있으므로이 대신 사용하십시오. 그러나 이것은 인수를 두 번 평가하므로 &lt;code&gt;x++&lt;/code&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fd50589315deafe5011fdea5a89280d20abb432c" translate="yes" xml:space="preserve">
          <source>. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;'^'&lt;/code&gt; in front of the name, so that,</source>
          <target state="translated">. (이와 관련하여 몇 가지 예외와 문제가 있습니다. 자세한 내용은 &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; 를 참조하십시오 .) &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; 및 &lt;code&gt;[:space:]&lt;/code&gt; 는 익숙한 &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; 및 &lt;code&gt;\s&lt;/code&gt; 캐릭터 클래스. POSIX 클래스를 부정하려면 이름 앞에 &lt;code&gt;'^'&lt;/code&gt; 를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="2db51a060293e1873f6869f67d8e79713a69ef25" translate="yes" xml:space="preserve">
          <source>. (There is a Perl script called &lt;b&gt;h2ph&lt;/b&gt; that comes with the Perl kit that may help you in this, but it's nontrivial.) SCALAR will be read and/or written depending on the FUNCTION; a C pointer to the string value of SCALAR will be passed as the third argument of the actual &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; call. (If SCALAR has no string value but does have a numeric value, that value will be passed rather than a pointer to the string value. To guarantee this to be true, add a &lt;code&gt;0&lt;/code&gt; to the scalar before using it.) The &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; functions may be needed to manipulate the values of structures used by &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. (이에 도움이 될 수있는 Perl 키트와 함께 제공되는 &lt;b&gt;h2ph&lt;/b&gt; 라는 Perl 스크립트 가 있지만 이는 사소하지 않습니다.) SCALAR는 FUNCTION에 따라 읽거나 작성됩니다. SCALAR의 문자열 값에 대한 C 포인터는 실제 &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;ioctl&lt;/code&gt; &lt;/a&gt; 호출 의 세 번째 인수로 전달됩니다 . (SCALAR 더 문자열 값이 없지만 숫자 값을 가질 경우, 그 값은 문자열 값에 대한 포인터보다는 전달됩니다. 추가,이 사실을 보장하기 위해 &lt;code&gt;0&lt;/code&gt; 을 사용하기 전에 스칼라로하십시오.) &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;ioctl&lt;/code&gt; 에서&lt;/a&gt; 사용하는 구조의 값을 조작하려면 함수가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebbcb028023ba5ec4bf990fcf6eb37768723056e" translate="yes" xml:space="preserve">
          <source>. (There is a Perl script called &lt;b&gt;h2ph&lt;/b&gt; that comes with the Perl kit that may help you in this, but it's nontrivial.) SCALAR will be read and/or written depending on the FUNCTION; a C pointer to the string value of SCALAR will be passed as the third argument of the actual &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; call. (If SCALAR has no string value but does have a numeric value, that value will be passed rather than a pointer to the string value. To guarantee this to be true, add a &lt;code&gt;0&lt;/code&gt; to the scalar before using it.) The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; functions may be needed to manipulate the values of structures used by &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">. (이에 도움이 될 수있는 Perl 키트와 함께 제공되는 &lt;b&gt;h2ph&lt;/b&gt; 라는 Perl 스크립트 가 있지만 사소한 것은 아닙니다.) SCALAR는 FUNCTION에 따라 읽거나 쓸 것입니다. SCALAR의 문자열 값에 대한 C 포인터는 실제 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 호출 의 세 번째 인수로 전달됩니다 . (SCALAR 더 문자열 값이 없지만 숫자 값을 가질 경우, 그 값은 문자열 값에 대한 포인터보다는 전달됩니다. 추가,이 사실을 보장하기 위해 &lt;code&gt;0&lt;/code&gt; 을 사용하기 전에 스칼라로하십시오.) &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 이 사용하는 구조의 값을 조작하기 위해 함수가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf29a1e7711e856247e88a22d78403cd4097d96" translate="yes" xml:space="preserve">
          <source>. (There is a Perl script called &lt;b&gt;h2ph&lt;/b&gt; that comes with the Perl kit that may help you in this, but it's nontrivial.) SCALAR will be read and/or written depending on the FUNCTION; a C pointer to the string value of SCALAR will be passed as the third argument of the actual &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; call. (If SCALAR has no string value but does have a numeric value, that value will be passed rather than a pointer to the string value. To guarantee this to be true, add a &lt;code&gt;0&lt;/code&gt; to the scalar before using it.) The &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; functions may be needed to manipulate the values of structures used by &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">. (이에 도움이 될 수있는 Perl 키트와 함께 제공되는 &lt;b&gt;h2ph&lt;/b&gt; 라는 Perl 스크립트 가 있지만 사소한 것은 아닙니다.) SCALAR는 FUNCTION에 따라 읽거나 쓸 것입니다. SCALAR의 문자열 값에 대한 C 포인터는 실제 &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 호출 의 세 번째 인수로 전달됩니다 . (SCALAR 더 문자열 값이 없지만 숫자 값을 가질 경우, 그 값은 문자열 값에 대한 포인터보다는 전달됩니다. 추가,이 사실을 보장하기 위해 &lt;code&gt;0&lt;/code&gt; 을 사용하기 전에 스칼라로하십시오.) &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 이 사용하는 구조의 값을 조작하기 위해 함수가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc82a4dc120028594b84107495cbc0deaebe016c" translate="yes" xml:space="preserve">
          <source>. (Yes, Virginia, there &lt;b&gt;is&lt;/b&gt; a YACC grammar for Perl!) The job of the parser is to take your code and &quot;understand&quot; it, splitting it into sentences, deciding which operands go with which operators and so on.</source>
          <target state="translated">. (예, 버지니아, 거기에 &lt;b&gt;있다&lt;/b&gt; 펄의 YACC 문법!) 파서의 작업은 피연산자가있는 사업자 등으로 이동하는 결정, 그것을 문장으로, 분할 코드를 가지고 그것을 &quot;이해&quot;하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="690c1a79ec29589f49d7e8d06988c85b3fcab0f7" translate="yes" xml:space="preserve">
          <source>. (in these examples &lt;code&gt;&quot;S&quot;&lt;/code&gt; and &lt;code&gt;&quot;T&quot;&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">. (이 예에서 &lt;code&gt;&quot;S&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;T&quot;&lt;/code&gt; 는 정규 하위 표현식입니다).</target>
        </trans-unit>
        <trans-unit id="cac2ef42eac4291ce9782faa9a407fa44d35265d" translate="yes" xml:space="preserve">
          <source>. (or</source>
          <target state="translated">. (또는</target>
        </trans-unit>
        <trans-unit id="236152725d137990a457e4cd09f9fd7d5e6c1e40" translate="yes" xml:space="preserve">
          <source>. &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; explain the</source>
          <target state="translated">. &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 와 &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="0b97909f09c9f763ca3dc7911d0df0016488e3ca" translate="yes" xml:space="preserve">
          <source>. &lt;b&gt;It is especially important to do this in modules to avoid penalizing all applications which use them.&lt;/b&gt;</source>
          <target state="translated">. &lt;b&gt;모듈을 사용하는 모든 응용 프로그램에 불이익을주지 않도록 모듈에서이 작업을 수행하는 것이 특히 중요합니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c84bd932de16eb29265e3c78e34c63425be61866" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;$&lt;/code&gt; is a shell prompt.</source>
          <target state="translated">. &lt;code&gt;$&lt;/code&gt; 는 쉘 프롬프트입니다.</target>
        </trans-unit>
        <trans-unit id="a872501bd8eee376a90e33fd1da5d7ad22e00ebc" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;$Config{d_setlocale}&lt;/code&gt; is &lt;code&gt;'define'&lt;/code&gt; on OS/390 or z/OS.</source>
          <target state="translated">. &lt;code&gt;$Config{d_setlocale}&lt;/code&gt; 은 OS / 390 또는 z / OS에서 &lt;code&gt;'define'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="689f2d81347c4e95450de6a6b67d57924dc6366c" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords indicate that the C subroutine does not inspect the memory pointed by this parameter, but will write through this pointer to provide additional return values.</source>
          <target state="translated">. &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 키워드는 C 서브 루틴이이 매개 변수가 가리키는 메모리를 검사하지 않지만 추가 포인터 값을 제공하기 위해이 포인터를 통해 씁니다.</target>
        </trans-unit>
        <trans-unit id="7fcdc380d7a23b700b238fab1e48c6a66ab49cbb" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; keywords indicate that the C subroutine does not inspect the memory pointed by this parameter, but will write through this pointer to provide additional return values.</source>
          <target state="translated">. &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; 키워드는 C 서브 루틴이이 매개 변수가 가리키는 메모리를 검사하지 않지만 추가 리턴 값을 제공하기 위해이 포인터를 통해 기록함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="88901232fc748fdea60269bc910d226f97e1cb4d" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;Perl_runops_debug&lt;/code&gt; is used with DEBUGGING and &lt;code&gt;Perl_runops_standard&lt;/code&gt; is used otherwise. For fine control over the execution of the compile tree it is possible to provide your own runops function.</source>
          <target state="translated">. &lt;code&gt;Perl_runops_debug&lt;/code&gt; 는 DEBUGGING 과 함께 사용되며 그렇지 않으면 &lt;code&gt;Perl_runops_standard&lt;/code&gt; 가 사용됩니다. 컴파일 트리 실행을 정밀하게 제어하기 위해 자체 Runops 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c7eee973f32ff4607b490bd51cf94d26808c4a" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;STDIN =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; turns the I/O transcoding completely off for that filehandle.</source>
          <target state="translated">. &lt;code&gt;STDIN =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 는 해당 파일 핸들에 대한 I / O 트랜스 코딩을 완전히 끕니다.</target>
        </trans-unit>
        <trans-unit id="ba96b39b2369555d32eba04ad56361c9a9156134" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;STDIN =&amp;gt; undef&lt;/code&gt; turns the I/O transcoding completely off for that filehandle.</source>
          <target state="translated">. &lt;code&gt;STDIN =&amp;gt; undef&lt;/code&gt; 는 해당 파일 핸들에 대한 I / O 트랜스 코딩을 완전히 해제합니다.</target>
        </trans-unit>
        <trans-unit id="22e9affa2bbc7ae84004e12265378a617db34fa8" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;special&lt;/code&gt; (usually, but not always, a multicharacter mapping), is tried first.</source>
          <target state="translated">. &lt;code&gt;special&lt;/code&gt; (보통 항상 다중 문자 매핑은 아님)가 먼저 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="34b205465f826019a73312394da64a5166d0e847" translate="yes" xml:space="preserve">
          <source>. A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; just gives temporary values to global (meaning package) variables. It does</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 단지 지구 (의미 패키지) 변수에 임시 값을 제공합니다. 그렇습니다</target>
        </trans-unit>
        <trans-unit id="d92dc079e56072c4dd03f3a9fb094902868ede9d" translate="yes" xml:space="preserve">
          <source>. A &lt;code&gt;local&lt;/code&gt; just gives temporary values to global (meaning package) variables. It does</source>
          <target state="translated">. &lt;code&gt;local&lt;/code&gt; 단지 지구 (의미 패키지) 변수에 임시 값을 제공합니다. 그렇습니다</target>
        </trans-unit>
        <trans-unit id="20d7984adc37598924d34162f803580d6f8e4473" translate="yes" xml:space="preserve">
          <source>. A character class allows a set of possible characters, rather than just a single character, to match at a particular point in a regexp. You can define your own custom character classes. These are denoted by brackets &lt;code&gt;[...]&lt;/code&gt; , with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="translated">. 문자 클래스를 사용하면 단일 문자가 아닌 가능한 문자 세트를 정규식의 특정 지점에서 일치시킬 수 있습니다. 고유 한 사용자 정의 문자 클래스를 정의 할 수 있습니다. 이것들은 대괄호 &lt;code&gt;[...]&lt;/code&gt; 로 표시되며 , 문자 세트와 일치 할 가능성이 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="ea187136ae4e7e7c9da0097eccfa70e52bc2fedf" translate="yes" xml:space="preserve">
          <source>. A character class allows a set of possible characters, rather than just a single character, to match at a particular point in a regexp. You can define your own custom character classes. These are denoted by brackets &lt;code&gt;[...]&lt;/code&gt;, with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="translated">. 문자 클래스를 사용하면 단일 문자가 아닌 가능한 문자 집합을 정규 표현식의 특정 지점에서 일치시킬 수 있습니다. 사용자 정의 문자 클래스를 정의 할 수 있습니다. 이들은 대괄호 &lt;code&gt;[...]&lt;/code&gt; 로 표시되며 , 내부에서 일치 할 수있는 문자 집합이 있습니다. 여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b629a81173e8b0555a45f0a8eab5759b801c2a12" translate="yes" xml:space="preserve">
          <source>. A code point is essentially the position of the character within the set of all possible Unicode characters, and thus in Perl, the term</source>
          <target state="translated">. 코드 포인트는 기본적으로 가능한 모든 유니 코드 문자 집합 내에서 문자의 위치이므로 Perl에서</target>
        </trans-unit>
        <trans-unit id="6967b877b0a6419ec120bcf48175f4179b1d1c97" translate="yes" xml:space="preserve">
          <source>. A module can install custom translations (inside the scope which &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;s the module) with the following magic incantation:</source>
          <target state="translated">. 모듈은 다음과 같은 마법의 주문과 함께 사용자 정의 번역을 ( 모듈 을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 하는 범위 내에서) 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fa39f453b27b8fde79ba1e37e6b3b686c6cd9fb" translate="yes" xml:space="preserve">
          <source>. A module can install custom translations (inside the scope which &lt;code&gt;use&lt;/code&gt;s the module) with the following magic incantation:</source>
          <target state="translated">. 모듈은 다음과 같은 마법 주문으로 사용자 정의 번역 ( 모듈 을 &lt;code&gt;use&lt;/code&gt; 하는 범위 내)을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="654c9133d804ea9801de6c352e63b0d752c4c7a2" translate="yes" xml:space="preserve">
          <source>. A source stream is created when the Perl parser opens a file, it continues to exist as the source code is read into memory, and it is destroyed when Perl is finished parsing the file. If the parser encounters a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement in a source stream, a new and distinct stream is created just for that file.</source>
          <target state="translated">. 소스 스트림은 Perl 구문 분석기가 파일을 열 때 작성되며 소스 코드를 메모리로 읽을 때 계속 존재하며 Perl이 파일 구문 분석을 마치면 소멸됩니다. 파서가 소스 스트림에서 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문을 발견하면 해당 파일에 대해서만 새롭고 고유 한 스트림이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="233c54b29b60b9e6d92cc6a4150b5bcf7faf5d59" translate="yes" xml:space="preserve">
          <source>. A source stream is created when the Perl parser opens a file, it continues to exist as the source code is read into memory, and it is destroyed when Perl is finished parsing the file. If the parser encounters a &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; statement in a source stream, a new and distinct stream is created just for that file.</source>
          <target state="translated">. Perl 파서가 파일을 열 때 소스 스트림이 생성되고, 소스 코드가 메모리로 읽어 질 때 계속 존재하며 Perl이 파일 구문 분석을 마치면 소멸됩니다. 파서가 소스 스트림에서 &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 문을 발견하면 해당 파일에 대해서만 새롭고 고유 한 스트림이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="27177b505cdc14ed8afa64dfc9fa5c9897f8366d" translate="yes" xml:space="preserve">
          <source>. ASCII is used this way for most cases.</source>
          <target state="translated">. ASCII는 대부분의 경우 이런 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ba2d601d95f584214b7a05377f233db7b020c5c" translate="yes" xml:space="preserve">
          <source>. Acts same as &lt;code&gt;find_encoding()&lt;/code&gt; but &lt;code&gt;mime_name()&lt;/code&gt; of returned object must match to</source>
          <target state="translated">. &lt;code&gt;find_encoding()&lt;/code&gt; 과 동일하게 작동 하지만 반환 된 객체의 &lt;code&gt;mime_name()&lt;/code&gt; 은 다음과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1f1a39d92f2a76d4292eccf2b32f34370ade789" translate="yes" xml:space="preserve">
          <source>. Again, not using exactly two digits is a recipe for disaster, but you can use &lt;code&gt;\x{...}&lt;/code&gt; to specify any number of hex digits.</source>
          <target state="translated">. 다시 말하지만 정확히 두 자리 숫자를 사용하지 않는 것은 재앙을 불러 일으키는 방법이지만 &lt;code&gt;\x{...}&lt;/code&gt; 를 사용하여 16 진수 숫자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2efb2ba1e620dbacfedb286bb11ac9ae5ea4f4" translate="yes" xml:space="preserve">
          <source>. All regex engines must be able to correctly build such a structure in their &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="translated">. 모든 정규식 엔진은 &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; 루틴 에서 이러한 구조를 올바르게 구축 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1be7e388b24fed423d29f693852a90533c3dce34" translate="yes" xml:space="preserve">
          <source>. All regex engines must be able to correctly build such a structure in their &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">. 모든 정규식 엔진은 &lt;a href=&quot;#comp&quot;&gt;컴프&lt;/a&gt; 루틴 에서 이러한 구조를 올바르게 구축 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0eb8ffacada74d7b0728dd1325a7888884aee218" translate="yes" xml:space="preserve">
          <source>. All the other functions are fairly simple wrappers which make it easier to call Perl subroutines in special cases. At the end of the day they will all call</source>
          <target state="translated">. 다른 모든 함수는 특별한 경우에 Perl 서브 루틴을보다 쉽게 ​​호출 할 수있는 상당히 간단한 랩퍼입니다. 하루가 끝나면 그들은 모두 전화 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="27da16d87cc57fa070324d863cd8cedd53811405" translate="yes" xml:space="preserve">
          <source>. All versions of Berkeley DB are available there.</source>
          <target state="translated">. Berkeley DB의 모든 버전을 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7101cbca81b1324605820165ddc0d74b9fe44d2a" translate="yes" xml:space="preserve">
          <source>. An empty</source>
          <target state="translated">. 빈</target>
        </trans-unit>
        <trans-unit id="233b57b3e77bae0ead5a8a30677ef0a77a1edf99" translate="yes" xml:space="preserve">
          <source>. And since the extension DLLs link with the Perl DLL, extension DLLs for older versions would load an older Perl DLL, and would most probably segfault (since the data in this DLL is not properly initialized).</source>
          <target state="translated">. 그리고 확장 DLL은 Perl DLL과 연결되기 때문에, 이전 버전의 확장 DLL은 이전 Perl DLL을로드하며, 아마도이 DLL의 데이터가 제대로 초기화되지 않았기 때문에 segfault 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="de259bd11ae330f9c68f383ed85ba6c2e159b450" translate="yes" xml:space="preserve">
          <source>. Any XS code should be in</source>
          <target state="translated">. 모든 XS 코드는</target>
        </trans-unit>
        <trans-unit id="75671be154b9c3d8b51b585074c5b9061967b6d3" translate="yes" xml:space="preserve">
          <source>. Any type of bracket not in the delimiter list is treated as an ordinary character.</source>
          <target state="translated">. 구분 기호 목록에없는 모든 유형의 대괄호는 일반 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bdcf75e96f17cc2c4c3a8be735b514fb9c36ef" translate="yes" xml:space="preserve">
          <source>. As a binary operator, it has two children: the add operator, providing the result of &lt;code&gt;$b+$c&lt;/code&gt; , is uppermost on line 5, and the left hand side is on line 10.</source>
          <target state="translated">. 이항 연산자로서 두 개의 하위 요소가 있습니다. &lt;code&gt;$b+$c&lt;/code&gt; 의 결과를 제공하는 add 연산자 는 5 행에서 가장 위쪽에 있고 왼쪽은 10 행에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b14231a260dc38bfc76eb01c0bd7737b636bfc6" translate="yes" xml:space="preserve">
          <source>. As a binary operator, it has two children: the add operator, providing the result of &lt;code&gt;$b+$c&lt;/code&gt;, is uppermost on line 5, and the left hand side is on line 10.</source>
          <target state="translated">. 이항 연산자로서 두 개의 자식이 있습니다. &lt;code&gt;$b+$c&lt;/code&gt; 의 결과를 제공하는 add 연산자 는 5 행에서 맨 위에 있고 왼쪽은 10 행에 있습니다.</target>
        </trans-unit>
        <trans-unit id="53d4b5ccec1621f068b34a98df82654fe06d0665" translate="yes" xml:space="preserve">
          <source>. As a corollary, though the actual tree contains more nodes than our simplified example, the execution order is the same as in our example.</source>
          <target state="translated">. 실제 트리에는 단순화 된 예제보다 많은 노드가 포함되어 있지만 실행 순서는 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c525726c99728c892ca019d38a86d797ed1a27e8" translate="yes" xml:space="preserve">
          <source>. As yet there is nothing useful you can do with the object at the perl level.</source>
          <target state="translated">. 그럼에도 불구하고 펄 수준에서 객체로 할 수있는 유용한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a1ba0a96e2cd6c9d394a4472d471f9ff7cd31bc" translate="yes" xml:space="preserve">
          <source>. Assuming such an entry is found, various things then happen, depending on the value found:</source>
          <target state="translated">. 그러한 항목이 발견되면 발견 된 값에 따라 다양한 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da93ec95ac544504e474beee8e0bb9e569ea1865" translate="yes" xml:space="preserve">
          <source>. Basic blocks are sections of code that are entered only in the beginning and exited only at the end. For example, a conditional jump starts a basic block. Basic block profiling usually works by</source>
          <target state="translated">. 기본 블록은 처음에만 입력되고 끝에서만 종료되는 코드 섹션입니다. 예를 들어, 조건부 점프는 기본 블록을 시작합니다. 기본 블록 프로파일 링은 일반적으로</target>
        </trans-unit>
        <trans-unit id="922dde6fe40fcfb9ac9ff6d274634cfcd6f24ba2" translate="yes" xml:space="preserve">
          <source>. Because we want the program to continue after detecting this error, it is essential that the stack be tidied up by removing the</source>
          <target state="translated">. 이 오류를 감지 한 후 프로그램을 계속 진행하려면 스택을 제거하여 스택을 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="38b8a4a88265debcef2bc8e73467237aa68e829c" translate="yes" xml:space="preserve">
          <source>. Both &lt;code&gt;sub1()&lt;/code&gt; and &lt;code&gt;sub2()&lt;/code&gt; access the global variable &lt;code&gt;$x&lt;/code&gt; , once to read and once to write. Depending on factors ranging from your thread implementation's scheduling algorithm to the phase of the moon, &lt;code&gt;$x&lt;/code&gt; can be 2 or 3.</source>
          <target state="translated">. 두 &lt;code&gt;sub1()&lt;/code&gt; 및 &lt;code&gt;sub2()&lt;/code&gt; 액세스 전역 변수 &lt;code&gt;$x&lt;/code&gt; 한 번 읽기 및 쓰기에 한 번합니다. 스레드 구현의 스케줄링 알고리즘에서 달의 위상에 이르기까지 다양한 요인에 따라 &lt;code&gt;$x&lt;/code&gt; 는 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9064d30b3dca30231b47ba8d42e2cf553d0ed288" translate="yes" xml:space="preserve">
          <source>. Both &lt;code&gt;sub1()&lt;/code&gt; and &lt;code&gt;sub2()&lt;/code&gt; access the global variable &lt;code&gt;$x&lt;/code&gt;, once to read and once to write. Depending on factors ranging from your thread implementation's scheduling algorithm to the phase of the moon, &lt;code&gt;$x&lt;/code&gt; can be 2 or 3.</source>
          <target state="translated">. &lt;code&gt;sub1()&lt;/code&gt; 및 &lt;code&gt;sub2()&lt;/code&gt; 둘 다 전역 변수 &lt;code&gt;$x&lt;/code&gt; 액세스합니다 . 한 번은 읽고 쓰고 한 번은 쓸 수 있습니다. 스레드 구현의 스케줄링 알고리즘에서 달의 위상에 이르기까지 다양한 요인에 따라 &lt;code&gt;$x&lt;/code&gt; 는 2 또는 3이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998a439013a873f26870288508560a8fdb5f11eb" translate="yes" xml:space="preserve">
          <source>. But because of the nature of Macintosh paths, some additional possibilities are allowed to make using this routine give reasonable results for some common situations. In other words, you are also allowed to concatenate</source>
          <target state="translated">. 그러나 Macintosh 경로의 특성으로 인해이 루틴을 사용하면 몇 가지 일반적인 상황에서 합리적인 결과를 얻을 수있는 추가 가능성이 있습니다. 다시 말해, 당신은 또한 연결할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6917b39371bfc155816910776071467b756a0d87" translate="yes" xml:space="preserve">
          <source>. By default, the modification date of the input file will be used, or the current date if input comes from &lt;code&gt;STDIN&lt;/code&gt;, and will be based on UTC (so that the output will be reproducible regardless of local time zone).</source>
          <target state="translated">. 기본적으로 입력 파일의 수정 날짜가 사용되거나 입력이 &lt;code&gt;STDIN&lt;/code&gt; 에서 오는 경우 현재 날짜가 사용 되며 UTC를 기반으로합니다 (현지 시간대에 관계없이 출력을 재현 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="134d8dc01fba0b67a376310993c3d356147ceebd" translate="yes" xml:space="preserve">
          <source>. By default, this is set to the version of Perl you run &lt;b&gt;pod2man&lt;/b&gt; under. Setting this to the empty string will cause some *roff implementations to use the system default value.</source>
          <target state="translated">. 기본적으로 이것은 &lt;b&gt;pod2man&lt;/b&gt; 을 실행하는 Perl 버전으로 설정 됩니다. 이것을 빈 문자열로 설정하면 일부 * roff 구현에서 시스템 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd199e23140531c836914088d48f55487bf7e65c" translate="yes" xml:space="preserve">
          <source>. Can be used to make sure that the UTF-8 flag is on, so that &lt;code&gt;\w&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; work as Unicode on strings containing characters in the range 0x80-0xFF (on ASCII and derivatives).</source>
          <target state="translated">. UTF-8 플래그가 켜져 있는지 확인하여 &lt;code&gt;\w&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 0x80-0xFF 범위의 문자 (ASCII 및 파생어)를 포함하는 문자열에서 유니 코드로 작동하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b8d29b7aaa3a46be9be50380ab1ce3e867db600" translate="yes" xml:space="preserve">
          <source>. Chapters and page numbers are given using the following editions:</source>
          <target state="translated">. 장과 페이지 번호는 다음 판을 사용하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="995d80ebe5e9c631b25033fd42a932b6fa61b6b7" translate="yes" xml:space="preserve">
          <source>. Child subroutines have &lt;code&gt;_&lt;/code&gt; and the name length appended, so constants with 10 character names would be in &lt;code&gt;constant_10&lt;/code&gt; with the default</source>
          <target state="translated">. 하위 서브 루틴에는 &lt;code&gt;_&lt;/code&gt; 와 이름 길이가 추가되므로 10 개의 문자 이름을 가진 &lt;code&gt;constant_10&lt;/code&gt; 는 기본값과 함께 constant_10 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63971449e6c29f2a08f74ad23883b2558d36606" translate="yes" xml:space="preserve">
          <source>. Choice of American/British/Other spellings is left as an exercise for the author of each bit of documentation. When patching documentation, try to emulate the documentation around you, rather than changing the existing prose.</source>
          <target state="translated">. 미국 / 영국 / 기타 철자의 선택은 각 문서의 저자를위한 연습으로 남습니다. 문서를 패치 할 때는 기존 산문을 변경하지 말고 문서를 에뮬레이션하십시오.</target>
        </trans-unit>
        <trans-unit id="7250762f6576023d602a07cc49bcc6fd77306c0e" translate="yes" xml:space="preserve">
          <source>. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, &lt;code&gt;\r&lt;/code&gt; for a carriage return and &lt;code&gt;\a&lt;/code&gt; for a bell (or alert). If your string is better thought of as a sequence of arbitrary bytes, the octal escape sequence,</source>
          <target state="translated">. 일반적인 예는 탭의 경우 &lt;code&gt;\t&lt;/code&gt; , 줄 바꿈의 경우 &lt;code&gt;\n&lt;/code&gt; , 캐리지 리턴의 경우 &lt;code&gt;\r&lt;/code&gt; , 벨 (또는 경고)의 경우 &lt;code&gt;\a&lt;/code&gt; 입니다. 문자열이 임의의 바이트 시퀀스, 8 진수 이스케이프 시퀀스로 더 잘 생각되면</target>
        </trans-unit>
        <trans-unit id="58ab3092f216e58d0241856d21b4fdcc0acc1fa6" translate="yes" xml:space="preserve">
          <source>. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, &lt;code&gt;\r&lt;/code&gt; for a carriage return and &lt;code&gt;\a&lt;/code&gt; for a bell (or alert). If your string is better thought of as a sequence of arbitrary bytes, the octal escape sequence, e.g., &lt;code&gt;\033&lt;/code&gt; , or hexadecimal escape sequence, e.g., &lt;code&gt;\x1B&lt;/code&gt; may be a more natural representation for your bytes. Here are some examples of escapes:</source>
          <target state="translated">. 일반적인 예는 탭의 경우 &lt;code&gt;\t&lt;/code&gt; , 줄 바꾸기의 경우 &lt;code&gt;\n&lt;/code&gt; , 캐리지 리턴의 경우 &lt;code&gt;\r&lt;/code&gt; , 종소리 (또는 경고)의 경우 &lt;code&gt;\a&lt;/code&gt; 입니다. 문자열이 임의의 바이트 시퀀스로 더 잘 생각되면 8 진 이스케이프 시퀀스 (예 : &lt;code&gt;\033&lt;/code&gt; ) 또는 16 진 이스케이프 시퀀스 (예 : &lt;code&gt;\x1B&lt;/code&gt; 가 바이트에 대한보다 자연스러운 표현 일 수 있습니다. 탈출의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d7e30195a0de047a3242c04e44600623627b182" translate="yes" xml:space="preserve">
          <source>. Copy or link</source>
          <target state="translated">. 복사 또는 링크</target>
        </trans-unit>
        <trans-unit id="79825b16c77c06b44977118fac4eea014741e249" translate="yes" xml:space="preserve">
          <source>. Currently OS/2 support of threads is very preliminary.</source>
          <target state="translated">. 현재 스레드에 대한 OS / 2 지원은 매우 예비 적입니다.</target>
        </trans-unit>
        <trans-unit id="135c9f2f36a34ddc0a2893c23665c762d2104afc" translate="yes" xml:space="preserve">
          <source>. Currently the maximum possible number of distinct regops is restricted to 256, with about a quarter already used.</source>
          <target state="translated">. 현재 최대 가능한 개별 레포 수는 256 개로 제한되며 약 1/4이 이미 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a874263e45933953bf0ed324a58df137c7e708" translate="yes" xml:space="preserve">
          <source>. Currently, there are only two styles: &lt;code&gt;lib&lt;/code&gt; and</source>
          <target state="translated">. 현재는 두 가지 스타일이 있습니다 : &lt;code&gt;lib&lt;/code&gt; 와</target>
        </trans-unit>
        <trans-unit id="53e5505050f1982d7363ce9cde826d9f92f57a58" translate="yes" xml:space="preserve">
          <source>. Decoding will terminate when $terminator (a string) appears in output.</source>
          <target state="translated">. $ terminator (문자열)가 출력에 나타나면 디코딩이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b4d5356abfd15d96c68ec478d2dd65b1348c5fec" translate="yes" xml:space="preserve">
          <source>. Determines how to map a Unicode character into a byte sequence.</source>
          <target state="translated">. 유니 코드 문자를 바이트 시퀀스로 매핑하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="59c539a141527ad47946cca8b46d791f7d164400" translate="yes" xml:space="preserve">
          <source>. Do not disturb that installation unless you really know what you are doing. If you remove the perl supplied with the OS, you will render some bits of your system inoperable. If you wish to install a newer version of perl, install it under a different prefix from /usr/perl5. Common prefixes to use are /usr/local and /opt/perl.</source>
          <target state="translated">. 당신이하고있는 일을 정말로 모른다면 그 설치를 방해하지 마십시오. OS와 함께 제공된 perl을 제거하면 시스템의 일부 비트가 작동하지 않게됩니다. 최신 버전의 perl을 설치하려면 / usr / perl5와 다른 접두사로 설치하십시오. 사용할 일반적인 접두사는 / usr / local 및 / opt / perl입니다.</target>
        </trans-unit>
        <trans-unit id="93b36a13a574d58a76b40f626c241af718c19914" translate="yes" xml:space="preserve">
          <source>. Don't use them in production code. Yet.</source>
          <target state="translated">. 프로덕션 코드에서는 사용하지 마십시오. 아직.</target>
        </trans-unit>
        <trans-unit id="7fd37bab10468d9938f078309153e9437be5450a" translate="yes" xml:space="preserve">
          <source>. E.g.</source>
          <target state="translated">. 예 :</target>
        </trans-unit>
        <trans-unit id="25ce36fbbb17f8d1b0a4109d1371fa2f34186024" translate="yes" xml:space="preserve">
          <source>. Each has at least four hexdigits.</source>
          <target state="translated">. 각각에는 최소한 4 개의 16 진수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4404b6be911fb9ccd359c1128f3d94cffa4c329" translate="yes" xml:space="preserve">
          <source>. Each has at least four hexdigits. The codes may be preceded by a word enclosed in angle brackets, then a space, like &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt; , giving the type of decomposition</source>
          <target state="translated">. 각각에는 최소한 4 개의 16 진수가 있습니다. 코드 앞에는 꺾쇠 괄호로 묶은 단어가 붙은 다음 &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt; 와 같이 공백 이있어 분해 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="198cd1fd252c543c7320dd12efcd77fe03ea2db7" translate="yes" xml:space="preserve">
          <source>. Each has at least four hexdigits. The codes may be preceded by a word enclosed in angle brackets, then a space, like &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt;, giving the type of decomposition</source>
          <target state="translated">. 각각에는 최소 4 개의 16 진수가 있습니다. 코드는 꺾쇠 괄호로 묶인 단어와 &lt;code&gt;&amp;lt;compat&amp;gt; &lt;/code&gt; 과 같은 공백이 선행하여 분해 유형을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63141e3b2c36400b64267234149999ae2c55ef9a" translate="yes" xml:space="preserve">
          <source>. Either because it doesn't make sense to back-port that part of the API, or simply because it hasn't been implemented yet. Patches welcome!</source>
          <target state="translated">. API의 해당 부분을 백 포트하는 것이 타당하지 않거나 아직 구현되지 않았기 때문입니다. 패치 환영합니다!</target>
        </trans-unit>
        <trans-unit id="66213f4444d55cf06422645edab101d784d01cec" translate="yes" xml:space="preserve">
          <source>. Except on Windows, this will continue to use certain of the POSIX 2008 functions in some situations. If these are buggy, you can pass the following to</source>
          <target state="translated">. Windows를 제외하고는 일부 상황에서 특정 POSIX 2008 기능을 계속 사용합니다. 버그가있는 경우 다음을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103da34daa28d7627bfd7c2b3ec90e61135c836c" translate="yes" xml:space="preserve">
          <source>. Finally, the &quot;.&quot; metacharacter matches any character except &quot;\n&quot; (unless you use &lt;code&gt;/s&lt;/code&gt;).</source>
          <target state="translated">. 마지막으로 &quot;.&quot; 메타 문자는 &quot;\ n&quot;을 제외한 모든 문자와 일치합니다 ( &lt;code&gt;/s&lt;/code&gt; 를 사용하지 않는 경우 ).</target>
        </trans-unit>
        <trans-unit id="dd14e4e8fe1dec95a597ebea05ec4794df85b973" translate="yes" xml:space="preserve">
          <source>. For compatibility with Unix usage, the type and version may also be omitted.</source>
          <target state="translated">. Unix 사용과의 호환성을 위해 유형 및 버전도 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e6eee63986fc4ab76895ba12b2ec35a0403931" translate="yes" xml:space="preserve">
          <source>. For each thing you test, an &lt;code&gt;ok&lt;/code&gt; is printed. Simple. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; interprets your test results to determine if you succeeded or failed (more on that later).</source>
          <target state="translated">. 테스트하는 각 항목에 대해 &lt;code&gt;ok&lt;/code&gt; 가 인쇄됩니다. 단순한. &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 는 테스트 결과를 해석하여 성공 여부를 결정합니다 (나중에 자세히 설명).</target>
        </trans-unit>
        <trans-unit id="b3d2c0dfaacb26c7f33418797db935878bbdde14" translate="yes" xml:space="preserve">
          <source>. For example,</source>
          <target state="translated">. 예를 들어</target>
        </trans-unit>
        <trans-unit id="740611fcdc6870a843c2364c8e58c7ed97b112e4" translate="yes" xml:space="preserve">
          <source>. For example, a Korean Hangul syllable is considered a single logical character, but most often consists of three actual Unicode characters: a leading consonant followed by an interior vowel followed by a trailing consonant.</source>
          <target state="translated">. 예를 들어 한국어 한글 음절은 하나의 논리 문자로 간주되지만 대부분 3 개의 실제 유니 코드 문자로 구성됩니다. 선행 자음, 내부 모음, 뒤에 자음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce03d7971acdd7f9bb1878ccf1c234bf855ffee" translate="yes" xml:space="preserve">
          <source>. For example, if you had tests in:</source>
          <target state="translated">. 예를 들어 다음과 같은 테스트가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="042727f423f9fa6f93e1e3706fb37670c040c890" translate="yes" xml:space="preserve">
          <source>. For example, if your code would normally go into</source>
          <target state="translated">. 예를 들어 코드가 일반적으로</target>
        </trans-unit>
        <trans-unit id="4f3f25bc941622e7175e3969043f856eeb61133e" translate="yes" xml:space="preserve">
          <source>. For example, they may crash the Perl interpreter during execution, or may dump core on termination. Depending on the module and the requirements of your application, it may be possible to work around such difficulties.</source>
          <target state="translated">. 예를 들어, 실행 중에 Perl 인터프리터가 충돌하거나 종료시 코어를 덤프 할 수 있습니다. 모듈과 응용 프로그램 요구 사항에 따라 이러한 어려움을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17ecac96b1adb18dd520ee9c0b9bae11aca3ab3" translate="yes" xml:space="preserve">
          <source>. For example:</source>
          <target state="translated">. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fddca2af68b08afcb09b50d2195be9684be0734" translate="yes" xml:space="preserve">
          <source>. For exploring Unicode character names and character properties, see its</source>
          <target state="translated">. 유니 코드 문자 이름 및 문자 속성을 살펴 보려면</target>
        </trans-unit>
        <trans-unit id="03024fb1bbe5faa78991a7214c34450e71dc2c32" translate="yes" xml:space="preserve">
          <source>. For other data types, or to examine return values, you'll need to manipulate the Perl stack. That's demonstrated in &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;&quot;Fiddling with the Perl stack from your C program&quot;&lt;/a&gt;.</source>
          <target state="translated">. 다른 데이터 유형의 경우 또는 반환 값을 검사하려면 Perl 스택을 조작해야합니다. 이는 &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;&quot;C 프로그램에서 Perl 스택 다루기&quot;&lt;/a&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="547c378c2449b9e81e8aa82ca93843bb7c621101" translate="yes" xml:space="preserve">
          <source>. For other data types, or to examine return values, you'll need to manipulate the Perl stack. That's demonstrated in &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;Fiddling with the Perl stack from your C program&lt;/a&gt;.</source>
          <target state="translated">. 다른 데이터 형식이나 반환 값을 확인하려면 Perl 스택을 조작해야합니다. 그것은 &lt;a href=&quot;#Fiddling-with-the-Perl-stack-from-your-C-program&quot;&gt;C 프로그램의 Perl 스택&lt;/a&gt; 으로 Fiddling 에서 시연됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdc504208ff194a9a78aeb193e18917b2314acc4" translate="yes" xml:space="preserve">
          <source>. FreeBSD 7 and earlier has a bug where either approach sometimes returns an incorrect value (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&lt;/a&gt; ). In these cases perl will fall back to the old behaviour of using C's &lt;code&gt;argv[0]&lt;/code&gt; value for &lt;code&gt;$^X&lt;/code&gt;.</source>
          <target state="translated">. FreeBSD 7 및 이전 버전에는 두 가지 방법 중 하나가 잘못된 값을 반환하는 버그가 있습니다 ( &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 참조&lt;/a&gt; ). 이 경우 perl은 &lt;code&gt;$^X&lt;/code&gt; 대해 C의 &lt;code&gt;argv[0]&lt;/code&gt; 값을 사용하는 이전 동작으로 되돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="9acfc198f0b2223d41f4211f848b117ef3bae556" translate="yes" xml:space="preserve">
          <source>. FreeBSD 7 and earlier has a bug where either approach sometimes returns an incorrect value (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&lt;/a&gt; ). In these cases perl will fall back to the old behaviour of using C's argv[0] value for &lt;code&gt;$^X&lt;/code&gt; .</source>
          <target state="translated">. FreeBSD 7 및 이전 버전은 두 가지 방법 중 하나가 때때로 잘못된 값을 반환하는 버그가 있습니다 ( &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=35703 참조&lt;/a&gt; ). 이 경우 perl은 &lt;code&gt;$^X&lt;/code&gt; C의 argv [0] 값을 사용하는 이전 동작으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="776299a173a3d589b8f3795e2f8b4c589b03ee73" translate="yes" xml:space="preserve">
          <source>. Given the amount of time between releases of Perl the version that ships with Perl is quite likely to be out of date, so the most recent version can always be found on CPAN (see &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;&quot;CPAN&quot; in perlmodlib&lt;/a&gt; for details), in the directory</source>
          <target state="translated">. Perl 릴리스 사이의 시간을 감안할 때 Perl과 함께 제공되는 버전은 구식 일 가능성이 매우 높으므로 가장 최신 버전은 항상 CPAN에서 찾을 수 있습니다 ( 자세한 내용 &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;은 perlmodlib의 &quot;CPAN&quot;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5f2b60383e9beeed5eccc01696d85bb58945bce4" translate="yes" xml:space="preserve">
          <source>. Given the amount of time between releases of Perl the version that ships with Perl is quite likely to be out of date, so the most recent version can always be found on CPAN (see &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;CPAN in perlmodlib&lt;/a&gt; for details), in the directory</source>
          <target state="translated">. Perl 릴리스 사이의 시간이 주어지면 Perl과 함께 제공되는 버전이 최신 버전이 아닐 수 있으므로 최신 버전은 항상 CPAN ( &lt;a href=&quot;perlmodlib#CPAN&quot;&gt;perlmodlib의 CPAN&lt;/a&gt; 참조) 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f9e68beb7f0b151bc8fceae81cb1b8ad5d7794e" translate="yes" xml:space="preserve">
          <source>. Having perl build itself would be impossible with</source>
          <target state="translated">. 펄 빌드 자체를 갖는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="1a7251116ddbed3c5631886b0448ee300597e327" translate="yes" xml:space="preserve">
          <source>. Here is a regexp with nested groups:</source>
          <target state="translated">. 다음은 중첩 그룹이있는 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="e70c7aa2494034e63eb8b4f2b22846a01d30041b" translate="yes" xml:space="preserve">
          <source>. However, it is possible to</source>
          <target state="translated">. 그러나</target>
        </trans-unit>
        <trans-unit id="41c7fa0e40900a8664ba983241943a10f0848bc9" translate="yes" xml:space="preserve">
          <source>. However, your host system and Cygwin configuration will affect Perl's runtime behavior (see &lt;a href=&quot;#TEST&quot;&gt;&quot;TEST&quot;&lt;/a&gt;).</source>
          <target state="translated">. 그러나 호스트 시스템과 Cygwin 구성은 Perl의 런타임 동작에 영향을줍니다 ( &lt;a href=&quot;#TEST&quot;&gt;&quot;TEST&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c7a0e55016332e0c5271c0854d6a9c26c89598fb" translate="yes" xml:space="preserve">
          <source>. However, your host system and Cygwin configuration will affect Perl's runtime behavior (see &lt;a href=&quot;#TEST&quot;&gt;TEST&lt;/a&gt;).</source>
          <target state="translated">. 그러나 호스트 시스템 및 Cygwin 구성은 Perl의 런타임 동작에 영향을 미칩니다 ( &lt;a href=&quot;#TEST&quot;&gt;테스트&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="96283c0c3b8fe3d7cdfa1e152ea82dd4983135dd" translate="yes" xml:space="preserve">
          <source>. I suggest only to use this option to parse application-specific files written by humans (configuration files, resource files etc.)</source>
          <target state="translated">. 이 옵션을 사용하여 사람이 작성한 응용 프로그램 별 파일 (구성 파일, 리소스 파일 등)을 구문 분석하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f863c23a93501fd973cdcb1d746f38bd8aa20cad" translate="yes" xml:space="preserve">
          <source>. If</source>
          <target state="translated">. 만약</target>
        </trans-unit>
        <trans-unit id="7f0c2910442f1f0b575ce98071a1f0ff5753a782" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;quoteHighBit&lt;/code&gt; is set, they will be quoted.</source>
          <target state="translated">. 경우 &lt;code&gt;quoteHighBit&lt;/code&gt; 가 설정되어, 그들은 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="da97ea613d41ccc8d570e6df5a8ec2180521c7e4" translate="yes" xml:space="preserve">
          <source>. If a group did not match, the associated backreference won't match either. (This can happen if the group is optional, or in a different branch of an alternation.) You can omit the &lt;code&gt;&quot;g&quot;&lt;/code&gt;, and write &lt;code&gt;&quot;\1&quot;&lt;/code&gt;,</source>
          <target state="translated">. 그룹이 일치하지 않으면 연관된 역 참조도 일치하지 않습니다. (그룹이 선택 사항입니다, 또는 교대의 다른 지점에서 경우가 발생할 수 있습니다.) 당신은 생략 할 수 있습니다 &lt;code&gt;&quot;g&quot;&lt;/code&gt; , 및 쓰기 &lt;code&gt;&quot;\1&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d44fe27c9789df6d9edbedc8e0441cfadb796292" translate="yes" xml:space="preserve">
          <source>. If all that fails it &lt;code&gt;croak&lt;/code&gt; s.</source>
          <target state="translated">. 모든 것이 실패하면 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b2357e7fcb2bcf90785e6fef6ea540ef76b840" translate="yes" xml:space="preserve">
          <source>. If all that fails it &lt;code&gt;croak&lt;/code&gt;s.</source>
          <target state="translated">. 그것을 실패하는 모든 경우, &lt;code&gt;croak&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="dbe4ccac3b5962271b48921e81142f21abf8b496" translate="yes" xml:space="preserve">
          <source>. If an object is a noun, then methods are its verbs (save, print, open).</source>
          <target state="translated">. 객체가 명사 인 경우 메소드는 동사 (저장, 인쇄, 열기)입니다.</target>
        </trans-unit>
        <trans-unit id="d6d823fabc5313d54be7c53757154c9b35bde3e3" translate="yes" xml:space="preserve">
          <source>. If called as a class method, a new object is created; if called as an instance method, the object is reset to the state contained in</source>
          <target state="translated">. 클래스 메소드로 호출되면 새 오브젝트가 작성됩니다. 인스턴스 메소드로 호출되면 객체가 포함 된 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2be741d48d441b8c30f1f1c49c12f9fc308d28a8" translate="yes" xml:space="preserve">
          <source>. If defined, it should be a search list, each element of which specifies a location for &lt;code&gt;%ENV&lt;/code&gt; elements. If you tell Perl to read or set the element &lt;code&gt;$ENV{&lt;/code&gt;</source>
          <target state="translated">. 정의 된 경우 검색 목록이어야하며 각 요소는 &lt;code&gt;%ENV&lt;/code&gt; 요소 의 위치를 ​​지정합니다 . Perl에게 &lt;code&gt;$ENV{&lt;/code&gt; 요소를 읽거나 설정하도록 지시하면</target>
        </trans-unit>
        <trans-unit id="cb88233b9470d06775dbd0f8abd50e567ad6f88f" translate="yes" xml:space="preserve">
          <source>. If found, Perl checks the start of the file for magic strings &lt;code&gt;&quot;#!&quot;&lt;/code&gt; and &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; . If found, Perl uses the rest of the first line as the beginning of the command line to run this script. The only mangling done to the first line is extraction of arguments (currently up to 3), and ignoring of the path-part of the &quot;interpreter&quot; name if it can't be found using the full path.</source>
          <target state="translated">. 발견되면, Perl은 파일의 시작 부분에서 매직 문자열 &lt;code&gt;&quot;#!&quot;&lt;/code&gt; 를 확인합니다.그리고 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; . 발견되면 Perl은 나머지 첫 번째 행을 명령 행의 시작으로 사용하여이 스크립트를 실행합니다. 첫 번째 행에서 수행되는 유일한 문제는 인수를 추출하고 (현재 최대 3 개) &quot;통역사&quot;이름의 경로 부분을 전체 경로를 사용하여 찾을 수없는 경우 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef1e5bf8cac901010071b6fa1937db5cb94871bc" translate="yes" xml:space="preserve">
          <source>. If found, Perl checks the start of the file for magic strings &lt;code&gt;&quot;#!&quot;&lt;/code&gt; and &lt;code&gt;&quot;extproc &quot;&lt;/code&gt;. If found, Perl uses the rest of the first line as the beginning of the command line to run this script. The only mangling done to the first line is extraction of arguments (currently up to 3), and ignoring of the path-part of the &quot;interpreter&quot; name if it can't be found using the full path.</source>
          <target state="translated">. 발견되면 Perl은 파일 시작에서 매직 문자열 &lt;code&gt;&quot;#!&quot;&lt;/code&gt; 을 확인합니다. 및 &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; . 발견되면 Perl은 첫 번째 줄의 나머지 부분을 명령 줄의 시작으로 사용하여이 스크립트를 실행합니다. 첫 번째 줄에 수행되는 유일한 변경은 인수 (현재 최대 3 개)를 추출하고 전체 경로를 사용하여 찾을 수없는 경우 &quot;interpreter&quot;이름의 경로 부분을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7968febd03fe8bde1f86e5757cb445071be1de4f" translate="yes" xml:space="preserve">
          <source>. If it does not give an error -- wrong</source>
          <target state="translated">. 오류가 발생하지 않으면 잘못</target>
        </trans-unit>
        <trans-unit id="3246f36b641961e96375e555d041b988c40cef52" translate="yes" xml:space="preserve">
          <source>. If it has no repeat count or uses a '*', the number of available items is used.</source>
          <target state="translated">. 반복 횟수가 없거나 '*'를 사용하면 사용 가능한 항목 수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdd29a6866d7877a8bab1f7946635ac6580b7bf2" translate="yes" xml:space="preserve">
          <source>. If successful, the instance</source>
          <target state="translated">. 성공하면 인스턴스</target>
        </trans-unit>
        <trans-unit id="c4f93a6d580968e7afb023f127bdef8253516411" translate="yes" xml:space="preserve">
          <source>. If the &lt;code&gt;/a&lt;/code&gt; regular expression modifier is in effect, it matches [0-9]. Otherwise, it matches anything that is matched by &lt;code&gt;\p{Digit}&lt;/code&gt; , which includes [0-9]. (An unlikely possible exception is that under locale matching rules, the current locale might not have &lt;code&gt;[0-9]&lt;/code&gt; matched by &lt;code&gt;\d&lt;/code&gt; , and/or might match other characters whose code point is less than 256. The only such locale definitions that are legal would be to match &lt;code&gt;[0-9]&lt;/code&gt; plus another set of 10 consecutive digit characters; anything else would be in violation of the C language standard, but Perl doesn't currently assume anything in regard to this.)</source>
          <target state="translated">. 는 IF &lt;code&gt;/a&lt;/code&gt; 정규식 개질제 사실상, 그것은 [0-9]와 일치한다. 그렇지 않으면 &lt;code&gt;\p{Digit}&lt;/code&gt; 과 일치하는 항목 ( [0-9] 포함 )과 일치합니다 . 로케일 일치 규칙에서 현재 로케일이 &lt;code&gt;\d&lt;/code&gt; 와 일치하는 &lt;code&gt;[0-9]&lt;/code&gt; 를 갖지 않거나 코드 포인트가 256보다 작은 다른 문자와 일치 할 수 있습니다. 합법적 인 것은 &lt;code&gt;[0-9]&lt;/code&gt; 와 10 개의 연속 숫자 문자를 추가하는 것입니다. 다른 언어는 C 언어 표준을 위반하지만, Perl은 현재 이것과 관련하여 어떤 것도 가정하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="34d095c4fc5388357c2c64a5e30566b16b7806a1" translate="yes" xml:space="preserve">
          <source>. If the &lt;code&gt;/a&lt;/code&gt; regular expression modifier is in effect, it matches [0-9]. Otherwise, it matches anything that is matched by &lt;code&gt;\p{Digit}&lt;/code&gt;, which includes [0-9]. (An unlikely possible exception is that under locale matching rules, the current locale might not have &lt;code&gt;[0-9]&lt;/code&gt; matched by &lt;code&gt;\d&lt;/code&gt;, and/or might match other characters whose code point is less than 256. The only such locale definitions that are legal would be to match &lt;code&gt;[0-9]&lt;/code&gt; plus another set of 10 consecutive digit characters; anything else would be in violation of the C language standard, but Perl doesn't currently assume anything in regard to this.)</source>
          <target state="translated">. 는 IF &lt;code&gt;/a&lt;/code&gt; 정규식 개질제 사실상, 그것은 [0-9]와 일치한다. 그렇지 않으면 [0-9]를 포함 하는 &lt;code&gt;\p{Digit}&lt;/code&gt; 와 일치하는 모든 항목과 일치 합니다. (불가능할 가능성이없는 예외는 로케일 일치 규칙에서 현재 로케일이 &lt;code&gt;\d&lt;/code&gt; 와 일치하는 &lt;code&gt;[0-9]&lt;/code&gt; 를 갖지 않거나 코드 포인트가 256 미만인 다른 문자와 일치 할 수 있다는 것입니다. legal은 &lt;code&gt;[0-9]&lt;/code&gt; 와 10 개의 연속 된 숫자 문자의 다른 집합 을 일치시키는 것입니다. 다른 모든 것은 C 언어 표준을 위반하지만 Perl은 현재 이와 관련하여 어떤 것도 가정하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="ed7f56f814a53f5d8a3417d988acd289ad7a8311" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, or equal to the empty string, the state information will be read from STDIN.</source>
          <target state="translated">. 인수가 없거나 빈 문자열과 같으면 STDIN에서 상태 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5824b191dbb77148d2f73c4545651fad0017e95b" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, or equal to the empty string, the state information will be written to STDOUT.</source>
          <target state="translated">. 인수가 없거나 빈 문자열과 같으면 상태 정보가 STDOUT에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="86c19918bb0e315fb37ff3bcb89d4d1d00e53177" translate="yes" xml:space="preserve">
          <source>. If the argument is missing, the object will continue using the same algorithm that was selected at creation.</source>
          <target state="translated">. 인수가 누락되면 객체는 생성시 선택한 것과 동일한 알고리즘을 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad394d00d49595ece3375d873bc65795f9a2a320" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_bin&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값이&amp;gt; UV_MAX의 경우 &lt;code&gt;grok_bin&lt;/code&gt; 의 반환 UV_MAX, 설정 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="340acc0c90a3ff630e29f3732ec436ada4a5d8ab" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_hex&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값이&amp;gt; UV_MAX 경우 &lt;code&gt;grok_hex&lt;/code&gt; 반환 UV_MAX, 설정 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="d2fe051154b3bd8b24a4c3334242986da9165e62" translate="yes" xml:space="preserve">
          <source>. If the value is &amp;gt; UV_MAX &lt;code&gt;grok_oct&lt;/code&gt; returns UV_MAX, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes the value to</source>
          <target state="translated">. 값 인 경우&amp;gt; UV_MAX의 &lt;code&gt;grok_oct&lt;/code&gt; 는 설정, UV_MAX를 반환 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 를 출력 플래그에서, 그리고에 값을 기록</target>
        </trans-unit>
        <trans-unit id="206aba5c7d9a84ce157c9a5e9c114a73d70137fc" translate="yes" xml:space="preserve">
          <source>. If there is no single code point folding defined for</source>
          <target state="translated">. 단일 코드 포인트 폴딩이 정의되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="1844efc2f3254e2a8d6a689f5eb6ab9ff69cba74" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c3aca0699f7236e45654ffe7027a808f1c3c2b60" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions. If the array becomes smaller then entries beyond count should be deleted.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다. 배열이 작아지면 개수를 초과하는 항목을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="08fb67d65bc5a9b5387592c9b07f875d13efe0ce" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; should be returned for new positions. If the array becomes smaller then entries beyond count should be deleted.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 매핑 이 반환되어야합니다. 배열이 작아지면 개수를 초과하는 항목을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e37729bd5e4487339f7d4fb9164549c3140fefc" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;undef&lt;/code&gt; should be returned for new positions.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;undef&lt;/code&gt; 매핑 이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dab97cd2cfab8913e7503a61e2eea4e88edee518" translate="yes" xml:space="preserve">
          <source>. If this makes the array larger then class's mapping of &lt;code&gt;undef&lt;/code&gt; should be returned for new positions. If the array becomes smaller then entries beyond count should be deleted.</source>
          <target state="translated">. 이것이 배열을 더 크게 만들면 새로운 위치에 대해 클래스의 &lt;code&gt;undef&lt;/code&gt; 매핑 이 반환되어야합니다. 배열이 작아지면 개수를 초과하는 항목을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b55cfc74642aa13a70757a2bc05c0c5ec795164" translate="yes" xml:space="preserve">
          <source>. If you are unsure about the proper location of a file that may have gotten copied while building the source distribution, consult the</source>
          <target state="translated">. 소스 배포판을 빌드하는 동안 복사되었을 수있는 파일의 적절한 위치에 대해 확실하지 않은 경우 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="42dfc7aa5f4468ffdf4e181f7b588d8c5857bc31" translate="yes" xml:space="preserve">
          <source>. If you get into link386 prompts, press &lt;code&gt;Ctrl-C&lt;/code&gt; to exit.</source>
          <target state="translated">. link386 프롬프트가 표시되면 &lt;code&gt;Ctrl-C&lt;/code&gt; 를 눌러 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7886d9569f9834e6bdaa9aa8eb1f34132432b7" translate="yes" xml:space="preserve">
          <source>. If you have such data then you should set &lt;code&gt;$Storable::interwork_56_64bit&lt;/code&gt; to a true value to make this Storable read and write files with the old header. You should also migrate your data, or any older perl you are communicating with, to this current version of Storable.</source>
          <target state="translated">. 이러한 데이터가있는 경우 &lt;code&gt;$Storable::interwork_56_64bit&lt;/code&gt; 를 true로 설정하여이 Storable이 기존 헤더로 파일을 읽고 쓸 수있게하십시오. 또한 데이터 또는 통신중인 이전 펄을이 현재 버전의 Storable로 마이그레이션해야합니다.</target>
        </trans-unit>
        <trans-unit id="d408ab7cf188c609a4c4840fba41a06a381a4651" translate="yes" xml:space="preserve">
          <source>. If your input lines might end in backslashes to indicate continuation, you want to skip ahead and get the next record.</source>
          <target state="translated">. 연속을 나타 내기 위해 입력 행이 백 슬래시로 끝나는 경우 계속 건너 뛰고 다음 레코드를 얻으려고합니다.</target>
        </trans-unit>
        <trans-unit id="1e5ca4130c539ef91a8bd43fde83a107301c6560" translate="yes" xml:space="preserve">
          <source>. If your platform doesn't support &lt;code&gt;NaN&lt;/code&gt; 's then &lt;code&gt;NaN&lt;/code&gt; is just a string with numeric value 0.</source>
          <target state="translated">. 플랫폼이 지원하지 않는 경우 &lt;code&gt;NaN&lt;/code&gt; 이 다음의를 &lt;code&gt;NaN&lt;/code&gt; 이는 숫자 값 0 단지 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b6f709ff143f9f57f5b144c58bc6a764f7c6db40" translate="yes" xml:space="preserve">
          <source>. If your platform doesn't support &lt;code&gt;NaN&lt;/code&gt;'s then &lt;code&gt;NaN&lt;/code&gt; is just a string with numeric value 0.</source>
          <target state="translated">. 플랫폼이 지원하지 않는 경우 &lt;code&gt;NaN&lt;/code&gt; 이 다음의를 &lt;code&gt;NaN&lt;/code&gt; 이는 숫자 값 0 단지 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a4ca80b61fe20e9969c2abb733817edd354f5d14" translate="yes" xml:space="preserve">
          <source>. In 2010, version 2 of the &lt;a href=&quot;../cpan/meta/spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; was released, which mandates JSON format for the metadata in order to overcome certain compatibility issues between YAML serializers and to avoid breaking older clients unable to handle a new version of the spec. The &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; library is now standard for accessing old and new-style Meta files.</source>
          <target state="translated">. 2010 년에 &lt;a href=&quot;../cpan/meta/spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt; 버전 2 가 릴리스되었습니다.이 버전은 YAML 시리얼 라이저 간의 특정 호환성 문제를 극복하고 새로운 버전의 사양을 처리 할 수없는 이전 클라이언트의 중단을 피하기 위해 메타 데이터에 대한 JSON 형식을 요구합니다. &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: 메타&lt;/a&gt; 도서관은 이제 과거와 새로운 스타일의 메타 파일에 액세스하기위한 표준이다.</target>
        </trans-unit>
        <trans-unit id="3d4088bf6eb687364405a322e155ff1cc18adb96" translate="yes" xml:space="preserve">
          <source>. In 2010, version 2 of the &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; was released, which mandates JSON format for the metadata in order to overcome certain compatibility issues between YAML serializers and to avoid breaking older clients unable to handle a new version of the spec. The &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN::Meta&lt;/a&gt; library is now standard for accessing old and new-style Meta files.</source>
          <target state="translated">. 2010 년에 &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt; 버전 2 가 출시되었습니다.이 버전은 YAML 직렬화 기 간의 특정 호환성 문제를 극복하고 새 버전의 사양을 처리 할 수없는 이전 클라이언트가 손상되는 것을 방지하기 위해 메타 데이터에 대한 JSON 형식을 요구합니다. &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN :: 메타&lt;/a&gt; 도서관은 이제 과거와 새로운 스타일의 메타 파일에 액세스하기위한 표준이다.</target>
        </trans-unit>
        <trans-unit id="d1c4b644424154ce3fe835b9230b290135cb482a" translate="yes" xml:space="preserve">
          <source>. In addition, if none of the functions in a list begin with the string &lt;b&gt;boot_&lt;/b&gt;, &lt;code&gt;Mksymlists&lt;/code&gt; will add a bootstrap function for that package, just as xsubpp does. (If a &lt;b&gt;boot_&amp;lt;pkg&amp;gt;&lt;/b&gt; function is present in the list, it is passed through unchanged.) If DL_FUNCS is not specified, it defaults to the bootstrap function for the extension specified in NAME.</source>
          <target state="translated">. 또한,리스트의 어떤 함수도 문자열 &lt;b&gt;boot_로&lt;/b&gt; 시작하지 &lt;b&gt;않으면&lt;/b&gt; , &lt;code&gt;Mksymlists&lt;/code&gt; 는 xsubpp와 마찬가지로 해당 패키지에 대한 부트 스트랩 함수를 추가합니다. (a 경우 &lt;b&gt;boot_ &amp;lt;PKG&amp;gt;&lt;/b&gt; 기능 목록에 존재하고, 그것은 그대로 통과한다.) DL_FUNCS 지정하지 않으면, 디폴트 NAME에 지정된 내선 부트 스트랩 기능.</target>
        </trans-unit>
        <trans-unit id="4f54f5e8eb8e964c049379a404dfcd3f689f59be" translate="yes" xml:space="preserve">
          <source>. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">. 사실 문자열을 길이 함수로 분할하는 방법은 기하 급수적으로 많습니다. 정규 표현식은 운이 좋으며 프로세스 초기에 일치 할 수 있지만 일치하는 항목이 없으면 Perl은 다음을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c632e42e7e1458b43dc1ad99933142821a596870" translate="yes" xml:space="preserve">
          <source>. In fact,</source>
          <target state="translated">. 사실로,</target>
        </trans-unit>
        <trans-unit id="bce9b2b9f8142db7d9ce85b3fc070c1b985539e3" translate="yes" xml:space="preserve">
          <source>. In geographical terms</source>
          <target state="translated">. 지리적으로</target>
        </trans-unit>
        <trans-unit id="87c6ca62a4ff7bfc3de8b73b2cb60e71a538d7f6" translate="yes" xml:space="preserve">
          <source>. In the unlikely case this is not the correct root, it is possible to override this with a hint value or command line option. This will be used in subsequent tests for AFSness in the configure and test process.</source>
          <target state="translated">. 드문 경우이지만 이것이 올바른 루트가 아닌 경우 힌트 값 또는 명령 행 옵션으로이를 대체 할 수 있습니다. 이는 구성 및 테스트 프로세스에서 AFSness에 대한 후속 테스트에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbd585e38f590ba194a3793f06f22dab045cf12" translate="yes" xml:space="preserve">
          <source>. In this case all the above are true (but very simple) functions which call the underlying implementation.</source>
          <target state="translated">. 이 경우 위의 모든 것은 기본 구현을 호출하는 참 (그러나 매우 간단한) 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d360c3eb53a832cf7747d52bf236e2b0eebf4a3e" translate="yes" xml:space="preserve">
          <source>. In those cases when you &lt;b&gt;require&lt;/b&gt; a &lt;b&gt;.ph&lt;/b&gt; file containing syntax errors, instead of the cryptic</source>
          <target state="translated">. 이 경우 암호 대신 구문 오류가 포함 된 &lt;b&gt;.ph&lt;/b&gt; 파일 이 &lt;b&gt;필요한&lt;/b&gt; 경우&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7b376a04246f5e00596e857391b316083a63b99d" translate="yes" xml:space="preserve">
          <source>. In turn, this hooks into an XSUB,</source>
          <target state="translated">. 차례로 이것은 XSUB에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3420f60f0bca96a2a73c405a1a85c20704cb3bc5" translate="yes" xml:space="preserve">
          <source>. Individual modules in</source>
          <target state="translated">. 개별 모듈</target>
        </trans-unit>
        <trans-unit id="a59f10c336a81d1ca73f037a2b8c92f6334418a6" translate="yes" xml:space="preserve">
          <source>. Inspect the &lt;code&gt;install&lt;/code&gt; logs (in the example above</source>
          <target state="translated">. 위의 예에서 &lt;code&gt;install&lt;/code&gt; 로그를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="25184bf63945467203d08f0de2a23c0f6dd54c05" translate="yes" xml:space="preserve">
          <source>. Instead, it will localize perl's notion of which filehandle &lt;code&gt;$.&lt;/code&gt; is currently aliased to.</source>
          <target state="translated">. 대신, 어떤 파일 핸들 &lt;code&gt;$.&lt;/code&gt; 대한 펄의 개념을 현지화 합니다. 현재 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="99f7f86480d4ea94cae9f5397fe0142ca2f2d10b" translate="yes" xml:space="preserve">
          <source>. It cannot be cleared or deleted; attempts to do so are silently ignored.</source>
          <target state="translated">. 지우거나 삭제할 수 없습니다. 그렇게하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e411fd2b458d1fe3f7731fd9a0f2621e9bb8a52f" translate="yes" xml:space="preserve">
          <source>. It couldn't possibly affect anything else, so no need to test beyond the single affected</source>
          <target state="translated">. 다른 것에 영향을 줄 수 없으므로 영향을받는 단일 항목 이상으로 테스트 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="da9b899ea96554fef6c0b4c1d1118774a6a7f968" translate="yes" xml:space="preserve">
          <source>. It does suffer from the bug of mishandling newlines in pathnames, which you can fix if you follow the example under &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;.</source>
          <target state="translated">. 경로 이름에서 줄 바꿈을 잘못 처리하는 버그가 있습니다 . &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt; 아래의 예를 따르면 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7f2139db1ad9c91528643fba773777f505b8d50" translate="yes" xml:space="preserve">
          <source>. It has the values &quot;unsigned char&quot; or &lt;code&gt;char&lt;/code&gt; .</source>
          <target state="translated">. &quot;unsigned char&quot;또는 &lt;code&gt;char&lt;/code&gt; 값이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6599a22ad2cd0d14a7e4506327cf7d32758c3e13" translate="yes" xml:space="preserve">
          <source>. It has the values &quot;unsigned char&quot; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">. 값은 &quot;unsigned char&quot;또는 &lt;code&gt;char&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="358df296223d08b4fb71d6b3899c26c08092421e" translate="yes" xml:space="preserve">
          <source>. It helps to ensure your test program ran all the way through and didn't die or skip some tests. &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed.&quot; &lt;code&gt;not ok 2&lt;/code&gt; &quot;The second test failed&quot;. Test::Simple helpfully prints out some extra commentary about your tests.</source>
          <target state="translated">. 테스트 프로그램이 끝까지 실행되고 죽거나 일부 테스트를 건너 뛰지 않았는지 확인하는 데 도움이됩니다. &lt;code&gt;ok 1&lt;/code&gt; &quot;첫 번째 테스트를 통과했습니다.&quot; &lt;code&gt;not ok 2&lt;/code&gt; &quot;두 번째 테스트 실패&quot;. Test :: Simple은 테스트에 대한 추가 설명을 유용하게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9f17a09d380724a3716b787a41ebd4613a73ee6f" translate="yes" xml:space="preserve">
          <source>. It is a plain '' if this is not the &lt;code&gt;GNU&lt;/code&gt; C library, or if the version is unknown.</source>
          <target state="translated">. 이것이 &lt;code&gt;GNU&lt;/code&gt; C 라이브러리 가 아니 거나 버전을 알 수없는 경우 '' 입니다.</target>
        </trans-unit>
        <trans-unit id="d9968fc8b94f6a056c1a481b9936f565e393c904" translate="yes" xml:space="preserve">
          <source>. It is also used instead of explicit</source>
          <target state="translated">. 명시 적 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d96c04f9a51ab5f437bd463e742a0003313be347" translate="yes" xml:space="preserve">
          <source>. It is conventionally invoked using the driver script &lt;b&gt;pod2man&lt;/b&gt;, but it can also be used directly.</source>
          <target state="translated">. 일반적으로 드라이버 스크립트 &lt;b&gt;pod2man을&lt;/b&gt; 사용하여 호출 되지만 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f513dd8d11fda24e9b49a220d530308d617cc39e" translate="yes" xml:space="preserve">
          <source>. It is defined primarily for backwards compatibility.</source>
          <target state="translated">. 기본적으로 이전 버전과의 호환성을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e2436b894ff16e0565f80d082127a7c7776b277b" translate="yes" xml:space="preserve">
          <source>. It is mainly used by other Configure units.</source>
          <target state="translated">. 주로 다른 구성 단위에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="854700a6ac77224f1a5ecd22073ecc6739bef63d" translate="yes" xml:space="preserve">
          <source>. It is not for skipping genuine bugs (we'll get to that in a moment).</source>
          <target state="translated">. 진짜 버그를 건너 뛰기위한 것이 아닙니다 (잠시 후에 알아볼 것입니다).</target>
        </trans-unit>
        <trans-unit id="16adfccff5a0fd918744c61c6f8ff806837a3906" translate="yes" xml:space="preserve">
          <source>. It is passed the following arguments:</source>
          <target state="translated">. 다음 인수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b7a0d6e44f6ace7415a5296fb2dc7c29a44158" translate="yes" xml:space="preserve">
          <source>. It is primarily intended to be called from a message handler when they have been passed an exception they don't want to format.</source>
          <target state="translated">. 형식화하지 않으려는 예외가 전달되었을 때 메시지 처리기에서 주로 호출하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb63e0a589c7c79183e0aee5a650e0d846db99ab" translate="yes" xml:space="preserve">
          <source>. It is unrelated to English</source>
          <target state="translated">. 영어와 관련이 없습니다</target>
        </trans-unit>
        <trans-unit id="74da5ff365578d17c8b9c1fe91da0e3966c4c014" translate="yes" xml:space="preserve">
          <source>. It should not be used for any other general YAML parsing or generation task.</source>
          <target state="translated">. 다른 일반 YAML 구문 분석 또는 생성 작업에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b38290ed6629f0ba79cc60e3f039d22be0b31883" translate="yes" xml:space="preserve">
          <source>. It will always be 0.</source>
          <target state="translated">. 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="c8ebeb64dfaf88dcb282fb968e8e06bb8fcc9b5f" translate="yes" xml:space="preserve">
          <source>. It will use the following search path to find default typemaps, with the rightmost typemap taking precedence.</source>
          <target state="translated">. 다음 검색 경로를 사용하여 가장 오른쪽의 유형 맵이 우선하는 기본 유형 맵을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="47b5a45699abc71afa96d3e0e904645134ffab28" translate="yes" xml:space="preserve">
          <source>. It works similar to the result of the Unix command</source>
          <target state="translated">. 유닉스 명령의 결과와 비슷하게 작동합니다</target>
        </trans-unit>
        <trans-unit id="5a643ab8daccf23ddaa3fb22633cc5ec24e871a4" translate="yes" xml:space="preserve">
          <source>. It'll work similarly for the second argument, but the third will be loaded as a file first.</source>
          <target state="translated">. 두 번째 인수에 대해서도 유사하게 작동하지만 세 번째 인수는 먼저 파일로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf942d7c5a7a7cc8b5f51dca65695a4b4f21342" translate="yes" xml:space="preserve">
          <source>. It's an alternative to &lt;code&gt;make test&lt;/code&gt; .</source>
          <target state="translated">. &lt;code&gt;make test&lt;/code&gt; 대체하는 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="d08b15eaba20ae4ffc714d0b24aa505e603f8dee" translate="yes" xml:space="preserve">
          <source>. It's an alternative to &lt;code&gt;make test&lt;/code&gt;.</source>
          <target state="translated">. &lt;code&gt;make test&lt;/code&gt; 를 만드는 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="f65c423102d4b2bb387d6ce7ac29cea0b802bdc1" translate="yes" xml:space="preserve">
          <source>. Just follow the instructions, and 99% of the installation blues would go away.</source>
          <target state="translated">. 지침을 따르기 만하면 설치 블루스의 99 %가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="f878690035ca0e58b744826cf63a8295cfc9f70e" translate="yes" xml:space="preserve">
          <source>. Later we'll see that this specification can contain more than just the option name. The reference to the variable is called the option</source>
          <target state="translated">. 나중에 우리는이 스펙이 옵션 이름 이상의 것을 포함 할 수 있음을 알게 될 것입니다. 변수에 대한 참조를 옵션이라고합니다</target>
        </trans-unit>
        <trans-unit id="8885267f0ed54b9a7692c1088a926a7ac95563d7" translate="yes" xml:space="preserve">
          <source>. MODE is usually a literal string comprising special characters that define the intended I/O role of the filehandle being created: whether it's read-only, or read-and-write, and so on.</source>
          <target state="translated">. MODE는 일반적으로 생성되는 파일 핸들의 의도 된 I / O 역할 (읽기 전용인지 읽기 및 쓰기 등)을 정의하는 특수 문자로 구성된 리터럴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c4bea9eaa9bee5e3756e1d73231b1234be2ae6f1" translate="yes" xml:space="preserve">
          <source>. Mac OS support by Paul Schinder &amp;lt;schinder@pobox.com&amp;gt; and Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;.</source>
          <target state="translated">. Paul Schinder &amp;lt;schinder@pobox.com&amp;gt; 및 Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;의 Mac OS 지원</target>
        </trans-unit>
        <trans-unit id="fbb2a7d7d50b2bcb78d660bec6afabd731e0db6a" translate="yes" xml:space="preserve">
          <source>. Make sure each of those</source>
          <target state="translated">. 그들 각각을 확인하십시오</target>
        </trans-unit>
        <trans-unit id="d2af23a9a799aeb1d6f76fd39a5251808a1a50e8" translate="yes" xml:space="preserve">
          <source>. More information on how to write good perldelta entries is available in the &lt;code&gt;Style&lt;/code&gt; section of</source>
          <target state="translated">. 좋은 perldelta 항목을 작성하는 방법에 대한 자세한 내용은 &lt;code&gt;Style&lt;/code&gt; 섹션 에서 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5fa79d5fe358db59b924db9e3afc91c8c4c97989" translate="yes" xml:space="preserve">
          <source>. None of the other processing of &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;pad_add_name_pvn in perlapi&lt;/a&gt; is done. Returns the offset of the allocated pad slot.</source>
          <target state="translated">. &lt;a href=&quot;perlapi#pad_add_name_pvn&quot;&gt;perlapi에서 pad_add_name_pvn&lt;/a&gt; 의 다른 처리 는 수행되지 않습니다. 할당 된 패드 슬롯의 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7039f806afb4a2ecb55b3bcaacedf3640a4cd77" translate="yes" xml:space="preserve">
          <source>. Note that all names passed to the user's</source>
          <target state="translated">. 모든 이름은 사용자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9be56d94b765d15db97085ae687fb211fbd1c96d" translate="yes" xml:space="preserve">
          <source>. Note that all names passed to the user's &lt;code&gt;wanted()&lt;/code&gt; function are still tainted. If this option is used while not in taint-mode, &lt;code&gt;untaint&lt;/code&gt; is a no-op.</source>
          <target state="translated">. 사용자의 &lt;code&gt;wanted()&lt;/code&gt; 함수에 전달 된 모든 이름 은 여전히 ​​오염되어 있습니다. 오염 모드가 아닌 상태에서이 옵션을 사용하면 &lt;code&gt;untaint&lt;/code&gt; 는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15bf0a4269dea3ad18ee10b385dbdaef11b74bf4" translate="yes" xml:space="preserve">
          <source>. Note that before these macros were added, Perl internals used to directly use character literals, so you may occasionally come across old code or documentation referring to 'U' magic rather than &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; for example.</source>
          <target state="translated">. 이러한 매크로가 추가되기 전에 Perl 내부는 문자 리터럴을 직접 사용하는 데 사용 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; , 예를 들어 PERL_MAGIC_uvar 가 아닌 'U'매직을 참조하는 오래된 코드 나 문서가 종종 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d06789deb8b5a7ca71d14547a85c1b9baded3394" translate="yes" xml:space="preserve">
          <source>. Note that extension code should</source>
          <target state="translated">. 확장 코드는</target>
        </trans-unit>
        <trans-unit id="12457e722ccfc654c8bad69405188c5af0f50ae7" translate="yes" xml:space="preserve">
          <source>. Now we can add our tests to the end. First, we'll test that the &lt;code&gt;U&lt;/code&gt; does indeed create Unicode strings.</source>
          <target state="translated">. 이제 테스트를 끝에 추가 할 수 있습니다. 먼저 &lt;code&gt;U&lt;/code&gt; 가 실제로 유니 코드 문자열을 생성 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="95d8b82e403a24e94a8215ff5138e9129ce71d0a" translate="yes" xml:space="preserve">
          <source>. Of course, it'll need to be executable first, so &lt;code&gt;chmod 755 script.pl&lt;/code&gt; (under Unix).</source>
          <target state="translated">. 물론, 먼저 실행 가능해야하므로 &lt;code&gt;chmod 755 script.pl&lt;/code&gt; (Unix 아래).</target>
        </trans-unit>
        <trans-unit id="7c64ceea87287666f57ddc1224318c09f3091913" translate="yes" xml:space="preserve">
          <source>. On building, &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; doesn't require any of</source>
          <target state="translated">. 빌드시 &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="537b462bbd527cd649466c0e0e150e64a30e9e53" translate="yes" xml:space="preserve">
          <source>. On operating systems which do not require a specific extension for executable files, this variable is empty.</source>
          <target state="translated">. 실행 파일에 특정 확장자가 필요없는 운영 체제에서이 변수는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55026f126a81b220971a849c6c2cb68bb628095e" translate="yes" xml:space="preserve">
          <source>. Once the enclosing &quot;&amp;lt; ... &amp;gt;&quot; is removed, this is passed (more or less) unchanged to &lt;code&gt;File::Glob&lt;/code&gt; to carry out a file match.</source>
          <target state="translated">. 둘러싸는 &quot;&amp;lt;...&amp;gt;&quot;가 제거되면 파일 일치를 수행하기 위해 &lt;code&gt;File::Glob&lt;/code&gt; 에 변경없이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="96e2b5e9bec44f8daa5c9f8eb8f20596cf31be4b" translate="yes" xml:space="preserve">
          <source>. One more rule is needed to understand how a match is determined for the whole regular expression: a match at an earlier position is always better than a match at a later position.</source>
          <target state="translated">. 전체 정규식에 대해 일치가 결정되는 방식을 이해하려면 규칙이 하나 더 필요합니다. 이전 위치의 일치는 항상 이후 위치의 일치보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="4160bde3f72822338469aa8433b4b5304c3dcc97" translate="yes" xml:space="preserve">
          <source>. One way to do this on some systems is to set the environment variable &lt;code&gt;LD_RUN_PATH&lt;/code&gt; to the directory that will be the final location of the shared</source>
          <target state="translated">. 일부 시스템에서이를 수행하는 한 가지 방법은 환경 변수 &lt;code&gt;LD_RUN_PATH&lt;/code&gt; 를 공유의 최종 위치가 될 디렉토리로 설정하는 것입니다</target>
        </trans-unit>
        <trans-unit id="7be1ea0808dfeddc5a5ce7a2663e5bdfc11b4e99" translate="yes" xml:space="preserve">
          <source>. Otherwise it matches any character but &lt;code&gt;\n&lt;/code&gt; .</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;\n&lt;/code&gt; 이외의 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f01c61f87df64d743068995bf6071556f53df117" translate="yes" xml:space="preserve">
          <source>. Otherwise it matches any character but &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;\n&lt;/code&gt; 제외한 모든 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="4c3e86c0fe5882b9760b15a3c30fea7570aedff9" translate="yes" xml:space="preserve">
          <source>. Otherwise, fall back on this implementation. The main use of this function is catching &lt;code&gt;-0.0&lt;/code&gt;.</source>
          <target state="translated">. 그렇지 않으면이 구현으로 대체하십시오. 이 함수의 주요 용도는 &lt;code&gt;-0.0&lt;/code&gt; 잡는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d6969174e97789c0a8cbd61099ffc2a91dee5f32" translate="yes" xml:space="preserve">
          <source>. Otherwise, if the</source>
          <target state="translated">. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="41e0e8c07d38f87111e8a525a5b3f67ff5e752ad" translate="yes" xml:space="preserve">
          <source>. Otherwise, it returns the value of &lt;code&gt;$@&lt;/code&gt; associated with the thread's execution status in its &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; context.</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 컨텍스트 에서 스레드의 실행 상태와 관련된 &lt;code&gt;$@&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5cc52cd40e11013f1b8d1c76e4bccb76648bab37" translate="yes" xml:space="preserve">
          <source>. Otherwise, it returns the value of &lt;code&gt;$@&lt;/code&gt; associated with the thread's execution status in its &lt;code&gt;eval&lt;/code&gt; context.</source>
          <target state="translated">. 그렇지 않으면 &lt;code&gt;eval&lt;/code&gt; 컨텍스트 에서 스레드의 실행 상태와 관련된 &lt;code&gt;$@&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b1e71ea4d22f53b2eb30fcb146b06118897444ae" translate="yes" xml:space="preserve">
          <source>. Over the years, it has become standard to keep this information in one or more CPAN Meta files distributed with each distribution.</source>
          <target state="translated">. 수년에 걸쳐이 정보를 각 배포와 함께 배포 된 하나 이상의 CPAN 메타 파일에 보관하는 것이 표준이되었습니다.</target>
        </trans-unit>
        <trans-unit id="06cf8affd89236a0eecaaa78bccddd732862b6d8" translate="yes" xml:space="preserve">
          <source>. Page numbers derive from the hardcover edition, first published in 1983 by George Allen &amp;amp; Unwin; no page numbers changed for the special 3-volume omnibus edition of 2002 or the various trade-paper editions, all again now by Harper Collins or Houghton Mifflin.</source>
          <target state="translated">. 페이지 번호는 1983 년 George Allen &amp;amp; Unwin이 처음 출판 한 하드 커버 에디션에서 파생됩니다. Harper Collins 또는 Houghton Mifflin에 의해 2002 년의 특수한 3 권 옴니버스 판이나 다양한 무역 용지 판에 대한 페이지 번호는 바뀌지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d4f4aa3da68de58187b7c018e5336cbc71134a54" translate="yes" xml:space="preserve">
          <source>. People who are interested in how to localize things in the containing scope should take a look there too.</source>
          <target state="translated">. 포함하는 범위에서 사물을 현지화하는 방법에 관심이있는 사람들도 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="c2b14d3f3d78674e56bc67813f86b24d2db0c711" translate="yes" xml:space="preserve">
          <source>. Perhaps what we ought to do is take the hard-wired value from</source>
          <target state="translated">. 아마도 우리가해야 할 일은 고정 된 가치를</target>
        </trans-unit>
        <trans-unit id="1bb197e77339ac738cd4c23655f60abef9ee8faa" translate="yes" xml:space="preserve">
          <source>. Perl does not do this for you. The &lt;code&gt;passwd&lt;/code&gt; is one-way hashed garble, not clear text, and may not be unhashed save by brute-force guessing. Secure systems use more a more secure hashing than DES. On systems supporting shadow password systems, Perl automatically returns the shadow password entry when called by a suitably empowered user, even if your underlying vendor-provided C library was too short-sighted to realize it should do this.</source>
          <target state="translated">. 펄은 당신을 위해 이것을하지 않습니다. &lt;code&gt;passwd&lt;/code&gt; 파일은 편도가 제대로 해석하지 일반 텍스트를 해시하고 추측 무차별로 저장 해시되지되지 않을 수 있습니다. 보안 시스템은 DES보다 더 안전한 해싱을 사용합니다. 섀도 암호 시스템을 지원하는 시스템에서 Perl은 기본 공급 업체 제공 C 라이브러리가 너무 짧아도이를 수행 할 수없는 경우에도 적절한 권한을 가진 사용자가 호출하면 섀도 암호 항목을 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c2d4fd11e3c3c2ef4d3668c3eb6e94ff499b67de" translate="yes" xml:space="preserve">
          <source>. Perl isn't much like other computer languages; it's highly context sensitive at times, it can be tricky to work out what sort of token something is, or where a token ends. As such, there's a lot of interplay between the tokeniser and the parser, which can get pretty frightening if you're not used to it.</source>
          <target state="translated">. 펄은 다른 컴퓨터 언어와 크게 다르지 않다. 때로는 문맥에 매우 민감하기 때문에 어떤 종류의 토큰인지 또는 토큰이 끝나는 곳을 해결하는 것이 까다로울 수 있습니다. 따라서 토큰 화기와 파서 사이에는 많은 상호 작용이 있으므로 익숙하지 않으면 상당히 무섭습니다.</target>
        </trans-unit>
        <trans-unit id="1515508cadc5797cd8ab959f1ca3339e49888887" translate="yes" xml:space="preserve">
          <source>. Please remove this variable and put &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt; instead.</source>
          <target state="translated">. 이 변수를 제거하고 대신 &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot; &lt;code&gt;PERL_SH_DIR&lt;/code&gt; &quot;&lt;/a&gt; 을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="cba1355f82c45a8fef21484f747404a76ae86f23" translate="yes" xml:space="preserve">
          <source>. Please remove this variable and put &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">. 이 변수를 제거하고 대신 &lt;code&gt;&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;&lt;/code&gt; 을 넣으 십시오 .</target>
        </trans-unit>
        <trans-unit id="3f1457da5e48adfeddc76831c3066a31d1b57f2e" translate="yes" xml:space="preserve">
          <source>. Pod processors should warn about this being deprecated syntax.</source>
          <target state="translated">. 포드 프로세서는이 사용되지 않는 구문에 대해 경고해야합니다.</target>
        </trans-unit>
        <trans-unit id="564d3ae644e1bfdb8a791d48b6f916dc882219b0" translate="yes" xml:space="preserve">
          <source>. Prior to Perl 5.26, &lt;code&gt;.&lt;/code&gt; -which represents the current directory, was included in &lt;code&gt;@INC&lt;/code&gt;; it has been removed. This change in behavior is documented in &lt;a href=&quot;perlrun#PERL_USE_UNSAFE_INC&quot;&gt;&lt;code&gt;PERL_USE_UNSAFE_INC&lt;/code&gt;&lt;/a&gt; and it is not recommended that &lt;code&gt;.&lt;/code&gt; be re-added to &lt;code&gt;@INC&lt;/code&gt;. If you need to modify &lt;code&gt;@INC&lt;/code&gt; at runtime, you should use the &lt;code&gt;use lib&lt;/code&gt; pragma to get the machine-dependent library properly loaded as well:</source>
          <target state="translated">. Perl 5.26 이전에는 &lt;code&gt;.&lt;/code&gt; -현재 디렉토리를 나타내며 &lt;code&gt;@INC&lt;/code&gt; 에 포함되었습니다 . 제거되었습니다. 동작의 변경에 설명되어 있습니다 &lt;a href=&quot;perlrun#PERL_USE_UNSAFE_INC&quot;&gt; &lt;code&gt;PERL_USE_UNSAFE_INC&lt;/code&gt; &lt;/a&gt; 그것은하지 않는 것이 좋습니다 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;@INC&lt;/code&gt; 에 다시 추가됩니다 . 런타임에 &lt;code&gt;@INC&lt;/code&gt; 를 수정해야하는 경우 &lt;code&gt;use lib&lt;/code&gt; pragma를 사용 하여 시스템 종속 라이브러리도 올바르게로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="78d896e0ef56e1d24740ae6e5074e45f9bb5ff12" translate="yes" xml:space="preserve">
          <source>. Programs must be prepared to deal with</source>
          <target state="translated">. 처리 할 프로그램을 준비해야합니다</target>
        </trans-unit>
        <trans-unit id="46be1dc32b301883ac9f960a586983088faefae1" translate="yes" xml:space="preserve">
          <source>. Programs using this variable must be prepared to deal with</source>
          <target state="translated">. 이 변수를 사용하는 프로그램은 처리 할 준비가되어 있어야합니다</target>
        </trans-unit>
        <trans-unit id="cd020a4f288e77d95d879b2ff99123114284aae5" translate="yes" xml:space="preserve">
          <source>. Programs using this variable must be prepared to deal with filename expansion.</source>
          <target state="translated">. 파일 이름 확장을 처리하려면이 변수를 사용하는 프로그램을 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="16f0fa2c6457ccd5a1bef736f8b2f051584ca655" translate="yes" xml:space="preserve">
          <source>. Rarely needed.</source>
          <target state="translated">. 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fbe3d58c554ed4c1d1d1b42c9e80cc50c48ac8a" translate="yes" xml:space="preserve">
          <source>. Recall, that if</source>
          <target state="translated">. 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="ab6a7d315e0a4101b03879bac7a3a3c3731c445f" translate="yes" xml:space="preserve">
          <source>. Returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no matching</source>
          <target state="translated">. 일치하지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="086cca4baa9483c73d9d398b13433901fa57fcb1" translate="yes" xml:space="preserve">
          <source>. Returns &lt;code&gt;undef&lt;/code&gt; if no matching</source>
          <target state="translated">. 일치하는 항목이 없으면 &lt;code&gt;undef&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17bd24a798e55f262ddde9c7e4ea74e8f691a79b" translate="yes" xml:space="preserve">
          <source>. Returns the new file position, or -1 if an error occurs.</source>
          <target state="translated">. 새 파일 위치를 반환하거나 오류가 발생하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4717fd7dfaf37fd66e5c1a6c2440f1a17feb75b" translate="yes" xml:space="preserve">
          <source>. Roles are relatively new to Perl, but have become rather popular. Roles are &lt;b&gt;applied&lt;/b&gt; to classes. Sometimes we say that classes &lt;b&gt;consume&lt;/b&gt; roles.</source>
          <target state="translated">. 역할은 Perl에 비교적 새로운 것이지만 다소 인기가 있습니다. 역할은 수업 에 &lt;b&gt;적용&lt;/b&gt; 됩니다. 때때로 우리는 클래스가 &lt;b&gt;소비&lt;/b&gt; 한다고 말합니다&lt;b&gt;&lt;/b&gt; 역할을 .</target>
        </trans-unit>
        <trans-unit id="85adbd9d6de0bb6d69a95e5ac09cd801db6ef4b2" translate="yes" xml:space="preserve">
          <source>. Running the profiled version of Perl will create an output file called</source>
          <target state="translated">. 프로파일 링 된 Perl 버전을 실행하면 다음과 같은 출력 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e550a655605c6f097b311744bc2ad2d1f7e02cd4" translate="yes" xml:space="preserve">
          <source>. Save your work and repeat...</source>
          <target state="translated">. 작업을 저장하고 반복하십시오 ...</target>
        </trans-unit>
        <trans-unit id="7143f409794e5396a72f2a6b101a534fc0b07928" translate="yes" xml:space="preserve">
          <source>. See</source>
          <target state="translated">. 보다</target>
        </trans-unit>
        <trans-unit id="bee7c9ef88ceab887add88fe362e6d8481b88a47" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-%28%40INC%29-at-runtime%3F&quot;&gt;&quot;How do I add a directory to my include path (@INC) at runtime?&quot;&lt;/a&gt; for details on how to run your newly installed modules.</source>
          <target state="translated">. 참조 &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-%28%40INC%29-at-runtime%3F&quot;&gt;&quot;어떻게 런타임에 내 포함 경로 (@INC)에 디렉토리를 추가하는 방법은 무엇입니까?&quot; &lt;/a&gt;새로 설치된 모듈을 실행하는 방법에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="0dc553c5d634355fec3724ccd2a074361b8ba50a" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-(%40INC)-at-runtime%3f&quot;&gt;How do I add a directory to my include path (@INC) at runtime?&lt;/a&gt; for details on how to run your newly installed modules.</source>
          <target state="translated">. &lt;a href=&quot;#How-do-I-add-a-directory-to-my-include-path-(%40INC)-at-runtime%3f&quot;&gt;런타임에 포함 경로 (@INC)에 디렉토리를 추가하는 방법을&lt;/a&gt; 참조하십시오 . 새로 설치된 모듈을 실행하는 방법에 대한 자세한 내용.</target>
        </trans-unit>
        <trans-unit id="ddb90c9c599d24903a474a87fa3a2bc0c13144bb" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;전제 조건&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba073e24f104c94d46d8d40d53b310f205b091a4" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d37a6f9d50749984cd729b9498de5dfbc561c7a6" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#Using-call_sv&quot;&gt;&quot;Using call_sv&quot;&lt;/a&gt; for details.</source>
          <target state="translated">. 자세한 내용은 &lt;a href=&quot;#Using-call_sv&quot;&gt;&quot;call_sv 사용&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="108cb27bf7c8d7031e4a5603b633fe94497e91da" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;#sv_magic&quot;&gt;sv_magic&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#sv_magic&quot;&gt;sv_magic을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1981f0c642c0f907ef847d7c17536d36f0ee8920" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;../../perlref&quot;&gt;perlref&lt;/a&gt; for more details on the mechanics of</source>
          <target state="translated">. 역학에 대한 자세한 내용 은 &lt;a href=&quot;../../perlref&quot;&gt;perlref&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b3ef3b8c9c5702c57fea51845f0a204e6ec73ba" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;Encode::Guess&quot;&gt;Encode::Guess&lt;/a&gt; for details.</source>
          <target state="translated">. 자세한 내용은 &lt;a href=&quot;Encode::Guess&quot;&gt;Encode :: Guess&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10889f2e8189c79b1f86ade1e2c38e0b8038ce1d" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;charnames&quot;&gt;charnames를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7c3fb52af08419ccda7242724b917a43e565a5f" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more details on the mechanics of</source>
          <target state="translated">. 메커니즘에 대한 자세한 내용 은 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="065f520588be974c5594d0397ea3e63f2dce18b1" translate="yes" xml:space="preserve">
          <source>. See AUTHORS for a full list of people involved. For any questions, send mail to</source>
          <target state="translated">. 관련된 사람들의 전체 목록은 저자를 참조하십시오. 질문이 있으시면 메일을 보내주십시오</target>
        </trans-unit>
        <trans-unit id="497d401abf0f6a33f3af121175866d056f439fb1" translate="yes" xml:space="preserve">
          <source>. See also &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::sleep()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#usleep-%28-%24useconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::usleep()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#clock_nanosleep-%28-%24which%2C-%24nanoseconds%2C-%24flags-%3D-0%29&quot;&gt;&lt;code&gt;clock_nanosleep()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. 참조 &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#usleep-%28-%24useconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#clock_nanosleep-%28-%24which%2C-%24nanoseconds%2C-%24flags-%3D-0%29&quot;&gt; &lt;code&gt;clock_nanosleep()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2199e77491bf38a33dfa905f96269e305f46f1c" translate="yes" xml:space="preserve">
          <source>. See also &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::sleep()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#usleep-%28-%24useconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::usleep()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#nanosleep-%28-%24nanoseconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. 참조 &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#usleep-%28-%24useconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#nanosleep-%28-%24nanoseconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1f5ea9b95dca4e87c6eca7c63129285f89aa83" translate="yes" xml:space="preserve">
          <source>. See also &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt;&lt;code&gt;Time::HiRes::sleep()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#clock_nanosleep-%28-%24which%2C-%24nanoseconds%2C-%24flags-%3D-0%29&quot;&gt;&lt;code&gt;clock_nanosleep()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. &lt;a href=&quot;#sleep-%28-%24floating_seconds-%29&quot;&gt; &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#clock_nanosleep-%28-%24which%2C-%24nanoseconds%2C-%24flags-%3D-0%29&quot;&gt; &lt;code&gt;clock_nanosleep()&lt;/code&gt; &lt;/a&gt; 도 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="1da2f25ee6e37cb910fd70d32927a95fc37e978b" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="526666d33c6dd6f0edce27a1b78dfa10ea26ace5" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269fb40594ac38479767dd170994fea4ce252e54" translate="yes" xml:space="preserve">
          <source>. See also &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , and &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</source>
          <target state="translated">. 참조 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; , 및 &lt;code&gt;Time::HiRes::clock_nanosleep()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73ed177a1496b0ffabfd429dcad99a1b5e86269c" translate="yes" xml:space="preserve">
          <source>. See man1dir.</source>
          <target state="translated">. man1dir을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="37f30b22c5af4841496858a795207dcf79c50797" translate="yes" xml:space="preserve">
          <source>. See man3dir.</source>
          <target state="translated">. man3dir을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c34835277b46e71de0c02bf6cf0f02eefcb4f7c6" translate="yes" xml:space="preserve">
          <source>. See the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">. Camel 5 장, &quot;패턴 일치&quot; 의 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b98009a504041b2a2e135284e783dfdbc1e8357f" translate="yes" xml:space="preserve">
          <source>. See the &lt;code&gt;tr///&lt;/code&gt; operator in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">. Camel 5 장, &quot;패턴 일치&quot; 의 &lt;code&gt;tr///&lt;/code&gt; 연산자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="532cefe5f4e0e07491434bf06b22de1364858a22" translate="yes" xml:space="preserve">
          <source>. Sigh!</source>
          <target state="translated">. 한숨!</target>
        </trans-unit>
        <trans-unit id="15721d069cd060fbc46f89e07bfe13ca468f8232" translate="yes" xml:space="preserve">
          <source>. Similarly, \x</source>
          <target state="translated">. 마찬가지로 \ x</target>
        </trans-unit>
        <trans-unit id="de4d0dbea4489047ca7b513d634afc159e7969dd" translate="yes" xml:space="preserve">
          <source>. Similarly, don't create patches for files under</source>
          <target state="translated">. 마찬가지로 파일에 대한 패치를 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="395988d77edcf52f02450c8878fe072fd4bc2688" translate="yes" xml:space="preserve">
          <source>. Since that character itself folds to &lt;code&gt;&quot;s&quot;&lt;/code&gt;, the string of two of them together should be equivalent to a single U+1E9E when foldcased.</source>
          <target state="translated">. 그 문자 자체가 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 로 접 히기 때문에 두 개의 문자열이 함께 접힌 경우 단일 U + 1E9E와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5eed1b7cba0329ac7a82750cca661eb2b07773c" translate="yes" xml:space="preserve">
          <source>. Since the core of Perl has now been tested, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; can and now should be used. You can also use the full suite of core modules in the tests. (As noted in &lt;a href=&quot;#Patching-a-core-module&quot;&gt;&quot;Patching a core module&quot;&lt;/a&gt; above, changes to</source>
          <target state="translated">. Perl의 핵심이 이제 테스트되었으므로 &lt;a href=&quot;Test::More&quot;&gt;Test :: More를&lt;/a&gt; 사용할 수 있으며 이제 사용해야합니다. 테스트에서 전체 핵심 모듈 제품군을 사용할 수도 있습니다. ( 위의 &lt;a href=&quot;#Patching-a-core-module&quot;&gt;&quot;코어 모듈 패치&quot;&lt;/a&gt; 에서 언급했듯이</target>
        </trans-unit>
        <trans-unit id="e7f91a5e70762d437d2b010c7f3894adf3f22e05" translate="yes" xml:space="preserve">
          <source>. Since we're going to be altering this file, let's copy it to</source>
          <target state="translated">. 이 파일을 변경할 것이므로 복사 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="453c217251c123d48625d5057df411e46d897211" translate="yes" xml:space="preserve">
          <source>. So as opposite of &lt;code&gt;find_encoding()&lt;/code&gt; canonical names and aliases are not used when searching for object.</source>
          <target state="translated">. 따라서 &lt;code&gt;find_encoding()&lt;/code&gt; 과 반대로 객체를 검색 할 때 정규 이름과 별칭이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4b19e5f2af8ac1ad558abf4f3e809cbb78dad50" translate="yes" xml:space="preserve">
          <source>. Some non-western languages require more complicated models, so Unicode created the</source>
          <target state="translated">. 서구 이외의 일부 언어에는 더 복잡한 모델이 필요하므로 유니 코드는</target>
        </trans-unit>
        <trans-unit id="924583291a21ac53f389c53cb7d36575da128db8" translate="yes" xml:space="preserve">
          <source>. Sometimes confused with &lt;code&gt;PATH&lt;/code&gt; .</source>
          <target state="translated">. 때때로 &lt;code&gt;PATH&lt;/code&gt; 와 혼동 .</target>
        </trans-unit>
        <trans-unit id="a3a8e9ed6a6374ab9e74cec517357439a65db7f6" translate="yes" xml:space="preserve">
          <source>. Sometimes confused with &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">. 때때로 &lt;code&gt;PATH&lt;/code&gt; 와 혼동됩니다 .</target>
        </trans-unit>
        <trans-unit id="f60154f92db701fa8dfa7c281d9f6dd872168811" translate="yes" xml:space="preserve">
          <source>. Source filters alter the program text of a module before Perl sees it, much as a C preprocessor alters the source text of a C program before the compiler sees it. This article tells you more about what source filters are, how they work, and how to write your own.</source>
          <target state="translated">. C 프리 프로세서가 C 프로그램의 소스 텍스트를 컴파일러가보기 전에 변경하는 것처럼 소스 필터는 Perl이보기 전에 모듈의 프로그램 텍스트를 변경합니다. 이 기사에서는 소스 필터의 정의, 작동 방식 및 직접 작성하는 방법에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4fb0cc3ffb7c7827094da5af5e02907a64d30d4e" translate="yes" xml:space="preserve">
          <source>. Specifically, it is a listing of functions, macros, flags, and variables that may be used by extension writers. Some specialized items are instead documented in</source>
          <target state="translated">. 특히 확장 작성자가 사용할 수있는 함수, 매크로, 플래그 및 변수의 목록입니다. 일부 특수 항목은 대신 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="c5324fa1cfeb6989f1cc904db6d96f2b5cf34a5f" translate="yes" xml:space="preserve">
          <source>. Specifically, the function is applied to an &lt;code&gt;entersub&lt;/code&gt; op tree for a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time as</source>
          <target state="translated">. 특히,이 함수는 &lt;code&gt;&amp;amp;&lt;/code&gt; 로 표시되지 않은 서브 루틴 호출 을위한 &lt;code&gt;entersub&lt;/code&gt; op 트리에 적용되며 , 여기서 호출 수신자는 다음과 같이 컴파일 시간에 식별 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719bbeb528773685892fbb466263ed7992f1ef35" translate="yes" xml:space="preserve">
          <source>. Stratus &lt;code&gt;VOS&lt;/code&gt; uses</source>
          <target state="translated">. Stratus &lt;code&gt;VOS&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="74794f3a0f64eaaac38d6eec10e61e0bb7ca4ab9" translate="yes" xml:space="preserve">
          <source>. Subpatterns are numbered based on the left to right order of their opening parenthesis. A backreference matches whatever actually matched the subpattern in the string being examined, not the rules for that subpattern. Therefore, &lt;code&gt;(0|0x)\d*\s\g1\d*&lt;/code&gt; will match &quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;, because subpattern 1 matched &quot;0x&quot;, even though the rule &lt;code&gt;0|0x&lt;/code&gt; could potentially match the leading 0 in the second number.</source>
          <target state="translated">. 하위 패턴은 여는 괄호의 왼쪽에서 오른쪽 순서에 따라 번호가 매겨집니다. 역 참조는 검사중인 문자열에서 하위 패턴과 실제로 일치하는 항목과 일치하며 해당 하위 패턴의 규칙은 아닙니다. 따라서, &lt;code&gt;(0|0x)\d*\s\g1\d*&lt;/code&gt; 1 서브 패턴은 &quot;0X&quot;를 일치하기 때문에 심지어 규칙 불구하고,하지 &quot;0x1234 01234&quot;를 &quot;0x1234 0x4321&quot;와 일치하지만 것 &lt;code&gt;0|0x&lt;/code&gt; 잠재적으로 일치 할 수있는 두 번째 숫자에서 선행 0입니다.</target>
        </trans-unit>
        <trans-unit id="0bd33c43194e6d65ba167a5061ae6b129a64b1cb" translate="yes" xml:space="preserve">
          <source>. Such discretionary locks are more flexible, but offer fewer guarantees. This means that files locked with flock() may be modified by programs that do not also use flock(). Cars that stop for red lights get on well with each other, but not with cars that don't stop for red lights. See the perlport manpage, your port's specific documentation, or your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (If you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">. 이러한 임의 잠금은 더 융통성이 있지만 보장은 적습니다. 즉, flock ()을 사용하지 않는 프로그램은 flock ()으로 잠겨있는 파일을 수정할 수 있습니다. 빨간불로 멈춘 차들은 서로 잘 어울리지 만 빨간불로 멈추지 않는 차들에는 맞지 않습니다. 자세한 내용은 perlport 맨 페이지, 포트 별 설명서 또는 시스템 별 로컬 맨 페이지를 참조하십시오. 이식 가능한 프로그램을 작성하는 경우 기존의 행동을 가정하는 것이 가장 좋습니다. (그렇지 않은 경우, 항상 자신의 시스템 특질 ( &quot;기능&quot;이라고도 함)에 대해 자유롭게 작성해야합니다. 이식성 문제에 대한 성실한 준수가 업무 수행에 방해가되지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="f924273cb0bf29ba0e14969a837f9a2c41715a31" translate="yes" xml:space="preserve">
          <source>. Take &lt;code&gt;OP_ADD&lt;/code&gt;, for example. (&lt;code&gt;OP_ADD&lt;/code&gt; is the token value from the &lt;code&gt;Aop(OP_ADD)&lt;/code&gt; in</source>
          <target state="translated">. 예를 들어 &lt;code&gt;OP_ADD&lt;/code&gt; 를 사용 하십시오 . ( &lt;code&gt;OP_ADD&lt;/code&gt; 는 &lt;code&gt;Aop(OP_ADD)&lt;/code&gt; 의 토큰 값 입니다.</target>
        </trans-unit>
        <trans-unit id="0219e78f15e9d632ec155375033bbb1f75756ae3" translate="yes" xml:space="preserve">
          <source>. Test::More will output special ok's which Test::Harness interprets as skipped, but passing, tests.</source>
          <target state="translated">. Test :: More는 특별한 ok를 출력합니다. Test :: Harness는 건너 뛰지 만 통과하는 테스트로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="86f914cd47c1c841e763a16c7dd3ea89826fb50f" translate="yes" xml:space="preserve">
          <source>. Tests for &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; are named</source>
          <target state="translated">. &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; 대한 테스트의 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="509fc989a8df02d181de3abd4b07ad24cc68349f" translate="yes" xml:space="preserve">
          <source>. Text following</source>
          <target state="translated">. 다음 텍스트</target>
        </trans-unit>
        <trans-unit id="52010a80ed4df47e71982f8570116561787baa7d" translate="yes" xml:space="preserve">
          <source>. That allows them to read/write files/buffers larger than 4Gig.</source>
          <target state="translated">. 이를 통해 4Gig보다 큰 파일 / 버퍼를 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="854b9e1fe58c6212ac93ec8182edd1d8e94236c0" translate="yes" xml:space="preserve">
          <source>. That filehandle provides an internal reference to the specified external file, conveniently stored in a Perl variable, and ready for I/O operations such as reading and writing.</source>
          <target state="translated">. 이 파일 핸들은 지정된 외부 파일에 대한 내부 참조를 제공하고 Perl 변수에 편리하게 저장되며 읽기 및 쓰기와 같은 I / O 작업에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96afc36fdc9cac6d245d493ea1697bcf23f65cf9" translate="yes" xml:space="preserve">
          <source>. That is, every (possibly wide) character gets replaced with a sequence of one or more characters that represent the individual</source>
          <target state="translated">. 즉, 모든 (아마도 넓은) 문자는 개인을 나타내는 하나 이상의 문자 시퀀스로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ee68fda4cc70d1e9047807e735452ddfef368e" translate="yes" xml:space="preserve">
          <source>. That means that if $fred is a lexical variable created with my() in the above example, the code wouldn't work at all: you'd accidentally access the global and skip right over the private lexical altogether. Global variables are bad because they can easily collide accidentally and in general make for non-scalable and confusing code.</source>
          <target state="translated">. 즉, $ fred가 위 예제에서 my ()로 만든 어휘 변수 인 경우 코드가 전혀 작동하지 않습니다. 실수로 전역에 액세스하고 개인 어휘를 건너 뛸 수 있습니다. 전역 변수는 실수로 쉽게 충돌 할 수 있고 일반적으로 확장 불가능하고 혼란스러운 코드를 만들 수 있기 때문에 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71cc74e6abc0852795fc00a102b3c6afa72a3049" translate="yes" xml:space="preserve">
          <source>. That way, the longer-lived variable will contain the expected reference until it goes out of scope.</source>
          <target state="translated">. 이렇게하면 수명이 긴 변수에 범위를 벗어날 때까지 예상 참조가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="338bcb0d0b4f6443c09736e45408c62579701cfd" translate="yes" xml:space="preserve">
          <source>. The</source>
          <target state="translated">. 그만큼</target>
        </trans-unit>
        <trans-unit id="c4b9c60bf381d578490da1380967c8f8ee21e9a9" translate="yes" xml:space="preserve">
          <source>. The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma can be used to establish default I/O layers.</source>
          <target state="translated">. &lt;a href=&quot;open&quot;&gt;열린&lt;/a&gt; 프라 그마는 기본 I / O 레이어를 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe300fb39c3e404963696de90c5f2b8fb1f4b10d" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma can be used to establish default I/O layers. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마는 기본 I / O 레이어를 설정하는 데 사용할 수 있습니다. &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43b7a7d48b732a7b49c73edd40605094cd605257" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operator assumes this so you don't have to spell out &quot;</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 당신이 &quot;밖으로 철자 할 필요가 없습니다 연산자는이 가정</target>
        </trans-unit>
        <trans-unit id="1d02d641b2daae8c8291ce30497232a482994b97" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma can be used to establish default I/O layers. See &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">. &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 프라 그마는 기본 I / O 레이어를 설정하는 데 사용할 수 있습니다. &lt;a href=&quot;../open&quot;&gt;open을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa935f862d5e3a704a56002cb0fb957dc8218ea" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;use VMS::Filespec&lt;/code&gt; or &lt;code&gt;require VMS::Filespec; import VMS::Filespec ...&lt;/code&gt; statement can be used to import the function names into the current package, but they're always available if you use the fully qualified name, whether or not you've mentioned the</source>
          <target state="translated">. &lt;code&gt;use VMS::Filespec&lt;/code&gt; 또는 &lt;code&gt;require VMS::Filespec; import VMS::Filespec ...&lt;/code&gt; 문을 사용하여 함수 이름을 현재 패키지로 가져올 수 있지만</target>
        </trans-unit>
        <trans-unit id="e7333d35d6cbd99cf7eda3fee658e2f85ce05fd6" translate="yes" xml:space="preserve">
          <source>. The &lt;code&gt;use&lt;/code&gt; operator assumes this so you don't have to spell out &quot;</source>
          <target state="translated">. &lt;code&gt;use&lt;/code&gt; 당신이 &quot;밖으로 철자 할 필요가 없습니다 연산자는이 가정</target>
        </trans-unit>
        <trans-unit id="d34046a75c4b4b70cb801b77ce3dd9d1f648ec86" translate="yes" xml:space="preserve">
          <source>. The C subroutine it calls defaults to the name of the perl visible subroutine, unless you give the parameter</source>
          <target state="translated">. 매개 변수를 제공하지 않는 한, 호출하는 C 서브 루틴은 기본적으로 perl visible 서브 루틴의 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9397ab7f8e9744e2e3279022e0ab86d9f126e59f" translate="yes" xml:space="preserve">
          <source>. The amount of data in the read cache will not exceed the value you specified for &lt;code&gt;memory&lt;/code&gt; . If &lt;code&gt;Tie::File&lt;/code&gt; wants to cache a new record, but the read cache is full, it will make room by expiring the least-recently visited records from the read cache.</source>
          <target state="translated">. 읽기 캐시의 데이터 양은 &lt;code&gt;memory&lt;/code&gt; 지정한 값을 초과하지 않습니다 . 경우 &lt;code&gt;Tie::File&lt;/code&gt; 새 레코드를 캐시 싶어하지만 읽기 캐시가 가득, 그것은 읽기 캐시에서 가장 최근에 방문한 기록을 만료하여 공간을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a27d692b3f924d2952de2843ea0614c4cb0575d" translate="yes" xml:space="preserve">
          <source>. The amount of data in the read cache will not exceed the value you specified for &lt;code&gt;memory&lt;/code&gt;. If &lt;code&gt;Tie::File&lt;/code&gt; wants to cache a new record, but the read cache is full, it will make room by expiring the least-recently visited records from the read cache.</source>
          <target state="translated">. 읽기 캐시의 데이터 양은 &lt;code&gt;memory&lt;/code&gt; 대해 지정한 값을 초과하지 않습니다 . 경우 &lt;code&gt;Tie::File&lt;/code&gt; 새 레코드를 캐시 싶어하지만 읽기 캐시가 가득, 그것은 읽기 캐시에서 가장 최근에 방문한 기록을 만료하여 공간을 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d43793da5a2959399e8063bdc35f4855ea88c66" translate="yes" xml:space="preserve">
          <source>. The argument is first interpreted as a floating point number, but then any fractional parts are truncated (towards zero), and the value is interpreted as an unsigned integer. The bits of this integer are stored in the unused bits of the NaN.</source>
          <target state="translated">. 인수는 먼저 부동 소수점 숫자로 해석되지만 소수 부분은 잘리고 (0쪽으로) 값은 부호없는 정수로 해석됩니다. 이 정수의 비트는 NaN의 사용되지 않은 비트에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="79601f5e82d6d993fd5c764e5bd99eacf802094f" translate="yes" xml:space="preserve">
          <source>. The arrow operator (&lt;code&gt;-&amp;gt;&lt;/code&gt; ) tells Perl that we are calling a method.</source>
          <target state="translated">. 화살표 연산자 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )는 Perl에게 메소드를 호출하고 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a39367a57b80e84f578109fdb0261380b41cb664" translate="yes" xml:space="preserve">
          <source>. The arrow operator (&lt;code&gt;-&amp;gt;&lt;/code&gt;) tells Perl that we are calling a method.</source>
          <target state="translated">. 화살표 연산자 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )는 Perl에게 우리가 메소드를 호출하고 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4ce742f8603278d1cc939bb3c2667ef58a5b743a" translate="yes" xml:space="preserve">
          <source>. The base64 encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used, enabling 6 bits to be represented per printable character.</source>
          <target state="translated">. base64 인코딩은 사람이 읽을 수없는 형태로 임의의 8 진수 시퀀스를 나타내도록 설계되었습니다. US-ASCII의 65 자 서브셋 ([A-Za-z0-9 + / =])이 사용되어 인쇄 가능한 문자 당 6 비트를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="132df5e01ce9879e06e9a0bb9623693b913390a1" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;lex_stuff_sv&lt;/a&gt; function is more convenient.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열을 Perl 스칼라로 사용할 수 &lt;a href=&quot;#lex_stuff_sv&quot;&gt;있으면 lex_stuff_sv&lt;/a&gt; 함수가 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="d893afc509f6379c799028f22bba6115198b3dd0" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열이 아직 Perl 스칼라가 아닌 경우 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; 함수는 스칼라를 구성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee8a3d9771584b9a4ccf95284b3a8174d3f9cca7" translate="yes" xml:space="preserve">
          <source>. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;lex_stuff_pvn&lt;/a&gt; function is more appropriate.</source>
          <target state="translated">. 버퍼가 현재 해석되는 방식에 따라 문자는 lexer 버퍼에 대해 &lt;a href=&quot;#lex_bufutf8&quot;&gt;코딩&lt;/a&gt; 됩니다 ( lex_bufutf8 ). 삽입 할 문자열을 &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;널&lt;/a&gt; 종료하는 것이 편리하지 않은 경우 lex_stuff_pvn 함수가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="0f56b744f4a2c77713600bfeb619e33a869c1cbc" translate="yes" xml:space="preserve">
          <source>. The commit is then actually performed when you run the next command, which will bring up your editor to describe the commit. Without &lt;code&gt;--no-commit&lt;/code&gt;, the commit would be made with nearly no useful message, which would greatly diminish the value of the merge commit as a placeholder for the work's description.</source>
          <target state="translated">. 그런 다음 커밋을 설명하는 편집기를 표시하는 다음 명령을 실행할 때 실제로 커밋이 수행됩니다. 없이 &lt;code&gt;--no-commit&lt;/code&gt; (가) 크게 작업의 설명을위한 자리로 커밋 병합의 가치를 감소 것이 거의없는 유용한 메시지와 함께 할 것입니다 커밋.</target>
        </trans-unit>
        <trans-unit id="c3b33e6ed1f1b6445bb5098593388c53d72702a9" translate="yes" xml:space="preserve">
          <source>. The declaration &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;use strict 'refs'&lt;/code&gt;&lt;/a&gt; disables this feature, which can cause all sorts of trouble if you use it by accident.</source>
          <target state="translated">. &lt;a href=&quot;strict&quot;&gt; &lt;code&gt;use strict 'refs'&lt;/code&gt; &lt;/a&gt; 사용 선언 은이 기능을 비활성화하므로 실수로 사용하면 모든 종류의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09b2a2d176e198b26fa708993e686fdffc215703" translate="yes" xml:space="preserve">
          <source>. The declaration &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; disables this feature, which can cause all sorts of trouble if you use it by accident.</source>
          <target state="translated">. 선언의 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; 실수로 그것을 사용하는 경우 문제의 모든 종류를 일으킬 수있는이 기능을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1f924a7620bcb58b87a1f9d9dd3fdfe4c62ff669" translate="yes" xml:space="preserve">
          <source>. The default is &quot;User Contributed Perl Documentation&quot;, but also see &lt;b&gt;--official&lt;/b&gt; below.</source>
          <target state="translated">. 기본값은 &quot;User Contributed Perl Documentation&quot;이지만 아래의 &lt;b&gt;--official&lt;/b&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="618c078508491fbfb47de5b8a07926b3458d7d8d" translate="yes" xml:space="preserve">
          <source>. The default library locations (e.g. privlib, sitelib) are either</source>
          <target state="translated">. 기본 라이브러리 위치 (예 : privlib, sitelib)는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="6f8ebc54d0178bb00994a39db8b9644acf1a8563" translate="yes" xml:space="preserve">
          <source>. The delimiters for it must be ASCII punctuation, but it may NOT be delimited by &lt;code&gt;&quot;{&quot;&lt;/code&gt;, nor &lt;code&gt;&quot;}&quot;&lt;/code&gt; nor contain a literal &lt;code&gt;&quot;}&quot;&lt;/code&gt;, as that delimits the end of the enclosing &lt;code&gt;\p{}&lt;/code&gt;. Like any pattern, certain other delimiters are terminated by their mirror images. These are &lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;[&lt;/code&gt;&quot;, and &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;. If the delimiter is any of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, &lt;code&gt;&quot;_&quot;&lt;/code&gt;, &lt;code&gt;&quot;+&quot;&lt;/code&gt;, or &lt;code&gt;&quot;\&quot;&lt;/code&gt;, or is the same delimiter as is used for the enclosing pattern, it must be preceded by a backslash escape, both fore and aft.</source>
          <target state="translated">. 구분 기호는 ASCII 구두점이어야하지만 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;}&quot;&lt;/code&gt; 로 구분 하거나 리터럴 &lt;code&gt;&quot;}&quot;&lt;/code&gt; 을 포함 할 수 없습니다. 이는 둘러싸는 &lt;code&gt;\p{}&lt;/code&gt; 의 끝을 구분하기 때문 입니다. 다른 패턴과 마찬가지로 다른 특정 구분 기호는 미러 이미지로 끝납니다. 이들은 &lt;code&gt;&quot;(&quot;&lt;/code&gt; , &lt;code&gt;&quot;[&lt;/code&gt; &quot;및 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 입니다. 구분 기호가 &lt;code&gt;&quot;-&quot;&lt;/code&gt; , &lt;code&gt;&quot;_&quot;&lt;/code&gt; , &lt;code&gt;&quot;+&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 중 하나이거나 둘러싸는 패턴에 사용 된 것과 동일한 구분 기호 인 경우) , 앞쪽과 뒤쪽 모두 백 슬래시 이스케이프가 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="ef73490f33664f8457822810666a2533a19bed96" translate="yes" xml:space="preserve">
          <source>. The directory</source>
          <target state="translated">. 디렉토리</target>
        </trans-unit>
        <trans-unit id="632ab13141757f9e687de51db78b780c50b12aa3" translate="yes" xml:space="preserve">
          <source>. The directory tree is left untouched.</source>
          <target state="translated">. 디렉토리 트리는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a378991e2ff9bbc4e73fa61ee57c00bdd052b15d" translate="yes" xml:space="preserve">
          <source>. The equivalent test can be made in C by using the &lt;code&gt;GIMME_V&lt;/code&gt; macro, which returns &lt;code&gt;G_ARRAY&lt;/code&gt; if you have been called in a list context, &lt;code&gt;G_SCALAR&lt;/code&gt; if in a scalar context, or &lt;code&gt;G_VOID&lt;/code&gt; if in a void context (i.e., the return value will not be used). An older version of this macro is called &lt;code&gt;GIMME&lt;/code&gt; ; in a void context it returns &lt;code&gt;G_SCALAR&lt;/code&gt; instead of &lt;code&gt;G_VOID&lt;/code&gt; . An example of using the &lt;code&gt;GIMME_V&lt;/code&gt; macro is shown in section</source>
          <target state="translated">. 목록 컨텍스트에서 &lt;code&gt;G_SCALAR&lt;/code&gt; 경우 G_ARRAY , 스칼라 컨텍스트 인 경우 &lt;code&gt;G_VOID&lt;/code&gt; 또는 void 컨텍스트 인 경우 &lt;code&gt;G_ARRAY&lt;/code&gt; 를 리턴 하는 &lt;code&gt;GIMME_V&lt;/code&gt; 매크로 를 사용하여 C에서 동등한 테스트를 수행 할 수 있습니다 (예 : 리턴 값이 익숙한). 이 매크로의 이전 버전을 &lt;code&gt;GIMME&lt;/code&gt; 라고 합니다 . 무효 맥락에서 반환 &lt;code&gt;G_SCALAR&lt;/code&gt; 대신 &lt;code&gt;G_VOID&lt;/code&gt; 을 . &lt;code&gt;GIMME_V&lt;/code&gt; 매크로 를 사용하는 예는 섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="44dedd4141cadca433f53717b2d9c75ad72d9b95" translate="yes" xml:space="preserve">
          <source>. The equivalent test can be made in C by using the &lt;code&gt;GIMME_V&lt;/code&gt; macro, which returns &lt;code&gt;G_ARRAY&lt;/code&gt; if you have been called in a list context, &lt;code&gt;G_SCALAR&lt;/code&gt; if in a scalar context, or &lt;code&gt;G_VOID&lt;/code&gt; if in a void context (i.e., the return value will not be used). An older version of this macro is called &lt;code&gt;GIMME&lt;/code&gt;; in a void context it returns &lt;code&gt;G_SCALAR&lt;/code&gt; instead of &lt;code&gt;G_VOID&lt;/code&gt;. An example of using the &lt;code&gt;GIMME_V&lt;/code&gt; macro is shown in section &lt;a href=&quot;#Using-GIMME_V&quot;&gt;&quot;Using GIMME_V&quot;&lt;/a&gt;.</source>
          <target state="translated">. 동등한 시험은 사용하여 C에서 할 수 &lt;code&gt;GIMME_V&lt;/code&gt; 의 반환 매크로, &lt;code&gt;G_ARRAY&lt;/code&gt; 을 당신은리스트 문맥에서 호출 된 경우를 &lt;code&gt;G_SCALAR&lt;/code&gt; 은 스칼라 문맥에서, 또는 경우 &lt;code&gt;G_VOID&lt;/code&gt; 무효 맥락에서 (즉, 반환 값은하지 않을 경우 익숙한). 이 매크로의 이전 버전을 &lt;code&gt;GIMME&lt;/code&gt; 라고 합니다 . 무효 맥락에서 반환 &lt;code&gt;G_SCALAR&lt;/code&gt; 대신 &lt;code&gt;G_VOID&lt;/code&gt; 을 . &lt;code&gt;GIMME_V&lt;/code&gt; 매크로 사용의 예는 &lt;a href=&quot;#Using-GIMME_V&quot;&gt;'GIMME_V 사용'&lt;/a&gt; 섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd333b30838b1fdef268a889fd4cb7c1f09da13" translate="yes" xml:space="preserve">
          <source>. The expression \c</source>
          <target state="translated">. 표현 \ c</target>
        </trans-unit>
        <trans-unit id="ef482f58ec037bafd28af56e419d7d82b45dc684" translate="yes" xml:space="preserve">
          <source>. The facility must be enabled first by a pragmatic declaration, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; , and it will produce a warning unless the &quot;experimental::signatures&quot; warnings category is disabled.</source>
          <target state="translated">. 이 기능은 실용적 선언으로 기능을 먼저 활성화하고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'signatures'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하며 &quot;experimental :: signatures&quot;경고 범주를 비활성화하지 않으면 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="37793220d42e0a63c90efd075b3729c3e11d12c9" translate="yes" xml:space="preserve">
          <source>. The facility must be enabled first by a pragmatic declaration, &lt;code&gt;use feature 'signatures'&lt;/code&gt;, and it will produce a warning unless the &quot;experimental::signatures&quot; warnings category is disabled.</source>
          <target state="translated">. 기능은 먼저 실용적인 선언에 의해 활성화되어야하며 &lt;code&gt;use feature 'signatures'&lt;/code&gt; 하며 &quot;experimental :: signatures&quot;경고 범주가 비활성화되지 않는 한 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ca1e47d5d2c200730329f1acb04a80468d3420bc" translate="yes" xml:space="preserve">
          <source>. The failures are caused by bugs in the CRT in VC++ 2013 which are fixed in VC++2015 and later, as explained by Microsoft here: &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&lt;/a&gt;. In the meantime, if you need fixed &lt;code&gt;stat&lt;/code&gt; and &lt;code&gt;utime&lt;/code&gt; functions then have a look at the CPAN distribution Win32::UTCFileTime.</source>
          <target state="translated">. 오류는 VC ++ 2013의 CRT 버그로 인해 발생합니다.이 버그는 VC ++ 2015 이상에서 수정되었습니다. Microsoft에서 설명 : &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes -visual-c-2013에서 올바른 파일 시간을 설정하지 못함&lt;/a&gt; . 그 동안 고정 된 &lt;code&gt;stat&lt;/code&gt; 및 &lt;code&gt;utime&lt;/code&gt; 함수 가 필요한 경우 CPAN 배포 Win32 :: UTCFileTime을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="993996ea1755cbddf6e3835d13a493c47b042aa6" translate="yes" xml:space="preserve">
          <source>. The failures are caused by bugs in the CRT in VC++ 2013 which will be fixed in future releases of VC++, as explained by Microsoft here: &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&lt;/a&gt;. In the meantime, if you need fixed &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt; functions then have a look at the CPAN distribution Win32::UTCFileTime.</source>
          <target state="translated">. 이 오류는 Microsoft에서 설명하는 &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-fails-to-set-the-correct-file-times-in-visual-c-2013&quot;&gt;https://connect.microsoft.com/VisualStudio/feedback/details/811534/utime-sometimes-&lt;/a&gt; VC ++ 2013의 CRT 버그로 인해 향후 VC ++ 릴리스에서 수정 될 예정입니다. -실시간 c-2013에서 올바른 파일 시간을 설정하지 못했습니다 . 그 동안 고정 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;&lt;/code&gt; 기능 이 필요한 경우 CPAN 분포 Win32 :: UTCFileTime을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="693dcad2e62533bf6a6c62ea9e5ed47e0a1b569a" translate="yes" xml:space="preserve">
          <source>. The following table shows them, along with their ASCII code points (in decimal and hex), their ASCII name, the control escape on ASCII platforms and a short description. (For EBCDIC platforms, see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt;.)</source>
          <target state="translated">. 다음 표는 ASCII 코드 포인트 (10 진수 및 16 진수), ASCII 이름, ASCII 플랫폼의 제어 이스케이프 및 간단한 설명과 함께 이들을 보여줍니다. (EBCDIC 플랫폼의 경우 &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic의 &quot;OPERATOR DIFFERENCES&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="209db736727fc0813e037a50d64ce2c4cb62c7c1" translate="yes" xml:space="preserve">
          <source>. The following table shows them, along with their ASCII code points (in decimal and hex), their ASCII name, the control escape on ASCII platforms and a short description. (For EBCDIC platforms, see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt;.)</source>
          <target state="translated">. 다음 표는 ASCII 코드 포인트 (10 진수 및 16 진수), ASCII 이름, ASCII 플랫폼의 제어 이스케이프 및 간단한 설명과 함께 이들을 보여줍니다. EBCDIC 플랫폼의 경우 &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic의 운영자 차이점을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb9b603496778c52c1a2d77f91cb20b3c0e09316" translate="yes" xml:space="preserve">
          <source>. The format of</source>
          <target state="translated">. 형식</target>
        </trans-unit>
        <trans-unit id="98bd86fe1138202f1f9439203697d2e6ccc0c1d1" translate="yes" xml:space="preserve">
          <source>. The former is useful if $prefix is a directory dedicated to perl (e.g.</source>
          <target state="translated">. 전자는 $ prefix가 perl 전용 디렉토리 인 경우에 유용합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="52456eda920c313c016ecbba8397c6a142320751" translate="yes" xml:space="preserve">
          <source>. The function is intended to be called in this manner:</source>
          <target state="translated">. 이 기능은 다음과 같은 방식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a592425b2e38798803c52cbd4beb0cd4ab9e044b" translate="yes" xml:space="preserve">
          <source>. The function should be defined like this:</source>
          <target state="translated">. 함수는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b277cb2a54f819af8bf29778d7360ede4ccd6c6" translate="yes" xml:space="preserve">
          <source>. The initializer value for a scalar element is just a scalar value. The initializer for an array element is an array reference. The initializer for a hash is a hash reference.</source>
          <target state="translated">. 스칼라 요소의 이니셜 라이저 값은 단지 스칼라 값입니다. 배열 요소의 이니셜 라이저는 배열 참조입니다. 해시의 이니셜 라이저는 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="afbe09239c4b0b80310b301635f392f6bbc5a351" translate="yes" xml:space="preserve">
          <source>. The input is the list of files that match the fileglob.</source>
          <target state="translated">. 입력은 fileglob와 일치하는 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="352aab7b2d0eaa0bc5aa9fc494beb1975384b34a" translate="yes" xml:space="preserve">
          <source>. The key field in the database is the location string and the value field is the time the location was last visited stored as a 4 byte binary value.</source>
          <target state="translated">. 데이터베이스의 키 필드는 위치 문자열이고 값 필드는 위치를 마지막으로 방문한 시간으로 4 바이트 이진 값으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="95555a38b0d0fdd7e883cd86b3b46ad68f807768" translate="yes" xml:space="preserve">
          <source>. The latter is most probably already fixed, if you see it and can trace where the latter spurious warning comes from, please inform me.</source>
          <target state="translated">. 후자는 아마도 이미 수정되었을 것입니다. 보시고 후자의 가짜 경고의 출처를 추적 할 수 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="92fd66a748779ee3429954e90cf1b31a9766b03d" translate="yes" xml:space="preserve">
          <source>. The latter means that if you just installed EMX, and made all the needed changes to</source>
          <target state="translated">. 후자는 EMX를 방금 설치하고 필요한 모든 사항을 변경 한 경우</target>
        </trans-unit>
        <trans-unit id="7e4c4954b32c854b5ebec7089c4678970bb9dad2" translate="yes" xml:space="preserve">
          <source>. The logical character sequence itself is unchanged. If</source>
          <target state="translated">. 논리 문자 순서 자체는 변경되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="cd29714c2a33b9f7328510e6da296e4c8f1474ee" translate="yes" xml:space="preserve">
          <source>. The makefile can use this with something like $shrpenv $(&lt;code&gt;CC&lt;/code&gt; ) -o perl</source>
          <target state="translated">. makefile은 이것을 $ shrpenv $ ( &lt;code&gt;CC&lt;/code&gt; ) -o perl 과 같은 것으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b03c44aca2024a062290e65cdad6340296b07dc8" translate="yes" xml:space="preserve">
          <source>. The makefile can use this with something like $shrpenv $(&lt;code&gt;CC&lt;/code&gt;) -o perl</source>
          <target state="translated">. makefile은 $ shrpenv $ ( &lt;code&gt;CC&lt;/code&gt; ) -o perl 과 같이 이것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28baca6170ca62229fafab754ab3c6019b0a96c" translate="yes" xml:space="preserve">
          <source>. The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the FILE * is opened in same mode as the PerlIO *.</source>
          <target state="translated">. 모드 인수는 fopen / PerlIO_open에 전달 될 문자열이어야합니다. NULL 인 경우-레거시 지원의 경우 FILE *는 PerlIO *와 동일한 모드에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="d127834d1054b17ba75249e4716d18cafb707bc6" translate="yes" xml:space="preserve">
          <source>. The name information can be used for POD translators.</source>
          <target state="translated">. 이름 정보는 POD 변환기에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e41d71ac7eded037c4670d30d4568b8d18ea55e" translate="yes" xml:space="preserve">
          <source>. The name of a feature bundle is prefixed with a colon, to distinguish it from an actual feature.</source>
          <target state="translated">. 기능 번들의 이름은 콜론으로 시작하여 실제 기능과 구별합니다.</target>
        </trans-unit>
        <trans-unit id="84b15d4f04c91fed2b935cf88259b619f7e87100" translate="yes" xml:space="preserve">
          <source>. The newly-allocated hash table may now have data stored and retrieved. Efforts to store more than &lt;code&gt;$table_size&lt;/code&gt; elements will result in a fatal error, as will efforts to store a value not exactly &lt;code&gt;$value_len&lt;/code&gt; characters in length, or reference through a key not exactly &lt;code&gt;$key_len&lt;/code&gt; characters in length. While these constraints may seem excessive, the result is a hash table using much less internal memory than an equivalent freely-allocated hash table.</source>
          <target state="translated">. 새로 할당 된 해시 테이블에 데이터를 저장하고 검색 할 수 있습니다. &lt;code&gt;$table_size&lt;/code&gt; 보다 많은 요소 를 저장 하려고 하면 치명적인 오류가 발생합니다. 정확히 &lt;code&gt;$value_len&lt;/code&gt; 문자 길이가 아닌 값을 저장 하거나 정확히 &lt;code&gt;$key_len&lt;/code&gt; 문자 길이가 아닌 키를 참조 하면 오류가 발생 합니다. 이러한 제약 조건이 과도하게 보일 수 있지만 결과적으로 자유롭게 할당되는 해시 테이블보다 훨씬 적은 내부 메모리를 사용하는 해시 테이블이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b95ab5214831e47ae4521fdbeb4471b9560f0ca4" translate="yes" xml:space="preserve">
          <source>. The object should provide the interface described in &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. If more than two arguments are provided, additional arguments are considered aliases for</source>
          <target state="translated">. 객체는 &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode :: Encoding에&lt;/a&gt; 설명 된 인터페이스를 제공해야합니다 . 두 개 이상의 인수가 제공되면 추가 인수는 다음에 대한 별칭으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="90f2a0f7f26f9ff04e556e24ec0e5a3e66bc88a2" translate="yes" xml:space="preserve">
          <source>. The object should provide the interface described in &lt;a href=&quot;encode/encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. If more than two arguments are provided, additional arguments are considered aliases for</source>
          <target state="translated">. 객체는 &lt;a href=&quot;encode/encoding&quot;&gt;Encode :: Encoding에&lt;/a&gt; 설명 된 인터페이스를 제공해야합니다 . 둘 이상의 인수가 제공되는 경우 추가 인수는에 대한 별명으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="96a94934114bd87c528984fa35f3cbd286f4a6de" translate="yes" xml:space="preserve">
          <source>. The old way was to declare it as &quot;int (*signal(...))()&quot;.</source>
          <target state="translated">. 오래된 방법은 &quot;int (* signal (...)) ()&quot;로 선언하는 것이 었습니다.</target>
        </trans-unit>
        <trans-unit id="af4d0c63d60ebd8bd921063f1610ae5b1868cae0" translate="yes" xml:space="preserve">
          <source>. The outlier &lt;code&gt;\c?&lt;/code&gt; on ASCII, which yields a non-C0 control &lt;code&gt;DEL&lt;/code&gt; , yields the outlier control &lt;code&gt;APC&lt;/code&gt; on EBCDIC, the one that isn't in the block of contiguous controls. Note that a subtlety of this is that &lt;code&gt;\c?&lt;/code&gt; on ASCII platforms is an ASCII character, while it isn't equivalent to any ASCII character in EBCDIC platforms.</source>
          <target state="translated">. 특이 치 &lt;code&gt;\c?&lt;/code&gt; 비 C0 제어 &lt;code&gt;DEL&lt;/code&gt; 을 생성하는 ASCII에서는 연속 제어 블록에없는 EBCDIC 에서 이상치 제어 &lt;code&gt;APC&lt;/code&gt; 를 생성 합니다. 이것의 미묘함은 &lt;code&gt;\c?&lt;/code&gt; ASCII 플랫폼의 ASCII 문자는 EBCDIC 플랫폼의 ASCII 문자와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd3933589237eb991c99b51b88f09d803792f4ad" translate="yes" xml:space="preserve">
          <source>. The outlier &lt;code&gt;\c?&lt;/code&gt; on ASCII, which yields a non-C0 control &lt;code&gt;DEL&lt;/code&gt;, yields the outlier control &lt;code&gt;APC&lt;/code&gt; on EBCDIC, the one that isn't in the block of contiguous controls. Note that a subtlety of this is that &lt;code&gt;\c?&lt;/code&gt; on ASCII platforms is an ASCII character, while it isn't equivalent to any ASCII character in EBCDIC platforms.</source>
          <target state="translated">. 이상치 &lt;code&gt;\c?&lt;/code&gt; 비 CO 제어 &lt;code&gt;DEL&lt;/code&gt; 을 생성하는 ASCII에서는 연속 제어 블록에없는 EBCDIC 의 이상 값 제어 &lt;code&gt;APC&lt;/code&gt; 를 생성 합니다. 이것의 미묘함은 &lt;code&gt;\c?&lt;/code&gt; ASCII 플랫폼에서는 ASCII 문자이지만 EBCDIC 플랫폼의 ASCII 문자와 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bd4f959347af60366084a6b999d2b4170409fa5" translate="yes" xml:space="preserve">
          <source>. The output is the list of files that match the fileglob.</source>
          <target state="translated">. 출력은 fileglob와 일치하는 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3a753f8f2e7a43103d1ff1824cd727b6ecbdb4ec" translate="yes" xml:space="preserve">
          <source>. The pattern code expression is like a regular code expression, except that the result of the code evaluation is treated as a regular expression and matched immediately. A simple example is</source>
          <target state="translated">. 패턴 코드 표현식은 코드 평가 결과가 정규 표현식으로 처리되고 즉시 일치된다는 점을 제외하면 일반 코드 표현식과 같습니다. 간단한 예는</target>
        </trans-unit>
        <trans-unit id="a244cd3187379cc2fe2c070c785808570854282b" translate="yes" xml:space="preserve">
          <source>. The people with little desire to understand Perl can just rename main(), and do necessary modification in a custom main() which calls the renamed function in appropriate time.</source>
          <target state="translated">. Perl을 이해하고 싶지 않은 사람들은 main ()의 이름을 바꾸고 적절한 시간에 이름이 변경된 함수를 호출하는 사용자 정의 main ()에서 필요한 수정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201d8370b36c2e56d7351b01de7f62376c175f87" translate="yes" xml:space="preserve">
          <source>. The perl headers (in particular &quot;perlio.h&quot;) will &lt;code&gt;#define&lt;/code&gt; them to the I/O mechanism selected at Configure time.</source>
          <target state="translated">. perl 헤더 (특히 &quot;perlio.h&quot;)는 구성시 선택된 I / O 메커니즘에 따라 &lt;code&gt;#define&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac04dd22ec2d3883b78a8c65c848b91a67ea61d0" translate="yes" xml:space="preserve">
          <source>. The quoted-printable encoding is intended to represent data that largely consists of bytes that correspond to printable characters in the ASCII character set. Each non-printable character (as defined by English Americans) is represented by a triplet consisting of the character &quot;=&quot; followed by two hexadecimal digits.</source>
          <target state="translated">. 인용 인쇄 가능 인코딩은 ASCII 문자 세트의 인쇄 가능 문자에 해당하는 바이트로 크게 구성된 데이터를 나타 내기위한 것입니다. 인쇄 할 수없는 각 문자 (영어 미국인에 의해 정의 됨)는 문자 &quot;=&quot;와 두 개의 16 진수로 구성되는 삼중 항으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="500581814351c949b94b39e4cb44f6f66856596f" translate="yes" xml:space="preserve">
          <source>. The remaining content of the buffer will be moved, and all pointers into the buffer updated appropriately.</source>
          <target state="translated">. 버퍼의 나머지 내용이 이동하고 버퍼의 모든 포인터가 적절하게 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="22430eb3a8c28a42cd2b9e57521a0c62f976ab90" translate="yes" xml:space="preserve">
          <source>. The repository contains many Perl revisions from Perl 1 onwards and all the revisions from Perforce, the previous version control system.</source>
          <target state="translated">. 저장소에는 Perl 1 이후의 많은 Perl 개정판과 이전 버전 제어 시스템 인 Perforce의 모든 개정판이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb3d7ca2967ce75e740e5fdec318eba71ce3dd4" translate="yes" xml:space="preserve">
          <source>. The rules for this are different for lower-level loops given by the greedy quantifiers &lt;code&gt;*+{}&lt;/code&gt; , and for higher-level ones like the &lt;code&gt;/g&lt;/code&gt; modifier or split() operator.</source>
          <target state="translated">. 이에 대한 규칙은 욕심 많은 수량 자 &lt;code&gt;*+{}&lt;/code&gt; 에 의해 주어진 하위 레벨 루프 와 &lt;code&gt;/g&lt;/code&gt; 수정 자 또는 split () 연산자 와 같은 상위 레벨 루프에 대해 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1754438a27d471f8ae277b9281477b845d59dd47" translate="yes" xml:space="preserve">
          <source>. The rules for this are different for lower-level loops given by the greedy quantifiers &lt;code&gt;*+{}&lt;/code&gt;, and for higher-level ones like the &lt;code&gt;/g&lt;/code&gt; modifier or &lt;code&gt;split()&lt;/code&gt; operator.</source>
          <target state="translated">. 이에 대한 규칙은 탐욕스러운 한정자 &lt;code&gt;*+{}&lt;/code&gt; 에 의해 제공되는 하위 수준 루프 와 &lt;code&gt;/g&lt;/code&gt; 수정 자 또는 &lt;code&gt;split()&lt;/code&gt; 연산자 와 같은 상위 수준 루프에 대해 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="03aa66011823d9de16726ea950dd95ac9e1fd5d9" translate="yes" xml:space="preserve">
          <source>. The simple pipeline command below runs the script without needing to create a temporary file to hold the uncompressed file.</source>
          <target state="translated">. 아래의 간단한 파이프 라인 명령은 압축되지 않은 파일을 보관하기 위해 임시 파일을 만들 필요없이 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="27721e0ebedbef76f0308d9d0eabaae4fcdb33f6" translate="yes" xml:space="preserve">
          <source>. The string pointed to by &lt;code&gt;key&lt;/code&gt; is Safefree()ed. If one has a</source>
          <target state="translated">. &lt;code&gt;key&lt;/code&gt; 가 가리키는 문자열 은 Safefree ()입니다. 하나 있다면</target>
        </trans-unit>
        <trans-unit id="9b46cc835e15bbfbdcebf9ceb7880e84ac2dc80a" translate="yes" xml:space="preserve">
          <source>. The term &quot;backtracking&quot; comes from the idea that matching a regexp is like a walk in the woods. Successfully matching a regexp is like arriving at a destination. There are many possible trailheads, one for each string position, and each one is tried in order, left to right. From each trailhead there may be many paths, some of which get you there, and some which are dead ends. When you walk along a trail and hit a dead end, you have to backtrack along the trail to an earlier point to try another trail. If you hit your destination, you stop immediately and forget about trying all the other trails. You are persistent, and only if you have tried all the trails from all the trailheads and not arrived at your destination, do you declare failure. To be concrete, here is a step-by-step analysis of what Perl does when it tries to match the regexp</source>
          <target state="translated">. &quot;역 추적&quot;이라는 용어는 정규 표현식을 일치시키는 것이 숲 속을 걷는 것과 같다는 생각에서 비롯된 것입니다. 정규 표현식을 성공적으로 일치시키는 것은 목적지에 도착하는 것과 같습니다. 가능한 트레일 헤드는 각 문자열 위치에 하나씩, 왼쪽에서 오른쪽으로 순서대로 시도됩니다. 각 트레일 헤드에는 여러 경로가있을 수 있으며, 그중 일부는 그곳에 도착하고 일부는 막 다른 골목에 있습니다. 트레일을 따라 걷다 막 다른 골목에 도달하면 다른 트레일을 시도하기 위해 트레일을 따라 이전 지점으로 되돌아 가야합니다. 목적지에 도달하면 즉시 정지하고 다른 모든 트레일을 시도하는 것을 잊습니다. 당신은 끈기 있고, 모든 트레일 헤드에서 모든 트레일을 시도했지만 목적지에 도착하지 않은 경우에만 실패를 선언합니까? 구체적으로 말하자면다음은 정규 표현식과 일치하려고 할 때 Perl이 수행하는 작업에 대한 단계별 분석입니다.</target>
        </trans-unit>
        <trans-unit id="67287b42e112f78aab0082dd4f95584b4f318556" translate="yes" xml:space="preserve">
          <source>. The term 'backtracking' comes from the idea that matching a regexp is like a walk in the woods. Successfully matching a regexp is like arriving at a destination. There are many possible trailheads, one for each string position, and each one is tried in order, left to right. From each trailhead there may be many paths, some of which get you there, and some which are dead ends. When you walk along a trail and hit a dead end, you have to backtrack along the trail to an earlier point to try another trail. If you hit your destination, you stop immediately and forget about trying all the other trails. You are persistent, and only if you have tried all the trails from all the trailheads and not arrived at your destination, do you declare failure. To be concrete, here is a step-by-step analysis of what Perl does when it tries to match the regexp</source>
          <target state="translated">. '역 추적'이라는 용어는 정규 표현식과 일치하는 것이 숲 속의 산책과 같다는 생각에서 비롯됩니다. 정규 표현식을 성공적으로 일치시키는 것은 목적지에 도착하는 것과 같습니다. 각 현 위치마다 하나씩 많은 트레일 헤드가 있으며, 각각 왼쪽에서 오른쪽으로 순서대로 시도됩니다. 각 트레일 헤드에는 많은 경로가있을 수 있으며, 그 중 일부는 도착할 수 있고 일부는 막 다른 길입니다. 트레일을 따라 걸을 때 막 다른 길을 가면 트레일을 따라 이전 지점으로 역 추적하여 다른 트레일을 시도해야합니다. 목적지에 도착하면 즉시 멈추고 다른 길을 모두 시도하는 것을 잊어 버리십시오. 귀하는 지속적이며 모든 트레일 헤드에서 모든 트레일을 시도했지만 목적지에 도착하지 않은 경우에만 실패를 선언합니까? 구체적으로, Perexp가 정규 표현식과 일치하려고 할 때 수행하는 작업에 대한 단계별 분석은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="271320c65fb03216673c7a60089d1bfc5db3e659" translate="yes" xml:space="preserve">
          <source>. The third, runs all test files within any subdirectory within any other subdirectory located under</source>
          <target state="translated">. 세 번째는 아래에있는 다른 하위 디렉터리 내의 하위 디렉터리 내에서 모든 테스트 파일을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1199d660ecd25075f0cdf9eb332edd41306fb5d2" translate="yes" xml:space="preserve">
          <source>. The tiny</source>
          <target state="translated">. 작은</target>
        </trans-unit>
        <trans-unit id="f8bf61a3338726aa2f8f5b4c9d009164e7670ace" translate="yes" xml:space="preserve">
          <source>. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">. 후행 X는 고유 한 영숫자 조합으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f827c6257f988b2cfbe83fce3e73ddf1d0943d59" translate="yes" xml:space="preserve">
          <source>. The undef third argument means:</source>
          <target state="translated">. undef 세 번째 인수는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff757407b18554327da61107241354758c27a9bd" translate="yes" xml:space="preserve">
          <source>. The use of &lt;code&gt;autodie&lt;/code&gt; with block eval is considered good practice.</source>
          <target state="translated">. 블록 평가와 함께 &lt;code&gt;autodie&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a2e85546ff1b49b5a3d548ca91cc9bb13a0aea4" translate="yes" xml:space="preserve">
          <source>. The value will be stored with the specified key in the hash.</source>
          <target state="translated">. 값은 지정된 키와 함께 해시에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2849d1607b0f29dbd3fdbc14fdf69cbd91b077" translate="yes" xml:space="preserve">
          <source>. Then you can use the modules from your Perl programs with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; or sometimes just &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &quot;/my/perl_directory&quot;;&lt;/code&gt; . If you're on a system that requires superuser/root access to install modules into the directories you see when you type &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; , you'll want to install them into a local directory (such as your home directory) and use this approach.</source>
          <target state="translated">. 그런 다음 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; 을 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하여 Perl 프로그램의 모듈을 사용할 수 있습니다 . 또는 때로는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &quot;/my/perl_directory&quot;;&lt;/code&gt; . &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 를 입력 할 때 표시되는 디렉토리에 모듈을 설치하기 위해 수퍼 유저 / 루트 액세스가 필요한 시스템에있는 경우 로컬 디렉토리 (예 : 홈 디렉토리)와이 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1842d5f94a1fdcb49d6f0f77d249f666636122c9" translate="yes" xml:space="preserve">
          <source>. Then you can use the modules from your Perl programs with &lt;code&gt;use lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; or sometimes just &lt;code&gt;use &quot;/my/perl_directory&quot;;&lt;/code&gt;. If you're on a system that requires superuser/root access to install modules into the directories you see when you type &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt;, you'll want to install them into a local directory (such as your home directory) and use this approach.</source>
          <target state="translated">. 그런 다음 &lt;code&gt;use lib &quot;/my/perl_directory/lib/site_perl&quot;;&lt;/code&gt; 을 사용 하여 Perl 프로그램의 모듈을 사용할 수 있습니다 . 또는 때때로 &lt;code&gt;use &quot;/my/perl_directory&quot;;&lt;/code&gt; . &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 를 입력 할 때 표시되는 디렉토리에 모듈을 설치하기 위해 수퍼 유저 / 루트 액세스가 필요한 시스템에 있다면 로컬 디렉토리 (예 : 홈 디렉토리)이 접근 방식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41e2d95e78f178f418e712b7eaca32286569001d" translate="yes" xml:space="preserve">
          <source>. There are many possibilities among the world's languages. The number of combinations is astronomical, and if there were a character for each combination, it would soon exhaust Unicode's more than a million possible characters. So Unicode took a different approach: there is a character for the base &lt;code&gt;H&lt;/code&gt; , and a character for each of the possible marks, and these can be variously combined to get a final logical character. So a logical character--what appears to be a single character--can be a sequence of more than one individual characters. The Unicode standard calls these &quot;extended grapheme clusters&quot; (which is an improved version of the no-longer much used &quot;grapheme cluster&quot;); Perl furnishes the &lt;code&gt;\X&lt;/code&gt; regular expression construct to match such sequences in their entirety.</source>
          <target state="translated">. 세계 언어들에는 많은 가능성이 있습니다. 조합의 수는 천문학적이며 각 조합에 대한 문자가 있으면 곧 유니 코드의 가능한 백만 개 이상의 문자를 사용할 수 있습니다. 따라서 유니 코드는 다른 접근 방식을 취했습니다. 기본 &lt;code&gt;H&lt;/code&gt; 문자와 가능한 각 마크 문자가 있으며 최종 논리 문자를 얻기 위해 다양하게 결합 할 수 있습니다. 따라서 논리 문자 (단일 문자로 표시됨)는 둘 이상의 개별 문자 시퀀스 일 수 있습니다. 유니 코드 표준은 이러한 &quot;확장 된 grapheme 클러스터&quot;(더 이상 사용되지 않는 &quot;grapheme 클러스터&quot;의 개선 된 버전)를 호출합니다. Perl은 &lt;code&gt;\X&lt;/code&gt; 정규 표현식 구조를 제공하여 이러한 서열을 전체적으로 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="b859bffd6633a2a259d33db2b3573f666da21944" translate="yes" xml:space="preserve">
          <source>. There are many possibilities among the world's languages. The number of combinations is astronomical, and if there were a character for each combination, it would soon exhaust Unicode's more than a million possible characters. So Unicode took a different approach: there is a character for the base &lt;code&gt;H&lt;/code&gt;, and a character for each of the possible marks, and these can be variously combined to get a final logical character. So a logical character--what appears to be a single character--can be a sequence of more than one individual characters. The Unicode standard calls these &quot;extended grapheme clusters&quot; (which is an improved version of the no-longer much used &quot;grapheme cluster&quot;); Perl furnishes the &lt;code&gt;\X&lt;/code&gt; regular expression construct to match such sequences in their entirety.</source>
          <target state="translated">. 세계의 언어에는 많은 가능성이 있습니다. 조합의 수는 천문학적이며 각 조합에 대한 문자가 있다면 곧 유니 코드의 가능한 백만 개 이상의 문자를 소진시킬 것입니다. 따라서 유니 코드는 다른 접근 방식을 취했습니다. 기본 &lt;code&gt;H&lt;/code&gt; 에 대한 문자와 가능한 각 표시에 대한 문자가 있으며, 이들을 다양하게 결합하여 최종 논리 문자를 얻을 수 있습니다. 따라서 논리적 문자 (단일 문자로 보이는 것)는 하나 이상의 개별 문자의 시퀀스 일 수 있습니다. 유니 코드 표준은이를 &quot;확장 된 자소 클러스터&quot;라고 부릅니다 (이는 더 이상 많이 사용되지 않는 &quot;자소 클러스터&quot;의 개선 된 버전입니다). Perl은 이러한 시퀀스를 전체적으로 일치시키기 위해 &lt;code&gt;\X&lt;/code&gt; 정규식 구조를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1eadc7716975de872df1e240fa5e27efd9843f58" translate="yes" xml:space="preserve">
          <source>. There are quite a few result types available; choosing which class to use is the responsibility of the</source>
          <target state="translated">. 사용 가능한 결과 유형이 꽤 있습니다. 사용할 수업을 선택하는 것은</target>
        </trans-unit>
        <trans-unit id="fc1d774c15da48c7b41ed72cf330c112b7557d27" translate="yes" xml:space="preserve">
          <source>. There is no expectation that a module under</source>
          <target state="translated">. 아래에 모듈이있을 것으로 예상되지 않습니다</target>
        </trans-unit>
        <trans-unit id="b15934fcc010d833b1b6611fcee4806aa409aca1" translate="yes" xml:space="preserve">
          <source>. There is no limit to the number of captured substrings that you may use. Groups are numbered with the leftmost open parenthesis being number 1,</source>
          <target state="translated">. 사용할 수있는 캡처 된 하위 문자열의 수에는 제한이 없습니다. 그룹은 가장 왼쪽에있는 여는 괄호가 1이되도록 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="f07748882481b43ba802e33458c4f0da3c02f2d4" translate="yes" xml:space="preserve">
          <source>. There is no limit to the number of captured substrings that you may use. Groups are numbered with the leftmost open parenthesis being number 1, etc. If a group did not match, the associated backreference won't match either. (This can happen if the group is optional, or in a different branch of an alternation.) You can omit the &lt;code&gt;&quot;g&quot;&lt;/code&gt; , and write &lt;code&gt;&quot;\1&quot;&lt;/code&gt; , etc, but there are some issues with this form, described below.</source>
          <target state="translated">. 사용할 수있는 캡처 된 부분 문자열의 수에는 제한이 없습니다. 그룹은 가장 왼쪽에있는 괄호가 숫자 1 등으로 번호가 매겨집니다. 그룹이 일치하지 않으면 연관된 역 참조도 일치하지 않습니다. (이 옵션은 그룹이 선택 사항이거나 교대의 다른 분기에있는 경우 발생할 수 있습니다.) &lt;code&gt;&quot;g&quot;&lt;/code&gt; 를 생략하고 &lt;code&gt;&quot;\1&quot;&lt;/code&gt; 등을 쓸 수 있지만 아래에 설명 된이 양식에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3ae656b3d4dccde9a6b843783f9804004492bc" translate="yes" xml:space="preserve">
          <source>. There is some naming convention which allows Perl to distinguish correct lines from wrong ones. The above names are almost the only names allowed by this convention which do not contain digits (which have absolutely different semantics).</source>
          <target state="translated">. Perl이 올바른 행과 잘못된 행을 구별 할 수있는 명명 규칙이 있습니다. 위의 이름은이 규칙에서 허용하는 거의 유일한 이름이며 숫자를 포함하지 않습니다 (절대적으로 의미가 다름).</target>
        </trans-unit>
        <trans-unit id="70ae579c941e1b2af83331b8b0575b24042dac0b" translate="yes" xml:space="preserve">
          <source>. Therefore data in these fields should NOT be used for dynamic (user-side) configuration.</source>
          <target state="translated">. 따라서이 필드의 데이터는 동적 (사용자측) 구성에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="df7a4d889790cf742e680d4d6efa4fd1ee3dd47f" translate="yes" xml:space="preserve">
          <source>. These are extensions to the traditional regular expression syntax that provide powerful new tools for pattern matching. We have already seen extensions in the form of the minimal matching constructs &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}?&lt;/code&gt;, and &lt;code&gt;{n,}?&lt;/code&gt;. Most of the extensions below have the form &lt;code&gt;(?char...)&lt;/code&gt;, where the &lt;code&gt;char&lt;/code&gt; is a character that determines the type of extension.</source>
          <target state="translated">. 이것들은 패턴 매칭을위한 강력하고 새로운 도구를 제공하는 전통적인 정규 표현식 구문의 확장입니다. 우리는 이미 최소 일치 구문의 형태로 확장을 보았습니다 &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}?&lt;/code&gt; 및 &lt;code&gt;{n,}?&lt;/code&gt; . 아래의 대부분의 확장자는 &lt;code&gt;(?char...)&lt;/code&gt; 이며, 여기서 &lt;code&gt;char&lt;/code&gt; 은 확장자의 유형을 결정하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f40a1ee0d51ebf15d390e739c288fb892f4c8938" translate="yes" xml:space="preserve">
          <source>. These are extensions to the traditional regular expression syntax that provide powerful new tools for pattern matching. We have already seen extensions in the form of the minimal matching constructs &lt;code&gt;??&lt;/code&gt;, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{n,m}?&lt;/code&gt;, and &lt;code&gt;{n,}?&lt;/code&gt;. Most of the extensions below have the form &lt;code&gt;(?char...)&lt;/code&gt;, where the &lt;code&gt;char&lt;/code&gt; is a character that determines the type of extension.</source>
          <target state="translated">. 이는 패턴 일치를위한 강력한 새 도구를 제공하는 기존 정규식 구문의 확장입니다. 우리는 이미 최소 매칭 구조의 형태로 확장을 보았습니다 &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{n,m}?&lt;/code&gt; , 그리고 &lt;code&gt;{n,}?&lt;/code&gt; . 아래의 대부분의 확장은 &lt;code&gt;(?char...)&lt;/code&gt; 이며, 여기서 &lt;code&gt;char&lt;/code&gt; 는 확장 유형을 결정하는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="d0fe671376fe423873e5083176cea32f8c57ff41" translate="yes" xml:space="preserve">
          <source>. These are old libraries supplied so that old programs that use them still run. The</source>
          <target state="translated">. 이것들은 그것들을 사용하는 오래된 프로그램이 여전히 실행되도록 제공된 오래된 라이브러리입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="454759045b5bf4b0bfdcd22dd8dd6d89d962177f" translate="yes" xml:space="preserve">
          <source>. These are shown for historical context and must not be produced in or consumed from any metadata structure of version 2 or higher.</source>
          <target state="translated">. 이는 기록 컨텍스트를 위해 표시되며 버전 2 이상의 메타 데이터 구조에서 생성되거나 사용되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d51f5b82ec726ec3264afac0ee1a71ba67d94d17" translate="yes" xml:space="preserve">
          <source>. These days, your best bet is to look at the &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; module available from CPAN, which also requires two other modules from CPAN, &lt;a href=&quot;IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;IO::Stty&quot;&gt;IO::Stty&lt;/a&gt;.</source>
          <target state="translated">. 요즘 가장 좋은 방법은 CPAN에서 사용할 수 있는 &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; 모듈 을 살펴 보는 것입니다.이 모듈에는 CPAN, &lt;a href=&quot;IO::Pty&quot;&gt;IO :: Pty&lt;/a&gt; 및 &lt;a href=&quot;IO::Stty&quot;&gt;IO :: Stty의&lt;/a&gt; 다른 두 모듈도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8364539299fc6e8e877e8a93bec948c2c56a9805" translate="yes" xml:space="preserve">
          <source>. These days, your best bet is to look at the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module available from CPAN, which also requires two other modules from CPAN, &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Stty&quot;&gt;IO::Stty&lt;/a&gt;.</source>
          <target state="translated">. 요즘 CPAN에서 사용 가능한 &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; 모듈 을 살펴 보는 것이 가장 좋습니다. CPAN의 다른 두 모듈 인 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Pty&quot;&gt;IO :: Pty&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Stty&quot;&gt;IO :: Stty&lt;/a&gt; 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ba6b2c48d03193d3763913a4f9e3d93618b2d213" translate="yes" xml:space="preserve">
          <source>. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in</source>
          <target state="translated">. 이 8 진수는 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; 플래그 설정 여부에 따라 UTF-8 또는 Latin-1로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b3c0c48688a8f7bba27cf24326ee5346b264572" translate="yes" xml:space="preserve">
          <source>. These revisions will never change semantics or add or remove specified behavior.</source>
          <target state="translated">. 이러한 개정은 의미 체계를 변경하거나 지정된 동작을 추가 또는 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6319b650504012b1b53a50eecb57429c0a9dcfe4" translate="yes" xml:space="preserve">
          <source>. They are almost like subclasses in that they have the same fields as &lt;code&gt;regnode&lt;/code&gt; , with possibly additional fields following in the structure, and in some cases the specific meaning (and name) of some of base fields are overridden. The following is a more complete description.</source>
          <target state="translated">. 그것들은 &lt;code&gt;regnode&lt;/code&gt; 와 동일한 필드를 가지고 있다는 점에서 서브 클래스와 거의 같습니다 . 구조에서 추가 필드가 이어질 수 있으며 경우에 따라 일부 기본 필드의 특정 의미 (및 이름)가 무시됩니다. 다음은보다 자세한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="9618e85e95e57cc6614cc9a95470d206c3ad3b7d" translate="yes" xml:space="preserve">
          <source>. They are almost like subclasses in that they have the same fields as &lt;code&gt;regnode&lt;/code&gt;, with possibly additional fields following in the structure, and in some cases the specific meaning (and name) of some of base fields are overridden. The following is a more complete description.</source>
          <target state="translated">. &lt;code&gt;regnode&lt;/code&gt; 와 동일한 필드를 가지며 구조에 추가 필드가있을 수 있으며 일부 경우 기본 필드의 특정 의미 (및 이름)가 재정의 된다는 점에서 서브 클래스와 거의 비슷 합니다. 다음은보다 완전한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="cd75f69783a2baccf3e6cd502bef7b11d6b9f1dc" translate="yes" xml:space="preserve">
          <source>. They can be used just as ordinary variables:</source>
          <target state="translated">. 일반 변수처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57272a6cda3a773fa9ad5fcdc0dbe778246cc48b" translate="yes" xml:space="preserve">
          <source>. They need the braces, so are written as &lt;code&gt;/\p{Ll}/&lt;/code&gt; or &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt; , or &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (the underscores are optional). &lt;code&gt;/\pLl/&lt;/code&gt; is valid, but means something different. It matches a two character string: a letter (Unicode property &lt;code&gt;\pL&lt;/code&gt; ), followed by a lowercase &lt;code&gt;l&lt;/code&gt; .</source>
          <target state="translated">. 중괄호가 필요하므로 &lt;code&gt;/\p{Ll}/&lt;/code&gt; 또는 &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt; 또는 &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (밑줄은 선택 사항)로 작성됩니다. &lt;code&gt;/\pLl/&lt;/code&gt; 은 유효하지만 다른 의미입니다. 문자 (유니 코드 특성 &lt;code&gt;\pL&lt;/code&gt; )와 소문자 &lt;code&gt;l&lt;/code&gt; 이 오는 두 개의 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="7ea6b9b119c9587405e34943c9b5f2d61525197a" translate="yes" xml:space="preserve">
          <source>. They need the braces, so are written as &lt;code&gt;/\p{Ll}/&lt;/code&gt; or &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt;, or &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (the underscores are optional). &lt;code&gt;/\pLl/&lt;/code&gt; is valid, but means something different. It matches a two character string: a letter (Unicode property &lt;code&gt;\pL&lt;/code&gt;), followed by a lowercase &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">. 중괄호가 필요하므로 &lt;code&gt;/\p{Ll}/&lt;/code&gt; 또는 &lt;code&gt;/\p{Lowercase_Letter}/&lt;/code&gt; 또는 &lt;code&gt;/\p{General_Category=Lowercase_Letter}/&lt;/code&gt; (밑줄은 선택 사항). &lt;code&gt;/\pLl/&lt;/code&gt; 은 유효하지만 다른 의미입니다. 문자 (유니 코드 속성 &lt;code&gt;\pL&lt;/code&gt; )와 소문자 &lt;code&gt;l&lt;/code&gt; 이 오는 2 개의 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c18a582b7f92b4f78c23e95b1cf02accd986e21b" translate="yes" xml:space="preserve">
          <source>. This C code is places at the start of a block, so you can declare variables in it.</source>
          <target state="translated">. 이 C 코드는 블록 시작 부분에 있으므로 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f4d13b8729ed274f6a8a631317728de1b0336d" translate="yes" xml:space="preserve">
          <source>. This advances &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; to match</source>
          <target state="translated">. 이것은 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; 을 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="b35fcf8a74bd022a9580104a744f0bdc08475a29" translate="yes" xml:space="preserve">
          <source>. This affects Perl's &lt;code&gt;\w&lt;/code&gt; regular expression metanotation, which stands for alphanumeric characters--that is, alphabetic, numeric, and the platform's native underscore. (Consult &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for more information about regular expressions.) Thanks to &lt;code&gt;LC_CTYPE&lt;/code&gt; , depending on your locale setting, characters like &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;, and &quot;&amp;oslash;&quot; may be understood as &lt;code&gt;\w&lt;/code&gt; characters. It also affects things like &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt; , and the POSIX character classes, like &lt;code&gt;[[:graph:]]&lt;/code&gt; . (See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for more information on all these.)</source>
          <target state="translated">. 이것은 Perl의 &lt;code&gt;\w&lt;/code&gt; 정규 표현식 메타 노테이션에 영향을 미칩니다. 이는 알파벳, 숫자 및 플랫폼의 기본 밑줄을 의미합니다. ( 정규 표현식에 대한 자세한 정보는 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 를 참조하십시오 .) &lt;code&gt;LC_CTYPE&lt;/code&gt; 덕분에 로케일 설정에 따라 &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;및 &quot;&amp;oslash;&quot;와 같은 문자 는 &lt;code&gt;\w&lt;/code&gt; 문자 로 이해 될 수 있습니다 . 또한 &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; 및 &lt;code&gt;[[:graph:]]&lt;/code&gt; 와 같은 POSIX 문자 클래스 에도 영향을줍니다 . ( 이 모든 &lt;a href=&quot;perlrecharclass&quot;&gt;것에&lt;/a&gt; 대한 자세한 정보는 perlrecharclass 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="269e5be095f95d8223d1e5356c614e40592cc651" translate="yes" xml:space="preserve">
          <source>. This affects Perl's &lt;code&gt;\w&lt;/code&gt; regular expression metanotation, which stands for alphanumeric characters--that is, alphabetic, numeric, and the platform's native underscore. (Consult &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for more information about regular expressions.) Thanks to &lt;code&gt;LC_CTYPE&lt;/code&gt;, depending on your locale setting, characters like &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;, and &quot;&amp;oslash;&quot; may be understood as &lt;code&gt;\w&lt;/code&gt; characters. It also affects things like &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, and the POSIX character classes, like &lt;code&gt;[[:graph:]]&lt;/code&gt;. (See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for more information on all these.)</source>
          <target state="translated">. 이는 영숫자 문자 (알파벳, 숫자 및 플랫폼의 기본 밑줄)를 나타내는 Perl의 &lt;code&gt;\w&lt;/code&gt; 정규식 메타 노테이션에 영향을줍니다 . ( 정규 표현식에 대한 자세한 내용은 &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 에 문의하십시오 .) &lt;code&gt;LC_CTYPE&lt;/code&gt; 덕분에 로케일 설정에 따라 &quot;&amp;aelig;&quot;, &quot;&amp;eth;&quot;, &quot;&amp;szlig;&quot;및 &quot;&amp;oslash;&quot;와 같은 문자 는 &lt;code&gt;\w&lt;/code&gt; 문자 로 이해 될 수 있습니다 . 또한 &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; 및 &lt;code&gt;[[:graph:]]&lt;/code&gt; 와 같은 POSIX 문자 클래스 에도 영향을 미칩니다 . ( 이 모든 &lt;a href=&quot;perlrecharclass&quot;&gt;것에&lt;/a&gt; 대한 자세한 정보는 perlrecharclass 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="292fb479a853e46bd4ecf5a0119063b45e1fdfc9" translate="yes" xml:space="preserve">
          <source>. This construct is useful for optimizations of what would otherwise be &quot;eternal&quot; matches, because it will not backtrack (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;). It may also be useful in places where the &quot;grab all you can, and do not give anything back&quot; semantic is desirable.</source>
          <target state="translated">. 이 구조는 역 추적하지 않기 때문에 &quot;영원한&quot;일치 항목을 최적화하는 데 유용합니다 ( &lt;a href=&quot;#Backtracking&quot;&gt;&quot;역 추적&quot;&lt;/a&gt; 참조 ). 또한 &quot;당신이 할 수있는 모든 것을 잡고 아무것도 돌려주지 않는다&quot;라는 의미가 바람직한 곳에서도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50585be931797e352a16a31cff946364d2998523" translate="yes" xml:space="preserve">
          <source>. This construct is useful for optimizations of what would otherwise be &quot;eternal&quot; matches, because it will not backtrack (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). It may also be useful in places where the &quot;grab all you can, and do not give anything back&quot; semantic is desirable.</source>
          <target state="translated">. 이 구문은 역 추적하지 않기 때문에 &quot;영원한&quot;일치 항목을 최적화하는 데 유용합니다 ( &lt;a href=&quot;#Backtracking&quot;&gt;역 추적&lt;/a&gt; 참조 ). 또한 &quot;의미 할 수있는 모든 것을 잡아 내고 아무것도 돌려주지 않는&quot;의미가 바람직한 곳에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbb5bbf55288455005a9b2624554c934ac032cd" translate="yes" xml:space="preserve">
          <source>. This entered computer lingo via the paper &quot;On Holy Wars and a Plea for Peace&quot; by Danny Cohen, USC/ISI IEN 137, April 1, 1980.</source>
          <target state="translated">. 이것은 1980 년 4 월 1 일 USC / ISI IEN 137 대니 코헨 (Danny Cohen)의 &quot;성스러운 전쟁과 평화를위한기도&quot;라는 논문을 통해 컴퓨터 용어로 들어갔다.</target>
        </trans-unit>
        <trans-unit id="3809e0e62de48ea8f912fa229a3b1c19f17c36c5" translate="yes" xml:space="preserve">
          <source>. This file acts as both forward declaration of all package routines, and as timestamp for the last update of the hierarchy.</source>
          <target state="translated">. 이 파일은 모든 패키지 루틴의 순방향 선언 및 계층의 마지막 업데이트에 대한 타임 스탬프 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="47f0695b79e4a62f046bf4d6a56dc69b6e31a2b7" translate="yes" xml:space="preserve">
          <source>. This file resides somewhere deep in the location you installed your perl library, find it out by</source>
          <target state="translated">. 이 파일은 펄 라이브러리를 설치 한 위치의 어딘가에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2be3d4dab06ff8de1c3af65b87672a1f250c96" translate="yes" xml:space="preserve">
          <source>. This gives one an access to EMX's</source>
          <target state="translated">. 이를 통해 EMX에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="46aab4ac7dc98f7e211f64d569ae1ce3a7b4af8a" translate="yes" xml:space="preserve">
          <source>. This includes methods inherited or imported by &lt;code&gt;$obj&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; , or &lt;code&gt;VAL&lt;/code&gt; .</source>
          <target state="translated">. 여기에는 &lt;code&gt;$obj&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; 또는 &lt;code&gt;VAL&lt;/code&gt; 이 상속하거나 가져온 메소드가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fe493fe2df58e31314e35f753c63c8bcdf1f60d" translate="yes" xml:space="preserve">
          <source>. This includes methods inherited or imported by &lt;code&gt;$obj&lt;/code&gt;, &lt;code&gt;CLASS&lt;/code&gt;, or &lt;code&gt;VAL&lt;/code&gt;.</source>
          <target state="translated">. 여기에는 &lt;code&gt;$obj&lt;/code&gt; , &lt;code&gt;CLASS&lt;/code&gt; 또는 &lt;code&gt;VAL&lt;/code&gt; 에 의해 상속되거나 가져온 메서드가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="d85307dde9a09b32449c60a5313b98a5973ff2c7" translate="yes" xml:space="preserve">
          <source>. This is a private hash where every object is stored. An &quot;object&quot; in this sense is any reference (blessed or unblessed) that has been used as a field hash key.</source>
          <target state="translated">. 이것은 모든 객체가 저장되는 개인 해시입니다. 이러한 의미에서 &quot;객체&quot;는 필드 해시 키로 사용 된 참조 (축복 또는 비 축복)입니다.</target>
        </trans-unit>
        <trans-unit id="a2cdaa392edbf49e429fe1dc9214079db19f181c" translate="yes" xml:space="preserve">
          <source>. This is a special file already opened on the script, so that there can be no race condition for evil scripts to exploit. On these systems, Perl should be compiled with &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; . The</source>
          <target state="translated">. 이것은 스크립트에서 이미 열린 특수 파일이므로 악의적 인 스크립트가 악용 할 수있는 경쟁 조건이 없습니다. 이러한 시스템에서 Perl은 &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 로 컴파일해야합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="277b7f26027520f2ee1211a1e425554f6a4f4960" translate="yes" xml:space="preserve">
          <source>. This is a special file already opened on the script, so that there can be no race condition for evil scripts to exploit. On these systems, Perl should be compiled with &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt;. The</source>
          <target state="translated">. 이것은 스크립트에서 이미 열려있는 특수 파일이므로 악의적 인 스크립트가 악용 할 수있는 경쟁 조건이 없습니다. 이러한 시스템에서 Perl은 &lt;code&gt;-DSETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 로 컴파일되어야합니다 . 그만큼</target>
        </trans-unit>
        <trans-unit id="a2864f51e0809a4502605d91af0e78f8003a6b91" translate="yes" xml:space="preserve">
          <source>. This is because 66 code points will always be unassigned, and so the &lt;code&gt;Age&lt;/code&gt; for them is the Unicode version in which the decision to make them so was made. For example, &lt;code&gt;U+FDD0&lt;/code&gt; is to be permanently unassigned to a character, and the decision to do that was made in version 3.1, so &lt;code&gt;\p{Age=3.1}&lt;/code&gt; matches this character, as also does &lt;code&gt;\p{Present_In: 3.1}&lt;/code&gt; and up.</source>
          <target state="translated">. 이는 66 개의 코드 포인트가 항상 할당 해제되어 있기 때문에이를위한 &lt;code&gt;Age&lt;/code&gt; 는이를 결정하는 유니 코드 버전입니다. 예를 들어, &lt;code&gt;U+FDD0&lt;/code&gt; 은 문자에 영구적으로 할당 해제되며 버전 3.1에서 수행 된 결정은 &lt;code&gt;\p{Age=3.1}&lt;/code&gt; 이이 문자와 일치하며 &lt;code&gt;\p{Present_In: 3.1}&lt;/code&gt; 및 쪽으로.</target>
        </trans-unit>
        <trans-unit id="bdf07babd3552a309bc961c0381ffe7de7e8f022" translate="yes" xml:space="preserve">
          <source>. This is because the makefile by default sets the drive letter to</source>
          <target state="translated">. 기본적으로 makefile은 드라이브 문자를</target>
        </trans-unit>
        <trans-unit id="fc454fe001d6d36df58e092c61a2198720958a66" translate="yes" xml:space="preserve">
          <source>. This is because there is a conflict with a similarly-named file</source>
          <target state="translated">. 비슷한 이름의 파일과 충돌하기 때문입니다</target>
        </trans-unit>
        <trans-unit id="2a6af843b3f9c3758afa449207e6300ed8332e2a" translate="yes" xml:space="preserve">
          <source>. This is by design. If</source>
          <target state="translated">. 이것은 의도적으로 설계된 동작입니다. 만약</target>
        </trans-unit>
        <trans-unit id="93f5f59e9c411bf2b79d7d72c3b74942de22a532" translate="yes" xml:space="preserve">
          <source>. This is copied under the</source>
          <target state="translated">. 이것은 아래에 복사됩니다</target>
        </trans-unit>
        <trans-unit id="4dd3c68fa5c32e16e123eaa693e773f653650f36" translate="yes" xml:space="preserve">
          <source>. This is currently only supported for &lt;code&gt;GNU&lt;/code&gt; ld on &lt;code&gt;ELF&lt;/code&gt; in dynamic loading builds.</source>
          <target state="translated">. 이것은 현재 동적 로딩 빌드 에서 &lt;code&gt;ELF&lt;/code&gt; 의 &lt;code&gt;GNU&lt;/code&gt; ld에 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7af8025fe87d5aab31b7a47c749ea1a87fce0d6" translate="yes" xml:space="preserve">
          <source>. This is done at run-time, so is called dynamic scoping. local() always affects global variables, also called package variables or dynamic variables.</source>
          <target state="translated">. 이 작업은 런타임에 수행되므로 동적 범위 지정이라고합니다. local ()은 항상 전역 변수 (패키지 변수 또는 동적 변수라고도 함)에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4c25e02bad7d2cac773965d696d2c2a687ad78e4" translate="yes" xml:space="preserve">
          <source>. This is done from</source>
          <target state="translated">. 이것은에서 이루어집니다</target>
        </trans-unit>
        <trans-unit id="b27ee6639c423265aa7d8874b0268983c66fc9bf" translate="yes" xml:space="preserve">
          <source>. This is installed again by running &lt;code&gt;cpan Bundle::Snapshot_2012_05_21_00&lt;/code&gt; , or installing &lt;code&gt;Bundle::Snapshot_2012_05_21_00&lt;/code&gt; from the CPAN shell.</source>
          <target state="translated">. &lt;code&gt;cpan Bundle::Snapshot_2012_05_21_00&lt;/code&gt; 을 실행 하거나 CPAN 쉘에서 &lt;code&gt;Bundle::Snapshot_2012_05_21_00&lt;/code&gt; 을 설치 하여 다시 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="3823ddaf1238d01760d00a61d4a308fff63739d8" translate="yes" xml:space="preserve">
          <source>. This is normal and expected. (There is a conflict with a similarly-named file</source>
          <target state="translated">. 이것은 정상이며 예상됩니다. (유사한 이름의 파일과 충돌이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c655d0e38e80b9ecc3fca4e245f5ce10c2d9a2" translate="yes" xml:space="preserve">
          <source>. This is probably OK, as most perl scripts shipped with Solaris use an explicit path. (There are a few exceptions, such as</source>
          <target state="translated">. Solaris와 함께 제공되는 대부분의 perl 스크립트는 명시적인 경로를 사용하기 때문에 이것은 아마도 괜찮습니다. (예를 들어 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e883175469b1c783e8a78114606c2d561139be6" translate="yes" xml:space="preserve">
          <source>. This is rarely needed, as Perl manages its memory quite well. But the option exists, should a class wish to perform specific actions upon the destruction of an instance.</source>
          <target state="translated">. Perl이 메모리를 잘 관리하기 때문에 이것은 거의 필요하지 않습니다. 그러나 클래스가 인스턴스 파괴시 특정 조치를 수행하려는 경우 옵션이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="333093d5d5321fc34ce46ed78526668442668aef" translate="yes" xml:space="preserve">
          <source>. This is similar to &lt;code&gt;sv_2mortal&lt;/code&gt; in that it is also a mechanism for doing a delayed &lt;code&gt;SvREFCNT_dec&lt;/code&gt; . However, while &lt;code&gt;sv_2mortal&lt;/code&gt; extends the lifetime of &lt;code&gt;sv&lt;/code&gt; until the beginning of the next statement, &lt;code&gt;SAVEFREESV&lt;/code&gt; extends it until the end of the enclosing scope. These lifetimes can be wildly different.</source>
          <target state="translated">. 이것은 지연된 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 을 수행하기위한 메커니즘이라는 점에서 &lt;code&gt;sv_2mortal&lt;/code&gt; 과 유사합니다 . 반면 그러나 &lt;code&gt;sv_2mortal&lt;/code&gt; 가 의 수명 연장 &lt;code&gt;sv&lt;/code&gt; 다음 문장의 시작 부분까지 &lt;code&gt;SAVEFREESV&lt;/code&gt; 는 바깥 쪽 범위의 끝 부분까지 확장합니다. 이 수명은 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f23d830008007d5d457a01dc89576f19b1a675" translate="yes" xml:space="preserve">
          <source>. This is similar to &lt;code&gt;sv_2mortal&lt;/code&gt; in that it is also a mechanism for doing a delayed &lt;code&gt;SvREFCNT_dec&lt;/code&gt;. However, while &lt;code&gt;sv_2mortal&lt;/code&gt; extends the lifetime of &lt;code&gt;sv&lt;/code&gt; until the beginning of the next statement, &lt;code&gt;SAVEFREESV&lt;/code&gt; extends it until the end of the enclosing scope. These lifetimes can be wildly different.</source>
          <target state="translated">. 이는 지연된 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 을 수행하기위한 메커니즘이라는 점에서 &lt;code&gt;sv_2mortal&lt;/code&gt; 과 유사합니다 . 반면 그러나 &lt;code&gt;sv_2mortal&lt;/code&gt; 가 의 수명 연장 &lt;code&gt;sv&lt;/code&gt; 다음 문장의 시작 부분까지 &lt;code&gt;SAVEFREESV&lt;/code&gt; 는 바깥 쪽 범위의 끝 부분까지 확장합니다. 이러한 수명은 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6926c3ac4d7edc58bc3ea380b4d2d54d9f28838f" translate="yes" xml:space="preserve">
          <source>. This macro evaluates its arguments more than once. If you are using &lt;code&gt;Perl_custom_op_xop&lt;/code&gt; to retreive a &lt;code&gt;XOP *&lt;/code&gt; from a &lt;code&gt;OP *&lt;/code&gt; , use the more efficient &lt;a href=&quot;#XopENTRYCUSTOM&quot;&gt;XopENTRYCUSTOM&lt;/a&gt; instead.</source>
          <target state="translated">. 이 매크로는 인수를 두 번 이상 평가합니다. &lt;code&gt;Perl_custom_op_xop&lt;/code&gt; 를 사용하여 &lt;code&gt;OP *&lt;/code&gt; 에서 &lt;code&gt;XOP *&lt;/code&gt; 를 검색하는 경우보다 효율적인 &lt;a href=&quot;#XopENTRYCUSTOM&quot;&gt;XopENTRYCUSTOM을&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca414c709e1a90a43e4a8b465a788e53c69235fb" translate="yes" xml:space="preserve">
          <source>. This may be useful e.g., if you need to run the installer many times and do not want to make many interactive changes in the GUI.</source>
          <target state="translated">. 예를 들어 설치 프로그램을 여러 번 실행해야하고 GUI에서 많은 대화식 변경을 원하지 않는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3776f3fabf7ab606cceb1e6f3f63ecb05da2010" translate="yes" xml:space="preserve">
          <source>. This means that if you have already detected the error by checking &lt;code&gt;$@&lt;/code&gt; and you want the program to continue, you must remember to pop the</source>
          <target state="translated">. 즉, &lt;code&gt;$@&lt;/code&gt; 를 확인하여 이미 오류를 감지 하고 프로그램을 계속하려면 프로그램을 계속 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2c905e3737670dc0a16e9b65486ea71a8080a95" translate="yes" xml:space="preserve">
          <source>. This means that in &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x = 1 + $x&lt;/code&gt; the second $x refers to one declared previously.</source>
          <target state="translated">. 이것은 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $x = 1 + $x&lt;/code&gt; 에서 두 번째 $ x는 이전에 선언 된 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="616674a02842b0e140325ccd23516cf1139a3c4a" translate="yes" xml:space="preserve">
          <source>. This means that in &lt;code&gt;my $x = 1 + $x&lt;/code&gt; the second $x refers to one declared previously.</source>
          <target state="translated">. 이것은 &lt;code&gt;my $x = 1 + $x&lt;/code&gt; 에서 두 번째 $ x가 이전에 선언 된 것을 참조한다는 것을 의미합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
