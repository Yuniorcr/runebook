<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8f1fcfbd88c7e47c13102ec9e5c6df21938df7a0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcpy&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">사용 가능한 경우 C 라이브러리 &lt;code&gt;strlcpy&lt;/code&gt; 또는 Perl 구현. 이것은 C &lt;code&gt;NUL&lt;/code&gt; 종료 문자열 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="adfc233e0a4f97350cc2e4aa535e9be9b6e383b2" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcpy&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt;-terminated strings.</source>
          <target state="translated">사용 가능한 경우 C 라이브러리 &lt;code&gt;strlcpy&lt;/code&gt; 또는 Perl 구현. 이것은 C &lt;code&gt;NUL&lt;/code&gt; 로 끝나는 문자열 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cab5c54be21dba3cacbe9ed00d0ba0253e4100fa" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strnlen&lt;/code&gt; if available, or a Perl implementation of it.</source>
          <target state="translated">사용 가능한 경우 C 라이브러리 &lt;code&gt;strnlen&lt;/code&gt; 또는 Perl 구현입니다.</target>
        </trans-unit>
        <trans-unit id="6e368fd4b911113fa139d4b324c13f128de90489" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;vsnprintf&lt;/code&gt; if available and standards-compliant. However, if if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">사용 가능하고 표준을 준수하는 경우 C 라이브러리 &lt;code&gt;vsnprintf&lt;/code&gt; . 그러나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 사용할 수없는 경우 불행히도 안전하지 않은 &lt;code&gt;vsprintf&lt;/code&gt; 를 사용 하여 버퍼를 오버런 할 수 있습니다 (오버런 검사가 있지만 너무 늦을 수 있음). 대신 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 를 사용하거나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 얻는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="46595b1731ae551daffc30fb89bb115ed53699c0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;vsnprintf&lt;/code&gt; if available and standards-compliant. However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt;.</source>
          <target state="translated">사용할 수 있고 표준을 준수하는 경우 C 라이브러리 &lt;code&gt;vsnprintf&lt;/code&gt; . 그러나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 사용할 수없는 경우 불행히도 버퍼를 오버런 할 수 있는 안전하지 않은 &lt;code&gt;vsprintf&lt;/code&gt; 를 사용합니다 (오버런 검사가 있지만 너무 늦을 수 있음). 대신 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 를 사용하거나 &lt;code&gt;vsnprintf&lt;/code&gt; 를 가져 오는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="5183e1e6aa36fa93c903a6e7e44a0cb72c213922" translate="yes" xml:space="preserve">
          <source>The C library routines listed in the table below return values based on the current locale. Use the entries in the final column for that functionality. The other two columns always assume a POSIX (or C) locale. The entries in the ASCII column are only meaningful for ASCII inputs, returning FALSE for anything else. Use these only when you &lt;b&gt;know&lt;/b&gt; that is what you want. The entries in the Latin1 column assume that the non-ASCII 8-bit characters are as Unicode defines, them, the same as ISO-8859-1, often called Latin 1.</source>
          <target state="translated">아래 표에 나열된 C 라이브러리 루틴은 현재 로케일을 기반으로 값을 리턴합니다. 해당 기능의 마지막 열에있는 항목을 사용하십시오. 다른 두 열은 항상 POSIX (또는 C) 로캘을 가정합니다. ASCII 열의 항목은 ASCII 입력에만 의미가 있으며 다른 항목에는 FALSE를 반환합니다. 원하는 것을 &lt;b&gt;알고&lt;/b&gt; 있을 때만 사용하십시오 . Latin1 열의 항목은 ASCII가 아닌 8 비트 문자가 유니 코드로 정의 된 것으로 간주되며 ISO-8859-1과 동일하며 종종 라틴어 1이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a28b4e51a54be7620c06b31ca4a6442c8879a612" translate="yes" xml:space="preserve">
          <source>The C pre-processor macro to use in the &lt;code&gt;#ifdef&lt;/code&gt; . This defaults to the</source>
          <target state="translated">ㄴ 프리 프로세서 매크로에 사용 &lt;code&gt;#ifdef&lt;/code&gt; 와 . 기본값은</target>
        </trans-unit>
        <trans-unit id="16943aac47982cbf30a645b09367e6342a703549" translate="yes" xml:space="preserve">
          <source>The C pre-processor macro to use in the &lt;code&gt;#ifdef&lt;/code&gt;. This defaults to the</source>
          <target state="translated">&lt;code&gt;#ifdef&lt;/code&gt; 에서 사용할 C 전 처리기 매크로 입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="e289a8cac4c6625ed2e896b05f021cd0b663f2cc" translate="yes" xml:space="preserve">
          <source>The C signature of the corresponding function should be</source>
          <target state="translated">해당 함수의 C 서명은</target>
        </trans-unit>
        <trans-unit id="434fa80b2289a7e8297f9f4dbd629257d6d523b1" translate="yes" xml:space="preserve">
          <source>The C source code and header files mostly live in the root of the source tree. There are a few platform-specific directories which contain C code. In addition, some of the modules shipped with Perl include C or XS code.</source>
          <target state="translated">C 소스 코드와 헤더 파일은 대부분 소스 트리의 루트에 있습니다. C 코드가 포함 된 플랫폼 별 디렉토리가 몇 가지 있습니다. 또한 Perl과 함께 제공되는 일부 모듈에는 C 또는 XS 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="128905b571f66231b1c910d09a2688b981aad8fb" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, but not a function that is affected by its contents. (Those with experience of standards committees will recognize that the working group decided to punt on the issue.) Consequently, Perl essentially takes no notice of it. If you really want to use &lt;code&gt;LC_MONETARY&lt;/code&gt; , you can query its contents--see &lt;a href=&quot;#The-localeconv-function&quot;&gt;The localeconv function&lt;/a&gt;--and use the information that it returns in your application's own formatting of currency amounts. However, you may well find that the information, voluminous and complex though it may be, still does not quite meet your requirements: currency formatting is a hard nut to crack.</source>
          <target state="translated">C 표준은 &lt;code&gt;LC_MONETARY&lt;/code&gt; 범주를 정의 하지만 그 내용에 영향을받는 함수는 아닙니다. (표준위원회의 경험이있는 사람들은 실무 그룹이이 문제를 해결하기로 결정했다는 것을 알게 될 것입니다.) 따라서 Perl은 본질적으로이를 인식하지 않습니다. &lt;code&gt;LC_MONETARY&lt;/code&gt; 를 실제로 사용하려면 내용을 쿼리하고 &lt;a href=&quot;#The-localeconv-function&quot;&gt;(localeconv 함수&lt;/a&gt; 참조) , 응용 프로그램 자체의 통화 금액 형식으로 반환되는 정보를 사용할 수 있습니다. 그러나 볼륨이 크고 복잡한 정보가 여전히 요구 사항을 충족하지 못하는 경우가 있습니다. 통화 형식화는 까다로울 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af9aa0541964b8be462404f9104ffc6a9724f799" translate="yes" xml:space="preserve">
          <source>The C standard defines the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, but not a function that is affected by its contents. (Those with experience of standards committees will recognize that the working group decided to punt on the issue.) Consequently, Perl essentially takes no notice of it. If you really want to use &lt;code&gt;LC_MONETARY&lt;/code&gt;, you can query its contents--see &lt;a href=&quot;#The-localeconv-function&quot;&gt;&quot;The localeconv function&quot;&lt;/a&gt;--and use the information that it returns in your application's own formatting of currency amounts. However, you may well find that the information, voluminous and complex though it may be, still does not quite meet your requirements: currency formatting is a hard nut to crack.</source>
          <target state="translated">C 표준은 &lt;code&gt;LC_MONETARY&lt;/code&gt; 범주를 정의 하지만 그 내용의 영향을받는 함수 는 정의 하지 않습니다. (표준위원회의 경험이있는 사람들은 실무 그룹이이 문제를 해결하기로 결정했음을 인식 할 것입니다.) 따라서 Perl은 본질적으로이 문제에 대해 알지 못합니다. &lt;code&gt;LC_MONETARY&lt;/code&gt; 를 실제로 사용하려면 내용을 쿼리하고 ( &lt;a href=&quot;#The-localeconv-function&quot;&gt;&quot;localeconv 함수&quot;&lt;/a&gt; 참조) 응용 프로그램 자체의 통화 금액 형식으로 반환되는 정보를 사용할 수 있습니다. 그러나 방대하고 복잡한 정보가 여전히 귀하의 요구 사항을 충족하지 못한다는 것을 알 수 있습니다. 통화 형식은 깨지기 어려운 너트입니다.</target>
        </trans-unit>
        <trans-unit id="9998f45e4c7233897bbe30273f117556d7539b74" translate="yes" xml:space="preserve">
          <source>The C structures used by Perl's internals to hold SV and OP information (PVIV, AV, HV, ..., OP, SVOP, UNOP, ...) are modelled on a class hierarchy and the &lt;code&gt;B&lt;/code&gt; module gives access to them via a true object hierarchy. Structure fields which point to other objects (whether types of SV or types of OP) are represented by the &lt;code&gt;B&lt;/code&gt; module as Perl objects of the appropriate class.</source>
          <target state="translated">SV 및 OP 정보 (PVIV, AV, HV, ..., OP, SVOP, UNOP 등)를 보유하기 위해 Perl의 내부에서 사용하는 C 구조는 클래스 계층 구조로 모델링되며 &lt;code&gt;B&lt;/code&gt; 모듈은 진정한 객체 계층. 다른 객체 (SV 유형 또는 OP 유형)를 가리키는 구조 필드는 &lt;code&gt;B&lt;/code&gt; 모듈에 의해 적절한 클래스의 Perl 객체로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e52cd1f128c9fdf3705990415e2a1725ce8c0daa" translate="yes" xml:space="preserve">
          <source>The C style for loop is rarely needed in Perl since Perl provides the more friendly list scanning &lt;code&gt;foreach&lt;/code&gt; loop.</source>
          <target state="translated">펄이 더 친화적 목록 스캔 제공하기 때문에 루프에 대한 C 스타일은 거의 펄에 필요하지 않습니다 &lt;code&gt;foreach&lt;/code&gt; 는 루프를.</target>
        </trans-unit>
        <trans-unit id="382f2022a70422666dd407272ac00165cb46d80c" translate="yes" xml:space="preserve">
          <source>The C variable that roughly corresponds to Perl's &lt;code&gt;$^W&lt;/code&gt; warning variable. However, &lt;code&gt;$^W&lt;/code&gt; is treated as a boolean, whereas &lt;code&gt;PL_dowarn&lt;/code&gt; is a collection of flag bits.</source>
          <target state="translated">대략 Perl의 &lt;code&gt;$^W&lt;/code&gt; 경고 변수에 해당하는 C 변수입니다 . 그러나 &lt;code&gt;$^W&lt;/code&gt; 는 부울로 처리되는 반면 &lt;code&gt;PL_dowarn&lt;/code&gt; 은 플래그 비트 모음입니다.</target>
        </trans-unit>
        <trans-unit id="41766adf1b20a48cee72fe6667e88ebc85cdc6f9" translate="yes" xml:space="preserve">
          <source>The C variable which corresponds to Perl's $^W warning variable.</source>
          <target state="translated">Perl의 $ ^ W 경고 변수에 해당하는 C 변수.</target>
        </trans-unit>
        <trans-unit id="dfa119354e27d0075a95b6198dbb34324da3f2fb" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is returned in</source>
          <target state="translated">C 레벨 함수 포인터는</target>
        </trans-unit>
        <trans-unit id="3ad2fed6645c9945d396d554659d98d3cd78d956" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is returned in &lt;code&gt;*ckfun_p&lt;/code&gt;, an SV argument for it is returned in &lt;code&gt;*ckobj_p&lt;/code&gt;, and control flags are returned in &lt;code&gt;*ckflags_p&lt;/code&gt;. The function is intended to be called in this manner:</source>
          <target state="translated">C 수준 함수 포인터는 &lt;code&gt;*ckfun_p&lt;/code&gt; 에서 반환되고 , SV 인수는 &lt;code&gt;*ckobj_p&lt;/code&gt; 에서 반환되고 , 제어 플래그는 &lt;code&gt;*ckflags_p&lt;/code&gt; 에서 반환됩니다 . 이 함수는 다음과 같은 방식으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="230e53618d509a745420dd7ed8f916298cb8a1f6" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is supplied in</source>
          <target state="translated">C 레벨 함수 포인터는</target>
        </trans-unit>
        <trans-unit id="6f125bb636ce0697387ef54d892359a73430d202" translate="yes" xml:space="preserve">
          <source>The C-level function pointer is supplied in &lt;code&gt;ckfun&lt;/code&gt;, an SV argument for it is supplied in &lt;code&gt;ckobj&lt;/code&gt;, and control flags are supplied in &lt;code&gt;ckflags&lt;/code&gt;. The function should be defined like this:</source>
          <target state="translated">C 레벨 함수 포인터는 &lt;code&gt;ckfun&lt;/code&gt; 에 제공되고 , 이에 대한 SV 인수는 &lt;code&gt;ckobj&lt;/code&gt; 에 제공되며 제어 플래그는 &lt;code&gt;ckflags&lt;/code&gt; 에 제공됩니다 . 함수는 다음과 같이 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1e1b0aeffa7ba38a3388c23b72c5a0f47c58d0b1" translate="yes" xml:space="preserve">
          <source>The C3 MRO</source>
          <target state="translated">C3 MRO</target>
        </trans-unit>
        <trans-unit id="0890f76e297e8a69278390e1b8b2216c138a276e" translate="yes" xml:space="preserve">
          <source>The C3 order also lets you call methods in sibling classes with the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; pseudo-class. See the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; documentation for more details on this feature.</source>
          <target state="translated">C3 순서를 사용하면 형제 클래스에서 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 의사. 이 기능에 대한 자세한 내용은&lt;a href=&quot;mro&quot;&gt; mro&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4dbcf2bc02f3e4b62f070fa8eb1a0e88af1ee01d" translate="yes" xml:space="preserve">
          <source>The C3 order also lets you call methods in sibling classes with the &lt;code&gt;next&lt;/code&gt; pseudo-class. See the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; documentation for more details on this feature.</source>
          <target state="translated">C3 순서를 사용하면 &lt;code&gt;next&lt;/code&gt; 의사 클래스와 함께 형제 클래스의 메서드를 호출 할 수도 있습니다 . 이 기능에 대한 자세한 내용 은 &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0ff2a087cbd21d4354452514069e5aa62203f63" translate="yes" xml:space="preserve">
          <source>The CASE: Keyword</source>
          <target state="translated">사례 : 키워드</target>
        </trans-unit>
        <trans-unit id="c34759e310ffd05ba41a3c6d9e4717368401e66b" translate="yes" xml:space="preserve">
          <source>The CASE: keyword allows an XSUB to have multiple distinct parts with each part acting as a virtual XSUB. CASE: is greedy and if it is used then all other XS keywords must be contained within a CASE:. This means nothing may precede the first CASE: in the XSUB and anything following the last CASE: is included in that case.</source>
          <target state="translated">CASE : 키워드를 사용하면 XSUB가 각 부분이 가상 XSUB 역할을하는 여러 개의 개별 부분을 가질 수 있습니다. CASE :는 욕심이 많으며 사용되는 경우 다른 모든 XS 키워드는 CASE :에 포함되어야합니다. 즉, XSUB에서 첫 번째 CASE 앞에는 아무것도 없으며 마지막 CASE : 뒤에 오는 것은 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fae674d05cdd7c7c93ed58176b2c5091862f5184" translate="yes" xml:space="preserve">
          <source>The CLEANUP: Keyword</source>
          <target state="translated">정리 : 키워드</target>
        </trans-unit>
        <trans-unit id="241f3ed896c795a2f153c574bd096719fc549cce" translate="yes" xml:space="preserve">
          <source>The CODE: Keyword</source>
          <target state="translated">코드 : 키워드</target>
        </trans-unit>
        <trans-unit id="75462a30b7eda0a1256e9e78d46c9b66a39ca496" translate="yes" xml:space="preserve">
          <source>The CODEHASHREF is a reference to a hash containing names as keys and either a string to eval or a code reference for each value. For each (KEY, VALUE) pair in the CODEHASHREF, this routine will call</source>
          <target state="translated">CODEHASHREF는 이름을 키로 포함하고 해시 할 문자열 또는 각 값에 대한 코드 참조를 포함하는 해시에 대한 참조입니다. CODEHASHREF의 각 (KEY, VALUE) 쌍에 대해이 루틴은</target>
        </trans-unit>
        <trans-unit id="2d375a6aa9b8906ba2ffceffe206a677c43a7349" translate="yes" xml:space="preserve">
          <source>The COP's hint flags, rendered with abbreviated names if possible. An empty string if this is not a COP. Here are the symbols used:</source>
          <target state="translated">가능한 경우 약어 이름으로 렌더링 된 COP의 힌트 플래그입니다. COP가 아닌 경우 빈 문자열입니다. 사용 된 기호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1edd5ccb6f317807268c4d710f3579aef8a9d833" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative, see timethis().</source>
          <target state="translated">COUNT는 0이거나 음수 일 수 있습니다. timethis ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7abd867e28669bc36a83d10cc2868dd307bb204" translate="yes" xml:space="preserve">
          <source>The COUNT can be zero or negative: this means the</source>
          <target state="translated">COUNT는 0 또는 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc832b0eb6220d0a76bc73b579ab0cb465685a6c" translate="yes" xml:space="preserve">
          <source>The CPAN Meta Spec has gone through several iterations. It was originally written in HTML and later revised into POD (though published in HTML generated from the POD). Fields were added, removed or changed, sometimes by design and sometimes to reflect real-world usage after the fact.</source>
          <target state="translated">CPAN 메타 스펙은 여러 번의 반복을 거쳤습니다. 원래 HTML로 작성되었고 나중에 POD로 수정되었습니다 (POD에서 생성 된 HTML로 게시되었지만). 필드는 때때로 디자인에 의해 추가, 제거 또는 변경되었으며, 때로는 사실 이후의 실제 사용을 반영하기도했습니다.</target>
        </trans-unit>
        <trans-unit id="7180933318067029f5e634690ac1d29792da70f9" translate="yes" xml:space="preserve">
          <source>The CPAN indexes are usually rebuilt once or twice per hour, but the typical CPAN mirror mirrors only once or twice per day. Depending on the quality of your mirror and your desire to be on the bleeding edge, you may want to set the following value to more or less than one day (which is the default). It determines after how many days CPAN.pm downloads new indexes.</source>
          <target state="translated">CPAN 인덱스는 일반적으로 시간당 한두 번 다시 작성되지만 일반적인 CPAN 미러는 하루에 한두 번만 미러링됩니다. 거울의 품질과 블리딩 엣지에 대한 욕구에 따라 다음 값을 하루 이상 (기본값)으로 설정할 수 있습니다. CPAN.pm이 새 인덱스를 다운로드하는 일 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a6abdf8e3ad6e66f818dbdbca4035e50c50fcaeb" translate="yes" xml:space="preserve">
          <source>The CPAN module &lt;a href=&quot;Term::ExtendedColor&quot;&gt;Term::ExtendedColor&lt;/a&gt; provides a different and more comprehensive interface for 256-color emulators that may be more convenient. The CPAN module &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; provides ANSI color (and other escape sequence) support in the Win32 Console environment. The CPAN module &lt;a href=&quot;Term::Chrome&quot;&gt;Term::Chrome&lt;/a&gt; provides a different interface using objects and operator overloading.</source>
          <target state="translated">CPAN 모듈 &lt;a href=&quot;Term::ExtendedColor&quot;&gt;Term :: ExtendedColor&lt;/a&gt; 는보다 편리 할 수있는 256 색 에뮬레이터를위한보다 포괄적 인 인터페이스를 제공합니다. CPAN 모듈 &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt; 는 Win32 콘솔 환경에서 ANSI 색상 (및 기타 이스케이프 시퀀스) 지원을 제공합니다. CPAN 모듈 &lt;a href=&quot;Term::Chrome&quot;&gt;Term :: Chrome&lt;/a&gt; 은 객체 및 연산자 오버로딩을 사용하여 다른 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="377d91db5cfe6b5bd06da1ed353fc316766187b9" translate="yes" xml:space="preserve">
          <source>The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term::ExtendedColor&lt;/a&gt; provides a different and more comprehensive interface for 256-color emulators that may be more convenient. The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; provides ANSI color (and other escape sequence) support in the Win32 Console environment.</source>
          <target state="translated">CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ExtendedColor&quot;&gt;Term :: ExtendedColor&lt;/a&gt; 는보다 편리한 256 색 에뮬레이터를위한 다양하고 포괄적 인 인터페이스를 제공합니다. CPAN 모듈 &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt; 는 Win32 콘솔 환경에서 ANSI 색상 (및 기타 이스케이프 시퀀스)을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d6b4425af9b4e8fb2b471139f3e26220141f7951" translate="yes" xml:space="preserve">
          <source>The CPAN module also supports named and versioned</source>
          <target state="translated">CPAN 모듈은 또한 명명 및 버전 관리를 지원합니다</target>
        </trans-unit>
        <trans-unit id="0c026574d1a86a555bc568a8cb4ff270316b96bc" translate="yes" xml:space="preserve">
          <source>The CPAN module automates or at least simplifies the make and install of perl modules and extensions. It includes some primitive searching capabilities and knows how to use LWP, HTTP::Tiny, Net::FTP and certain external download clients to fetch distributions from the net.</source>
          <target state="translated">CPAN 모듈은 perl 모듈 및 확장의 작성 및 설치를 자동화하거나 최소한 단순화합니다. 여기에는 기본 검색 기능이 포함되어 있으며 LWP, HTTP :: Tiny, Net :: FTP 및 특정 외부 다운로드 클라이언트를 사용하여 인터넷에서 배포를 가져 오는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e178ebb5191d2f8095d21912890034971c23f17" translate="yes" xml:space="preserve">
          <source>The CPAN module can detect when a module which you are trying to build depends on prerequisites. If this happens, it can build the prerequisites for you automatically ('follow'), ask you for confirmation ('ask'), or just ignore them ('ignore'). Choosing 'follow' also sets PERL_AUTOINSTALL and PERL_EXTUTILS_AUTOINSTALL for &quot;--defaultdeps&quot; if not already set.</source>
          <target state="translated">CPAN 모듈은 빌드하려는 모듈이 전제 조건에 따라 달라지는시기를 감지 할 수 있습니다. 이 경우 자동으로 전제 조건을 구축하거나 ( '따라') 확인을 요청하거나 ( '요청') 무시 만하면됩니다 ( '무시'). 'follow'를 선택하면 아직 설정되지 않은 경우 PERL_AUTOINSTALL 및 PERL_EXTUTILS_AUTOINSTALL이 &quot;--defaultdeps&quot;로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6c6573c37a2e4b0e2c1f6ecf5ee527de52c79b5e" translate="yes" xml:space="preserve">
          <source>The CPAN program is trying to depend on as little as possible so the user can use it in hostile environment. It works better the more goodies the environment provides. For example if you try in the CPAN shell</source>
          <target state="translated">CPAN 프로그램은 사용자가 적대적인 환경에서 사용할 수 있도록 가능한 한 적게 의존하려고합니다. 환경이 제공하는 혜택이 많을수록 더 잘 작동합니다. 예를 들어 CPAN 쉘에서 시도하는 경우</target>
        </trans-unit>
        <trans-unit id="2a9104a5899c9b5ddc878450acd02185c2e99e32" translate="yes" xml:space="preserve">
          <source>The CPAN shell can watch the &lt;code&gt;blib/&lt;/code&gt; directories that are built up before running &lt;code&gt;make test&lt;/code&gt; to determine whether the current distribution contains modules that are indexed with a distro with a higher distro-version number than the current one. It can then let the build of this distro fail when it would not represent the most up-to-date version of the distro.</source>
          <target state="translated">CPAN 쉘은 &lt;code&gt;make test&lt;/code&gt; 를 실행하기 전에 빌드 된 &lt;code&gt;blib/&lt;/code&gt; 디렉토리를 감시하여 현재 배포판에 현재 배포판 번호가 더 높은 배포판으로 인덱싱 된 모듈이 있는지 확인할 수 있습니다. 그런 다음이 배포판의 빌드가 최신 버전의 배포판을 나타내지 않을 때 실패하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3c16b6783c8485510b294bb4614459cd02562de" translate="yes" xml:space="preserve">
          <source>The CPAN shell can watch the &lt;code&gt;blib/&lt;/code&gt; directories that are built up before running &lt;code&gt;make test&lt;/code&gt; to determine whether the current distribution will end up with modules being overwritten with decreasing module version numbers. It can then let the build of this distro fail when it discovers a downgrade.</source>
          <target state="translated">CPAN 쉘은 &lt;code&gt;make test&lt;/code&gt; 를 실행하기 전에 빌드 된 &lt;code&gt;blib/&lt;/code&gt; 디렉토리를 감시하여 현재 배포판이 모듈 버전 번호가 감소하는 것으로 덮어 쓰여지는 모듈로 끝나는 지 여부를 결정할 수 있습니다. 그런 다음 다운 그레이드를 발견하면이 배포판의 빌드가 실패하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2553ac7849cb5bbcba314a404bb8ec936977f23" translate="yes" xml:space="preserve">
          <source>The CPAN testers ( &lt;a href=&quot;http://cpantesters.org/&quot;&gt;http://cpantesters.org/&lt;/a&gt; ) are a group of volunteers who test CPAN modules on a variety of platforms.</source>
          <target state="translated">CPAN 테스터 ( &lt;a href=&quot;http://cpantesters.org/&quot;&gt;http://cpantesters.org/&lt;/a&gt; )는 다양한 플랫폼에서 CPAN 모듈을 테스트하는 자원 봉사자 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="85d1aee245c3b6a287276d71fb8b02358e6086ca" translate="yes" xml:space="preserve">
          <source>The CPAN testers ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; ) are a group of volunteers who test CPAN modules on a variety of platforms.</source>
          <target state="translated">CPAN 테스터 ( &lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt; )는 다양한 플랫폼에서 CPAN 모듈을 테스트하는 자원 봉사자 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="e02636a6cb280626a26310497466ab4002dc994b" translate="yes" xml:space="preserve">
          <source>The CRC32 and ISIZE trailer fields must be present.</source>
          <target state="translated">CRC32 및 ISIZE 트레일러 필드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="188c40af9bea4d196bff4ce74cfb4e6b4de81eff" translate="yes" xml:space="preserve">
          <source>The CV also has to have a reference count on the slab. Sometimes the first op created is immediately freed. If the reference count of the slab reaches 0, then it will be freed with the CV still pointing to it.</source>
          <target state="translated">CV에는 슬래브에 대한 참조 횟수도 있어야합니다. 때로는 생성 된 첫 번째 작업이 즉시 해제됩니다. 슬래브의 참조 횟수가 0에 도달하면 CV가 여전히 가리키는 상태로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9feb874c73b191dd9599e9b2017419a0da4abb3d" translate="yes" xml:space="preserve">
          <source>The C_ARGS: Keyword</source>
          <target state="translated">C_ARGS : 키워드</target>
        </trans-unit>
        <trans-unit id="701e155d0ecdee0723938fe9c7bf1396f627436a" translate="yes" xml:space="preserve">
          <source>The C_ARGS: keyword allows creating of XSUBS which have different calling sequence from Perl than from C, without a need to write CODE: or PPCODE: section. The contents of the C_ARGS: paragraph is put as the argument to the called C function without any change.</source>
          <target state="translated">C_ARGS : 키워드를 사용하면 CODE : 또는 PPCODE : 섹션을 작성할 필요없이 Perl과 다른 호출 순서를 갖는 XSUBS를 작성할 수 있습니다. C_ARGS : 단락의 내용은 변경없이 호출 된 C 함수의 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd34313e432c589bd3beca248664e04fa335c40" translate="yes" xml:space="preserve">
          <source>The Carp module first appeared in Larry Wall's perl 5.000 distribution. Since then it has been modified by several of the perl 5 porters. Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt; divested Carp into an independent distribution.</source>
          <target state="translated">잉어 모듈은 Larry Wall의 perl 5.000 배포판에 처음 등장했습니다. 그 이후로 여러 perl 5 포터에 의해 수정되었습니다. Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;는 잉어를 독립된 배포판에 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="73aa54f605c75d537db25ae13f844b387570066b" translate="yes" xml:space="preserve">
          <source>The Carp routines are useful in your own modules because they act like &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt;, but with a message which is more likely to be useful to a user of your module. In the case of &lt;code&gt;cluck()&lt;/code&gt; and &lt;code&gt;confess()&lt;/code&gt; , that context is a summary of every call in the call-stack; &lt;code&gt;longmess()&lt;/code&gt; returns the contents of the error message.</source>
          <target state="translated">Carp 루틴은 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 과 같이 작동 하지만 모듈 사용자에게 유용 할 수있는 메시지가 있으므로 자신의 모듈에서 유용합니다. 의 경우 &lt;code&gt;cluck()&lt;/code&gt; 와 &lt;code&gt;confess()&lt;/code&gt; , 즉 컨텍스트 호출 스택에있는 모든 통화의 요약이며; &lt;code&gt;longmess()&lt;/code&gt; 는 오류 메시지의 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9cbfa4d50460beab14f143ba0a90c72ae59001f" translate="yes" xml:space="preserve">
          <source>The Carp routines are useful in your own modules because they act like &lt;code&gt;die()&lt;/code&gt; or &lt;code&gt;warn()&lt;/code&gt;, but with a message which is more likely to be useful to a user of your module. In the case of &lt;code&gt;cluck()&lt;/code&gt; and &lt;code&gt;confess()&lt;/code&gt;, that context is a summary of every call in the call-stack; &lt;code&gt;longmess()&lt;/code&gt; returns the contents of the error message.</source>
          <target state="translated">Carp 루틴은 &lt;code&gt;die()&lt;/code&gt; 또는 &lt;code&gt;warn()&lt;/code&gt; 처럼 작동하기 때문에 자신의 모듈에서 유용 하지만 모듈 사용자에게 더 유용 할 것 같은 메시지가 있습니다. 의 경우 &lt;code&gt;cluck()&lt;/code&gt; 와 &lt;code&gt;confess()&lt;/code&gt; , 즉 컨텍스트 호출 스택에있는 모든 통화의 요약이며; &lt;code&gt;longmess()&lt;/code&gt; 는 오류 메시지의 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a9dcee0d40bd7f4aac08fafa5945185600a2589" translate="yes" xml:space="preserve">
          <source>The Carp routines don't handle exception objects currently. If called with a first argument that is a reference, they simply call die() or warn(), as appropriate.</source>
          <target state="translated">잉어 루틴은 현재 예외 객체를 처리하지 않습니다. 참조 인 첫 번째 인수로 호출 된 경우, 적절하게 die () 또는 warn ()을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f74ecb659d2dae844024a2a7edc2eb73241a6948" translate="yes" xml:space="preserve">
          <source>The Color Stack</source>
          <target state="translated">컬러 스택</target>
        </trans-unit>
        <trans-unit id="0e751c2cd8e75382ca856116ff4097eafeafab18" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network (CPAN) offers a wealth of extensions, some of which require a C compiler to build. Look in &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; for more information on CPAN.</source>
          <target state="translated">CPAN (Comprehensive Perl Archive Network)은 다양한 확장 기능을 제공하며,이 중 일부는 빌드하려면 C 컴파일러가 필요합니다. CPAN에 대한 자세한 내용 은 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9b8c2d3c4428a91048a1d4feac51e61b6c58906" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network (CPAN) offers a wealth of extensions, some of which require a C compiler to build. Look in &lt;a href=&quot;https://www.cpan.org/&quot;&gt;https://www.cpan.org/&lt;/a&gt; for more information on CPAN.</source>
          <target state="translated">CPAN (Comprehensive Perl Archive Network)은 다양한 확장 기능을 제공하며, 그중 일부는 빌드하는 데 C 컴파일러가 필요합니다. CPAN에 대한 자세한 내용 은 &lt;a href=&quot;https://www.cpan.org/&quot;&gt;https://www.cpan.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a3290ed25612a4eaac36507c34578ae080df3b2" translate="yes" xml:space="preserve">
          <source>The Comprehensive Perl Archive Network. (See the Camel Preface and Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo; for details.)</source>
          <target state="translated">종합적인 Perl 아카이브 네트워크. (자세한 내용은 Camel Preface 및 Camel 19 장 &quot;CPAN&quot;을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="fbde9b6a7a92989c5e72924e954088639a082096" translate="yes" xml:space="preserve">
          <source>The Config module contains all the information that was available to the &lt;code&gt;Configure&lt;/code&gt; program at Perl build time (over 900 values).</source>
          <target state="translated">구성 모듈에는 Perl 빌드 시간 (900 개 이상의 값)에서 &lt;code&gt;Configure&lt;/code&gt; 프로그램에 사용 가능한 모든 정보가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f82ec628dc6b60e59ddc0aa4e8da2f644e35b47f" translate="yes" xml:space="preserve">
          <source>The Config module is installed into the architecture and version specific library directory ($Config{installarchlib}) and it checks the perl version number when loaded.</source>
          <target state="translated">구성 모듈은 아키텍처 및 버전 별 라이브러리 디렉토리 ($ Config {installarchlib})에 설치되며로드 될 때 perl 버전 번호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cfdfb921abaaac3f8f467a1db7786aa8a018327d" translate="yes" xml:space="preserve">
          <source>The Config::Extensions module provides a hash &lt;code&gt;%Extensions&lt;/code&gt; containing all the core extensions that were enabled for this perl. The hash is keyed by extension name, with each entry having one of 3 possible values:</source>
          <target state="translated">Config :: Extensions 모듈은 이 perl에 대해 활성화 된 모든 코어 확장을 포함 하는 해시 &lt;code&gt;%Extensions&lt;/code&gt; 를 제공합니다 . 해시는 확장 이름으로 키가 지정되며 각 항목에는 3 가지 가능한 값 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93bfc257b83bc0f3f1d509f0feed1135175ce382" translate="yes" xml:space="preserve">
          <source>The Conformance Test for the UCA is available under &lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;http://www.unicode.org/Public/UCA/&lt;/a&gt;.</source>
          <target state="translated">UCA 적합성 테스트는 &lt;a href=&quot;http://www.unicode.org/Public/UCA/&quot;&gt;http://www.unicode.org/Public/UCA/에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9099e439d69987253b372d83d6abc9bc4c12963" translate="yes" xml:space="preserve">
          <source>The Curses module from CPAN provides a dynamically loadable object module interface to a curses library. A small demo can be found at the directory &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&lt;/a&gt; ; this program repeats a command and updates the screen as needed, rendering &lt;b&gt;rep ps axu&lt;/b&gt; similar to &lt;b&gt;top&lt;/b&gt;.</source>
          <target state="translated">CPAN의 Curses 모듈은 curses 라이브러리에 동적으로로드 가능한 오브젝트 모듈 인터페이스를 제공합니다. 작은 데모는 &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz&lt;/a&gt; 디렉토리에 있습니다 . 이 프로그램은 명령을 반복하고 필요에 따라 화면을 업데이트하여 &lt;b&gt;rep ps axu&lt;/b&gt; 를 &lt;b&gt;top&lt;/b&gt; 과 유사하게 렌더링 합니다.</target>
        </trans-unit>
        <trans-unit id="f56195e85a07fe1da8d19407f249186fab551788" translate="yes" xml:space="preserve">
          <source>The Curses module from CPAN provides a dynamically loadable object module interface to a curses library. A small demo can be found at the directory &lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/rep.gz&lt;/a&gt; ; this program repeats a command and updates the screen as needed, rendering &lt;b&gt;rep ps axu&lt;/b&gt; similar to &lt;b&gt;top&lt;/b&gt;.</source>
          <target state="translated">CPAN의 Curses 모듈은 curses 라이브러리에 동적으로로드 가능한 개체 모듈 인터페이스를 제공합니다. 작은 데모는 &lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/rep.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/rep.gz&lt;/a&gt; 디렉토리에서 찾을 수 있습니다 . 이 프로그램은 명령을 반복하고 필요에 따라 화면을 업데이트하여 &lt;b&gt;rep ps axu&lt;/b&gt; 를 &lt;b&gt;top&lt;/b&gt; 과 유사하게 렌더링 합니다.</target>
        </trans-unit>
        <trans-unit id="57cf931c65f72f4c6357c1dcccdb2aaadfc12fd9" translate="yes" xml:space="preserve">
          <source>The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame at that depth of recursion into the CV. The 0th slot of a frame AV is an AV which is &lt;code&gt;@_&lt;/code&gt;. Other entries are storage for variables and op targets.</source>
          <target state="translated">PADLIST의 CvDEPTH 항목은 CV 로의 재귀 깊이에서 스택 프레임 인 PAD (AV)입니다. 프레임 AV의 0 번째 슬롯은 &lt;code&gt;@_&lt;/code&gt; 인 AV입니다 . 다른 항목은 변수 및 연산 대상을위한 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="e14abdffc22e514738def0dbe442a1a41dfd62a8" translate="yes" xml:space="preserve">
          <source>The CvDEPTH'th entry of a PADLIST is a PAD (an AV) which is the stack frame at that depth of recursion into the CV. The 0th slot of a frame AV is an AV which is @_. Other entries are storage for variables and op targets.</source>
          <target state="translated">PADLIST의 CvDEPTH '번째 항목은 PAD (AV)이며 CV에 대한 재귀 깊이의 스택 프레임입니다. 프레임 AV의 0 번째 슬롯은 AV 인 AV입니다. 다른 항목은 변수 및 op 대상을위한 스토리지입니다.</target>
        </trans-unit>
        <trans-unit id="4c8b698edc086f6d5f09074b59ab49b539df94b8" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; implementation has holes (it can not restrict file access by native Win32 programs).</source>
          <target state="translated">Cygwin &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; 구현에는 구멍이 있습니다 (기본 Win32 프로그램의 파일 액세스를 제한 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="24d81b19eab85eca5ef9e9f2cae5a86c87573ad6" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; functions make the</source>
          <target state="translated">Cygwin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; 함수는</target>
        </trans-unit>
        <trans-unit id="d23ff041e40438e62d0feb42c683d19b5b1acbde" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;chroot()&lt;/code&gt; implementation has holes (it can not restrict file access by native Win32 programs).</source>
          <target state="translated">Cygwin &lt;code&gt;chroot()&lt;/code&gt; 구현에는 구멍이 있습니다 (기본 Win32 프로그램에 의한 파일 액세스를 제한 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="159a00124fe2a3dd0d65427a3cc6234d985a09c1" translate="yes" xml:space="preserve">
          <source>The Cygwin &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;lstat()&lt;/code&gt; and &lt;code&gt;readlink()&lt;/code&gt; functions make the</source>
          <target state="translated">Cygwin &lt;code&gt;stat()&lt;/code&gt; , &lt;code&gt;lstat()&lt;/code&gt; 및 &lt;code&gt;readlink()&lt;/code&gt; 함수는</target>
        </trans-unit>
        <trans-unit id="ba192629e74cc31eca240e3c966c286bb927abba" translate="yes" xml:space="preserve">
          <source>The Cygwin environment for Win32;</source>
          <target state="translated">Win32 용 Cygwin 환경;</target>
        </trans-unit>
        <trans-unit id="1c285b2bd2bfb42d86890b2e5f1ea0881773f57b" translate="yes" xml:space="preserve">
          <source>The Cygwin tools are ports of the popular GNU development tools for Win32 platforms. They run thanks to the Cygwin library which provides the UNIX system calls and environment these programs expect. More information about this project can be found at:</source>
          <target state="translated">Cygwin 도구는 Win32 플랫폼 용으로 널리 사용되는 GNU 개발 도구의 포트입니다. Cygwin 라이브러리 덕분에 UNIX 시스템 호출 및 이러한 프로그램이 기대하는 환경을 제공합니다. 이 프로젝트에 대한 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c1f15ff329b2e8194094e815d08360dc942cc0" translate="yes" xml:space="preserve">
          <source>The DB_BTREE format is useful when you want to store data in a given order. By default the keys will be stored in lexical order, but as you will see from the example shown in the next section, it is very easy to define your own sorting function.</source>
          <target state="translated">DB_BTREE 형식은 지정된 순서로 데이터를 저장하려는 경우에 유용합니다. 기본적으로 키는 어휘 순서로 저장되지만 다음 섹션의 예에서 볼 수 있듯이 자체 정렬 기능을 정의하는 것은 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="da84dd6e821316467ab753b852b3c6f56039e638" translate="yes" xml:space="preserve">
          <source>The DB_File interface was written by Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;.</source>
          <target state="translated">DB_File 인터페이스는 Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc4b830fc8435dde71447902321a40e9b54b9e85" translate="yes" xml:space="preserve">
          <source>The DB_File tests (db-btree.t, db-hash.t, db-recno.t) may fail you have installed a newer version of Berkeley DB into the system and the -I and -L compiler and linker flags introduce version conflicts with the DB 1.85 headers and libraries that came with the Tru64. For example, mixing a DB v2 library with the DB v1 headers is a bad idea. Watch out for Configure options -Dlocincpth and -Dloclibpth, and check your /usr/local/include and /usr/local/lib since they are included by default.</source>
          <target state="translated">DB_File 테스트 (db-btree.t, db-hash.t, db-recno.t)가 시스템에 최신 버전의 Berkeley DB를 설치하지 못했을 수 있으며 -I 및 -L 컴파일러 및 링커 플래그는 버전 충돌을 유발합니다. Tru64와 함께 제공되는 DB 1.85 헤더 및 라이브러리 예를 들어, DB v2 라이브러리를 DB v1 헤더와 혼합하는 것은 나쁜 생각입니다. 구성 옵션 -Dlocincpth 및 -Dloclibpth를 확인하고 / usr / local / include 및 / usr / local / lib는 기본적으로 포함되어 있으므로 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4aa7475384871e821eca8486a731a00b705b7453" translate="yes" xml:space="preserve">
          <source>The DB_HASH file format is probably the most commonly used of the three file formats that &lt;b&gt;DB_File&lt;/b&gt; supports. It is also very straightforward to use.</source>
          <target state="translated">DB_HASH 파일 형식은 &lt;b&gt;DB_File이&lt;/b&gt; 지원 하는 세 가지 파일 형식 중 가장 일반적으로 사용됩니다 . 사용하는 것도 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="093622558089c2ef694fcbf575b62744b7d5e02e" translate="yes" xml:space="preserve">
          <source>The DEBUGGING define exposes more code to the compiler, therefore more ways for things to go wrong. You should try it.</source>
          <target state="translated">DEBUGGING 정의는 더 많은 코드를 컴파일러에 노출 시키므로 더 많은 문제가 발생할 수 있습니다. 당신은 그것을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd3218b27f646c5b1da0c16a7d86f78d988008e7" translate="yes" xml:space="preserve">
          <source>The DECC$FILENAME_UNIX_REPORT logical name controls how Perl interprets filenames to the extent that Perl uses the CRTL internally for many purposes, and attempts to follow CRTL conventions for reporting filenames. The DECC$FILENAME_UNIX_ONLY feature differs in that it expects all filenames passed to the C run-time to be already in Unix format. This feature is not yet supported in Perl since Perl uses traditional OpenVMS file specifications internally and in the test harness, and it is not yet clear whether this mode will be useful or useable. The feature logical name DECC$POSIX_COMPLIANT_PATHNAMES is new with the RMS Symbolic Link SDK and included with OpenVMS v8.3, but is not yet supported in Perl.</source>
          <target state="translated">DECC $ FILENAME_UNIX_REPORT 논리 이름은 Perl이 여러 목적으로 내부적으로 CRTL을 사용하는 정도까지 Perl이 파일 이름을 해석하는 방법을 제어하고 파일 이름보고를 위해 CRTL 규칙을 따르려고합니다. DECC $ FILENAME_UNIX_ONLY 기능은 C 런타임에 전달 된 모든 파일 이름이 이미 Unix 형식 일 것으로 예상한다는 점에서 다릅니다. Perl은 내부 및 테스트 하네스에서 전통적인 OpenVMS 파일 사양을 사용하므로이 기능은 아직 Perl에서 지원되지 않으며이 모드가 유용하거나 사용 가능한지 아직 명확하지 않습니다. 기능 논리 이름 DECC $ POSIX_COMPLIANT_PATHNAMES는 RMS Symbolic Link SDK의 새로운 기능이며 OpenVMS v8.3에 포함되어 있지만 Perl에서는 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34754ae0e5b2e9872602a8baba89565547dc682e" translate="yes" xml:space="preserve">
          <source>The DOS FAT filesystem can accommodate only &quot;8.3&quot; style filenames. Under the &quot;case-insensitive, but case-preserving&quot; HPFS (OS/2) and NTFS (NT) filesystems you may have to be careful about case returned with functions like &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; or used with functions like &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt;&lt;code&gt;opendir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DOS FAT 파일 시스템은 &quot;8.3&quot;스타일 파일 이름 만 수용 할 수 있습니다. &quot;대소 문자를 구분하지 않지만 대소 문자를 유지하는&quot;HPFS (OS / 2) 및 NTFS (NT) 파일 시스템에서는 &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; 과 같은 함수로 반환 되거나 &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt; &lt;code&gt;opendir&lt;/code&gt; &lt;/a&gt; 과 같은 함수와 함께 사용되는 대소 문자에 대해주의해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d134d51441969270625bd1289ca90b131d940f8" translate="yes" xml:space="preserve">
          <source>The DOS FAT filesystem can accommodate only &quot;8.3&quot; style filenames. Under the &quot;case-insensitive, but case-preserving&quot; HPFS (OS/2) and NTFS (NT) filesystems you may have to be careful about case returned with functions like &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or used with functions like &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">DOS FAT 파일 시스템은 &quot;8.3&quot;스타일 파일 이름 만 수용 할 수 있습니다. &quot;대소 문자를 구분하지 않지만 대소 문자를 보존하는&quot;HPFS (OS / 2) 및 NTFS (NT) 파일 시스템에서 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 과 같은 함수로 반환 되거나 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 과 같은 함수와 함께 사용되는 경우에주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75f8398d5bfa6a293a0fdb8da6ccdfdc51d972bc" translate="yes" xml:space="preserve">
          <source>The Default Unicode Collation Element Table (DUCET)</source>
          <target state="translated">기본 유니 코드 데이터 정렬 요소 테이블 (DUCET)</target>
        </trans-unit>
        <trans-unit id="7dd3be7b9dd561f608dcd769b421201875493bce" translate="yes" xml:space="preserve">
          <source>The Devil in the Details</source>
          <target state="translated">디테일 속의 악마</target>
        </trans-unit>
        <trans-unit id="37eace57ea45e399a72f8107235f1e100b1ee8bb" translate="yes" xml:space="preserve">
          <source>The DynaLoader is designed to be a very simple high-level interface that is sufficiently general to cover the requirements of SunOS, HP-UX, Linux, VMS and other platforms.</source>
          <target state="translated">DynaLoader는 SunOS, HP-UX, Linux, VMS 및 기타 플랫폼의 요구 사항을 충분히 수용 할 수있는 매우 간단한 고급 인터페이스로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="f912c465834fcee4d486c53fdce3a5c5359e646e" translate="yes" xml:space="preserve">
          <source>The EBCDIC code page in use on Siemens' BS2000 system is distinct from 1047 and 0037. It is identified below as the POSIX-BC set. Like 0037 and 1047, it is the same as ISO 8859-1 in 20 code point values.</source>
          <target state="translated">Siemens BS2000 시스템에서 사용중인 EBCDIC 코드 페이지는 1047 및 0037과 다릅니다. 아래는 POSIX-BC 세트로 식별됩니다. 0037 및 1047과 마찬가지로 20 개의 코드 포인트 값에서 ISO 8859-1과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="79364f1341ebeff610668d7a68e618ee03998d55" translate="yes" xml:space="preserve">
          <source>The EBCDIC controls provide three possible line terminator characters, CR (0x0D), LF (0x25), and NL (0x15). On ASCII platforms, the symbols &quot;NL&quot; and &quot;LF&quot; refer to the same character, but in strict EBCDIC terminology they are different ones. The EBCDIC NL is mapped to the C1 control called &quot;NEL&quot; (&quot;Next Line&quot;; here's a case where the mapping makes quite a bit of sense, and hence isn't just arbitrary). On some EBCDIC platforms, this NL or NEL is the typical line terminator. This is true of z/OS and BS2000. In these platforms, the C compilers will swap the LF and NEL code points, so that &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is 0x15, and refers to NL. Perl does that too; you can see it in the code chart &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. This makes things generally &quot;just work&quot; without you even having to be aware that there is a swap.</source>
          <target state="translated">EBCDIC 컨트롤은 CR (0x0D), LF (0x25) 및 NL (0x15)의 세 가지 줄 종결 자 문자를 제공합니다. ASCII 플랫폼에서 &quot;NL&quot;및 &quot;LF&quot;기호는 동일한 문자를 나타내지 만 엄격한 EBCDIC 용어에서는 서로 다릅니다. EBCDIC NL은 &quot;NEL&quot;( &quot;Next Line&quot;)이라는 C1 컨트롤에 매핑됩니다. 여기에 매핑이 상당히 의미가 있고 임의적이지 않습니다. 일부 EBCDIC 플랫폼에서이 NL 또는 NEL은 일반적인 회선 종결 자입니다. 이는 z / OS 및 BS2000의 경우에 해당합니다. 이러한 플랫폼에서 C 컴파일러는 LF 및 NEL 코드 포인트를 교환하므로 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 0x15이며 NL을 참조합니다. 펄도 그렇게한다. &lt;a href=&quot;#recipe-3&quot;&gt;아래&lt;/a&gt; 코드 차트에서 볼 수 있습니다 . 이것은 일반적으로 &quot;그냥 작동합니다&quot;스왑이 있다는 것을 알 필요조차 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebf0849b9c64cecc2853f7671dcdaa67dfb5bd40" translate="yes" xml:space="preserve">
          <source>The EMX environment for DOS, OS/2, etc. emx@iaehv.nl, &lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt; Also &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;.</source>
          <target state="translated">DOS, OS / 2 등의 EMX 환경. emx@iaehv.nl, &lt;a href=&quot;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&quot;&gt;ftp://hobbes.nmsu.edu/pub/os2/dev/emx/&lt;/a&gt; 또한 &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256f82d42fe9ffdaee741a9745d27494e5988357" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: Keyword</source>
          <target state="translated">EXPORT_XSUB_SYMBOLS : 키워드</target>
        </trans-unit>
        <trans-unit id="dc2d72754e20f4d7576339fd0b632f9904767606" translate="yes" xml:space="preserve">
          <source>The EXPORT_XSUB_SYMBOLS: keyword is likely something you will never need. In perl versions earlier than 5.16.0, this keyword does nothing. Starting with 5.16, XSUB symbols are no longer exported by default. That is, they are &lt;code&gt;static&lt;/code&gt; functions. If you include</source>
          <target state="translated">EXPORT_XSUB_SYMBOLS : 키워드는 아마도 필요하지 않을 것입니다. 5.16.0 이전의 perl 버전에서이 키워드는 아무 작업도 수행하지 않습니다. 5.16부터는 XSUB 기호가 더 이상 기본적으로 내보내지지 않습니다. 즉, &lt;code&gt;static&lt;/code&gt; 함수입니다. 포함하면</target>
        </trans-unit>
        <trans-unit id="617a336bda8dcf8d5dea55c8c402db880f815331" translate="yes" xml:space="preserve">
          <source>The EXPR can be arbitrarily complicated provided its final operation is an element or slice of an aggregate:</source>
          <target state="translated">EXPR은 최종 작업이 집합의 요소 또는 슬라이스 인 경우 임의로 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1575f71c727dbc3cc08a704b1c6455476c26b21" translate="yes" xml:space="preserve">
          <source>The EXTEND() macro is used to make room on the argument stack for 2 return values. The PPCODE: directive causes the &lt;b&gt;xsubpp&lt;/b&gt; compiler to create a stack pointer available as &lt;code&gt;SP&lt;/code&gt; , and it is this pointer which is being used in the EXTEND() macro. The values are then pushed onto the stack with the PUSHs() macro.</source>
          <target state="translated">EXTEND () 매크로는 2 개의 반환 값을위한 인수 스택을위한 공간을 만드는 데 사용됩니다. PPCODE : 지시문은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 &lt;code&gt;SP&lt;/code&gt; 로 사용할 수있는 스택 포인터를 작성 하게하며이 포인터 는 EXTEND () 매크로에서 사용됩니다. 그런 다음 PUSHs () 매크로를 사용하여 값을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="fbb0ca569cb556ba681ff6410a6a62e634baacb5" translate="yes" xml:space="preserve">
          <source>The EXTEND() macro is used to make room on the argument stack for 2 return values. The PPCODE: directive causes the &lt;b&gt;xsubpp&lt;/b&gt; compiler to create a stack pointer available as &lt;code&gt;SP&lt;/code&gt;, and it is this pointer which is being used in the EXTEND() macro. The values are then pushed onto the stack with the PUSHs() macro.</source>
          <target state="translated">EXTEND () 매크로는 2 개의 반환 값을위한 인수 스택에 공간을 만드는 데 사용됩니다. PPCODE : 지시문은 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러가 &lt;code&gt;SP&lt;/code&gt; 로 사용할 수있는 스택 포인터를 생성하도록 합니다.이 포인터는 EXTEND () 매크로에서 사용됩니다. 그런 다음 값은 PUSHs () 매크로를 사용하여 스택으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="24d94044d20d73e1e217702a7997adf3573359ef" translate="yes" xml:space="preserve">
          <source>The Eclipse Perl Integration Project integrates Perl editing/debugging with Eclipse.</source>
          <target state="translated">Eclipse Perl 통합 프로젝트는 Perl 편집 / 디버깅을 Eclipse와 통합합니다.</target>
        </trans-unit>
        <trans-unit id="089e76f353c6f78abb99ad80ce2ae65f3d8d4946" translate="yes" xml:space="preserve">
          <source>The Eighth, and Final Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 여덟 번째 규칙 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45e6da0d5cb898ad01f0a9bae1837646548ecfe3" translate="yes" xml:space="preserve">
          <source>The Ellipsis Statement</source>
          <target state="translated">줄임표</target>
        </trans-unit>
        <trans-unit id="e36201c57b08755e4246cc5ce75f450c34e846b3" translate="yes" xml:space="preserve">
          <source>The Encode module is not available.</source>
          <target state="translated">인코딩 모듈을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a85df1c32e44ae493b3d9d47f5ce746d47a72805" translate="yes" xml:space="preserve">
          <source>The Encode package comes with</source>
          <target state="translated">Encode 패키지는 함께 제공됩니다</target>
        </trans-unit>
        <trans-unit id="1795442e49f2b33213fac82a59f9aa602577ec9d" translate="yes" xml:space="preserve">
          <source>The End Of Cargo Cult Programming</source>
          <target state="translated">화물 컬트 프로그래밍의 끝</target>
        </trans-unit>
        <trans-unit id="8b81b46699720b949c812be3aaed26b804f52e55" translate="yes" xml:space="preserve">
          <source>The English module, loaded via</source>
          <target state="translated">통해로드 된 영어 모듈</target>
        </trans-unit>
        <trans-unit id="f6ae3dbecbd56f2fb799d619d775a492c5918b30" translate="yes" xml:space="preserve">
          <source>The English name $EXCEPTIONS_BEING_CAUGHT is slightly misleading, because the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value does not indicate whether exceptions are being caught, since compilation of the main program does not catch exceptions.</source>
          <target state="translated">영어 프로그램 $ EXCEPTIONS_BEING_CAUGHT는 기본 프로그램의 컴파일이 예외를 포착하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 값이 예외가 포착되는지 여부를 나타내지 않기 때문에 약간 오도 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0aaaf06e85d16f6ddc3592a8167c76a1d6973f" translate="yes" xml:space="preserve">
          <source>The English name $EXCEPTIONS_BEING_CAUGHT is slightly misleading, because the &lt;code&gt;undef&lt;/code&gt; value does not indicate whether exceptions are being caught, since compilation of the main program does not catch exceptions.</source>
          <target state="translated">영어 이름 $ EXCEPTIONS_BEING_CAUGHT는 주 프로그램의 컴파일이 예외를 포착하지 않기 때문에 &lt;code&gt;undef&lt;/code&gt; 값이 예외 포착 여부를 나타내지 않기 때문에 약간 오해의 소지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a563900434d5f24e6b403136d7617e396332a2c1" translate="yes" xml:space="preserve">
          <source>The Execution of this file takes 2 parameters as input. The first being the NetWare SDK path, second being the path for CodeWarrior Compiler &amp;amp; tools. Execution of this file sets these paths and also sets the build type to Release by default.</source>
          <target state="translated">이 파일의 실행은 2 개의 매개 변수를 입력으로 사용합니다. 첫 번째는 NetWare SDK 경로이고, 두 번째는 CodeWarrior 컴파일러 및 도구의 경로입니다. 이 파일을 실행하면 이러한 경로가 설정되고 빌드 유형도 기본적으로 릴리스로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f147b2a13785e77381665ed5dff1c497a9b6d450" translate="yes" xml:space="preserve">
          <source>The Exporter module implements an &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method which allows a module to export functions and variables to its users' namespaces. Many modules use Exporter rather than implementing their own &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method because Exporter provides a highly flexible interface, with an implementation optimised for the common case.</source>
          <target state="translated">Exporter 모듈은 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드를 구현하여 모듈이 함수와 변수를 사용자의 네임 스페이스로 내보낼 수 있도록합니다. Exporter는 일반적인 경우에 최적화 된 구현과 함께 매우 유연한 인터페이스를 제공하므로 많은 모듈이 자체 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 방법을 구현하는 대신 Exporter를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5de439b721ed17c9f2beb77cfc0636cc6a4f9644" translate="yes" xml:space="preserve">
          <source>The Exporter module implements an &lt;code&gt;import&lt;/code&gt; method which allows a module to export functions and variables to its users' namespaces. Many modules use Exporter rather than implementing their own &lt;code&gt;import&lt;/code&gt; method because Exporter provides a highly flexible interface, with an implementation optimised for the common case.</source>
          <target state="translated">Exporter 모듈 은 모듈이 함수와 변수를 사용자의 네임 스페이스로 내보낼 수 있도록 하는 &lt;code&gt;import&lt;/code&gt; 메서드를 구현합니다 . Exporter는 일반적인 경우에 최적화 된 구현과 함께 매우 유연한 인터페이스를 제공하기 때문에 많은 모듈에서 자체 &lt;code&gt;import&lt;/code&gt; 방법을 구현하는 대신 Exporter를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f4abee164dbbeb51e77682498dd2aaadf957faf7" translate="yes" xml:space="preserve">
          <source>The Exporter module will convert an attempt to import a number from a module into a call to &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; . This can be used to validate that the version of the module being used is greater than or equal to the required version.</source>
          <target state="translated">내보내기 모듈은 모듈에서 번호를 가져 오려는 시도를 &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; 에 대한 호출로 변환합니다 . 사용중인 모듈의 버전이 필요한 버전 이상인지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd3004cd233ff28afa63f4bc81c071655de79dc" translate="yes" xml:space="preserve">
          <source>The Exporter module will convert an attempt to import a number from a module into a call to &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt;. This can be used to validate that the version of the module being used is greater than or equal to the required version.</source>
          <target state="translated">Exporter 모듈은 모듈에서 번호를 가져 오려는 시도를 &lt;code&gt;$module_name-&amp;gt;VERSION($value)&lt;/code&gt; 호출로 변환합니다 . 사용중인 모듈의 버전이 필요한 버전보다 크거나 같은지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c52e8ff54cbaf19ce5405ab1f4fcb23fdb70082" translate="yes" xml:space="preserve">
          <source>The Extended Binary Coded Decimal Interchange Code refers to a large collection of single- and multi-byte coded character sets that are quite different from ASCII and ISO 8859-1, and are all slightly different from each other; they typically run on host computers. The EBCDIC encodings derive from 8-bit byte extensions of Hollerith punched card encodings, which long predate ASCII. The layout on the cards was such that high bits were set for the upper and lower case alphabetic characters &lt;code&gt;[a-z]&lt;/code&gt; and &lt;code&gt;[A-Z]&lt;/code&gt; , but there were gaps within each Latin alphabet range, visible in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. These gaps can cause complications.</source>
          <target state="translated">확장 이진 코드화 된 10 진수 교환 코드는 ASCII 및 ISO 8859-1과는 상당히 다르고 모두 약간 다른 1 바이트 및 멀티 바이트 코드화 된 문자 집합의 모음입니다. 이들은 일반적으로 호스트 컴퓨터에서 실행됩니다. EBCDIC 인코딩은 ASCII 이전의 Hollerith 펀치 카드 인코딩의 8 비트 바이트 확장에서 파생됩니다. 카드의 레이아웃은 대문자 및 소문자 알파벳 문자 &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[A-Z]&lt;/code&gt; 대해 높은 비트가 설정 되었지만 각 라틴 알파벳 범위 내에는 &lt;a href=&quot;#recipe-3&quot;&gt;아래&lt;/a&gt; 표에서 볼 수있는 간격이있었습니다 . 이러한 차이는 합병증을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e6fe3f5f76e932526aa466a43332afa9dc5338" translate="yes" xml:space="preserve">
          <source>The Extended Binary Coded Decimal Interchange Code refers to a large collection of single- and multi-byte coded character sets that are quite different from ASCII and ISO 8859-1, and are all slightly different from each other; they typically run on host computers. The EBCDIC encodings derive from 8-bit byte extensions of Hollerith punched card encodings, which long predate ASCII. The layout on the cards was such that high bits were set for the upper and lower case alphabetic characters &lt;code&gt;[a-z]&lt;/code&gt; and &lt;code&gt;[A-Z]&lt;/code&gt;, but there were gaps within each Latin alphabet range, visible in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt;. These gaps can cause complications.</source>
          <target state="translated">확장 이진 코드 십진 교환 코드는 ASCII 및 ISO 8859-1과는 상당히 다르며 모두 서로 약간 다른 단일 및 다중 바이트 코드 문자 집합의 대규모 모음을 나타냅니다. 일반적으로 호스트 컴퓨터에서 실행됩니다. EBCDIC 인코딩은 Hollerith 천공 카드 인코딩의 8 비트 바이트 확장에서 파생되며, 이는 ASCII보다 오래 전입니다. 카드의 레이아웃은 대문자와 소문자 알파벳 문자 &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[A-Z]&lt;/code&gt; 대해 높은 비트가 설정 되었지만 각 라틴 알파벳 범위 내에 간격이 있었으며 &lt;a href=&quot;#recipe-3&quot;&gt;아래&lt;/a&gt; 표에서 볼 수 있습니다 . 이러한 간격은 합병증을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f06c8685e10bb2298b3fbb853d3946ef5600f7b" translate="yes" xml:space="preserve">
          <source>The Extended Time field (ID &quot;UT&quot;), set using the &lt;code&gt;exTime&lt;/code&gt; option, and the Unix2 extra field (ID &quot;Ux), set using the &lt;code&gt;exUnix2&lt;/code&gt; option, are examples of extra fields.</source>
          <target state="translated">사용하여 설정 확장 된 시간 필드 (ID &quot;UT&quot;), &lt;code&gt;exTime&lt;/code&gt; 의 옵션을, 그리고 Unix2 추가 필드 (ID &quot;UX)의 사용 설정 &lt;code&gt;exUnix2&lt;/code&gt; 의 옵션은 추가 필드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="fcb46fea1b1fd4aac6612092ac926ea662164c18" translate="yes" xml:space="preserve">
          <source>The FALLBACK: Keyword</source>
          <target state="translated">폴백 : 키워드</target>
        </trans-unit>
        <trans-unit id="81e67da9b589fcad262531decfe34d5e04ad538d" translate="yes" xml:space="preserve">
          <source>The FTP protocol allows files to be sent to or fetched from the server. Each transfer involves a &lt;b&gt;local file&lt;/b&gt; (on the client) and a &lt;b&gt;remote file&lt;/b&gt; (on the server). In this module, the same file name will be used for both local and remote if only one is specified. This means that transferring remote file &lt;code&gt;/path/to/file&lt;/code&gt; will try to put that file in &lt;code&gt;/path/to/file&lt;/code&gt; locally, unless you specify a local file name.</source>
          <target state="translated">FTP 프로토콜을 사용하면 서버로 파일을 보내거나 가져올 수 있습니다. 각 전송에는 &lt;b&gt;로컬 파일&lt;/b&gt; (클라이언트)과 &lt;b&gt;원격 파일&lt;/b&gt; (서버)이 포함됩니다. 이 모듈에서 하나의 파일 만 지정하면 로컬 및 원격 모두에 동일한 파일 이름이 사용됩니다. 이는 원격 파일 &lt;code&gt;/path/to/file&lt;/code&gt; 을 전송 하면 로컬 파일 이름을 지정하지 않는 한 해당 파일을 &lt;code&gt;/path/to/file&lt;/code&gt; 에 로컬로 배치하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c495bad2966bc708b3127acbfa36e3706f48122a" translate="yes" xml:space="preserve">
          <source>The FTP protocol does not have a command for changing the permissions of a file on the remote server. But some ftp servers may allow a chmod command to be issued via a SITE command, eg</source>
          <target state="translated">FTP 프로토콜에는 원격 서버에있는 파일의 권한을 변경하는 명령이 없습니다. 그러나 일부 ftp 서버는 chmod 명령이 SITE 명령을 통해 실행되도록 허용 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cb9e18bf7a6f85ed039d727582b3460b71f7b255" translate="yes" xml:space="preserve">
          <source>The Fibonacci sequence is defined by</source>
          <target state="translated">피보나치 수열은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="19ca5c1f27cf809b055786ff82f78ffa209098e1" translate="yes" xml:space="preserve">
          <source>The Field @* for Variable-Width Multi-Line Text</source>
          <target state="translated">가변 폭 다중 라인 텍스트를위한 필드 @ *</target>
        </trans-unit>
        <trans-unit id="e40af0a7d64eded8997f1df4aaf651855caff401" translate="yes" xml:space="preserve">
          <source>The Field ^* for Variable-Width One-line-at-a-time Text</source>
          <target state="translated">한 번에 한 줄씩 가변 너비 텍스트의 필드 ^ *</target>
        </trans-unit>
        <trans-unit id="051fa4e84ae2fee9062644631a452abe1ffe1819" translate="yes" xml:space="preserve">
          <source>The Fifth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 다섯 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="916ba58ad633c9294928c7ea005c39a240dcf055" translate="yes" xml:space="preserve">
          <source>The File::Compare::compare function compares the contents of two sources, each of which can be a file or a file handle. It is exported from File::Compare by default.</source>
          <target state="translated">File :: Compare :: compare 함수는 파일 또는 파일 핸들 일 수있는 두 가지 소스의 내용을 비교합니다. File :: Compare에서 기본적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="ca8ebdce3138f1ac959e2447b9991cb0fe638baf" translate="yes" xml:space="preserve">
          <source>The File::Copy module provides two basic functions, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;move&lt;/code&gt; , which are useful for getting the contents of a file from one place to another.</source>
          <target state="translated">File :: Copy 모듈은 파일 의 내용을 한 곳에서 다른 곳으로 가져 오는 데 유용한 &lt;code&gt;copy&lt;/code&gt; 및 &lt;code&gt;move&lt;/code&gt; 의 두 가지 기본 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b7d24fcde1381958d2641531b616c0cd5e78b77f" translate="yes" xml:space="preserve">
          <source>The File::Copy module provides two basic functions, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;move&lt;/code&gt;, which are useful for getting the contents of a file from one place to another.</source>
          <target state="translated">File :: Copy 모듈은 파일 내용을 한 곳에서 다른 곳으로 가져 오는 데 유용한 두 가지 기본 기능인 &lt;code&gt;copy&lt;/code&gt; 및 &lt;code&gt;move&lt;/code&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="09b1bcb4dc016e97cb98e50f74998315b3fcc200" translate="yes" xml:space="preserve">
          <source>The File::Temp has been a standard module since Perl 5.6.1. If you don't have a modern enough Perl installed, use the &lt;code&gt;new_tmpfile&lt;/code&gt; class method from the IO::File module to get a filehandle opened for reading and writing. Use it if you don't need to know the file's name:</source>
          <target state="translated">File :: Temp는 Perl 5.6.1 이후 표준 모듈입니다. 최신 Perl을 설치하지 않은 경우 IO :: File 모듈에서 &lt;code&gt;new_tmpfile&lt;/code&gt; 클래스 메소드를 사용하여 읽고 쓸 수 있도록 파일 핸들을여십시오. 파일 이름을 알 필요가없는 경우 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b913943216bac4cfd103b39436c3d12211246595" translate="yes" xml:space="preserve">
          <source>The Filter</source>
          <target state="translated">필터</target>
        </trans-unit>
        <trans-unit id="43340f79f355f6131007a53845317a0044b9a6f5" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module exports into the package that calls &lt;code&gt;FILTER&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;s it directly) -- such as package &quot;BANG&quot; in the above example -- two automagically constructed subroutines -- &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; -- which take care of all the nasty details.</source>
          <target state="translated">통화하는 패키지로 필터 : 간단한 모듈 수출 &lt;code&gt;FILTER&lt;/code&gt; (또는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 직접 S) - 같은 패키지 &quot;BANG&quot;로 위의 예 -이 개 자동적으로 구성된 서브 루틴 - &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;unimport&lt;/code&gt; - 모든 돌봐 불쾌한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="4d3500b44e6ec7278bc6ff631f76a47e52773f24" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module exports into the package that calls &lt;code&gt;FILTER&lt;/code&gt; (or &lt;code&gt;use&lt;/code&gt;s it directly) -- such as package &quot;BANG&quot; in the above example -- two automagically constructed subroutines -- &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; -- which take care of all the nasty details.</source>
          <target state="translated">통화하는 패키지로 필터 : 간단한 모듈 수출 &lt;code&gt;FILTER&lt;/code&gt; (또는 &lt;code&gt;use&lt;/code&gt; 직접 S) - 같은 패키지 &quot;BANG&quot;로 위의 예 -이 개 자동적으로 구성된 서브 루틴 - &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;unimport&lt;/code&gt; - 모든 돌봐 불쾌한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="6e7c10894c7b8df4a2736098e84057abd21e37b8" translate="yes" xml:space="preserve">
          <source>The Filter::Simple module provides a simplified interface to Filter::Util::Call; one that is sufficient for most common cases.</source>
          <target state="translated">Filter :: Simple 모듈은 Filter :: Util :: Call에 단순화 된 인터페이스를 제공합니다. 가장 일반적인 경우에 충분한 것.</target>
        </trans-unit>
        <trans-unit id="18ec459e5bbbe06d639719053b95c70e354e1142" translate="yes" xml:space="preserve">
          <source>The Firewall option is only for support of one type of firewall. The type supported is an ftp proxy.</source>
          <target state="translated">방화벽 옵션은 한 가지 유형의 방화벽 만 지원합니다. 지원되는 유형은 ftp 프록시입니다.</target>
        </trans-unit>
        <trans-unit id="bddf2be2229684864beadb4258752319125e5d27" translate="yes" xml:space="preserve">
          <source>The First Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 첫 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12f9f39f270f13a8b0bc63e2ebc08b16d8fbc693" translate="yes" xml:space="preserve">
          <source>The Fix</source>
          <target state="translated">수정</target>
        </trans-unit>
        <trans-unit id="c785438975752290d77a3cbc9b618a56d2ef340f" translate="yes" xml:space="preserve">
          <source>The Fourth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 네 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fc0887978d7a0f1367b4c9ada979ec50584ea98" translate="yes" xml:space="preserve">
          <source>The FreeBSD extensions to the POSIX standard are the following flags:</source>
          <target state="translated">POSIX 표준에 대한 FreeBSD 확장은 다음 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="ab3e557141760f9299f04ad34f2deeabfcc7fef0" translate="yes" xml:space="preserve">
          <source>The FreeMiNT port uses GNU dld for loadable module capabilities. So ensure you have that library installed when building perl.</source>
          <target state="translated">FreeMiNT 포트는로드 가능한 모듈 기능을 위해 GNU dld를 사용합니다. 따라서 perl을 빌드 할 때 해당 라이브러리가 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bd44ad85b88fe564fe8b68f6373986e32c743703" translate="yes" xml:space="preserve">
          <source>The GDBM documentation doesn't imply that files from untrusted sources can be safely used with &lt;code&gt;libgdbm&lt;/code&gt;.</source>
          <target state="translated">GDBM 문서는 신뢰할 수없는 소스의 파일이 &lt;code&gt;libgdbm&lt;/code&gt; 과 함께 안전하게 사용될 수 있음을 암시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ee84d8925574036a2d7863cc65cfdc54b37fced1" translate="yes" xml:space="preserve">
          <source>The GDBM error number and error message interface needs to be added.</source>
          <target state="translated">GDBM 오류 번호 및 오류 메시지 인터페이스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0fd999d74111938e315c20e741e008d3fd7c5c7" translate="yes" xml:space="preserve">
          <source>The GNU C Compiler</source>
          <target state="translated">GNU C 컴파일러</target>
        </trans-unit>
        <trans-unit id="f7502d47efcc98abcd8c943af7c016d5af95a756" translate="yes" xml:space="preserve">
          <source>The GNU tar specification</source>
          <target state="translated">GNU tar 사양</target>
        </trans-unit>
        <trans-unit id="894d7b2fc0f57e109a134bcb9ec74e4755f78f6b" translate="yes" xml:space="preserve">
          <source>The GSM0338 is also covered in Encode::Byte even though it is not an &quot;extended ASCII&quot; encoding.</source>
          <target state="translated">GSM0338은 &quot;확장 된 ASCII&quot;인코딩이 아니더라도 Encode :: Byte에서도 다루어집니다.</target>
        </trans-unit>
        <trans-unit id="61c74b1ce70e651c940d8afc41945cbe9a38bcfe" translate="yes" xml:space="preserve">
          <source>The GV representing &lt;code&gt;*_&lt;/code&gt;. Useful for access to &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*_&lt;/code&gt; 를 나타내는 GV 입니다. &lt;code&gt;$_&lt;/code&gt; 에 액세스하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d9d4765228818a588c101c574dcfb1a870a89ab7" translate="yes" xml:space="preserve">
          <source>The GV returned from &lt;code&gt;gv_fetchmeth&lt;/code&gt; may be a method cache entry, which is not visible to Perl code. So when calling &lt;code&gt;call_sv&lt;/code&gt; , you should not use the GV directly; instead, you should use the method's CV, which can be obtained from the GV with the &lt;code&gt;GvCV&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;gv_fetchmeth&lt;/code&gt; 에서 반환 된 GV 는 메서드 캐시 항목 일 수 있으며 Perl 코드에는 보이지 않습니다. 따라서 &lt;code&gt;call_sv&lt;/code&gt; 를 호출 할 때 GV를 직접 사용해서는 안됩니다. 대신 &lt;code&gt;GvCV&lt;/code&gt; 매크로 를 사용하여 GV에서 얻을 수있는 메소드의 CV를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="239c65b1784a17283acff31d3912eefd7c81191b" translate="yes" xml:space="preserve">
          <source>The GV returned from &lt;code&gt;gv_fetchmeth&lt;/code&gt; may be a method cache entry, which is not visible to Perl code. So when calling &lt;code&gt;call_sv&lt;/code&gt;, you should not use the GV directly; instead, you should use the method's CV, which can be obtained from the GV with the &lt;code&gt;GvCV&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;gv_fetchmeth&lt;/code&gt; 에서 반환 된 GV는 Perl 코드에 표시되지 않는 메서드 캐시 항목 일 수 있습니다. 따라서 &lt;code&gt;call_sv&lt;/code&gt; 를 호출 할 때 GV를 직접 사용해서는 안됩니다. 대신 &lt;code&gt;GvCV&lt;/code&gt; 매크로 를 사용하여 GV에서 얻을 수있는 메서드의 CV를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b49130058618570dadbdb5fe7db0bf1f3977aebe" translate="yes" xml:space="preserve">
          <source>The GV which was last used for a filehandle input operation. (&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</source>
          <target state="translated">파일 핸들 입력 조작에 마지막으로 사용 된 GV ( &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="55e852dea5ba8376da3dd27662792e25a263d554" translate="yes" xml:space="preserve">
          <source>The GV which was last used for a filehandle input operation. (&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">파일 핸들 입력 작업에 마지막으로 사용 된 GV입니다. ( &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f9210879f69c79f8b2c57a2c424d2e90c56d2548" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag is meant to be used in conjunction with G_EVAL in</source>
          <target state="translated">G_KEEPERR 플래그는 다음에서 G_EVAL과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="270052086120a712d1ce772352a3feccf55ed3d1" translate="yes" xml:space="preserve">
          <source>The G_KEEPERR flag was introduced in Perl version 5.002.</source>
          <target state="translated">G_KEEPERR 플래그는 Perl 버전 5.002에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c166e1d44ca297aba655d34fc5c35cdba6de63b6" translate="yes" xml:space="preserve">
          <source>The Gamma function [C99].</source>
          <target state="translated">감마 기능 [C99].</target>
        </trans-unit>
        <trans-unit id="c28a373a90d22851cb6b0c5d6429010695515e8d" translate="yes" xml:space="preserve">
          <source>The Generic Object</source>
          <target state="translated">일반 객체</target>
        </trans-unit>
        <trans-unit id="be19e055acdc9d4cfa79691a16d99bc6afcec772" translate="yes" xml:space="preserve">
          <source>The Getopt::Long module implements an extended getopt function called GetOptions(). It parses the command line from &lt;code&gt;@ARGV&lt;/code&gt; , recognizing and removing specified options and their possible values.</source>
          <target state="translated">Getopt :: Long 모듈은 GetOptions ()라는 확장 된 getopt 함수를 구현합니다. 지정된 옵션과 가능한 값을 인식하고 제거하여 &lt;code&gt;@ARGV&lt;/code&gt; 에서 명령 행을 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="4a3bcfdeb4f782209b79b7132268830942ffb31a" translate="yes" xml:space="preserve">
          <source>The Getopt::Long module implements an extended getopt function called GetOptions(). It parses the command line from &lt;code&gt;@ARGV&lt;/code&gt;, recognizing and removing specified options and their possible values.</source>
          <target state="translated">Getopt :: Long 모듈은 GetOptions ()라는 확장 된 getopt 함수를 구현합니다. &lt;code&gt;@ARGV&lt;/code&gt; 에서 명령 줄을 구문 분석하여 지정된 옵션과 가능한 값을 인식하고 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2070520f96de2fb3aff1e83e6888cb8e89e845b4" translate="yes" xml:space="preserve">
          <source>The Gods Must Be Crazy</source>
          <target state="translated">신들은 미쳐야한다</target>
        </trans-unit>
        <trans-unit id="95a2e8168d41f50bb6b37295098c965f76153807" translate="yes" xml:space="preserve">
          <source>The Guide</source>
          <target state="translated">가이드</target>
        </trans-unit>
        <trans-unit id="5298e135f008dcbe68c1cb6c5368e25d31e290a3" translate="yes" xml:space="preserve">
          <source>The HP ANSI C Compiler</source>
          <target state="translated">HP ANSI C 컴파일러</target>
        </trans-unit>
        <trans-unit id="cbc8f650d8669a3292691821f3fcd62a7f570f6f" translate="yes" xml:space="preserve">
          <source>The HP porting centres are limited in what systems they are allowed to port to and they usually choose the two most recent OS versions available.</source>
          <target state="translated">HP 포팅 센터는 포트 할 수있는 시스템이 제한되어 있으며 일반적으로 사용 가능한 최신 OS 버전 2 개를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f122712cd3f618cf66f5c1f12ee353af13431595" translate="yes" xml:space="preserve">
          <source>The HTML/XML character reference modes are about the same. In place of &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt;, HTML uses &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; where</source>
          <target state="translated">HTML / XML 문자 참조 모드는 거의 같습니다. &lt;code&gt;\x{&lt;i&gt;HHHH&lt;/i&gt;}&lt;/code&gt; 대신 HTML은 &lt;code&gt;&amp;amp;#&lt;i&gt;NNN&lt;/i&gt;;&lt;/code&gt; 어디</target>
        </trans-unit>
        <trans-unit id="36100c08868e01dc8cc43e522dca19e6917bba7c" translate="yes" xml:space="preserve">
          <source>The Hitchhiker's Guide to the Galaxy</source>
          <target state="translated">은하수를 여행하는 히치하이커를위한 안내서</target>
        </trans-unit>
        <trans-unit id="e1c3679460c98c3b3c6c4ab57a10e09b7a1778d9" translate="yes" xml:space="preserve">
          <source>The Hobbit</source>
          <target state="translated">호빗</target>
        </trans-unit>
        <trans-unit id="7095c243f9ea4a1c6f36f3116033fc3223182156" translate="yes" xml:space="preserve">
          <source>The HostName for the hosts command port. This is madatory, the program will fail if not provided.</source>
          <target state="translated">호스트 명령 포트의 호스트 이름입니다. 이것은 미친 짓이며, 제공되지 않으면 프로그램이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ff076bcca2d7f3f3bc21f192dd45509aa2d50344" translate="yes" xml:space="preserve">
          <source>The I/O layers can also be specified more flexibly with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, or look at the following example.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma를 사용하여 I / O 레이어를보다 유연하게 지정할 수도 있습니다 . &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조 하거나 다음 예를보십시오.</target>
        </trans-unit>
        <trans-unit id="52b8a7c66504091a567fd93cc4e8e2a5db8efd87" translate="yes" xml:space="preserve">
          <source>The I/O layers can also be specified more flexibly with the &lt;code&gt;open&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, or look at the following example.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; pragma를 사용하여 I / O 계층을보다 유연하게 지정할 수도 있습니다 . &lt;a href=&quot;open&quot;&gt;open을&lt;/a&gt; 참조 하거나 다음 예제를보십시오.</target>
        </trans-unit>
        <trans-unit id="9bb410ea518f5686bb8957c03ada154b43330468" translate="yes" xml:space="preserve">
          <source>The IANA is responsible for delegating management of the top level country domains. The country domains are the two-letter (lowercase) codes from ISO 3166 with a few other additions.</source>
          <target state="translated">IANA는 최상위 국가 도메인 관리 위임을 담당합니다. 국가 도메인은 몇 가지 다른 추가 사항이있는 ISO 3166의 2 자리 (소문자) 코드입니다.</target>
        </trans-unit>
        <trans-unit id="494453dbfde6185be2550cd595666629ce3cd776" translate="yes" xml:space="preserve">
          <source>The IANA language subtag registry.</source>
          <target state="translated">IANA 언어 하위 태그 레지스트리</target>
        </trans-unit>
        <trans-unit id="14ed0108ca9064725768107f673bb9f9f4c35fe4" translate="yes" xml:space="preserve">
          <source>The IBM ANSI C Compiler</source>
          <target state="translated">IBM ANSI C 컴파일러</target>
        </trans-unit>
        <trans-unit id="02dd8ba3a34ffd809cf07605a9d86d87105f9946" translate="yes" xml:space="preserve">
          <source>The IBM APAR number for this problem is IZ50240 (Reported component ID: 5765G0300 / AIX 5.3). It is possible to get an ifix for that problem. If you need an ifix please contact your local IBM AIX support.</source>
          <target state="translated">이 문제점의 IBM APAR 번호는 IZ50240입니다 (보고 된 구성 요소 ID : 5765G0300 / AIX 5.3). 해당 문제에 대한 ifix를 얻을 수 있습니다. ifix가 필요한 경우 로컬 IBM AIX 지원에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="a6c290ab208815021765007f305a8fc14c88a6b4" translate="yes" xml:space="preserve">
          <source>The IBM's compiler patch levels 5.0.0.0 and 5.0.1.0 have compiler optimization bugs that affect compiling perl.c and regcomp.c, respectively. If Perl's configuration detects those compiler patch levels, optimization is turned off for the said source code files. Upgrading to at least 5.0.2.0 is recommended.</source>
          <target state="translated">IBM의 컴파일러 패치 레벨 5.0.0.0 및 5.0.1.0에는 perl.c 및 regcomp.c의 컴파일에 각각 영향을주는 컴파일러 최적화 버그가 있습니다. Perl의 구성이 해당 컴파일러 패치 레벨을 발견하면, 해당 소스 코드 파일에 대한 최적화가 해제됩니다. 5.0.2.0 이상으로 업그레이드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9495fe8f41686bc61a5fe351f28585160b7d92af" translate="yes" xml:space="preserve">
          <source>The ID header in an &lt;code&gt;ExtraField&lt;/code&gt; sub-field can consist of any two bytes.</source>
          <target state="translated">&lt;code&gt;ExtraField&lt;/code&gt; 서브 필드 의 ID 헤더는 2 바이트로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12476b805899024ebbbf1698dd235cf902a1c7c0" translate="yes" xml:space="preserve">
          <source>The ID of the context that was used to create the event.</source>
          <target state="translated">이벤트를 만드는 데 사용 된 컨텍스트의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="1ab0e27c330240961003daf34d48c41005b17eec" translate="yes" xml:space="preserve">
          <source>The ID of the hub that the event was send to.</source>
          <target state="translated">이벤트가 전송 된 허브의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="9b87452eae0a7c924c411f78515d55cae30c106f" translate="yes" xml:space="preserve">
          <source>The ID of the hub that was current when the event was created.</source>
          <target state="translated">이벤트가 생성 될 때 최신 상태였던 허브의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="e1d154173604900e6d649a0362f6607140bc599a" translate="yes" xml:space="preserve">
          <source>The IDs of all objects available within a program are strings that can be expanded to the corresponding real objects with the &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; method. Expand returns a list of CPAN::Module objects according to the &lt;code&gt;@things&lt;/code&gt; arguments given. In scalar context, it returns only the first element of the list.</source>
          <target state="translated">프로그램 내에서 사용 가능한 모든 오브젝트의 ID는 &lt;code&gt;CPAN::Shell-&amp;gt;expand(&quot;Module&quot;,@things)&lt;/code&gt; 메소드 를 사용하여 해당 실제 오브젝트로 확장 될 수있는 문자열입니다 . Expand는 주어진 &lt;code&gt;@things&lt;/code&gt; 인수 에 따라 CPAN :: Module 객체 목록을 반환합니다 . 스칼라 컨텍스트에서는 목록의 첫 번째 요소 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10ac6c437c9901ca659c989f66f60ed9a2a13418" translate="yes" xml:space="preserve">
          <source>The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</source>
          <target state="translated">IN / OUTLIST / IN_OUTLIST / OUT / IN_OUT 키워드</target>
        </trans-unit>
        <trans-unit id="348998c68227b2675b00049ded155d9a2e0cebf4" translate="yes" xml:space="preserve">
          <source>The INCLUDE: Keyword</source>
          <target state="translated">포함 : 키워드</target>
        </trans-unit>
        <trans-unit id="2fd635a1ef0c21453ce812dc91933d7964a41662" translate="yes" xml:space="preserve">
          <source>The INCLUDE_COMMAND: Keyword</source>
          <target state="translated">INCLUDE_COMMAND : 키워드</target>
        </trans-unit>
        <trans-unit id="edaf758a314e34d83c79323397c8453ba48d6649" translate="yes" xml:space="preserve">
          <source>The INIT: Keyword</source>
          <target state="translated">INIT : 키워드</target>
        </trans-unit>
        <trans-unit id="c2a1ae034dc0e7090561071ada28079423ed98bf" translate="yes" xml:space="preserve">
          <source>The INIT: directive contains code that will be placed immediately after the argument stack is decoded. C does not allow variable declarations at arbitrary locations inside a function, so this is usually the best way to declare local variables needed by the XSUB. (Alternatively, one could put the whole &lt;code&gt;PPCODE:&lt;/code&gt; section into braces, and put these declarations on top.)</source>
          <target state="translated">INIT : 지시문에는 인수 스택이 디코딩 된 직후에 배치되는 코드가 포함됩니다. C는 함수 내의 임의 위치에서 변수 선언을 허용하지 않으므로 일반적으로 XSUB에 필요한 로컬 변수를 선언하는 가장 좋은 방법입니다. (또는 전체 &lt;code&gt;PPCODE:&lt;/code&gt; 섹션을 중괄호로 묶고 이러한 선언을 맨 위에 넣을 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="08f7558037e95071c749920f4074890a9d7217ea" translate="yes" xml:space="preserve">
          <source>The INIT: keyword allows initialization to be inserted into the XSUB before the compiler generates the call to the C function. Unlike the CODE: keyword above, this keyword does not affect the way the compiler handles RETVAL.</source>
          <target state="translated">INIT : 키워드를 사용하면 컴파일러가 C 함수에 대한 호출을 생성하기 전에 초기화를 XSUB에 삽입 할 수 있습니다. 위의 CODE : 키워드와 달리이 키워드는 컴파일러가 RETVAL을 처리하는 방식에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05bebe82f53ea5f020b6b0d4fe1069dcc8a1edbb" translate="yes" xml:space="preserve">
          <source>The INPUT and OUTPUT sections substitute underscores for double-colons on the fly, giving the desired effect. This example demonstrates some of the power and versatility of the typemap facility.</source>
          <target state="translated">INPUT 및 OUTPUT 섹션은 이중 콜론을 밑줄로 대신 사용하여 원하는 효과를줍니다. 이 예제는 타입 맵 기능의 강력한 기능과 다양성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="970adbac5d031ff3f8daeef101bb8b55901dc870" translate="yes" xml:space="preserve">
          <source>The INPUT: Keyword</source>
          <target state="translated">입력 : 키워드</target>
        </trans-unit>
        <trans-unit id="21ee92ef918e68068f302b993af8bd2d49672033" translate="yes" xml:space="preserve">
          <source>The INSTALL file in the perl top-level has much information that is only relevant to people building Perl on Unix-like systems. In particular, you can safely ignore any information that talks about &quot;Configure&quot;.</source>
          <target state="translated">perl 최상위 레벨의 INSTALL 파일에는 Unix 계열 시스템에서 Perl을 빌드하는 사람들과 관련된 많은 정보가 있습니다. 특히 &quot;구성&quot;에 관한 정보는 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="0adfc9336795bed66f7e1ae7c7424119e43e300c" translate="yes" xml:space="preserve">
          <source>The INSTALL... macros in turn default to their %Config ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.</source>
          <target state="translated">INSTALL ... 매크로는 기본적으로 % Config ($ Config {installprivlib}, $ Config {installarchlib} 등)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9023b649b609edcd17550081d28e4a80cf681ce5" translate="yes" xml:space="preserve">
          <source>The INTERFACE: Keyword</source>
          <target state="translated">인터페이스 : 키워드</target>
        </trans-unit>
        <trans-unit id="e1fc34a9a712c8a8848d549ec748ba68c13f33e7" translate="yes" xml:space="preserve">
          <source>The INTERFACE_MACRO: Keyword</source>
          <target state="translated">INTERFACE_MACRO : 키워드</target>
        </trans-unit>
        <trans-unit id="1dc68d829f3e7afebf9178286cb38cc376f6ec35" translate="yes" xml:space="preserve">
          <source>The IO::Pty and Expect modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="translated">CPAN의 IO :: Pty 및 Expect 모듈은 실제 tty (실제 pseudo-tty)를 제공하므로 호출 된 명령에서 다시 라인 버퍼링으로 돌아갈 수 있으므로 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99807f53289794deab86efdaf9d7a76fb60defb6" translate="yes" xml:space="preserve">
          <source>The IO::Socket(3) manpage describes the object library, and the Socket(3) manpage describes the low-level interface to sockets. Besides the obvious functions in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, you should also check out the</source>
          <target state="translated">IO :: Socket (3) 맨 페이지는 객체 라이브러리를 설명하고 Socket (3) 맨 페이지는 소켓에 대한 저수준 인터페이스를 설명합니다. &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 의 명백한 기능 외에도 ,</target>
        </trans-unit>
        <trans-unit id="bb5f7f025be1cf04ec567ae65c089a38b2f5ae67" translate="yes" xml:space="preserve">
          <source>The IP protocol to use for the socket (e.g. &lt;code&gt;'tcp'&lt;/code&gt;, &lt;code&gt;IPPROTO_TCP&lt;/code&gt;, &lt;code&gt;'udp'&lt;/code&gt;,&lt;code&gt;IPPROTO_UDP&lt;/code&gt;). Normally this will be left undefined, and either &lt;code&gt;getaddrinfo&lt;/code&gt; or the kernel will choose an appropriate value. May be given either in string name or numeric form.</source>
          <target state="translated">소켓에 사용할 IP 프로토콜 (예 : &lt;code&gt;'tcp'&lt;/code&gt; , &lt;code&gt;IPPROTO_TCP&lt;/code&gt; , &lt;code&gt;'udp'&lt;/code&gt; , &lt;code&gt;IPPROTO_UDP&lt;/code&gt; ). 일반적으로 이것은 정의되지 않은 상태로 남아 있으며 &lt;code&gt;getaddrinfo&lt;/code&gt; 또는 커널이 적절한 값을 선택합니다. 문자열 이름 또는 숫자 형식으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0a9e9c2d5b3d41df694af6945579b725a01526" translate="yes" xml:space="preserve">
          <source>The IPC subsystem lives in this namespace. There are not many good reasons to add anything to this namespace, with exception of IPC drivers.</source>
          <target state="translated">IPC 하위 시스템은이 네임 스페이스에 있습니다. IPC 드라이버를 제외하고이 네임 스페이스에 아무것도 추가해야하는 이유는 많지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd19329497c4746f419d864be77ab0a23a7089f7" translate="yes" xml:space="preserve">
          <source>The ISO 4217 data.</source>
          <target state="translated">ISO 4217 데이터</target>
        </trans-unit>
        <trans-unit id="9aedc742ca6fb2dc7b951347169405aefc47d178" translate="yes" xml:space="preserve">
          <source>The ISO 8601 standard defines the date format to be YYYY-MM-DD, and the time format to be hh:mm:ss (24 hour clock), and if combined, they should be concatenated with date first and with a capital 'T' in front of the time.</source>
          <target state="translated">ISO 8601 표준은 날짜 형식을 YYYY-MM-DD로 정의하고 시간 형식을 hh : mm : ss (24 시간제)로 정의하고 결합 된 경우 날짜와 먼저, 대문자 'T로 연결해야합니다. '시간의 앞에.</target>
        </trans-unit>
        <trans-unit id="b1897fe9f53f26e8ee1d177c372171adf09aeabb" translate="yes" xml:space="preserve">
          <source>The ISO 8859-</source>
          <target state="translated">ISO 8859-</target>
        </trans-unit>
        <trans-unit id="be3a3d5a87727d649fad4e25cef60372ccbe4e20" translate="yes" xml:space="preserve">
          <source>The IVdf will expand to whatever is the correct format for the IVs.</source>
          <target state="translated">IVdf는 IV에 적합한 형식으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="2438b4ecbe3dbd078f85fcd76de3ac8517dfbe33" translate="yes" xml:space="preserve">
          <source>The Inside-out Technique</source>
          <target state="translated">인사이드 아웃 기법</target>
        </trans-unit>
        <trans-unit id="bfd4ccd468ad208229b8e304f3f53a782dd6a87c" translate="yes" xml:space="preserve">
          <source>The Intent</source>
          <target state="translated">의도</target>
        </trans-unit>
        <trans-unit id="2342b66467ebaece52e091e32751a96c53b72eee" translate="yes" xml:space="preserve">
          <source>The Internals namespace is used by the core Perl development team to expose certain low level internals routines for testing and other purposes.</source>
          <target state="translated">내부 네임 스페이스는 핵심 Perl 개발 팀에서 테스트 및 기타 목적을 위해 특정 저수준 내부 루틴을 노출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94771cb0c8e4f1f0a6f837c00d85c8dc460252be" translate="yes" xml:space="preserve">
          <source>The Internet line terminator is &quot;\015\012&quot;. Under ASCII variants of Unix, that could usually be written as &quot;\r\n&quot;, but under other systems, &quot;\r\n&quot; might at times be &quot;\015\015\012&quot;, &quot;\012\012\015&quot;, or something completely different. The standards specify writing &quot;\015\012&quot; to be conformant (be strict in what you provide), but they also recommend accepting a lone &quot;\012&quot; on input (be lenient in what you require). We haven't always been very good about that in the code in this manpage, but unless you're on a Mac from way back in its pre-Unix dark ages, you'll probably be ok.</source>
          <target state="translated">인터넷 회선 종결자는 &quot;\ 015 \ 012&quot;입니다. Unix의 ASCII 변형에서는 일반적으로 &quot;\ r \ n&quot;으로 쓸 수 있지만 다른 시스템에서는 &quot;\ r \ n&quot;이 &quot;\ 015 \ 015 \ 012&quot;, &quot;\ 012 \ 012 \ 015 일 수 있습니다. &quot;또는 완전히 다른 것입니다. 표준은 &quot;\ 015 \ 012&quot;를 준수하도록 지정하지만 (제공 한 내용이 엄격해야 함) 입력시 고독한 &quot;\ 012&quot;를 수락하는 것이 좋습니다 (필요한 내용에 관대함). 우리는이 맨 페이지의 코드에서 그 점을 항상 잘 알고 있지는 않지만, Unix 이전의 어두운 시대로 돌아 가지 않는 한 Mac에 있지 않으면 아마 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="501b92baa8d232237960cf668a9120aec4afdddd" translate="yes" xml:space="preserve">
          <source>The Keyed-Hash Message Authentication Code (HMAC):</source>
          <target state="translated">키 해시 메시지 인증 코드 (HMAC) :</target>
        </trans-unit>
        <trans-unit id="cf2010a1a611616a3268f58f445690ff33fdae55" translate="yes" xml:space="preserve">
          <source>The LAYER parameter of the &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; function is described as &quot;DISCIPLINE&quot; in &quot;Programming Perl, 3rd Edition&quot;. However, since the publishing of this book, by many known as &quot;Camel III&quot;, the consensus of the naming of this functionality has moved from &quot;discipline&quot; to &quot;layer&quot;. All documentation of this version of Perl therefore refers to &quot;layers&quot; rather than to &quot;disciplines&quot;. Now back to the regularly scheduled documentation...</source>
          <target state="translated">&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt; 기능 의 LAYER 매개 변수는 &quot;Programming Perl, 3rd Edition&quot;에서 &quot;DISCIPLINE&quot;으로 설명됩니다. 그러나 &quot;Camel III&quot;로 알려진이 책이 출판 된 이후로이 기능의 이름에 대한 합의는 &quot;훈련&quot;에서 &quot;레이어&quot;로 이동했습니다. 따라서이 버전의 Perl에 대한 모든 문서는 &quot;분야&quot;가 아닌 &quot;계층&quot;을 참조합니다. 이제 정기적으로 예약 된 문서로 돌아갑니다 ...</target>
        </trans-unit>
        <trans-unit id="d65b2222a8c282dae9b3cd28518dc29329740227" translate="yes" xml:space="preserve">
          <source>The LAYER parameter of the binmode() function is described as &quot;DISCIPLINE&quot; in &quot;Programming Perl, 3rd Edition&quot;. However, since the publishing of this book, by many known as &quot;Camel III&quot;, the consensus of the naming of this functionality has moved from &quot;discipline&quot; to &quot;layer&quot;. All documentation of this version of Perl therefore refers to &quot;layers&quot; rather than to &quot;disciplines&quot;. Now back to the regularly scheduled documentation...</source>
          <target state="translated">binmode () 함수의 LAYER 매개 변수는 &quot;Programming Perl, 3rd Edition&quot;에서 &quot;DISCIPLINE&quot;으로 설명됩니다. 그러나 많은 사람들이 &quot;Camel III&quot;이라고하는이 책을 출판 한 이후로이 기능의 명명에 대한 합의는 &quot;징계&quot;에서 &quot;계층&quot;으로 옮겨졌습니다. 따라서이 버전의 Perl에 대한 모든 문서는 &quot;훈련&quot;이 아니라 &quot;계층&quot;을 나타냅니다. 이제 정기적으로 예약 된 설명서로 돌아가십시오 ...</target>
        </trans-unit>
        <trans-unit id="c5a27ef16f958a529f7db36014226c11d0b2a269" translate="yes" xml:space="preserve">
          <source>The LENGTH must be less than or equal to the buffer size.</source>
          <target state="translated">LENGTH는 버퍼 크기보다 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ea2784880355655cd5260296b326df11e2887853" translate="yes" xml:space="preserve">
          <source>The LLP64 data model is different from the LP64 data model that is the norm on 64-bit Unix platforms. In the former, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; are both 32-bit data types, while pointers are 64 bits wide. In addition, there is a separate 64-bit wide integral type, &lt;code&gt;__int64&lt;/code&gt; . In contrast, the LP64 data model that is pervasive on Unix platforms provides &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; as the 32-bit type, while both the &lt;code&gt;long&lt;/code&gt; type and pointers are of 64-bit precision. Note that both models provide for 64-bits of addressability.</source>
          <target state="translated">LLP64 데이터 모델은 64 비트 Unix 플랫폼에서 일반적으로 사용되는 LP64 데이터 모델과 다릅니다. 전자에서 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;long&lt;/code&gt; 은 모두 32 비트 데이터 형식이고 포인터는 64 비트입니다. 또한 별도의 64 비트 너비 정수 유형 인 &lt;code&gt;__int64&lt;/code&gt; 가 있습니다. 반대로 Unix 플랫폼에서 널리 사용되는 LP64 데이터 모델은 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 를 32 비트 유형으로 제공하는 반면 &lt;code&gt;long&lt;/code&gt; 유형과 포인터는 모두 64 비트 정밀도입니다. 두 모델 모두 64 비트의 주소 지정 가능성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce21f7a39833b3b397891fa624e87d1fa1bb0f31" translate="yes" xml:space="preserve">
          <source>The LLP64 data model is different from the LP64 data model that is the norm on 64-bit Unix platforms. In the former, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; are both 32-bit data types, while pointers are 64 bits wide. In addition, there is a separate 64-bit wide integral type, &lt;code&gt;__int64&lt;/code&gt;. In contrast, the LP64 data model that is pervasive on Unix platforms provides &lt;code&gt;int&lt;/code&gt; as the 32-bit type, while both the &lt;code&gt;long&lt;/code&gt; type and pointers are of 64-bit precision. Note that both models provide for 64-bits of addressability.</source>
          <target state="translated">LLP64 데이터 모델은 64 비트 Unix 플랫폼에서 표준 인 LP64 데이터 모델과 다릅니다. 전자에서 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;long&lt;/code&gt; 은 모두 32 비트 데이터 유형이고 포인터는 64 비트입니다. 또한 별도의 64 비트 폭 정수 유형 &lt;code&gt;__int64&lt;/code&gt; 가 있습니다. 반대로 Unix 플랫폼에서 널리 사용되는 LP64 데이터 모델 은 32 비트 유형으로 &lt;code&gt;int&lt;/code&gt; 를 제공 하는 반면 &lt;code&gt;long&lt;/code&gt; 유형과 포인터는 모두 64 비트 정밀도입니다. 두 모델 모두 64 비트 주소 지정 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89a865b15f025e4125f9521e0cbb444b319a7463" translate="yes" xml:space="preserve">
          <source>The Layout</source>
          <target state="translated">배치</target>
        </trans-unit>
        <trans-unit id="3892e7769cde3def977297b2fd107c985947cfbb" translate="yes" xml:space="preserve">
          <source>The Lays of Beleriand</source>
          <target state="translated">Beleriand의 낳는다</target>
        </trans-unit>
        <trans-unit id="b0afa09df1fad56be5d5842b1eca124439a7ca1c" translate="yes" xml:space="preserve">
          <source>The LimitOutput option.</source>
          <target state="translated">LimitOutput 옵션.</target>
        </trans-unit>
        <trans-unit id="6bf08ad7095de382c5cb38d291417012501ff158" translate="yes" xml:space="preserve">
          <source>The Line Feed (LF) character is actually a 14th variant character, and Perl checks for that as well.</source>
          <target state="translated">줄 바꿈 (LF) 문자는 실제로 14 번째 변형 문자이며 Perl도이를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e2c746fe2ac2e652c0a7fa2affbbadf67729cfb6" translate="yes" xml:space="preserve">
          <source>The Linguistic View</source>
          <target state="translated">언어 적 관점</target>
        </trans-unit>
        <trans-unit id="7609c4332cdddf67282a426dcc844b81450f8724" translate="yes" xml:space="preserve">
          <source>The Locale-Codes distribution.</source>
          <target state="translated">로캘 코드 배포</target>
        </trans-unit>
        <trans-unit id="4371d0e1d710e94eadf09e06051f14e2003db5e7" translate="yes" xml:space="preserve">
          <source>The Locale/Maketext.pm source. Observe that the module is much shorter than its documentation!</source>
          <target state="translated">Locale / Maketext.pm 소스 모듈이 설명서보다 훨씬 짧은 지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="38bb5321e46a281dda4ae130db97eaa961627a32" translate="yes" xml:space="preserve">
          <source>The Lord of the Rings</source>
          <target state="translated">반지의 제왕</target>
        </trans-unit>
        <trans-unit id="5b43d0f809cf7c1db877d9b28a9fa286b9d389c4" translate="yes" xml:space="preserve">
          <source>The Lucas sequence is defined by</source>
          <target state="translated">Lucas 시퀀스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="65d1f880f060efd8bb95b4c1ef3aa2f9bbc16903" translate="yes" xml:space="preserve">
          <source>The MANIFEST file contains the names of all the files just created in the Mytest directory.</source>
          <target state="translated">MANIFEST 파일에는 Mytest 디렉토리에 방금 생성 된 모든 파일의 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc342c2add9e7769b6276801f43191956bbbeb6e" translate="yes" xml:space="preserve">
          <source>The MD5 algorithm is defined in RFC 1321. This implementation is derived from the reference C code in RFC 1321 which is covered by the following copyright statement:</source>
          <target state="translated">MD5 알고리즘은 RFC 1321에 정의되어 있습니다.이 구현은 RFC 1321의 참조 C 코드에서 파생되며 다음 저작권 정보가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97df132e442d1f2bf4b0a61020e962a19ec4340d" translate="yes" xml:space="preserve">
          <source>The META.yml file describes important properties of contributed Perl distributions such as the ones found on &lt;a href=&quot;http://www.cpan.org&quot;&gt;CPAN&lt;/a&gt;. It is typically created by tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; and &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">META.yml 파일은 &lt;a href=&quot;http://www.cpan.org&quot;&gt;CPAN&lt;/a&gt; 에있는 것과 같은 기여 된 Perl 배포의 중요한 속성을 설명합니다 . 일반적으로 &lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 및 &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; 와 같은 도구로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9537d8b0ad6140964d74f5fb5b27ffc5de966f02" translate="yes" xml:space="preserve">
          <source>The MIME name as defined in IETF RFCs. This includes all &quot;iso-&quot;s.</source>
          <target state="translated">IETF RFC에 정의 된 MIME 이름입니다. 여기에는 모든 &quot;iso-&quot;가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e86531fea95dec4dbc1a4122ea65572723c44f18" translate="yes" xml:space="preserve">
          <source>The MM_* hierarchy</source>
          <target state="translated">MM_ * 계층</target>
        </trans-unit>
        <trans-unit id="a517aaaef144e51dda68ffaef4baabb6659f9741" translate="yes" xml:space="preserve">
          <source>The MODULE Keyword</source>
          <target state="translated">모듈 키워드</target>
        </trans-unit>
        <trans-unit id="d640b9c0318e742980f68cffc45a40affd82cb5f" translate="yes" xml:space="preserve">
          <source>The MODULE keyword is used to start the XS code and to specify the package of the functions which are being defined. All text preceding the first MODULE keyword is considered C code and is passed through to the output with POD stripped, but otherwise untouched. Every XS module will have a bootstrap function which is used to hook the XSUBs into Perl. The package name of this bootstrap function will match the value of the last MODULE statement in the XS source files. The value of MODULE should always remain constant within the same XS file, though this is not required.</source>
          <target state="translated">MODULE 키워드는 XS 코드를 시작하고 정의중인 기능의 패키지를 지정하는 데 사용됩니다. 첫 번째 MODULE 키워드 앞에있는 모든 텍스트는 C 코드로 간주되며 POD가 제거 된 상태로 출력에 전달되지만 그렇지 않으면 그대로 유지됩니다. 모든 XS 모듈에는 XSUB를 Perl에 연결하는 데 사용되는 부트 스트랩 기능이 있습니다. 이 부트 스트랩 함수의 패키지 이름은 XS 소스 파일의 마지막 MODULE 문의 값과 일치합니다. MODULE의 값은 항상 동일한 XS 파일 내에서 일정하게 유지되어야하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="eb4b2ce583f381cfbe7f078522f5b75cf8b0acdd" translate="yes" xml:space="preserve">
          <source>The MY_CXT_INIT macro initializes storage for the &lt;code&gt;my_cxt_t&lt;/code&gt; struct.</source>
          <target state="translated">MY_CXT_INIT 매크로는 &lt;code&gt;my_cxt_t&lt;/code&gt; 의 스토리지를 초기화합니다 . 구조체의 .</target>
        </trans-unit>
        <trans-unit id="2dd4eb6a77854464c830f76b78c6ac15e92b669d" translate="yes" xml:space="preserve">
          <source>The Makefile to be produced may be altered by adding arguments of the form &lt;code&gt;KEY=VALUE&lt;/code&gt; . E.g.</source>
          <target state="translated">생성 될 Makefile은 &lt;code&gt;KEY=VALUE&lt;/code&gt; 형식의 인수를 추가하여 변경 될 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="ed7104714526631620d13360de25ce56cd201d37" translate="yes" xml:space="preserve">
          <source>The Makefile to be produced may be altered by adding arguments of the form &lt;code&gt;KEY=VALUE&lt;/code&gt;. E.g.</source>
          <target state="translated">생성 될 Makefile은 &lt;code&gt;KEY=VALUE&lt;/code&gt; 형식의 인수를 추가하여 변경할 수 있습니다 . 예</target>
        </trans-unit>
        <trans-unit id="ad78ec4ae3b5a4c78156cf44036606a40c32aaf5" translate="yes" xml:space="preserve">
          <source>The Mantra</source>
          <target state="translated">만트라</target>
        </trans-unit>
        <trans-unit id="1b194ffb2833786ebe5362ee6e09704940be3454" translate="yes" xml:space="preserve">
          <source>The Memoize man page.</source>
          <target state="translated">Memoize 매뉴얼 페이지.</target>
        </trans-unit>
        <trans-unit id="c9b6eed232325cf1c4a45f0c05f4eef2581e5150" translate="yes" xml:space="preserve">
          <source>The Metrowerks will give a lot of warnings about unused variables and empty declarations, you can ignore those.</source>
          <target state="translated">Metrowerks는 사용하지 않는 변수와 빈 선언에 대해 많은 경고를 제공하므로 무시해도됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="8b07a539021a149c75372ae5a8d60bcacade8512" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual C++ compilers are also now being given away free. They are available as &quot;Visual C++ Toolkit 2003&quot; or &quot;Visual C++ 2005-2013 Express Edition&quot; (and also as part of the &quot;.NET Framework SDK&quot;) and are the same compilers that ship with &quot;Visual C++ .NET 2003 Professional&quot; or &quot;Visual C++ 2005-2013 Professional&quot; respectively.</source>
          <target state="translated">Microsoft Visual C ++ 컴파일러도 이제 무료로 제공되고 있습니다. &quot;Visual C ++ Toolkit 2003&quot;또는 &quot;Visual C ++ 2005-2013 Express Edition&quot;(및 &quot;.NET Framework SDK&quot;의 일부)으로 제공되며 &quot;Visual C ++ .NET 2003 Professional&quot;과 함께 제공되는 동일한 컴파일러입니다. 또는 &quot;Visual C ++ 2005-2013 Professional&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ab62c064605eae4546fca3e4db8285d748ce8c99" translate="yes" xml:space="preserve">
          <source>The Microsoft Visual C++ compilers are also now being given away free. They are available as &quot;Visual C++ Toolkit 2003&quot; or &quot;Visual C++ 2005-2019 Express [or Community, from 2017] Edition&quot; (and also as part of the &quot;.NET Framework SDK&quot;) and are the same compilers that ship with &quot;Visual C++ .NET 2003 Professional&quot; or &quot;Visual C++ 2005-2019 Professional&quot; respectively.</source>
          <target state="translated">Microsoft Visual C ++ 컴파일러도 이제 무료로 제공됩니다. &quot;Visual C ++ Toolkit 2003&quot;또는 &quot;Visual C ++ 2005-2019 Express [또는 Community, from 2017] Edition&quot;(또한 &quot;.NET Framework SDK&quot;의 일부로)으로 제공되며 &quot; Visual C ++ .NET 2003 Professional &quot;또는&quot;Visual C ++ 2005-2019 Professional &quot;.</target>
        </trans-unit>
        <trans-unit id="b6efbee1ed83675ffebd32144ba8248768436ab5" translate="yes" xml:space="preserve">
          <source>The NAME section (&lt;code&gt;=head1 NAME&lt;/code&gt; ) should consist of a single paragraph with the script/module name, followed by a dash `-' and a very short description of what the thing is good for.</source>
          <target state="translated">NAME 섹션 ( &lt;code&gt;=head1 NAME&lt;/code&gt; )은 스크립트 / 모듈 이름이있는 단일 단락으로 구성되고 그 뒤에 대시`- '가 있고 그 내용이 무엇인지에 대한 아주 짧은 설명으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6693ae0b360d96815c5bd0a47dde50f7c7078343" translate="yes" xml:space="preserve">
          <source>The NAME section (&lt;code&gt;=head1 NAME&lt;/code&gt;) should consist of a single paragraph with the script/module name, followed by a dash `-' and a very short description of what the thing is good for.</source>
          <target state="translated">NAME 섹션 ( &lt;code&gt;=head1 NAME&lt;/code&gt; )은 스크립트 / 모듈 이름, 대시`- '및 그에 대한 매우 짧은 설명이있는 단일 단락으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="552a987af386f5239d1d91c8f3cd7d6b46b27cbb" translate="yes" xml:space="preserve">
          <source>The NAME section should be recognized specially and index entries emitted for everything in that section. This would have to be deferred until the next section, since extraneous things in NAME tends to confuse various man page processors. Currently, no index entries are emitted for anything in NAME.</source>
          <target state="translated">NAME 섹션은 특별히 인식되어야하며 해당 섹션의 모든 항목에 대해 생성 된 색인 항목입니다. NAME의 외부 항목이 다양한 매뉴얼 페이지 프로세서를 혼동하는 경향이 있으므로 다음 섹션까지 연기해야합니다. 현재 NAME의 항목에는 색인 항목이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="106247dd546d0d783bd133d840e85e93e8398962" translate="yes" xml:space="preserve">
          <source>The NAS systems are equipped with Synology Disk Storage Manager (DSM), which is a trimmed-down Linux system enhanced with several tools for managing the NAS. There are several flavours of hardware: Marvell Armada (ARMv5tel, ARMv7l), Intel Atom (i686, x86_64), Freescale QorIQ (PPC), and more. For a full list see the &lt;a href=&quot;https://forum.synology.com/wiki/index.php/What_kind_of_CPU_does_my_NAS_have&quot;&gt;Synology FAQ&lt;/a&gt;.</source>
          <target state="translated">NAS 시스템에는 NAS 관리를위한 여러 도구로 강화 된 축소 된 Linux 시스템 인 Synology Disk Storage Manager (DSM)가 장착되어 있습니다. 하드웨어에는 Marvell Armada (ARMv5tel, ARMv7l), Intel Atom (i686, x86_64), Freescale QorIQ (PPC) 등 여러 종류가 있습니다. 전체 목록은 &lt;a href=&quot;https://forum.synology.com/wiki/index.php/What_kind_of_CPU_does_my_NAS_have&quot;&gt;Synology FAQ를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eede37533894539b6f0e561b631aee0b3870de35" translate="yes" xml:space="preserve">
          <source>The NEVER keyword must appear by itself if used within the Notify option and &quot;requests that a DSN not be returned to the sender under any conditions.&quot;</source>
          <target state="translated">알림 옵션 내에서 사용하고 &quot;어떤 조건에서도 발신자에게 DSN을 반환하지 않도록 요청&quot;하는 경우 NEVER 키워드가 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1dccb0bb054644651ad0c69767bda009b1d0637b" translate="yes" xml:space="preserve">
          <source>The NO_INIT Keyword</source>
          <target state="translated">NO_INIT 키워드</target>
        </trans-unit>
        <trans-unit id="23729fabcc944859639583f78edb8c8ef05b2818" translate="yes" xml:space="preserve">
          <source>The NO_INIT keyword is used to indicate that a function parameter is being used only as an output value. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will normally generate code to read the values of all function parameters from the argument stack and assign them to C variables upon entry to the function. NO_INIT will tell the compiler that some parameters will be used for output rather than for input and that they will be handled before the function terminates.</source>
          <target state="translated">NO_INIT 키워드는 함수 매개 변수가 출력 값으로 만 사용되고 있음을 나타내는 데 사용됩니다. &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러는 일반적으로 아규먼트 스택에서 모든 함수 매개 변수의 값을 읽고 함수 항목에 C 변수에 할당하는 코드를 생성합니다. NO_INIT는 컴파일러에게 일부 매개 변수가 입력이 아닌 출력에 사용되며 함수가 종료되기 전에 처리 될 것이라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="8fd6dba18911a57231232a7c939d805f823c76e7" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT Keyword</source>
          <target state="translated">NO_OUTPUT 키워드</target>
        </trans-unit>
        <trans-unit id="03379df3fc9b65eb904066ecff904227f6ca6017" translate="yes" xml:space="preserve">
          <source>The NO_OUTPUT can be placed as the first token of the XSUB. This keyword indicates that while the C subroutine we provide an interface to has a non-&lt;code&gt;void&lt;/code&gt; return type, the return value of this C subroutine should not be returned from the generated Perl subroutine.</source>
          <target state="translated">NO_OUTPUT은 XSUB의 첫 번째 토큰으로 배치 될 수 있습니다. 이 키워드는 C 서브 루틴이 &lt;code&gt;void&lt;/code&gt; 가 아닌 리턴 유형 을 갖는 인터페이스를 제공하지만이 C 서브 루틴 의 리턴 값은 생성 된 Perl 서브 루틴에서 리턴되지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="904e01c3e307ff335e43430a3d4bc1ddd9643078" translate="yes" xml:space="preserve">
          <source>The Name_Alias property is also of this form. But each scalar consists of two components: 1) the name, and 2) the type of alias this is. They are separated by a colon and a space. In Unicode 6.1, there are several alias types:</source>
          <target state="translated">Name_Alias ​​속성도이 형식입니다. 그러나 각 스칼라는 1) 이름과 2)이 별칭 유형으로 구성됩니다. 콜론과 공백으로 구분됩니다. 유니 코드 6.1에는 몇 가지 별명 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8335e651ec579d0644f75bd5c6369bb3697cc7b" translate="yes" xml:space="preserve">
          <source>The Nestable version works by looking for hash references being stored and converting them to tied hashes so that they too can have references as keys. This will happen without warning whenever you store a reference to one of your own hashes in the tied hash.</source>
          <target state="translated">Nestable 버전은 저장되는 해시 참조를 찾아 묶음 해시로 변환하여 키로 참조를 가질 수 있도록합니다. 묶인 해시에 자신의 해시 중 하나에 대한 참조를 저장할 때마다 경고없이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcc5f60d1d23d703a1928d0437cd7198d0e10748" translate="yes" xml:space="preserve">
          <source>The Net::FTP class is a subclass of Net::Cmd and (depending on avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</source>
          <target state="translated">Net :: FTP 클래스는 Net :: Cmd의 하위 클래스이며 (가용성에 따라) IO :: Socket :: IP, IO :: Socket :: INET6 또는 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1aaccf615c02a846abe966f8242837a674850c5a" translate="yes" xml:space="preserve">
          <source>The Net::FTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net :: FTP 클래스는 Net :: Cmd 및 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d9d26da428292375c28f9684d936ea134ec92e54" translate="yes" xml:space="preserve">
          <source>The Net::NNTP class is a subclass of Net::Cmd and (depending on avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</source>
          <target state="translated">Net :: NNTP 클래스는 Net :: Cmd의 하위 클래스이며 (가용성에 따라) IO :: Socket :: IP, IO :: Socket :: INET6 또는 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="01eaa0b5dde8380e0c7a54964e805d8bfcf3acc6" translate="yes" xml:space="preserve">
          <source>The Net::NNTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net :: NNTP 클래스는 Net :: Cmd 및 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1e3d237e3c13e3aa3df1e19263d5bac06b656919" translate="yes" xml:space="preserve">
          <source>The Net::POP3 class is a subclass of Net::Cmd and (depending on avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</source>
          <target state="translated">Net :: POP3 클래스는 Net :: Cmd의 하위 클래스이며 (가용성에 따라) IO :: Socket :: IP, IO :: Socket :: INET6 또는 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="da23b39231b794a7054fda91fbd214625459379e" translate="yes" xml:space="preserve">
          <source>The Net::POP3 class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net :: POP3 클래스는 Net :: Cmd 및 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8eafd8b349ddad570caf90318b2392764d6c202b" translate="yes" xml:space="preserve">
          <source>The Net::SMTP class is a subclass of Net::Cmd and (depending on avaibility) of IO::Socket::IP, IO::Socket::INET6 or IO::Socket::INET.</source>
          <target state="translated">Net :: SMTP 클래스는 Net :: Cmd의 하위 클래스이며 (가용성에 따라) IO :: Socket :: IP, IO :: Socket :: INET6 또는 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8d68199e14c6e60b44de999602d0fae86539eba2" translate="yes" xml:space="preserve">
          <source>The Net::SMTP class is a subclass of Net::Cmd and IO::Socket::INET.</source>
          <target state="translated">Net :: SMTP 클래스는 Net :: Cmd 및 IO :: Socket :: INET의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="64f60cb8e2581437bfdc17a813e7b06233279924" translate="yes" xml:space="preserve">
          <source>The OP's flags, abbreviated as a series of symbols.</source>
          <target state="translated">OP의 플래그는 일련의 기호로 축약됩니다.</target>
        </trans-unit>
        <trans-unit id="895a69280490efde337cd0fd19af585a8e383312" translate="yes" xml:space="preserve">
          <source>The OP's name, in all caps.</source>
          <target state="translated">모든 대문자로 된 OP의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="02eabb0cd331fbbf23966749354f0c2df6db1d07" translate="yes" xml:space="preserve">
          <source>The OP's name.</source>
          <target state="translated">OP의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2e25dacc5e61c7fb0d63f53483335a706cbf1613" translate="yes" xml:space="preserve">
          <source>The OP's private flags, rendered with abbreviated names if possible.</source>
          <target state="translated">가능한 경우 약어 이름으로 렌더링 된 OP의 개인용 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="59e423cd50aec687154fc4dc506adc4e55e686ff" translate="yes" xml:space="preserve">
          <source>The OP-specific information of the OP (such as the SV for an SVOP, the non-local exit pointers for a LOOP, etc.) enclosed in parentheses.</source>
          <target state="translated">OP의 OP 특정 정보 (예 : SVOP의 SV, LOOP의 비 로컬 종료 포인터 등)는 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="0f586844a0e8ae4292abb29dd5184b53fc4b9536" translate="yes" xml:space="preserve">
          <source>The OS/390 and z/OS C run-time libraries provide &lt;code&gt;_atoe()&lt;/code&gt; and &lt;code&gt;_etoa()&lt;/code&gt; functions.</source>
          <target state="translated">OS / 390 및 z / OS C 런타임 라이브러리는 &lt;code&gt;_atoe()&lt;/code&gt; 및 &lt;code&gt;_etoa()&lt;/code&gt; 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="efc93b2b68cdc27d26189d3924b12fba2216cd16" translate="yes" xml:space="preserve">
          <source>The OUTPUT: Keyword</source>
          <target state="translated">출력 : 키워드</target>
        </trans-unit>
        <trans-unit id="6558e5f212b7172c05e18d1a7261588a3081027f" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword can also be used to indicate that function parameters are output variables. This may be necessary when a parameter has been modified within the function and the programmer would like the update to be seen by Perl.</source>
          <target state="translated">OUTPUT : 키워드를 사용하여 함수 매개 변수가 출력 변수임을 표시 할 수도 있습니다. 이것은 함수 내에서 매개 변수가 수정되었고 프로그래머가 Perl에 의해 업데이트를보고자 할 때 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a9f4665d98e2b1d4598fa0b47867a5d82b1767" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword indicates that certain function parameters should be updated (new values made visible to Perl) when the XSUB terminates or that certain values should be returned to the calling Perl function. For simple functions which have no CODE: or PPCODE: section, such as the sin() function above, the RETVAL variable is automatically designated as an output value. For more complex functions the &lt;b&gt;xsubpp&lt;/b&gt; compiler will need help to determine which variables are output variables.</source>
          <target state="translated">OUTPUT : 키워드는 XSUB가 종료 될 때 특정 함수 매개 변수가 갱신되거나 (Perl에 새 값이 표시됨) 특정 값이 호출 Perl 함수에 리턴되어야 함을 나타냅니다. 위의 sin () 함수와 같이 CODE : 또는 PPCODE : 섹션이없는 간단한 함수의 경우 RETVAL 변수가 자동으로 출력 값으로 지정됩니다. 보다 복잡한 함수의 경우 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러는 출력 변수 인 변수를 결정하는 데 도움이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4cc5401f4b3edfb0209daaa58ea92639a885ffb3" translate="yes" xml:space="preserve">
          <source>The OUTPUT: keyword will also allow an output parameter to be mapped to a matching piece of code rather than to a typemap.</source>
          <target state="translated">OUTPUT : 키워드를 사용하면 출력 매개 변수를 유형 맵이 아닌 일치하는 코드에 맵핑 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee72e50bec09b405c45fd6861c78e461f0c9260" translate="yes" xml:space="preserve">
          <source>The OVERLOAD: Keyword</source>
          <target state="translated">과부하 : 키워드</target>
        </trans-unit>
        <trans-unit id="7288e63116c84272f399850db852020e0cc73247" translate="yes" xml:space="preserve">
          <source>The Opcode module allow you to define an</source>
          <target state="translated">Opcode 모듈을 사용하면</target>
        </trans-unit>
        <trans-unit id="959cf82efacd7e02d3ef8885dabccff7457e7125" translate="yes" xml:space="preserve">
          <source>The Opcode module is not usually used directly. See the ops pragma and Safe modules for more typical uses.</source>
          <target state="translated">Opcode 모듈은 일반적으로 직접 사용되지 않습니다. 보다 일반적인 용도는 ops pragma 및 Safe 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc2df1bcfc1883b7877806492c6187e99dd073c7" translate="yes" xml:space="preserve">
          <source>The Opcode package contains functions for manipulating operator names tags and sets. All are available for export by the package.</source>
          <target state="translated">Opcode 패키지에는 운영자 이름 태그 및 세트를 조작하는 기능이 포함되어 있습니다. 모두 패키지로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d0c8d509c42bd9d64cbd39302a78c4a8138b0f" translate="yes" xml:space="preserve">
          <source>The Output File Glob is a normal string, with 2 glob-like features.</source>
          <target state="translated">Output File Glob은 2 개의 glob-like 기능을 가진 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="84f8f10721f91385f97d9092c39e5e78fd029d2f" translate="yes" xml:space="preserve">
          <source>The PACKAGE Keyword</source>
          <target state="translated">패키지 키워드</target>
        </trans-unit>
        <trans-unit id="865d0a1c65f77bfae0d9586920617d375bc6acfd" translate="yes" xml:space="preserve">
          <source>The PADLIST has a C array where pads are stored.</source>
          <target state="translated">PADLIST에는 패드가 저장된 C 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a42650858d4f29fe76f5f506d61c2fcd72c3a0" translate="yes" xml:space="preserve">
          <source>The PASE environment is a runtime environment for OS/400 that can run executables built for PowerPC AIX in OS/400; see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;. PASE is ASCII-based, not EBCDIC-based as the ILE.</source>
          <target state="translated">PASE 환경은 OS / 400에서 PowerPC AIX 용으로 빌드 된 실행 파일을 실행할 수있는 OS / 400 용 런타임 환경입니다. &lt;a href=&quot;perlos400&quot;&gt;perlos400을&lt;/a&gt; 참조하십시오 . PASE는 ILE로서 EBCDIC 기반이 아닌 ASCII 기반입니다.</target>
        </trans-unit>
        <trans-unit id="1f72b8482ed4bc7cb03eba7f8d7c5860c8cba587" translate="yes" xml:space="preserve">
          <source>The PATH isn't the only environment variable which can cause problems. Because some shells may use the variables IFS, CDPATH, ENV, and BASH_ENV, Perl checks that those are either empty or untainted when starting subprocesses. You may wish to add something like this to your setid and taint-checking scripts.</source>
          <target state="translated">PATH는 문제를 일으킬 수있는 유일한 환경 변수가 아닙니다. 일부 쉘은 변수 IFS, CDPATH, ENV 및 BASH_ENV를 사용할 수 있으므로 Perl은 서브 프로세스를 시작할 때 비어 있거나 포함되지 않았는지 확인합니다. setid 및 taint-checking 스크립트에 이와 같은 것을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d39bcf239c4e87e009e146ae36fe8545147ee4" translate="yes" xml:space="preserve">
          <source>The PATHEXT env variable will be used to get a list of extensions that might indicate a command, otherwise .com, .exe, .bat and .cmd will be used by default.</source>
          <target state="translated">PATHEXT env 변수는 명령을 나타낼 수있는 확장명 목록을 가져 오는 데 사용됩니다. 그렇지 않으면 기본적으로 .com, .exe, .bat 및 .cmd가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7243f6ac7c83fe20c93feefd9b08218632215bc2" translate="yes" xml:space="preserve">
          <source>The PATTERN need not be constant; an expression may be used to specify a pattern that varies at runtime.</source>
          <target state="translated">패턴은 일정 할 필요는 없습니다. 식은 런타임에 따라 달라지는 패턴을 지정하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04507c264a2e77c0e8f0df6a3e09248b499b830" translate="yes" xml:space="preserve">
          <source>The PAX format specification</source>
          <target state="translated">PAX 형식 사양</target>
        </trans-unit>
        <trans-unit id="5641c4470c4030794d6b37def1d2df51ddf9b8cb" translate="yes" xml:space="preserve">
          <source>The PERL5DB environment variable is only used when Perl is started with a bare &lt;a href=&quot;#-d&quot;&gt;&quot;-d&quot;&lt;/a&gt; switch.</source>
          <target state="translated">PERL5DB 환경 변수는 Perl이 베어 &lt;a href=&quot;#-d&quot;&gt;&quot;-d&quot;&lt;/a&gt; 스위치로 시작될 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="692a1dbebc7770986f39cc91bf3402c713778957" translate="yes" xml:space="preserve">
          <source>The PERL5DB environment variable is only used when Perl is started with a bare &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">PERL5DB 환경 변수는 Perl이 bare &lt;b&gt;-d&lt;/b&gt; 스위치로 시작된 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="384a9bba0d39d96f016ef9adb9ada5d921ed7ef6" translate="yes" xml:space="preserve">
          <source>The PERL5LIB and PERLLIB environment elements work as documented in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, except that the element separator is, by default, '|' instead of ':'. However, when running under a Unix shell as determined by the logical name &lt;code&gt;GNV$UNIX_SHELL&lt;/code&gt;, the separator will be ':' as on Unix systems. The directory specifications may use either VMS or Unix syntax.</source>
          <target state="translated">PERL5LIB 및 PERLLIB 환경 요소 는 요소 구분 기호가 기본적으로 '|'인 것을 제외하고 는 &lt;a href=&quot;perl&quot;&gt;perl에&lt;/a&gt; 설명 된대로 작동 합니다. 대신에 ':'. 그러나 논리 이름 &lt;code&gt;GNV$UNIX_SHELL&lt;/code&gt; 의해 결정된 Unix 쉘에서 실행할 때 구분 기호는 Unix 시스템에서와 같이 ':'입니다. 디렉토리 사양은 VMS 또는 Unix 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eee98df1ea759ea4940bac25b454fb3fd49fcab" translate="yes" xml:space="preserve">
          <source>The PERL5LIB and PERLLIB logical names work as documented in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, except that the element separator is '|' instead of ':'. The directory specifications may use either VMS or Unix syntax.</source>
          <target state="translated">PERL5LIB 및 PERLLIB 논리 이름 은 요소 구분 기호가 '|'인 것을 제외하고 &lt;a href=&quot;perl&quot;&gt;perl에&lt;/a&gt; 문서화 된대로 작동 합니다. 대신에 ':'. 디렉토리 스펙은 VMS 또는 Unix 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="368f8cf4322638139da678fdc3327c77e1a054e7" translate="yes" xml:space="preserve">
          <source>The PERLIO environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">PerlIO가 변수 모드에서 실행될 때 PERLIO 환경 변수는 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="054efbf018fd73b713cd0bc442abab0d7792d243" translate="yes" xml:space="preserve">
          <source>The PERLLIB environment variable is completely ignored when Perl is run in taint mode.</source>
          <target state="translated">Perl이 환경 모드에서 실행될 때 PERLLIB 환경 변수는 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d86bdeabcf0cc9f48a3238fc1e1e9701f94852a2" translate="yes" xml:space="preserve">
          <source>The PERL_MAGIC_uvar interface for hashes</source>
          <target state="translated">해시 용 PERL_MAGIC_uvar 인터페이스</target>
        </trans-unit>
        <trans-unit id="fb91b23c022ab8bc327b326b9c283bc9250f0c0a" translate="yes" xml:space="preserve">
          <source>The PERL_VMS_EXCEPTION_DEBUG being defined as &quot;ENABLE&quot; will cause the VMS debugger to be invoked if a fatal exception that is not otherwise handled is raised. The purpose of this is to allow debugging of internal Perl problems that would cause such a condition.</source>
          <target state="translated">&quot;ENABLE&quot;로 정의되는 PERL_VMS_EXCEPTION_DEBUG는 달리 처리되지 않은 치명적인 예외가 발생하면 VMS 디버거가 호출되게합니다. 이것의 목적은 그러한 조건을 야기하는 내부 Perl 문제점의 디버깅을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e2373bae9a9b5526191c72b5feebb5b501ede90" translate="yes" xml:space="preserve">
          <source>The POD file has some &lt;code&gt;=item&lt;/code&gt; and/or &lt;code&gt;=head&lt;/code&gt; commands that have the same text. Potential hyperlinks to such a text cannot be unique then. This warning is printed only with warning level greater than one.</source>
          <target state="translated">POD 파일에는 &lt;code&gt;=item&lt;/code&gt; 및 / 또는 &lt;code&gt;=head&lt;/code&gt; 동일한 텍스트를 가진 = head 명령이 있습니다. 그런 텍스트에 대한 잠재적 하이퍼 링크는 고유 할 수 없습니다. 이 경고는 경고 수준이 1보다 큰 경우에만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6a2061d2e11b2e67b0037b468d2ff510b08d969a" translate="yes" xml:space="preserve">
          <source>The POD names of files are the plain basenames with any Perl-like extension (.pm, .pl, .pod) stripped, and path separators replaced by &lt;code&gt;::&lt;/code&gt; 's.</source>
          <target state="translated">파일의 POD 이름은 Perl과 같은 확장명 (.pm, .pl, .pod)이 제거되고 경로 구분 기호가 &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaaea120a98c76d72d04152c7cbfbf8c567750c1" translate="yes" xml:space="preserve">
          <source>The POD names of files are the plain basenames with any Perl-like extension (.pm, .pl, .pod) stripped, and path separators replaced by &lt;code&gt;::&lt;/code&gt;'s.</source>
          <target state="translated">파일의 POD 이름은 Perl과 유사한 확장자 (.pm, .pl, .pod)가 제거 된 일반 기본 이름이며 경로 구분자는 &lt;code&gt;::&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3f7ef3aaed3b96c670ec2c717b4d27aac5d999a" translate="yes" xml:space="preserve">
          <source>The POSIX class matches according to the locale, except:</source>
          <target state="translated">POSIX 클래스는 다음을 제외하고 로케일에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d05b25c0d51d4520f59dbd5e7b83c675d81a2280" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as its Full-range counterpart.</source>
          <target state="translated">POSIX 클래스는 Full-range 클래스와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a91522989698e72a81436ce9d52c71f12180a429" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the ASCII range counterpart.</source>
          <target state="translated">POSIX 클래스는 ASCII 범위와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="45eac6affb7dfd81e7b1ef63dd7e0a2e6da662a9" translate="yes" xml:space="preserve">
          <source>The POSIX class matches the same as the Full-range counterpart.</source>
          <target state="translated">POSIX 클래스는 전체 범위와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dc901c76cdcb97dea7310ea8ea924293bb5949f6" translate="yes" xml:space="preserve">
          <source>The POSIX defined flags for bsd_glob() are:</source>
          <target state="translated">bsd_glob ()에 대한 POSIX 정의 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e02533c48482c5a2f4dfad5d8b4125c0bf7939c7" translate="yes" xml:space="preserve">
          <source>The POSIX locale system is used to specify both the language conventions requested by the user and the preferred character set to consume and output. The &lt;code&gt;Encode::Locale&lt;/code&gt; module looks up the charset and encoding (called a CODESET in the locale jargon) and arranges for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to know this encoding under the name &quot;locale&quot;. It means bytes obtained from the environment can be converted to Unicode strings by calling &lt;code&gt;Encode::encode(locale =&amp;gt; $bytes)&lt;/code&gt; and converted back again with &lt;code&gt;Encode::decode(locale =&amp;gt; $string)&lt;/code&gt;.</source>
          <target state="translated">POSIX 로케일 시스템은 사용자가 요청한 언어 규칙과 소비 및 출력 할 선호 문자 세트를 모두 지정하는 데 사용됩니다. &lt;code&gt;Encode::Locale&lt;/code&gt; 에 대한 모듈 외모 (로케일 전문 용어에 코드 세트라고 함) 캐릭터 세트 및 인코딩 위로 주선 &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 모듈은 이름이 &quot;로케일&quot;에서이 인코딩을 알 수 있습니다. 이는 &lt;code&gt;Encode::encode(locale =&amp;gt; $bytes)&lt;/code&gt; 를 호출하여 환경에서 얻은 바이트를 유니 코드 문자열로 변환하고 &lt;code&gt;Encode::decode(locale =&amp;gt; $string)&lt;/code&gt; 으로 다시 변환 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0fced43544b15278205eeaf1ce05bf21af49dca0" translate="yes" xml:space="preserve">
          <source>The POSIX module (part of the standard perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and other mathematical and trigonometric functions. The &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; module (part of the standard perl distribution) defines mathematical functions that work on both the reals and the imaginary numbers. &lt;code&gt;Math::Complex&lt;/code&gt; is not as efficient as POSIX, but POSIX can't work with complex numbers.</source>
          <target state="translated">POSIX 모듈 (표준 펄 분포의 일부)은 &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; 및 기타 수학 및 삼각 함수를 구현합니다. &lt;code&gt;&lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; 모듈 (표준 펄 배포판의 일부) 수학 함수를 정의하는 실수와 허수 모두에서 작동하는지. &lt;code&gt;Math::Complex&lt;/code&gt; 는 POSIX만큼 효율적이지 않지만 POSIX는 복잡한 숫자로 작동 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0598c2a0577b8090da85af7bced7c87385823843" translate="yes" xml:space="preserve">
          <source>The POSIX module (part of the standard perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt;, &lt;code&gt;floor()&lt;/code&gt;, and other mathematical and trigonometric functions. The &lt;code&gt;&lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; module (part of the standard perl distribution) defines mathematical functions that work on both the reals and the imaginary numbers. &lt;code&gt;Math::Complex&lt;/code&gt; is not as efficient as POSIX, but POSIX can't work with complex numbers.</source>
          <target state="translated">POSIX 모듈 (표준 perl 배포판의 일부)은 &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; 및 기타 수학 및 삼각 함수를 구현합니다. &lt;code&gt;&lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt;&lt;/code&gt; 모듈 (표준 펄 배포판의 일부) 수학 함수를 정의하는 실수와 허수 모두에서 작동하는지. &lt;code&gt;Math::Complex&lt;/code&gt; 는 POSIX만큼 효율적이지 않지만 POSIX는 복소수로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58a76e828b7178504f0efaab58e9fc7ae8c408e4" translate="yes" xml:space="preserve">
          <source>The POSIX module permits you to access all (or nearly all) the standard POSIX 1003.1 identifiers. Many of these identifiers have been given Perl-ish interfaces.</source>
          <target state="translated">POSIX 모듈을 사용하면 모든 표준 POSIX 1003.1 식별자에 액세스 할 수 있습니다. 이러한 식별자 중 다수에는 Perl-ish 인터페이스가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb00001e36c555e321a2c3180d9872e8c4493925" translate="yes" xml:space="preserve">
          <source>The POSIX provided &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; , and the FreeBSD extensions &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; , and &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; flags have not been implemented in the Perl version because they involve more complex interaction with the underlying C structures.</source>
          <target state="translated">POSIX는 &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; 및 FreeBSD 확장명 &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; 및 &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; 를 제공했습니다. 플래그는 기본 C 구조와보다 복잡한 상호 작용을 포함하므로 Perl 버전에서는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="12f49e309bec425066fcc1d87a34c78738358c28" translate="yes" xml:space="preserve">
          <source>The POSIX provided &lt;code&gt;GLOB_APPEND&lt;/code&gt;, &lt;code&gt;GLOB_DOOFFS&lt;/code&gt;, and the FreeBSD extensions &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt;, and &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; flags have not been implemented in the Perl version because they involve more complex interaction with the underlying C structures.</source>
          <target state="translated">POSIX는 &lt;code&gt;GLOB_APPEND&lt;/code&gt; , &lt;code&gt;GLOB_DOOFFS&lt;/code&gt; , FreeBSD 확장 &lt;code&gt;GLOB_ALTDIRFUNC&lt;/code&gt; , &lt;code&gt;GLOB_MAGCHAR&lt;/code&gt; 플래그는 기본 C 구조와의 더 복잡한 상호 작용을 포함하기 때문에 Perl 버전에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a0d47d53c93142215e84e50218c868cd954904f3" translate="yes" xml:space="preserve">
          <source>The POSIX::strftime() approach has the benefit of being, in theory, independent of the current locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for details.</source>
          <target state="translated">POSIX :: strftime () 접근 방식은 이론적으로 현재 로케일과 무관 한 이점이 있습니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4be5af1b8c4f7ec96a716021937a3c9561f2d5c" translate="yes" xml:space="preserve">
          <source>The POSTCALL: Keyword</source>
          <target state="translated">POSTCALL : 키워드</target>
        </trans-unit>
        <trans-unit id="58e421a82995ac1225598edc3f8a16b394004724" translate="yes" xml:space="preserve">
          <source>The POSTCALL: block does not make a lot of sense when the C subroutine call is supplied by user by providing either CODE: or PPCODE: section.</source>
          <target state="translated">POSTCALL : 블록은 CODE : 또는 PPCODE : 섹션을 제공하여 사용자가 C 서브 루틴 호출을 제공 할 때 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b336bc59359478eb80f69f21fc081230df6f7578" translate="yes" xml:space="preserve">
          <source>The PPCODE: Keyword</source>
          <target state="translated">PPCODE : 키워드</target>
        </trans-unit>
        <trans-unit id="cfd48109a24f72ee93cb2960e4b31f2a2958e886" translate="yes" xml:space="preserve">
          <source>The PPCODE: keyword is an alternate form of the CODE: keyword and is used to tell the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the programmer is supplying the code to control the argument stack for the XSUBs return values. Occasionally one will want an XSUB to return a list of values rather than a single value. In these cases one must use PPCODE: and then explicitly push the list of values on the stack. The PPCODE: and CODE: keywords should not be used together within the same XSUB.</source>
          <target state="translated">PPCODE : 키워드는 CODE : 키워드의 대체 형식이며 &lt;b&gt;xsubpp&lt;/b&gt; 를 알려주는 데 사용됩니다.&lt;b&gt;&lt;/b&gt; 컴파일러 XSUB 반환 값에 대한 인수 스택을 제어하는 ​​코드를 제공하고 있음을 컴파일러 됩니다. 때때로 XSUB가 단일 값이 아닌 값 목록을 반환하기를 원할 것입니다. 이 경우 PPCODE :를 사용해야합니다. 그런 다음 스택에서 값 목록을 명시 적으로 푸시하십시오. PPCODE : 및 CODE : 키워드는 동일한 XSUB 내에서 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7f4e638293474e32a1342be9b48c14f4f2f5af" translate="yes" xml:space="preserve">
          <source>The PREFIX Keyword</source>
          <target state="translated">PREFIX 키워드</target>
        </trans-unit>
        <trans-unit id="52a603903d899ccd2bb20a31b53d728d154bd0a6" translate="yes" xml:space="preserve">
          <source>The PREFIX keyword designates prefixes which should be removed from the Perl function names. If the C function is &lt;code&gt;rpcb_gettime()&lt;/code&gt; and the PREFIX value is &lt;code&gt;rpcb_&lt;/code&gt; then Perl will see this function as &lt;code&gt;gettime()&lt;/code&gt; .</source>
          <target state="translated">PREFIX 키워드는 Perl 함수 이름에서 제거해야하는 접 두부를 지정합니다. C 함수가 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 이고 PREFIX 값이 &lt;code&gt;rpcb_&lt;/code&gt; 이면 Perl은이 함수를 &lt;code&gt;gettime()&lt;/code&gt; 로 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="60c73f19592a380d6edab54152586445dff98315" translate="yes" xml:space="preserve">
          <source>The PREFIX keyword designates prefixes which should be removed from the Perl function names. If the C function is &lt;code&gt;rpcb_gettime()&lt;/code&gt; and the PREFIX value is &lt;code&gt;rpcb_&lt;/code&gt; then Perl will see this function as &lt;code&gt;gettime()&lt;/code&gt;.</source>
          <target state="translated">PREFIX 키워드는 Perl 함수 이름에서 제거되어야하는 접 두부를 지정합니다. C 함수가 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 이고 PREFIX 값이 &lt;code&gt;rpcb_&lt;/code&gt; 이면 Perl은이 함수를 &lt;code&gt;gettime()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="88877bb4605c88019ee2001796614ad12f854190" translate="yes" xml:space="preserve">
          <source>The PREINIT: Keyword</source>
          <target state="translated">PREINIT : 키워드</target>
        </trans-unit>
        <trans-unit id="81434e6a015b3cc52c205c8d0096aa1b8047f180" translate="yes" xml:space="preserve">
          <source>The PREINIT: keyword allows extra variables to be declared immediately before or after the declarations of the parameters from the INPUT: section are emitted.</source>
          <target state="translated">PREINIT : 키워드를 사용하면 INPUT : 섹션에서 매개 변수 선언 직전 또는 직후에 추가 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7bb955840f60bbf203155b0452f242dc963bed" translate="yes" xml:space="preserve">
          <source>The PROTOTYPE: Keyword</source>
          <target state="translated">프로토 타입 : 키워드</target>
        </trans-unit>
        <trans-unit id="88332a599c2ebe7acc31d1e6540ad41d11fdae24" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: Keyword</source>
          <target state="translated">프로토 타입 : 키워드</target>
        </trans-unit>
        <trans-unit id="786dd0fb60abbd3d46b59d9c05e8332c26b0f79b" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-prototypes&lt;/code&gt; and &lt;code&gt;-noprototypes&lt;/code&gt; options. This keyword overrides the command line options. Prototypes are disabled by default. When prototypes are enabled, XSUBs will be given Perl prototypes. This keyword may be used multiple times in an XS module to enable and disable prototypes for different parts of the module. Note that &lt;b&gt;xsubpp&lt;/b&gt; will nag you if you don't explicitly enable or disable prototypes, with:</source>
          <target state="translated">PROTOTYPES : 키워드는 &lt;b&gt;xsubpp&lt;/b&gt; 의 &lt;code&gt;-prototypes&lt;/code&gt; 및 &lt;code&gt;-noprototypes&lt;/code&gt; 옵션에 해당합니다. 이 키워드는 명령 줄 옵션을 재정의합니다. 프로토 타입은 기본적으로 비활성화되어 있습니다. 프로토 타입이 활성화되면 XSUB에 Perl 프로토 타입이 제공됩니다. 이 키워드는 XS 모듈에서 여러 번 사용하여 모듈의 다른 부분에 대한 프로토 타입을 활성화 및 비활성화 할 수 있습니다. 다음 과 같이 프로토 타입을 명시 적으로 활성화 또는 비활성화하지 않으면 &lt;b&gt;xsubpp&lt;/b&gt; 가 잔소리를합니다.</target>
        </trans-unit>
        <trans-unit id="4762c608488c900a25e5c9ce4a388703783fff72" translate="yes" xml:space="preserve">
          <source>The PROTOTYPES: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-prototypes&lt;/code&gt; and &lt;code&gt;-noprototypes&lt;/code&gt; options. This keyword overrides the command line options. Prototypes are enabled by default. When prototypes are enabled XSUBs will be given Perl prototypes. This keyword may be used multiple times in an XS module to enable and disable prototypes for different parts of the module.</source>
          <target state="translated">PROTOTYPES : 키워드는 &lt;b&gt;xsubpp&lt;/b&gt; 의 &lt;code&gt;-prototypes&lt;/code&gt; 및 &lt;code&gt;-noprototypes&lt;/code&gt; 옵션에 해당합니다. 이 키워드는 명령 행 옵션을 대체합니다. 프로토 타입은 기본적으로 활성화되어 있습니다. 프로토 타입이 활성화되면 XSUB에 Perl 프로토 타입이 제공됩니다. 이 키워드는 XS 모듈에서 여러 번 사용되어 모듈의 다른 부분에 대한 프로토 타입을 활성화 및 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8858e68caca79cf42ddd4c6888db50a3b0e45380" translate="yes" xml:space="preserve">
          <source>The PV of &lt;code&gt;sv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 의 PV 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="32ef6835ed63a718cf287a36ed5a59d894d8bfe4" translate="yes" xml:space="preserve">
          <source>The PV of the sv is returned.</source>
          <target state="translated">sv의 PV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbea6ce0d8ba0f98747339e84eb8596aa1948b13" translate="yes" xml:space="preserve">
          <source>The Perl 5 core includes mechanisms to help porters make backwards incompatible changes more compatible such as the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; modules. Please use them when appropriate.</source>
          <target state="translated">Perl 5 코어에는 포터가 이전 버전과 호환되지 않는 변경 사항을 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 및 &lt;a href=&quot;deprecate&quot;&gt;더 이상 사용하지 않는&lt;/a&gt; 모듈 과 같이 호환 가능하게하는 메커니즘이 포함되어 있습니다. 적절한 경우 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bab276840135536c5b050850ebb3b382c1feec45" translate="yes" xml:space="preserve">
          <source>The Perl 5 smartmatch and &lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; constructs are not compatible with their Perl 6 analogues. The most visible difference and least important difference is that, in Perl 5, parentheses are required around the argument to &lt;code&gt;given()&lt;/code&gt; and &lt;code&gt;when()&lt;/code&gt; (except when this last one is used as a statement modifier). Parentheses in Perl 6 are always optional in a control construct such as &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; , or &lt;code&gt;when()&lt;/code&gt; ; they can't be made optional in Perl 5 without a great deal of potential confusion, because Perl 5 would parse the expression</source>
          <target state="translated">Perl 5 스마트 매치와 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 구성은 Perl 6 아날로그와 호환되지 않습니다. 가장 눈에 띄는 차이점과 가장 중요한 차이점은 Perl 5에서 &lt;code&gt;given()&lt;/code&gt; 및 &lt;code&gt;when()&lt;/code&gt; 대한 인수 주위에 괄호가 필요하다는 것입니다 (마지막 수정자가 명령문 수정 자로 사용될 때 제외). Perl 6의 괄호는 &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; 또는 &lt;code&gt;when()&lt;/code&gt; 과 같은 제어 구문에서 항상 선택 사항입니다 . Perl 5는 표현을 파싱하기 때문에 잠재적 인 혼란이없이 Perl 5에서 선택적으로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09286d90028a2a377ed6e40ea8180db0174df9c4" translate="yes" xml:space="preserve">
          <source>The Perl 5 smartmatch and &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; constructs are not compatible with their Raku analogues. The most visible difference and least important difference is that, in Perl 5, parentheses are required around the argument to &lt;code&gt;given()&lt;/code&gt; and &lt;code&gt;when()&lt;/code&gt; (except when this last one is used as a statement modifier). Parentheses in Raku are always optional in a control construct such as &lt;code&gt;if()&lt;/code&gt;, &lt;code&gt;while()&lt;/code&gt;, or &lt;code&gt;when()&lt;/code&gt;; they can't be made optional in Perl 5 without a great deal of potential confusion, because Perl 5 would parse the expression</source>
          <target state="translated">Perl 5 스마트 매치 및 &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 구조가 Raku 아날로그와 호환되지 않습니다. 가장 눈에 띄는 차이점과 가장 덜 중요한 차이점은 Perl 5에서 &lt;code&gt;given()&lt;/code&gt; 및 &lt;code&gt;when()&lt;/code&gt; 대한 인수 주위에 괄호가 필요하다는 것입니다 (이 마지막 항목이 문 수정 자로 사용되는 경우 제외). Raku의 괄호는 &lt;code&gt;if()&lt;/code&gt; , &lt;code&gt;while()&lt;/code&gt; 또는 &lt;code&gt;when()&lt;/code&gt; 과 같은 제어 구문에서 항상 선택 사항입니다 . Perl 5는 표현식을 구문 분석하기 때문에 잠재적 인 혼란없이 Perl 5에서 선택 사항으로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d32638db8a1c22afb3b560c2715ac8287958e39" translate="yes" xml:space="preserve">
          <source>The Perl 5 source code is available at &amp;lt;&lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;&amp;gt; and ExtUtils-CBuilder may be found in the</source>
          <target state="translated">Perl 5 소스 코드는 &amp;lt; &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt; &amp;gt; 에서 구할 수 있으며 ExtUtils-CBuilder는</target>
        </trans-unit>
        <trans-unit id="57bf9707107e60b120163b520432b9abfd308a24" translate="yes" xml:space="preserve">
          <source>The Perl 5 source code is available at &lt;a href=&quot;https://perl5.git.perl.org/perl.git&quot;&gt;https://perl5.git.perl.org/perl.git&lt;/a&gt; and ExtUtils-CBuilder may be found in the</source>
          <target state="translated">Perl 5 소스 코드는 &lt;a href=&quot;https://perl5.git.perl.org/perl.git&quot;&gt;https://perl5.git.perl.org/perl.git&lt;/a&gt; 에서 사용할 수 있으며 ExtUtils-CBuilder는</target>
        </trans-unit>
        <trans-unit id="afeaca8df1b6424181f3a66ccbb3b6382d64c41b" translate="yes" xml:space="preserve">
          <source>The Perl API changes over time. New functions are added or the interfaces of existing functions are changed. The &lt;code&gt;Devel::PPPort&lt;/code&gt; module tries to provide compatibility code for some of these changes, so XS writers don't have to code it themselves when supporting multiple versions of Perl.</source>
          <target state="translated">Perl API는 시간이 지남에 따라 변경됩니다. 새로운 기능이 추가되거나 기존 기능의 인터페이스가 변경됩니다. &lt;code&gt;Devel::PPPort&lt;/code&gt; 펄의 여러 버전을 지원할 때 XS 작가는 코드 그 자체를하지 않아도 모듈은 이러한 변경 사항 중 일부에 대한 호환성 코드를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b3ddaaeb977cd171a0809e4c9d46db7115a9f674" translate="yes" xml:space="preserve">
          <source>The Perl Archive Toolkit ( &lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt; ) is Perl's analog to Java's JAR. It's freely available and on CPAN ( &lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt; ).</source>
          <target state="translated">Perl Archive Toolkit ( &lt;a href=&quot;http://par.perl.org/&quot;&gt;http://par.perl.org/&lt;/a&gt; )은 Perl의 Java JAR과 유사합니다. CPAN ( &lt;a href=&quot;http://search.cpan.org/dist/PAR/&quot;&gt;http://search.cpan.org/dist/PAR/&lt;/a&gt; ) 에서 무료로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="473f038dad9f7fe5ef22d5db4b0f0781bb1b2cfd" translate="yes" xml:space="preserve">
          <source>The Perl Archive Toolkit is Perl's analog to Java's JAR. It's freely available and on CPAN ( &lt;a href=&quot;https://metacpan.org/pod/PAR&quot;&gt;https://metacpan.org/pod/PAR&lt;/a&gt; ).</source>
          <target state="translated">Perl Archive Toolkit은 Perl의 Java JAR과 유사합니다. CPAN ( &lt;a href=&quot;https://metacpan.org/pod/PAR&quot;&gt;https://metacpan.org/pod/PAR&lt;/a&gt; ) 에서 무료로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f01c36b942223cd02d483b2f8710a5fcbe7b3f1a" translate="yes" xml:space="preserve">
          <source>The Perl Authors Upload SErver (&lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;), the gateway for &lt;b&gt;modules&lt;/b&gt; on their way to &lt;b&gt;CPAN&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;CPAN&lt;/b&gt; 으로가는 &lt;b&gt;모듈&lt;/b&gt; 의 게이트웨이 인 Perl Authors Upload SErver ( &lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt; ) .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b633506d32991c982d57371e8ff5e8e620c6651c" translate="yes" xml:space="preserve">
          <source>The Perl Compiler Backend</source>
          <target state="translated">펄 컴파일러 백엔드</target>
        </trans-unit>
        <trans-unit id="528f579664ac974a57416a02a9f4d6f1fb344d5b" translate="yes" xml:space="preserve">
          <source>The Perl DLL is installed in \System\Libs\. The Perl libraries and extension DLLs are installed in \System\Libs\Perl\X.Y.Z\. The PerlApp is installed in \System\Apps\, and the SIS also installs a couple of demo scripts in \Perl\ (C:\Mydocs\Perl\ on Nokia 7710).</source>
          <target state="translated">Perl DLL은 \ System \ Libs \에 설치됩니다. Perl 라이브러리 및 확장 DLL은 \ System \ Libs \ Perl \ XYZ \에 설치됩니다. PerlApp은 \ System \ Apps \에 설치되며 SIS는 \ Perl \ (Nokia 7710의 C : \ Mydocs \ Perl \)에 몇 개의 데모 스크립트도 설치합니다.</target>
        </trans-unit>
        <trans-unit id="b0d4827468980c5df0784a8af4ce7848ecde4b66" translate="yes" xml:space="preserve">
          <source>The Perl Debugger</source>
          <target state="translated">펄 디버거</target>
        </trans-unit>
        <trans-unit id="003a86b939921d18b908afadb31a1624a5c158e1" translate="yes" xml:space="preserve">
          <source>The Perl Dev Kit ( &lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt; ) from ActiveState can &quot;Turn your Perl programs into ready-to-run executables for HP-UX, Linux, Solaris and Windows.&quot;</source>
          <target state="translated">ActiveState 의 Perl Dev Kit ( &lt;a href=&quot;http://www.activestate.com/Products/Perl_Dev_Kit/&quot;&gt;http://www.activestate.com/Products/Perl_Dev_Kit/&lt;/a&gt; )는 &quot;Perl 프로그램을 HP-UX, Linux, Solaris 및 Windows 용 실행 가능한 실행 파일로 전환 할 수 있습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="1c56af5a226a11b5977e777d4fb79e3fb6c794f9" translate="yes" xml:space="preserve">
          <source>The Perl Forked Debugger</source>
          <target state="translated">펄 포크 디버거</target>
        </trans-unit>
        <trans-unit id="076abbe7cec0580634f13cf92571ce869da1bf79" translate="yes" xml:space="preserve">
          <source>The Perl Foundation is an advocacy organization for the Perl language which maintains the web site &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; as a general advocacy site for the Perl language. It uses the domain to provide general support services to the Perl community, including the hosting of mailing lists, web sites, and other services. There are also many other sub-domains for special topics like learning Perl and jobs in Perl, such as:</source>
          <target state="translated">Perl Foundation은 Perl 언어의 옹호 조직으로서 웹 사이트 &lt;a href=&quot;http://www.perl.org/&quot;&gt;http://www.perl.org/&lt;/a&gt; 를 Perl 언어의 일반 옹호 사이트로 유지합니다 . 도메인을 사용하여 메일 목록, 웹 사이트 및 기타 서비스 호스팅을 포함하여 Perl 커뮤니티에 일반 지원 서비스를 제공합니다. Perl 학습 및 Perl에서의 작업과 같은 특수 주제에 대한 다른 많은 하위 도메인도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d177a21aa5a9fba680e844771ded5bc126e66e5c" translate="yes" xml:space="preserve">
          <source>The Perl Journal</source>
          <target state="translated">펄 저널</target>
        </trans-unit>
        <trans-unit id="b540cf823fa7d059f14c61e7a0646ec955faa0d9" translate="yes" xml:space="preserve">
          <source>The Perl Profiler</source>
          <target state="translated">펄 프로파일 러</target>
        </trans-unit>
        <trans-unit id="b016030ffb60704d0c5d1297b6257d8c67a0ebea" translate="yes" xml:space="preserve">
          <source>The Perl Review, &lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt; maintains a website and Google calendar (&lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt;) for tracking workshops, hackathons, Perl Mongers meetings, and other events. Views of this calendar are at &lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt; and &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org&lt;/a&gt;.</source>
          <target state="translated">Perl Review, &lt;a href=&quot;http://www.theperlreview.com&quot;&gt;http://www.theperlreview.com&lt;/a&gt; 은 워크숍, 해커 톤, ​​Perl Mongers 미팅 및 기타 이벤트를 추적 하기위한 웹 사이트 및 Google 캘린더 ( &lt;a href=&quot;http://www.theperlreview.com/community_calendar&quot;&gt;http://www.theperlreview.com/community_calendar&lt;/a&gt; )를 유지 관리 합니다. 이 달력은 &lt;a href=&quot;http://www.perl.org/events.html&quot;&gt;http://www.perl.org/events.html&lt;/a&gt; 및 &lt;a href=&quot;http://www.yapc.org&quot;&gt;http://www.yapc.org에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6955a584a390227f3bb9df6a8ce1cb0fe482186c" translate="yes" xml:space="preserve">
          <source>The Perl argument stack is used to store the values which are sent as parameters to the XSUB and to store the XSUB's return value(s). In reality all Perl functions (including non-XSUB ones) keep their values on this stack all the same time, each limited to its own range of positions on the stack. In this document the first position on that stack which belongs to the active function will be referred to as position 0 for that function.</source>
          <target state="translated">Perl 인수 스택은 XSUB에 매개 변수로 전송 된 값을 저장하고 XSUB의 리턴 값을 저장하는 데 사용됩니다. 실제로 모든 Perl 함수 (XSUB 이외의 함수 포함)는이 스택에서 값을 항상 같은 시간에 유지합니다. 각 스택은 스택의 고유 한 위치 범위로 제한됩니다. 이 문서에서는 활성 기능에 속하는 스택의 첫 번째 위치를 해당 기능의 위치 0이라고합니다.</target>
        </trans-unit>
        <trans-unit id="757030d94cb8509fb2a87930fca0f3a3c3c2e5dc" translate="yes" xml:space="preserve">
          <source>The Perl build system on *nix-like systems starts with the</source>
          <target state="translated">* nix 계열 시스템의 Perl 빌드 시스템은</target>
        </trans-unit>
        <trans-unit id="1afd605920f29e13092c6aa9a01dbc8ba4878de1" translate="yes" xml:space="preserve">
          <source>The Perl build system starts with the</source>
          <target state="translated">Perl 빌드 시스템은</target>
        </trans-unit>
        <trans-unit id="a9258ba19bb8bd1578e5dbedb6897e00444b562d" translate="yes" xml:space="preserve">
          <source>The Perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">PerlIO.pm의 Perl 코드는 다음을 수행하여 계층을 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="337328dc6570faaca13781601b8dac575ac43697" translate="yes" xml:space="preserve">
          <source>The Perl community has a rather large IRC presence. For starters, it has its own IRC network, &lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc://irc.perl.org&lt;/a&gt;. General (not help-oriented) chat can be found at &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;. Many other more specific chats are also hosted on the network. Information about irc.perl.org is located on the network's website: &lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http://www.irc.perl.org&lt;/a&gt;. For a more help-oriented #perl, check out &lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt;irc://irc.freenode.net/#perl&lt;/a&gt;. Perl 6 development also has a presence in &lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc://irc.freenode.net/#perl6&lt;/a&gt;. Most Perl-related channels will be kind enough to point you in the right direction if you ask nicely.</source>
          <target state="translated">Perl 커뮤니티는 다소 큰 IRC 존재를 가지고 있습니다. 우선, 자체 IRC 네트워크 &lt;a href=&quot;irc://irc.perl.org&quot;&gt;irc : //irc.perl.org가&lt;/a&gt; 있습니다. &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc : //irc.perl.org/#perl&lt;/a&gt; 에서 일반 (도움말 중심이 아닌) 채팅을 찾을 수 있습니다 . 더 많은 다른 특정 채팅도 네트워크에서 호스팅됩니다. irc.perl.org에 대한 정보는 네트워크 웹 사이트 ( &lt;a href=&quot;http://www.irc.perl.org&quot;&gt;http://www.irc.perl.org)에&lt;/a&gt; 있습니다. 도움말 중심의 #perl을 확인하려면&lt;a href=&quot;irc://irc.freenode.net/#perl&quot;&gt; irc : //irc.freenode.net/#perl을&lt;/a&gt; . Perl 6 개발에는 &lt;a href=&quot;irc://irc.freenode.net/#perl6&quot;&gt;irc : //irc.freenode.net/#perl6도&lt;/a&gt; 있습니다. 대부분의 Perl 관련 채널은 친절하게 요청하면 올바른 방향으로 안내 할 수있을만큼 친절합니다.</target>
        </trans-unit>
        <trans-unit id="1e71a9470b64a2480ea7c8c2886a8ca9bc8c982c" translate="yes" xml:space="preserve">
          <source>The Perl community is as diverse as Perl, and there is a large amount of evidence that the Perl users apply TMTOWTDI to all endeavors, not just programming. From websites, to IRC, to mailing lists, there is more than one way to get involved in the community.</source>
          <target state="translated">Perl 커뮤니티는 Perl만큼 다양하며 Perl 사용자가 프로그래밍뿐만 아니라 모든 노력에 TMTOWTDI를 적용한다는 많은 증거가 있습니다. 웹 사이트, IRC, 메일 목록에 이르기까지 커뮤니티에 참여하는 방법은 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75fca85980fcb62b1837d386b956468cb5d6629f" translate="yes" xml:space="preserve">
          <source>The Perl community is geared toward supporting the most recent releases, so you'll have an easier time finding help for those.</source>
          <target state="translated">Perl 커뮤니티는 최신 릴리스를 지원하도록 설계되었으므로보다 쉽게 ​​도움을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660fe5fd6a64acb9219ffd0837bb1e282e990fa7" translate="yes" xml:space="preserve">
          <source>The Perl core has an extensive test suite. If you add new tests (or new modules with tests), you may need to update the</source>
          <target state="translated">Perl 코어에는 광범위한 테스트 스위트가 있습니다. 새 테스트 (또는 테스트가 포함 된 새 모듈)를 추가하는 경우</target>
        </trans-unit>
        <trans-unit id="8f13ce29b0232702f230a3b4d47d029f48d1ff8a" translate="yes" xml:space="preserve">
          <source>The Perl core uses a handful of keys in &lt;code&gt;%^H&lt;/code&gt; which do not follow this convention, because they predate it. Keys that follow the convention won't conflict with the core's historical keys.</source>
          <target state="translated">Perl 코어는 &lt;code&gt;%^H&lt;/code&gt; 의 소수 키를 사용합니다. 이전 규칙을 따르지 않기 때문에이 규칙을 따르지 않습니다. 컨벤션을 따르는 키는 코어의 히스토리 키와 충돌하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40fdaea2f094775674cd40eee5e41200dd9b0a76" translate="yes" xml:space="preserve">
          <source>The Perl development team are called Perl 5 Porters, and their organization is described at &lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html&lt;/a&gt;. The organizational rules really just boil down to one: Larry is always right, even when he was wrong.</source>
          <target state="translated">Perl 개발 팀은 Perl 5 Porters라고하며 조직은 &lt;a href=&quot;http://perldoc.perl.org/perlpolicy.html&quot;&gt;http://perldoc.perl.org/perlpolicy.html에&lt;/a&gt; 설명되어 있습니다 . 있습니다. 조직의 규칙은 실제로 한 가지로 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="85f7977946f345bcbaa5f5a8afb688bfb2d58512" translate="yes" xml:space="preserve">
          <source>The Perl development team occasionally make changes to the internal core of the language, but all possible efforts are made toward backward compatibility.</source>
          <target state="translated">Perl 개발 팀은 때때로 언어의 내부 핵심을 변경하지만 가능한 모든 노력은 이전 버전과의 호환성을 위해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="bef6ea773b29bc42d6bc39580b413ba88c9c2941" translate="yes" xml:space="preserve">
          <source>The Perl engine/interpreter and the host are orthogonal entities. There could be one or more interpreters in a process, and one or more &quot;hosts&quot;, with free association between them.</source>
          <target state="translated">Perl 엔진 / 통역사 및 호스트는 직교 엔티티입니다. 프로세스에 하나 이상의 통역사가있을 수 있고, 하나 이상의 &quot;호스트&quot;가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be2ab355cd62828f3bbc09e8a520aa45842fe8c2" translate="yes" xml:space="preserve">
          <source>The Perl equivalent for this is &lt;code&gt;$#myarray&lt;/code&gt; .</source>
          <target state="translated">이것과 동등한 Perl은 &lt;code&gt;$#myarray&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2c47ceb12a208fd04ecb769532f606625e8320e" translate="yes" xml:space="preserve">
          <source>The Perl equivalent for this is &lt;code&gt;$#myarray&lt;/code&gt;.</source>
          <target state="translated">이에 상응하는 Perl은 &lt;code&gt;$#myarray&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1cde81a2f242b3582034df0f4319a7432d51e97" translate="yes" xml:space="preserve">
          <source>The Perl error from the last &lt;code&gt;eval&lt;/code&gt; operator, i.e. the last exception that was caught. For &lt;code&gt;eval BLOCK&lt;/code&gt;, this is either a runtime error message or the string or reference &lt;code&gt;die&lt;/code&gt; was called with. The &lt;code&gt;eval STRING&lt;/code&gt; form also catches syntax errors and other compile time exceptions.</source>
          <target state="translated">마지막 &lt;code&gt;eval&lt;/code&gt; 연산자 의 Perl 오류 , 즉 발견 된 마지막 예외입니다. 들면 &lt;code&gt;eval BLOCK&lt;/code&gt; , 이것은 런타임 에러 메시지 또는 문자열 또는 참조이거나 &lt;code&gt;die&lt;/code&gt; 불려 하였다. &lt;code&gt;eval STRING&lt;/code&gt; 형태는 구문 오류 및 기타 컴파일 시간 예외를 잡는다.</target>
        </trans-unit>
        <trans-unit id="3bbb1426c72d3038d784b1de2b64c8aea8f60fd1" translate="yes" xml:space="preserve">
          <source>The Perl executables can be easily rebuilt at any moment. Moreover, one can use the</source>
          <target state="translated">Perl 실행 파일은 언제든지 쉽게 재 구축 할 수 있습니다. 또한, 하나를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d136d03bdd5714dfcd154602e7c27ff31ede4518" translate="yes" xml:space="preserve">
          <source>The Perl forked debugger places the debugger commands and output in a separate X-11 terminal window so that commands and output from multiple processes are not mixed together.</source>
          <target state="translated">Perl forked 디버거는 디버거 명령과 출력을 별도의 X-11 터미널 창에 배치하므로 여러 프로세스의 명령과 출력이 함께 혼합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa02d08b07357f1b109729d24eaf520757219ddc" translate="yes" xml:space="preserve">
          <source>The Perl functions for dealing with sockets have the same names as the corresponding system calls in C, but their arguments tend to differ for two reasons. First, Perl filehandles work differently than C file descriptors. Second, Perl already knows the length of its strings, so you don't need to pass that information.</source>
          <target state="translated">소켓을 다루기위한 Perl 함수는 C의 해당 시스템 호출과 동일한 이름을 갖지만, 인수는 두 가지 이유로 다른 경향이 있습니다. 먼저, Perl 파일 핸들은 C 파일 디스크립터와 다르게 작동합니다. 둘째, Perl은 이미 문자열의 길이를 알고 있으므로 해당 정보를 전달할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="92147dd8f1d29e8ce474756b4726d9b1d8e42e16" translate="yes" xml:space="preserve">
          <source>The Perl interface was written by Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;, and is released under the artistic license. Further modifications were made by Greg Bacon &amp;lt;gbacon@cs.uah.edu&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;, and Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;. The C glob code has the following copyright:</source>
          <target state="translated">Perl 인터페이스는 Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;이 작성했으며 예술적 라이센스에 따라 배포됩니다. Greg Bacon &amp;lt;gbacon@cs.uah.edu&amp;gt;, Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt; 및 Thomas Wegner &amp;lt;wegner_thomas@yahoo.com&amp;gt;에 의해 추가 수정되었습니다. C 글로브 코드에는 다음과 같은 저작권이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99bc4ac3d59eed09e1d0f94b3a3f01535d2fc89d" translate="yes" xml:space="preserve">
          <source>The Perl interpreter can be regarded as a closed box: it has an API for feeding it code or otherwise making it do things, but it also has functions for its own use. This smells a lot like an object, and there are ways for you to build Perl so that you can have multiple interpreters, with one interpreter represented either as a C structure, or inside a thread-specific structure. These structures contain all the context, the state of that interpreter.</source>
          <target state="translated">Perl 인터프리터는 닫힌 상자로 간주 될 수 있습니다. 코드를 공급하거나 작업을 수행하기위한 API가 있지만 자체 사용 기능도 있습니다. 이것은 객체처럼 냄새가 나며 Perl을 빌드하여 여러 개의 인터프리터를 가질 수있는 방법이 있습니다. 하나의 인터프리터가 C 구조 또는 스레드 특정 구조로 표시됩니다. 이러한 구조에는 해당 컨텍스트의 모든 컨텍스트, 해당 인터프리터의 상태가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec97d45bb2f6ea56e5a238f738362154db298f5" translate="yes" xml:space="preserve">
          <source>The Perl logo is a trademark of the Perl Foundation.</source>
          <target state="translated">Perl 로고는 Perl Foundation의 상표입니다.</target>
        </trans-unit>
        <trans-unit id="6b8a4b8bd5fc4d36250e80003bd49d95bed77a10" translate="yes" xml:space="preserve">
          <source>The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. (Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.)</source>
          <target state="translated">함수 호출 및 반환 값에 대한 Perl 모델은 간단합니다. 모든 함수는 하나의 단일 스칼라 목록으로 매개 변수로 전달되며 모든 함수는 마찬가지로 단일 단일 스칼라 목록으로 호출자에게 리턴됩니다. 이 호출 및 반환 목록의 배열 또는 해시는 ID를 잃어 버릴 것입니다. 그러나이를 피하기 위해 항상 참조로 전달을 사용할 수 있습니다. 호출리스트와 리턴리스트 모두 원하는만큼의 스칼라 요소를 포함 할 수 있습니다. (종종 명시적인 return 문이없는 함수를 서브 루틴이라고하지만 실제로 Perl의 관점에는 차이가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="b9ee0cf4ab63cf1be081346d4784ae92aedc21e4" translate="yes" xml:space="preserve">
          <source>The Perl motto is &quot;There's more than one way to do it.&quot; Divining how many more is left as an exercise to the reader.</source>
          <target state="translated">펄 좌우명은 &quot;한 가지 이상의 방법이있다&quot;는 것이다. 독자에게 연습으로 남은 횟수를 몇 가지로 나누십시오.</target>
        </trans-unit>
        <trans-unit id="b25f4bf878cf14a357970d887adcbf624e87e118" translate="yes" xml:space="preserve">
          <source>The Perl parser will expand $variable and @variable references in regular expressions unless the delimiter is a single quote. Remember, too, that the right-hand side of a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution is considered a double-quoted string (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). Remember also that any regex special characters will be acted on unless you precede the substitution with \Q. Here's an example:</source>
          <target state="translated">구분 기호가 작은 따옴표가 아닌 경우 Perl 파서는 정규식에서 $ variable 및 @variable 참조를 확장합니다. 또한 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 치환 의 오른쪽 은 큰 따옴표로 묶인 문자열로 간주됩니다 ( 자세한 내용 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조). \ Q로 대체하기 전에는 정규 표현식 특수 문자가 작동한다는 점도 기억하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bb23a0f0b6dd49dd4367abccbbe19ac7c297438" translate="yes" xml:space="preserve">
          <source>The Perl parser will expand $variable and @variable references in regular expressions unless the delimiter is a single quote. Remember, too, that the right-hand side of a &lt;code&gt;s///&lt;/code&gt; substitution is considered a double-quoted string (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). Remember also that any regex special characters will be acted on unless you precede the substitution with \Q. Here's an example:</source>
          <target state="translated">Perl 구문 분석기는 구분 기호가 작은 따옴표가 아닌 경우 정규식에서 $ variable 및 @variable 참조를 확장합니다. 또한 &lt;code&gt;s///&lt;/code&gt; 대체 의 오른쪽 은 큰 따옴표로 묶인 문자열로 간주 된다는 점을 기억하십시오 ( 자세한 내용 은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조). \ Q로 대체하지 않는 한 모든 정규식 특수 문자가 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bc52b1056fd349e5d759d3b05d91376e2d9a16e" translate="yes" xml:space="preserve">
          <source>The Perl port has been done for the most part using the Symbian standard POSIX-ish STDLIB library. It is a reasonably complete library, but certain corners of such emulation libraries that tend to be left unimplemented on non-UNIX platforms have been left unimplemented also this time: fork(), signals(), user/group ids, select() working for sockets, non-blocking sockets, and so forth. See the file</source>
          <target state="translated">Perl 포트는 대부분 Symbian 표준 POSIX-ish STDLIB 라이브러리를 사용하여 수행되었습니다. 합리적으로 완전한 라이브러리이지만 유닉스가 아닌 플랫폼에서 구현되지 않은 경향이있는 에뮬레이션 라이브러리의 특정 모서리는 이번에도 구현되지 않은 채로 있습니다 : fork (), 시그널 (), 사용자 / 그룹 ID, select () 작동 소켓, 비 차단 소켓 등에 사용됩니다. 파일보기</target>
        </trans-unit>
        <trans-unit id="b67868d8a32ed03bc87b830fb6a6b1a5f3f79a34" translate="yes" xml:space="preserve">
          <source>The Perl regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs give access to most of the Unicode character properties. The table below shows all these constructs, both single and compound forms.</source>
          <target state="translated">Perl 정규식 &lt;code&gt;\p{}&lt;/code&gt; 및 &lt;code&gt;\P{}&lt;/code&gt; 구문은 대부분의 유니 코드 문자 속성에 대한 액세스를 제공합니다. 아래 표는 단일 및 복합 형태의 모든 구성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f0e8425fc37fe67a70d8b01bf266a53e0f530848" translate="yes" xml:space="preserve">
          <source>The Perl source tree is big. Here's some of the thing you'll find in it:</source>
          <target state="translated">펄 소스 트리가 크다. 여기에 몇 가지 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0d4acb6c550a60d6a38a5a63678cce3e904bee" translate="yes" xml:space="preserve">
          <source>The Perl subroutine,</source>
          <target state="translated">Perl 서브 루틴</target>
        </trans-unit>
        <trans-unit id="df3a691d5cbb91293ddf18af01bb5af5f01bbb73" translate="yes" xml:space="preserve">
          <source>The Perl syntax error message from the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; operator. If &lt;code&gt;$@&lt;/code&gt; is the null string, the last &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; parsed and executed correctly (although the operations you invoked may have failed in the normal fashion).</source>
          <target state="translated">마지막 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 연산자 의 Perl 구문 오류 메시지입니다 . 경우 &lt;code&gt;$@&lt;/code&gt; 널 (null) 문자열입니다, 마지막 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 구문 분석 (당신이 호출 한 작업이 정상적인 방식으로 실패 할 수 있지만)이 올바르게 실행.</target>
        </trans-unit>
        <trans-unit id="968a791625fe0d4ef7287cb8aaab8e329d603dbe" translate="yes" xml:space="preserve">
          <source>The Perl test suite may still report some errors on the Hurd. The &quot;lib/anydbm&quot; and &quot;pragma/warnings&quot; tests will almost certainly fail. Both failures are not really specific to the Hurd, as indicated by the test suite output.</source>
          <target state="translated">Perl 테스트 스위트는 여전히 허드에서 일부 오류를보고 할 수 있습니다. &quot;lib / anydbm&quot;및 &quot;pragma / warnings&quot;테스트는 거의 실패 할 것입니다. 테스트 스위트 출력에서 ​​알 수 있듯이 두 실패 모두 실제로 허드에만 해당되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f6abf53e543be5d8676f05668af9e144a63af4c4" translate="yes" xml:space="preserve">
          <source>The Perl variables that are available for interpolation into typemaps are the following:</source>
          <target state="translated">타입 맵으로 보간 할 수있는 Perl 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bcd8c322dd20c222b91b35688318973e6596a5a" translate="yes" xml:space="preserve">
          <source>The Perl warning &quot;Wide character in ...&quot; is caused by such a character. With no specified encoding layer, Perl tries to fit things into a single byte. When it can't, it emits this warning (if warnings are enabled), and uses UTF-8 encoded data instead.</source>
          <target state="translated">Perl 경고 &quot;Wide character in ...&quot;는 이러한 문자로 인해 발생합니다. 지정된 인코딩 레이어가 없으면 Perl은 사물을 단일 바이트에 맞추려고합니다. 불가능한 경우이 경고가 발생하고 (경고가 활성화 된 경우) UTF-8로 인코딩 된 데이터를 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4d7feb5052b0fb54136f812ed2c2ffa2175dab42" translate="yes" xml:space="preserve">
          <source>The Perl-QA list attempted to ensure backwards compatibility with &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;. However, there are some minor differences.</source>
          <target state="translated">Perl-QA 목록은 &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; 와의 호환성을 보장하려고 시도했습니다 . 그러나 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4653a5c894c628131ce3248063452bdc6e7c23b1" translate="yes" xml:space="preserve">
          <source>The Perl-QA list attempted to ensure backwards compatibility with &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;. However, there are some minor differences.</source>
          <target state="translated">Perl-QA 목록은 &lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 와의 하위 호환성을 보장하려고 시도했습니다 . 그러나 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ec1c232da33c6ab26241322f9069a9704be0af" translate="yes" xml:space="preserve">
          <source>The PerlApp also is started when the &quot;Perl recognizer&quot; (also included and installed) detects a Perl file being activated through the GUI, and offers either to install it under \Perl (if the Perl file is in the inbox of the messaging application) or to run it (if the Perl file is under \Perl).</source>
          <target state="translated">PerlApp은 또한 &quot;Perl 인식기&quot;(포함 및 설치됨)가 GUI를 통해 활성화되는 Perl 파일을 감지하고 \ Perl 아래에 설치하도록 제안합니다 (Perl 파일이 메시징 응용 프로그램의받은 편지함에있는 경우). 또는 Perl 파일이 \ Perl 아래에있는 경우이를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c6111a686e0ef0ac50573a59b08dc1b8aeb3287a" translate="yes" xml:space="preserve">
          <source>The PerlApp application demonstrates how to embed Perl interpreters to a Symbian application. The &quot;Time&quot; menu item runs the following Perl code: &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , the &quot;Oneliner&quot; allows one to type in Perl code, and the &quot;Run&quot; opens a file chooser for selecting a Perl file to run.</source>
          <target state="translated">PerlApp 애플리케이션은 Perl 인터프리터를 Symbian 애플리케이션에 임베드하는 방법을 보여줍니다. &quot;Time&quot;메뉴 항목은 다음 Perl 코드를 실행합니다 : &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &quot;Running in &quot;, $^O, &quot;\n&quot;, &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , &quot;Oneliner&quot;를 사용하면 Perl 코드를 입력 할 수 있으며 &quot;Run&quot;은 파일을 엽니 다 실행할 Perl 파일을 선택하기위한 선택기.</target>
        </trans-unit>
        <trans-unit id="4d9adfc5463254f6fb18f709ce324c5c105cc49a" translate="yes" xml:space="preserve">
          <source>The PerlApp application demonstrates how to embed Perl interpreters to a Symbian application. The &quot;Time&quot; menu item runs the following Perl code: &lt;code&gt;print &quot;Running in &quot;, $^O, &quot;\n&quot;, scalar localtime&lt;/code&gt;, the &quot;Oneliner&quot; allows one to type in Perl code, and the &quot;Run&quot; opens a file chooser for selecting a Perl file to run.</source>
          <target state="translated">PerlApp 애플리케이션은 Perl 인터프리터를 Symbian 애플리케이션에 임베드하는 방법을 보여줍니다. &quot;Time&quot;메뉴 항목은 다음 Perl 코드를 실행합니다. &lt;code&gt;print &quot;Running in &quot;, $^O, &quot;\n&quot;, scalar localtime&lt;/code&gt; , &quot;Oneliner&quot;를 사용하면 Perl 코드를 입력 할 수 있으며 &quot;Run&quot;은 파일을 엽니 다. 실행할 Perl 파일을 선택하기위한 선택기.</target>
        </trans-unit>
        <trans-unit id="b43fd89b2979a98b7d902f7d0334218ba2ca529e" translate="yes" xml:space="preserve">
          <source>The PerlIO abstraction was introduced in perl5.003_02 but languished as just an abstraction until perl5.7.0. However during that time a number of perl extensions switched to using it, so the API is mostly fixed to maintain (source) compatibility.</source>
          <target state="translated">PerlIO 추상화는 perl5.003_02에 도입되었지만 perl5.7.0까지 추상화로 사라졌습니다. 그러나 그 기간 동안 많은 perl 확장이 그것을 사용하도록 전환했기 때문에 API는 대부분 (소스) 호환성을 유지하도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="43641046aefdabfa554afe6cf89fa8594b9147ac" translate="yes" xml:space="preserve">
          <source>The PerlIO is set to textmode. Use PerlIO_binmode if this is not the desired mode.</source>
          <target state="translated">PerlIO가 텍스트 모드로 설정되어 있습니다. 원하는 모드가 아닌 경우 PerlIO_binmode를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="df2a9946f78c97c4cb0379505dfaf42cfc784763" translate="yes" xml:space="preserve">
          <source>The PerlIO::via module allows you to develop PerlIO layers in Perl, without having to go into the nitty gritty of programming C with XS as the interface to Perl.</source>
          <target state="translated">PerlIO :: via 모듈을 사용하면 Perl의 인터페이스로 XS를 사용하여 C를 프로그래밍하는 데 어려움을 겪지 않고도 PerlIO에서 PerlIO 계층을 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b9d42402dbac92bb5f313095f98e57d920e008" translate="yes" xml:space="preserve">
          <source>The Pod format is not necessarily sufficient for writing a book. Pod is just meant to be an idiot-proof common source for nroff, HTML, TeX, and other markup languages, as used for online documentation. Translators exist for &lt;b&gt;pod2text&lt;/b&gt;, &lt;b&gt;pod2html&lt;/b&gt;, &lt;b&gt;pod2man&lt;/b&gt; (that's for nroff(1) and troff(1)), &lt;b&gt;pod2latex&lt;/b&gt;, and &lt;b&gt;pod2fm&lt;/b&gt;. Various others are available in CPAN.</source>
          <target state="translated">포드 형식이 책을 쓰기에 반드시 필요한 것은 아닙니다. 포드는 온라인 문서에 사용되는 nroff, HTML, TeX 및 기타 마크 업 언어에 대한 바보 방지 공통 소스입니다. &lt;b&gt;pod2text&lt;/b&gt; , &lt;b&gt;pod2html&lt;/b&gt; , &lt;b&gt;pod2man&lt;/b&gt; (nroff (1) 및 troff (1) 용), &lt;b&gt;pod2latex&lt;/b&gt; 및 &lt;b&gt;pod2fm&lt;/b&gt; 용 번역기가 존재합니다 . CPAN에는 다양한 다른 제품이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5181d340ea28e7004e1fc926376f0269c6a7af0c" translate="yes" xml:space="preserve">
          <source>The Pod parser normally expects to read octets and to convert those octets to characters based on the &lt;code&gt;=encoding&lt;/code&gt; declaration in the Pod source. Set this option to a true value to indicate that the Pod source is already a Perl character stream. This tells the parser to ignore any &lt;code&gt;=encoding&lt;/code&gt; command and to skip all the code paths involving decoding octets.</source>
          <target state="translated">포드 파서는 일반적으로 옥텟을 읽고 포드 소스 의 &lt;code&gt;=encoding&lt;/code&gt; 선언에 따라 옥텟을 문자로 변환 할 것으로 예상합니다 . 포드 소스가 이미 Perl 문자 스트림임을 나타내려면이 옵션을 true 값으로 설정하십시오. 이것은 파서에게 &lt;code&gt;=encoding&lt;/code&gt; 명령 을 무시하고 옥텟 디코딩과 관련된 모든 코드 경로를 건너 뛰 도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="d54e40195036f1a1a1b5551f96370345ff64638a" translate="yes" xml:space="preserve">
          <source>The Pod::Simple parser expects to read &lt;b&gt;octets&lt;/b&gt;. The parser will decode the octets into Perl's internal character string representation using the value of the &lt;code&gt;=encoding&lt;/code&gt; declaration in the POD source.</source>
          <target state="translated">Pod :: Simple 파서는 &lt;b&gt;octets&lt;/b&gt; 를 읽을 것으로 예상합니다 . 파서는 POD 소스에서 &lt;code&gt;=encoding&lt;/code&gt; 선언 값을 사용하여 옥텟을 Perl의 내부 문자열 표현으로 디코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="a52e0eb3298b4fa461fa923215cc1e681ac40256" translate="yes" xml:space="preserve">
          <source>The Pod::Usage distribution comes with a script pod2usage which offers a command line interface to the functionality of Pod::Usage. See &lt;a href=&quot;../pod2usage&quot;&gt;pod2usage&lt;/a&gt;.</source>
          <target state="translated">Pod :: Usage 배포에는 Pod :: Usage 기능에 대한 명령 줄 인터페이스를 제공하는 스크립트 pod2usage가 제공됩니다. &lt;a href=&quot;../pod2usage&quot;&gt;pod2usage를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="342da3224177ffce0c8476a7ad4ab61dce1236a8" translate="yes" xml:space="preserve">
          <source>The Pod::Usage distribution comes with a script pod2usage which offers a command line interface to the functionality of Pod::Usage. See &lt;a href=&quot;pod2usage&quot;&gt;pod2usage&lt;/a&gt;.</source>
          <target state="translated">Pod :: Usage 배포에는 Pod :: Usage의 기능에 대한 명령 줄 인터페이스를 제공하는 pod2usage 스크립트가 함께 제공됩니다. &lt;a href=&quot;pod2usage&quot;&gt;pod2usage를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27cf4d4fc397867d0e2a99e5b7bffdeae843c96c" translate="yes" xml:space="preserve">
          <source>The Portable Operating System Interface specification.</source>
          <target state="translated">휴대용 운영 체제 인터페이스 사양.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="a943a44dd922d7ce9eeb93393027ddca6e6855a1" translate="yes" xml:space="preserve">
          <source>The Proof in the Pudding: Localizing Web Sites</source>
          <target state="translated">푸딩의 증거 : 웹 사이트 현지화</target>
        </trans-unit>
        <trans-unit id="cca8ca027231a86237a6c4dda51f169cc4d16c32" translate="yes" xml:space="preserve">
          <source>The Pugs prototype Perl 6 Object Model uses C3</source>
          <target state="translated">퍼그 프로토 타입 Perl 6 오브젝트 모델은 C3를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="77d5d72ac418e20fd29b7eec3b6c8de1afc54920" translate="yes" xml:space="preserve">
          <source>The REGEXP struct is defined in</source>
          <target state="translated">REGEXP 구조체는</target>
        </trans-unit>
        <trans-unit id="2ad89d37eadf28843f6bcc04fe292798559736be" translate="yes" xml:space="preserve">
          <source>The REGEXP structure</source>
          <target state="translated">REGEXP 구조</target>
        </trans-unit>
        <trans-unit id="8da65302c118d1898dddaf19bb76877bb8166258" translate="yes" xml:space="preserve">
          <source>The REGEXP structure contains all the data that Perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that Perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts, such as if the pattern anchored in some way, or what flags were used during the compile, or if the program contains special constructs that Perl needs to be aware of.</source>
          <target state="translated">REGEXP 구조에는 정규 표현식을 올바르게 사용하기 위해 Perl이 알고 있어야하는 모든 데이터가 포함됩니다. 여기에는 Perl이 정규식 엔진을 실제로 사용해야하는지 여부를 결정하는 데 사용할 수있는 최적화에 대한 데이터와 패턴이 어떤 방식으로 고정되었는지 또는 어떤 플래그가 있는지 등 다양한 컨텍스트에서 패턴을 올바르게 실행하는 데 필요한 다양한 제어 정보가 포함됩니다. 컴파일 도중 또는 프로그램에 Perl이 알아야하는 특수한 구성이 포함 된 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6f38948819f825c1778442bfb0bf54fd236038" translate="yes" xml:space="preserve">
          <source>The REQUIRE: Keyword</source>
          <target state="translated">필요 : 키워드</target>
        </trans-unit>
        <trans-unit id="eb7911fb319180325559ab93300e4a8e754d4918" translate="yes" xml:space="preserve">
          <source>The REQUIRE: keyword is used to indicate the minimum version of the &lt;b&gt;xsubpp&lt;/b&gt; compiler needed to compile the XS module. An XS module which contains the following statement will compile with only &lt;b&gt;xsubpp&lt;/b&gt; version 1.922 or greater:</source>
          <target state="translated">REQUIRE : 키워드는 XS 모듈을 컴파일하는 데 필요한 &lt;b&gt;xsubpp&lt;/b&gt; 컴파일러 의 최소 ​​버전을 나타내는 데 사용됩니다 . 다음 명령문이 포함 된 XS 모듈은 &lt;b&gt;xsubpp&lt;/b&gt; 버전 1.922 이상 으로 만 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="325d9dc6bcb33887233fc6bb3fee83c1db779aa6" translate="yes" xml:space="preserve">
          <source>The RETVAL Variable</source>
          <target state="translated">RETVAL 변수</target>
        </trans-unit>
        <trans-unit id="2c001438878b5f3376fc8700b6556da0eb7ce7c1" translate="yes" xml:space="preserve">
          <source>The RETVAL variable is a special C variable that is declared automatically for you. The C type of RETVAL matches the return type of the C library function. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will declare this variable in each XSUB with non-&lt;code&gt;void&lt;/code&gt; return type. By default the generated C function will use RETVAL to hold the return value of the C library function being called. In simple cases the value of RETVAL will be placed in ST(0) of the argument stack where it can be received by Perl as the return value of the XSUB.</source>
          <target state="translated">RETVAL 변수는 자동으로 선언되는 특수 C 변수입니다. RETVAL의 C 유형은 C 라이브러리 함수의 리턴 유형과 일치합니다. &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러 비 각 XSUB이 변수를 선언한다 &lt;code&gt;void&lt;/code&gt; 반환형. 기본적으로 생성 된 C 함수는 RETVAL을 사용하여 호출중인 C 라이브러리 함수의 리턴 값을 보유합니다. 간단한 경우에 RETVAL의 값은 인수 스택의 ST (0)에 배치되며 여기서 Perl은 XSUB의 반환 값으로이를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5719fca838ea2f703064b736671d8a5c53c2b7c" translate="yes" xml:space="preserve">
          <source>The Ram is a cookbook with hundreds of examples of using Perl to accomplish specific tasks:</source>
          <target state="translated">Ram은 특정 작업을 수행하기 위해 Perl을 사용하는 수백 가지 예가 포함 된 요리 책입니다.</target>
        </trans-unit>
        <trans-unit id="bda5eb8009d503d3f7d7ac84a0313722c46a6dc4" translate="yes" xml:space="preserve">
          <source>The Rest</source>
          <target state="translated">나머지</target>
        </trans-unit>
        <trans-unit id="c06052540c4d2319036f128e767c17cbef7e664e" translate="yes" xml:space="preserve">
          <source>The Role of the typemap File in Your Distribution</source>
          <target state="translated">배포판에서 typemap 파일의 역할</target>
        </trans-unit>
        <trans-unit id="5afe900033efd0b8bef5b765a85f46485e313663" translate="yes" xml:space="preserve">
          <source>The SCOPE: Keyword</source>
          <target state="translated">범위 : 키워드</target>
        </trans-unit>
        <trans-unit id="3f77c1166b9eee5ec219ef962a60436e0a2f2130" translate="yes" xml:space="preserve">
          <source>The SCOPE: keyword allows scoping to be enabled for a particular XSUB. If enabled, the XSUB will invoke ENTER and LEAVE automatically.</source>
          <target state="translated">SCOPE : 키워드를 사용하면 특정 XSUB에 대해 범위를 사용할 수 있습니다. 활성화되면 XSUB는 ENTER와 LEAVE를 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3f3c8dbe377ba2fb462f83142477acc2c9fed9b5" translate="yes" xml:space="preserve">
          <source>The SEEK_* constants can be imported from the &lt;code&gt;Fcntl&lt;/code&gt; module if you don't wish to use the numbers &lt;code&gt;0&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; in your code.</source>
          <target state="translated">코드에서 숫자 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 를 사용하지 않으려면 &lt;code&gt;Fcntl&lt;/code&gt; 모듈 에서 SEEK_ * 상수를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d010c15a00d1737e8860874919af2b7673f8f8d1" translate="yes" xml:space="preserve">
          <source>The SPACE in the middle of the hex constant is illegal.</source>
          <target state="translated">16 진수 상수 중간에있는 SPACE는 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="6874e0e71dff8b677770e211cb23f7a0bc03af61" translate="yes" xml:space="preserve">
          <source>The STDIN filehandle used by the command is inherited from Perl's STDIN. For example:</source>
          <target state="translated">명령이 사용하는 STDIN 파일 핸들은 Perl의 STDIN에서 상속됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9698c556df2cef5c4ee4e944157366d894bd711" translate="yes" xml:space="preserve">
          <source>The SV arena serves the secondary purpose of allowing still-live SVs to be located and destroyed during final cleanup.</source>
          <target state="translated">SV 아레나는 최종 정리 중에 스틸 SV를 찾아 파괴 할 수 있도록하는 2 차 목적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="332365c51a56742e6dc7e2519268fd9ddbd41147" translate="yes" xml:space="preserve">
          <source>The SV is always returned containing an actual string, and with no other OK bits set. Unlike &lt;code&gt;$!&lt;/code&gt;, a message is even yielded for &lt;code&gt;errnum&lt;/code&gt; zero (meaning success), and if no useful message is available then a useless string (currently empty) is returned.</source>
          <target state="translated">SV는 항상 실제 문자열을 포함하고 다른 OK 비트가 설정되지 않은 상태로 반환됩니다. &lt;code&gt;$!&lt;/code&gt; 와는 달리 ! , &lt;code&gt;errnum&lt;/code&gt; 0 (성공을 의미)에 대해 메시지가 생성 되고 유용한 메시지를 사용할 수없는 경우 쓸모없는 문자열 (현재 비어 있음)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c47f45991f58d6b684980827b605f9d75549d35" translate="yes" xml:space="preserve">
          <source>The SV is an HV or a reference to an HV</source>
          <target state="translated">SV는 HV 또는 HV에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="82e45de5e22cb3332054cbfb0b3a963e2aa8939b" translate="yes" xml:space="preserve">
          <source>The SV returned has a refcount of 1.</source>
          <target state="translated">반환 된 SV의 참조 횟수는 1입니다.</target>
        </trans-unit>
        <trans-unit id="3397a37f03fe6e25c10e0df218712221b41b076a" translate="yes" xml:space="preserve">
          <source>The SV* corresponding to the $_ variable. Works even if there is a lexical $_ in scope.</source>
          <target state="translated">$ _ 변수에 해당하는 SV *. 범위에 어휘 $ _가있는 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e05dbcb3245d69dc4e0d0e0af3a2a1e2fb65e7e7" translate="yes" xml:space="preserve">
          <source>The SV* corresponding to the &lt;code&gt;$_&lt;/code&gt; variable. Works even if there is a lexical &lt;code&gt;$_&lt;/code&gt; in scope.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; 변수에 해당하는 SV * 입니다. 범위에 어휘 &lt;code&gt;$_&lt;/code&gt; 가 있어도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="166ec7ce6ae952f37ed9ee7074b722386bfc06c5" translate="yes" xml:space="preserve">
          <source>The SYS:/temp is preferred in Novell NetWare and the C:\system\temp for Symbian (the File::Spec::Win32 is used also for those platforms).</source>
          <target state="translated">SYS : / temp는 Novell NetWare에서 선호되며 Symbian의 경우 C : \ system \ temp (File :: Spec :: Win32는 해당 플랫폼에도 사용됨)입니다.</target>
        </trans-unit>
        <trans-unit id="c305a702522737f58ad2f086c3a8baae101bf7fa" translate="yes" xml:space="preserve">
          <source>The Safe extension module allows the creation of compartments in which perl code can be evaluated. Each compartment has</source>
          <target state="translated">안전 확장 모듈을 사용하면 펄 코드를 평가할 수있는 구획을 만들 수 있습니다. 각 구획에는</target>
        </trans-unit>
        <trans-unit id="f3ebdf6626009aca2f7b1117ac99eeb3a50e8a0f" translate="yes" xml:space="preserve">
          <source>The Second Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 두 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59ce582565e3aa2e433ddd5ed3ee6bdecbd67e3d" translate="yes" xml:space="preserve">
          <source>The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:</source>
          <target state="translated">보안 해시 표준 (Draft FIPS PUB 180-4)은 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0cf9a0044474cf0b7a47510d7ab73b298c8894f" translate="yes" xml:space="preserve">
          <source>The SelfLoader can load stubs automatically at module initialization with the statement 'SelfLoader-&amp;gt;load_stubs()';, but you may wish to avoid having the stub loading overhead associated with your initialization (though note that the SelfLoader::load_stubs method will be called sooner or later - at latest when the first sub is being autoloaded). In this case, you can put the sub stubs before the __DATA__ token. This can be done manually, but this module allows automatic generation of the stubs.</source>
          <target state="translated">SelfLoader는 'SelfLoader-&amp;gt; load_stubs ()'문을 사용하여 모듈 초기화시 스텁을 자동으로로드 할 수 있지만, 초기화와 연관된 스텁로드 오버 헤드가 발생하지 않도록 할 수 있습니다 (SelfLoader :: load_stubs 메소드가 호출됨에 유의하십시오) 조만간-최근에 첫 번째 서브가 자동로드되는 경우). 이 경우 하위 스텁을 __DATA__ 토큰 앞에 놓을 수 있습니다. 이 작업은 수동으로 수행 할 수 있지만이 모듈을 사용하면 스텁을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c273113828f1c56d85466a94fe42bd54d051b33a" translate="yes" xml:space="preserve">
          <source>The Seventh Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 일곱 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48b5fdd7473bc512821401bfc6bdb55846607392" translate="yes" xml:space="preserve">
          <source>The Silmarillion</source>
          <target state="translated">실마릴리온</target>
        </trans-unit>
        <trans-unit id="3d872a2e6f315517170676af6926b6bd336f2e79" translate="yes" xml:space="preserve">
          <source>The Sixth Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 여섯 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2615af73b1e9a8107739890b278d6bb8e8c58b89" translate="yes" xml:space="preserve">
          <source>The Socket library makes this slightly easier:</source>
          <target state="translated">소켓 라이브러리는 이것을 약간 더 쉽게 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="0346baceabdf020f1948aaad1950b71c29c8313d" translate="yes" xml:space="preserve">
          <source>The Solaris FAQ is available at &lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;http://www.science.uva.nl/pub/solaris/solaris2.html&lt;/a&gt;.</source>
          <target state="translated">Solaris FAQ는 &lt;a href=&quot;http://www.science.uva.nl/pub/solaris/solaris2.html&quot;&gt;http://www.science.uva.nl/pub/solaris/solaris2.html에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6524b148594d89baefb15f79bab2c7c15e79227" translate="yes" xml:space="preserve">
          <source>The Solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="f8bdb1b7f6851c01f4e6dd6b9335a25cbb9f32fe" translate="yes" xml:space="preserve">
          <source>The Source Filters distribution is available on CPAN, in</source>
          <target state="translated">소스 필터 배포는 CPAN에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95deb069230cbfe43ae345e5dcb1b877dd184d4" translate="yes" xml:space="preserve">
          <source>The Storable engine can also store data into a Perl scalar instead, to later retrieve them. This is mainly used to freeze a complex structure in some safe compact memory place (where it can possibly be sent to another process via some IPC, since freezing the structure also serializes it in effect). Later on, and maybe somewhere else, you can thaw the Perl scalar out and recreate the original complex structure in memory.</source>
          <target state="translated">Storable 엔진은 데이터를 나중에 Perl 스칼라에 저장하여 나중에 검색 할 수도 있습니다. 이것은 주로 안전한 소형 메모리 장소에서 복잡한 구조를 고정하는 데 사용됩니다 (구조를 동결하면 사실상 직렬화되기 때문에 일부 IPC를 통해 다른 프로세스로 전송 될 수 있음). 나중에 그리고 어딘가에 Perl 스칼라를 녹여서 메모리에 원래의 복잡한 구조를 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b46a98161104ffbf830836edabb2204067559b45" translate="yes" xml:space="preserve">
          <source>The Storable package brings persistence to your Perl data structures containing SCALAR, ARRAY, HASH or REF objects, i.e. anything that can be conveniently stored to disk and retrieved at a later time.</source>
          <target state="translated">Storable 패키지는 SCALAR, ARRAY, HASH 또는 REF 객체, 즉 디스크에 저장하고 나중에 검색 할 수있는 모든 것을 포함하는 Perl 데이터 구조에 지속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c31479831ac23c24002214051aef3521fbb967b" translate="yes" xml:space="preserve">
          <source>The Sun Managers' FAQ is available at &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt;</source>
          <target state="translated">Sun Manager의 FAQ는 &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4005ffb38cdcce66cf2552b3af0aed0d38d327" translate="yes" xml:space="preserve">
          <source>The Symbian port is licensed under the same terms as Perl itself.</source>
          <target state="translated">Symbian 포트는 Perl과 동일한 조건으로 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3f94b6eeafe888e9cb15f1090b03b3cc5b3e69" translate="yes" xml:space="preserve">
          <source>The Syntax of Variable Names</source>
          <target state="translated">변수 이름의 구문</target>
        </trans-unit>
        <trans-unit id="0dcb2ce1d39ebcd7787f9ace607f3511d6d60bc4" translate="yes" xml:space="preserve">
          <source>The SysV IPC code above was written long ago, and it's definitely clunky looking. For a more modern look, see the IPC::SysV module.</source>
          <target state="translated">위의 SysV IPC 코드는 오래 전에 작성되었으며 확실히 어색합니다. 보다 현대적인 모습을 보려면 IPC :: SysV 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1108c2be9cd2e091cb328bd69a9211fcbd132c6" translate="yes" xml:space="preserve">
          <source>The TAP version being parsed.</source>
          <target state="translated">구문 분석중인 TAP 버전입니다.</target>
        </trans-unit>
        <trans-unit id="c764a86dc20d72cedc0d0324258aff840654c9a9" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">TEMPLATE는 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 함수 에서와 동일한 형식을 갖습니다 . 다음은 하위 문자열을 수행하는 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="81ef1999f4ab1d77c16c0134c1c911b0b6e377cd" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">TEMPLATE는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 기능 과 동일한 형식 입니다. 서브 스트링을 수행하는 서브 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14ab3be603ef17e174d5422d8fa9db4cbcd8a394" translate="yes" xml:space="preserve">
          <source>The TEMPLATE has the same format as in the &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function. Here's a subroutine that does substring:</source>
          <target state="translated">TEMPLATE는 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 기능 과 동일한 형식 입니다. 서브 스트링을 수행하는 서브 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c84fad0e6672900e0ccb385df9c5a53aa073119f" translate="yes" xml:space="preserve">
          <source>The TEMPLATE is a sequence of characters that give the order and type of values, as follows:</source>
          <target state="translated">TEMPLATE는 다음과 같이 순서 및 유형의 값을 제공하는 일련의 문자입니다.</target>
        </trans-unit>
        <trans-unit id="aa18d821da8b238046aafed6e970f790f7308b97" translate="yes" xml:space="preserve">
          <source>The TTY to use for debugging I/O.</source>
          <target state="translated">I / O 디버깅에 사용할 TTY입니다.</target>
        </trans-unit>
        <trans-unit id="28ac83583a93c3bbe04e5be7ac1ae0bf8d97eb60" translate="yes" xml:space="preserve">
          <source>The TYPEMAP file</source>
          <target state="translated">TYPEMAP 파일</target>
        </trans-unit>
        <trans-unit id="10a06ea76a05d039fe9de3770c4f7ea4ca5db2f3" translate="yes" xml:space="preserve">
          <source>The TYPEMAP: Keyword</source>
          <target state="translated">TYPEMAP : 키워드</target>
        </trans-unit>
        <trans-unit id="a995c45f782f6eac7b2e49619c36fb98f70351d5" translate="yes" xml:space="preserve">
          <source>The T_SYSRET typemap is used to process return values from system calls. It is only meaningful when passing values from C to perl (there is no concept of passing a system return value from Perl to C).</source>
          <target state="translated">T_SYSRET 유형 맵은 시스템 호출의 리턴 값을 처리하는 데 사용됩니다. C에서 perl로 값을 전달할 때만 의미가 있습니다 (Perl에서 C로 시스템 리턴 값을 전달한다는 개념은 없습니다).</target>
        </trans-unit>
        <trans-unit id="c00d492559cf23114ccf6a4416bb2a3622dd118a" translate="yes" xml:space="preserve">
          <source>The Tale of the Children of Hurin</source>
          <target state="translated">후린의 아이들 이야기</target>
        </trans-unit>
        <trans-unit id="dc20618b36ece0cca578d0aaf6a793d399b51768" translate="yes" xml:space="preserve">
          <source>The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in old-style Tamil numbers in which they would appear no more than one in a row, separated by characters that mean &quot;times 10&quot;, &quot;times 100&quot;, etc. (See &lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21&lt;/a&gt;.)</source>
          <target state="translated">타밀어 숫자 (U + 0BE6-U + 0BEF)는 구식 타밀어 숫자로도 합법적으로 사용될 수 있습니다.이 숫자는 &quot;10 번&quot;, &quot;100 번&quot;을 의미하는 문자로 구분되어 한 행에 하나만 표시됩니다. 등 ( &lt;a href=&quot;http://www.unicode.org/notes/tn21&quot;&gt;http://www.unicode.org/notes/tn21&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="4b3b613445e9a0be0d75987b86a3f67177a19e47" translate="yes" xml:space="preserve">
          <source>The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in old-style Tamil numbers in which they would appear no more than one in a row, separated by characters that mean &quot;times 10&quot;, &quot;times 100&quot;, etc. (See &lt;a href=&quot;https://www.unicode.org/notes/tn21&quot;&gt;https://www.unicode.org/notes/tn21&lt;/a&gt;.)</source>
          <target state="translated">타밀 숫자 (U + 0BE6-U + 0BEF)는 &quot;10 배&quot;, &quot;100 배&quot;를 의미하는 문자로 구분하여 한 행에 하나만 표시되는 이전 스타일의 타밀 번호에서도 사용할 수 있습니다. 등 ( &lt;a href=&quot;https://www.unicode.org/notes/tn21&quot;&gt;https://www.unicode.org/notes/tn21&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="47ba114bf39e8b27a93263e54d8b1d42bd44b898" translate="yes" xml:space="preserve">
          <source>The Term::ReadKey module from CPAN may be easier to use. Recent versions include also support for non-portable systems as well.</source>
          <target state="translated">CPAN의 Term :: ReadKey 모듈을 사용하는 것이 더 쉬울 수 있습니다. 최신 버전에는 비 휴대용 시스템도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="defb60906fe7a29c78d833874b9dfd53a8da0c7e" translate="yes" xml:space="preserve">
          <source>The Test Anything Protocol (http://testanything.org/) isn't just for Perl. Just about any language can be used to write tests that output TAP. There are TAP based testing libraries for C, C++, PHP, Python and many others. If I can't find a TAP library for my language of choice it's easy to generate valid TAP. It looks like this:</source>
          <target state="translated">Test Anything Protocol (http://testanything.org/)은 Perl만을위한 것이 아닙니다. 거의 모든 언어를 사용하여 TAP를 출력하는 테스트를 작성할 수 있습니다. C, C ++, PHP, Python 등을위한 TAP 기반 테스트 라이브러리가 있습니다. 선택한 언어에 대한 TAP 라이브러리를 찾을 수없는 경우 유효한 TAP를 쉽게 생성 할 수 있습니다. 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="67ea73e6609d8a40648d86cab0f961b9f807f2d1" translate="yes" xml:space="preserve">
          <source>The Test2:: namespace is intended for extensions and frameworks. Tools, Plugins, etc should not go directly into this namespace. However extensions that are used to build tools and plugins may go here.</source>
          <target state="translated">Test2 :: 네임 스페이스는 확장 및 프레임 워크를위한 것입니다. 도구, 플러그인 등은이 네임 스페이스로 직접 이동해서는 안됩니다. 그러나 도구 및 플러그인을 빌드하는 데 사용되는 확장은 여기에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa06b70b29d84b54fc9ac81b1912f694e075b4ab" translate="yes" xml:space="preserve">
          <source>The Test::Builder implementation of subtests was certifiably insane. Test2 uses a stacked event hub system that greatly improves how subtests are implemented.</source>
          <target state="translated">하위 테스트의 Test :: Builder 구현은 확실히 미쳤습니다. Test2는 하위 테스트가 구현되는 방식을 크게 향상시키는 스택 형 이벤트 허브 시스템을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a150f420306a95f4538179d329cb0544a6c30f52" translate="yes" xml:space="preserve">
          <source>The Test::Builder singleton is now a simple compatibility wrapper around Test2. The Test::Builder singleton is no longer the central place for results. Many results bypass the Test::Builder singleton completely, which breaks and behavior intended when replacing the singleton.</source>
          <target state="translated">Test :: Builder 싱글 톤은 이제 Test2에 대한 간단한 호환성 래퍼입니다. Test :: Builder 싱글 톤은 더 이상 결과의 중심이 아닙니다. 많은 결과가 Test :: Builder 싱글 톤을 완전히 우회하며, 싱글 톤을 대체 할 때 의도 한 중단 및 동작입니다.</target>
        </trans-unit>
        <trans-unit id="14338af7c00e8b96b2c3abe72dd41cc7a7108717" translate="yes" xml:space="preserve">
          <source>The Test::Builder2/1.5 projects both died out. Now the conditional code people added has become a mine field. A vast majority of modules broken by Test2 fall into this category.</source>
          <target state="translated">Test :: Builder2 / 1.5 프로젝트는 모두 종료되었습니다. 이제 사람들이 추가 한 조건부 코드가 지뢰밭이되었습니다. Test2에 의해 중단 된 대부분의 모듈이이 범주에 속합니다.</target>
        </trans-unit>
        <trans-unit id="bca1768d51df8c4857efd38ce38584cfe993e7ba" translate="yes" xml:space="preserve">
          <source>The Test::Harness developers hang out on the tapx-dev mailing list[1]. For discussion of general, language independent TAP issues there's the tap-l[2] list. Finally there's a wiki dedicated to the Test Anything Protocol[3]. Contributions to the wiki, patches and suggestions are all welcome.</source>
          <target state="translated">Test :: Harness 개발자는 tapx-dev 메일 링리스트 [1]에 있습니다. 일반적인 언어 독립적 TAP 문제에 대한 논의를 위해 tap-l [2] 목록이 있습니다. 마지막으로 Test Anything Protocol [3] 전용 위키가 있습니다. 위키에 대한 기고, 패치 및 제안은 모두 환영합니다.</target>
        </trans-unit>
        <trans-unit id="51d735714b4bc15d3dc8dd3f8139c4900ed3a21d" translate="yes" xml:space="preserve">
          <source>The Test::Harness module is a compatibility wrapper around TAP::Harness. For new applications I should use TAP::Harness directly. As we'll see, prove uses TAP::Harness.</source>
          <target state="translated">Test :: Harness 모듈은 TAP :: Harness에 대한 호환성 래퍼입니다. 새로운 응용 프로그램의 경우 TAP :: Harness를 직접 사용해야합니다. 보시다시피 Proven은 TAP :: Harness를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="35a1f7393254a3b1337f16135889cbf5d4ddbd76" translate="yes" xml:space="preserve">
          <source>The Third Rule of Sys::Syslog is:</source>
          <target state="translated">Sys :: Syslog의 세 번째 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93fb358185964087944f1d6c1078da04b430b4f0" translate="yes" xml:space="preserve">
          <source>The Tree subsubsection in XML::Parser</source>
          <target state="translated">XML :: Parser의 트리 하위 섹션</target>
        </trans-unit>
        <trans-unit id="8dd1d72b0140a01ec4804e7eb5bb38229499e0d2" translate="yes" xml:space="preserve">
          <source>The U/WIN environment for Win32, &lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http://www.research.att.com/sw/tools/uwin/&lt;/a&gt;</source>
          <target state="translated">Win32 용 U / WIN 환경, &lt;a href=&quot;http://www.research.att.com/sw/tools/uwin/&quot;&gt;http://www.research.att.com/sw/tools/uwin/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="769648b0d99f3965f04ad4c0ff49f028dec18b56" translate="yes" xml:space="preserve">
          <source>The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags affect how the function handles a Unicode non-character. And likewise, the UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Code points above 0x7FFF_FFFF (which are even less portable) can be warned and/or disallowed even if other above-Unicode code points are accepted, by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF flags.</source>
          <target state="translated">UNICODE_WARN_NONCHAR 및 UNICODE_DISALLOW_NONCHAR 플래그는 함수가 문자가 아닌 유니 코드를 처리하는 방법에 영향을줍니다. 마찬가지로 UNICODE_WARN_SUPER 및 UNICODE_DISALLOW_SUPER 플래그는 유니 코드 최대 값 0x10FFFF보다 큰 코드 포인트 처리에 영향을줍니다. UNICODE_WARN_FE_FF 및 UNICODE_DISALLOW_FE_FF 플래그를 사용하여 0x7FFF_FFFF (이동성이 덜한) 이상의 코드 포인트는 유니 코드 이상의 다른 코드 포인트가 허용 되더라도 경고 및 / 또는 허용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1a9962a264046baa6e654280499186de4c8dcb8" translate="yes" xml:space="preserve">
          <source>The UNIVERSAL Class</source>
          <target state="translated">유니버설 클래스</target>
        </trans-unit>
        <trans-unit id="cd88063ac12501d08f31a4f0019952c1198ff637" translate="yes" xml:space="preserve">
          <source>The URL must have unsafe characters escaped and international domain names encoded. See &lt;code&gt;request()&lt;/code&gt; for valid options and a description of the response. Any &lt;code&gt;content-type&lt;/code&gt; header or content in the options hashref will be ignored.</source>
          <target state="translated">URL에는 안전하지 않은 문자가 이스케이프되고 국제 도메인 이름이 인코딩되어야합니다. 유효한 옵션과 응답에 대한 설명은 &lt;code&gt;request()&lt;/code&gt; 를 참조하십시오 . 옵션 hashref의 모든 &lt;code&gt;content-type&lt;/code&gt; 헤더 또는 콘텐츠는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="626ffdf925f7f1a1535b1e7a24ab5f1836995ec2" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a CSS file to include. This option is not set by default.</source>
          <target state="translated">포함 할 CSS 파일의 URL 또는 상대 경로입니다. 이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40bee207a472a4fd5b0841568ca70dbba8442ce0" translate="yes" xml:space="preserve">
          <source>The URL or relative path of a JavaScript file to pull in. This option is not set by default.</source>
          <target state="translated">가져올 JavaScript 파일의 URL 또는 상대 경로입니다.이 옵션은 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da88ae39f79698f8a366077011136f1217b89d12" translate="yes" xml:space="preserve">
          <source>The USE_PERLIO implementation is described in &lt;a href=&quot;perliol&quot;&gt;perliol&lt;/a&gt;.</source>
          <target state="translated">USE_PERLIO 구현은 perliol에 설명되어 &lt;a href=&quot;perliol&quot;&gt;있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5daf05eaea510ba5b0017fb9c306e9890c51ff94" translate="yes" xml:space="preserve">
          <source>The UTF-32 family is pretty much like the UTF-16 family, except that the units are 32-bit, and therefore the surrogate scheme is not needed. UTF-32 is a fixed-width encoding. The &lt;code&gt;BOM&lt;/code&gt; signatures are &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; for BE and &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; for LE.</source>
          <target state="translated">UTF-32 제품군은 단위가 32 비트이므로 대리 체계가 필요하지 않다는 점을 제외하면 UTF-16 제품군과 매우 비슷합니다. UTF-32는 고정 너비 인코딩입니다. &lt;code&gt;BOM&lt;/code&gt; 의 서명은 &lt;code&gt;0x00 0x00 0xFE 0xFF&lt;/code&gt; BE 및 &lt;code&gt;0xFF 0xFE 0x00 0x00&lt;/code&gt; LE합니다.</target>
        </trans-unit>
        <trans-unit id="bc2a3bd272acf800ee5bf335378472d902fdd721" translate="yes" xml:space="preserve">
          <source>The UTF-8 flag is not changed by this function. A terminating NUL byte is guaranteed.</source>
          <target state="translated">UTF-8 플래그는이 함수에 의해 변경되지 않습니다. 종료 NUL 바이트가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="1dd8debe441de21cb20cb60141841b3943f5b160" translate="yes" xml:space="preserve">
          <source>The UTF8 flag</source>
          <target state="translated">UTF8 플래그</target>
        </trans-unit>
        <trans-unit id="3497009379d436d65cbfa7fccfbc30ab781daaa7" translate="yes" xml:space="preserve">
          <source>The UTF8 flag, also called SvUTF8, is an internal flag that indicates that the current internal representation is UTF-8. Without the flag, it is assumed to be ISO-8859-1. Perl converts between these automatically. (Actually Perl usually assumes the representation is ASCII; see &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3F&quot;&gt;&quot;Why do regex character classes sometimes match only in the ASCII range?&quot;&lt;/a&gt; above.)</source>
          <target state="translated">SvUTF8이라고도하는 UTF8 플래그는 현재 내부 표현이 UTF-8임을 나타내는 내부 플래그입니다. 플래그가 없으면 ISO-8859-1로 간주됩니다. Perl은 이들 사이를 자동으로 변환합니다. (실제로 Perl은 일반적으로 표현이 ASCII라고 가정합니다. 위의 &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3F&quot;&gt;&quot;정규식 문자 클래스가 때때로 ASCII 범위에서만 일치하는 이유는 무엇입니까?&quot;를&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e84247eff9f0cf26586d5f7b3851d2932bd10a42" translate="yes" xml:space="preserve">
          <source>The UTF8 flag, also called SvUTF8, is an internal flag that indicates that the current internal representation is UTF-8. Without the flag, it is assumed to be ISO-8859-1. Perl converts between these automatically. (Actually Perl usually assumes the representation is ASCII; see &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;Why do regex character classes sometimes match only in the ASCII range?&lt;/a&gt; above.)</source>
          <target state="translated">SvUTF8이라고도하는 UTF8 플래그는 현재 내부 표현이 UTF-8임을 나타내는 내부 플래그입니다. 플래그가 없으면 ISO-8859-1로 간주됩니다. 펄은 이들 사이를 자동으로 변환합니다. (실제로 Perl은 일반적으로 표현이 ASCII라고 가정합니다. &lt;a href=&quot;#Why-do-regex-character-classes-sometimes-match-only-in-the-ASCII-range%3f&quot;&gt;정규식 문자 클래스가 때때로 ASCII 범위에서만 일치하는 이유는 무엇입니까?를&lt;/a&gt; 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="0c156f969a0dd40349df4b801ec75724f31841f0" translate="yes" xml:space="preserve">
          <source>The UTF8_CHECK_ONLY flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt; ) and return zero.</source>
          <target state="translated">UTF8_CHECK_ONLY 플래그는 허용되지 않는 (다른 플래그에 의한) 기형이 발견 될 때 동작을 대체합니다. 이 플래그가 설정되면 루틴은 호출자가 경고를 발생한다고 가정하고이 함수는 자동으로 &lt;code&gt;retlen&lt;/code&gt; 을 &lt;code&gt;-1&lt;/code&gt; ( &lt;code&gt;STRLEN&lt;/code&gt; 로 캐스트 )로 설정하고 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dee97b6ee4395720ec2caa0d5bb0e598ccb46481" translate="yes" xml:space="preserve">
          <source>The UUID of the context that was used to create the event. (If uuid tagging was enabled)</source>
          <target state="translated">이벤트를 만드는 데 사용 된 컨텍스트의 UUID입니다. (uuid 태그 지정이 활성화 된 경우)</target>
        </trans-unit>
        <trans-unit id="84daa0ce367af94311b87e303afdb6ed339120b9" translate="yes" xml:space="preserve">
          <source>The UUID of the hub that the event was sent to.</source>
          <target state="translated">이벤트가 전송 된 허브의 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="42009d82456b5488829e94829354eecab81597ba" translate="yes" xml:space="preserve">
          <source>The UUID of the hub that was current when the event was created. (If uuid tagging was enabled).</source>
          <target state="translated">이벤트가 생성 될 때 최신 상태였던 허브의 UUID입니다. (uuid 태그 지정이 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="fe051c2554d575b5ef8dd3483cd37e0f3f831882" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt; properties give what script a given character is in. Either property can be specified with the compound form like &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (short: &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ), or &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (short: &lt;code&gt;\p{scx=java}&lt;/code&gt; ). In addition, Perl furnishes shortcuts for all &lt;code&gt;Script&lt;/code&gt; property names. You can omit everything up through the equals (or colon), and simply write &lt;code&gt;\p{Latin}&lt;/code&gt; or &lt;code&gt;\P{Cyrillic}&lt;/code&gt; . (This is not true for &lt;code&gt;Script_Extensions&lt;/code&gt; , which is required to be written in the compound form.)</source>
          <target state="translated">유니 코드 &lt;code&gt;Script&lt;/code&gt; 및 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성은 지정된 문자의 스크립트를 제공합니다. &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (약식 : &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ) 또는 &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; 와 같은 복합 형식으로 속성을 지정할 수 있습니다. Javanese} (약식 : &lt;code&gt;\p{scx=java}&lt;/code&gt; ). 또한 Perl은 모든 &lt;code&gt;Script&lt;/code&gt; 속성 이름에 대한 바로 가기를 제공 합니다. 등호 (또는 콜론)를 통해 모든 것을 생략하고 간단히 &lt;code&gt;\p{Latin}&lt;/code&gt; 또는 &lt;code&gt;\P{Cyrillic}&lt;/code&gt; 쓸 수 있습니다. ( 복합 형식으로 작성 &lt;code&gt;Script_Extensions&lt;/code&gt; 경우 에는 해당되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="a799b97493123ec1207912da9978bb609aabac08" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt; properties give what script a given character is in. The &lt;code&gt;Script_Extensions&lt;/code&gt; property is an improved version of &lt;code&gt;Script&lt;/code&gt;, as demonstrated below. Either property can be specified with the compound form like &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (short: &lt;code&gt;\p{sc=hebr}&lt;/code&gt;), or &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (short: &lt;code&gt;\p{scx=java}&lt;/code&gt;). In addition, Perl furnishes shortcuts for all &lt;code&gt;Script_Extensions&lt;/code&gt; property names. You can omit everything up through the equals (or colon), and simply write &lt;code&gt;\p{Latin}&lt;/code&gt; or &lt;code&gt;\P{Cyrillic}&lt;/code&gt;. (This is not true for &lt;code&gt;Script&lt;/code&gt;, which is required to be written in the compound form. Prior to Perl v5.26, the single form returned the plain old &lt;code&gt;Script&lt;/code&gt; version, but was changed because &lt;code&gt;Script_Extensions&lt;/code&gt; gives better results.)</source>
          <target state="translated">Unicode &lt;code&gt;Script&lt;/code&gt; 및 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성은 주어진 문자가 포함 된 스크립트를 제공합니다. &lt;code&gt;Script_Extensions&lt;/code&gt; 속성은 아래에 설명 된대로 &lt;code&gt;Script&lt;/code&gt; 의 개선 된 버전입니다 . 속성은 &lt;code&gt;\p{Script=Hebrew}&lt;/code&gt; (줄임말 : &lt;code&gt;\p{sc=hebr}&lt;/code&gt; ) 또는 &lt;code&gt;\p{Script_Extensions=Javanese}&lt;/code&gt; (줄임말 : &lt;code&gt;\p{scx=java}&lt;/code&gt; ) 와 같은 복합 형식으로 지정할 수 있습니다 . 또한 Perl은 모든 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성 이름에 대한 바로 가기를 제공 합니다. 등호 (또는 콜론)를 통해 모든 것을 생략하고 간단히 &lt;code&gt;\p{Latin}&lt;/code&gt; 또는 &lt;code&gt;\P{Cyrillic}&lt;/code&gt; 작성할 수 있습니다. (이것은 사실이 아닙니다. &lt;code&gt;Script&lt;/code&gt; , 복합 형식으로 작성해야합니다. Perl v5.26 이전에는 단일 양식이 일반 이전 &lt;code&gt;Script&lt;/code&gt; 버전을 반환 했지만 &lt;code&gt;Script_Extensions&lt;/code&gt; 가 더 나은 결과를 제공 하기 때문에 변경되었습니다 .)</target>
        </trans-unit>
        <trans-unit id="c83e3b7637cbbc620c9e558cb0dcb895e621c1cb" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;\p{Script}&lt;/code&gt; and &lt;code&gt;\p{Script_Extensions}&lt;/code&gt; properties are used to categorize every Unicode character into the language script it is written in. (&lt;code&gt;Script_Extensions&lt;/code&gt; is an improved version of &lt;code&gt;Script&lt;/code&gt;, which is retained for backward compatibility, and so you should generally use &lt;code&gt;Script_Extensions&lt;/code&gt;.) For example, English, French, and a bunch of other European languages are written in the Latin script. But there is also the Greek script, the Thai script, the Katakana script,</source>
          <target state="translated">유니 코드 &lt;code&gt;\p{Script}&lt;/code&gt; 및 &lt;code&gt;\p{Script_Extensions}&lt;/code&gt; 속성은 모든 유니 코드 문자를 작성되는 언어 스크립트로 분류하는 데 사용됩니다. &lt;code&gt;Script_Extensions&lt;/code&gt; 는 이전 버전과의 호환성을 위해 유지되는 &lt;code&gt;Script&lt;/code&gt; 의 개선 된 버전 이므로 다음 작업을 수행해야합니다. 일반적으로 &lt;code&gt;Script_Extensions&lt;/code&gt; 를 사용 합니다 . 예를 들어 영어, 프랑스어 및 기타 여러 유럽 언어는 라틴 스크립트로 작성됩니다. 하지만 그리스 문자, 태국 문자, 가타카나 문자도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68ace88196ee8ab90b1eb6e05c27ca6293cc1949" translate="yes" xml:space="preserve">
          <source>The Unicode &lt;code&gt;\p{Script}&lt;/code&gt; property is used to categorize every Unicode character into the language script it is written in. For example, English, French, and a bunch of other European languages are written in the Latin script. But there is also the Greek script, the Thai script, the Katakana script, etc. You can test whether a character is in a particular script with, for example &lt;code&gt;\p{Latin}&lt;/code&gt; , &lt;code&gt;\p{Greek}&lt;/code&gt; , or &lt;code&gt;\p{Katakana}&lt;/code&gt; . To test if it isn't in the Balinese script, you would use &lt;code&gt;\P{Balinese}&lt;/code&gt; .</source>
          <target state="translated">Unicode &lt;code&gt;\p{Script}&lt;/code&gt; 속성은 모든 유니 코드 문자를 작성된 언어 스크립트로 분류하는 데 사용됩니다. 예를 들어 영어, 프랑스어 및 기타 여러 유럽 언어는 라틴 스크립트로 작성됩니다. 그러나 그리스어 스크립트, 태국어 스크립트, 가타카나 스크립트 등도 있습니다. &lt;code&gt;\p{Latin}&lt;/code&gt; , &lt;code&gt;\p{Greek}&lt;/code&gt; 또는 &lt;code&gt;\p{Katakana}&lt;/code&gt; 등을 사용하여 특정 스크립트에 문자가 있는지 테스트 할 수 있습니다. } . 발리 스크립트에 없는지 테스트하려면 &lt;code&gt;\P{Balinese}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c137959e417f1d80c5a78f30067a032e5b5cba1e" translate="yes" xml:space="preserve">
          <source>The Unicode CLDR project extracts the POSIX portion of many of its locales, available at</source>
          <target state="translated">Unicode CLDR 프로젝트는 여러 로케일의 POSIX 부분을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="d486f8bf02133ca434524335056eb02772644059" translate="yes" xml:space="preserve">
          <source>The Unicode Character Map</source>
          <target state="translated">유니 코드 문자표</target>
        </trans-unit>
        <trans-unit id="c5ce90a3e4de6a4acbbf53c0744b1a0991c6efd2" translate="yes" xml:space="preserve">
          <source>The Unicode Consortium has a list of articles and books, some of which give a much more in depth treatment of Unicode: &lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http://unicode.org/resources/readinglist.html&lt;/a&gt;</source>
          <target state="translated">유니 코드 컨소시엄에는 기사 및 서적 목록이 있으며 그 중 일부는 유니 코드에 대한 심층적 인 처리를 제공합니다. &lt;a href=&quot;http://unicode.org/resources/readinglist.html&quot;&gt;http://unicode.org/resources/readinglist.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f47c9f664ce4e52a0db000d2410941371e77032" translate="yes" xml:space="preserve">
          <source>The Unicode Standard, Version 6.1</source>
          <target state="translated">유니 코드 표준, 버전 6.1</target>
        </trans-unit>
        <trans-unit id="ceaf176fe24089b589f5a8df64bfcb78329c82a1" translate="yes" xml:space="preserve">
          <source>The Unicode character sets associates characters with integers. Encoding these numbers in an equal number of bytes would more than double the requirements for storing texts written in Latin alphabets. The UTF-8 encoding avoids this by storing the most common (from a western point of view) characters in a single byte while encoding the rarer ones in three or more bytes.</source>
          <target state="translated">유니 코드 문자 세트는 문자를 정수와 연관시킵니다. 이 숫자를 같은 바이트 수로 인코딩하면 라틴 알파벳으로 작성된 텍스트를 저장하는 데 필요한 요구 사항이 두 배 이상 증가합니다. UTF-8 인코딩은 가장 일반적인 (서부 관점에서) 문자를 단일 바이트에 저장하고 가장 드문 문자를 3 개 이상의 바이트로 인코딩하여이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b01639a1272db3c72594d5482698c9a198da2486" translate="yes" xml:space="preserve">
          <source>The Unicode code points are just abstract numbers. To input and output these abstract numbers, the numbers must be</source>
          <target state="translated">유니 코드 코드 포인트는 단지 추상 숫자입니다. 이 추상 숫자를 입력하고 출력하려면 숫자가</target>
        </trans-unit>
        <trans-unit id="fee82003cf69ee996e6b6206be19d9eb1e9b4ae7" translate="yes" xml:space="preserve">
          <source>The Unicode data base is delivered in two different formats. The XML version is valid for more modern Unicode releases. The other version is a collection of files. The two are intended to give equivalent information. Perl uses the older form; this allows you to recompile Perl to use early Unicode releases.</source>
          <target state="translated">유니 코드 데이터베이스는 두 가지 형식으로 제공됩니다. XML 버전은 최신 유니 코드 릴리스에 유효합니다. 다른 버전은 파일 모음입니다. 이 두 가지는 동등한 정보를 제공하기위한 것입니다. Perl은 이전 형식을 사용합니다. 따라서 초기 유니 코드 릴리스를 사용하기 위해 Perl을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0af64faddaa46b640051dd4c06cacd9bdf1c61ba" translate="yes" xml:space="preserve">
          <source>The Unicode name for each of the control characters (such as LINE FEED) is the empty string. However almost all had names assigned by other standards, such as the ASCII Standard, or were in common use. &lt;code&gt;viacode&lt;/code&gt; returns these names as the &quot;best&quot; ones available. Unicode 6.1 has created Name_Aliases for each of them, including alternate names, like NEW LINE. &lt;code&gt;viacode&lt;/code&gt; uses the original name, &quot;LINE FEED&quot; in preference to the alternate. Similarly the name returned for U+FEFF is &quot;ZERO WIDTH NO-BREAK SPACE&quot;, not &quot;BYTE ORDER MARK&quot;.</source>
          <target state="translated">각 제어 문자 (예 : LINE FEED)의 유니 코드 이름은 빈 문자열입니다. 그러나 거의 모든 이름에는 ASCII 표준과 같은 다른 표준에 의해 지정된 이름이 있거나 일반적으로 사용되었습니다. &lt;code&gt;viacode&lt;/code&gt; 는 이러한 이름을 사용 가능한 &quot;최상의&quot;이름으로 반환합니다. 유니 코드 6.1은 NEW LINE과 같은 대체 이름을 포함하여 각각에 대해 Name_Aliases를 작성했습니다. &lt;code&gt;viacode&lt;/code&gt; 는 대체 이름보다 원래 이름 인 &quot;LINE FEED&quot;를 사용합니다. 마찬가지로 U + FEFF에 대해 반환 된 이름은 &quot;BYTE ORDER MARK&quot;가 아니라 &quot;ZERO WIDTH NO-BREAK SPACE&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="0ede66bf69d832626e4487c425ff000b31b3a47f" translate="yes" xml:space="preserve">
          <source>The Unicode property wildcards feature is experimental</source>
          <target state="translated">유니 코드 속성 와일드 카드 기능은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="1ac858cb298c00054e86b0d115cb91b95f10f3cf" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation because that more clearly shows the division of Unicode into blocks of 256 characters. Hexadecimal is also simply shorter than decimal. You can use decimal notation, too, but learning to use hexadecimal just makes life easier with the Unicode standard. The &lt;code&gt;U+HHHH&lt;/code&gt; notation uses hexadecimal, for example.</source>
          <target state="translated">유니 코드 표준은 16 진수 표기법을 선호합니다. 왜냐하면 유니 코드를 256 문자 블록으로 나누는 것을보다 명확하게 보여주기 때문입니다. 16 진법은 단순히 10 진법보다 짧습니다. 십진수 표기법도 사용할 수 있지만 16 진수를 사용하는 법을 배우면 유니 코드 표준을 사용하는 것이 더 쉽습니다. &lt;code&gt;U+HHHH&lt;/code&gt; 의 표기는, 예를 들어 16 진수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c3a6b1f5384fadabab8fcfef374f7c8fdfe374ab" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation for the code points. If numbers like &lt;code&gt;0x0041&lt;/code&gt; are unfamiliar to you, take a peek at a later section, &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;&quot;Hexadecimal Notation&quot;&lt;/a&gt;. The Unicode standard uses the notation &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt;, to give the hexadecimal code point and the normative name of the character.</source>
          <target state="translated">유니 코드 표준은 코드 포인트에 16 진수 표기법을 사용하는 것을 선호합니다. &lt;code&gt;0x0041&lt;/code&gt; 과 같은 숫자 가 익숙하지 않은 경우 나중에 &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;&quot;16 진수 표기법&quot;&lt;/a&gt; 섹션을 살펴보십시오 . 유니 코드 표준은 &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt; 표기법 을 사용하여 16 진수 코드 포인트와 문자의 표준 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e6fd7f938d86967a9161a418271cce0d06cd2600" translate="yes" xml:space="preserve">
          <source>The Unicode standard prefers using hexadecimal notation for the code points. If numbers like &lt;code&gt;0x0041&lt;/code&gt; are unfamiliar to you, take a peek at a later section, &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;Hexadecimal Notation&lt;/a&gt;. The Unicode standard uses the notation &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt;, to give the hexadecimal code point and the normative name of the character.</source>
          <target state="translated">유니 코드 표준은 코드 포인트에 16 진 표기법을 사용하는 것을 선호합니다. &lt;code&gt;0x0041&lt;/code&gt; 과 같은 숫자 가 익숙하지 않은 경우 , &lt;a href=&quot;#Hexadecimal-Notation&quot;&gt;16 진수 표기법&lt;/a&gt; 섹션을 살펴보십시오 . 유니 코드 표준은 표기법 &lt;code&gt;U+0041 LATIN CAPITAL LETTER A&lt;/code&gt; 를 사용하여 16 진 코드 포인트와 문자의 규범 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c02514a64c1d2f4e4fce35a40ef0864ea99b3007" translate="yes" xml:space="preserve">
          <source>The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. This module is Copyright(C) 2001-2014, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">perl 용 Unicode :: Collate 모듈은 SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;에 의해 작성되었습니다. 이 모듈은 SADAHIRO Tomoyuki의 Copyright (C) 2001-2014입니다. 일본. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="aeaefd7f92a39270b4af8e187f61268b7f767f37" translate="yes" xml:space="preserve">
          <source>The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. This module is Copyright(C) 2001-2018, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">Perl 용 Unicode :: Collate 모듈은 SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;에 의해 작성되었습니다. 이 모듈은 Copyright (C) 2001-2018, SADAHIRO Tomoyuki입니다. 일본. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="0a1deaf2c2a3071deed518e52c43513782d1a52d" translate="yes" xml:space="preserve">
          <source>The Unicode::Collate::Locale module for perl was written by SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;. This module is Copyright(C) 2004-2018, SADAHIRO Tomoyuki. Japan. All rights reserved.</source>
          <target state="translated">Perl 용 Unicode :: Collate :: Locale 모듈은 SADAHIRO Tomoyuki, &amp;lt;SADAHIRO@cpan.org&amp;gt;에 의해 작성되었습니다. 이 모듈은 Copyright (C) 2004-2018, SADAHIRO Tomoyuki입니다. 일본. 판권 소유.</target>
        </trans-unit>
        <trans-unit id="473e3f8c820ceadead01839cdf7e14621c8d192f" translate="yes" xml:space="preserve">
          <source>The Unicode::UCD module offers a series of functions that provide a simple interface to the Unicode Character Database.</source>
          <target state="translated">Unicode :: UCD 모듈은 유니 코드 문자 데이터베이스에 대한 간단한 인터페이스를 제공하는 일련의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="26e3ce0808d98a59d29700d316741aae764f2a61" translate="yes" xml:space="preserve">
          <source>The Unix System V IPC (&lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; ) is not available even on all Unix platforms.</source>
          <target state="translated">Unix 시스템 V IPC ( &lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; )는 모든 Unix 플랫폼에서도 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="754b26e5a10f0a4b8f59af0a3e25be514060a639" translate="yes" xml:space="preserve">
          <source>The Unix System V IPC (&lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt;) is not available even on all Unix platforms.</source>
          <target state="translated">Unix System V IPC ( &lt;code&gt;msg*(), sem*(), shm*()&lt;/code&gt; )는 모든 Unix 플랫폼에서도 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fae3b6a0c7efbf25175bd611a319e0fb66e5613e" translate="yes" xml:space="preserve">
          <source>The Unix column assumes that you are not accessing a serial line (like a tty) in canonical mode. If you are, then CR on input becomes &quot;\n&quot;, and &quot;\n&quot; on output becomes CRLF.</source>
          <target state="translated">유닉스 열은 표준 모드에서 tty와 같은 직렬 회선에 액세스하지 않는다고 가정합니다. 그렇다면 입력의 CR이 &quot;\ n&quot;이되고 출력의 &quot;\ n&quot;이 CRLF가됩니다.</target>
        </trans-unit>
        <trans-unit id="dd39418cfe05cee0fae6b087e55e6c5b32837941" translate="yes" xml:space="preserve">
          <source>The Unix emulation library's translation of filenames to native assumes that this sort of translation is required, and it allows a user-defined list of known suffixes that it will transpose in this fashion. This may seem transparent, but consider that with these rules</source>
          <target state="translated">유닉스 에뮬레이션 라이브러리의 파일 이름을 기본으로 변환하는 것은 이러한 종류의 변환이 필요하다고 가정하며 이러한 방식으로 변환 될 알려진 접미사의 사용자 정의 목록을 허용합니다. 이것은 투명 해 보일 수 있지만 이러한 규칙을 사용하면</target>
        </trans-unit>
        <trans-unit id="9ca9afdfa9b1be5687aa05531467ec65e45a620e" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt;&lt;code&gt;mkdir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; are modified by your umask, so even if you tell &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt;, if your umask is &lt;code&gt;0022&lt;/code&gt;, then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt;. If your &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt;).</source>
          <target state="translated">Unix 권한 &lt;code&gt;rwxr-x---&lt;/code&gt; 는 3 비트의 세 세트 또는 세 개의 8 진수로 표시됩니다 : &lt;code&gt;0750&lt;/code&gt; (선행 0은 8 진수를 나타내며 숫자 중 하나가 아님). &lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt; 값을 사용할 권한을 나타내는 비트와 같은 수이다. &lt;a href=&quot;#mkdir-FILENAME%2CMODE&quot;&gt; &lt;code&gt;mkdir&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; 을 전달하는 권한 (또는 &quot;모드&quot;) 값 은 umask에 의해 수정됩니다. 따라서 &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; 에게 권한이 &lt;code&gt;0777&lt;/code&gt; 인 파일을 생성하도록 지시 하더라도 umask가 &lt;code&gt;0022&lt;/code&gt; 이면 실제로 파일은 권한 &lt;code&gt;0755&lt;/code&gt; 로 생성됩니다. . 귀하의 경우 &lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; 를&lt;/a&gt; 했다 &lt;code&gt;0027&lt;/code&gt; 을다음 전달 (다른 사람들이 읽을 수 없습니다 쓰기 또는 실행 그룹은 쓸 수 없습니다) &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt; &lt;code&gt;0666&lt;/code&gt; 을 모드 파일을 만들 것입니다 &lt;code&gt;0640&lt;/code&gt; 을 (때문에 &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; 입니다 &lt;code&gt;0640&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb551ea7181334bc4b0216d63d17835797e645a3" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Unix 권한 &lt;code&gt;rwxr-x---&lt;/code&gt; 는 3 비트의 3 비트 세트 또는 3 개의 8 진수로 표시됩니다. &lt;code&gt;0750&lt;/code&gt; (앞의 0은 8 진수를 나타내며 숫자 중 하나가 아닙니다). &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값을 사용할 권한을 나타내는 비트와 같은 수이다. &lt;code&gt;&lt;a href=&quot;functions/mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 전달하는 권한 (또는 &quot;모드&quot;) 값 은 umask에 의해 수정되므로 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 권한 &lt;code&gt;0777&lt;/code&gt; 의 파일을 작성하도록 지시 하더라도 umask가 &lt;code&gt;0022&lt;/code&gt; 인 경우 파일은 실제로 권한 &lt;code&gt;0755&lt;/code&gt; 로 작성됩니다. . 귀하의 경우 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 했다 &lt;code&gt;0027&lt;/code&gt; 을다음 전달 (다른 사람들이 읽을 수 없습니다 쓰기 또는 실행 그룹은 쓸 수 없습니다) &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; 을 모드 파일을 만들 것입니다 &lt;code&gt;0640&lt;/code&gt; 을 (때문에 &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; 입니다 &lt;code&gt;0640&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96615142b96c010257cd138eceafdbdb1fcfb3bc" translate="yes" xml:space="preserve">
          <source>The Unix permission &lt;code&gt;rwxr-x---&lt;/code&gt; is represented as three sets of three bits, or three octal digits: &lt;code&gt;0750&lt;/code&gt; (the leading 0 indicates octal and isn't one of the digits). The &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value is such a number representing disabled permissions bits. The permission (or &quot;mode&quot;) values you pass &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; are modified by your umask, so even if you tell &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; to create a file with permissions &lt;code&gt;0777&lt;/code&gt; , if your umask is &lt;code&gt;0022&lt;/code&gt; , then the file will actually be created with permissions &lt;code&gt;0755&lt;/code&gt; . If your &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; were &lt;code&gt;0027&lt;/code&gt; (group can't write; others can't read, write, or execute), then passing &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;&lt;code&gt;0666&lt;/code&gt; would create a file with mode &lt;code&gt;0640&lt;/code&gt; (because &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; is &lt;code&gt;0640&lt;/code&gt; ).</source>
          <target state="translated">Unix 권한 &lt;code&gt;rwxr-x---&lt;/code&gt; 는 3 비트의 3 비트 세트 또는 3 개의 8 진수로 표시됩니다. &lt;code&gt;0750&lt;/code&gt; (앞의 0은 8 진수를 나타내며 숫자 중 하나가 아닙니다). &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 값을 사용할 권한을 나타내는 비트와 같은 수이다. &lt;code&gt;&lt;a href=&quot;mkdir&quot;&gt;mkdir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 전달하는 권한 (또는 &quot;모드&quot;) 값 은 umask에 의해 수정되므로 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 에 권한 &lt;code&gt;0777&lt;/code&gt; 의 파일을 작성하도록 지시 하더라도 umask가 &lt;code&gt;0022&lt;/code&gt; 인 경우 파일은 실제로 권한 &lt;code&gt;0755&lt;/code&gt; 로 작성됩니다. . 귀하의 경우 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 를 했다 &lt;code&gt;0027&lt;/code&gt; 을다음 전달 (다른 사람들이 읽을 수 없습니다 쓰기 또는 실행 그룹은 쓸 수 없습니다) &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; &lt;code&gt;0666&lt;/code&gt; 을 모드 파일을 만들 것입니다 &lt;code&gt;0640&lt;/code&gt; 을 (때문에 &lt;code&gt;0666 &amp;amp;~ 027&lt;/code&gt; 입니다 &lt;code&gt;0640&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d68f3b12b3008b73f340d97bbe8121b4ae3d9886" translate="yes" xml:space="preserve">
          <source>The Unix program that displays online documentation (manual pages) for you.</source>
          <target state="translated">온라인 설명서 (수동 페이지)를 표시하는 Unix 프로그램.</target>
        </trans-unit>
        <trans-unit id="6c706863878da4b315305112df038324c52a3cf6" translate="yes" xml:space="preserve">
          <source>The VERSION argument cannot be an arbitrary expression. It only counts as a VERSION argument if it is a version number literal, starting with either a digit or &lt;code&gt;v&lt;/code&gt; followed by a digit. Anything that doesn't look like a version literal will be parsed as the start of the LIST. Nevertheless, many attempts to use an arbitrary expression as a VERSION argument will appear to work, because &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;'s &lt;code&gt;import&lt;/code&gt; method handles numeric arguments specially, performing version checks rather than treating them as things to export.</source>
          <target state="translated">VERSION 인수는 임의의 표현식이 될 수 없습니다. 버전 번호 리터럴 인 경우에만 VERSION 인수로 계산되며, 숫자 또는 &lt;code&gt;v&lt;/code&gt; 뒤에 숫자로 시작합니다 . 버전 리터럴처럼 보이지 않는 것은 LIST의 시작으로 구문 분석됩니다. 그럼에도 불구하고 &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; 의 &lt;code&gt;import&lt;/code&gt; 메서드는 숫자 인수를 특수하게 처리하여 내보낼 항목으로 처리하지 않고 버전 확인을 수행 하기 때문에 임의의 표현식을 VERSION 인수로 사용하려는 많은 시도가 작동하는 것처럼 보입니다 .</target>
        </trans-unit>
        <trans-unit id="025899dcfc40460b6af9f2e480800fa184584302" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: Keyword</source>
          <target state="translated">VERSIONCHECK : 키워드</target>
        </trans-unit>
        <trans-unit id="191f8a3a602b994bc056ffe04831bd5feed30108" translate="yes" xml:space="preserve">
          <source>The VERSIONCHECK: keyword corresponds to &lt;b&gt;xsubpp&lt;/b&gt;'s &lt;code&gt;-versioncheck&lt;/code&gt; and &lt;code&gt;-noversioncheck&lt;/code&gt; options. This keyword overrides the command line options. Version checking is enabled by default. When version checking is enabled the XS module will attempt to verify that its version matches the version of the PM module.</source>
          <target state="translated">VERSIONCHECK : 키워드는 &lt;b&gt;xsubpp&lt;/b&gt; 의 &lt;code&gt;-versioncheck&lt;/code&gt; 및 &lt;code&gt;-noversioncheck&lt;/code&gt; 옵션에 해당합니다. 이 키워드는 명령 행 옵션을 대체합니다. 버전 확인은 기본적으로 활성화되어 있습니다. 버전 확인이 활성화되면 XS 모듈은 해당 버전이 PM 모듈 버전과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="31810a324065cda0c309cc9a428227e29cec207b" translate="yes" xml:space="preserve">
          <source>The VER_SUITE_xxx names are listed here to cross reference the Microsoft documentation. The Win32 module does not provide symbolic names for these constants.</source>
          <target state="translated">VER_SUITE_xxx 이름은 Microsoft 설명서를 상호 참조하기 위해 여기에 나열되어 있습니다. Win32 모듈은 이러한 상수에 대한 기호 이름을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04e7acc0343752ab985314abfd05d75387072015" translate="yes" xml:space="preserve">
          <source>The VMS operating system has two filesystems, designated by their on-disk structure (ODS) level: ODS-2 and its successor ODS-5. The initial port of Perl to VMS pre-dates ODS-5, but all current testing and development assumes ODS-5 and its capabilities, including case preservation, extended characters in filespecs, and names up to 8192 bytes long.</source>
          <target state="translated">VMS 운영 체제에는 디스크 구조 (ODS) 레벨로 지정된 두 개의 파일 시스템이 있습니다 : ODS-2 및 후속 ODS-5. Perl의 VMS 로의 초기 포트는 ODS-5보다 오래되었지만 현재의 모든 테스트 및 개발은 대소 문자 보존, 파일 스펙의 확장 문자 및 최대 8192 바이트의 이름을 포함한 ODS-5 및 그 기능을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e84afcf35140baf902f87ad4d215db86a487ee71" translate="yes" xml:space="preserve">
          <source>The VMS::DCLsym extension provides access to DCL symbols using a tied hash interface. This allows Perl scripts to manipulate symbols in a manner similar to the way in which logical names are manipulated via the built-in &lt;code&gt;%ENV&lt;/code&gt; hash. Alternatively, one can call methods in this package directly to read, create, and delete symbols.</source>
          <target state="translated">VMS :: DCLsym 확장은 연결된 해시 인터페이스를 사용하여 DCL 기호에 대한 액세스를 제공합니다. 이를 통해 Perl 스크립트는 내장 된 &lt;code&gt;%ENV&lt;/code&gt; 해시 를 통해 논리 이름을 조작하는 방식과 유사한 방식으로 기호를 조작 할 수 있습니다 . 또는이 패키지의 메서드를 직접 호출하여 기호를 읽고, 만들고, 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b30b00a3df196d84b7a24a918a3d0aa60756c262" translate="yes" xml:space="preserve">
          <source>The VOS mailing list.</source>
          <target state="translated">VOS 메일 링리스트.</target>
        </trans-unit>
        <trans-unit id="161e1bfbc06df075efcc1a9cc5552842ca746333" translate="yes" xml:space="preserve">
          <source>The Win32 module contains functions to access Win32 APIs.</source>
          <target state="translated">Win32 모듈에는 Win32 API에 액세스하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e59303fe7c8cd36efc35383c5bbb06ef61bf43f" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState installer for Perl, will modify the Registry to associate the</source>
          <target state="translated">Perl 용 ActiveState 설치 프로그램을 사용할 때 Win95 / NT 설치는 레지스트리를 수정하여</target>
        </trans-unit>
        <trans-unit id="f858558f020a34e7480b07972a3c08c5fd6984b6" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState port of Perl, will modify the Registry to associate the &lt;code&gt;.pl&lt;/code&gt; extension with the perl interpreter. If you install another port, perhaps even building your own Win95/NT Perl from the standard sources by using a Windows port of gcc (e.g., with cygwin or mingw32), then you'll have to modify the Registry yourself. In addition to associating &lt;code&gt;.pl&lt;/code&gt; with the interpreter, NT people can use: &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; to let them run the program &lt;code&gt;install-linux.pl&lt;/code&gt; merely by typing &lt;code&gt;install-linux&lt;/code&gt; .</source>
          <target state="translated">Perl의 ActiveState 포트를 사용할 때 Win95 / NT 설치는 &lt;code&gt;.pl&lt;/code&gt; 확장자를 perl 인터프리터와 연관 시키도록 레지스트리를 수정합니다 . 다른 포트를 설치하는 경우, gcc의 Windows 포트 (예 : cygwin 또는 mingw32 사용)를 사용하여 표준 소스에서 자체 Win95 / NT Perl을 빌드하는 경우에도 레지스트리를 직접 수정해야합니다. &lt;code&gt;.pl&lt;/code&gt; 을 인터프리터와 연관시키는 것 외에도 NT 사용자는 &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; 을 사용 하여 &lt;code&gt;install-linux&lt;/code&gt; 를 입력하여 &lt;code&gt;install-linux.pl&lt;/code&gt; 프로그램을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93475116c0483bce92231ff887f1e0c655785984" translate="yes" xml:space="preserve">
          <source>The Win95/NT installation, when using the ActiveState port of Perl, will modify the Registry to associate the &lt;code&gt;.pl&lt;/code&gt; extension with the perl interpreter. If you install another port, perhaps even building your own Win95/NT Perl from the standard sources by using a Windows port of gcc (e.g., with cygwin or mingw32), then you'll have to modify the Registry yourself. In addition to associating &lt;code&gt;.pl&lt;/code&gt; with the interpreter, NT people can use: &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; to let them run the program &lt;code&gt;install-linux.pl&lt;/code&gt; merely by typing &lt;code&gt;install-linux&lt;/code&gt;.</source>
          <target state="translated">Perl의 ActiveState 포트를 사용할 때 Win95 / NT 설치는 &lt;code&gt;.pl&lt;/code&gt; 확장자를 perl 인터프리터와 연결하도록 레지스트리를 수정합니다 . 다른 포트를 설치하는 경우, gcc의 Windows 포트 (예 : cygwin 또는 mingw32 사용)를 사용하여 표준 소스에서 자체 Win95 / NT Perl을 빌드하는 경우에도 레지스트리를 직접 수정해야합니다. &lt;code&gt;.pl&lt;/code&gt; 을 인터프리터와 연결하는 것 외에도 NT 사용자는 &lt;code&gt;SET PATHEXT=%PATHEXT%;.PL&lt;/code&gt; 을 사용 하여 &lt;code&gt;install-linux&lt;/code&gt; 를 입력하여 &lt;code&gt;install-linux.pl&lt;/code&gt; 프로그램을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="beb45e4cde225026f4e16a740e28e45e50f2309b" translate="yes" xml:space="preserve">
          <source>The Windows SDK can be downloaded from &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt;. The MinGW64 compiler is available at &lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64&lt;/a&gt;. The latter is actually a cross-compiler targeting Win64. There's also a trimmed down compiler (no java, or gfortran) suitable for building perl available at: &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</source>
          <target state="translated">Windows SDK는 &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;http://www.microsoft.com/&lt;/a&gt; 에서 다운로드 할 수 있습니다 . MinGW64 컴파일러는 &lt;a href=&quot;http://sourceforge.net/projects/mingw-w64&quot;&gt;http://sourceforge.net/projects/mingw-w64&lt;/a&gt; 에서 사용할 수 있습니다 . 후자는 실제로 Win64를 대상으로하는 크로스 컴파일러입니다. &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt; 에서 사용할 수있는 perl을 빌드하는 데 적합한 트리밍 된 컴파일러 (Java 또는 gfortran 없음)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbe2efc78435ba8cf6e55fad0149fe59e0e53cf" translate="yes" xml:space="preserve">
          <source>The Windows SDK can be downloaded from &lt;a href=&quot;https://developer.microsoft.com/windows/downloads/sdk-archive&quot;&gt;https://developer.microsoft.com/windows/downloads/sdk-archive&lt;/a&gt;. The MinGW64 compiler is available at &lt;a href=&quot;http://mingw-w64.org&quot;&gt;http://mingw-w64.org&lt;/a&gt;. The latter is actually a cross-compiler targeting Win64. There's also a trimmed down compiler (no java, or gfortran) suitable for building perl available at: &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</source>
          <target state="translated">Windows SDK는 &lt;a href=&quot;https://developer.microsoft.com/windows/downloads/sdk-archive&quot;&gt;https://developer.microsoft.com/windows/downloads/sdk-archive&lt;/a&gt; 에서 다운로드 할 수 있습니다 . MinGW64 컴파일러는 &lt;a href=&quot;http://mingw-w64.org&quot;&gt;http://mingw-w64.org&lt;/a&gt; 에서 사용할 수 있습니다 . 후자는 실제로 Win64를 대상으로하는 크로스 컴파일러입니다. 펄 빌드에 적합한 잘린 컴파일러 (Java 또는 gfortran 없음)도 있습니다. &lt;a href=&quot;http://strawberryperl.com/package/kmx/64_gcctoolchain/&quot;&gt;http://strawberryperl.com/package/kmx/64_gcctoolchain/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1dd1e762380b02f42ad88590f07ac599a582c23" translate="yes" xml:space="preserve">
          <source>The Windows documentation describes the shell parsing rules here: &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&lt;/a&gt; and the C runtime parsing rules here: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt;.</source>
          <target state="translated">Windows 설명서는 여기에서 셸 구문 분석 규칙을 설명합니다. &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&quot;&gt;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&lt;/a&gt; 및 여기 에서 C 런타임 구문 분석 규칙 : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b55eae8f11f90d40d721637c558ef17ead60319e" translate="yes" xml:space="preserve">
          <source>The Windows documentation describes the shell parsing rules here: &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd&quot;&gt;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd&lt;/a&gt; and the C runtime parsing rules here: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&lt;/a&gt;.</source>
          <target state="translated">Windows 설명서에서는 셸 구문 분석 규칙에 대해 설명합니다. &lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd&quot;&gt;https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd&lt;/a&gt; 및 C 런타임 구문 분석 규칙 : &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/17w5ykft%28v=VS.100%29.aspx&quot;&gt;https://msdn.microsoft .com / en-us / library / 17w5ykft % 28v = VS.100 % 29.aspx&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0944600f567f37796a44d203cb305a8c3dc31877" translate="yes" xml:space="preserve">
          <source>The World Factbook maintained by the CIA is a potential source of the data. Unfortunately, it adds/preserves non-standard codes, so it is no longer used as a source of data.</source>
          <target state="translated">CIA가 유지 관리하는 World Factbook은 잠재적 인 데이터 소스입니다. 불행히도 비표준 코드를 추가 / 보존하므로 더 이상 데이터 소스로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91e3c6e2754b93eaf46a2a00de960a8c0e2e11b1" translate="yes" xml:space="preserve">
          <source>The XL C for AIX is integrated in the XL C/C++ for AIX compiler and therefore also supported.</source>
          <target state="translated">AIX 용 XL C는 AIX 컴파일러 용 XL C / C ++에 통합되어 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="26b303e7615c750693be69ec473b2f4dff6fc26e" translate="yes" xml:space="preserve">
          <source>The XPUSH* macros will automatically extend the return stack to prevent it from being overrun. You push values onto the stack in the order you want them seen by the calling program.</source>
          <target state="translated">XPUSH * 매크로는 오버런을 방지하기 위해 리턴 스택을 자동으로 확장합니다. 호출 프로그램에서 원하는 순서대로 값을 스택에 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="a60c05b1221aad4f1b3aa2c5d4dc4eb83e2bb2ba" translate="yes" xml:space="preserve">
          <source>The XROVER command returns reference information for the article(s) specified.</source>
          <target state="translated">XROVER 명령은 지정된 기사에 대한 참조 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11313e63e9f00be77c380f5038dabb62b6e1dd06" translate="yes" xml:space="preserve">
          <source>The XS code, with ellipsis, follows.</source>
          <target state="translated">줄임표가있는 XS 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7fa3ea30854edb41afcb9fc07a8de31e1d1857c" translate="yes" xml:space="preserve">
          <source>The XS compiler is called &lt;b&gt;xsubpp&lt;/b&gt;. This compiler creates the constructs necessary to let an XSUB manipulate Perl values, and creates the glue necessary to let Perl call the XSUB. The compiler uses &lt;b&gt;typemaps&lt;/b&gt; to determine how to map C function parameters and output values to Perl values and back. The default typemap (which comes with Perl) handles many common C types. A supplementary typemap may also be needed to handle any special structures and types for the library being linked. For more information on typemaps, see &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;.</source>
          <target state="translated">XS 컴파일러를 &lt;b&gt;xsubpp&lt;/b&gt; 라고 합니다. 이 컴파일러는 XSUB가 Perl 값을 조작하는 데 필요한 구문을 작성하고 Perl이 XSUB를 호출하는 데 필요한 접착제를 작성합니다. 컴파일러는 &lt;b&gt;타입 맵&lt;/b&gt; 을 사용 하여 C 함수 매개 변수 및 출력 값을 Perl 값으로 매핑하는 방법을 결정합니다. 기본 유형 맵 (Perl과 함께 제공)은 많은 공통 C 유형을 처리합니다. 링크되는 라이브러리에 대한 특수 구조 및 유형을 처리하기 위해 보충 유형 맵이 필요할 수도 있습니다. 타입 맵에 대한 자세한 내용은 &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="316ad807cb25bc3d3f1712abb13698e177372189" translate="yes" xml:space="preserve">
          <source>The XS implementation of &lt;a href=&quot;#set_subname&quot;&gt;&quot;set_subname&quot;&lt;/a&gt; was copied from &lt;a href=&quot;Sub::Name&quot;&gt;Sub::Name&lt;/a&gt; by Matthijs van Duin &amp;lt;xmath@cpan.org&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;#set_subname&quot;&gt;&quot;set_subname&quot;&lt;/a&gt; 의 XS 구현은 Matthijs van Duin &amp;lt;xmath@cpan.org&amp;gt;의 &lt;a href=&quot;Sub::Name&quot;&gt;Sub :: Name&lt;/a&gt; 에서 복사되었습니다.</target>
        </trans-unit>
        <trans-unit id="f7b25a71b5ed14cc6ac2648af9eea46c98febfb6" translate="yes" xml:space="preserve">
          <source>The XS implementation uses code from metamail. Copyright 1991 Bell Communications Research, Inc. (Bellcore)</source>
          <target state="translated">XS 구현은 메타 메일의 코드를 사용합니다. Copyright 1991 Bell Communications Research, Inc. (벨 코어)</target>
        </trans-unit>
        <trans-unit id="d9806f72759923810498b1550dc8fe607f007c38" translate="yes" xml:space="preserve">
          <source>The XS language allows one to describe the mapping between how the C routine is used, and how the corresponding Perl routine is used. It also allows creation of Perl routines which are directly translated to C code and which are not related to a pre-existing C function. In cases when the C interface coincides with the Perl interface, the XSUB declaration is almost identical to a declaration of a C function (in K&amp;amp;R style). In such circumstances, there is another tool called &lt;code&gt;h2xs&lt;/code&gt; that is able to translate an entire C header file into a corresponding XS file that will provide glue to the functions/macros described in the header file.</source>
          <target state="translated">XS 언어를 사용하면 C 루틴 사용 방법과 해당 Perl 루틴 사용 방법 간의 맵핑을 설명 할 수 있습니다. 또한 C 코드로 직접 변환되고 기존 C 함수와 관련이없는 Perl 루틴을 작성할 수 있습니다. C 인터페이스가 Perl 인터페이스와 일치하는 경우 XSUB 선언은 C 함수 선언 (K &amp;amp; R 스타일)과 거의 동일합니다. 이러한 상황에서는 전체 C 헤더 파일을 해당 XS 파일로 변환하여 헤더 파일에 설명 된 기능 / 매크로에 접착제를 제공 할 수있는 &lt;code&gt;h2xs&lt;/code&gt; 라는 도구 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec313ae92b11ca169ff5d7233881fd7bd18d45a" translate="yes" xml:space="preserve">
          <source>The XS module can use INCLUDE: to pull that file into it.</source>
          <target state="translated">XS 모듈은 INCLUDE :를 사용하여 해당 파일을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="218e35287369aa01c3e7fcdd8962b5804ec13123" translate="yes" xml:space="preserve">
          <source>The XSUB follows.</source>
          <target state="translated">XSUB는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e74c8817464edf988ad4bdeab912f47c5f34e75" translate="yes" xml:space="preserve">
          <source>The XSUB mechanism is a simple way for Perl programs to access C subroutines. An XSUB routine will have a stack that contains the arguments from the Perl program, and a way to map from the Perl data structures to a C equivalent.</source>
          <target state="translated">XSUB 메커니즘은 Perl 프로그램이 C 서브 루틴에 액세스하는 간단한 방법입니다. XSUB 루틴에는 Perl 프로그램의 인수가 포함 된 스택과 Perl 데이터 구조에서 동등한 C 구조를 맵핑하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d59b445869847df575ae1068c63533e2dbc9b4f" translate="yes" xml:space="preserve">
          <source>The XSUB will look like the code which follows. A CODE: block is used to call the real rpcb_gettime() function with the parameters in the correct order for that function.</source>
          <target state="translated">XSUB는 다음 코드와 같습니다. CODE : 블록은 해당 함수에 대해 올바른 순서로 매개 변수와 함께 실제 rpcb_gettime () 함수를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4912ec37b73cb1d3321d6d839b0519b8e1f0ad32" translate="yes" xml:space="preserve">
          <source>The XSUB's parameters are usually evaluated immediately after entering the XSUB. The INPUT: keyword can be used to force those parameters to be evaluated a little later. The INPUT: keyword can be used multiple times within an XSUB and can be used to list one or more input variables. This keyword is used with the PREINIT: keyword.</source>
          <target state="translated">XSUB의 매개 변수는 일반적으로 XSUB를 입력 한 직후에 평가됩니다. INPUT : 키워드를 사용하여 해당 매개 변수를 나중에 나중에 강제로 평가할 수 있습니다. INPUT : 키워드는 XSUB 내에서 여러 번 사용될 수 있으며 하나 이상의 입력 변수를 나열하는 데 사용될 수 있습니다. 이 키워드는 PREINIT : 키워드와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="889ae69f0e646c6957d38054ac7106368e38cd84" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent of &lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;. The returned &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structure can be interrogated to find all the information returned to Perl by &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;. Note that XSUBs don't get a stack frame, so &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; will return information for the immediately-surrounding Perl code.</source>
          <target state="translated">XSUB-writer의 &lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt; 와 같습니다 . 반환 된 &lt;code&gt;PERL_CONTEXT&lt;/code&gt; 구조체는 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 의해 Perl에 반환 된 모든 정보를 찾기 위해 조사 될 수 있습니다 . XSUB에는 스택 프레임이 없으므로 &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; 은 바로 주변 Perl 코드에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="38f0167208f5f73a4eea0294315d78c4976d83be" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent of &lt;a href=&quot;perlfunc#caller&quot;&gt;caller()&lt;/a&gt;. The returned &lt;code&gt;PERL_CONTEXT&lt;/code&gt; structure can be interrogated to find all the information returned to Perl by &lt;code&gt;caller&lt;/code&gt;. Note that XSUBs don't get a stack frame, so &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; will return information for the immediately-surrounding Perl code.</source>
          <target state="translated">XSUB 작성기의 &lt;a href=&quot;perlfunc#caller&quot;&gt;caller ()에 해당&lt;/a&gt; 합니다. 반환 된 &lt;code&gt;PERL_CONTEXT&lt;/code&gt; 구조는 &lt;code&gt;caller&lt;/code&gt; 의해 Perl로 반환 된 모든 정보를 찾기 위해 조사 될 수 있습니다 . XSUB는 스택 프레임을 얻지 못하므로 &lt;code&gt;caller_cx(0, NULL)&lt;/code&gt; 은 바로 주변의 Perl 코드에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf42b7fd9e4e74da90d9e8ca347b2091c98166db" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent to Perl's &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Returns &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; for void, scalar or list context, respectively. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for a usage example.</source>
          <target state="translated">XSUB-writer는 Perl의 &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; 와 같습니다 . void, 스칼라 또는 목록 컨텍스트에 대해 각각 &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; 또는 &lt;code&gt;G_ARRAY&lt;/code&gt; 를 리턴 합니다. 사용 예는 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60b6a12693aed888dd9a87c29d13fafdb64bfa25" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's equivalent to Perl's &lt;code&gt;wantarray&lt;/code&gt;. Returns &lt;code&gt;G_VOID&lt;/code&gt;, &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; for void, scalar or list context, respectively. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for a usage example.</source>
          <target state="translated">Perl의 &lt;code&gt;wantarray&lt;/code&gt; 에 해당하는 XSUB 작성자 입니다. void, scalar 또는 list context에 대해 각각 &lt;code&gt;G_VOID&lt;/code&gt; , &lt;code&gt;G_SCALAR&lt;/code&gt; 또는 &lt;code&gt;G_ARRAY&lt;/code&gt; 를 반환 합니다. 사용 예는 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75d69996de0f1c3559d54da444421bb8a65343e9" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;free&lt;/code&gt; function.</source>
          <target state="translated">는 C에 XSUB - 작가의 인터페이스 &lt;code&gt;free&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="4f02f4da65d7f066b59683d438863c2a77521a78" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function, with cast. See also &lt;code&gt;&lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;malloc&lt;/code&gt; 함수에 대한 XSUB 작성기의 인터페이스 ( 캐스트 포함). &lt;code&gt;&lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="407a1fe0a1b35df310a191803c348a1466dc758e" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function, with cast. See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">캐스트와 함께 C &lt;code&gt;malloc&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스 . &lt;code&gt;Newx&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03573c77e22afa37657d3ab695d4f1f77625b4b6" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function.</source>
          <target state="translated">C &lt;code&gt;malloc&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스</target>
        </trans-unit>
        <trans-unit id="bb6fbdec07f505cf20563b49cda07ec35e3c5893" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function. The allocated memory is zeroed with &lt;code&gt;memzero&lt;/code&gt; . See also &lt;code&gt;Newx&lt;/code&gt; .</source>
          <target state="translated">C &lt;code&gt;malloc&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스 할당 된 메모리는 &lt;code&gt;memzero&lt;/code&gt; 로 제로화됩니다 . &lt;code&gt;Newx&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3b4eb02671afcd694c8b668e95b70de9de28970" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;malloc&lt;/code&gt; function. The allocated memory is zeroed with &lt;code&gt;memzero&lt;/code&gt;. See also &lt;code&gt;&lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;malloc&lt;/code&gt; 함수에 대한 XSUB 작성기의 인터페이스 . 할당 된 메모리는 &lt;code&gt;memzero&lt;/code&gt; 로 0이 됩니다 . &lt;code&gt;&lt;a href=&quot;#Newx&quot;&gt;&quot;Newx&quot;&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d6479c07c3b0d97a87e82ed0ae3141425639ab4" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memcpy&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. May fail on overlapping copies. See also &lt;code&gt;&lt;a href=&quot;#Move&quot;&gt;&quot;Move&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;memcpy&lt;/code&gt; 함수에 대한 XSUB 작성기의 인터페이스 입니다. &lt;code&gt;src&lt;/code&gt; 소스입니다 &lt;code&gt;dest&lt;/code&gt; 대상입니다 &lt;code&gt;nitems&lt;/code&gt; 항목의 수이며, &lt;code&gt;type&lt;/code&gt; 유형입니다. 중복 된 사본에서 실패 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#Move&quot;&gt;&quot;Move&quot;&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="012775e63d169c2ca0d945eee45190f976576a44" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memcpy&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. May fail on overlapping copies. See also &lt;code&gt;Move&lt;/code&gt; .</source>
          <target state="translated">C &lt;code&gt;memcpy&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스 &lt;code&gt;src&lt;/code&gt; 소스입니다 &lt;code&gt;dest&lt;/code&gt; 대상입니다 &lt;code&gt;nitems&lt;/code&gt; 항목의 수이며, &lt;code&gt;type&lt;/code&gt; 유형입니다. 중복 사본에서 실패 할 수 있습니다. &lt;code&gt;Move&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c5ac6989d849719aa13ddf9442b260bae933437" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memmove&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. Can do overlapping moves. See also &lt;code&gt;&lt;a href=&quot;#Copy&quot;&gt;&quot;Copy&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;memmove&lt;/code&gt; 기능에 대한 XSUB 작성기의 인터페이스 . &lt;code&gt;src&lt;/code&gt; 소스입니다 &lt;code&gt;dest&lt;/code&gt; 대상입니다 &lt;code&gt;nitems&lt;/code&gt; 항목의 수이며, &lt;code&gt;type&lt;/code&gt; 유형입니다. 겹치는 동작을 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;#Copy&quot;&gt;&quot;Copy&quot;&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45005a2398999be54551083e5df9a69f712a0c93" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memmove&lt;/code&gt; function. The &lt;code&gt;src&lt;/code&gt; is the source, &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type. Can do overlapping moves. See also &lt;code&gt;Copy&lt;/code&gt; .</source>
          <target state="translated">C &lt;code&gt;memmove&lt;/code&gt; 기능에 대한 XSUB-writer 인터페이스 . &lt;code&gt;src&lt;/code&gt; 소스입니다 &lt;code&gt;dest&lt;/code&gt; 대상입니다 &lt;code&gt;nitems&lt;/code&gt; 항목의 수이며, &lt;code&gt;type&lt;/code&gt; 유형입니다. 겹치는 동작을 수행 할 수 있습니다. &lt;code&gt;Copy&lt;/code&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="6a4b16e416d5be5fce93e4644cc50a90934125a5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;memzero&lt;/code&gt; function. The &lt;code&gt;dest&lt;/code&gt; is the destination, &lt;code&gt;nitems&lt;/code&gt; is the number of items, and &lt;code&gt;type&lt;/code&gt; is the type.</source>
          <target state="translated">C &lt;code&gt;memzero&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스 &lt;code&gt;dest&lt;/code&gt; 대상입니다 &lt;code&gt;nitems&lt;/code&gt; 항목의 수이며, &lt;code&gt;type&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="37176570a3748e41537c9ad870ca5c052d9042c5" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function, with cast.</source>
          <target state="translated">캐스트 를 사용하여 C &lt;code&gt;realloc&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="c8ea9501eaec9d4dc35b91e9053fafc1e103de32" translate="yes" xml:space="preserve">
          <source>The XSUB-writer's interface to the C &lt;code&gt;realloc&lt;/code&gt; function.</source>
          <target state="translated">C &lt;code&gt;realloc&lt;/code&gt; 함수에 대한 XSUB-writer 인터페이스</target>
        </trans-unit>
        <trans-unit id="b5f612b4df0e6a83ff9d89b145ebd6884b1f570e" translate="yes" xml:space="preserve">
          <source>The XSUBPP Program</source>
          <target state="translated">XSUBPP 프로그램</target>
        </trans-unit>
        <trans-unit id="1e85e39271c3e660414eb16aa8d858f60416c1a5" translate="yes" xml:space="preserve">
          <source>The XSUBs for the blue() and set_blue() methods are defined with the class name but the parameter for the object (THIS, or &quot;self&quot;) is implicit and is not listed.</source>
          <target state="translated">blue () 및 set_blue () 메소드의 XSUB는 클래스 이름으로 정의되지만 오브젝트의 매개 변수 (THIS 또는 &quot;self&quot;)는 내재되어 있으며 나열되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f515a1ddc8e361ef2e2c6d0f98a0db815d43b99f" translate="yes" xml:space="preserve">
          <source>The YAML files themselves must have the &lt;code&gt;.yml&lt;/code&gt; extension; all other files are ignored (for two exceptions see</source>
          <target state="translated">YAML 파일 자체의 확장자 는 &lt;code&gt;.yml&lt;/code&gt; 이어야합니다 . 다른 모든 파일은 무시됩니다 (두 가지 예외는</target>
        </trans-unit>
        <trans-unit id="d674c081d1720c0407789140462f1119f634eb87" translate="yes" xml:space="preserve">
          <source>The Zxxx, Zyyy, and Zzzz codes are not used.</source>
          <target state="translated">Zxxx, Zyyy 및 Zzzz 코드는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb61dbdf150df0568557c97e9633ab5164b764f0" translate="yes" xml:space="preserve">
          <source>The __DATA__ token</source>
          <target state="translated">__DATA__ 토큰</target>
        </trans-unit>
        <trans-unit id="463e37f3f7783165c25668e9edcd6bb8f407a3e5" translate="yes" xml:space="preserve">
          <source>The _splain_ Program</source>
          <target state="translated">_splain_ 프로그램</target>
        </trans-unit>
        <trans-unit id="14c9176f141fa52e2e9b370433e3e5dfafe8e555" translate="yes" xml:space="preserve">
          <source>The ability of an independent subexpression to prevent backtracking can be quite useful. Suppose we want to match a non-empty string enclosed in parentheses up to two levels deep. Then the following regexp matches:</source>
          <target state="translated">역 추적을 방지하기위한 독립적 인 하위 식의 능력은 매우 유용 할 수 있습니다. 비어 있지 않은 문자열을 괄호로 묶고 최대 2 단계까지 일치 시키려고한다고 가정합니다. 그런 다음 다음 정규 표현식이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d9ff4522b539fedb72c69d4e7d1a591065047a06" translate="yes" xml:space="preserve">
          <source>The ability to create &quot;canned&quot; filters. These allow commonly used filters to be packaged into a stand-alone module.</source>
          <target state="translated">&quot;통조림&quot;필터를 만드는 기능. 이를 통해 일반적으로 사용되는 필터를 독립형 모듈로 패키지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b03d5ecb823d555d353e5848c41c73876ec792" translate="yes" xml:space="preserve">
          <source>The ability to easily apply multiple filters to a single DBM file.</source>
          <target state="translated">단일 DBM 파일에 여러 필터를 쉽게 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc5351dffa5e895e1941f39e52d40f5050cb1a0" translate="yes" xml:space="preserve">
          <source>The ability to interpolate means you can do something like</source>
          <target state="translated">보간 기능은 다음과 같은 작업을 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2a644c13f043d9a916e16c6cb02fd3b3d632a99e" translate="yes" xml:space="preserve">
          <source>The ability to put additional declarations before the typemap entries are processed is very handy in the cases when typemap conversions manipulate some global state:</source>
          <target state="translated">타입 맵 엔트리가 처리되기 전에 추가 선언을하는 기능은 타입 맵 변환이 일부 글로벌 상태를 조작하는 경우에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bca0d0a62c6e09e5d5a84f9c8ee968851fbd9ea7" translate="yes" xml:space="preserve">
          <source>The ability to specify a different outermost delimiter bracket is useful in some circumstances. For example, in the Parse::RecDescent module, parser actions which are to be performed only on a successful parse are specified using a &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive. For example:</source>
          <target state="translated">다른 가장 바깥 쪽 구분 기호를 지정하는 기능은 일부 상황에서 유용합니다. 예를 들어 Parse :: RecDescent 모듈에서 성공적인 구문 분석에서만 수행 될 구문 분석기 조치는 &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; 지시문을 사용하여 지정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7831a4ab904fb19cccaef2cd8bee46906dc6994f" translate="yes" xml:space="preserve">
          <source>The above are all directly tied to the table hashref structure described in &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt;.</source>
          <target state="translated">위의 내용은 모두 &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info에&lt;/a&gt; 설명 된 테이블 해시 참조 구조에 직접 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc890528d2492bad24f35a51d7d007c56cdbd51" translate="yes" xml:space="preserve">
          <source>The above attempts to show how the layer scheme works in a simple case. The application's &lt;code&gt;PerlIO *&lt;/code&gt; points to an entry in the table(s) representing open (allocated) handles. For example the first three slots in the table correspond to &lt;code&gt;stdin&lt;/code&gt; ,&lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; . The table in turn points to the current &quot;top&quot; layer for the handle - in this case an instance of the generic buffering layer &quot;perlio&quot;. That layer in turn points to the next layer down - in this case the low-level &quot;unix&quot; layer.</source>
          <target state="translated">위의 방법은 간단한 경우 계층 구조가 어떻게 작동하는지 보여줍니다. 응용 프로그램의 &lt;code&gt;PerlIO *&lt;/code&gt; 는 열린 (할당 된) 핸들을 나타내는 테이블의 항목을 가리 킵니다. 예를 들어, 표의 처음 3 개 슬롯은 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 에 해당합니다. . 표는 차례로 핸들의 현재 &quot;상위&quot;레이어 (이 경우 일반 버퍼링 레이어 &quot;perlio&quot;의 인스턴스)를 가리 킵니다. 그 레이어는 차례로 다음 레이어를 가리 킵니다.이 경우에는 저수준 &quot;유닉스&quot;레이어입니다.</target>
        </trans-unit>
        <trans-unit id="e0817e79103d9eade83ccf2e685e7a23909668ba" translate="yes" xml:space="preserve">
          <source>The above attempts to show how the layer scheme works in a simple case. The application's &lt;code&gt;PerlIO *&lt;/code&gt; points to an entry in the table(s) representing open (allocated) handles. For example the first three slots in the table correspond to &lt;code&gt;stdin&lt;/code&gt;,&lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;. The table in turn points to the current &quot;top&quot; layer for the handle - in this case an instance of the generic buffering layer &quot;perlio&quot;. That layer in turn points to the next layer down - in this case the low-level &quot;unix&quot; layer.</source>
          <target state="translated">위의 내용은 간단한 경우에 레이어 구성표가 어떻게 작동하는지 보여줍니다. 응용 프로그램의 &lt;code&gt;PerlIO *&lt;/code&gt; 는 열린 (할당 된) 핸들을 나타내는 테이블의 항목을 가리 킵니다. 예를 들어 테이블의 처음 세 슬롯은 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 에 해당합니다 . 그러면 테이블은 핸들의 현재 &quot;상위&quot;레이어 (이 경우 일반 버퍼링 레이어 &quot;perlio&quot;의 인스턴스)를 가리 킵니다. 이 레이어는 차례로 다음 레이어를 가리 킵니다.이 경우에는 저수준 &quot;unix&quot;레이어를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="1f2bd16bb7c121630627629d4088e69bc48879ce" translate="yes" xml:space="preserve">
          <source>The above cautionary tale relates how an attempt at localization can lead from programmer consternation, to program obfuscation, to a need for sedation. But careful evaluation shows that your choice of tools merely needed further consideration.</source>
          <target state="translated">위의 경고 이야기는 지역화 시도가 프로그래머의 당혹감, 프로그램 난독 화, 진정의 필요성으로 이어질 수있는 방법과 관련이 있습니다. 그러나 신중한 평가에 따르면 도구 선택에 더 많은 고려가 필요하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="154e8ab9c566d8ad2aa028157cde5973bb6a8d8d" translate="yes" xml:space="preserve">
          <source>The above code is shorthand for, and will be interpreted as, this:</source>
          <target state="translated">위의 코드는 다음의 약칭이며 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="abf94dbab29db68325894cd60a65f3c2a1fc56fa" translate="yes" xml:space="preserve">
          <source>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</source>
          <target state="translated">상기 저작권 고지 및이 허가 고지는 소프트웨어의 모든 사본 또는 상당 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="920a0c05a1870979970a148b0bf6f893a03606b0" translate="yes" xml:space="preserve">
          <source>The above example code blocks also suggest how to use &lt;code&gt;reduce&lt;/code&gt; to build a more efficient combined version of one of these basic functions and a &lt;code&gt;map&lt;/code&gt; block. For example, to find the total length of all the strings in a list, we could use</source>
          <target state="translated">위의 예제 코드 블록 은 이러한 기본 기능 중 하나와 &lt;code&gt;map&lt;/code&gt; 블록 의보다 효율적인 결합 버전을 빌드 하기 위해 &lt;code&gt;reduce&lt;/code&gt; 를 사용하는 방법을 제안합니다 . 예를 들어, 목록에있는 모든 문자열의 총 길이를 찾으려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="267b118ff06011e806ac608fae00f2938fa2a609" translate="yes" xml:space="preserve">
          <source>The above example works only if &lt;code&gt;&quot;s&quot;&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt; -terminated; otherwise you have to pass its length to &lt;code&gt;newSVpv&lt;/code&gt; .</source>
          <target state="translated">위의 예제는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 가 &lt;code&gt;NUL&lt;/code&gt; 로 종료 된 경우에만 작동합니다 . 그렇지 않으면 길이를 &lt;code&gt;newSVpv&lt;/code&gt; 로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c8de591a9f5de43bfe220525cc4252c1a69ffea" translate="yes" xml:space="preserve">
          <source>The above example works only if &lt;code&gt;&quot;s&quot;&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;-terminated; otherwise you have to pass its length to &lt;code&gt;newSVpv&lt;/code&gt;.</source>
          <target state="translated">위의 예는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 가 &lt;code&gt;NUL&lt;/code&gt; 로 끝나는 경우에만 작동합니다 . 그렇지 않으면 길이를 &lt;code&gt;newSVpv&lt;/code&gt; 로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a24a47b6e29ea30653b134f5da5c978447aa0575" translate="yes" xml:space="preserve">
          <source>The above example would print out the message:</source>
          <target state="translated">위의 예는 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f4ebb52f7b218814c788462297b6da7a43f52650" translate="yes" xml:space="preserve">
          <source>The above four are optional except in other formatting codes, notably &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , and when preceded by a capital letter.</source>
          <target state="translated">위의 네 개는 다른 형식화 ​​코드, 특히 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 및 대문자가 앞에 오는 경우를 제외하고는 선택 사항 입니다.</target>
        </trans-unit>
        <trans-unit id="c78371758c589c3c8bfb3fd5e20c39861ce480e6" translate="yes" xml:space="preserve">
          <source>The above four are optional except in other formatting codes, notably &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt;, and when preceded by a capital letter.</source>
          <target state="translated">위의 4 개는 다른 형식화 ​​코드 (특히 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; )와 대문자가 앞에 오는 경우를 제외하고는 선택 사항 입니다.</target>
        </trans-unit>
        <trans-unit id="dd54f214af2e16fd555100563837da248db5495d" translate="yes" xml:space="preserve">
          <source>The above is a somewhat simplified view of what really happens. Since Perl allows more flexible calling conventions than C, XSUBs may do much more in practice, such as checking input parameters for validity, throwing exceptions (or returning undef/empty list) if the return value from the C function indicates failure, calling different C functions based on numbers and types of the arguments, providing an object-oriented interface, etc.</source>
          <target state="translated">위의 내용은 실제 상황에 대한 약간 단순화 된 견해입니다. Perl은 C보다 더 유연한 호출 규칙을 허용하므로, XSUB는 유효성에 대한 입력 매개 변수 확인, C 함수의 반환 값이 실패를 나타내면 다른 C를 호출하는 경우 예외 발생 (또는 undef / empty 목록 반환)과 같이 실제로 훨씬 더 많은 작업을 수행 할 수 있습니다. 인수의 숫자와 유형에 기반한 함수, 객체 지향 인터페이스 제공 등</target>
        </trans-unit>
        <trans-unit id="754ca936a964e1d5816b54783f4e5f1ce663020d" translate="yes" xml:space="preserve">
          <source>The above is roughly equivalent to a &quot;stdio&quot; buffered stream, but with much more flexibility:</source>
          <target state="translated">위의 내용은 &quot;stdio&quot;버퍼링 스트림과 거의 동일하지만 훨씬 더 융통성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcad7cfc523d43a196084786f96b8329cc3ac60" translate="yes" xml:space="preserve">
          <source>The above module is very primitive. It does not implement mutator methods (&lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; and so on), does not do deep copying (not required without mutators!), and implements only those arithmetic operations which are used in the example.</source>
          <target state="translated">위의 모듈은 매우 원시적입니다. 뮤 테이터 메소드 ( &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등)를 구현하지 않고 딥 카피 (뮤 테이터 없이는 필요하지 않음)를 수행하지 않으며 예제에서 사용 된 산술 연산 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f65aa9e6c0ae33d210ebc8743e7e8c52d83cdaaa" translate="yes" xml:space="preserve">
          <source>The above module is very primitive. It does not implement mutator methods (&lt;code&gt;++&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt; and so on), does not do deep copying (not required without mutators!), and implements only those arithmetic operations which are used in the example.</source>
          <target state="translated">위의 모듈은 매우 원시적입니다. 뮤 테이터 메서드 ( &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등)를 구현하지 않고, 딥 카피를 수행하지 않으며 (뮤 테이터 없이는 필요하지 않습니다!), 예제에서 사용 된 산술 연산 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0224abc4d53f4853654c5321f1ed40b4253ec78d" translate="yes" xml:space="preserve">
          <source>The above procedure describes a basic environment and hence results in a basic Perl. If you want to add additional libraries to Perl, you may need some extra settings.</source>
          <target state="translated">위의 절차는 기본 환경을 설명하므로 기본 Perl이 생성됩니다. Perl에 추가 라이브러리를 추가하려면 몇 가지 추가 설정이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="281ac3a4234dba5767807b1f7ef90bcb868fb84e" translate="yes" xml:space="preserve">
          <source>The above recipes describe the ordering of matches</source>
          <target state="translated">위의 요리법은 경기의 순서를 설명합니다</target>
        </trans-unit>
        <trans-unit id="abb826d1f92a77f8ee5fb15c131983e89da595f3" translate="yes" xml:space="preserve">
          <source>The above search for &quot;interpreter&quot; is recursive: if</source>
          <target state="translated">위의 &quot;통역사&quot;에 대한 검색은 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="b606cf43c801f260cbdfb890db240a19d58a3f8e" translate="yes" xml:space="preserve">
          <source>The above subroutine may be called with either one or two arguments. The default value expression is evaluated when the subroutine is called, so it may provide different default values for different calls. It is only evaluated if the argument was actually omitted from the call. For example,</source>
          <target state="translated">위의 서브 루틴은 하나 또는 두 개의 인수로 호출 될 수 있습니다. 서브 루틴이 호출 될 때 디폴트 값 표현식이 평가되므로 호출마다 다른 디폴트 값을 제공 할 수 있습니다. 인수가 실제로 호출에서 생략 된 경우에만 평가됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="54c21b6df45da0f9df4499ebff5512482a22c709" translate="yes" xml:space="preserve">
          <source>The above test passes two values to &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; -- the first a coderef, and the second is the number 4. Before &lt;code&gt;ok&lt;/code&gt; compares them, it calls the coderef, and uses its return value as the real value of this parameter. Assuming that &lt;code&gt;$bytecount&lt;/code&gt; returns 4, &lt;code&gt;ok&lt;/code&gt; ends up testing &lt;code&gt;4 eq 4&lt;/code&gt; . Since that's true, this test passes.</source>
          <target state="translated">상기 시험은 2 개 값 전달 &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; - 제의 코드 참조를, 두번째 이전 수가 4 인 &lt;code&gt;ok&lt;/code&gt; 그들을 비교는 코드 참조를 호출하고,이 파라미터의 실제 값으로 반환 값을 사용 . &lt;code&gt;$bytecount&lt;/code&gt; 가 4를 리턴 한다고 가정하면 &lt;code&gt;ok&lt;/code&gt; 는 &lt;code&gt;4 eq 4&lt;/code&gt; 테스트를 끝냅니다 . 사실이므로이 테스트는 통과합니다.</target>
        </trans-unit>
        <trans-unit id="4124d08100af679d2e8922e200fdad5fa0d10475" translate="yes" xml:space="preserve">
          <source>The above test passes two values to &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; -- the first a coderef, and the second is the number 4. Before &lt;code&gt;ok&lt;/code&gt; compares them, it calls the coderef, and uses its return value as the real value of this parameter. Assuming that &lt;code&gt;$bytecount&lt;/code&gt; returns 4, &lt;code&gt;ok&lt;/code&gt; ends up testing &lt;code&gt;4 eq 4&lt;/code&gt;. Since that's true, this test passes.</source>
          <target state="translated">위의 테스트는 두 값을 &lt;code&gt;ok(arg1, arg2)&lt;/code&gt; 합니다. 첫 번째는 coderef이고 두 번째는 숫자 4입니다. &lt;code&gt;ok&lt;/code&gt; 가이를 비교 하기 전에 coderef를 호출하고 반환 값을이 매개 변수의 실제 값으로 사용합니다. . &lt;code&gt;$bytecount&lt;/code&gt; 가 4를 반환 한다고 가정하면 &lt;code&gt;ok&lt;/code&gt; 는 &lt;code&gt;4 eq 4&lt;/code&gt; 테스트를 종료합니다 . 사실이므로이 테스트는 통과합니다.</target>
        </trans-unit>
        <trans-unit id="b1ef6a2bf455cf77affd01d5de26884f122aeca1" translate="yes" xml:space="preserve">
          <source>The above variables have all been localized and may be changed without affecting data outside of the wanted function.</source>
          <target state="translated">위의 변수는 모두 현지화되었으며 원하는 기능 외부의 데이터에 영향을 미치지 않고 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae51a1ce20f245092ecaad634de2dfa1ff5d3441" translate="yes" xml:space="preserve">
          <source>The above won't happen every time competing process update the same &lt;b&gt;DB_File&lt;/b&gt; database, but it does illustrate why the technique should not be used.</source>
          <target state="translated">위의 내용은 경쟁 프로세스가 동일한 &lt;b&gt;DB_File&lt;/b&gt; 데이터베이스를 업데이트 할 때마다 발생 하지는 않지만 기술을 사용하지 않아야하는 이유를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc41a4f0a3f76304cef64d6e5a6ef09703d79c81" translate="yes" xml:space="preserve">
          <source>The accept method will perform the system call &lt;code&gt;accept&lt;/code&gt; on the socket and return a new object. The new object will be created in the same class as the listen socket, unless a specific package name is specified. This object can be used to communicate with the client that was trying to connect.</source>
          <target state="translated">accept 메소드는 소켓 에서 시스템 호출 &lt;code&gt;accept&lt;/code&gt; 를 수행하고 새 객체를 반환합니다. 특정 패키지 이름이 지정되지 않은 경우 새 객체는 청취 소켓과 동일한 클래스에 생성됩니다. 이 개체는 연결을 시도한 클라이언트와 통신하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1ad066d4a66bd948f60c33d21673c18f0eb993" translate="yes" xml:space="preserve">
          <source>The accessor method provided by &lt;code&gt;struct&lt;/code&gt; for an element depends on the declared type of the element.</source>
          <target state="translated">요소에 대한 &lt;code&gt;struct&lt;/code&gt; 에서 제공하는 접근 자 메서드 는 선언 된 요소 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2cc7abc6dcf89e4b9609885153970267df830f15" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; . Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return an array reference with the first element being a hash reference, and the remaining methods should operate on the hash &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; :</source>
          <target state="translated">접근 자 메서드는 연결된 해시의 데이터에 대한 실제 저장소가 &lt;code&gt;(&lt;a href=&quot;../functions/tied&quot;&gt;tied&lt;/a&gt;(%tiedhash))-&amp;gt;[0]&lt;/code&gt; 의해 참조되는 해시에 있다고 가정합니다 . 따라서 덮어 쓴 &lt;code&gt;TIEHASH&lt;/code&gt; 메소드는 첫 번째 요소가 해시 참조 인 배열 참조를 리턴해야하며 나머지 메소드는 해시 &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7a99d41dec80efd3bb967ed05e291afdbfc948b" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;(tied(%tiedhash))-&amp;gt;[0]&lt;/code&gt;. Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return an array reference with the first element being a hash reference, and the remaining methods should operate on the hash &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt;:</source>
          <target state="translated">접근 자 메서드는 연결된 해시의 데이터에 대한 실제 저장소가 &lt;code&gt;(tied(%tiedhash))-&amp;gt;[0]&lt;/code&gt; 참조하는 해시에 있다고 가정합니다 . 따라서 덮어 쓴 &lt;code&gt;TIEHASH&lt;/code&gt; 메서드는 첫 번째 요소가 해시 참조 인 배열 참조를 반환해야하며 나머지 메서드는 해시 &lt;code&gt;%{ $_[0]-&amp;gt;[0] }&lt;/code&gt; 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="225d5409f9e31ec1fd3549dba0dd919b3904ec0c" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;. Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return a hash reference, and the remaining methods should operate on the hash referenced by the first argument:</source>
          <target state="translated">접근 자 메서드는 연결된 해시의 데이터에 대한 실제 저장소가 &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; 참조하는 해시에 있다고 가정합니다 . 따라서 덮어 쓴 &lt;code&gt;TIEHASH&lt;/code&gt; 메소드는 해시 참조를 리턴해야하며 나머지 메소드는 첫 번째 인수가 참조하는 해시에서 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="22c3cbe07ec593efd22ad406908293c52e255fa1" translate="yes" xml:space="preserve">
          <source>The accessor methods assume that the actual storage for the data in the tied hash is in the hash referenced by &lt;code&gt;tied(%tiedhash)&lt;/code&gt;. Thus overwritten &lt;code&gt;TIEHASH&lt;/code&gt; method should return a hash reference, and the remaining methods should operate on the hash referenced by the first argument:</source>
          <target state="translated">접근 자 메서드는 묶인 해시의 데이터에 대한 실제 저장소가 &lt;code&gt;tied(%tiedhash)&lt;/code&gt; 참조하는 해시에 있다고 가정합니다 . 따라서 덮어 쓴 &lt;code&gt;TIEHASH&lt;/code&gt; 메서드는 해시 참조를 반환해야하며 나머지 메서드는 첫 번째 인수가 참조하는 해시에서 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="2198a837e059e4191004ad59c18436a206b5087a" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element.</source>
          <target state="translated">접근 자의 인수가 있다면 요소에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="0a55122025df9d01179435aa1526880dbd188b0d" translate="yes" xml:space="preserve">
          <source>The accessor's argument, if any, is assigned to the element. The accessor will &lt;code&gt;croak&lt;/code&gt; if this is not an appropriate object reference.</source>
          <target state="translated">접근 자의 인수가 있다면 요소에 할당됩니다. 이것이 적절한 객체 참조가 아닌 경우 접근자는 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc291805bbdf71f35da9613fd10fc72effdd81d3" translate="yes" xml:space="preserve">
          <source>The act of calling up a deity, daemon, program, method, subroutine, or function to get it to do what you think it&amp;rsquo;s supposed to do. We usually &amp;ldquo;call&amp;rdquo; subroutines but &amp;ldquo;invoke&amp;rdquo; methods, since it sounds cooler.</source>
          <target state="translated">생각,해야 할 일을하기 위해 신, 데몬, 프로그램, 메소드, 서브 루틴 또는 함수를 호출하는 행위. 우리는 보통 서브 루틴을 &quot;호출&quot;하지만 더 시원하게 들리기 때문에 &quot;호출&quot;메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0aae7e6b56823ac18d0d863614b52f8ccee20556" translate="yes" xml:space="preserve">
          <source>The act of emptying a &lt;b&gt;buffer&lt;/b&gt;, often before it&amp;rsquo;s full.</source>
          <target state="translated">&lt;b&gt;버퍼&lt;/b&gt; 가 가득 차기 전에 &lt;b&gt;버퍼&lt;/b&gt; 를 비우는 동작 .</target>
        </trans-unit>
        <trans-unit id="da4cbb2e16fc1345262c617dbbfacc0e9a82482b" translate="yes" xml:space="preserve">
          <source>The action begins in</source>
          <target state="translated">행동은</target>
        </trans-unit>
        <trans-unit id="a59fa9853137f7a626cc876fbba010fe4429a3bd" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;SvUTF8&lt;/code&gt; flag of the &lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt; scalar is significant, but not the whole story regarding the input character encoding. Normally, when a file is being read, the scalar contains octets and its &lt;code&gt;SvUTF8&lt;/code&gt; flag is off, but the octets should be interpreted as UTF-8 if the &lt;code&gt;use utf8&lt;/code&gt; pragma is in effect. During a string eval, however, the scalar may have the &lt;code&gt;SvUTF8&lt;/code&gt; flag on, and in this case its octets should be interpreted as UTF-8 unless the &lt;code&gt;use bytes&lt;/code&gt; pragma is in effect. This logic may change in the future; use this function instead of implementing the logic yourself.</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt; linestr&quot;&lt;/a&gt; 스칼라 의 실제 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그 는 중요하지만 입력 문자 인코딩에 관한 전체 스토리는 아닙니다. 일반적으로 파일을 읽을 때 스칼라에는 옥텟이 포함되고 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그가 꺼져 있지만 &lt;code&gt;use utf8&lt;/code&gt; pragma 사용 이 유효한 경우 옥텟은 UTF-8로 해석되어야합니다 . 그러나 문자열 평가 중에 스칼라는 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 켤 수 있으며, 이 경우 &lt;code&gt;use bytes&lt;/code&gt; pragma가 적용 되지 않는 한 해당 옥텟은 UTF-8로 해석되어야합니다 . 이 논리는 나중에 변경 될 수 있습니다. 로직을 직접 구현하는 대신이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c50575ea6cd15b6f99786b019f7fd7d151291681" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;SvUTF8&lt;/code&gt; flag of the &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt; scalar is significant, but not the whole story regarding the input character encoding. Normally, when a file is being read, the scalar contains octets and its &lt;code&gt;SvUTF8&lt;/code&gt; flag is off, but the octets should be interpreted as UTF-8 if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma is in effect. During a string eval, however, the scalar may have the &lt;code&gt;SvUTF8&lt;/code&gt; flag on, and in this case its octets should be interpreted as UTF-8 unless the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma is in effect. This logic may change in the future; use this function instead of implementing the logic yourself.</source>
          <target state="translated">&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt; 스칼라 의 실제 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그 는 중요하지만 입력 문자 인코딩에 관한 전체 스토리는 아닙니다. 일반적으로 파일을 읽을 때 스칼라는 옥텟을 포함하고 해당 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그가 꺼져 있지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효 하면 옥텟은 UTF-8로 해석되어야합니다 . 그러나 문자열 평가 중에 스칼라에 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그 가 설정되어있을 수 있으며이 경우 8 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 바이트 pragma가 적용 되지 않는 한 8 진수는 UTF-8로 해석되어야합니다 . 이 논리는 나중에 변경 될 수 있습니다. 로직을 직접 구현하는 대신이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a94b4ce4a496025784aac08e7538a717b7eb0307" translate="yes" xml:space="preserve">
          <source>The actual achievable subsecond resolution depends on the combination of the operating system and the filesystem.</source>
          <target state="translated">실제 달성 가능한 1 초 미만의 해상도는 운영 체제와 파일 시스템의 조합에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="688c727fc0925c53d58507ba1b9428c5b1709811" translate="yes" xml:space="preserve">
          <source>The actual definition of what shrink does might change in future versions, but it will always try to save space at the expense of time.</source>
          <target state="translated">Shrink가 수행하는 작업의 실제 정의는 향후 버전에서 변경 될 수 있지만 항상 시간을 희생하면서 공간을 절약하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7dd5fba3f25088e2897b2cb955245840fd943e5f" translate="yes" xml:space="preserve">
          <source>The actual difference between PPCODE: and CODE: sections is in the initialization of &lt;code&gt;SP&lt;/code&gt; macro (which stands for the</source>
          <target state="translated">PPCODE :와 CODE : 섹션의 실제 차이점은 &lt;code&gt;SP&lt;/code&gt; 매크로 의 초기화 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8adbcba0e7f4d6240d43127016adb7bebb0e850" translate="yes" xml:space="preserve">
          <source>The actual functions called are known as PP code, and they're spread between four files:</source>
          <target state="translated">호출되는 실제 함수는 PP 코드라고하며 4 개의 파일로 분산되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fed5c7ec6f1ab01c643aa93a8adb0f82c40adfa" translate="yes" xml:space="preserve">
          <source>The actual numbers are stored as unsigned big integers (with separate sign).</source>
          <target state="translated">실제 숫자는 부호없는 큰 정수 (별도의 부호)로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7371146aaafc3d93e00f035ea0ab638040fbcf08" translate="yes" xml:space="preserve">
          <source>The actual permissions set depend on the value of the &lt;code&gt;CYGWIN&lt;/code&gt; in the SYSTEM environment settings. (Cygwin)</source>
          <target state="translated">실제 권한 설정은 SYSTEM 환경 설정 의 &lt;code&gt;CYGWIN&lt;/code&gt; 값에 따라 다릅니다 . (사이 윈)</target>
        </trans-unit>
        <trans-unit id="6f09daaa018160f529d356d689ea131810985b7e" translate="yes" xml:space="preserve">
          <source>The actual sizes (in bytes) of native shorts, ints, longs, and long longs on the platform where Perl was built are also available from the command line:</source>
          <target state="translated">Perl이 빌드 된 플랫폼에서 기본 short, int, long 및 long long의 실제 크기 (바이트)도 명령 행에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9688cf79c9a25cc4e9f2e8b4c5ac878b783210d" translate="yes" xml:space="preserve">
          <source>The actual values on the argument stack are pointers to the values passed in. When an argument is listed as being an OUTPUT value, its corresponding value on the stack (i.e., ST(0) if it was the first argument) is changed. You can verify this by looking at the C code generated for Example 3. The code for the round() XSUB routine contains lines that look like this:</source>
          <target state="translated">인수 스택의 실제 값은 전달 된 값에 대한 포인터입니다. 인수가 OUTPUT 값으로 나열되면 스택의 해당 값 (즉, 첫 번째 인수 인 경우 ST (0))이 변경됩니다. 예제 3에 대해 생성 된 C 코드를 보면이를 확인할 수 있습니다. round () XSUB 루틴의 코드는 다음과 같은 행을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9efd0030f2fab9c72c68391b18e8706f0e577dc3" translate="yes" xml:space="preserve">
          <source>The add_bits() method is an alternative to add() that allow partial bytes to be appended to the message. Most users should just ignore this method as partial bytes is very unlikely to be of any practical use.</source>
          <target state="translated">add_bits () 메소드는 메시지에 부분 바이트를 추가 할 수있는 add ()의 대안입니다. 부분 바이트는 실용적이지 않기 때문에 대부분의 사용자는이 방법을 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="4385ce0c6decd2654eecaf2223aa22c33620d447" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $ctx object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $ctx object if this occurs.</source>
          <target state="translated">addfile () 메소드는 어떤 이유로 데이터 읽기에 실패하면 croak ()합니다. 삐걱 거리면 $ ctx 객체의 상태를 예측할 수 없습니다. addfile () 메소드는 파일이 실패하기 전에 파일을 부분적으로 읽을 수있었습니다. 이것이 발생하면 $ ctx 객체를 삭제하거나 재설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29515a29b800fb1b3a5d264f9d3d2a8c7827591b" translate="yes" xml:space="preserve">
          <source>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $md5 object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $md5 object if this occurs.</source>
          <target state="translated">addfile () 메소드는 어떤 이유로 데이터 읽기에 실패하면 croak ()합니다. 삐걱 거리면 $ md5 객체의 상태를 예측할 수 없습니다. addfile () 메소드는 실패하기 전에 파일을 부분적으로 읽을 수있었습니다. 이 경우 $ md5 객체를 삭제하거나 재설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bad770ef214b3ea483bf0a738f9ad60704fafe4f" translate="yes" xml:space="preserve">
          <source>The addition of threads has changed Perl's internals substantially. There are implications for people who write modules with XS code or external libraries. However, since Perl data is not shared among threads by default, Perl modules stand a high chance of being thread-safe or can be made thread-safe easily. Modules that are not tagged as thread-safe should be tested or code reviewed before being used in production code.</source>
          <target state="translated">스레드의 추가로 Perl의 내부가 크게 변경되었습니다. XS 코드 또는 외부 라이브러리로 모듈을 작성하는 사람들에게는 의미가 있습니다. 그러나 Perl 데이터는 기본적으로 스레드간에 공유되지 않기 때문에 Perl 모듈은 스레드로부터 안전하거나 스레드로부터 안전하게 만들 수 있습니다. 스레드 안전으로 태그가 지정되지 않은 모듈은 프로덕션 코드에서 사용하기 전에 테스트하거나 코드를 검토해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fb5062c416df742306ccabb4b5f706bc8df9b28" translate="yes" xml:space="preserve">
          <source>The additional state of being</source>
          <target state="translated">추가 상태</target>
        </trans-unit>
        <trans-unit id="e003249c8de3365551eedf50a46a7442176acc5e" translate="yes" xml:space="preserve">
          <source>The address family (e.g. &lt;code&gt;AF_INET&lt;/code&gt; )</source>
          <target state="translated">주소 패밀리 (예 : &lt;code&gt;AF_INET&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7bf70fa18ad1c20233643e58c97888e7efb3d875" translate="yes" xml:space="preserve">
          <source>The address family (e.g. &lt;code&gt;AF_INET&lt;/code&gt;)</source>
          <target state="translated">주소 계열 (예 : &lt;code&gt;AF_INET&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1b40bb6ad6bb7b6aebc6d2cbbbcbc39a9a863860" translate="yes" xml:space="preserve">
          <source>The address family to pass to &lt;code&gt;getaddrinfo&lt;/code&gt; (e.g. &lt;code&gt;AF_INET&lt;/code&gt;, &lt;code&gt;AF_INET6&lt;/code&gt;). Normally this will be left undefined, and &lt;code&gt;getaddrinfo&lt;/code&gt; will search using any address family supported by the system.</source>
          <target state="translated">&lt;code&gt;getaddrinfo&lt;/code&gt; 에 전달할 주소 계열 (예 : &lt;code&gt;AF_INET&lt;/code&gt; , &lt;code&gt;AF_INET6&lt;/code&gt; ). 일반적으로 이것은 정의되지 않은 상태로 유지되며 &lt;code&gt;getaddrinfo&lt;/code&gt; 는 시스템에서 지원하는 모든 주소 계열을 사용하여 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f126536906b38b811e2283014aef5b17fb2a2bb1" translate="yes" xml:space="preserve">
          <source>The address in a packed string (such as would be returned by pack_sockaddr_in())</source>
          <target state="translated">묶음 문자열의 주소 (예 : pack_sockaddr_in ()에 의해 반환 됨)</target>
        </trans-unit>
        <trans-unit id="9ca884174256cffd8e2121d14b1b2f9600471f92" translate="yes" xml:space="preserve">
          <source>The address of the OP's SV, if it has an SV, in hexadecimal.</source>
          <target state="translated">SV가있는 경우 OP의 SV 주소는 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="452ef6486bc83e321d333ed85c0a567a4e8c1783" translate="yes" xml:space="preserve">
          <source>The address of the OP's first child, in hexadecimal.</source>
          <target state="translated">OP의 첫 번째 자식 주소 (16 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="2838690d17f05c70e3e67bc06eecc94e3f275b6e" translate="yes" xml:space="preserve">
          <source>The address of the OP's last child, in hexadecimal.</source>
          <target state="translated">OP의 마지막 자식 주소 (16 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="e332f1e7f698853a5727152a76eca59b2c2b494a" translate="yes" xml:space="preserve">
          <source>The address of the OP's next OP, in hexadecimal.</source>
          <target state="translated">OP의 다음 OP 주소 (16 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="1290cc2c32604c72580d6a56eb9a2ca86ec89ccf" translate="yes" xml:space="preserve">
          <source>The address of the OP's next youngest sibling, in hexadecimal.</source>
          <target state="translated">OP의 다음 막내 형제 주소 (16 진수).</target>
        </trans-unit>
        <trans-unit id="b68836e0a8059af6d65948c4349c2eade8a16af3" translate="yes" xml:space="preserve">
          <source>The address of the OP, in hexadecimal.</source>
          <target state="translated">OP의 주소 (16 진)입니다.</target>
        </trans-unit>
        <trans-unit id="09ebb8cc7d0fd73db86fd8a64bea18fe0c098b0c" translate="yes" xml:space="preserve">
          <source>The address tables of DLLs are patched only once, when they are loaded. The addresses of the entry points into DLLs are guaranteed to be the same for all the programs which use the same DLL. This removes the runtime fixup - once DLL is loaded, its code is read-only.</source>
          <target state="translated">DLL의 주소 테이블은로드 될 때 한 번만 패치됩니다. DLL 진입 점의 주소는 동일한 DLL을 사용하는 모든 프로그램에서 동일하게 보장됩니다. 이렇게하면 런타임 수정이 제거됩니다. 일단 DLL이로드되면 해당 코드는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="c74bfa2ec2baf330be7b8d46296fdd61de05ff99" translate="yes" xml:space="preserve">
          <source>The advantage of this approach comparing to ALIAS: keyword is that there is no need to code a switch statement, each Perl function (which shares the same XSUB) knows which C function it should call. Additionally, one can attach an extra function remainder() at runtime by using</source>
          <target state="translated">ALIAS : 키워드와 비교할 때이 방법의 장점은 스위치 명령문을 코딩 할 필요가 없다는 것입니다. 각 Perl 함수 (동일한 XSUB를 공유 함)는 호출해야하는 C 함수를 알고 있습니다. 또한 런타임에 다음을 사용하여 추가 함수 나머지 ()를 첨부 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1ba0a293372a8086f2c3cb8bd66f4ad49631031c" translate="yes" xml:space="preserve">
          <source>The advantage of this technique is that you have complete control over the implementation of your filter. The big disadvantage is the increased complexity required to write the filter - not only do you need to understand the source filter hooks, but you also need a reasonable knowledge of Perl guts. One of the few times it is worth going to this trouble is when writing a source scrambler. The &lt;code&gt;decrypt&lt;/code&gt; filter (which unscrambles the source before Perl parses it) included with the source filter distribution is an example of a C source filter (see Decryption Filters, below).</source>
          <target state="translated">이 기술의 장점은 필터 구현을 완전히 제어 할 수 있다는 것입니다. 가장 큰 단점은 필터를 작성하는 데 필요한 복잡성이 증가한다는 것입니다. 소스 필터 후크를 이해해야 할뿐만 아니라 Perl 내장에 대한 합리적인 지식이 필요합니다. 소스 스크램블러를 작성할 때이 문제를 해결해야 할 때가 있습니다. &lt;code&gt;decrypt&lt;/code&gt; 소스 필터 분포 포함 (펄을 파싱하기 전에 소스 스크램블을 풉니) 필터 (이하, 해독 필터 참조) C 소스 필터의 예이다.</target>
        </trans-unit>
        <trans-unit id="072e0efbeb225d357c21442cc8c46a3dcf93b381" translate="yes" xml:space="preserve">
          <source>The advantage of using the above macros is that you don't have to setup an extra function for &lt;code&gt;call_*&lt;/code&gt; , and that using these macros is faster than using &lt;code&gt;call_*&lt;/code&gt; .</source>
          <target state="translated">위의 매크로를 사용하면 &lt;code&gt;call_*&lt;/code&gt; 에 추가 기능을 설정할 필요가 없으며 이러한 매크로를 사용하는 것이 &lt;code&gt;call_*&lt;/code&gt; 를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="a1fbd017120fed3df83cd151b13ad466853145db" translate="yes" xml:space="preserve">
          <source>The advantage of using the above macros is that you don't have to setup an extra function for &lt;code&gt;call_*&lt;/code&gt;, and that using these macros is faster than using &lt;code&gt;call_*&lt;/code&gt;.</source>
          <target state="translated">위의 매크로를 사용할 때의 장점은 &lt;code&gt;call_*&lt;/code&gt; 에 대한 추가 함수를 설정할 필요가 없으며 이러한 매크로를 사용하는 것이 &lt;code&gt;call_*&lt;/code&gt; 를 사용하는 것보다 빠르다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="53174719bc4a34362607e16e39670825ed959235" translate="yes" xml:space="preserve">
          <source>The agent on whose behalf a &lt;b&gt;method&lt;/b&gt; is invoked. In a &lt;b&gt;class&lt;/b&gt; method, the invocant is a package name. In an &lt;b&gt;instance&lt;/b&gt; method, the invocant is an object reference.</source>
          <target state="translated">&lt;b&gt;메소드&lt;/b&gt; 를 호출 한 에이전트입니다 . A의 &lt;b&gt;클래스&lt;/b&gt; 에있어서, 상기 invocant은 패키지 이름입니다. 에서 &lt;b&gt;인스턴스&lt;/b&gt; 에있어서, 상기 invocant 개체 참조한다.</target>
        </trans-unit>
        <trans-unit id="3e3cbe3ecc5eb1d553a5d35837bcb40ffd7eda37" translate="yes" xml:space="preserve">
          <source>The aim of the implementation is to provide the PerlIO API in a flexible and platform neutral manner. It is also a trial of an &quot;Object Oriented C, with vtables&quot; approach which may be applied to Perl 6.</source>
          <target state="translated">구현의 목표는 유연하고 플랫폼 중립적 인 방식으로 PerlIO API를 제공하는 것입니다. 또한 Perl 6에 적용될 수있는 &quot;vtables를 가진 객체 지향 C&quot;접근 방식의 시험판입니다.</target>
        </trans-unit>
        <trans-unit id="f4966bbd3f1dba4528607b30613ff49272963ff7" translate="yes" xml:space="preserve">
          <source>The aim of the implementation is to provide the PerlIO API in a flexible and platform neutral manner. It is also a trial of an &quot;Object Oriented C, with vtables&quot; approach which may be applied to Raku.</source>
          <target state="translated">구현의 목적은 유연하고 플랫폼 중립적 인 방식으로 PerlIO API를 제공하는 것입니다. 또한 Raku에 적용될 수있는 &quot;객체 지향 C, vtables&quot;접근 방식의 시험입니다.</target>
        </trans-unit>
        <trans-unit id="eca34d276a1e0da5bdcd3481f3be5f1fa01ec807" translate="yes" xml:space="preserve">
          <source>The aim of this stage is to take the Perl source, and turn it into an op tree. We'll see what one of those looks like later. Strictly speaking, there's three things going on here.</source>
          <target state="translated">이 단계의 목표는 Perl 소스를 가져 와서 op 트리로 만드는 것입니다. 우리는 나중에 그 중 하나가 어떻게 보이는지 볼 것입니다. 엄밀히 말하면, 여기에는 세 가지 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c84b06bf15cbe5bd96e34833737cbd3f8f36b72" translate="yes" xml:space="preserve">
          <source>The alarm() test failure is caused by system() apparently blocking alarm(). That is probably a libc bug, and given that SunOS 4.x has been end-of-lifed years ago, don't hold your breath for a fix. In addition to that, don't try anything too Unicode-y, especially with Encode, and you should be fine in SunOS 4.x.</source>
          <target state="translated">alarm () 테스트 실패는 system ()이 명백하게 alarm ()을 차단하여 발생합니다. 이것은 아마도 libc 버그 일 것입니다. SunOS 4.x가 몇 년 전에 수명이 다했다는 것을 감안할 때, 숨을 고치지 마십시오. 그 외에도 특히 Encode를 사용하여 너무 유니 코드로 시도하지 마십시오 .SunOS 4.x에서는 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac23951d81146a4c25773847fcd1353c10dfdb5b" translate="yes" xml:space="preserve">
          <source>The alias_code function is deprecated and will be removed in the December 2014 release.</source>
          <target state="translated">alias_code 함수는 더 이상 사용되지 않으며 2014 년 12 월 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f5829e682c777d3809510d4e74d665806fe75e9a" translate="yes" xml:space="preserve">
          <source>The alias_code function is preserved for backwards compatibility, but the following two are identical:</source>
          <target state="translated">alias_code 함수는 이전 버전과의 호환성을 위해 유지되지만 다음 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="70cc56ad5f5fa00e1dcd91a0319ec7c86448a5ca" translate="yes" xml:space="preserve">
          <source>The alloc command allows you to give the ftp server a hint about the size of the file about to be transferred using the ALLO ftp command. Some storage systems use this to make intelligent decisions about how to store the file. The &lt;code&gt;SIZE&lt;/code&gt; argument represents the size of the file in bytes. The &lt;code&gt;RECORD_SIZE&lt;/code&gt; argument indicates a maximum record or page size for files sent with a record or page structure.</source>
          <target state="translated">alloc 명령을 사용하면 ALLO ftp 명령을 사용하여 전송하려는 파일 크기에 대한 힌트를 ftp 서버에 제공 할 수 있습니다. 일부 스토리지 시스템은이를 사용하여 파일을 저장하는 방법에 대한 현명한 결정을 내립니다. &lt;code&gt;SIZE&lt;/code&gt; 의 인수는 파일의 크기 (바이트)를 나타냅니다. &lt;code&gt;RECORD_SIZE&lt;/code&gt; 인수는 기록 또는 페이지 구조로 전송 파일의 최대 레코드 또는 페이지 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b33892c53e0bb40f7871a5fed62579159a0f62e4" translate="yes" xml:space="preserve">
          <source>The alternative &lt;code&gt;STORABLE_attach&lt;/code&gt; method provides a solution for these shared objects. Instead of &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; , you implement &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; instead.</source>
          <target state="translated">대체 &lt;code&gt;STORABLE_attach&lt;/code&gt; 메소드는 이러한 공유 객체에 대한 솔루션을 제공합니다. 대신에 &lt;code&gt;STORABLE_freeze&lt;/code&gt; -&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; 은 , 당신이 구현 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 을 -&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e3eb421bcfd4a0e17ee07a7f425c335a4d323655" translate="yes" xml:space="preserve">
          <source>The alternative &lt;code&gt;STORABLE_attach&lt;/code&gt; method provides a solution for these shared objects. Instead of &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt;, you implement &lt;code&gt;STORABLE_freeze&lt;/code&gt; --&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; instead.</source>
          <target state="translated">대체 &lt;code&gt;STORABLE_attach&lt;/code&gt; 메소드는 이러한 공유 객체에 대한 솔루션을 제공합니다. 대신에 &lt;code&gt;STORABLE_freeze&lt;/code&gt; -&amp;gt; &lt;code&gt;STORABLE_thaw&lt;/code&gt; 은 , 당신이 구현 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 을 -&amp;gt; &lt;code&gt;STORABLE_attach&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="402e3151897f6beaece02f0ebb7344497fe45587" translate="yes" xml:space="preserve">
          <source>The alternative is to put the stubs in before the &lt;code&gt;__DATA__&lt;/code&gt; token BEFORE releasing the module, and for this purpose the &lt;code&gt;Devel::SelfStubber&lt;/code&gt; module is available. However this does require the extra step of ensuring that the stubs are in the module. If this is done I strongly recommend that this is done BEFORE releasing the module - it should NOT be done at install time in general.</source>
          <target state="translated">대안은 모듈을 해제 하기 전에 &lt;code&gt;__DATA__&lt;/code&gt; 토큰 앞에 스텁을 배치하는 것이며,이를 위해 &lt;code&gt;Devel::SelfStubber&lt;/code&gt; 모듈을 사용할 수 있습니다. 그러나 스텁이 모듈에 있는지 확인하는 추가 단계가 필요합니다. 이 작업을 수행 한 경우 모듈을 릴리스하기 전에이 작업을 수행하는 것이 좋습니다. 일반적으로 설치시 수행하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="58514d8e829fed1e0895720e4cd799ba14789a4f" translate="yes" xml:space="preserve">
          <source>The ambiguity between built-in type names and class names significantly limits the utility of &lt;code&gt;ref&lt;/code&gt;. For unambiguous information, use &lt;a href=&quot;Scalar::Util#blessed&quot;&gt;&lt;code&gt;Scalar::Util::blessed()&lt;/code&gt;&lt;/a&gt; for information about blessing, and &lt;a href=&quot;Scalar::Util#reftype&quot;&gt;&lt;code&gt;Scalar::Util::reftype()&lt;/code&gt;&lt;/a&gt; for information about physical types. Use &lt;a href=&quot;universal#%24obj-%3Eisa%28-TYPE-%29&quot;&gt;the &lt;code&gt;isa&lt;/code&gt; method&lt;/a&gt; for class membership tests, though one must be sure of blessedness before attempting a method call.</source>
          <target state="translated">내장 유형 이름과 클래스 이름 사이의 모호성은 &lt;code&gt;ref&lt;/code&gt; 의 유틸리티를 크게 제한합니다 . 명확한 정보를 보려면 축복에 대한 정보는 &lt;a href=&quot;Scalar::Util#blessed&quot;&gt; &lt;code&gt;Scalar::Util::blessed()&lt;/code&gt; &lt;/a&gt; 를 사용 하고 물리적 유형에 대한 정보는 &lt;a href=&quot;Scalar::Util#reftype&quot;&gt; &lt;code&gt;Scalar::Util::reftype()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오. 사용 &lt;a href=&quot;universal#%24obj-%3Eisa%28-TYPE-%29&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt; 방법 중 하나는 메서드 호출을 시도하기 전에 축복의 확인해야하지만, 클래스 회원 시험을.</target>
        </trans-unit>
        <trans-unit id="9cdca5fc72b074e8501939b48f8ca4c5d30e0fb2" translate="yes" xml:space="preserve">
          <source>The amnesty facet is a list instead of a single item, this is important as amnesty can come from multiple places at once.</source>
          <target state="translated">사면 패싯은 단일 항목이 아닌 목록이며, 사면은 한 번에 여러 곳에서 올 수 있으므로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6f8e08a6bd15bdf7cb57a249a2eb325f0bdb259e" translate="yes" xml:space="preserve">
          <source>The amount of sbrk(2)ed memory needed to keep buckets aligned.</source>
          <target state="translated">버킷을 정렬하는 데 필요한 sbrk (2) 메모리의 양입니다.</target>
        </trans-unit>
        <trans-unit id="24d94fd90247d993fe24e78a68e00db6f524e13c" translate="yes" xml:space="preserve">
          <source>The anger you feel when the computer is being lazy. This makes you write programs that don&amp;rsquo;t just react to your needs, but actually anticipate them. Or at least that pretend to. Hence, the second great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">컴퓨터가 게으르고있을 때 느끼는 분노. 이것은 당신의 요구에 부응하는 것이 아니라 실제로 예상하는 프로그램을 작성하게합니다. 아니면 적어도 척. 따라서 프로그래머의 두 번째 큰 미덕. &lt;b&gt;게으름&lt;/b&gt; 과 &lt;b&gt;후부&lt;/b&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="2d396c6c924a9cda1b9caf0839be7530a8ba7f62" translate="yes" xml:space="preserve">
          <source>The anonymous subroutine returned by add_function_generator() isn't technically a closure because it refers to no lexicals outside its own scope. Using a closure gives you a</source>
          <target state="translated">add_function_generator ()에 의해 리턴 된 익명 서브 루틴은 자체 범위 밖의 어휘를 참조하지 않기 때문에 기술적으로 닫히지 않습니다. 클로저를 사용하면</target>
        </trans-unit>
        <trans-unit id="7c26228772d7852b95995c9f2def9a6401f105ab" translate="yes" xml:space="preserve">
          <source>The answer is &lt;b&gt;recursion&lt;/b&gt;, and maybe &lt;b&gt;threads&lt;/b&gt;. Both these can create several execution pointers going into the same subroutine. For the subroutine-child not write over the temporaries for the subroutine-parent (lifespan of which covers the call to the child), the parent and the child should have different scratchpads. (</source>
          <target state="translated">대답은 &lt;b&gt;재귀입니다&lt;/b&gt; 이며 &lt;b&gt;스레드 일 수&lt;/b&gt; 있습니다. 둘 다 동일한 서브 루틴으로 들어가는 여러 실행 포인터를 만들 수 있습니다. 서브 루틴-자식이 서브 루틴-부모의 수명을 초과하지 않는 경우 (자녀의 전화를받는 수명) 부모와 자식은 서로 다른 스크래치 패드를 가져야합니다. (</target>
        </trans-unit>
        <trans-unit id="352a5795d3c7f4b3f3c9dafd2990d2244d787ba4" translate="yes" xml:space="preserve">
          <source>The answer is that our regexp works well until we get past the last real match. Then the regexp will fail to match a synchronized &lt;code&gt;TGA&lt;/code&gt; and start stepping ahead one character position at a time, not what we want. The solution is to use &lt;code&gt;\G&lt;/code&gt; to anchor the match to the codon alignment:</source>
          <target state="translated">대답은 마지막 실제 경기를 지날 때까지 정규 표현식이 잘 작동한다는 것입니다. 그러면 정규 표현식이 동기화 된 &lt;code&gt;TGA&lt;/code&gt; 와 일치하지 않습니다. 와 하지 않고 원하는 문자가 아닌 한 번에 한 문자 위치 씩 앞으로 나아갑니다. 해결책은 &lt;code&gt;\G&lt;/code&gt; 를 사용 하여 일치를 코돈 정렬에 고정시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08cdc226d03f36a2e4fc74ff822641ef90ed1cc6" translate="yes" xml:space="preserve">
          <source>The answer lies in the optimizations the regex engine makes. In the first case, all the engine sees are plain old characters (aside from the &lt;code&gt;?{}&lt;/code&gt; construct). It's smart enough to realize that the string 'ddd' doesn't occur in our target string before actually running the pattern through. But in the second case, we've tricked it into thinking that our pattern is more complicated. It takes a look, sees our character class, and decides that it will have to actually run the pattern to determine whether or not it matches, and in the process of running it hits the print statement before it discovers that we don't have a match.</source>
          <target state="translated">그 대답은 정규식 엔진의 최적화에 있습니다. 첫 번째 경우 모든 엔진에 보이는 오래된 문자입니다 ( &lt;code&gt;?{}&lt;/code&gt; 구문 제외)입니다. 실제로 패턴을 실행하기 전에 문자열 'ddd'가 대상 문자열에서 발생하지 않는다는 것을 인식하는 것이 현명합니다. 그러나 두 번째 경우에는 패턴이 더 복잡하다고 생각하도록 속였습니다. 살펴보고, 캐릭터 클래스를보고, 패턴이 실제로 일치하는지 여부를 결정하기 위해 실제로 패턴을 실행해야하는지 결정하고, 실행하는 동안 패턴이없는 것을 발견하기 전에 print 문을칩니다. 시합.</target>
        </trans-unit>
        <trans-unit id="2730e764755110ec17ad7723859c24cb17a27564" translate="yes" xml:space="preserve">
          <source>The answer lies in the optimizations the regexp engine makes. In the first case, all the engine sees are plain old characters (aside from the &lt;code&gt;?{}&lt;/code&gt; construct). It's smart enough to realize that the string &lt;code&gt;'ddd'&lt;/code&gt; doesn't occur in our target string before actually running the pattern through. But in the second case, we've tricked it into thinking that our pattern is more complicated. It takes a look, sees our character class, and decides that it will have to actually run the pattern to determine whether or not it matches, and in the process of running it hits the print statement before it discovers that we don't have a match.</source>
          <target state="translated">대답은 regexp 엔진이 만드는 최적화에 있습니다. 첫 번째 경우, 엔진이 보는 모든 것은 ( &lt;code&gt;?{}&lt;/code&gt; 구조를 제외하고) 평범한 오래된 문자 입니다. 실제로 패턴을 실행하기 전에 &lt;code&gt;'ddd'&lt;/code&gt; 문자열이 대상 문자열에서 발생하지 않는다는 사실을 깨닫는 것이 현명 합니다. 그러나 두 번째 경우에는 패턴이 더 복잡하다고 생각하도록 속였습니다. 한 번 살펴보고, 캐릭터 클래스를보고, 패턴이 일치하는지 여부를 결정하기 위해 실제로 패턴을 실행해야한다고 결정합니다. 시합.</target>
        </trans-unit>
        <trans-unit id="a5831b08e8cef23b3074e1a04c2a596b4fb392c8" translate="yes" xml:space="preserve">
          <source>The answer to requirement 2) is that a regexp (mostly) uses Unicode characters. The &quot;mostly&quot; is for messy backward compatibility reasons, but starting in Perl 5.14, any regex compiled in the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically turned on within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher) will turn that &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode properly, you should ensure that &lt;code&gt;'unicode_strings'&lt;/code&gt; is turned on. Internally, this is encoded to bytes using either UTF-8 or a native 8 bit encoding, depending on the history of the string, but conceptually it is a sequence of characters, not bytes. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for a tutorial about that.</source>
          <target state="translated">요구 사항 2)에 대한 대답은 정규 표현식 (대부분)이 유니 코드 문자를 사용한다는 것입니다. &quot;대부분&quot;은 이전 버전과의 호환성 문제로, Perl 5.14부터 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 이상의 범위 내에서 자동으로 설정 됨) 의 범위에서 컴파일 된 정규식 은 &quot; &quot;항상&quot;으로. 유니 코드를 올바르게 처리하려면 &lt;code&gt;'unicode_strings'&lt;/code&gt; 가 켜져 있는지 확인해야합니다 . 내부적으로 이것은 문자열 히스토리에 따라 UTF-8 또는 기본 8 비트 인코딩을 사용하여 바이트로 인코딩되지만 개념적으로 바이트가 아닌 일련의 문자입니다. &lt;a href=&quot;perlunitut&quot;&gt;이에&lt;/a&gt; 대한 튜토리얼은 perlunitut 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a999753d34cd305deea473ca5bdc5af4298059" translate="yes" xml:space="preserve">
          <source>The answer to requirement 2) is that a regexp (mostly) uses Unicode characters. The &quot;mostly&quot; is for messy backward compatibility reasons, but starting in Perl 5.14, any regexp compiled in the scope of a &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (which is automatically turned on within the scope of a &lt;code&gt;use 5.012&lt;/code&gt; or higher) will turn that &quot;mostly&quot; into &quot;always&quot;. If you want to handle Unicode properly, you should ensure that &lt;code&gt;'unicode_strings'&lt;/code&gt; is turned on. Internally, this is encoded to bytes using either UTF-8 or a native 8 bit encoding, depending on the history of the string, but conceptually it is a sequence of characters, not bytes. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for a tutorial about that.</source>
          <target state="translated">요구 사항 2)에 대한 대답은 정규 표현식 (대부분)이 유니 코드 문자를 사용한다는 것입니다. &quot;대부분&quot;은 이전 버전과의 호환성 문제를위한 것이지만 Perl 5.14부터 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; ( &lt;code&gt;use 5.012&lt;/code&gt; 이상 범위 내에서 자동으로 설정 됨) 범위에서 컴파일 된 모든 정규 표현식 은 &quot; 대부분 &quot;&quot;항상 &quot;으로. 유니 코드를 올바르게 처리하려면 &lt;code&gt;'unicode_strings'&lt;/code&gt; 가 켜져 있는지 확인해야합니다 . 내부적으로 이것은 문자열의 히스토리에 따라 UTF-8 또는 기본 8 비트 인코딩을 사용하여 바이트로 인코딩되지만 개념적으로는 바이트가 아닌 문자 시퀀스입니다. &lt;a href=&quot;perlunitut&quot;&gt;이에&lt;/a&gt; 대한 튜토리얼은 perlunitut 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20d531062e140b270ded3777e912ee516610a562" translate="yes" xml:space="preserve">
          <source>The answer to this is &quot;maybe&quot;. The FTP protocol does not specify a command to change file permissions on a remote host. However many servers do allow you to run the chmod command via the &lt;code&gt;SITE&lt;/code&gt; command. This can be done with</source>
          <target state="translated">이에 대한 대답은 &quot;어쩌면&quot;입니다. FTP 프로토콜은 원격 호스트에서 파일 권한을 변경하는 명령을 지정하지 않습니다. 그러나 많은 서버에서 &lt;code&gt;SITE&lt;/code&gt; 명령을 통해 chmod 명령을 실행할 수 있습니다 . 이것은 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab2461c5e3f0cff2ecb68a3151a2d92b8a70b40b" translate="yes" xml:space="preserve">
          <source>The answers may be off by few percentages because of the irregular (slightly aspherical) form of the Earth. The errors are at worst about 0.55%, but generally below 0.3%.</source>
          <target state="translated">불규칙한 (약간의 비구면) 형태의 지구로 인해 답이 몇 퍼센트 감소 할 수 있습니다. 오류는 최악의 경우 약 0.55 %이지만 일반적으로 0.3 % 미만입니다.</target>
        </trans-unit>
        <trans-unit id="d59be2ed12ab2165af09c3bf2c28e33ef82222db" translate="yes" xml:space="preserve">
          <source>The appended output looks like:</source>
          <target state="translated">추가 된 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4db40f607ddc8390942febb79a391b99968cc41b" translate="yes" xml:space="preserve">
          <source>The application window should now show an icon for iPKGui.</source>
          <target state="translated">이제 응용 프로그램 창에 iPKGui 아이콘이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd30cce9c74d0ed491dced5ecc139a5a1ba48e4" translate="yes" xml:space="preserve">
          <source>The appropriate string for the capability will be returned.</source>
          <target state="translated">기능에 적합한 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f8d591ba1ea36ab7ecf92938aa47215b4e6f08c" translate="yes" xml:space="preserve">
          <source>The archive member (filename) used is the empty string.</source>
          <target state="translated">사용 된 아카이브 멤버 (파일 이름)는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3156ec770160eccf0b831e893b19fba7da139602" translate="yes" xml:space="preserve">
          <source>The arcus (also known as the inverse) functions of the sine, cosine, and tangent</source>
          <target state="translated">사인, 코사인 및 탄젠트의 아크 (역수라고도 함) 함수</target>
        </trans-unit>
        <trans-unit id="ef155b03ef2bd4353f5f3ae9ce3143e92ce08f0b" translate="yes" xml:space="preserve">
          <source>The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc and acotan/acot are aliases). Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">사인, 코사인 및 탄젠트의 원호 함수 (acosec / acsc 및 acotan / acot는 별칭)입니다. atan2 (0, 0)은 잘 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d90394bf6d1003afd92e57075638d8ec96a8f149" translate="yes" xml:space="preserve">
          <source>The area (also known as the inverse) functions of the hyperbolic sine, cosine, and tangent</source>
          <target state="translated">쌍곡 사인, 코사인 및 탄젠트의 면적 (역수라고도 함) 함수</target>
        </trans-unit>
        <trans-unit id="96b07ebcfe3eb3364fc6d5a9b44430b864f7f185" translate="yes" xml:space="preserve">
          <source>The area cofunctions of the hyperbolic sine, cosine, and tangent (acsch/acosech and acoth/acotanh are aliases)</source>
          <target state="translated">쌍곡 사인, 코사인 및 탄젠트의 면적 함수 (acsch / acosech 및 acoth / acotanh는 별칭 임)</target>
        </trans-unit>
        <trans-unit id="5ccdfb64dc7931913963c31e04d78b0a9af3ae93" translate="yes" xml:space="preserve">
          <source>The area in which a particular invocation of a particular file or subroutine keeps some of its temporary values, including any lexically scoped variables.</source>
          <target state="translated">특정 파일 또는 서브 루틴의 특정 호출은 어휘 범위 변수를 포함하여 임시 값의 일부를 유지하는 영역입니다.</target>
        </trans-unit>
        <trans-unit id="d10c9af72d3c8216f90487b0cb07489720300b93" translate="yes" xml:space="preserve">
          <source>The arg variable is initially set by taking the value from ST(0), then is stored back into ST(0) at the end of the routine.</source>
          <target state="translated">arg 변수는 처음에 ST (0)에서 값을 가져 와서 설정 한 다음 루틴 종료시 ST (0)에 다시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4d814bb4a725af841ef1489f2dfafba121655945" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;level&lt;/code&gt; should be either 0 or -1. If &lt;code&gt;level==0&lt;/code&gt; , as a side-effect creates a glob with the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;stash&lt;/code&gt; which in the case of success contains an alias for the subroutine, and sets up caching info for this glob.</source>
          <target state="translated">인수 &lt;code&gt;level&lt;/code&gt; 은 0 또는 -1이어야합니다. &lt;code&gt;level==0&lt;/code&gt; 인 경우 부작용으로 주어진 &lt;code&gt;stash&lt;/code&gt; 에 지정된 &lt;code&gt;name&lt;/code&gt; 의 글로브를 작성하는데 , 성공시 서브 루틴의 별명을 포함하고이 글로브에 대한 캐싱 정보를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="02eb9b15d9bcbfeeb5429ffa2dc160c976e4912a" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;level&lt;/code&gt; should be either 0 or -1. If &lt;code&gt;level==0&lt;/code&gt;, as a side-effect creates a glob with the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;stash&lt;/code&gt; which in the case of success contains an alias for the subroutine, and sets up caching info for this glob.</source>
          <target state="translated">인수 &lt;code&gt;level&lt;/code&gt; 은 0 또는 -1이어야합니다. &lt;code&gt;level==0&lt;/code&gt; 인 경우 부작용으로 주어진 &lt;code&gt;stash&lt;/code&gt; 에 주어진 &lt;code&gt;name&lt;/code&gt; 의 glob을 만들고 성공의 경우 서브 루틴에 대한 별칭을 포함하고이 glob에 대한 캐싱 정보를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="46a90c11604ca06c6858b07026656614cf325b22" translate="yes" xml:space="preserve">
          <source>The argument after &lt;code&gt;'autotie'&lt;/code&gt; is a reference to a hash in which each key is the name of an attribute to be created, and each value is the class to which variables ascribed that attribute should be tied.</source>
          <target state="translated">&lt;code&gt;'autotie'&lt;/code&gt; 뒤의 인수 는 각 키가 생성 될 속성의 이름 인 각 해시에 대한 참조이며, 각 값은 해당 속성에 속하는 변수가 연결되는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="de7c9584c8050b2d0fdb24caf50ee070b0a90073" translate="yes" xml:space="preserve">
          <source>The argument specification can be</source>
          <target state="translated">인수 사양은</target>
        </trans-unit>
        <trans-unit id="e56eb85000cd23825e22500ebb61377895023bf6" translate="yes" xml:space="preserve">
          <source>The argument specification is optional. If omitted, the option is considered boolean, a value of 1 will be assigned when the option is used on the command line.</source>
          <target state="translated">인수 스펙은 선택 사항입니다. 생략하면 옵션이 부울로 간주되며 명령 행에서 옵션을 사용할 때 값 1이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f70b3fa6aabdcb387bd854a30ff21340870477da" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;LIST_CACHE&lt;/code&gt; or &lt;code&gt;SCALAR_CACHE&lt;/code&gt; must either be one of the following four strings:</source>
          <target state="translated">&lt;code&gt;LIST_CACHE&lt;/code&gt; 또는 &lt;code&gt;SCALAR_CACHE&lt;/code&gt; 에 대한 인수 는 다음 4 개의 문자열 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c5464d59534d6182be5453dd048427e6d0c50353" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;$heading1&lt;/code&gt; , &lt;code&gt;$heading2&lt;/code&gt; , etc. are the heading titles of the corresponding sections, subsections, etc. to try and match. If &lt;code&gt;$headingN&lt;/code&gt; is omitted then it defaults to the current corresponding section heading title in the input.</source>
          <target state="translated">인수 &lt;code&gt;$heading1&lt;/code&gt; , &lt;code&gt;$heading2&lt;/code&gt; 등은 시도하고 일치시킬 해당 섹션, 하위 섹션 등의 제목 제목입니다. 경우 &lt;code&gt;$headingN&lt;/code&gt; 입력 전류에 대응하는 섹션 제목 타이틀로 기본 생략한다.</target>
        </trans-unit>
        <trans-unit id="0c2d811d7e533f13a02dc5ccb0c9cf2822f648ef" translate="yes" xml:space="preserve">
          <source>The arguments after the</source>
          <target state="translated">이후의 주장</target>
        </trans-unit>
        <trans-unit id="c3ee6db939d4bf6fb2dbd132ec653ceddc879c3d" translate="yes" xml:space="preserve">
          <source>The arguments and expected behaviour of these methods are described in &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;.</source>
          <target state="translated">이러한 메소드의 주장과 예상되는 동작은 &lt;a href=&quot;../digest&quot;&gt;다이제스트에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4ca15ce5b5fa69733326d0ffcc5ec4afa84ebb" translate="yes" xml:space="preserve">
          <source>The arguments and expected behaviour of these methods are described in &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;.</source>
          <target state="translated">이러한 메서드의 인수 및 예상되는 동작은 &lt;a href=&quot;digest&quot;&gt;Digest에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c76d2b203709556f900b75ce0e52a9ac994219" translate="yes" xml:space="preserve">
          <source>The arguments are available via @ARGV, not $1, $2, etc.</source>
          <target state="translated">인수는 $ 1, $ 2 등이 아닌 @ARGV를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb92f325e1877b21a75fa1acba0a791fd4726a3" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;sv_setpvf&lt;/code&gt; are processed like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, and the formatted output becomes the value.</source>
          <target state="translated">&lt;code&gt;sv_setpvf&lt;/code&gt; 의 인수는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 같이 처리 되며 형식화 된 출력이 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="12a6eed4c04c06182dcbdc88af7b6f5d14916ec8" translate="yes" xml:space="preserve">
          <source>The arguments of &lt;code&gt;sv_setpvf&lt;/code&gt; are processed like &lt;code&gt;sprintf&lt;/code&gt;, and the formatted output becomes the value.</source>
          <target state="translated">&lt;code&gt;sv_setpvf&lt;/code&gt; 의 인수는 &lt;code&gt;sprintf&lt;/code&gt; 처럼 처리 되고 형식화 된 출력이 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="839631a833c7558b199549ece29ff396d5371aa7" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement which invokes &lt;b&gt;sigtrap&lt;/b&gt; are processed in order. When a signal name or the name of one of &lt;b&gt;sigtrap&lt;/b&gt;'s signal lists is encountered a handler is immediately installed, when an option is encountered it affects subsequently installed handlers.</source>
          <target state="translated">&lt;b&gt;sigtrap&lt;/b&gt; 을 호출 하는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 문에 전달 된 인수 는 순서대로 처리됩니다. 신호 이름 또는 &lt;b&gt;sigtrap&lt;/b&gt; 의 신호 목록 중 하나의 이름 이 발견되면 핸들러가 즉시 설치되고, 옵션이 발견되면 이후에 설치된 핸들러에 영향을줍니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f5ad564be7b9f128b2ebd6f7ebe4c5d1cd8225d2" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &lt;code&gt;use&lt;/code&gt; statement which invokes &lt;b&gt;sigtrap&lt;/b&gt; are processed in order. When a signal name or the name of one of &lt;b&gt;sigtrap&lt;/b&gt;'s signal lists is encountered a handler is immediately installed, when an option is encountered it affects subsequently installed handlers.</source>
          <target state="translated">&lt;b&gt;sigtrap&lt;/b&gt; 을 호출 하는 &lt;code&gt;use&lt;/code&gt; 문에 전달 된 인수 는 순서대로 처리됩니다. 신호 이름 또는 &lt;b&gt;sigtrap&lt;/b&gt; 의 신호 목록 중 하나의 이름 이 발견되면 핸들러가 즉시 설치되고 옵션이 발견되면 이후에 설치된 핸들러에 영향을줍니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a181ad8a8d3a3252da75be7994d668c484c4410f" translate="yes" xml:space="preserve">
          <source>The arguments should be a hashref with</source>
          <target state="translated">인수는 다음과 같은 해시 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="01c93f64cbaa573f1e972a244178e4f2a83875d0" translate="yes" xml:space="preserve">
          <source>The arguments themselves are any values following the &lt;code&gt;flags&lt;/code&gt; argument.</source>
          <target state="translated">인수 자체는 &lt;code&gt;flags&lt;/code&gt; 인수 뒤에 오는 모든 값 입니다.</target>
        </trans-unit>
        <trans-unit id="380902efca5b9b3a75f7c59abab4db85bec7e897" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are in scalar context, and &lt;code&gt;given&lt;/code&gt; assigns the &lt;code&gt;$_&lt;/code&gt; variable its topic value.</source>
          <target state="translated">에 대한 인수는 &lt;code&gt;given&lt;/code&gt; 와 &lt;code&gt;when&lt;/code&gt; 스칼라 문맥에서, 그리고 &lt;code&gt;given&lt;/code&gt; 양수인에게 &lt;code&gt;$_&lt;/code&gt; 변수의 항목 값입니다.</target>
        </trans-unit>
        <trans-unit id="068e099d67cc2d75f1c7db95c76c5ffd7d8bfa72" translate="yes" xml:space="preserve">
          <source>The arguments to layers are by default returned in parentheses after the name of the layer, and certain layers (like &lt;code&gt;:utf8&lt;/code&gt;) are not real layers but instead flags on real layers; to get all of these returned separately, use the optional &lt;code&gt;details&lt;/code&gt; argument:</source>
          <target state="translated">레이어에 대한 인수는 기본적으로 레이어 이름 뒤의 괄호 안에 반환되며, 특정 레이어 (예 &lt;code&gt;:utf8&lt;/code&gt; )는 실제 레이어가 아니라 실제 레이어의 플래그입니다. 이러한 모든 항목을 개별적으로 반환하려면 선택적 &lt;code&gt;details&lt;/code&gt; 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bee53666a69514e40c684814c2f3de57ce34649e" translate="yes" xml:space="preserve">
          <source>The arguments to layers are by default returned in parentheses after the name of the layer, and certain layers (like &lt;code&gt;utf8&lt;/code&gt; ) are not real layers but instead flags on real layers; to get all of these returned separately, use the optional &lt;code&gt;details&lt;/code&gt; argument:</source>
          <target state="translated">레이어에 대한 인수는 기본적으로 레이어 이름 뒤에 괄호 안에 반환되며, &lt;code&gt;utf8&lt;/code&gt; 과 같은 특정 레이어 는 실제 레이어가 아니라 실제 레이어의 플래그입니다. 이 모든 것을 개별적으로 반환하려면 선택적 &lt;code&gt;details&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e693a7b71ba349ddefc634c4aa1cd90dc56ea7f" translate="yes" xml:space="preserve">
          <source>The arithmetics with pure imaginary numbers works just like you would expect it with real numbers... you just have to remember that</source>
          <target state="translated">순수한 허수를 사용한 산술은 실수로 예상하는 것과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="27b0340458e5b6bada543e551d3178c4f1de6919" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@ARGV&lt;/code&gt; contains the command-line arguments intended for the script. &lt;code&gt;$#ARGV&lt;/code&gt; is generally the number of arguments minus one, because &lt;code&gt;$ARGV[0]&lt;/code&gt; is the first argument,</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; 배열 에는 스크립트를위한 명령 행 인수가 포함됩니다. &lt;code&gt;$#ARGV&lt;/code&gt; 는 일반적으로 인수의 수에서 1을 뺀 수입니다. &lt;code&gt;$ARGV[0]&lt;/code&gt; 이 첫 번째 인수이므로</target>
        </trans-unit>
        <trans-unit id="5e6fff9bfd20cc94284be277039aa46feebe2516" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@F&lt;/code&gt; contains the fields of each line read in when autosplit mode is turned on. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-a&lt;/b&gt; switch. This array is package-specific, and must be declared or given a full package name if not in package main when running under &lt;code&gt;strict 'vars'&lt;/code&gt; .</source>
          <target state="translated">배열 &lt;code&gt;@F&lt;/code&gt; 는 자동 분할 모드가 켜져있을 때 읽은 각 줄의 필드를 포함합니다. &lt;b&gt;-a&lt;/b&gt; 스위치에 대해서는 &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오 . 이 배열은 패키지마다 &lt;code&gt;strict 'vars'&lt;/code&gt; 에서 실행될 때 main 패키지에없는 경우 선언되거나 전체 패키지 이름을 지정해야합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="64f8a732ee6971720fa678ad575d37739ab35841" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@F&lt;/code&gt; contains the fields of each line read in when autosplit mode is turned on. See &lt;a href=&quot;perlrun#-a&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-a&lt;/b&gt; switch. This array is package-specific, and must be declared or given a full package name if not in package main when running under &lt;code&gt;strict 'vars'&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;@F&lt;/code&gt; 에는 자동 분할 모드가 켜져있을 때 읽은 각 행의 필드가 포함됩니다. &lt;b&gt;-a&lt;/b&gt; 스위치에 대해서는 &lt;a href=&quot;perlrun#-a&quot;&gt;perlrun&lt;/a&gt; 을 참조하십시오 . 이 배열은 패키지에 따라 &lt;code&gt;strict 'vars'&lt;/code&gt; 에서 실행할 때 main 패키지에없는 경우 선언하거나 전체 패키지 이름을 지정해야합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8441a1e4197d6b374d0c52606833f2a1d2d3753" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@INC&lt;/code&gt; contains the list of places that the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; constructs look for their library files. It initially consists of the arguments to any &lt;b&gt;-I&lt;/b&gt; command-line switches, followed by the default Perl library, probably</source>
          <target state="translated">배열 &lt;code&gt;@INC&lt;/code&gt; 것을 장소의 목록을 포함 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; EXPR&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 구조가 라이브러리 파일을 찾을 수 있습니다. 처음에는 &lt;b&gt;-I&lt;/b&gt; 명령 행 스위치 에 대한 인수로 구성되며 기본 Perl 라이브러리가 이어집니다.</target>
        </trans-unit>
        <trans-unit id="6609d6bd6d5c0f2d7621bfd7abdb3a828ea60e2e" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;@INC&lt;/code&gt; contains the list of places that the &lt;code&gt;do EXPR&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;use&lt;/code&gt; constructs look for their library files. It initially consists of the arguments to any &lt;b&gt;-I&lt;/b&gt; command-line switches, followed by the default Perl library, probably</source>
          <target state="translated">&lt;code&gt;@INC&lt;/code&gt; 배열 에는 &lt;code&gt;do EXPR&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 구문이 라이브러리 파일을 찾는 장소 목록이 포함되어 있습니다. 처음에는 &lt;b&gt;-I&lt;/b&gt; 명령 줄 스위치 에 대한 인수 와 기본 Perl 라이브러리 (아마도</target>
        </trans-unit>
        <trans-unit id="a14a26b2dd6454634cc1107915a7a3aee19dc784" translate="yes" xml:space="preserve">
          <source>The array indices start with 0. A negative subscript retrieves its value from the end. In our example, &lt;code&gt;$myarray[-1]&lt;/code&gt; would have been 5000, and &lt;code&gt;$myarray[-2]&lt;/code&gt; would have been 500.</source>
          <target state="translated">배열 인덱스는 0으로 시작합니다. 음의 아래 첨자는 끝에서 값을 검색합니다. 이 예에서 &lt;code&gt;$myarray[-1]&lt;/code&gt; 은 5000이고 &lt;code&gt;$myarray[-2]&lt;/code&gt; 는 500입니다.</target>
        </trans-unit>
        <trans-unit id="5870f5124d5a86e2473fbde56d4d16aa6bdafbce" translate="yes" xml:space="preserve">
          <source>The array returned by the &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; operator is divided up according to the same rules the CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; routine. Therefore, the &quot;system time&quot; elements will always be 0, since there is no difference between &quot;user time&quot; and &quot;system&quot; time under VMS, and the time accumulated by a subprocess may or may not appear separately in the &quot;child time&quot; field, depending on whether &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; keeps track of subprocesses separately. Note especially that the VAXCRTL (at least) keeps track only of subprocesses spawned using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;; it will not accumulate the times of subprocesses spawned via pipes, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, or backticks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; 연산자가 리턴 한 배열 은 CRTL &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 루틴 과 동일한 규칙에 따라 나뉩니다 . 따라서 &quot;시스템 시간&quot;요소는 VMS 하에서 &quot;사용자 시간&quot;과 &quot;시스템&quot;시간 사이에 차이가없고 하위 프로세스에 의해 누적 된 시간이 &quot;자식 시간&quot;에 개별적으로 나타나거나 나타나지 않을 수 있기 때문에 항상 0입니다. &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 가 하위 프로세스를 개별적으로 추적 하는지 여부에 따라 필드 . 특히 VAXCRTL은 (적어도) &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 사용하여 생성 된 하위 프로세스 만 추적합니다 . 파이프, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 또는 백틱을 통해 생성 된 하위 프로세스의 시간을 누적하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e6578cf977163193727755ba3387b3c83b43e327" translate="yes" xml:space="preserve">
          <source>The array returned by the &lt;code&gt;times&lt;/code&gt; operator is divided up according to the same rules the CRTL &lt;code&gt;times()&lt;/code&gt; routine. Therefore, the &quot;system time&quot; elements will always be 0, since there is no difference between &quot;user time&quot; and &quot;system&quot; time under VMS, and the time accumulated by a subprocess may or may not appear separately in the &quot;child time&quot; field, depending on whether &lt;code&gt;times()&lt;/code&gt; keeps track of subprocesses separately. Note especially that the VAXCRTL (at least) keeps track only of subprocesses spawned using &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;; it will not accumulate the times of subprocesses spawned via pipes, &lt;code&gt;system()&lt;/code&gt;, or backticks.</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt; 연산자에 의해 반환 된 배열 은 CRTL &lt;code&gt;times()&lt;/code&gt; 루틴 과 동일한 규칙에 따라 나뉩니다 . 따라서 &quot;시스템 시간&quot;요소는 VMS에서 &quot;사용자 시간&quot;과 &quot;시스템&quot;시간 사이에 차이가 없기 때문에 항상 0이며 하위 프로세스에 의해 누적 된 시간은 &quot;하위 시간&quot;에 별도로 나타날 수도 있고 나타나지 않을 수도 있습니다. 필드는 &lt;code&gt;times()&lt;/code&gt; 가 하위 프로세스를 개별적으로 추적 하는지 여부에 따라 다릅니다 . 특히 VAXCRTL은 (적어도) &lt;code&gt;fork()&lt;/code&gt; 및 &lt;code&gt;exec()&lt;/code&gt; 사용하여 생성 된 하위 프로세스 만 추적합니다 . 파이프, &lt;code&gt;system()&lt;/code&gt; 또는 백틱을 통해 생성 된 하위 프로세스의 시간을 누적하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e203923e4bb3b1b85d85c3be6cf6dca987c9241" translate="yes" xml:space="preserve">
          <source>The arrays &lt;code&gt;@EXPORT&lt;/code&gt; and &lt;code&gt;@EXPORT_OK&lt;/code&gt; in a module hold lists of symbols that are going to be exported into the users name space by default, or which they can request to be exported, respectively. The symbols can represent functions, scalars, arrays, hashes, or typeglobs. The symbols must be given by full name with the exception that the ampersand in front of a function is optional, e.g.</source>
          <target state="translated">배열 &lt;code&gt;@EXPORT&lt;/code&gt; 및 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 가는 기호 모듈 보류 목록에 기본적으로 사용자 이름 공간으로 내보낼하거나 각각 내보낼 수 요청할 수있다. 기호는 함수, 스칼라, 배열, 해시 또는 타입 글로브를 나타낼 수 있습니다. 함수 앞의 앰퍼샌드가 선택 사항 인 경우를 제외하고 기호는 전체 이름으로 제공해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="6be6541bf2f3c9c38b314f884349aae8de53fdfb" translate="yes" xml:space="preserve">
          <source>The arrays completely specify the mappings for all possible code points. The final element in an inversion map returned by this function will always be for the range that consists of all the code points that aren't legal Unicode, but that are expressible on the platform. (That is, it starts with code point 0x110000, the first code point above the legal Unicode maximum, and extends to infinity.) The value for that range will be the same that any typical unassigned code point has for the specified property. (Certain unassigned code points are not &quot;typical&quot;; for example the non-character code points, or those in blocks that are to be written right-to-left. The above-Unicode range's value is not based on these atypical code points.) It could be argued that, instead of treating these as unassigned Unicode code points, the value for this range should be &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If you wish, you can change the returned arrays accordingly.</source>
          <target state="translated">배열은 가능한 모든 코드 포인트에 대한 매핑을 완전히 지정합니다. 이 함수가 반환 한 반전 맵의 마지막 요소는 항상 유효한 유니 코드는 아니지만 플랫폼에서 표현할 수있는 모든 코드 포인트로 구성된 범위에 대한 것입니다. 즉, 유효한 유니 코드 최대 값을 초과하는 첫 번째 코드 포인트 인 코드 포인트 0x110000으로 시작하여 무한대로 확장됩니다. 해당 범위의 값은 할당되지 않은 일반적인 코드 포인트가 지정된 속성과 동일합니다. (할당되지 않은 특정 코드 포인트는 &quot;일반적&quot;이 아닙니다 (예 : 문자가 아닌 코드 포인트 또는 오른쪽에서 왼쪽으로 쓰는 블록의 코드 포인트). 유니 코드 범위의 값은 이러한 비정형 코드 포인트를 기반으로하지 않습니다. )이를 할당되지 않은 유니 코드 코드 포인트로 취급하는 대신,이 범위의 값은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . 원하는 경우 반환 된 배열을 적절히 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fafc915fb0b23a9b73e4358f1bba51130676e84d" translate="yes" xml:space="preserve">
          <source>The arrays completely specify the mappings for all possible code points. The final element in an inversion map returned by this function will always be for the range that consists of all the code points that aren't legal Unicode, but that are expressible on the platform. (That is, it starts with code point 0x110000, the first code point above the legal Unicode maximum, and extends to infinity.) The value for that range will be the same that any typical unassigned code point has for the specified property. (Certain unassigned code points are not &quot;typical&quot;; for example the non-character code points, or those in blocks that are to be written right-to-left. The above-Unicode range's value is not based on these atypical code points.) It could be argued that, instead of treating these as unassigned Unicode code points, the value for this range should be &lt;code&gt;undef&lt;/code&gt;. If you wish, you can change the returned arrays accordingly.</source>
          <target state="translated">배열은 가능한 모든 코드 포인트에 대한 매핑을 완전히 지정합니다. 이 함수에 의해 반환되는 반전 맵의 마지막 요소는 항상 합법적 인 유니 코드는 아니지만 플랫폼에서 표현할 수있는 모든 코드 포인트로 구성된 범위에 대한 것입니다. 즉, 합법적 인 유니 코드 최대 값을 초과하는 첫 번째 코드 포인트 인 코드 포인트 0x110000으로 시작하여 무한대로 확장됩니다. 해당 범위의 값은 지정된 속성에 대해 할당되지 않은 일반적인 코드 포인트의 값과 동일합니다. (지정되지 않은 특정 코드 포인트는 &quot;일반&quot;이 아닙니다. 예를 들어 문자가 아닌 코드 포인트 또는 오른쪽에서 왼쪽으로 작성되는 블록의 코드 포인트. 위의 유니 코드 범위의 값은 이러한 비정형 코드 포인트를 기반으로하지 않습니다. )이를 할당되지 않은 유니 코드 코드 포인트로 취급하는 대신이 범위의 값은 다음과 같아야합니다. &lt;code&gt;undef&lt;/code&gt; . 원하는 경우 반환 된 배열을 적절하게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="215f34a814c5d96aebb0e5a01677224428736e62" translate="yes" xml:space="preserve">
          <source>The arrays.h/arrays.c code in the &lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt; module on CPAN does just this. If you're doing a lot of float or double processing, consider using the &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; module from CPAN instead--it makes number-crunching easy.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/PGPLOT&quot;&gt;PGPLOT&lt;/a&gt; 모듈에 있는 arrays.h / arrays.c 코드는 이 작업을 수행합니다. 많은 부동 또는 이중 처리를 수행하는 경우 대신 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/PDL&quot;&gt;PDL&lt;/a&gt; 모듈을 사용하는 것이 좋습니다. 이는 숫자를 쉽게 처리 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="5a463784997136eebb771d904f4c8e2296a00f84" translate="yes" xml:space="preserve">
          <source>The arrays.h/arrays.c code in the &lt;a href=&quot;pgplot&quot;&gt;PGPLOT&lt;/a&gt; module on CPAN does just this. If you're doing a lot of float or double processing, consider using the &lt;a href=&quot;pdl&quot;&gt;PDL&lt;/a&gt; module from CPAN instead--it makes number-crunching easy.</source>
          <target state="translated">CPAN 의 &lt;a href=&quot;pgplot&quot;&gt;PGPLOT&lt;/a&gt; 모듈에 있는 arrays.h / arrays.c 코드는 이를 수행합니다. 부동 또는 이중 처리를 많이 수행하는 경우 대신 CPAN 의 &lt;a href=&quot;pdl&quot;&gt;PDL&lt;/a&gt; 모듈을 사용하는 것이 좋습니다. 이렇게하면 번호 처리가 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="7c674ebc98c67a6b78e8bff2084920a9483e6761" translate="yes" xml:space="preserve">
          <source>The arrow points to the sequence number of the next op; they're not displayed in -exec mode, for obvious reasons.</source>
          <target state="translated">화살표는 다음 op의 시퀀스 번호를 가리 킵니다. 명백한 이유로 -exec 모드로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3369ef5421624f50c9461a4385bdfc6e73878c8" translate="yes" xml:space="preserve">
          <source>The art of defining something (at least partly) in terms of itself, which is a naughty no-no in dictionaries but often works out okay in computer programs if you&amp;rsquo;re careful not to recurse forever (which is like an infinite loop with more spectacular failure modes).</source>
          <target state="translated">그 자체로 (적어도 부분적으로) 무언가를 정의하는 기술은 사전에서 나쁜 것은 아니지만 영원히 재귀하지 않도록주의하면 컴퓨터 프로그램에서 정상적으로 작동합니다 (더 많은 것을 가진 무한 루프와 같습니다) 화려한 실패 모드).</target>
        </trans-unit>
        <trans-unit id="44c6ad6b4370d28f2449d941c6198878c199473e" translate="yes" xml:space="preserve">
          <source>The article &quot;Constants in Perl&quot;, in</source>
          <target state="translated">&quot;Perl의 상수&quot;기사</target>
        </trans-unit>
        <trans-unit id="8684dac1717627016887887b24ef032c124ad96b" translate="yes" xml:space="preserve">
          <source>The assertion facet is provided by any event representing an assertion that was made.</source>
          <target state="translated">어설 션 패싯은 작성된 어설 션을 나타내는 모든 이벤트에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a192d0a93de689a6420b9f8549f9f014d023dc" translate="yes" xml:space="preserve">
          <source>The assignment to &lt;code&gt;$^R&lt;/code&gt; above is properly localized, so the old value of &lt;code&gt;$^R&lt;/code&gt; is restored if the assertion is backtracked; compare &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;.</source>
          <target state="translated">위의 &lt;code&gt;$^R&lt;/code&gt; 대한 할당 은 적절하게 지역화되었으므로 어설 션이 역 추적되면 &lt;code&gt;$^R&lt;/code&gt; 의 이전 값 이 복원됩니다. &lt;a href=&quot;#Backtracking&quot;&gt;&quot;역 추적&quot;&lt;/a&gt; 비교 .</target>
        </trans-unit>
        <trans-unit id="f1506bf3257cec0583c1b75ddabb2245f7506472" translate="yes" xml:space="preserve">
          <source>The assignment to &lt;code&gt;$^R&lt;/code&gt; above is properly localized, so the old value of &lt;code&gt;$^R&lt;/code&gt; is restored if the assertion is backtracked; compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;.</source>
          <target state="translated">위의 &lt;code&gt;$^R&lt;/code&gt; 대한 지정 이 올바르게 현지화되었으므로 어설 션이 역 추적되면 이전 &lt;code&gt;$^R&lt;/code&gt; 값 이 복원됩니다. &lt;a href=&quot;#Backtracking&quot;&gt;역 추적&lt;/a&gt; 비교 .</target>
        </trans-unit>
        <trans-unit id="afaa9c220de769e54d663ab2c9c6d4f430c692cd" translate="yes" xml:space="preserve">
          <source>The assignment variants of these operators (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ) behave likewise under the feature.</source>
          <target state="translated">이러한 연산자의 할당 변형 ( &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; )도 기능에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="59071d60702fd34620d925929432374ea0d5ec90" translate="yes" xml:space="preserve">
          <source>The assignment variants of these operators (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt;) behave likewise under the feature.</source>
          <target state="translated">이러한 연산자의 할당 변형 ( &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; )은 기능에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71ba6eda663c17eb85a62c08062fb7adfc8e5822" translate="yes" xml:space="preserve">
          <source>The association between the filter object and the source stream is made with the &lt;code&gt;filter_add()&lt;/code&gt; function. This takes a filter object as a parameter (&lt;code&gt;$ref&lt;/code&gt; in this case) and installs it in the source stream.</source>
          <target state="translated">필터 객체와 소스 스트림 간의 연관은 &lt;code&gt;filter_add()&lt;/code&gt; 함수 로 이루어집니다 . 필터 객체를 매개 변수로 사용하고 ( 이 경우 &lt;code&gt;$ref&lt;/code&gt; ) 소스 스트림에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="12a98cd04a6eb830d540ea5356e8449610414ff4" translate="yes" xml:space="preserve">
          <source>The atmark() functionality is also exportable as sockatmark() function:</source>
          <target state="translated">atmark () 기능은 sockatmark () 함수로 내보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="30252fd845cfc7120c5fe1c8c4bfc41149abe5bb" translate="yes" xml:space="preserve">
          <source>The atmark() implementation: Copyright 2001, Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;. This module is distributed under the same terms as Perl itself. Feel free to use, modify and redistribute it as long as you retain the correct attribution.</source>
          <target state="translated">atmark () 구현 : Copyright 2001, Lincoln Stein &amp;lt;lstein@cshl.org&amp;gt;. 이 모듈은 Perl 자체와 동일한 용어로 배포됩니다. 올바른 속성을 유지하는 한 자유롭게 사용, 수정 및 재배포하십시오.</target>
        </trans-unit>
        <trans-unit id="b16e464d772931ef9f887f2554628c044c9311d4" translate="yes" xml:space="preserve">
          <source>The attribute</source>
          <target state="translated">속성</target>
        </trans-unit>
        <trans-unit id="82c21f7a3ae183ec4d3047341406ff01ae50460f" translate="yes" xml:space="preserve">
          <source>The attribute list is passed as a list of constant strings to the code which associates them with the subroutine. In particular, the second example of valid syntax above currently looks like this in terms of how it's parsed and invoked:</source>
          <target state="translated">속성 목록은 상수 문자열 목록으로 코드에 전달되어 서브 루틴과 연결됩니다. 특히, 위의 유효한 구문의 두 번째 예는 구문 분석 및 호출 방식 측면에서 현재 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24fd7818618a01c86bb3fbd35ae188606e0bab24" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;:locked&lt;/code&gt; (on code references) and &lt;code&gt;:unique&lt;/code&gt; (on array, hash and scalar references) have had no effect since Perl 5.005 and Perl 5.8.8 respectively. Their use has been deprecated since.</source>
          <target state="translated">&lt;code&gt;:locked&lt;/code&gt; (코드 참조에서) 및 &lt;code&gt;:unique&lt;/code&gt; (배열, 해시 및 스칼라 참조에서) 속성 은 각각 Perl 5.005 및 Perl 5.8.8 이후로 효과가 없었습니다. 그들의 사용은 그 이후로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b657a6989977956f6b98ac68863da82534e8cebe" translate="yes" xml:space="preserve">
          <source>The attributes must be valid as simple identifier names (without any punctuation other than the '_' character). They may have a parameter list appended, which is only checked for whether its parentheses ('(',')') nest properly.</source>
          <target state="translated">속성은 간단한 식별자 이름으로 유효해야합니다 ( '_'문자 이외의 구두점 제외). 매개 변수 목록이 추가되어 괄호 ( '(', ')')가 제대로 중첩되는지 여부 만 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed84825a166e6951e0ea73a90f4a198ad861429" translate="yes" xml:space="preserve">
          <source>The author admits the module is crazy, and he is awaiting a stable release of something new (Test2) to completely rewrite it in a sane way.</source>
          <target state="translated">저자는 모듈이 미쳤음을 인정하고, 정상적인 방식으로 완전히 재 작성하기 위해 새로운 무언가 (Test2)의 안정적인 릴리스를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6773066d674b1f4d653955ef73a085c07f393513" translate="yes" xml:space="preserve">
          <source>The author is particularly grateful to</source>
          <target state="translated">저자는 특히 감사합니다</target>
        </trans-unit>
        <trans-unit id="a93ac8e5cbb3f89224036c2390524cda7879089a" translate="yes" xml:space="preserve">
          <source>The author that PAUSE allows to assign &lt;b&gt;co-maintainer&lt;/b&gt; permissions to a &lt;b&gt;namespace&lt;/b&gt;. A primary maintainer can give up this distinction by assigning it to another PAUSE author. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">PAUSE가 &lt;b&gt;공동 유지 관리자&lt;/b&gt; 권한을 &lt;b&gt;네임 스페이스&lt;/b&gt; 에 할당 할 수있는 작성자 . 기본 관리자는 다른 PAUSE 작성자에게이 구분을 지정하여이 구분을 포기할 수 있습니다. 낙타 19 장 &quot;CPAN&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08620722332423b72a0cf9f7ae67e151d08d71e3" translate="yes" xml:space="preserve">
          <source>The author would like to thank Jeff Pinyan, Andrew Johnson, Peter Haworth, Ronald J Kimball, and Joe Smith for all their helpful comments.</source>
          <target state="translated">저자는 Jeff Pinyan, Andrew Johnson, Peter Haworth, Ronald J Kimball 및 Joe Smith에게 도움이되는 모든 의견에 감사를 표합니다.</target>
        </trans-unit>
        <trans-unit id="7842e70d44fa0066b01f00b794f28e99cc120d48" translate="yes" xml:space="preserve">
          <source>The author would like to thank Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful comments.</source>
          <target state="translated">저자는 Mark-Jason Dominus, Tom Christiansen, Ilya Zakharevich, Brad Hughes 및 Mike Giroux에게 도움이되는 모든 의견에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="d5ab428bb4c4aa590bf7abb081e2b965dbe912a0" translate="yes" xml:space="preserve">
          <source>The author's book</source>
          <target state="translated">저자의 책</target>
        </trans-unit>
        <trans-unit id="c9e7cff5bfc96623d1a90b00467d7f7914fdeb06" translate="yes" xml:space="preserve">
          <source>The authors make &lt;b&gt;no warranty&lt;/b&gt;, implied or otherwise, about the suitability of this software for safety or security purposes.</source>
          <target state="translated">저자 는 안전 또는 보안 목적으로이 소프트웨어의 적합성에 대해 암시 적이든 명시 적이든 &lt;b&gt;어떠한 보증도하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd8067e06812735b51136d8d5ba18979e5deef6" translate="yes" xml:space="preserve">
          <source>The authors shall not in any case be liable for special, incidental, consequential, indirect or other similar damages arising from the use of this software.</source>
          <target state="translated">저자는 어떠한 경우에도이 소프트웨어의 사용으로 인해 발생하는 특수, 부수적, 결과적, 간접적 또는 기타 유사한 손해에 대해 책임을지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac4f3e7625a4b29694017ee1288427918dba79c" translate="yes" xml:space="preserve">
          <source>The auto-decrement operator is not magical.</source>
          <target state="translated">자동 감소 연산자는 마법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c93a7c7b52c97bf0962eebd109f5c679236979ad" translate="yes" xml:space="preserve">
          <source>The auto-increment operator has a little extra builtin magic to it. If you increment a variable that is numeric, or that has ever been used in a numeric context, you get a normal increment. If, however, the variable has been used in only string contexts since it was set, and has a value that is not the empty string and matches the pattern &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; , the increment is done as a string, preserving each character within its range, with carry:</source>
          <target state="translated">자동 증가 연산자에는 약간의 추가 마법이 있습니다. 숫자이거나 숫자 컨텍스트에서 사용 된 변수를 증가 시키면 정상적인 증가를 얻습니다. 그러나 변수가 설정된 이후 문자열 컨텍스트에서만 사용되었으며 값이 비어있는 문자열이 아니며 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 패턴과 일치하는 경우 / , 증가는 문자열로 수행되며, 각 문자를 해당 범위 내에서 캐리로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="98f580a9f3836ac4322566d6b8e478f5fae589f6" translate="yes" xml:space="preserve">
          <source>The auto-increment operator has a little extra builtin magic to it. If you increment a variable that is numeric, or that has ever been used in a numeric context, you get a normal increment. If, however, the variable has been used in only string contexts since it was set, and has a value that is not the empty string and matches the pattern &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the increment is done as a string, preserving each character within its range, with carry:</source>
          <target state="translated">자동 증가 연산자에는 약간의 추가 마법이 있습니다. 숫자이거나 숫자 컨텍스트에서 사용 된 적이있는 변수를 증가 시키면 정상적인 증가를 얻습니다. 그러나 변수가 설정된 이후 문자열 컨텍스트에서만 사용되었고 값이 빈 문자열이 아니고 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 패턴과 일치하는 경우 / , 증가는 문자열로 수행되며 캐리와 함께 범위 내에서 각 문자를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2fa846bc3447cd43bb267eb92f634f66df9d2ff7" translate="yes" xml:space="preserve">
          <source>The autodie pragma &lt;b&gt;&amp;lt;does not check calls to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;&lt;/b&gt;&amp;gt;.</source>
          <target state="translated">autodie pragma는 &lt;b&gt;&amp;lt; &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; &lt;/b&gt;&lt;b&gt; 호출을 확인하지 않습니다&lt;/b&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="98a12471c985b89ef516cb117a195367046ae1e2" translate="yes" xml:space="preserve">
          <source>The autodie pragma &lt;b&gt;does not check calls to &lt;code&gt;print&lt;/code&gt;&lt;/b&gt;.</source>
          <target state="translated">autodie pragma &lt;b&gt;는 &lt;code&gt;print&lt;/code&gt; &lt;/b&gt;&lt;b&gt; 호출을 확인하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="6a915a44546183301bc1ab2da7f5d31390cf86d3" translate="yes" xml:space="preserve">
          <source>The autodocumentation system was originally added to the Perl core by Benjamin Stuhl. Documentation is by whoever was kind enough to document their functions.</source>
          <target state="translated">자동 문서 시스템은 원래 Benjamin Stuhl에 의해 Perl 코어에 추가되었습니다. 문서는 자신의 기능을 문서화하기에 충분히 친절한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="8079744af772ab20606cdbd94e725737d1ff3213" translate="yes" xml:space="preserve">
          <source>The automatic and manual perl installation leave precompiled paths inside perl executables. While these paths are overwritable (see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot;&lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;&quot;&lt;/a&gt;, &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;), some people may prefer binary editing of paths inside the executables/DLLs.</source>
          <target state="translated">자동 및 수동 perl 설치는 perl 실행 파일 내에 미리 컴파일 된 경로를 남겨 둡니다. 이러한 경로는 덮어 쓸 수 있지만 ( &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot; &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; &quot;&lt;/a&gt; , &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot; &lt;code&gt;PERL_SH_DIR&lt;/code&gt; &quot;&lt;/a&gt; 참조) 일부 사람들은 실행 파일 / DLL 내부 경로의 바이너리 편집을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c574214b5c14cf6b803beb9ac59c1988cd63384" translate="yes" xml:space="preserve">
          <source>The automatic and manual perl installation leave precompiled paths inside perl executables. While these paths are overwriteable (see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;, &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;), some people may prefer binary editing of paths inside the executables/DLLs.</source>
          <target state="translated">자동 및 수동 perl 설치는 사전 컴파일 된 경로를 perl 실행 파일 내에 둡니다. 이러한 경로는 덮어 쓸 수 있지만 ( &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt; , &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt; 참조 ) 일부 사람들은 실행 파일 / DLL 내의 경로를 이진 편집하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff6dd9cd9205a8a816f4c19d3aaf08bb26c3152c" translate="yes" xml:space="preserve">
          <source>The available binary operators are:</source>
          <target state="translated">사용 가능한 이진 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68bb2a0daa0abd0313002b533bf42c71219aad2d" translate="yes" xml:space="preserve">
          <source>The available diagnostics are:</source>
          <target state="translated">사용 가능한 진단은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8dc3fd07c3386d7e5ad61722c90a54b40f250e5" translate="yes" xml:space="preserve">
          <source>The available fields in the structure are:</source>
          <target state="translated">구조에서 사용 가능한 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f5d9f966a103b02ff0ce621879d3a486bfe42de" translate="yes" xml:space="preserve">
          <source>The available functions and the gdbm/perl interface need to be documented.</source>
          <target state="translated">사용 가능한 기능과 gdbm / perl 인터페이스를 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="191f1bb9111a3757ed2ccf45e0e506ae45f1cb2d" translate="yes" xml:space="preserve">
          <source>The available locales depend on your operating system; try whether &lt;code&gt;locale -a&lt;/code&gt; shows them or man pages for &quot;locale&quot; or &quot;nlsinfo&quot; or the direct approach &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; or &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; or &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; . Not all the locales that your vendor supports are necessarily installed: please consult your operating system's documentation and possibly your local system administration. The locale names are probably something like &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; or &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt;, for example &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; is the Swiss (CH) variant of French (fr), ISO Latin (8859) 1 (-1) which is the Western European character set.</source>
          <target state="translated">사용 가능한 로케일은 운영 체제에 따라 다릅니다. &lt;code&gt;locale -a&lt;/code&gt; 가 &quot;locale&quot;또는 &quot;nlsinfo&quot;또는 &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; 또는 &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; 또는 &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; 대한 매뉴얼 페이지를 표시 하는지 또는 시도 하십시오 . 공급 업체가 지원하는 모든 로캘이 반드시 설치되어있는 것은 아닙니다. 운영 체제 설명서 및 가능하면 로컬 시스템 관리를 참조하십시오. 로케일 이름은 아마도 &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; 또는 &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt; 과 같습니다 (예 : &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; 은 프랑스어 (fr), ISO Latin (8859)의 스위스 (CH) 변형 임) 서유럽 문자 세트 인 1 (-1).</target>
        </trans-unit>
        <trans-unit id="5950d79a94709fa9a34b50cb796d9ae7869a56cf" translate="yes" xml:space="preserve">
          <source>The available locales depend on your operating system; try whether &lt;code&gt;locale -a&lt;/code&gt; shows them or man pages for &quot;locale&quot; or &quot;nlsinfo&quot; or the direct approach &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; or &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; or &lt;code&gt;ls /usr/lib/locale&lt;/code&gt;. Not all the locales that your vendor supports are necessarily installed: please consult your operating system's documentation and possibly your local system administration. The locale names are probably something like &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; or &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt;, for example &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; is the Swiss (CH) variant of French (fr), ISO Latin (8859) 1 (-1) which is the Western European character set.</source>
          <target state="translated">사용 가능한 로케일은 운영 체제에 따라 다릅니다. &lt;code&gt;locale -a&lt;/code&gt; 가 &quot;locale&quot;또는 &quot;nlsinfo&quot;에 대한 매뉴얼 페이지를 표시 하는지 또는 직접 접근 방식 &lt;code&gt;ls /usr/lib/nls/loc&lt;/code&gt; 또는 &lt;code&gt;ls /usr/lib/nls&lt;/code&gt; 또는 &lt;code&gt;ls /usr/lib/locale&lt;/code&gt; 시도해보십시오 . 공급 업체에서 지원하는 모든 로케일이 반드시 설치되어있는 것은 아닙니다. 운영 체제 설명서와 로컬 시스템 관리자를 참조하십시오. 로케일 이름은 &lt;code&gt;xx_XX.(ISO)?8859-N&lt;/code&gt; 또는 &lt;code&gt;xx_XX.(ISO)?8859N&lt;/code&gt; 과 유사 합니다. 예를 들어 &lt;code&gt;fr_CH.ISO8859-1&lt;/code&gt; 은 프랑스어 (fr), ISO 라틴어 (8859)의 스위스 (CH) 변형입니다. 서유럽 문자 집합 인 1 (-1)입니다.</target>
        </trans-unit>
        <trans-unit id="7b104fea0c3b585be7abd9fdcae3632fd9df0849" translate="yes" xml:space="preserve">
          <source>The available mechanisms are:</source>
          <target state="translated">사용 가능한 메커니즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54ed46c150718473d8504c434e30cd577b337e90" translate="yes" xml:space="preserve">
          <source>The available options are:</source>
          <target state="translated">사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="456a0ea0217776b650b3498424ef7ee39f3e2d1e" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVbytex_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVbytex_force&lt;/code&gt; 매크로 의 백엔드 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c9c39e2f67b22506a14c5cc6a8fbccb70ed928c" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVbytex_force&lt;/code&gt; macro. Always use the macro instead. If the SV cannot be downgraded from UTF-8, this croaks.</source>
          <target state="translated">&lt;code&gt;SvPVbytex_force&lt;/code&gt; 매크로 의 백엔드입니다 . 대신 항상 매크로를 사용하십시오. SV를 UTF-8에서 다운 그레이드 할 수 없으면이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6595fe0b01dc35e2c9393282a00929c691d16bd4" translate="yes" xml:space="preserve">
          <source>The backend for the &lt;code&gt;SvPVutf8x_force&lt;/code&gt; macro. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVutf8x_force&lt;/code&gt; 매크로 의 백엔드 항상 매크로를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77f66884acce6cf3a3939cb28b0a48cb55b42d47" translate="yes" xml:space="preserve">
          <source>The backslash</source>
          <target state="translated">백 슬래시</target>
        </trans-unit>
        <trans-unit id="d905ecd546099386ec13c3559da83e50955fb3c5" translate="yes" xml:space="preserve">
          <source>The backslash character &lt;code&gt;'\'&lt;/code&gt; is a metacharacter itself and needs to be backslashed:</source>
          <target state="translated">백 슬래시 문자 &lt;code&gt;'\'&lt;/code&gt; 는 메타 문자 자체이며 백 슬래시 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5d16ba0f19a77aff188cb440352e4e0d16b06509" translate="yes" xml:space="preserve">
          <source>The backslash sequence can mean either ASCII- or Full-range Unicode, depending on various factors as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">백 슬래시 시퀀스는 &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;어떤 문자 세트 수정자가 적용됩니까?&quot;에&lt;/a&gt; 설명 된 다양한 요인에 따라 ASCII 또는 전체 범위 유니 코드를 의미 할 수 있습니다. perlre에서 .</target>
        </trans-unit>
        <trans-unit id="3991be487f455d5a6205c52bea36150b4cf4f97a" translate="yes" xml:space="preserve">
          <source>The backslash sequence can mean either ASCII- or Full-range Unicode, depending on various factors as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">백 슬래시 시퀀스는 &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;어떤 문자 세트 수정자가 적용됩니까?에&lt;/a&gt; 설명 된 다양한 요인에 따라 ASCII 또는 전체 범위 유니 코드를 의미 할 수 있습니다 . perlre에서 .</target>
        </trans-unit>
        <trans-unit id="f6d38a5acb41572fd3f6bf7b206aa3e31dca4b0b" translate="yes" xml:space="preserve">
          <source>The backtick operator does no translation of the return value, unlike &lt;b&gt;csh&lt;/b&gt;.</source>
          <target state="translated">backtick 연산자는 &lt;b&gt;csh&lt;/b&gt; 와 달리 반환 값을 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ee45daa9d8b6e8559dda882c9eead013ce496d22" translate="yes" xml:space="preserve">
          <source>The backtick operator does variable interpolation without regard to the presence of single quotes in the command.</source>
          <target state="translated">백틱 연산자는 명령에 작은 따옴표가 있는지 여부에 관계없이 변수 보간을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8cd2b3706bb4ede8bd356d31a0615f4df40a7834" translate="yes" xml:space="preserve">
          <source>The backtrace returns the stack trace of the C call frames, with the symbol names (function names), the object names (like &quot;perl&quot;), and if it can, also the source code locations (&lt;a href=&quot;file:line&quot;&gt;file:line&lt;/a&gt;).</source>
          <target state="translated">역 추적은 심볼 이름 (함수 이름), 객체 이름 (예 : &quot;perl&quot;) 및 가능한 경우 소스 코드 위치 ( &lt;a href=&quot;file:line&quot;&gt;file : line&lt;/a&gt; ) 와 함께 C 호출 프레임의 스택 추적을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7be2ba03c165802aeabdf2632e495da4dcc28f6f" translate="yes" xml:space="preserve">
          <source>The backtrace returns the stack trace of the C call frames, with the symbol names (function names), the object names (like &quot;perl&quot;), and if it can, also the source code locations (file:line).</source>
          <target state="translated">역 추적은 기호 이름 (함수 이름), 개체 이름 (예 : &quot;perl&quot;) 및 가능한 경우 소스 코드 위치 (file : line)와 함께 C 호출 프레임의 스택 추적을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96ebe28b56489a95977a5e2389b0960b80b46cd2" translate="yes" xml:space="preserve">
          <source>The bailout event is generated when things go horribly wrong and you need to halt all testing in the current file.</source>
          <target state="translated">상황이 끔찍하게 잘못되어 현재 파일의 모든 테스트를 중지해야 할 때 구제 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8bed32736e1b2815ccd999741f9407d4d43d0e8b" translate="yes" xml:space="preserve">
          <source>The base class implementation of the &lt;b&gt;interior_sequence()&lt;/b&gt; method simply returns the raw text of the interior sequence (as it occurred in the input) to the caller.</source>
          <target state="translated">&lt;b&gt;interior_sequence ()&lt;/b&gt; 메소드 의 기본 클래스 구현은 단순히 입력에서 발생한 내부 시퀀스의 원시 텍스트를 호출자에게 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c9ddcb47643cb89116a0a922b50075bea2f25a0e" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method returns the given text.</source>
          <target state="translated">이 메소드의 기본 클래스 구현은 주어진 텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3f5a827dc5c599719e7ecb28e524afa3505acc67" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the text block as it occurred in the input stream).</source>
          <target state="translated">이 메소드의 기본 클래스 구현은 입력 스트림에서 발생한대로 텍스트 블록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="df7aaeb92a14b1f8eaf4aa28b1e80496ba8b43fa" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply prints the textblock (unmodified) to the output filehandle.</source>
          <target state="translated">이 메소드의 기본 클래스 구현은 단순히 텍스트 블록 (수정되지 않은)을 출력 파일 핸들에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="303eecbc86fd9c0b4febc57eac0a317dd40331d4" translate="yes" xml:space="preserve">
          <source>The base class implementation of this method simply treats the raw POD command as normal block of paragraph text (invoking the &lt;b&gt;textblock()&lt;/b&gt; method with the command paragraph).</source>
          <target state="translated">이 메소드의 기본 클래스 구현은 단순히 원시 POD 명령을 일반 단락 텍스트 블록으로 처리합니다 ( 명령 단락으로 &lt;b&gt;textblock ()&lt;/b&gt; 메소드 호출 ).</target>
        </trans-unit>
        <trans-unit id="30a72b363b2b43c23f33604f0e962c105dbc3384" translate="yes" xml:space="preserve">
          <source>The base class is added to &lt;code&gt;@ISA&lt;/code&gt; for you, and all constants from base classes are added to subclasses automatically.</source>
          <target state="translated">기본 클래스가 &lt;code&gt;@ISA&lt;/code&gt; 에 추가되고 기본 클래스의 모든 상수가 자동으로 하위 클래스에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b322d5503c2a18a0550bcf3559879c8738ef1a3f" translate="yes" xml:space="preserve">
          <source>The base class' &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is &lt;b&gt;not&lt;/b&gt; called.</source>
          <target state="translated">기본 클래스의 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 메소드가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c67d57925265dfe31af175d142a40fbc15ed1d" translate="yes" xml:space="preserve">
          <source>The base class' &lt;code&gt;import&lt;/code&gt; method is &lt;b&gt;not&lt;/b&gt; called.</source>
          <target state="translated">기본 클래스의 &lt;code&gt;import&lt;/code&gt; 메서드가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="869b6928181db8fd7439173a04a65a2b691f1a82" translate="yes" xml:space="preserve">
          <source>The base function, e.g., &lt;code&gt;isALPHA()&lt;/code&gt; , takes an octet (either a &lt;code&gt;char&lt;/code&gt; or a &lt;code&gt;U8&lt;/code&gt; ) as input and returns a boolean as to whether or not the character represented by that octet is (or on non-ASCII platforms, corresponds to) an ASCII character in the named class based on platform, Unicode, and Perl rules. If the input is a number that doesn't fit in an octet, FALSE is returned.</source>
          <target state="translated">기본 함수 (예 : &lt;code&gt;isALPHA()&lt;/code&gt; 는 8 진수 ( &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;U8&lt;/code&gt; )를 입력으로 사용하고 해당 8 진수로 표시되는 문자가 (또는 비 ASCII 플랫폼에서 해당하는) 문자인지 여부에 대한 부울을 리턴합니다. 플랫폼, 유니 코드 및 Perl 규칙을 기반으로하는 명명 된 클래스의 ASCII 문자 입력이 8 진수에 맞지 않는 숫자이면 FALSE가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d234cdce2bcb4f19ba810617dcca3bc4ffa9c20" translate="yes" xml:space="preserve">
          <source>The base function, e.g., &lt;code&gt;isALPHA()&lt;/code&gt;, takes any signed or unsigned value, treating it as a code point, and returns a boolean as to whether or not the character represented by it is (or on non-ASCII platforms, corresponds to) an ASCII character in the named class based on platform, Unicode, and Perl rules. If the input is a number that doesn't fit in an octet, FALSE is returned.</source>
          <target state="translated">기본 함수 (예 : &lt;code&gt;isALPHA()&lt;/code&gt; )는 부호있는 값이나 부호없는 값을 가져 와서 코드 포인트로 취급하고,이 값이 나타내는 문자가 (또는 비 ASCII 플랫폼에 해당하는지) 여부에 대한 부울을 반환합니다. 플랫폼, 유니 코드 및 Perl 규칙을 기반으로하는 명명 된 클래스의 ASCII 문자. 입력이 8 진수에 맞지 않는 숫자이면 FALSE가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8f2804e508b958c60caacf5d5b30abc7cf323886" translate="yes" xml:space="preserve">
          <source>The base of this stack is pointed to by the interpreter variable &lt;code&gt;PL_markstack&lt;/code&gt;, of type &lt;code&gt;I32 *&lt;/code&gt;.</source>
          <target state="translated">이 스택의 기본은 &lt;code&gt;I32 *&lt;/code&gt; 유형 의 인터프리터 변수 &lt;code&gt;PL_markstack&lt;/code&gt; 에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e058a82fd7eb15740962778cc7b72974faeb4eae" translate="yes" xml:space="preserve">
          <source>The base of this stack is pointed to by the interpreter variable &lt;code&gt;PL_savestack&lt;/code&gt;, of type &lt;code&gt;ANY *&lt;/code&gt;.</source>
          <target state="translated">이 스택의 기본은 &lt;code&gt;ANY *&lt;/code&gt; 유형 의 인터프리터 변수 &lt;code&gt;PL_savestack&lt;/code&gt; 에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4166192c0d77747c217ee386c4f1f52c441e8d0" translate="yes" xml:space="preserve">
          <source>The base of this stack is pointed to by the interpreter variable &lt;code&gt;PL_scopestack&lt;/code&gt;, of type &lt;code&gt;I32 *&lt;/code&gt;. If enabled, the scope stack names are stored in a separate array pointed to by &lt;code&gt;PL_scopestack_name&lt;/code&gt;, of type &lt;code&gt;const char **&lt;/code&gt;.</source>
          <target state="translated">이 스택의 기본은 &lt;code&gt;I32 *&lt;/code&gt; 유형 의 인터프리터 변수 &lt;code&gt;PL_scopestack&lt;/code&gt; 에 의해 지정됩니다 . 활성화 된 경우 범위 스택 이름은 &lt;code&gt;const char **&lt;/code&gt; 유형의 &lt;code&gt;PL_scopestack_name&lt;/code&gt; 이 가리키는 별도의 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="824bda9b43bcc66f929ba59be0ebb4977a91b3a1" translate="yes" xml:space="preserve">
          <source>The base of this stack is pointed to by the interpreter variable &lt;code&gt;PL_stack_base&lt;/code&gt;, of type &lt;code&gt;SV **&lt;/code&gt;.</source>
          <target state="translated">이 스택의베이스는 &lt;code&gt;SV **&lt;/code&gt; 유형 의 인터프리터 변수 &lt;code&gt;PL_stack_base&lt;/code&gt; 에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9219e5e4059ab6937b9fd91a95ef5f4c72681579" translate="yes" xml:space="preserve">
          <source>The base of this stack is pointed to by the interpreter variable &lt;code&gt;PL_tmps_stack&lt;/code&gt;, of type &lt;code&gt;SV **&lt;/code&gt;.</source>
          <target state="translated">이 스택의 기본은 &lt;code&gt;SV **&lt;/code&gt; 유형 의 인터프리터 변수 &lt;code&gt;PL_tmps_stack&lt;/code&gt; 에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4a446b2fbdd7a1f128f546637cc4e95f828763e" translate="yes" xml:space="preserve">
          <source>The base port of Perl to Symbian only implements the basic POSIX-like functionality; it does not implement any further Symbian or Series 60, Series 80, or UIQ bindings for Perl.</source>
          <target state="translated">Perl에서 Symbian으로의 기본 포트는 기본 POSIX와 유사한 기능 만 구현합니다. Perl에 대한 추가 Symbian 또는 Series 60, Series 80 또는 UIQ 바인딩을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b0c0715021b7093caa628303290fd7be9406317" translate="yes" xml:space="preserve">
          <source>The base revision level of this package, from the</source>
          <target state="translated">이 패키지의 기본 개정 레벨</target>
        </trans-unit>
        <trans-unit id="1f81368d64cf4514ffa26dd1724286707ec25460" translate="yes" xml:space="preserve">
          <source>The base should be zero or between 2 and 36, inclusive. When the base is zero or omitted &lt;code&gt;strtol&lt;/code&gt; will use the string itself to determine the base: a leading &quot;0x&quot; or &quot;0X&quot; means hexadecimal; a leading &quot;0&quot; means octal; any other leading characters mean decimal. Thus, &quot;1234&quot; is parsed as a decimal number, &quot;01234&quot; as an octal number, and &quot;0x1234&quot; as a hexadecimal number.</source>
          <target state="translated">밑은 0 또는 2와 36 사이 여야합니다. 밑이 0이거나 생략되면 &lt;code&gt;strtol&lt;/code&gt; 은 문자열 자체를 사용하여 밑을 결정합니다. 선행 &quot;0x&quot;또는 &quot;0X&quot;는 16 진수를 의미합니다. 선행 &quot;0&quot;은 8 진을 의미하고; 다른 선행 문자는 십진수를 의미합니다. 따라서 &quot;1234&quot;는 10 진수로, &quot;01234&quot;는 8 진수로, &quot;0x1234&quot;는 16 진수로 파싱됩니다.</target>
        </trans-unit>
        <trans-unit id="d0bf4e2fa899dc153c411be4c5898369064784f4" translate="yes" xml:space="preserve">
          <source>The base structure of a regop is defined in</source>
          <target state="translated">regop의 기본 구조는</target>
        </trans-unit>
        <trans-unit id="29446f6b360bcce933609abf092817cd60b4c651" translate="yes" xml:space="preserve">
          <source>The base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the string &quot;==&quot; to the result.</source>
          <target state="translated">리턴 된 base64 인코딩 문자열은 4 바이트의 배수로 채워지지 않습니다. 다른 base64로 인코딩 된 md5 다이제스트와 상호 운용성을 원할 경우 문자열 &quot;==&quot;를 결과에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62008320ba4d00f25379dd84477ae04ac38f096e" translate="yes" xml:space="preserve">
          <source>The basic &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; interface that uses &lt;code&gt;_handle_element_start()&lt;/code&gt;, &lt;code&gt;_handle_element_end()&lt;/code&gt; and &lt;code&gt;_handle_text()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_handle_element_start()&lt;/code&gt; , &lt;code&gt;_handle_element_end()&lt;/code&gt; 및 &lt;code&gt;_handle_text()&lt;/code&gt; 를 사용 하는 기본 &lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt; 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="d8ffce64bc52685123cf17779b3bc30ab4b06b36" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;quant&lt;/code&gt; method that Locale::Maketext provides should be good for many languages. For some languages, it might be useful to modify it (or its constituent &lt;code&gt;numerate&lt;/code&gt; method) to take a plural form in the two-argument call to &lt;code&gt;quant&lt;/code&gt; (as in &quot;[quant,_1,files]&quot;) if it's all-around easier to infer the singular form from the plural, than to infer the plural form from the singular.</source>
          <target state="translated">Locale :: Maketext가 제공하는 기본 &lt;code&gt;quant&lt;/code&gt; 메소드는 많은 언어에 적합해야합니다. 일부 언어의 경우, 그것은 (또는 그 구성 수정 유용 할 수 있습니다 &lt;code&gt;numerate&lt;/code&gt; 에 2 개의 인수를 호출의 복수 형태 취할 방법) &lt;code&gt;quant&lt;/code&gt; (같이 &quot;[퀀트, _1 파일]&quot;)은 모든 주위의 경우 쉽게 단수의 복수 형태를 유추하는 것보다 복수의 단수 형태를 유추하는 것.</target>
        </trans-unit>
        <trans-unit id="bd8f1357516762bbb931d125e3d2a8b11599ee5f" translate="yes" xml:space="preserve">
          <source>The basic IPC facilities of Perl are built out of the good old Unix signals, named pipes, pipe opens, the Berkeley socket routines, and SysV IPC calls. Each is used in slightly different situations.</source>
          <target state="translated">Perl의 기본 IPC 기능은 오래된 유닉스 신호, 명명 된 파이프, 파이프 개구부, 버클리 소켓 루틴 및 SysV IPC 호출로 구축됩니다. 각각 약간 다른 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9eaaba65a1dac8dd5fd38c2dd581e65245159383" translate="yes" xml:space="preserve">
          <source>The basic building block of Perl strings has always been a &quot;character&quot;. The changes basically come down to that the implementation no longer thinks that a character is always just a single byte.</source>
          <target state="translated">Perl 문자열의 기본 구성 요소는 항상 &quot;문자&quot;였습니다. 변경 사항은 기본적으로 구현이 더 이상 문자가 항상 단일 바이트라고 생각하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bf944598ad68a6908fe4ecd014a8a61a7b06d00e" translate="yes" xml:space="preserve">
          <source>The basic data structure is a PerlIOl:</source>
          <target state="translated">기본 데이터 구조는 PerlIOl입니다.</target>
        </trans-unit>
        <trans-unit id="b5815b577f436fdec50339dbc9340f9c6b027e08" translate="yes" xml:space="preserve">
          <source>The basic design of Locale::Maketext is object-oriented, and Locale::Maketext is an abstract base class, from which you derive a &quot;project class&quot;. The project class (with a name like &quot;TkBocciBall::Localize&quot;, which you then use in your module) is in turn the base class for all the &quot;language classes&quot; for your project (with names &quot;TkBocciBall::Localize::it&quot;, &quot;TkBocciBall::Localize::en&quot;, &quot;TkBocciBall::Localize::fr&quot;, etc.).</source>
          <target state="translated">Locale :: Maketext의 기본 디자인은 객체 지향적이며 Locale :: Maketext는 &quot;프로젝트 클래스&quot;를 파생시키는 추상 기본 클래스입니다. 모듈에서 사용하는 &quot;TkBocciBall :: Localize&quot;와 같은 이름을 가진 프로젝트 클래스는 프로젝트의 모든 &quot;언어 클래스&quot;의 기본 클래스입니다 (이름이 &quot;TkBocciBall :: Localize :: it&quot;). &quot;,&quot;TkBocciBall :: Localize :: en &quot;,&quot;TkBocciBall :: Localize :: fr &quot;등).</target>
        </trans-unit>
        <trans-unit id="7d3d2515e50dae3561d665210b7c755d11c489ee" translate="yes" xml:space="preserve">
          <source>The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few simple rules are followed:</source>
          <target state="translated">Math :: BigInt의 기본 설계는 몇 가지 간단한 규칙을 따르는 한 적은 작업으로 간단한 서브 클래스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1933c32469836b92b1e6ed87797ae53de2e4a98a" translate="yes" xml:space="preserve">
          <source>The basic files in a module look something like this.</source>
          <target state="translated">모듈의 기본 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6d870a61314be9718a03ae44ad1eb35ba8497ce" translate="yes" xml:space="preserve">
          <source>The basic function names: &lt;code&gt;attrLetsToBits&lt;/code&gt;, &lt;code&gt;createFile&lt;/code&gt;, &lt;code&gt;fileConstant&lt;/code&gt;, &lt;code&gt;fileLastError&lt;/code&gt;, &lt;code&gt;getLogicalDrives&lt;/code&gt;, &lt;code&gt;setFilePointer&lt;/code&gt;, &lt;code&gt;getFileSize&lt;/code&gt;, &lt;code&gt;CloseHandle&lt;/code&gt;, &lt;code&gt;CopyFile&lt;/code&gt;, &lt;code&gt;CreateFile&lt;/code&gt;, &lt;code&gt;DefineDosDevice&lt;/code&gt;, &lt;code&gt;DeleteFile&lt;/code&gt;, &lt;code&gt;DeviceIoControl&lt;/code&gt;, &lt;code&gt;FdGetOsFHandle&lt;/code&gt;, &lt;code&gt;GetDriveType&lt;/code&gt;, &lt;code&gt;GetFileAttributes&lt;/code&gt;, &lt;code&gt;GetFileSize&lt;/code&gt;, &lt;code&gt;GetFileType&lt;/code&gt;, &lt;code&gt;GetHandleInformation&lt;/code&gt;, &lt;code&gt;GetLogicalDrives&lt;/code&gt;, &lt;code&gt;GetLogicalDriveStrings&lt;/code&gt;, &lt;code&gt;GetOsFHandle&lt;/code&gt;, &lt;code&gt;GetOverlappedResult&lt;/code&gt;, &lt;code&gt;GetVolumeInformation&lt;/code&gt;, &lt;code&gt;IsContainerPartition&lt;/code&gt;, &lt;code&gt;IsRecognizedPartition&lt;/code&gt;, &lt;code&gt;MoveFile&lt;/code&gt;, &lt;code&gt;MoveFileEx&lt;/code&gt;, &lt;code&gt;OsFHandleOpen&lt;/code&gt;, &lt;code&gt;OsFHandleOpenFd&lt;/code&gt;, &lt;code&gt;QueryDosDevice&lt;/code&gt;, &lt;code&gt;ReadFile&lt;/code&gt;, &lt;code&gt;SetErrorMode&lt;/code&gt;, &lt;code&gt;SetFilePointer&lt;/code&gt;, &lt;code&gt;SetHandleInformation&lt;/code&gt;, and &lt;code&gt;WriteFile&lt;/code&gt;.</source>
          <target state="translated">기본 함수 이름 : &lt;code&gt;attrLetsToBits&lt;/code&gt; , &lt;code&gt;createFile&lt;/code&gt; , &lt;code&gt;fileConstant&lt;/code&gt; , &lt;code&gt;fileLastError&lt;/code&gt; , &lt;code&gt;getLogicalDrives&lt;/code&gt; , &lt;code&gt;setFilePointer&lt;/code&gt; , &lt;code&gt;getFileSize&lt;/code&gt; , &lt;code&gt;CloseHandle&lt;/code&gt; , &lt;code&gt;CopyFile&lt;/code&gt; 수 , &lt;code&gt;CreateFile&lt;/code&gt; 에 , &lt;code&gt;DefineDosDevice&lt;/code&gt; , &lt;code&gt;DeleteFile&lt;/code&gt; 을 , &lt;code&gt;DeviceIoControl&lt;/code&gt; 을 , &lt;code&gt;FdGetOsFHandle&lt;/code&gt; , &lt;code&gt;GetDriveType&lt;/code&gt; , &lt;code&gt;GetFileAttributes&lt;/code&gt; 와 , &lt;code&gt;GetFileSize&lt;/code&gt; , &lt;code&gt;GetFileType&lt;/code&gt; , &lt;code&gt;GetHandleInformation&lt;/code&gt; , &lt;code&gt;GetLogicalDrives&lt;/code&gt; , &lt;code&gt;GetLogicalDriveStrings&lt;/code&gt; , &lt;code&gt;GetOsFHandle&lt;/code&gt; , &lt;code&gt;GetOverlappedResult&lt;/code&gt; , &lt;code&gt;GetVolumeInformation&lt;/code&gt; , &lt;code&gt;IsContainerPartition&lt;/code&gt; , &lt;code&gt;IsRecognizedPartition&lt;/code&gt; , &lt;code&gt;MoveFile&lt;/code&gt; , &lt;code&gt;MoveFileEx&lt;/code&gt; , &lt;code&gt;OsFHandleOpen&lt;/code&gt; , &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; , &lt;code&gt;QueryDosDevice&lt;/code&gt; , &lt;code&gt;ReadFile&lt;/code&gt; 을 , &lt;code&gt;SetErrorMode&lt;/code&gt; , &lt;code&gt;SetFilePointer&lt;/code&gt; 를 , &lt;code&gt;SetHandleInformation&lt;/code&gt; 과 &lt;code&gt;WriteFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341f2c68b6960d075517d469051ae07bb1f926b7" translate="yes" xml:space="preserve">
          <source>The basic idea of inserting, changing, or deleting a line from a text file involves reading and printing the file to the point you want to make the change, making the change, then reading and printing the rest of the file. Perl doesn't provide random access to lines (especially since the record input separator, &lt;code&gt;$/&lt;/code&gt; , is mutable), although modules such as &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; can fake it.</source>
          <target state="translated">텍스트 파일에서 행을 삽입, 변경 또는 삭제하는 기본 개념은 파일을 변경하려는 지점까지 읽고 인쇄하고 변경 한 다음 나머지 파일을 읽고 인쇄하는 것입니다. Perl은 &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; 과 같은 모듈 이 위조 할 수 있지만 행에 대한 임의 액세스를 제공하지 않습니다 (특히 레코드 입력 구분 기호 &lt;code&gt;$/&lt;/code&gt; 가 변경 가능 하므로).</target>
        </trans-unit>
        <trans-unit id="73d46d53ac64c7d929449ef005ae74bdb7048b67" translate="yes" xml:space="preserve">
          <source>The basic idea of inserting, changing, or deleting a line from a text file involves reading and printing the file to the point you want to make the change, making the change, then reading and printing the rest of the file. Perl doesn't provide random access to lines (especially since the record input separator, &lt;code&gt;$/&lt;/code&gt;, is mutable), although modules such as &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; can fake it.</source>
          <target state="translated">텍스트 파일에서 행을 삽입, 변경 또는 삭제하는 기본 개념은 변경하려는 지점까지 파일을 읽고 인쇄하고, 변경 한 다음 나머지 파일을 읽고 인쇄하는 것입니다. Perl은 행에 대한 임의 액세스를 제공하지 않지만 (특히 레코드 입력 구분 기호 인 &lt;code&gt;$/&lt;/code&gt; 는 변경 가능하므로) &lt;a href=&quot;Tie::File&quot;&gt;Tie :: File&lt;/a&gt; 과 같은 모듈이 이를 가짜로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99456abf05b5371483583dbfe86305dc116a350f" translate="yes" xml:space="preserve">
          <source>The basic purpose of this module is to print out either &quot;ok #&quot; or &quot;not ok #&quot; depending on if a given test succeeded or failed. Everything else is just gravy.</source>
          <target state="translated">이 모듈의 기본 목적은 주어진 테스트의 성공 또는 실패 여부에 따라 &quot;ok #&quot;또는 &quot;not ok #&quot;를 인쇄하는 것입니다. 다른 모든 것은 단지 국물입니다.</target>
        </trans-unit>
        <trans-unit id="64db8342329369b417d189ab1b4fe97232b396bf" translate="yes" xml:space="preserve">
          <source>The basic structure of this routine is to try to find the start- and/or end-points of where the pattern could match, and to ensure that the string is long enough to match the pattern. It tries to use more efficient methods over less efficient methods and may involve considerable cross-checking of constraints to find the place in the string that matches. For instance it may try to determine that a given fixed string must be not only present but a certain number of chars before the end of the string, or whatever.</source>
          <target state="translated">이 루틴의 기본 구조는 패턴이 일치 할 수있는 시작점 및 / 또는 끝점을 찾고 문자열이 패턴과 일치하기에 충분히 길도록하는 것입니다. 덜 효율적인 방법보다 더 효율적인 방법을 사용하려고하며 문자열에서 일치하는 위치를 찾기 위해 제약 조건을 상당히 교차 검사해야 할 수 있습니다. 예를 들어 주어진 고정 문자열이 문자열의 끝 이전에 존재하거나 특정 수의 문자 또는 기타로 존재해야한다고 결정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80dbc79bfdbd83bc8576245228c2b94ef265f584" translate="yes" xml:space="preserve">
          <source>The basic unit of Perl testing is the ok. For each thing you want to test your program will print out an &quot;ok&quot; or &quot;not ok&quot; to indicate pass or fail. You do this with the &lt;code&gt;ok()&lt;/code&gt; function (see below).</source>
          <target state="translated">Perl 테스트의 기본 단위는 괜찮습니다. 테스트하려는 각 항목에 대해 &quot;ok&quot;또는 &quot;not ok&quot;를 인쇄하여 합격 또는 불합격을 나타냅니다. &lt;code&gt;ok()&lt;/code&gt; 함수를 사용 하여이 작업을 수행 합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e78bcfeff26c8ed24e8e77c222a138596b768482" translate="yes" xml:space="preserve">
          <source>The beginning of the epoch is different on most non-Unix operating systems [8]. Even though Perl smooths out the differences for the most part, certain ports do it differently. MacPerl is one off the top of my head. [9] Rather than putting a comment in the test and hoping someone will read the test while debugging the failure, we can explicitly say it's never going to work and skip the test.</source>
          <target state="translated">시대의 시작은 대부분의 비 Unix 운영 체제에서 다릅니다 [8]. Perl이 대부분의 경우 차이를 완화하더라도 특정 포트는 다르게 수행합니다. MacPerl은 내 머리 꼭대기에서 벗어난 것입니다. [9] 테스트에 주석을 달고 실패를 디버깅하는 동안 누군가가 테스트를 읽어주기를 바라는 대신, 절대 작동하지 않을 것이라고 명시 적으로 말하고 테스트를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20eeacb6cbf86ebba36b318f2c77375e12ee151e" translate="yes" xml:space="preserve">
          <source>The behavior implied by the &lt;b&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/b&gt; pragma is not mandatory.</source>
          <target state="translated">&lt;b&gt;사용 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt;&lt;/b&gt; pragma가 암시하는 동작 은 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9d2230b748e4308cffef19ddef65b44d6210c473" translate="yes" xml:space="preserve">
          <source>The behavior implied by the &lt;b&gt;use warnings&lt;/b&gt; pragma is not mandatory.</source>
          <target state="translated">&lt;b&gt;사용 경고&lt;/b&gt; pragma에 의해 암시 된 동작 은 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b5f143aadeaa7a8e64e344e87d8748a02f3060a4" translate="yes" xml:space="preserve">
          <source>The behavior is undefined if LENGTH is greater than the length of the file.</source>
          <target state="translated">LENGTH가 파일 길이보다 큰 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2096cb596b278036fd28628376a1846bea674e31" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt; on a directory handle depends on the operating system. On a system with &lt;a href=&quot;http://man.he.net/man3/dirfd&quot;&gt;dirfd(3)&lt;/a&gt; or similar, &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="translated">디렉토리 핸들 에서 &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt; &lt;code&gt;fileno&lt;/code&gt; &lt;/a&gt; 의 동작은 운영 체제에 따라 다릅니다. &lt;a href=&quot;http://man.he.net/man3/dirfd&quot;&gt;dirfd (3)&lt;/a&gt; 또는 이와 유사한 시스템 에서 디렉토리 핸들의 &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt; &lt;code&gt;fileno&lt;/code&gt; &lt;/a&gt; 는 핸들과 관련된 기본 파일 설명자를 반환합니다. 이러한 지원이없는 시스템에서는 정의되지 않은 값을 반환하고 &lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;(errno).</target>
        </trans-unit>
        <trans-unit id="2f1c51d0082c9a007ed014e64f75cf7ba3d7eb5f" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">디렉토리 핸들 에서 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 의 동작은 운영 체제에 따라 다릅니다. dirfd (3) 또는 이와 유사한 시스템 에서 디렉토리 핸들의 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 는 핸들과 연관된 기본 파일 디스크립터를 리턴합니다. 이러한 지원이없는 시스템에서는 정의되지 않은 값을 반환하고 &lt;code&gt;$!&lt;/code&gt; (errno).</target>
        </trans-unit>
        <trans-unit id="ac7e84891cea0201bfbd9008ae17bfca2f62f2a2" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">정규식 코드 블록 내에서 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 의 동작 (예 : &lt;code&gt;/(?{...})/&lt;/code&gt; )은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f854aca9536e1cea9a0904019b31bc3e9f0356" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle depends on the operating system. On a system with dirfd(3) or similar, &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; on a directory handle returns the underlying file descriptor associated with the handle; on systems with no such support, it returns the undefined value, and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">디렉토리 핸들 에서 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 의 동작은 운영 체제에 따라 다릅니다. dirfd (3) 또는 이와 유사한 시스템 에서 디렉토리 핸들의 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 는 핸들과 연관된 기본 파일 디스크립터를 리턴합니다. 이러한 지원이없는 시스템에서는 정의되지 않은 값을 반환하고 &lt;code&gt;$!&lt;/code&gt; (errno).</target>
        </trans-unit>
        <trans-unit id="b40b140fab8dabde747778f074dcf7a657d0f19a" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;__SUB__&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt;) is subject to change.</source>
          <target state="translated">정규식 코드 블록 (예 : &lt;code&gt;/(?{...})/&lt;/code&gt; ) 내에서 &lt;code&gt;__SUB__&lt;/code&gt; 의 동작은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c21c5f299927d5b3bf2172e0cf7aff5e3373e8" translate="yes" xml:space="preserve">
          <source>The behavior of PREFIX is complicated and depends closely on how your Perl is configured. The resulting installation locations will vary from machine to machine and even different installations of Perl on the same machine. Because of this, its difficult to document where prefix will place your modules.</source>
          <target state="translated">PREFIX의 동작은 복잡하며 Perl의 구성 방식에 밀접하게 의존합니다. 결과 설치 위치는 기계마다 다르며 심지어 동일한 기계에서 다른 Perl 설치도 있습니다. 이 때문에 접두사가 모듈을 배치 할 위치를 문서화하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="93dc5bd5efb782736e0942603b0c8fa1c754b397" translate="yes" xml:space="preserve">
          <source>The behavior of a smartmatch depends on what type of things its arguments are, as determined by the following table. The first row of the table whose types apply determines the smartmatch behavior. Because what actually happens is mostly determined by the type of the second operand, the table is sorted on the right operand instead of on the left.</source>
          <target state="translated">스마트 매치의 동작은 다음 표에 따라 결정되는 인수 유형에 따라 다릅니다. 유형이 적용되는 테이블의 첫 번째 행이 스마트 매치 동작을 결정합니다. 실제로 발생하는 일은 대부분 두 번째 피연산자의 유형에 따라 결정되므로 테이블은 왼쪽이 아닌 오른쪽 피연산자에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="f414c994d5bce7014330ec5990bba640279929f3" translate="yes" xml:space="preserve">
          <source>The behavior of binary arithmetic operators depends on whether they're used on numbers or strings. The operators treat a string as a series of bits and work with that (the string &lt;code&gt;&quot;3&quot;&lt;/code&gt; is the bit pattern &lt;code&gt;00110011&lt;/code&gt; ). The operators work with the binary form of a number (the number &lt;code&gt;3&lt;/code&gt; is treated as the bit pattern &lt;code&gt;00000011&lt;/code&gt; ).</source>
          <target state="translated">이진 산술 연산자의 동작은 숫자 또는 문자열에 사용되는지 여부에 따라 다릅니다. 연산자는 문자열을 일련의 비트로 취급하고이를 사용합니다 (문자열 &lt;code&gt;&quot;3&quot;&lt;/code&gt; 은 비트 패턴 &lt;code&gt;00110011&lt;/code&gt; ). 연산자는 숫자의 이진 형식으로 작업합니다 (숫자 &lt;code&gt;3&lt;/code&gt; 은 비트 패턴 &lt;code&gt;00000011&lt;/code&gt; 로 처리됨 ).</target>
        </trans-unit>
        <trans-unit id="61a33e39ba8bd8a7eda6fc2bc9495d8cd7f236d5" translate="yes" xml:space="preserve">
          <source>The behavior of binary arithmetic operators depends on whether they're used on numbers or strings. The operators treat a string as a series of bits and work with that (the string &lt;code&gt;&quot;3&quot;&lt;/code&gt; is the bit pattern &lt;code&gt;00110011&lt;/code&gt;). The operators work with the binary form of a number (the number &lt;code&gt;3&lt;/code&gt; is treated as the bit pattern &lt;code&gt;00000011&lt;/code&gt;).</source>
          <target state="translated">이진 산술 연산자의 동작은 숫자 또는 문자열에 사용되는지 여부에 따라 다릅니다. 연산자는 문자열을 일련의 비트로 취급하고이를 처리합니다 (문자열 &lt;code&gt;&quot;3&quot;&lt;/code&gt; 은 비트 패턴 &lt;code&gt;00110011&lt;/code&gt; 임). 연산자는 숫자의 이진 형식으로 작업합니다 (숫자 &lt;code&gt;3&lt;/code&gt; 은 비트 패턴 &lt;code&gt;00000011&lt;/code&gt; 로 처리됨 ).</target>
        </trans-unit>
        <trans-unit id="31eed332c2e58a5c0964723f7df67ca11212685a" translate="yes" xml:space="preserve">
          <source>The behavior of kill when a</source>
          <target state="translated">때 살인의 행동</target>
        </trans-unit>
        <trans-unit id="d59b4319820011355ea137761a33247562041027" translate="yes" xml:space="preserve">
          <source>The behavior of local() on non-existent members of composite types is subject to change in future.</source>
          <target state="translated">존재하지 않는 복합 유형의 멤버에 대한 local ()의 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d079532ca2996d42dc670ce4330816041cebfb1a" translate="yes" xml:space="preserve">
          <source>The behavior of local() on non-existent members of composite types is subject to change in future. The behavior of local() on array elements specified using negative indexes is particularly surprising, and is very likely to change.</source>
          <target state="translated">존재하지 않는 복합 유형 멤버에 대한 local ()의 동작은 향후 변경 될 수 있습니다. 음수 인덱스를 사용하여 지정된 배열 요소에 대한 local () 동작은 특히 놀랍고 변경 될 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="94074c7a51f126b1c094a943070970e09d6ecaef" translate="yes" xml:space="preserve">
          <source>The behavior of the overloaded operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">오버로드 된 연산자 %의 동작은 Perl의 내장 % 연산자 (perlop 맨 페이지에 문서화 됨)의 동작 및 방정식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ad390bfcc2f23a71fab54461bd3359a98aa3f6d" translate="yes" xml:space="preserve">
          <source>The behavior of these operators is problematic (and subject to change) if either or both of the strings are encoded in UTF-8 (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;.</source>
          <target state="translated">이 연산자의 동작은 문자열 중 하나 또는 둘 다 UTF-8로 인코딩 된 경우 문제가되고 변경 될 수 있습니다 ( &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;perlunicode의 바이트 및 문자 의미&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="a64f313f128b7624f16c0e92b9e3e3d919ea21bc" translate="yes" xml:space="preserve">
          <source>The behavior of tied arrays is not precisely the same as for regular arrays. For example:</source>
          <target state="translated">연결된 배열의 동작은 일반 배열과 정확히 동일하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d6e17f33363309695a628e965769ec7e992d708" translate="yes" xml:space="preserve">
          <source>The behaviour enabled by &lt;code&gt;MultiHomed&lt;/code&gt; is in fact implemented by &lt;code&gt;IO::Socket::IP&lt;/code&gt; as it is required to correctly support searching for a useable address from the results of the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; call. The constructor will ignore the value of this argument, except if it is defined but false. An exception is thrown in this case, because that would request it disable the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; search behaviour in the first place.</source>
          <target state="translated">&lt;code&gt;MultiHomed&lt;/code&gt; 에 의해 활성화 된 동작 은 실제로 &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 호출 결과에서 사용 가능한 주소 검색을 올바르게 지원하는 데 필요하므로 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 의해 구현됩니다 . 생성자는 정의되었지만 false 인 경우를 제외하고이 인수의 값을 무시합니다. 이 경우 처음에 &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 검색 동작을 비활성화하도록 요청하기 때문에 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="81add6bddb2cf2d3ac083c893ddbfb13210c6d9c" translate="yes" xml:space="preserve">
          <source>The behaviour is identical to the behaviour of the Maple and Mathematica function for negative integers n, k.</source>
          <target state="translated">이 동작은 음의 정수 n, k에 대한 Maple 및 Mathematica 함수의 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="86659ece67a318dbbee63a0198094606262d645f" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#__SUB__&quot;&gt;&lt;code&gt;__SUB__&lt;/code&gt;&lt;/a&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt;) is subject to change.</source>
          <target state="translated">정규식 코드 블록 (예 : &lt;code&gt;/(?{...})/&lt;/code&gt; ) 내에서 &lt;a href=&quot;#__SUB__&quot;&gt; &lt;code&gt;__SUB__&lt;/code&gt; &lt;/a&gt; 의 동작은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0badd9be08f08b4979fe3b1de97bfe49c691a516" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;%-&lt;/code&gt; is implemented via the &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; 의 동작은 &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 모듈을 통해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e661f036702b62721315aa1d02abc1020897293c" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;%-&lt;/code&gt; is implemented via the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; 의 동작은 &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; 모듈을 통해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f2f442d7e61435532ac3ebe398b46e4cb8b23b2" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">정규식 코드 블록 내에서 &lt;code&gt;&lt;a href=&quot;__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 의 동작 (예 : &lt;code&gt;/(?{...})/&lt;/code&gt; )은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecf97494e2dabd3d3c4d6cda259bfc77c61ec233" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; within a regex code block (such as &lt;code&gt;/(?{...})/&lt;/code&gt; ) is subject to change.</source>
          <target state="translated">정규식 코드 블록 내에서 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 의 동작 (예 : &lt;code&gt;/(?{...})/&lt;/code&gt; )은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893a97392f7263bab5a8304f6d49e881ca91ba83" translate="yes" xml:space="preserve">
          <source>The behaviour of File::Fetch can be altered by changing the following global variables:</source>
          <target state="translated">File :: Fetch의 동작은 다음 전역 변수를 변경하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9225f0f55c56aed5c676f19da54d01c0121ae5ab" translate="yes" xml:space="preserve">
          <source>The behaviour of IPC::Cmd can be altered by changing the following global variables:</source>
          <target state="translated">IPC :: Cmd의 동작은 다음 전역 변수를 변경하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d64ba516b01f1b6dc31324edef30defa2d23432c" translate="yes" xml:space="preserve">
          <source>The behaviour of Module::Load::Conditional can be altered by changing the following global variables:</source>
          <target state="translated">Module :: Load :: Conditional의 동작은 다음 전역 변수를 변경하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47460fd55663b585106f39954f79fa9625db07e7" translate="yes" xml:space="preserve">
          <source>The behaviour of Params::Check can be altered by changing the following global variables:</source>
          <target state="translated">Params :: Check의 동작은 다음 전역 변수를 변경하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deb69a58f590c98de917558022e0254d1d774946" translate="yes" xml:space="preserve">
          <source>The behaviour of the function depends on the arguments:</source>
          <target state="translated">함수의 동작은 인수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ec80595e1c021e2b98071cdf1e5337bff9c960f" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">이 옵션의 동작은 &lt;code&gt;$output&lt;/code&gt; 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="1261454ba433f0ffbaaf578315904f113ae3fec5" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 동작은 &lt;code&gt;$output&lt;/code&gt; 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="db32480c737ba8d1007a7ce0c4ddf37612954128" translate="yes" xml:space="preserve">
          <source>The behaviour of this option is dependent on the type of output data stream.</source>
          <target state="translated">이 옵션의 동작은 출력 데이터 스트림 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ae8ebb83ae7fe5dc9eabc5af8c2815aedcfc7b2d" translate="yes" xml:space="preserve">
          <source>The belief that &amp;ldquo;small is beautiful&amp;rdquo;. Paradoxically, if you say something in a small language, it turns out big, and if you say it in a big language, it turns out small. Go figure.</source>
          <target state="translated">&quot;작은 것이 아름답다&quot;는 믿음. 역설적으로, 작은 언어로 무언가를 말하면 크게 나타나고, 큰 언어로 말하면 작게 나타납니다. 그림을 이동.</target>
        </trans-unit>
        <trans-unit id="5dcff025d12c2edfa9fc4a567fa29e7990ea6873" translate="yes" xml:space="preserve">
          <source>The benefit of using &lt;code&gt;-Mlib=/foo&lt;/code&gt; over &lt;code&gt;-I/foo&lt;/code&gt; , is that the former will automagically remove any duplicated directories, while the latter will not.</source>
          <target state="translated">&lt;code&gt;-I/foo&lt;/code&gt; &lt;code&gt;-Mlib=/foo&lt;/code&gt; 보다 -Mlib = / foo 를 사용 하면 전자가 복제 된 디렉토리를 자동으로 제거하지만 후자는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a1d4088b37d379e81cd51e05856ac66578c7565" translate="yes" xml:space="preserve">
          <source>The benefit of using &lt;code&gt;-Mlib=/foo&lt;/code&gt; over &lt;code&gt;-I/foo&lt;/code&gt;, is that the former will automagically remove any duplicated directories, while the latter will not.</source>
          <target state="translated">&lt;code&gt;-I/foo&lt;/code&gt; &lt;code&gt;-Mlib=/foo&lt;/code&gt; 보다 -Mlib = / foo 를 사용하는 이점은 전자가 중복 된 디렉토리를 자동으로 제거하는 반면 후자는 그렇지 않다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18900f73de54d7de200d866c09a29fdcc8cd53a3" translate="yes" xml:space="preserve">
          <source>The best algorithm depends on many things. On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times. You can force the choice of algorithm with this pragma, but this feels heavy-handed, so the subpragmas beginning with a &lt;code&gt;_&lt;/code&gt; may not persist beyond Perl 5.8. The default algorithm is mergesort, which will be stable even if you do not explicitly demand it. But the stability of the default sort is a side-effect that could change in later versions. If stability is important, be sure to say so with a</source>
          <target state="translated">가장 좋은 알고리즘은 많은 것에 달려 있습니다. 평균적으로 mergesort는 quicksort보다 적은 수의 비교를 수행하므로 복잡한 비교 루틴을 사용할 때 더 좋습니다. Mergesort는 또한 기존 순서를 이용하므로 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 를 사용하여 여러 정렬 된 배열을 병합하는 것이 좋습니다. 반면에, 퀵 정렬은 종종 작은 배열의 경우 더 빠르며 몇 가지 고유 한 값의 배열에서는 여러 번 반복됩니다. 이 pragma를 사용하여 알고리즘을 강제로 선택할 수 있지만,이 방법은 힘이 넘치므로 subpragma는 &lt;code&gt;_&lt;/code&gt; Perl 5.8 이상으로 지속되지 않을 수 있습니다. 기본 알고리즘은 mergesort이며, 명시 적으로 요구하지 않더라도 안정적입니다. 그러나 기본 정렬의 안정성은 이후 버전에서 변경 될 수있는 부작용입니다. 안정성이 중요하다면</target>
        </trans-unit>
        <trans-unit id="25c86820424aca2962f29e4f76c6234dbf83f89d" translate="yes" xml:space="preserve">
          <source>The best comments explain</source>
          <target state="translated">최고의 의견 설명</target>
        </trans-unit>
        <trans-unit id="97fb423abf47c78c911e5c1b325aae0069b921b4" translate="yes" xml:space="preserve">
          <source>The best way to avoid this oddity is to use this pragma RIGHT AFTER other modules are loaded. i.e.</source>
          <target state="translated">이 이상한 점을 피하는 가장 좋은 방법은 다른 모듈을로드 한 후에이 pragma를 사용하는 것입니다. 즉</target>
        </trans-unit>
        <trans-unit id="7c4c0bd8f72ca6e9c0f331a5d5955e9a813aecd9" translate="yes" xml:space="preserve">
          <source>The best way to do this is to come up with a better algorithm. This can often make a dramatic difference. Jon Bentley's book</source>
          <target state="translated">가장 좋은 방법은 더 나은 알고리즘을 만드는 것입니다. 이것은 종종 극적인 차이를 만들 수 있습니다. 존 벤틀리의 책</target>
        </trans-unit>
        <trans-unit id="98421bf65e01fd86f5f0e0be25fe15a961951223" translate="yes" xml:space="preserve">
          <source>The best way to know for sure, and pick up many helpful suggestions, is to ask someone who knows. Comp.lang.perl.misc is read by just about all the people who develop modules and it's the best place to ask.</source>
          <target state="translated">확실하게 알고 가장 유용한 제안을받는 가장 좋은 방법은 아는 사람에게 물어 보는 것입니다. Comp.lang.perl.misc는 모듈을 개발하는 모든 사람들에 의해 읽혀졌으며 요청하기 가장 좋은 곳입니다.</target>
        </trans-unit>
        <trans-unit id="8012d3847bdbe5868b4008ed2bf6d56e73e2edc0" translate="yes" xml:space="preserve">
          <source>The best way to know for sure, and pick up many helpful suggestions, is to ask someone who knows. The &amp;lt;module-authors@perl.org&amp;gt; mailing list is useful for this purpose; it's also accessible via news interface as perl.module-authors at nntp.perl.org.</source>
          <target state="translated">확실히 알 수있는 가장 좋은 방법은 아는 사람에게 물어 보는 것입니다. &amp;lt;module-authors@perl.org&amp;gt; 메일 링리스트는 이러한 목적에 유용합니다. 또한 nntp.perl.org에서 perl.module-authors로 뉴스 인터페이스를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32d03eab0e341d80074007f2d5b494b8f3cdcfe" translate="yes" xml:space="preserve">
          <source>The best way to prevent this issue is to use waitpid(), as in the following example:</source>
          <target state="translated">이 문제를 방지하는 가장 좋은 방법은 다음 예제와 같이 waitpid ()를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="832c6230c64f67a2bd05effe72650dfa3f10cba9" translate="yes" xml:space="preserve">
          <source>The best way to unlock a file is to discard the object and untie the array. It is probably unsafe to unlock the file without also untying it, because if you do, changes may remain unwritten inside the object. That is why there is no shortcut for unlocking. If you really want to unlock the file prematurely, you know what to do; if you don't know what to do, then don't do it.</source>
          <target state="translated">파일 잠금을 해제하는 가장 좋은 방법은 객체를 버리고 배열을 해제하는 것입니다. 파일을 풀지 않고 파일을 잠금 해제하지 않으면 안전하지 않을 수 있습니다. 변경하면 객체 내부에서 변경 사항이 기록되지 않은 상태로 남아있을 수 있습니다. 이것이 바로 잠금 해제 단축키가없는 이유입니다. 파일을 조기에 잠금 해제하려면 어떻게해야하는지 알고 있습니다. 해야 할 일을 모른다면하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7b82cd1f6eaec920a028950cb809a9a88e952b55" translate="yes" xml:space="preserve">
          <source>The big advantage of this form is that it makes it much easier to write patterns with references that can be interpolated in larger patterns, even if the larger pattern also contains capture groups.</source>
          <target state="translated">이 형식의 큰 장점은 큰 패턴에도 캡처 그룹이 포함되어 있어도 큰 패턴으로 보간 할 수있는 참조를 사용하여 패턴을 훨씬 쉽게 작성할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d54be9133193e99a54a3311620e4e293b6619ef3" translate="yes" xml:space="preserve">
          <source>The big difference between the two types of filter is that the</source>
          <target state="translated">두 필터 유형의 큰 차이점은</target>
        </trans-unit>
        <trans-unit id="f4cd1959ad69d1f5686957182fd610eaea766644" translate="yes" xml:space="preserve">
          <source>The big difference between this filter and the previous example is the use of context data in the filter object. The filter object is based on a hash reference, and is used to keep various pieces of context information between calls to the filter function. All but two of the hash fields are used for error reporting. The first of those two, Enabled, is used by the filter to determine whether the debugging code should be given to the Perl parser. The second, InTraceBlock, is true when the filter has encountered a &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; line, but has not yet encountered the following &lt;code&gt;DEBUG_END&lt;/code&gt; line.</source>
          <target state="translated">이 필터와 이전 예제의 큰 차이점은 필터 객체에서 컨텍스트 데이터를 사용한다는 것입니다. 필터 객체는 해시 참조를 기반으로하며 필터 함수 호출간에 다양한 컨텍스트 정보를 유지하는 데 사용됩니다. 두 개의 해시 필드를 제외한 모든 필드가 오류보고에 사용됩니다. 이 두 가지 중 첫 번째 인 Enabled는 필터에서 디버깅 코드를 Perl 파서에 제공해야하는지 여부를 결정하는 데 사용됩니다. 두 번째 InTraceBlock은 필터에 &lt;code&gt;DEBUG_BEGIN&lt;/code&gt; 행이 있지만 아직 다음 &lt;code&gt;DEBUG_END&lt;/code&gt; 행 이없는 경우에 해당 됩니다.</target>
        </trans-unit>
        <trans-unit id="52b096e99c9cb93102a3127548a39ec46a5e6a20" translate="yes" xml:space="preserve">
          <source>The big problem with this approach is that if you don't have control over source code being run in the child process, you can't control what it does with pipe buffering. Thus you can't just open a pipe to &lt;code&gt;cat -v&lt;/code&gt; and continually read and write a line from it.</source>
          <target state="translated">이 방법의 큰 문제점은 하위 프로세스에서 실행되는 소스 코드를 제어 할 수없는 경우 파이프 버퍼링으로 수행하는 작업을 제어 할 수 없다는 것입니다. 따라서 &lt;code&gt;cat -v&lt;/code&gt; 에 파이프를 열고 파이프를 계속 읽고 쓸 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6486f0bee06ebbaca6cfa5b06fc46e3b4ab031bf" translate="yes" xml:space="preserve">
          <source>The biggest difference between Perl</source>
          <target state="translated">펄의 가장 큰 차이점</target>
        </trans-unit>
        <trans-unit id="10223441fe4732f3b2ec434dced2b599c8ca3725" translate="yes" xml:space="preserve">
          <source>The biggest difference is that the first construction would reinstate the initial value of $var, irrespective of how control exits the block: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, etc. It is a little bit more efficient as well.</source>
          <target state="translated">가장 큰 차이점은 첫 번째 구성은 제어가 블록을 나가는 방식 ( &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 등 )에 관계없이 $ var의 초기 값을 복원한다는 것 입니다. 조금 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6d4b9ecf43748dd68211a96fe0ef2db50ead91fe" translate="yes" xml:space="preserve">
          <source>The biggest difference is that the first construction would reinstate the initial value of $var, irrespective of how control exits the block: &lt;code&gt;goto&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;/&lt;code&gt;eval&lt;/code&gt;, etc. It is a little bit more efficient as well.</source>
          <target state="translated">가장 큰 차이점은 첫 번째 구성은 제어가 블록을 어떻게 빠져 나가는 지에 관계없이 $ var의 초기 값을 복원한다는 것입니다 : &lt;code&gt;goto&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;die&lt;/code&gt; / &lt;code&gt;eval&lt;/code&gt; 등. 조금 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="3dfc4089faf0bdc2fe8184811a388d88572e3199" translate="yes" xml:space="preserve">
          <source>The biggest trap of all is forgetting to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; or use the &lt;b&gt;-w&lt;/b&gt; switch; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; and &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The second biggest trap is not making your entire program runnable under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; . The third biggest trap is not reading the list of changes in this version of Perl; see &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta&lt;/a&gt;.</source>
          <target state="translated">가장 큰 함정은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하거나 &lt;b&gt;-w&lt;/b&gt; 스위치를 사용하지 않는 것입니다. &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 및 &lt;a href=&quot;perlrun&quot;&gt;perlrun을&lt;/a&gt; 참조하십시오 . 두 번째로 큰 함정은 전체 프로그램을 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하지 못하게 만드는 것 입니다. 세 번째로 큰 함정은이 버전의 Perl의 변경 목록을 읽지 않는 것입니다. &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perldelta.html&quot;&gt;perldelta를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="38941a9c4cca341e1a51c0f43387b6f303ceb4c0" translate="yes" xml:space="preserve">
          <source>The biggest trap of all is forgetting to &lt;code&gt;use warnings&lt;/code&gt; or use the &lt;b&gt;-w&lt;/b&gt; switch; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; and &lt;a href=&quot;perlrun#-w&quot;&gt;&quot;-w&quot; in perlrun&lt;/a&gt;. The second biggest trap is not making your entire program runnable under &lt;code&gt;use strict&lt;/code&gt;. The third biggest trap is not reading the list of changes in this version of Perl; see &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perldelta&quot;&gt;perldelta&lt;/a&gt;.</source>
          <target state="translated">가장 큰 함정은 &lt;code&gt;use warnings&lt;/code&gt; 를 사용 하거나 &lt;b&gt;-w&lt;/b&gt; 스위치를 사용하는 것을 잊는 것입니다 . &lt;a href=&quot;perlrun#-w&quot;&gt;perlrun의 &lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 및 &quot;-w&quot;를 참조하십시오 . 두 번째로 큰 함정은 전체 프로그램을 &lt;code&gt;use strict&lt;/code&gt; 하에서 실행 가능하게 만드는 것이 아닙니다 . 세 번째로 큰 함정은이 버전의 Perl에서 변경 사항 목록을 읽는 것이 아닙니다. &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perldelta&quot;&gt;perldelta&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="86312f7a492ad492d886bde4c3d6e414b56f1879" translate="yes" xml:space="preserve">
          <source>The binary can be installed into the directory where perl normally resides on your machine with</source>
          <target state="translated">바이너리는 perl이 일반적으로 컴퓨터에있는 디렉토리에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="153cbfaf81971e19f89aca8f0baea516f2171a06" translate="yes" xml:space="preserve">
          <source>The binary number may optionally be prefixed with &quot;0b&quot; or &quot;b&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">&lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 가 설정되어 있지 않으면 이진 번호 앞에 &quot;0b&quot;또는 &quot;b&quot;가 붙을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="260a97cfd0810db3460b5405ac59371428470067" translate="yes" xml:space="preserve">
          <source>The binary number may optionally be prefixed with &lt;code&gt;&quot;0b&quot;&lt;/code&gt; or &lt;code&gt;&quot;b&quot;&lt;/code&gt; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; on entry.</source>
          <target state="translated">입력시 &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; 가 &lt;code&gt;*flags&lt;/code&gt; 에 설정되어 있지 않으면 이진수 는 선택적으로 &lt;code&gt;&quot;0b&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 로시작될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc1bf2dab8b81eb0899313841a54927fbe7de16" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; and the unary operators &lt;code&gt;-&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; will attempt to convert arguments to integers. If both conversions are possible without loss of precision, and the operation can be performed without loss of precision then the integer result is used. Otherwise arguments are converted to floating point format and the floating point result is used. The caching of conversions (as described above) means that the integer conversion does not throw away fractional parts on floating point numbers.</source>
          <target state="translated">이진 연산자 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 단항 연산자 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 과이 &lt;code&gt;--&lt;/code&gt; 정수로 변환 인수를 시도합니다. 정밀도 손실없이 두 변환이 가능하고 정밀도 손실없이 연산을 수행 할 수 있으면 정수 결과가 사용됩니다. 그렇지 않으면 인수가 부동 소수점 형식으로 변환되고 부동 소수점 결과가 사용됩니다. 변환 캐싱 (위 설명 참조)은 정수 변환이 부동 소수점 숫자에서 소수 부분을 버리지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="34b2fabfd461f9205bd6b3948a84a133b83e2dc9" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; and the unary operators &lt;code&gt;-&lt;/code&gt;&lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; will attempt to convert arguments to integers. If both conversions are possible without loss of precision, and the operation can be performed without loss of precision then the integer result is used. Otherwise arguments are converted to floating point format and the floating point result is used. The caching of conversions (as described above) means that the integer conversion does not throw away fractional parts on floating point numbers.</source>
          <target state="translated">진 사업자 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 단항 연산자 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;abs&lt;/code&gt; 과이 &lt;code&gt;--&lt;/code&gt; 정수로 변환 인수를 시도합니다. 정밀도 손실없이 두 변환이 모두 가능하고 정밀도 손실없이 연산을 수행 할 수있는 경우 정수 결과가 사용됩니다. 그렇지 않으면 인수가 부동 소수점 형식으로 변환되고 부동 소수점 결과가 사용됩니다. 변환 캐싱 (위에서 설명한대로)은 정수 변환이 부동 소수점 숫자의 소수 부분을 버리지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8ca5d6db74ad7330ed62ce2b0444cb3f1dc6c897" translate="yes" xml:space="preserve">
          <source>The bind() call can be omitted when specifying the &lt;code&gt;bind&lt;/code&gt; option to new().</source>
          <target state="translated">new ()에 &lt;code&gt;bind&lt;/code&gt; 옵션을 지정할 때 bind () 호출을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bc82db291b733618e76b84e58f74ac2a34e10aa" translate="yes" xml:space="preserve">
          <source>The bit complement operator &lt;code&gt;~&lt;/code&gt; may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that. Similarly for &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt;: you will be operating on the internally-encoded bit patterns of the Unicode characters, not on the code point values, which is very probably not what you want.</source>
          <target state="translated">비트 보수 연산자 &lt;code&gt;~&lt;/code&gt; 는 서 수가 255보다 큰 문자를 포함하는 문자열에 사용될 경우 놀라운 결과를 생성 할 수 있습니다. 이러한 경우 결과는 문자의 내부 인코딩과 일치하지만 다른 것은 아닙니다. 그러지 마 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec()&lt;/a&gt;&lt;/code&gt; 유사하게 : 코드 포인트 값이 아닌 유니 코드 문자의 내부 인코딩 된 비트 패턴에서 작동 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d35eca1d1b5259b3fe2499ebc8287ac008c74743" translate="yes" xml:space="preserve">
          <source>The bit of magic mentioned in the section title occurs when the regexp backtracks in the process of searching for a match. If the regexp backtracks over a code expression and if the variables used within are localized using &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, the changes in the variables produced by the code expression are undone! Thus, if we wanted to count how many times a character got matched inside a group, we could use, e.g.,</source>
          <target state="translated">섹션 제목에 언급 된 약간의 마술은 정규 표현식이 일치하는 과정을 추적 할 때 발생합니다. 정규 표현식이 코드 표현식을 역 추적하고 그 안에 사용 된 변수가 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 을 사용하여 지역화 된 경우 코드 표현식에 의해 생성 된 변수의 변경 사항은 취소됩니다! 따라서 그룹 내에서 캐릭터가 몇 번 일치하는지 계산하려면 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320805179abec0b3990b286801669b6ad7da1dad" translate="yes" xml:space="preserve">
          <source>The bit of magic mentioned in the section title occurs when the regexp backtracks in the process of searching for a match. If the regexp backtracks over a code expression and if the variables used within are localized using &lt;code&gt;local&lt;/code&gt;, the changes in the variables produced by the code expression are undone! Thus, if we wanted to count how many times a character got matched inside a group, we could use,</source>
          <target state="translated">섹션 제목에 언급 된 마법은 정규 표현식이 일치 항목을 검색하는 과정에서 역 추적 할 때 발생합니다. 정규 표현식이 코드 표현식을 역 추적하고 내부에 사용 된 변수가 &lt;code&gt;local&lt;/code&gt; 을 사용하여 지역화 되면 코드 표현식에 의해 생성 된 변수의 변경이 취소됩니다! 따라서 그룹 내에서 캐릭터가 몇 번 일치하는지 세고 싶다면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e1e5bfe9f52e71b4a679c89e1ebe8060bbbb9c" translate="yes" xml:space="preserve">
          <source>The bit string operators, &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; and (starting in v5.22) &lt;code&gt;&amp;amp;. |. ^.  ~.&lt;/code&gt; can operate on characters that don't fit into a byte. However, the current behavior is likely to change. You should not use these operators on strings that are encoded in UTF-8. If you're not sure about the encoding of a string, downgrade it before using any of these operators; you can use &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_downgrade() &lt;/a&gt;.</source>
          <target state="translated">비트 문자열 연산자 &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; 및 (v5.22에서 시작) &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; 바이트에 맞지 않는 문자에서 작동 할 수 있습니다. 그러나 현재 동작은 변경 될 수 있습니다. UTF-8로 인코딩 된 문자열에는 이러한 연산자를 사용하지 않아야합니다. 문자열 인코딩이 확실하지 않은 경우 이러한 연산자를 사용하기 전에 문자열을 다운 그레이드하십시오. &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_downgrade ()&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92ea7982112c700c61ad33b048a75c5e0023256a" translate="yes" xml:space="preserve">
          <source>The bit string operators, &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; and (starting in v5.22) &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; can operate on bit strings encoded in UTF-8, but this can give unexpected results if any of the strings contain code points above 0xFF. Starting in v5.28, it is a fatal error to have such an operand. Otherwise, the operation is performed on a non-UTF-8 copy of the operand. If you're not sure about the encoding of a string, downgrade it before using any of these operators; you can use &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비트 문자열 연산자 &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; 및 (v5.22부터) &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; UTF-8로 인코딩 된 비트 문자열에서 작동 할 수 있지만 문자열에 0xFF 이상의 코드 포인트가 포함 된 경우 예기치 않은 결과가 발생할 수 있습니다. v5.28부터 이러한 피연산자가 있으면 치명적 오류입니다. 그렇지 않으면 피연산자의 UTF-8이 아닌 복사본에서 연산이 수행됩니다. 문자열의 인코딩이 확실하지 않은 경우 이러한 연산자를 사용하기 전에 다운 그레이드하십시오. &lt;a href=&quot;utf8#Utility-functions&quot;&gt; &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798f07dedaf152fa64ff8f36aa832d747a59dede" translate="yes" xml:space="preserve">
          <source>The bitmask</source>
          <target state="translated">비트 마스크</target>
        </trans-unit>
        <trans-unit id="7f65bb852dcddd2ea289cb9a819f8b8574f5d891" translate="yes" xml:space="preserve">
          <source>The bitwise operators such as &amp;amp; ^ | may return different results when operating on string or character data in a Perl program running on an EBCDIC platform than when run on an ASCII platform. Here is an example adapted from the one in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;:</source>
          <target state="translated">&amp;amp; ^ |와 같은 비트 연산자 EBCDIC 플랫폼에서 실행되는 Perl 프로그램의 문자열 또는 문자 데이터에서 작동 할 때 ASCII 플랫폼에서 실행될 때와 다른 결과를 리턴 할 수 있습니다. 다음은 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 의 예제에서 수정 한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="d67719a0018ada51c49577a7919834168925f81a" translate="yes" xml:space="preserve">
          <source>The blacklist() and whitelist() methods extend their internal lists whenever they are called. To reset the blacklist or whitelist, create a new maketext object.</source>
          <target state="translated">blacklist () 및 whitelist () 메서드는 호출 될 때마다 내부 목록을 확장합니다. 블랙리스트 또는 화이트리스트를 재설정하려면 새 maketext 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6f959154b03d16bc90e316f48db81d6452186e11" translate="yes" xml:space="preserve">
          <source>The bless() operator may be used to associate the object a reference points to with a package functioning as an object class. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">bless () 연산자는 참조가 가리키는 객체를 객체 클래스로 기능하는 패키지와 연관시키는 데 사용될 수 있습니다. &lt;a href=&quot;perlobj&quot;&gt;perlobj를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62c6e0f6d8c3596c1d5e718f86c80115574f39a3" translate="yes" xml:space="preserve">
          <source>The blibdirs.ts target is deprecated. Depend on blibdirs instead.</source>
          <target state="translated">blibdirs.ts 대상은 더 이상 사용되지 않습니다. 대신 blibdirs에 의존하십시오.</target>
        </trans-unit>
        <trans-unit id="a0e8f481ec3e68f2eee488cdec2641a9ee4fc58d" translate="yes" xml:space="preserve">
          <source>The body of an object is never examined by an inside-out class, only its reference address is used. This allows for the body of an actual object to be</source>
          <target state="translated">객체의 본문은 인사이드 아웃 클래스에 의해 검사되지 않으며 참조 주소 만 사용됩니다. 이를 통해 실제 객체의 몸체가</target>
        </trans-unit>
        <trans-unit id="5f03e7d3d4bcb5b96cdb3a0cb31e708fb5a607fe" translate="yes" xml:space="preserve">
          <source>The bond between a magical variable and its implementation class. See the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and Camel chapter 14, &amp;ldquo;Tied Variables&amp;rdquo;.</source>
          <target state="translated">마법 변수와 구현 클래스 사이의 결합. 참조 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; Camel 27 장, &quot;기능&quot;및 Camel 14 장, &quot; 타이 변수&quot; 타이 기능을.</target>
        </trans-unit>
        <trans-unit id="6affa2b7104b1da6c00bbf1686781f01c860a19f" translate="yes" xml:space="preserve">
          <source>The bond between a magical variable and its implementation class. See the &lt;code&gt;tie&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and Camel chapter 14, &amp;ldquo;Tied Variables&amp;rdquo;.</source>
          <target state="translated">마법 변수와 그 구현 클래스 사이의 유대. Camel 27 장, &quot;함수&quot;및 Camel 14 장, &quot;동일 변수&quot; 의 &lt;code&gt;tie&lt;/code&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d1559aa0f7fe592165823ac05e1383677536c15" translate="yes" xml:space="preserve">
          <source>The boss thread does relatively little work. While tasks aren't necessarily performed faster than with any other method, it tends to have the best user-response times.</source>
          <target state="translated">보스 스레드는 상대적으로 거의 작동하지 않습니다. 작업이 다른 방법보다 반드시 더 빨리 수행되는 것은 아니지만 최상의 사용자 응답 시간을 갖는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d643dd67e77ce12596be6c04808856092685be2" translate="yes" xml:space="preserve">
          <source>The boss/worker model usually has one</source>
          <target state="translated">보스 / 작업자 모델에는 일반적으로</target>
        </trans-unit>
        <trans-unit id="7cb25d97420dee45b6ff8e8d1d3ce98bc5f8cf9f" translate="yes" xml:space="preserve">
          <source>The bottom line is that Perl has always practiced &quot;Character Semantics&quot;, but with the advent of Unicode, that is now different than &quot;Byte Semantics&quot;.</source>
          <target state="translated">결론적으로 Perl은 항상 &quot;문자 의미론&quot;을 연습했지만, 유니 코드의 출현으로 이제는 &quot;바이트 의미론&quot;과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b78f42ecd2e198ccb02cbf24e0cb3e2f279a41cb" translate="yes" xml:space="preserve">
          <source>The bottom line is that using &lt;code&gt;/o&lt;/code&gt; is almost never a good idea.</source>
          <target state="translated">&lt;code&gt;/o&lt;/code&gt; 으로 / o 를 사용 하는 것은 결코 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d9acf6e820cb60c3e92eccf3aa1b7d56933e4bb1" translate="yes" xml:space="preserve">
          <source>The bracketing construct &lt;code&gt;( ... )&lt;/code&gt; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &lt;code&gt;\g1&lt;/code&gt; (or &lt;code&gt;\g{1}&lt;/code&gt; ) for the first, &lt;code&gt;\g2&lt;/code&gt; (or &lt;code&gt;\g{2}&lt;/code&gt; ) for the second, and so on. This is called a</source>
          <target state="translated">브라케팅 구성 &lt;code&gt;( ... )&lt;/code&gt; 은 캡처 그룹 (캡처 버퍼라고도 함 )을 작성합니다. 나중에 동일한 패턴 내에서 그룹의 현재 내용을 참조하려면 첫 번째 는 &lt;code&gt;\g1&lt;/code&gt; (또는 &lt;code&gt;\g{1}&lt;/code&gt; )을 사용하고 두 번째는 &lt;code&gt;\g2&lt;/code&gt; (또는 &lt;code&gt;\g{2}&lt;/code&gt; )을 사용하십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="ca8e05cb686ed2cb963230f7ff966be7f26d3402" translate="yes" xml:space="preserve">
          <source>The branches that begin with &quot;origin&quot; correspond to the &quot;git remote&quot; that you cloned from (which is named &quot;origin&quot;). Each branch on the remote will be exactly tracked by these branches. You should NEVER do work on these remote tracking branches. You only ever do work in a local branch. Local branches can be configured to automerge (on pull) from a designated remote tracking branch. This is the case with the default branch &lt;code&gt;blead&lt;/code&gt; which will be configured to merge from the remote tracking branch &lt;code&gt;origin/blead&lt;/code&gt;.</source>
          <target state="translated">&quot;origin&quot;으로 시작하는 분기는 복제 한 &quot;git remote&quot;( &quot;origin&quot;이라고 함)에 해당합니다. 원격지의 각 분기는 이러한 분기에 의해 정확하게 추적됩니다. 이러한 원격 추적 분기에 대해 작업을 수행해서는 안됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 당신은 지역 지점에서만 일합니다. 지정된 원격 추적 분기에서 자동 병합 (풀시)하도록 로컬 분기를 구성 할 수 있습니다. 원격 추적 분기 &lt;code&gt;origin/blead&lt;/code&gt; 에서 병합하도록 구성되는 기본 분기 &lt;code&gt;blead&lt;/code&gt; 의 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="e36070a31e90d55267b22c4c53ba4bb76bc4e98b" translate="yes" xml:space="preserve">
          <source>The btree format allows arbitrary key/value pairs to be stored in a sorted, balanced binary tree.</source>
          <target state="translated">btree 형식을 사용하면 임의의 키 / 값 쌍을 정렬 된 균형 이진 트리에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d23a8ab70ee632140bebef4fc4a9cc18111b1ba" translate="yes" xml:space="preserve">
          <source>The bucket usage information provided by &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(%hash)&lt;/a&gt;&lt;/code&gt; 제공 한 버킷 사용 정보를 사용할 수 없습니다. 이것이 의미하는 것은 부울 컨텍스트에서 % tied_hash를 사용하면 제대로 작동하지 않는다는 것입니다 (현재 해시가 비어 있는지 또는 해시 요소에 관계없이 항상 false를 테스트 함).</target>
        </trans-unit>
        <trans-unit id="f906901c8089ec2511c9cdd8f08022908a2f9d72" translate="yes" xml:space="preserve">
          <source>The buffer being looked at is based on reading data, and the data received so far stopped in the middle of a character, so that the next read will read the remainder of this character. (It is up to the caller to deal with the split bytes somehow.)</source>
          <target state="translated">보고있는 버퍼는 데이터 읽기를 기반으로하며 지금까지 수신 된 데이터는 문자 중간에서 중지되어 다음 읽기가이 문자의 나머지 부분을 읽습니다. (분할 된 바이트를 어떻게 든 처리하는 것은 호출자에게 달려 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ca05fef836743ccb209a85580910e15958fde72d" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds data written to it but not sent to next layer.</source>
          <target state="translated">이 계층의 버퍼에는 현재 데이터가 기록되었지만 다음 계층으로 전송되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7906bb96b8244bc39b3b8a2c3c66a3c0af5824fe" translate="yes" xml:space="preserve">
          <source>The buffer for this layer currently holds unconsumed data read from layer below.</source>
          <target state="translated">이 계층의 버퍼는 현재 아래 계층에서 읽은 소비되지 않은 데이터를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6ea453ad94b47d04a0aaf4ba8a7c5a8d66aac757" translate="yes" xml:space="preserve">
          <source>The buffer for this layer should be filled (for read) from layer below. When you &quot;subclass&quot; PerlIOBuf layer, you want to use its</source>
          <target state="translated">이 레이어의 버퍼는 아래 레이어에서 채워야합니다 (읽기 위해). PerlIOBuf 레이어를 &quot;서브 클래스&quot;할 때</target>
        </trans-unit>
        <trans-unit id="0b0da711f6da8dbe92866cc34757189eaf594fa5" translate="yes" xml:space="preserve">
          <source>The buffer parameters can either be a scalar or a scalar reference.</source>
          <target state="translated">버퍼 매개 변수는 스칼라 또는 스칼라 참조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3180fcf8985754e2c180a612db1e7626b0444c64" translate="yes" xml:space="preserve">
          <source>The buffer size parameter is ignored. If either argument to &lt;code&gt;copy&lt;/code&gt; is a handle to an opened file, then data is copied using Perl operators, and no effort is made to preserve file attributes or record structure.</source>
          <target state="translated">버퍼 크기 매개 변수는 무시됩니다. &lt;code&gt;copy&lt;/code&gt; 할 인수가 열린 파일에 대한 핸들 인 경우 Perl 연산자를 사용하여 데이터가 복사되며 파일 속성 또는 레코드 구조를 보존하기 위해 노력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1be0b2e149c4efd88fafeca46ff94f066b87423d" translate="yes" xml:space="preserve">
          <source>The build phase is when the distribution's source code is compiled (if necessary) and otherwise made ready for installation.</source>
          <target state="translated">빌드 단계는 배포판의 소스 코드가 컴파일되고 (필요한 경우) 설치 준비가 될 때입니다.</target>
        </trans-unit>
        <trans-unit id="3a3e5d3d24ac3da5ee8782f3b635bd002510477d" translate="yes" xml:space="preserve">
          <source>The build procedure is completely standard:</source>
          <target state="translated">빌드 절차는 완전히 표준입니다 :</target>
        </trans-unit>
        <trans-unit id="eb86001bb0f7c51ab8f75bc125c6599630a9618e" translate="yes" xml:space="preserve">
          <source>The build process is dependent on the location of the NetWare SDK. Once the Tools &amp;amp; SDK are installed, the build environment has to be setup. The following batch files setup the environment.</source>
          <target state="translated">빌드 프로세스는 NetWare SDK의 위치에 따라 다릅니다. 도구 및 SDK가 설치되면 빌드 환경을 설정해야합니다. 다음 배치 파일은 환경을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="66dc024a88d2f72023e3d27090cc749788a83502" translate="yes" xml:space="preserve">
          <source>The build requires CodeWarrior compiler and linker. In addition, the &quot;NetWare SDK&quot;, &quot;NLM &amp;amp; NetWare Libraries for C&quot; and &quot;NetWare Server Protocol Libraries for C&quot;, all available at &lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&lt;/a&gt;, are required. Microsoft Visual C++ version 4.2 or later is also required.</source>
          <target state="translated">빌드에는 CodeWarrior 컴파일러 및 링커가 필요합니다. 또한 &quot;NetWare SDK&quot;, &quot;C 용 NLM 및 NetWare 라이브러리&quot;및 &quot;C 용 NetWare 서버 프로토콜 라이브러리&quot;는 모두 &lt;a href=&quot;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&quot;&gt;http://developer.novell.com/wiki/index.php/Category:Novell_Developer_Kit&lt;/a&gt; 에서 구할 수 있습니다 . 필수입니다. Microsoft Visual C ++ 버전 4.2 이상도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2259dbbc3b96c959be9cc8cbfc89bd2fed26000d" translate="yes" xml:space="preserve">
          <source>The build scripts assume the 'absolute style' SDK installs under C:, the 'subst style' will not work.</source>
          <target state="translated">빌드 스크립트는 '절대 스타일'SDK가 C : 아래에 설치되어 있다고 가정하고 '서브 스타일'이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c1866a50a6b5aca129fc8a6f5bfc9c74d8445fc" translate="yes" xml:space="preserve">
          <source>The build system that Perl uses is called metaconfig. This system is maintained separately from the Perl core, and knows about the platform-specific Configure-like scripts, as well as</source>
          <target state="translated">Perl이 사용하는 빌드 시스템을 metaconfig라고합니다. 이 시스템은 Perl 코어와 별도로 유지 관리되며 플랫폼 별 Configure 유사 스크립트뿐만 아니라</target>
        </trans-unit>
        <trans-unit id="2ba6778f7060ad4df8f24bbc1bdc4f90be4ddf10" translate="yes" xml:space="preserve">
          <source>The build system that Perl uses is called metaconfig. This system is maintained separately from the Perl core.</source>
          <target state="translated">Perl이 사용하는 빌드 시스템을 metaconfig라고합니다. 이 시스템은 Perl 코어와 별도로 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="942228e32ca9b0927fd55428e4055983f76b4ec4" translate="yes" xml:space="preserve">
          <source>The built-ins &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements. (You can't override the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; syntax, though).</source>
          <target state="translated">내장 된 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 도 무시할 수 있지만 특별한 마법으로 인해 원래 구문이 유지되므로 대체를 위해 프로토 타입을 정의 할 필요가 없습니다. ( 하지만 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; 구문을 무시할 수는 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="bcb6cfab09e5bc86e4c8980fb6b4cf2b8530694c" translate="yes" xml:space="preserve">
          <source>The built-ins &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;glob&lt;/code&gt; can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements. (You can't override the &lt;code&gt;do BLOCK&lt;/code&gt; syntax, though).</source>
          <target state="translated">내장 된 &lt;code&gt;do&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;glob&lt;/code&gt; 도 재정의 할 수 있지만 특별한 마법으로 인해 원래 구문이 유지되며 대체를위한 프로토 타입을 정의 할 필요가 없습니다. ( 하지만 &lt;code&gt;do BLOCK&lt;/code&gt; 구문을 재정의 할 수는 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="296da44de5630b90165936266a71322d333ad173" translate="yes" xml:space="preserve">
          <source>The bulk of the &lt;code&gt;B&lt;/code&gt; module is the methods for accessing fields of these structures.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 모듈 의 대부분은 이러한 구조의 필드에 액세스하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8b0e07205f847f3c71cfbfff3ef8429008605c63" translate="yes" xml:space="preserve">
          <source>The bulk of the work is done by the &lt;code&gt;check_num()&lt;/code&gt; subroutine, which takes a reference to its input queue and a prime number that it's responsible for. After pulling in the input queue and the prime that the subroutine is checking (line 11), we create a new queue (line 13) and reserve a scalar for the thread that we're likely to create later (line 12).</source>
          <target state="translated">대부분의 작업은 &lt;code&gt;check_num()&lt;/code&gt; 서브 루틴에 의해 수행됩니다. check_num () 서브 루틴은 입력 큐와 담당하는 소수를 참조합니다. 입력 큐와 서브 루틴이 점검하고있는 프라임 (11 행)을 가져온 후, 우리는 새로운 큐 (13 행)를 작성하고 나중에 생성 할 스레드에 대한 스칼라를 예약합니다 (12 행).</target>
        </trans-unit>
        <trans-unit id="791442532861b4bafb692d53705783ee9bec0932" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 빌드 된 플랫폼의 바이트 순서는 &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; 를 통해 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a22ccaf7c6bd804cab616f223b89fb4c998d9e8" translate="yes" xml:space="preserve">
          <source>The byteorder on the platform where Perl was built is also available via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Perl이 빌드 된 플랫폼의 바이트 순서는 &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; 를 통해 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95b43b81c5e8935337a225eeb872942eb25c3b63" translate="yes" xml:space="preserve">
          <source>The cache itself consumes about 310 bytes per cached record, so if your file has many short records, you may want to decrease the cache memory limit, or else the cache overhead may exceed the size of the cached data.</source>
          <target state="translated">캐시 자체는 캐시 된 레코드 당 약 310 바이트를 소비하므로 파일에 짧은 레코드가 많은 경우 캐시 메모리 제한을 줄이거 나 캐시 오버 헤드가 캐시 된 데이터의 크기를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c278db5f1039a1e6a3c5cfe42f53a238c1ae1813" translate="yes" xml:space="preserve">
          <source>The cached value of &lt;a href=&quot;IO::Socket#peername&quot;&gt;&quot;peername&quot; in IO::Socket&lt;/a&gt; is updated with the result of &lt;code&gt;recv&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket#peername&quot;&gt;IO :: Socket&lt;/a&gt; 의 캐시 된 &quot;peername&quot; 값 이 &lt;code&gt;recv&lt;/code&gt; 의 결과로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="64eab8d82090d9e1801adf3ce396bf3e93f4b8ee" translate="yes" xml:space="preserve">
          <source>The call graph looks like this:</source>
          <target state="translated">호출 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28ea28f282558b210d4a57daeeed34d90ebc6017" translate="yes" xml:space="preserve">
          <source>The call is implemented in terms of either Perl's or your system's native &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread(3)&lt;/a&gt; library function, via the &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers applied to the handle. To get a true &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt; system call, see &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;sysread&lt;/a&gt;.</source>
          <target state="translated">호출은 핸들에 적용된 &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; 계층을 통해 Perl 또는 시스템의 기본 &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread (3)&lt;/a&gt; 라이브러리 함수 측면에서 구현됩니다 . 진정한 &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read (2)&lt;/a&gt; 시스템 호출 을 얻으려면 &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;sysread를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="438b1deafb199f6d78cd53708e2c5819899363df" translate="yes" xml:space="preserve">
          <source>The call is implemented in terms of either Perl's or your system's native fread(3) library function. To get a true read(2) system call, see &lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;sysread&lt;/a&gt;.</source>
          <target state="translated">호출은 Perl 또는 시스템의 기본 fread (3) 라이브러리 함수 측면에서 구현됩니다. 진정한 read (2) 시스템 호출을 얻으려면 &lt;a href=&quot;#sysread-FILEHANDLE%2cSCALAR%2cLENGTH%2cOFFSET&quot;&gt;sysread를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dea5bcbc0f1552fc56e337d8752664ae2f4f6f3" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; creates a new filehandle &lt;code&gt;$inf&lt;/code&gt; that can be used to read from the parent filehandle &lt;code&gt;$fh&lt;/code&gt;, uncompressing it as it goes. The use of the &lt;code&gt;InputLength&lt;/code&gt; option will guarantee that</source>
          <target state="translated">&lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; 대한 호출 은 부모 파일 핸들 &lt;code&gt;$fh&lt;/code&gt; 에서 읽는 데 사용할 수 있는 새 파일 핸들 &lt;code&gt;$inf&lt;/code&gt; 를 생성하여 압축을 해제합니다. &lt;code&gt;InputLength&lt;/code&gt; 옵션을 사용 하면</target>
        </trans-unit>
        <trans-unit id="743d372bad1a8cad2381aca07cbb441a9da8196f" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;XSLoader::load()&lt;/code&gt; (or &lt;code&gt;bootstrap()&lt;/code&gt; ) calls the module's bootstrap code. For modules build by</source>
          <target state="translated">를 호출 &lt;code&gt;XSLoader::load()&lt;/code&gt; (또는 &lt;code&gt;bootstrap()&lt;/code&gt; ) 모듈의 부트 스트랩 코드를 호출합니다. 모듈 별</target>
        </trans-unit>
        <trans-unit id="77d246877b0bad5cdb649d39d041409ba15b1a8d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;XSLoader::load()&lt;/code&gt; (or &lt;code&gt;bootstrap()&lt;/code&gt;) calls the module's bootstrap code. For modules build by</source>
          <target state="translated">를 호출 &lt;code&gt;XSLoader::load()&lt;/code&gt; (또는 &lt;code&gt;bootstrap()&lt;/code&gt; ) 모듈의 부트 스트랩 코드를 호출합니다. 모듈 빌드의 경우</target>
        </trans-unit>
        <trans-unit id="3ec6acbf7a32681ee91fb2a933c9fbfbb9c3da0d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;from_to()&lt;/code&gt; changes the bytes in &lt;code&gt;$data&lt;/code&gt; , but nothing material about the nature of the string has changed as far as Perl is concerned. Both before and after the call, the string &lt;code&gt;$data&lt;/code&gt; contains just a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the string remains as &quot;system-native 8-bit bytes&quot;.</source>
          <target state="translated">&lt;code&gt;from_to()&lt;/code&gt; 호출하면 &lt;code&gt;$data&lt;/code&gt; 의 바이트 가 변경되지만 Perl과 관련하여 문자열의 특성에 대한 자료는 변경되지 않았습니다. 호출 전후에 문자열 &lt;code&gt;$data&lt;/code&gt; 에는 단지 8 비트 바이트가 들어 있습니다. Perl과 관련하여 문자열 인코딩은 &quot;시스템 기본 8 비트 바이트&quot;로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3d37ade85eca4b57a3f79aae9ff9fc00a179db7d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;from_to()&lt;/code&gt; changes the bytes in &lt;code&gt;$data&lt;/code&gt;, but nothing material about the nature of the string has changed as far as Perl is concerned. Both before and after the call, the string &lt;code&gt;$data&lt;/code&gt; contains just a bunch of 8-bit bytes. As far as Perl is concerned, the encoding of the string remains as &quot;system-native 8-bit bytes&quot;.</source>
          <target state="translated">&lt;code&gt;from_to()&lt;/code&gt; 호출 은 &lt;code&gt;$data&lt;/code&gt; 의 바이트를 변경 하지만 Perl에 관한 한 문자열의 특성에 대한 자료는 변경되지 않았습니다. 호출 전후에 &lt;code&gt;$data&lt;/code&gt; 문자열 에는 8 비트 바이트 만 포함됩니다. Perl에 관한 한 문자열의 인코딩은 &quot;시스템 네이티브 8 비트 바이트&quot;로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ad70e5f54776fc0924c4e470d4ee9b439b4f2953" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;warnings::register&lt;/code&gt; will create a new warnings category called &quot;MyMod::Abc&quot;, i.e. the new category name matches the current package name. The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function in the module will display a warning message if it gets given a relative path as a parameter. This warnings will only be displayed if the code that uses &lt;code&gt;MyMod::Abc&lt;/code&gt; has actually enabled them with the &lt;code&gt;warnings&lt;/code&gt; pragma like below.</source>
          <target state="translated">&lt;code&gt;warnings::register&lt;/code&gt; 호출하면 &quot;MyMod :: Abc&quot;라는 새 경고 범주가 작성됩니다. 즉, 새 범주 이름이 현재 패키지 이름과 일치합니다. 모듈 의 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 기능은 상대 경로가 매개 변수로 제공되면 경고 메시지를 표시합니다. 이 경고는 &lt;code&gt;MyMod::Abc&lt;/code&gt; 를 사용하는 코드에서 실제로 다음과 같은 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 활성화 한 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="552b61142422757f12c0c7b1b8b0eca87f13a4a7" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;warnings::register&lt;/code&gt; will create a new warnings category called &quot;MyMod::Abc&quot;, i.e. the new category name matches the current package name. The &lt;code&gt;open&lt;/code&gt; function in the module will display a warning message if it gets given a relative path as a parameter. This warnings will only be displayed if the code that uses &lt;code&gt;MyMod::Abc&lt;/code&gt; has actually enabled them with the &lt;code&gt;warnings&lt;/code&gt; pragma like below.</source>
          <target state="translated">&lt;code&gt;warnings::register&lt;/code&gt; 호출하면 &quot;MyMod :: Abc&quot;라는 새 경고 범주가 생성됩니다. 즉, 새 범주 이름이 현재 패키지 이름과 일치합니다. 모듈 의 &lt;code&gt;open&lt;/code&gt; 함수는 매개 변수로 상대 경로가 주어지면 경고 메시지를 표시합니다. 이 경고는 &lt;code&gt;MyMod::Abc&lt;/code&gt; 를 사용하는 코드 가 실제로 아래와 같은 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 활성화 한 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="de39aad93d96a8313ed651448e2dc806dfea3c70" translate="yes" xml:space="preserve">
          <source>The call to GetOptions() parses the command line arguments that are present in &lt;code&gt;@ARGV&lt;/code&gt; and sets the option variable to the value &lt;code&gt;1&lt;/code&gt; if the option did occur on the command line. Otherwise, the option variable is not touched. Setting the option value to true is often called</source>
          <target state="translated">GetOptions ()를 호출하면 &lt;code&gt;@ARGV&lt;/code&gt; 에 있는 명령 줄 인수를 구문 분석 하고 옵션이 명령 줄에서 발생한 경우 옵션 변수를 값 &lt;code&gt;1&lt;/code&gt; 로 설정합니다. 그렇지 않으면 옵션 변수를 건드리지 않습니다. 옵션 값을 true로 설정하는 것을 종종 호출합니다</target>
        </trans-unit>
        <trans-unit id="171eeffe94ffcbbb77d480c5aae1700315d244fd" translate="yes" xml:space="preserve">
          <source>The call to the program that is able to compile perlmain.c. Defaults to $(CC).</source>
          <target state="translated">perlmain.c를 컴파일 할 수있는 프로그램 호출 기본값은 $ (CC)입니다.</target>
        </trans-unit>
        <trans-unit id="acb2e8bffbae50387da55c62d3573564cf939bc2" translate="yes" xml:space="preserve">
          <source>The call to this method is currently made</source>
          <target state="translated">이 메소드에 대한 호출은 현재 이루어집니다</target>
        </trans-unit>
        <trans-unit id="af59be20c7eb663137f8b78548e36aec5ac0b8fe" translate="yes" xml:space="preserve">
          <source>The callback methods &lt;code&gt;start_code&lt;/code&gt; and &lt;code&gt;end_code&lt;/code&gt; emits the &lt;code&gt;code&lt;/code&gt; tags before and after &lt;code&gt;handle_code&lt;/code&gt; is invoked, so you might want to override these together with &lt;code&gt;handle_code&lt;/code&gt; if this wrapping isn't suitable.</source>
          <target state="translated">&lt;code&gt;handle_code&lt;/code&gt; 가 호출 되기 전후에 콜백 메소드 &lt;code&gt;start_code&lt;/code&gt; 및 &lt;code&gt;end_code&lt;/code&gt; 가 &lt;code&gt;code&lt;/code&gt; 태그를 생성 하므로이 줄 바꿈이 적합하지 않은 경우 &lt;code&gt;handle_code&lt;/code&gt; 와 함께이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e4b93d3f2cc24bc6cb3f704f926b3838cfb6c18" translate="yes" xml:space="preserve">
          <source>The callback routine's return value is not used for anything.</source>
          <target state="translated">콜백 루틴의 반환 값은 아무것도 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df4f95aac52b872cdb00cff71137de388b659b49" translate="yes" xml:space="preserve">
          <source>The callbacks are called for each opcode visited by Concise, in the same order as they are added. Each subroutine is passed five parameters.</source>
          <target state="translated">Concise가 방문한 각 opcode에 대해 콜백이 추가 된 순서대로 호출됩니다. 각 서브 루틴에는 5 개의 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cf3ef404c2544a6e1a747fcdf0563fa6c44b7664" translate="yes" xml:space="preserve">
          <source>The caller is responsible for incrementing the reference count of the array returned if it wants to keep the structure. Hence, if you have created a temporary value that you keep no pointer to, &lt;code&gt;sv_2mortal()&lt;/code&gt; to ensure that it is disposed of correctly. If you have cached your return value, then return a pointer to it without changing the reference count.</source>
          <target state="translated">호출자는 구조를 유지하려는 경우 반환 된 배열의 참조 횟수를 증가시킵니다. 따라서 포인터를 유지하지 않는 임시 값을 만든 경우 &lt;code&gt;sv_2mortal()&lt;/code&gt; 이 올바르게 처리되도록합니다. 반환 값을 캐시 한 경우 참조 카운트를 변경하지 않고 포인터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="671d96a33310c49a05e0c1c4b0cfeb6f76489798" translate="yes" xml:space="preserve">
          <source>The caller, of course, is responsible for freeing any returned AV.</source>
          <target state="translated">물론 호출자는 반환 된 AV를 해제 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd57cc43591eee37d999f667a57775d31d798dc" translate="yes" xml:space="preserve">
          <source>The caller, of course, is responsible for freeing any returned HV.</source>
          <target state="translated">물론 호출자는 반환 된 HV를 해제 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="261ce3b0bcf399d133cb40e0b62c874dd44f485a" translate="yes" xml:space="preserve">
          <source>The calling context of the function (scalar or list context) is propagated to the normalizer. This means that if the memoized function will treat its arguments differently in list context than it would in scalar context, you can have the normalizer function select its behavior based on the results of &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;. Even if called in a list context, a normalizer should still return a single string.</source>
          <target state="translated">함수의 호출 컨텍스트 (스칼라 또는 목록 컨텍스트)가 노멀 라이저로 전파됩니다. 즉, 메모 된 함수가 스칼라 컨텍스트 &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt; 달리 목록 컨텍스트에서 인수를 다르게 처리하는 경우 노멀 라이저 함수가 wantarray 의 결과에 따라 동작을 선택하도록 할 수 있습니다. . 목록 컨텍스트에서 호출 되더라도 노멀 라이저는 여전히 단일 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d070e240146e387bd5e6b205e3e45aa0621ebacc" translate="yes" xml:space="preserve">
          <source>The calling context of the function (scalar or list context) is propagated to the normalizer. This means that if the memoized function will treat its arguments differently in list context than it would in scalar context, you can have the normalizer function select its behavior based on the results of &lt;code&gt;wantarray&lt;/code&gt;. Even if called in a list context, a normalizer should still return a single string.</source>
          <target state="translated">함수의 호출 컨텍스트 (스칼라 또는 목록 컨텍스트)는 노멀 라이저로 전파됩니다. 즉, &lt;code&gt;wantarray&lt;/code&gt; 화 된 함수가 스칼라 컨텍스트와 목록 컨텍스트에서 인수를 다르게 처리하는 경우, 노멀 라이저 함수가 wantarray 의 결과에 따라 동작을 선택하도록 할 수 있습니다 . 목록 컨텍스트에서 호출 되더라도 노멀 라이저는 여전히 단일 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bf2965af27484a7764a15d3bbb805341a4c18b1" translate="yes" xml:space="preserve">
          <source>The canonical list of operator names is the contents of the array PL_op_name defined and initialised in file</source>
          <target state="translated">정식 연산자 이름 목록은 파일에서 정의되고 초기화 된 PL_op_name 배열의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="c754480a0b53533e23d99a04ff3b99e5ce4e8f9f" translate="yes" xml:space="preserve">
          <source>The canonical name for the host if the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag was provided, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. This field will only be present on the first returned address.</source>
          <target state="translated">&lt;code&gt;AI_CANONNAME&lt;/code&gt; 플래그가 제공된 경우 호스트의 정식 이름 이거나 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다. 이 필드는 첫 번째 반송 주소에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0d0a9b948bc1ff787f892920e44c62f1399240e8" translate="yes" xml:space="preserve">
          <source>The canonical name for the host if the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag was provided, or &lt;code&gt;undef&lt;/code&gt; otherwise. This field will only be present on the first returned address.</source>
          <target state="translated">&lt;code&gt;AI_CANONNAME&lt;/code&gt; 플래그가 제공된 경우 호스트의 표준 이름 , 그렇지 않으면 &lt;code&gt;undef&lt;/code&gt; . 이 필드는 첫 번째 반환 된 주소에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ddb3e29fbb2261125aa3969a5b44d4db9de4c6e" translate="yes" xml:space="preserve">
          <source>The canonical name of a delegate distribution to install instead. Useful when a new version, although it tests OK itself, breaks something else or a developer release or a fork is already uploaded that is better than the last released version.</source>
          <target state="translated">대신 설치할 대리자 배포의 정식 이름입니다. 새 버전은 확인 자체를 테스트하지만 다른 것을 깨뜨 리거나 개발자 릴리스 또는 포크가 이미 업로드되어 마지막 릴리스 버전보다 나은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69da2adf0aadd37547ac813fb993aa6ad1179ac5" translate="yes" xml:space="preserve">
          <source>The canonical name of a given encoding does not necessarily agree with IANA Character Set Registry, commonly seen as &lt;code&gt;Content-Type:
text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt;. For most cases, the canonical name works, but sometimes it does not, most notably with &quot;utf-8-strict&quot;.</source>
          <target state="translated">지정된 인코딩의 정식 이름이 일반적으로 &lt;code&gt;Content-Type: text/plain; charset=&lt;i&gt;WHATEVER&lt;/i&gt;&lt;/code&gt; . 대부분의 경우, 표준 이름은 작동하지만 때로는 &quot;utf-8-strict&quot;에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7959d4667d41c3277e70505dbf41353d2303db33" translate="yes" xml:space="preserve">
          <source>The capability whose string is to be output.</source>
          <target state="translated">문자열을 출력 할 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a744fed76bc528e01936c6092d667062609b77e5" translate="yes" xml:space="preserve">
          <source>The caret allows for simpler stringification of compiled regular expressions. These look like</source>
          <target state="translated">캐럿을 사용하면 컴파일 된 정규식을보다 간단하게 문자열화할 수 있습니다. 이것들은</target>
        </trans-unit>
        <trans-unit id="58a0fb0132766b545bb2895a2475db60984127a8" translate="yes" xml:space="preserve">
          <source>The caret tells Perl that this cluster doesn't inherit the flags of any surrounding pattern, but uses the system defaults (&lt;code&gt;d-imnsx&lt;/code&gt;), modified by any flags specified.</source>
          <target state="translated">캐럿은이 클러스터가 주변 패턴의 플래그를 상속하지 않지만 지정된 플래그에 의해 수정 된 시스템 기본값 ( &lt;code&gt;d-imnsx&lt;/code&gt; )을 사용한다고 Perl에 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="743958808118b71ad904b9a5f8eed52c69df8dc0" translate="yes" xml:space="preserve">
          <source>The caret tells Perl that this cluster doesn't inherit the flags of any surrounding pattern, but uses the system defaults (&lt;code&gt;d-imsx&lt;/code&gt; ), modified by any flags specified.</source>
          <target state="translated">캐럿은 Perl에게이 클러스터가 주변 패턴의 플래그를 상속하지 않지만 지정된 플래그로 수정 된 시스템 기본값 ( &lt;code&gt;d-imsx&lt;/code&gt; )을 사용한다고 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d4cdf247822c1c118e5e2a91cdbbd856905f935f" translate="yes" xml:space="preserve">
          <source>The case used for capitals that are followed by lowercase characters instead of by more capitals. Sometimes called sentence case or headline case. English doesn&amp;rsquo;t use Unicode titlecase, but casing rules for English titles are more complicated than simply capitalizing each word&amp;rsquo;s first character.</source>
          <target state="translated">더 많은 대문자 대신 소문자 뒤에 대문자가 사용됩니다. 때때로 문장 또는 헤드 라인 사건이라고합니다. 영어는 유니 코드 제목을 사용하지 않지만 영어 제목의 대소 문자 구분 규칙은 단순히 각 단어의 첫 문자를 대문자로 표기하는 것보다 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d711d105fb7ff9ba5105330930cd96c20b047fd3" translate="yes" xml:space="preserve">
          <source>The casemap used in Unicode when comparing or matching without regard to case. Comparing lower-, title-, or uppercase are all unreliable due to Unicode&amp;rsquo;s complex, one-to-many case mappings. Foldcase is a &lt;b&gt;lowercase&lt;/b&gt; variant (using a partially decomposed &lt;b&gt;normalization&lt;/b&gt; form for certain codepoints) created specifically to resolve this.</source>
          <target state="translated">대소 문자와 상관없이 비교 또는 일치 할 때 유니 코드로 사용되는 사례 맵입니다. 유니 코드의 복잡한 일대 다 사례 매핑으로 인해 소문자, 제목 또는 대문자를 모두 비교할 수 없습니다. Foldcase는 이를 해결하기 위해 특별히 작성된 &lt;b&gt;소문자&lt;/b&gt; 변형입니다 ( 특정 코드 포인트에 대해 부분적으로 분해 &lt;b&gt;된 정규화&lt;/b&gt; 양식 사용 ).</target>
        </trans-unit>
        <trans-unit id="f16ecea32ddc45aef48d30c6428e765b0124d50c" translate="yes" xml:space="preserve">
          <source>The cases when the shell is used are:</source>
          <target state="translated">쉘을 사용하는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c680dd1b7f73705ea5a617eb796674dddd3290c8" translate="yes" xml:space="preserve">
          <source>The cases where whitespace must be used are when the quoting character is a word character (meaning it matches &lt;code&gt;/\w/&lt;/code&gt;):</source>
          <target state="translated">공백을 사용해야하는 경우는 인용 문자가 단어 문자 ( &lt;code&gt;/\w/&lt;/code&gt; 와 일치 함을 의미 ) 일 때입니다.</target>
        </trans-unit>
        <trans-unit id="c4f70f75c345302363bdfc512065cdf97aa1e52e" translate="yes" xml:space="preserve">
          <source>The casing of the character name is irrelevant when used in &lt;code&gt;\p{}&lt;/code&gt;, as are most spaces, underscores and hyphens. (A few outlier characters cause problems with ignoring all of them always. The details (which you can look up when you get more proficient, and if ever needed) are in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;).</source>
          <target state="translated">대부분의 공백, 밑줄 및 하이픈과 마찬가지로 &lt;code&gt;\p{}&lt;/code&gt; 에서 사용할 때 문자 이름의 대 / 소문자는 관련이 없습니다 . (몇몇 특이 치 문자는 항상 모든 것을 무시하는 데 문제를 일으 킵니다. 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44&lt;/a&gt; 에 있습니다. -24.html # UAX44-LM2 ).</target>
        </trans-unit>
        <trans-unit id="90158421e0d058f44be7171e42f898369c12eafb" translate="yes" xml:space="preserve">
          <source>The categories are currently:</source>
          <target state="translated">카테고리는 현재 :</target>
        </trans-unit>
        <trans-unit id="998a96285bef3fbf35e88e13ee25ef0e94c840c0" translate="yes" xml:space="preserve">
          <source>The character following &lt;code&gt;\c&lt;/code&gt; is mapped to some other character as shown in the table:</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt; 다음에 오는 문자는 표에 표시된 것처럼 다른 문자에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0182edc494649671b24bec81ea32f4948632cbbf" translate="yes" xml:space="preserve">
          <source>The character set /adul flags cancel each other out. So, in this example,</source>
          <target state="translated">문자 세트 / adul 플래그는 서로를 취소합니다. 이 예에서는</target>
        </trans-unit>
        <trans-unit id="918f2c2a366ec496a31bbfb3ab7debba8ce1e85d" translate="yes" xml:space="preserve">
          <source>The character set &lt;code&gt;/adul&lt;/code&gt; flags cancel each other out. So, in this example,</source>
          <target state="translated">문자 세트 &lt;code&gt;/adul&lt;/code&gt; 플래그는 서로를 취소합니다. 따라서이 예에서는</target>
        </trans-unit>
        <trans-unit id="9d4fb2a2ad59e5fb5f2e1ac776d2184744805bf9" translate="yes" xml:space="preserve">
          <source>The character set rules are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; . The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. If present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt;, and by the internal macros &lt;code&gt;is_utf8_space&lt;/code&gt; under UTF-8, and &lt;code&gt;isSPACE_LC&lt;/code&gt; under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; .</source>
          <target state="translated">문자 집합 규칙은이 필드에 포함 된 열거 형에 의해 결정됩니다. 이것은 여전히 ​​실험적이며 변경 될 수 있지만 현재 인터페이스는 인라인 함수 &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; 를 사용하여 규칙을 반환합니다 . 현재 문서화 된 값은 REGEX_LOCALE_CHARSET이며, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효 하면 설정됩니다 . 존재한다면 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 공백의 로케일 따라 정의를 사용 RXf_SKIPWHITE 또는 RXf_WHITE 효과에있을 때. ASCII 공백은 &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt; 및 UTF-8 에서 내부 매크로 &lt;code&gt;is_utf8_space&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;code&gt;isSPACE_LC&lt;/code&gt; 에 따라 정의 &lt;a href=&quot;functions/use&quot;&gt; 사용중인 됩니다.&lt;/a&gt;됩니다. .</target>
        </trans-unit>
        <trans-unit id="1006e65bf0ea1b6722bc74455ec57526aa88bfce" translate="yes" xml:space="preserve">
          <source>The character set rules are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt;. The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if &lt;code&gt;use locale&lt;/code&gt; is in effect. If present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;, &lt;code&gt;split&lt;/code&gt; will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt;, and by the internal macros &lt;code&gt;is_utf8_space&lt;/code&gt; under UTF-8, and &lt;code&gt;isSPACE_LC&lt;/code&gt; under &lt;code&gt;use locale&lt;/code&gt;.</source>
          <target state="translated">문자 집합 규칙은이 필드에 포함 된 열거 형에 의해 결정됩니다. 아직 실험적이며 변경 될 수 있지만 현재 인터페이스는 인라인 함수 &lt;code&gt;get_regex_charset(const U32 flags)&lt;/code&gt; 를 사용하여 규칙을 반환합니다 . 현재 문서화 된 유일한 값은 REGEX_LOCALE_CHARSET이며 &lt;code&gt;use locale&lt;/code&gt; 이 유효한 경우 설정됩니다 . 존재한다면 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; , &lt;code&gt;split&lt;/code&gt; 공백의 로케일 따라 정의를 사용 RXf_SKIPWHITE 또는 RXf_WHITE 효과에있을 때. ASCII 공백은 &lt;a href=&quot;perlapi#isSPACE&quot;&gt;isSPACE&lt;/a&gt; 에 따라 정의되며 내부 매크로 는 UTF-8에서 &lt;code&gt;isSPACE_LC&lt;/code&gt; , &lt;code&gt;use locale&lt;/code&gt; 에서는 &lt;code&gt;is_utf8_space&lt;/code&gt; 에 의해 정의 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a9c5d866ba1d6358a34fce2d9ed9c3acf7a55d6" translate="yes" xml:space="preserve">
          <source>The character set to declare in the Content-Type meta tag created by default for &lt;code&gt;html_header_tags&lt;/code&gt; . Note that this option will be ignored if the value of &lt;code&gt;html_header_tags&lt;/code&gt; is changed. Defaults to &quot;ISO-8859-1&quot;.</source>
          <target state="translated">&lt;code&gt;html_header_tags&lt;/code&gt; 에 대해 기본적으로 작성된 Content-Type 메타 태그에서 선언하도록 설정된 문자입니다 . &lt;code&gt;html_header_tags&lt;/code&gt; 값 이 변경 되면이 옵션이 무시됩니다 . 기본값은 &quot;ISO-8859-1&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7bbbaf7a0d85222e6047992118e7a5595b991c40" translate="yes" xml:space="preserve">
          <source>The character set to declare in the Content-Type meta tag created by default for &lt;code&gt;html_header_tags&lt;/code&gt;. Note that this option will be ignored if the value of &lt;code&gt;html_header_tags&lt;/code&gt; is changed. Defaults to &quot;ISO-8859-1&quot;.</source>
          <target state="translated">&lt;code&gt;html_header_tags&lt;/code&gt; 에 대해 기본적으로 생성 된 Content-Type 메타 태그에서 선언 할 문자 집합 입니다. &lt;code&gt;html_header_tags&lt;/code&gt; 의 값 이 변경 되면이 옵션은 무시됩니다 . 기본값은 &quot;ISO-8859-1&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="71daab686bee256e6d597c2f8159505d9e02d07d" translate="yes" xml:space="preserve">
          <source>The characters &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; are special in the L&amp;lt;...&amp;gt; context. Although the hyperlink parser does its best to determine which &quot;/&quot; is text and which is a delimiter in case of doubt, one ought to escape these literal characters like this:</source>
          <target state="translated">문자 &lt;code&gt;|&lt;/code&gt; 그리고 &lt;code&gt;/&lt;/code&gt; 는 L &amp;lt;...&amp;gt; 문맥에서 특별하다. 하이퍼 링크 파서는 어떤 &quot;/&quot;가 텍스트이고 어떤 것이 확실하지 않은지를 구분하기 위해 최선을 다하지만 다음과 같이이 리터럴 문자를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ff02caaaab7f68c513a82b0f22ef13b932d63d1" translate="yes" xml:space="preserve">
          <source>The characters from &lt;code&gt;&quot;ktn&quot;&lt;/code&gt; and &lt;code&gt;&quot;ce&quot;&lt;/code&gt; are combined to determine the what value for &lt;code&gt;$uCreate&lt;/code&gt; to pass to &lt;code&gt;CreateFile&lt;/code&gt; [unless overridden by &lt;code&gt;$rvhvOptions&lt;/code&gt;]:</source>
          <target state="translated">&lt;code&gt;&quot;ktn&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;ce&quot;&lt;/code&gt; 의 문자 는 결합되어 &lt;code&gt;$uCreate&lt;/code&gt; 가 &lt;code&gt;CreateFile&lt;/code&gt; 에 전달할 값을 결정합니다 [ &lt;code&gt;$rvhvOptions&lt;/code&gt; 재정의되지 않는 한 ].</target>
        </trans-unit>
        <trans-unit id="9e5d809d420604eb5bdc15b23bb82aec938490ad" translate="yes" xml:space="preserve">
          <source>The characters used to recall a command or spawn a shell. By default, both are set to &lt;code&gt;!&lt;/code&gt; , which is unfortunate.</source>
          <target state="translated">명령을 불러 오거나 쉘을 생성하는 데 사용되는 문자입니다. 기본적으로 둘 다 &lt;code&gt;!&lt;/code&gt; 로 설정되어 있습니다 . 불행한 일입니다.</target>
        </trans-unit>
        <trans-unit id="71b0ae63b1869c444b2d6a66cebc76939cbbfcd3" translate="yes" xml:space="preserve">
          <source>The characters used to recall a command or spawn a shell. By default, both are set to &lt;code&gt;!&lt;/code&gt;, which is unfortunate.</source>
          <target state="translated">명령을 호출하거나 셸을 생성하는 데 사용되는 문자입니다. 기본적으로 둘 다 &lt;code&gt;!&lt;/code&gt; , 이는 유감입니다.</target>
        </trans-unit>
        <trans-unit id="e773f45ca864ba89a36f322f409cea0a88593853" translate="yes" xml:space="preserve">
          <source>The check function in this case is &lt;code&gt;Perl_ck_null&lt;/code&gt;, which does nothing. Let's look at a more interesting case:</source>
          <target state="translated">이 경우 검사 기능은 &lt;code&gt;Perl_ck_null&lt;/code&gt; 이며 아무 작업도 수행하지 않습니다. 더 흥미로운 사례를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffd9954b7982718c7437be17e29fbfd3df1a4fe1" translate="yes" xml:space="preserve">
          <source>The check routine returns the node which should be inserted into the tree (if the top-level node was not modified, check routine returns its argument).</source>
          <target state="translated">점검 루틴은 트리에 삽입해야하는 노드를 리턴합니다 (최상위 노드가 수정되지 않은 경우 점검 루틴은 인수를 리턴합니다).</target>
        </trans-unit>
        <trans-unit id="47475762ffe9e435213b5064a86af730e143c18a" translate="yes" xml:space="preserve">
          <source>The chunk of memory which is pointed to by &lt;code&gt;p&lt;/code&gt; is Safefree()ed at the end of</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 메모리 청크 는 Safefree ()입니다.</target>
        </trans-unit>
        <trans-unit id="16a3c0a4c50db86e628588170d93fcb36250d2c0" translate="yes" xml:space="preserve">
          <source>The class created by &lt;code&gt;struct&lt;/code&gt; must not be a subclass of another class other than &lt;code&gt;UNIVERSAL&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 로 작성된 클래스는 &lt;code&gt;UNIVERSAL&lt;/code&gt; 이외의 다른 클래스의 서브 클래스가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="88f1a4970b1de3dad6377cd36487420429de6caf" translate="yes" xml:space="preserve">
          <source>The class created by &lt;code&gt;struct&lt;/code&gt; must not be a subclass of another class other than &lt;code&gt;UNIVERSAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 에 의해 생성 된 클래스는 &lt;code&gt;UNIVERSAL&lt;/code&gt; 이외의 다른 클래스의 하위 클래스가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="232a87cc5cdc58df0837defb5b9c5d4aee8a3bd8" translate="yes" xml:space="preserve">
          <source>The class method &lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; returns a boolean to tell you whether your user requested less of something.</source>
          <target state="translated">&lt;code&gt;less-&amp;gt;of( NAME )&lt;/code&gt; 클래스 메소드 는 부울을 반환하여 사용자의 요청이 적 었는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="94cc64c25f30949cf122aa35d8a463e7d89e7056" translate="yes" xml:space="preserve">
          <source>The class method is invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; . Associates an array instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association. The method should return an object of a class which provides the methods below.</source>
          <target state="translated">클래스 메소드는 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; @array, classname&lt;/code&gt; 명령에 의해 호출됩니다 . 배열 인스턴스를 지정된 클래스와 연결합니다. &lt;code&gt;LIST&lt;/code&gt; 는 연결을 완료하는 데 필요한 추가 인수 ( &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 및 compatriots 행)를 나타냅니다 . 이 메소드는 아래 메소드를 제공하는 클래스의 오브젝트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="e05d5689d984cdb52c910ae565ac5aed89b0c503" translate="yes" xml:space="preserve">
          <source>The class method is invoked by the command &lt;code&gt;tie @array, classname&lt;/code&gt;. Associates an array instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association. The method should return an object of a class which provides the methods below.</source>
          <target state="translated">클래스 메소드는 &lt;code&gt;tie @array, classname&lt;/code&gt; 명령에 의해 호출됩니다 . 배열 인스턴스를 지정된 클래스와 연결합니다. &lt;code&gt;LIST&lt;/code&gt; 는 연결을 완료하는 데 필요한 추가 인수 ( &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; 및 compatriots 줄을 따라)를 나타냅니다 . 메소드는 아래 메소드를 제공하는 클래스의 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d36e86369efaf1df03cb1d3f2a6ee7366375ea68" translate="yes" xml:space="preserve">
          <source>The class methods invoked for modifying and fetching are these:</source>
          <target state="translated">수정 및 페치하기 위해 호출 된 클래스 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb7ad0f5c3104759f9a927a624c52b31af5c0c8d" translate="yes" xml:space="preserve">
          <source>The class of iterator to use, override if you're sub-classing. Defaults to &lt;a href=&quot;TAP::Parser::Iterator::Process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt;.</source>
          <target state="translated">사용할 반복기의 클래스입니다. 서브 클래 싱하는 경우 재정의합니다. 기본값은 &lt;a href=&quot;TAP::Parser::Iterator::Process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1b0dfbb45fdf8e07fc85663576479f4111cc42e" translate="yes" xml:space="preserve">
          <source>The class of iterator to use, override if you're sub-classing. Defaults to &lt;a href=&quot;TAP::Parser::Iterator::Stream&quot;&gt;TAP::Parser::Iterator::Stream&lt;/a&gt;.</source>
          <target state="translated">사용할 반복기의 클래스입니다. 서브 클래 싱하는 경우 재정의합니다. 기본값은 &lt;a href=&quot;TAP::Parser::Iterator::Stream&quot;&gt;TAP :: Parser :: Iterator :: Stream&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16f1f45dc986b853b9f9c28d5e7c510f2818ec6c" translate="yes" xml:space="preserve">
          <source>The class of the OP's SV, if it has one, in all caps (e.g., 'IV').</source>
          <target state="translated">OP의 SV 클래스 (있는 경우)는 모든 대문자로 표시됩니다 (예 : 'IV').</target>
        </trans-unit>
        <trans-unit id="1a1cd2e1aca2f382b8e61ec8f61c8bcfacf6a4ed" translate="yes" xml:space="preserve">
          <source>The classic example of where callbacks are used is when writing an event driven program, such as for an X11 application. In this case you register functions to be called whenever specific events occur, e.g., a mouse button is pressed, the cursor moves into a window or a menu item is selected.</source>
          <target state="translated">콜백이 사용되는 전형적인 예는 X11 응용 프로그램과 같은 이벤트 중심 프로그램을 작성할 때입니다. 이 경우 마우스 버튼을 누르거나 커서를 창으로 이동하거나 메뉴 항목을 선택하는 등 특정 이벤트가 발생할 때마다 호출 할 기능을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="afd27c70324ba44f98c6ba791399b603450a20e4" translate="yes" xml:space="preserve">
          <source>The classic floating-point number $VERSION. The advantage to this style is that you don't need to do anything special, just type a number into your source file. Quoting is recommended, as it ensures that trailing zeroes (&quot;1.50&quot;) are preserved in any warnings or other output.</source>
          <target state="translated">고전적인 부동 소수점 숫자 $ VERSION. 이 스타일의 장점은 특별한 작업을 수행 할 필요가 없으며 소스 파일에 숫자를 입력하기 만하면된다는 것입니다. 경고 또는 기타 출력에서 ​​후행 0 ( &quot;1.50&quot;)이 유지되도록하므로 인용이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="99430da67a315f54b20e2f72a5fd52a7326fcd42" translate="yes" xml:space="preserve">
          <source>The clobber method is simply:</source>
          <target state="translated">클로버 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d62999c9944be1bb3aba520e7d0e62efb63cb438" translate="yes" xml:space="preserve">
          <source>The clone method creates a copy of the digest state object and returns a reference to the copy.</source>
          <target state="translated">clone 메소드는 요약 상태 오브젝트의 사본을 작성하고 사본에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">코드</target>
        </trans-unit>
        <trans-unit id="563ad7ecb10abdc47d619f7b3d0884f86cf94b31" translate="yes" xml:space="preserve">
          <source>The code above can be rearranged to get around the problem, like this:</source>
          <target state="translated">위의 코드는 다음과 같이 문제를 해결하기 위해 재 배열 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecf14a60f040b746943a04d158c46f884d48943b" translate="yes" xml:space="preserve">
          <source>The code above uses DB_File, but again it will work with any of the DBM modules.</source>
          <target state="translated">위의 코드는 DB_File을 사용하지만 모든 DBM 모듈에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6d3c51612c2ccbd720904d0ac0d50a474014ffdd" translate="yes" xml:space="preserve">
          <source>The code above uses SDBM_File, but it will work with any of the DBM modules.</source>
          <target state="translated">위의 코드는 SDBM_File을 사용하지만 모든 DBM 모듈에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d0ef4aba54c8ec4419ef4523d1390067d9ff6620" translate="yes" xml:space="preserve">
          <source>The code below can be used to traverse a zip file, one compressed data stream at a time.</source>
          <target state="translated">아래 코드는 한 번에 하나의 압축 된 데이터 스트림 인 zip 파일을 탐색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29217257764218057a5c39c6d3e329014141e5b" translate="yes" xml:space="preserve">
          <source>The code below for</source>
          <target state="translated">에 대한 아래 코드</target>
        </trans-unit>
        <trans-unit id="1d78d26d7e9f445a9bc052e60af207768e7330c6" translate="yes" xml:space="preserve">
          <source>The code below is the example given in the section</source>
          <target state="translated">아래 코드는 섹션에 제공된 예입니다.</target>
        </trans-unit>
        <trans-unit id="8bdb3d95ccb59bc0d07d098ed208693769c903c6" translate="yes" xml:space="preserve">
          <source>The code below is the example given in the section &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;Returning a List of Values&quot;&lt;/a&gt; recoded to use &lt;code&gt;ST&lt;/code&gt; instead of &lt;code&gt;POP*&lt;/code&gt;.</source>
          <target state="translated">아래 코드 는 &lt;code&gt;POP*&lt;/code&gt; 대신 &lt;code&gt;ST&lt;/code&gt; 를 사용하도록 레코딩 된 &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;값 목록 반환&quot;&lt;/a&gt; 섹션에 제공된 예 입니다.</target>
        </trans-unit>
        <trans-unit id="6e196e9f225b5138a983bdb659d302d31a1c384a" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt; .</source>
          <target state="translated">아래 코드는 두 모듈을 모두 사용하지만 &lt;code&gt;Derived&lt;/code&gt; 의 경고 만 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="9f8d10f2ac8bfc175d6b9fc2029df5ae45e37aba" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt;.</source>
          <target state="translated">아래 코드는 두 모듈을 모두 사용하지만 &lt;code&gt;Derived&lt;/code&gt; 의 경고 만 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="4b70175bee574db6d4bbb54ae246e1319c020349" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). For example,</source>
          <target state="translated">코드 블록은 어휘 변수 선언의 관점에서 새로운 범위를 도입하지만 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 및 유사한 지역화 동작 의 관점 에서는 &lt;b&gt;아닙니다&lt;/b&gt; . 따라서 동일한 패턴의 코드 블록은 이전 블록에서 현지화 된 값을 계속 볼 수 있습니다. 이러한 누적 된 현지화는 성공적인 일치가 끝날 때 또는 어설 션이 역 추적 된 경우에 취소됩니다 ( &lt;a href=&quot;#Backtracking&quot;&gt;역 추적&lt;/a&gt; 비교 ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="1ccc31759490ed4f4b37600e130c2bd926ef15da" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;local&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;). For example,</source>
          <target state="translated">코드 블록은 있지만, 어휘 변수 선언의 관점에서 새로운 범위를 도입 &lt;b&gt;하지&lt;/b&gt; 의 관점에서 &lt;code&gt;local&lt;/code&gt; 및 이와 유사한 지역화 행동. 따라서 동일한 패턴 내의 이후 코드 블록은 이전 블록에서 지역화 된 값을 계속 볼 수 있습니다. 이러한 누적 된 현지화는 성공적인 일치가 끝날 때 또는 어설 션이 역 추적 된 경우 ( &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt; 비교) 취소됩니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="e98d3c5b00844f7eee566f69a2fd1ffcc0553db1" translate="yes" xml:space="preserve">
          <source>The code can only see the compartment's namespace (as returned by the &lt;b&gt;root&lt;/b&gt; method). The compartment's root package appears to be the &lt;code&gt;main::&lt;/code&gt; package to the code inside the compartment.</source>
          <target state="translated">코드는 구획의 네임 스페이스 만 볼 수 있습니다 ( &lt;b&gt;루트&lt;/b&gt; 메소드에 의해 리턴 됨 ). 구획의 루트 패키지 는 구획 내부의 코드에 대한 &lt;code&gt;main::&lt;/code&gt; 패키지 인 것으로 보입니다 .</target>
        </trans-unit>
        <trans-unit id="7cc1bb98d53bdcc3465bf9409e43dfe68967ea92" translate="yes" xml:space="preserve">
          <source>The code in the enclosing block has warnings enabled, but the inner block has them disabled. In this case that means the assignment to the scalar &lt;code&gt;$c&lt;/code&gt; will trip the &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; warning, but the assignment to the scalar &lt;code&gt;$b&lt;/code&gt; will not.</source>
          <target state="translated">엔 클로징 블록의 코드에는 경고가 활성화되어 있지만 내부 블록에는 코드가 비활성화되어 있습니다. 이 경우 스칼라 &lt;code&gt;$c&lt;/code&gt; 대한 지정 은 &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; 경고 를 트립 하지만 스칼라 &lt;code&gt;$b&lt;/code&gt; 대한 지정 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bbef419a6073b40632618263de6b83e9a3b2f8c" translate="yes" xml:space="preserve">
          <source>The code involved in &lt;code&gt;study_chunk()&lt;/code&gt; is extremely cryptic. Be careful. :-)</source>
          <target state="translated">&lt;code&gt;study_chunk()&lt;/code&gt; 관련된 코드 는 매우 암호입니다. 조심해. :-)</target>
        </trans-unit>
        <trans-unit id="fa55939059730530d1f6070150cdfbb84afaa7d4" translate="yes" xml:space="preserve">
          <source>The code is executed</source>
          <target state="translated">코드가 실행됩니다</target>
        </trans-unit>
        <trans-unit id="8fe7ae8735b35c106099f4a767ac8bec4145c55c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt; . Note that</source>
          <target state="translated">코드는 패키지 &lt;code&gt;DB&lt;/code&gt; 에서 실행됩니다 . 참고</target>
        </trans-unit>
        <trans-unit id="4798879ea913146cee43e9bcaacaa4e16f87e07c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt;. Note that</source>
          <target state="translated">코드는 패키지 &lt;code&gt;DB&lt;/code&gt; 에서 실행됩니다 . 참고</target>
        </trans-unit>
        <trans-unit id="5bdd192de0a16314fb946ed4a5f124bbba34ce51" translate="yes" xml:space="preserve">
          <source>The code is hosted on Github: https://github.com/jonathanstowe/Term-Cap please feel free to fork, submit patches etc, etc there.</source>
          <target state="translated">코드는 Github에서 호스팅됩니다 : https://github.com/jonathanstowe/Term-Cap 자유롭게 포크하거나 패치를 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="6188bbd338f5f4453ec5eefb9a596ee762c4a047" translate="yes" xml:space="preserve">
          <source>The code is not optimized for speed, especially because we use &lt;code&gt;Math::Complex&lt;/code&gt; and thus go quite near complex numbers while doing the computations even when the arguments are not. This, however, cannot be completely avoided if we want things like &lt;code&gt;asin(2)&lt;/code&gt; to give an answer instead of giving a fatal runtime error.</source>
          <target state="translated">코드는 속도에 최적화되어 있지 않습니다. 특히 &lt;code&gt;Math::Complex&lt;/code&gt; 를 사용하므로 인수가 아닌 경우에도 계산을 수행하는 동안 복잡한 숫자에 가깝습니다. 그러나 치명적인 런타임 오류를 발생시키는 대신 &lt;code&gt;asin(2)&lt;/code&gt; 와 같은 것이 응답을 제공 하려는 경우이를 피할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eeb45ce8e4c72e0b27d2dd4e6b03aed6d8283a3c" translate="yes" xml:space="preserve">
          <source>The code isn't pretty as I mentioned -- I never thought it would be a 1000- line program when I started, or I might not have begun. :-) But I would have been less cavalier in how the parts of the program communicated with each other, etc. It might also have helped if I didn't have to divine the makeup of the stabs on the fly, and then account for micro differences between my compiler and gcc.</source>
          <target state="translated">내가 언급 한대로 코드가 예쁘지 않다. 처음 시작할 때 1000 줄 프로그램이라고 생각하지 않았거나 시작하지 않았을 수도있다. :-) 그러나 나는 프로그램의 일부가 서로 통신하는 방법에 대해 덜 무심했을 것입니다. 그것은 또한 찌르기의 화장을 신성하게 할 필요가 없다면 도움이 될 것입니다. 내 컴파일러와 gcc의 미세한 차이.</target>
        </trans-unit>
        <trans-unit id="1af03be532193b63c39bccd8f3769c3c4ba84570" translate="yes" xml:space="preserve">
          <source>The code point can be any that will fit in an IV on this machine, using Perl's extension to official UTF-8 to represent those higher than the Unicode maximum of 0x10FFFF. That means that this macro is used to efficiently decide if the next few bytes in &lt;code&gt;s&lt;/code&gt; is legal UTF-8 for a single character.</source>
          <target state="translated">코드 포인트는이 컴퓨터의 IV에 맞는 모든 것이 될 수 있으며, Perl의 공식 UTF-8 확장을 사용하여 유니 코드 최대 값 인 0x10FFFF보다 높은 값을 나타냅니다. 즉,이 매크로는 &lt;code&gt;s&lt;/code&gt; 의 다음 몇 바이트 가 단일 문자에 대해 유효한 UTF-8 인지 여부를 효율적으로 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a38d0cd4c97e31c5c6e8ef232e032151d44d07e" translate="yes" xml:space="preserve">
          <source>The code point represented by the input UTF-8 sequence is for a Unicode non-character code point. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_NONCHAR&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt; flags.</source>
          <target state="translated">입력 UTF-8 시퀀스로 표시되는 코드 포인트는 유니 코드 비 문자 코드 포인트 용입니다. 이 비트는 입력 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 &lt;code&gt;UTF8_DISALLOW_NONCHAR&lt;/code&gt; 또는 &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt; 플래그 가 포함 된 경우에만 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e137833ea36c6bb446c1454de0e7f32827ac2db" translate="yes" xml:space="preserve">
          <source>The code reference associated with &lt;code&gt;Store&lt;/code&gt; will be called before any key/value is written to the database and the code reference associated with &lt;code&gt;Fetch&lt;/code&gt; will be called after any key/value is read from the database.</source>
          <target state="translated">키 / 값이 데이터베이스에 기록되기 전에 &lt;code&gt;Store&lt;/code&gt; 와 연관된 코드 참조 가 호출되고 데이터베이스에서 키 / 값을 읽은 후에 &lt;code&gt;Fetch&lt;/code&gt; 와 연관된 코드 참조 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9112803a8d3c96a68465b0bcde1920f2e7e6a455" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from</source>
          <target state="translated">파싱 ​​할 코드는</target>
        </trans-unit>
        <trans-unit id="f56dbc06407874bee55a6ea0f6f2fbee35bbf70f" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;rsfp&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt;, if non-null, provides a string (in SV form) containing code to be parsed. A copy of the string is made, so subsequent modification of &lt;code&gt;line&lt;/code&gt; does not affect parsing. &lt;code&gt;rsfp&lt;/code&gt;, if non-null, provides an input stream from which code will be read to be parsed. If both are non-null, the code in &lt;code&gt;line&lt;/code&gt; comes first and must consist of complete lines of input, and &lt;code&gt;rsfp&lt;/code&gt; supplies the remainder of the source.</source>
          <target state="translated">구문 분석 할 코드는 &lt;code&gt;line&lt;/code&gt; 및 &lt;code&gt;rsfp&lt;/code&gt; 에서 가져옵니다 . null이 아닌 경우 &lt;code&gt;line&lt;/code&gt; 은 구문 분석 할 코드가 포함 된 문자열 (SV 형식)을 제공합니다. 문자열의 복사본이 만들어 지므로 이후에 &lt;code&gt;line&lt;/code&gt; 수정 해도 구문 분석에 영향을주지 않습니다. &lt;code&gt;rsfp&lt;/code&gt; 는 null이 아닌 경우 구문 분석을 위해 코드를 읽을 입력 스트림을 제공합니다. 둘 다 null이 아니면 &lt;code&gt;line&lt;/code&gt; 의 코드 가 먼저 나오고 완전한 입력 줄로 구성되어야하며 &lt;code&gt;rsfp&lt;/code&gt; 는 나머지 소스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="471ec4c1f979a5d05323a39069daf19923ca3333" translate="yes" xml:space="preserve">
          <source>The code to run inside the subtest.</source>
          <target state="translated">하위 테스트 내에서 실행할 코드입니다.</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">코드:</target>
        </trans-unit>
        <trans-unit id="eeae5d7673ad77a6f3fce469e318a0a0bf4653ce" translate="yes" xml:space="preserve">
          <source>The codebase is a mixture of tabs and spaces for indentation, and we are moving to spaces only. Converting lines you're patching from 8-wide tabs to spaces will help this migration.</source>
          <target state="translated">코드베이스는 들여 쓰기를위한 탭과 공백의 혼합이며 공백으로 만 이동합니다. 패치중인 줄을 8 개 탭에서 공백으로 변환하면이 마이그레이션에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="6c4c60f240f194fdb0d0584f5890bfd1f9a58985" translate="yes" xml:space="preserve">
          <source>The coderef you provide is returned and can be used to remove the hook later.</source>
          <target state="translated">제공 한 코드 참조가 반환되며 나중에 후크를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43bd0609e5f4f6c76dfb80ec0b3769b0a1ce5867" translate="yes" xml:space="preserve">
          <source>The codes generated by this module are standard terminal control codes, complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI color&quot; for the color codes). The non-color control codes (bold, dark, italic, underline, and reverse) are part of the earlier ANSI X3.64 standard for control sequences for video terminals and peripherals.</source>
          <target state="translated">이 모듈에 의해 생성 된 코드는 ECMA-048 및 ISO 6429 (일반적으로 컬러 코드에 대해 &quot;ANSI 컬러&quot;)를 준수하는 표준 터미널 제어 코드입니다. 비색 제어 코드 (굵게, 어둡게, 기울임 꼴, 밑줄 및 역)는 비디오 터미널 및 주변 장치의 제어 시퀀스에 대한 이전 ANSI X3.64 표준의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="6fab56ccb009185913550effa31ed3b9edd378e9" translate="yes" xml:space="preserve">
          <source>The codesets currently supported are:</source>
          <target state="translated">현재 지원되는 코드 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71e94bac38239334b6900c0a017267aa1a8ae397" translate="yes" xml:space="preserve">
          <source>The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch and cotanh/coth are aliases)</source>
          <target state="translated">쌍곡 사인, 코사인 및 탄젠트의 조합 (cosech / csch 및 cotanh / coth는 별칭)</target>
        </trans-unit>
        <trans-unit id="28a5561373d2289312316102a3c2581ebe7698d3" translate="yes" xml:space="preserve">
          <source>The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot are aliases)</source>
          <target state="translated">사인, 코사인 및 탄젠트의 cofunctions (cosec / csc 및 cotan / cot는 별명 임)</target>
        </trans-unit>
        <trans-unit id="e024e4f61b24aaae2c3c812d1f87a03e707d97c4" translate="yes" xml:space="preserve">
          <source>The collation sequence can be any set of unique characters. These two cases are equivalent</source>
          <target state="translated">데이터 정렬 순서는 고유 한 문자 집합이 될 수 있습니다. 이 두 경우는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4a1e9fabea4570a18aadb2a0be8b117d7c1d1876" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt; .</source>
          <target state="translated">의 집단 세트 &lt;b&gt;환경 변수는&lt;/b&gt; 사용자의 &lt;b&gt;프로세스&lt;/b&gt; 의 부모로부터 상속. &lt;code&gt;%ENV&lt;/code&gt; 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="8146e94413ec1f316b7c3977a5863b7a90080ad4" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt;.</source>
          <target state="translated">의 집단 세트 &lt;b&gt;환경 변수는&lt;/b&gt; 사용자의 &lt;b&gt;프로세스&lt;/b&gt; 의 부모로부터 상속. &lt;code&gt;%ENV&lt;/code&gt; 를 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="54dbe0de410d1fee14f151bad669e4e7f64514b7" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal.</source>
          <target state="translated">&lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 가 터미널과 호환 되지 않으면 색상 기능이 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="69123f14b307a724c7d2b32425d73c9819412a9e" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal. Additionally, &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; must be installed on windows platforms for color output.</source>
          <target state="translated">&lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor&lt;/a&gt; 가 터미널과 호환 되지 않으면 색상 기능이 작동하지 않습니다 . 또한 &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt; 는 컬러 출력을 위해 Windows 플랫폼에 설치되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d494da03d1029e001559e320101aec67b6081a14" translate="yes" xml:space="preserve">
          <source>The color stack, including the &lt;code&gt;:pushpop&lt;/code&gt; import tag, PUSHCOLOR, POPCOLOR, LOCALCOLOR, and the $Term::ANSIColor::AUTOLOCAL variable, was added in Term::ANSIColor 2.00, included in Perl 5.10.1.</source>
          <target state="translated">&lt;code&gt;:pushpop&lt;/code&gt; 가져 오기 태그, PUSHCOLOR, POPCOLOR, LOCALCOLOR 및 $ Term :: ANSIColor :: AUTOLOCAL 변수를 포함한 색상 스택 이 Perl 5.10.1에 포함 된 Term :: ANSIColor 2.00에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="99f186121577072655b8ffd874560fdf2ec9538e" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76, unless &lt;b&gt;-t&lt;/b&gt; is given, in which case it's two columns less than the width of your terminal device.</source>
          <target state="translated">오른쪽에서 텍스트를 줄 바꿈하는 열입니다. &lt;b&gt;-t&lt;/b&gt; 를 지정 하지 않으면 기본값은 76 입니다.이 경우 터미널 장치의 너비보다 두 열이 작습니다.</target>
        </trans-unit>
        <trans-unit id="dc0da64614756f754ff954c33b5269fabc02fce0" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76.</source>
          <target state="translated">오른쪽에서 텍스트를 줄 바꿈하는 열입니다. 기본값은 76입니다.</target>
        </trans-unit>
        <trans-unit id="e8623930908f634360f3d6d3225f352295877e28" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 와 &lt;code&gt;\G&lt;/code&gt; 조합 하면 문자열을 한 번에 조금씩 처리하고 임의의 Perl 논리를 사용하여 다음에 수행 할 작업을 결정할 수 있습니다. 현재 &lt;code&gt;\G&lt;/code&gt; 앵커는 패턴의 시작 부분에 앵커하는 데 사용될 때만 완벽하게 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee0a722061e99b2e3ae6619dfca4f00fe8cf72e" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 와 &lt;code&gt;\G&lt;/code&gt; 의 조합을 사용하면 문자열을 한 번에 조금씩 처리하고 임의의 Perl 논리를 사용하여 다음에 수행 할 작업을 결정할 수 있습니다. 현재 &lt;code&gt;\G&lt;/code&gt; 앵커는 패턴의 시작 부분에 앵커하는 데 사용할 때만 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="970e7f15d0c6ab9e35629ba58fe853786b66b02c" translate="yes" xml:space="preserve">
          <source>The combination of multiple command- line switches (</source>
          <target state="translated">여러 명령 줄 스위치 (</target>
        </trans-unit>
        <trans-unit id="e655e997e08648320978a6ff86ae273d24047f81" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ) if it really wants to, but not vice-versa.</source>
          <target state="translated">3 &amp;amp; 4의 결합 된 효과는 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하는 코드 가 실제로 원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; 유형 코드 ( &lt;a href=&quot;functions/local&quot;&gt;로컬&lt;/a&gt; $ ^ W = 0 사용 ) 의 경고 동작을 제어 할 수있게하는 것입니다 . 반대로.</target>
        </trans-unit>
        <trans-unit id="e3995e1eb61da1d6a07b530102c1f24daec8bae4" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;local $^W=0&lt;/code&gt;) if it really wants to, but not vice-versa.</source>
          <target state="translated">3과 4의 결합 된 효과는 &lt;code&gt;warnings&lt;/code&gt; pragma를 사용하여 $ ^ W 유형 코드 ( &lt;code&gt;local $^W=0&lt;/code&gt; ) 의 경고 동작을 제어하는 코드를 허용 하지만 그 반대는 아닙니다. 마찬가지로.</target>
        </trans-unit>
        <trans-unit id="c5195e2f756a78470c45dda1ae8fbd38d00cbe08" translate="yes" xml:space="preserve">
          <source>The command &quot;=for</source>
          <target state="translated">&quot;= for 명령</target>
        </trans-unit>
        <trans-unit id="3786e2d525dc34959fb151cbab27e80aefbcfac1" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git clean&lt;/code&gt; can with varying arguments be used as a replacement for &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git clean&lt;/code&gt; 명령 은 다양한 인수와 함께 &lt;code&gt;make clean&lt;/code&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8aeb4458c1560b0d5ab2e46d755733e3bb6324" translate="yes" xml:space="preserve">
          <source>The command does not start.</source>
          <target state="translated">명령이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e6f4f93a21a7f88a65ff2221b6911802d75f842" translate="yes" xml:space="preserve">
          <source>The command is killed by a signal.</source>
          <target state="translated">명령이 신호에 의해 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="914be5b158c3cc5be779f3d3fed5d23185a3c4a4" translate="yes" xml:space="preserve">
          <source>The command line interface is tightly integrated with an &lt;b&gt;emacs&lt;/b&gt; extension and there's a &lt;b&gt;vi&lt;/b&gt; interface too.</source>
          <target state="translated">커맨드 라인 인터페이스는 &lt;b&gt;emacs&lt;/b&gt; 확장과 밀접하게 통합되어 있으며 &lt;b&gt;vi&lt;/b&gt; 인터페이스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f789ad4d35bca82f26a9236e86bce7a57e057b98" translate="yes" xml:space="preserve">
          <source>The command line is not split by GetOptions, but by the command line interpreter (CLI). On Unix, this is the shell. On Windows, it is COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.</source>
          <target state="translated">명령 줄은 GetOptions가 아니라 명령 줄 인터프리터 (CLI)에 의해 분할됩니다. 유닉스에서 이것은 쉘입니다. Windows에서는 COMMAND.COM 또는 CMD.EXE입니다. 다른 운영 체제에는 다른 CLI가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a12dc653b968ec55d9bfea4484d747acafd8c027" translate="yes" xml:space="preserve">
          <source>The command returns a non-zero exit value (but see below).</source>
          <target state="translated">이 명령은 0이 아닌 종료 값을 반환합니다 (하지만 아래 참조).</target>
        </trans-unit>
        <trans-unit id="4a884c5530c697acec58e6764eb13db7fac15f02" translate="yes" xml:space="preserve">
          <source>The command to run is built as follows:</source>
          <target state="translated">실행할 명령은 다음과 같이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="ccf7fbf7b3dd60fe57ca23a7e47b3c4eeb05e932" translate="yes" xml:space="preserve">
          <source>The command used to load the debugger code. The default is:</source>
          <target state="translated">디버거 코드를로드하는 데 사용되는 명령입니다. 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35175a977556088d11ca4a7b0e7332f1ce787324" translate="yes" xml:space="preserve">
          <source>The command's STDOUT and STDERR (and possibly STDIN, depending on your shell) will be the same as the parent's. You won't need to catch SIGCHLD because of the double-fork taking place; see below for details.</source>
          <target state="translated">명령의 STDOUT 및 STDERR (및 쉘에 따라 STDIN도 가능)은 부모의 명령과 동일합니다. 이중 포크가 발생하기 때문에 SIGCHLD를 잡을 필요가 없습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75337684a9346d140506f8cf5d632c3a6fe46276" translate="yes" xml:space="preserve">
          <source>The command-line mentioned in the SYNOPSIS section corresponds to the Perl code</source>
          <target state="translated">SYNOPSIS 섹션에 언급 된 명령 줄은 Perl 코드에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ea72136c38b086284678c74c52f83815bf874db4" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;=pod&lt;/code&gt; and &lt;code&gt;=cut&lt;/code&gt; do not take any arguments.</source>
          <target state="translated">&lt;code&gt;=pod&lt;/code&gt; 및 &lt;code&gt;=cut&lt;/code&gt; 명령 은 인수를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e3cdc1d66a6ddbc94785be80a34d0a817fb94d" translate="yes" xml:space="preserve">
          <source>The commands available in the shell interface are methods in the package CPAN::Shell. If you enter the shell command, your input is split by the Text::ParseWords::shellwords() routine, which acts like most shells do. The first word is interpreted as the method to be invoked, and the rest of the words are treated as the method's arguments. Continuation lines are supported by ending a line with a literal backslash.</source>
          <target state="translated">쉘 인터페이스에서 사용 가능한 명령은 CPAN :: Shell 패키지의 메소드입니다. 쉘 명령을 입력하면 대부분의 쉘처럼 작동하는 Text :: ParseWords :: shellwords () 루틴으로 입력이 분할됩니다. 첫 번째 단어는 호출 할 메소드로 해석되며 나머지 단어는 메소드의 인수로 처리됩니다. 연속 라인은 리터럴 백 슬래시로 라인을 종료하여 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="50c172c64b8304a2667bbd4145cf67a46b69892f" translate="yes" xml:space="preserve">
          <source>The commit message should include a description of the problem that the patch corrects or new functionality that the patch adds.</source>
          <target state="translated">커밋 메시지에는 패치로 해결되는 문제 또는 패치가 추가 한 새로운 기능에 대한 설명이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a48a6b9a39f2c1e8f05ac68afbc7708f295daa69" translate="yes" xml:space="preserve">
          <source>The common (and original) usage of B::Concise was for command-line renderings of simple code, as given in EXAMPLE. But you can also use &lt;b&gt;B::Concise&lt;/b&gt; from your code, and call compile() directly, and repeatedly. By doing so, you can avoid the compile-time only operation of O.pm, and even use the debugger to step through B::Concise::compile() itself.</source>
          <target state="translated">B :: Concise의 일반적인 (및 원래) 사용법은 예제에 제공된 것처럼 간단한 코드의 명령 줄 렌더링에 사용되었습니다. 그러나 코드에서 &lt;b&gt;B :: Concise&lt;/b&gt; 를 사용 하고 compile ()을 직접 반복해서 호출 할 수도 있습니다 . 이렇게하면 O.pm의 컴파일 타임 전용 작업을 피하고 디버거를 사용하여 B :: Concise :: compile () 자체를 단계별로 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="092b88432af421400f5d15e398af7e25459b6caf" translate="yes" xml:space="preserve">
          <source>The comparison function is required to behave. If it returns inconsistent results (sometimes saying &lt;code&gt;$x[1]&lt;/code&gt; is less than &lt;code&gt;$x[2]&lt;/code&gt; and sometimes saying the opposite, for example) the results are not well-defined.</source>
          <target state="translated">비교 기능이 작동해야합니다. 일치하지 않는 결과를 반환하면 ( 예를 들어 &lt;code&gt;$x[1]&lt;/code&gt; 이 &lt;code&gt;$x[2]&lt;/code&gt; 보다 작고 때로는 반대의 경우도 있음) 결과가 잘 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="edfa309c58fb1bf1eba2e1c0e1a54aa1aefcb60b" translate="yes" xml:space="preserve">
          <source>The compilation of a subroutine can be affected by a few compiler directives, &lt;b&gt;pragmas&lt;/b&gt;. These are:</source>
          <target state="translated">서브 루틴의 컴파일은 소수의 컴파일러 지시문 인 &lt;b&gt;pragmas의&lt;/b&gt; 영향을받을 수 있습니다 . 이것들은:</target>
        </trans-unit>
        <trans-unit id="ecde94171862ef8b275c6d67c44a792fcd8d5efd" translate="yes" xml:space="preserve">
          <source>The compile tree is executed in a runops function. There are two runops functions, in</source>
          <target state="translated">컴파일 트리는 runops 함수에서 실행됩니다. 두 가지 룬 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79a77bf1e2569d28ea6eda34147b4768d49e28ad" translate="yes" xml:space="preserve">
          <source>The compiler will search for typemap files called</source>
          <target state="translated">컴파일러는 다음과 같은 유형 맵 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="111471390604961ec6523ced1b372373b53d8003" translate="yes" xml:space="preserve">
          <source>The compiler would immediately flag that as an error</source>
          <target state="translated">컴파일러는 즉시 오류로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="89f4eed42cf9fec88c7f54948d286e3b27120ba8" translate="yes" xml:space="preserve">
          <source>The complementary error function [C99].</source>
          <target state="translated">상보 오차 함수 [C99].</target>
        </trans-unit>
        <trans-unit id="685be68b0319918e48d33648874bae1d830f5b52" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://perldoc.perl.org/perl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="translated">전체 Perl 문서는 Perl 배포와 함께 사용할 수 있습니다. Perl이 로컬로 설치되어 있다면 아마도 문서도 설치했을 것입니다 : 터미널에 &lt;code&gt;perldoc perl&lt;/code&gt; 을 입력 하거나 &lt;a href=&quot;http://perldoc.perl.org/perl.html&quot;&gt;온라인으로보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed6f778f02ef1fa177aa048ce5ee5aeaef666a7f" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="translated">완전한 Perl 문서는 Perl 배포판과 함께 제공됩니다. Perl을 로컬로 설치 한 경우 문서를 설치했을 수도 있습니다. 터미널에 &lt;code&gt;perldoc perl&lt;/code&gt; 을 입력 하거나 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;온라인으로보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="068df1cb71064dd3af102dcffe784783c3c8d76f" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is compressed.</source>
          <target state="translated">데이터가 압축되기 전에 유효한 파일 이름 만 포함하도록 전체 배열이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="3bc7e120c73e8eddc193ee78a2c4c1f364b17641" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is uncompressed.</source>
          <target state="translated">데이터가 압축 해제되기 전에 유효한 파일 이름 만 포함하도록 전체 배열이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="98b6ca723bf0fecfbf2258563e5ac721bc8076d0" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 지시문에 지정할 수있는 전체 키 목록은 해시 &lt;code&gt;%overload::ops&lt;/code&gt; 의 값에 공백으로 구분되어 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="39b8357b2b8bda435df838b871e13a6e868a463b" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;use overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;use overload&lt;/code&gt; 지시문 에서 지정할 수있는 전체 키 목록은 해시 &lt;code&gt;%overload::ops&lt;/code&gt; 값에 공백으로 구분되어 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="52c281d1dec7eebd9b6bf4d9cf26bf4311a392cc" translate="yes" xml:space="preserve">
          <source>The complete table can be found in the Sun Managers' FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; under &quot;9.1) Which Sun models run which versions of SunOS?&quot;.</source>
          <target state="translated">전체 표는 &quot;9.1) 어떤 Sun 모델이 어떤 버전의 SunOS를 실행합니까?&quot; 의 Sun Managers FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="243520c31a219c7d1aad4ef85de5d88764701e20" translate="yes" xml:space="preserve">
          <source>The completion character &amp;lt;tab&amp;gt; cannot be changed.</source>
          <target state="translated">완성 문자 &amp;lt;tab&amp;gt;은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="23ff44fc7bcd5bb4196b4eabff893cd96c4f3b50" translate="yes" xml:space="preserve">
          <source>The complexity of the language you're trying to output a phrase in is entirely abstracted inside (and encapsulated within) the Maketext module for that interface. When you call:</source>
          <target state="translated">구문을 출력하려는 ​​언어의 복잡성은 해당 인터페이스의 Maketext 모듈 내부에서 완전히 추상화되고 캡슐화됩니다. 전화 할 때 :</target>
        </trans-unit>
        <trans-unit id="17b9f988fe18d77702fa8f938bb3b8ecfcbaea7a" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;&quot;Formatting Codes&quot; in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L-Codes&quot;&gt;&quot;About L&amp;lt;...&amp;gt; Codes&quot;&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="translated">이 코드의 복잡한 구문은 &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;perlpod의 &quot;Formatting Codes&quot;에서&lt;/a&gt; 자세히 설명하고, 구현 세부 사항은 아래 &lt;a href=&quot;#About-L-Codes&quot;&gt;&quot;About L &amp;lt;...&amp;gt; Codes&quot;에서 설명&lt;/a&gt; 합니다. L &amp;lt;content&amp;gt;의 내용을 파싱하는 것은 까다 롭습니다. 특히 콘텐츠가 URL처럼 보이는지 또는 리터럴 &quot;|&quot;로 분할되어야하는지 여부를 확인해야합니다. 및 / 또는 &quot;/&quot;(올바른 순서로!) 등,</target>
        </trans-unit>
        <trans-unit id="57f8fbb5c61dbf32a6295f7091431384e77ad0b9" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;About L&amp;lt;...&amp;gt; Codes&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="translated">이 코드의 복잡한 구문은 &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;perlpod의 형식화 코드에서&lt;/a&gt; 자세히 설명하며 구현 세부 사항은 &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;L &amp;lt;...&amp;gt; 코드 정보&lt;/a&gt; 에서 아래에 설명되어 있습니다 . L &amp;lt;content&amp;gt;의 내용을 파싱하는 것은 까다 롭습니다. 특히 콘텐츠가 URL처럼 보이는지 또는 리터럴 &quot;|&quot;로 분할되어야하는지 여부를 확인해야합니다. 및 / 또는 &quot;/&quot;(올바른 순서로) 등</target>
        </trans-unit>
        <trans-unit id="3e080e954af33f166a94bcfa488743e85b7e060c" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt; .</source>
          <target state="translated">이를 작성하는 복합적인 방법은 &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (약식 : &lt;code&gt;\p{gc:n}&lt;/code&gt; )와 같습니다. 그러나 Perl은 동일하거나 콜론 분리자를 통해 모든 것이 생략되는 바로 가기를 제공합니다. 따라서 대신 &lt;code&gt;\pN&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f504fa5a5306a0e609df2f9c35729a9aad217004" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt;). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt;.</source>
          <target state="translated">이것들을 쓰는 복합적인 방법은 &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (줄임말 : &lt;code&gt;\p{gc:n}&lt;/code&gt; )와 같습니다. 그러나 Perl은 등호 또는 콜론 구분 기호를 통한 모든 항목이 생략되는 단축키를 제공합니다. 따라서 대신 &lt;code&gt;\pN&lt;/code&gt; 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4be8f3e8beb322b0e55f10e2929087827e8f380" translate="yes" xml:space="preserve">
          <source>The computer on which a program or other data resides.</source>
          <target state="translated">프로그램 또는 기타 데이터가있는 컴퓨터</target>
        </trans-unit>
        <trans-unit id="cfcbad8d7cd3118bc2c84750149f972c9d76bac3" translate="yes" xml:space="preserve">
          <source>The concatenation operator is &quot;.&quot;, not the null string. (Using the null string would render &lt;code&gt;/pat/ /pat/&lt;/code&gt; unparsable, because the third slash would be interpreted as a division operator--the tokenizer is in fact slightly context sensitive for operators like &quot;/&quot;, &quot;?&quot;, and &quot;&amp;gt;&quot;. And in fact, &quot;.&quot; itself can be the beginning of a number.)</source>
          <target state="translated">연결 연산자는 널 문자열이 아닌 &quot;.&quot;입니다. (널 문자열을 사용하면 &lt;code&gt;/pat/ /pat/&lt;/code&gt; 해석 할 수 없습니다. 세 번째 슬래시는 나누기 연산자로 해석되기 때문에 토크 나이 저는 실제로 &quot;/&quot;, &quot;?&quot;및 &quot;&amp;gt; &quot;. 그리고 실제로&quot;. &quot;자체는 숫자의 시작일 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7397c296c9007588d87f382f9ceff5394823ef48" translate="yes" xml:space="preserve">
          <source>The concise style uses symbols to convey maximum info with minimal clutter (like hex addresses). With just a little practice, you can start to see the flowers, not just the branches, in the trees.</source>
          <target state="translated">간결한 스타일은 기호를 사용하여 16 진수 주소와 같은 최소한의 혼란으로 최대 정보를 전달합니다. 약간의 연습만으로도 나무에서 가지뿐만 아니라 꽃을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9749679dc3561ae81ba863d8e80238321089767" translate="yes" xml:space="preserve">
          <source>The concrete formatter must implement</source>
          <target state="translated">콘크리트 포맷터는</target>
        </trans-unit>
        <trans-unit id="ff1705816e805e2b10cae23ac0d85181e713e425" translate="yes" xml:space="preserve">
          <source>The condition expression of a &lt;code&gt;for&lt;/code&gt; loop gets the same magic treatment of &lt;code&gt;readline&lt;/code&gt; et al that the condition expression of a &lt;code&gt;while&lt;/code&gt; loop gets.</source>
          <target state="translated">a의 조건 표현식 &lt;code&gt;for&lt;/code&gt; 루프는 같은 마법 처리 얻을 &lt;code&gt;readline&lt;/code&gt; a의 상태를 표현한다는 등의 알 &lt;code&gt;while&lt;/code&gt; 루프를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec6253a94addb83f76f25a71c4752860278fa23c" translate="yes" xml:space="preserve">
          <source>The conditions can be any Perl expression. See the list of operators in the next section for information on comparison and boolean logic operators, which are commonly used in conditional statements.</source>
          <target state="translated">조건은 모든 Perl 표현식 일 수 있습니다. 조건문에 일반적으로 사용되는 비교 및 ​​부울 논리 연산자에 대한 정보는 다음 섹션의 연산자 목록을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="660b170e644dc462db23e032c8de8f3cadb36f87" translate="yes" xml:space="preserve">
          <source>The conduit through which all events flow.</source>
          <target state="translated">모든 이벤트가 통과하는 통로입니다.</target>
        </trans-unit>
        <trans-unit id="543b88d3ab70df9ad92d2d1112ca25224746b1f5" translate="yes" xml:space="preserve">
          <source>The configuration data is held globally in a file in the perl installation tree, but a user may override any of these values by providing their own. This can be done by having a &lt;code&gt;.libnetrc&lt;/code&gt; file in their home directory. This file should return a reference to a HASH containing the keys described below. For example</source>
          <target state="translated">구성 데이터는 전체적으로 perl 설치 트리의 파일에 보관되지만 사용자는 고유 한 값을 제공하여 이러한 값을 대체 할 수 있습니다. 홈 디렉토리에 &lt;code&gt;.libnetrc&lt;/code&gt; 파일 이 있으면이를 수행 할 수 있습니다 . 이 파일은 아래 설명 된 키가 포함 된 HASH에 대한 참조를 반환해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9a78f97fbb5cf4075595c0b03128bde7af0266c1" translate="yes" xml:space="preserve">
          <source>The configuration dialog can be started any time later again by issuing the command &lt;code&gt; o conf init &lt;/code&gt; in the CPAN shell. A subset of the configuration dialog can be run by issuing &lt;code&gt;o conf init WORD&lt;/code&gt; where WORD is any valid config variable or a regular expression.</source>
          <target state="translated">CPAN 쉘에서 &lt;code&gt; o conf init &lt;/code&gt; 명령을 실행하여 나중에 구성 대화 상자를 다시 시작할 수 있습니다 . &lt;code&gt;o conf init WORD&lt;/code&gt; 를 발행하여 구성 대화 상자의 서브 세트를 실행할 수 있습니다. 여기서 WORD는 유효한 구성 변수 또는 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="b4c7562be2672acce7fe43e87808c7f47379f387" translate="yes" xml:space="preserve">
          <source>The configuration parameter check_sigs is there to turn signature checking on or off.</source>
          <target state="translated">구성 매개 변수 check_sigs는 서명 확인을 켜거나 끄는 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
