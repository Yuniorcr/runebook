<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="e8f4fc6abff769c701a3cd104bd7d5e13a65f76f" translate="yes" xml:space="preserve">
          <source>The configure phase occurs before any dynamic configuration has been attempted. Libraries required by the configure phase &lt;b&gt;must&lt;/b&gt; be available for use before the distribution building tool has been executed.</source>
          <target state="translated">구성 단계는 동적 구성이 시도되기 전에 발생합니다. 배포 구축 도구를 실행하기 전에 구성 단계에 필요한 라이브러리 를 사용할 수 &lt;b&gt;있어야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cb35472fba52fde6c0d287b9880009008ce62bd4" translate="yes" xml:space="preserve">
          <source>The conformance test for the UCA</source>
          <target state="translated">UCA에 대한 적합성 테스트</target>
        </trans-unit>
        <trans-unit id="92e8c71c043d1ee5895cf5c5a239168a7f0a8975" translate="yes" xml:space="preserve">
          <source>The confusion arises because people incorrectly assume that the sigil denotes the variable type.</source>
          <target state="translated">사람들이시길이 변수 유형을 나타내는 것으로 잘못 가정하기 때문에 혼란이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="72def2ab61e0c7e7dccd965b3f9393136d20aa03" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;pi&lt;/code&gt; and some handy multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also available if separately exported:</source>
          <target state="translated">별도로 pi를 내 보내면 상수 &lt;code&gt;pi&lt;/code&gt; 와 일부 편리한 배수 (pi2, pi4 및 pip2 (pi / 2) 및 pip4 (pi / 4))도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81821f9e03375c52f91dde5667119328458dcfd" translate="yes" xml:space="preserve">
          <source>The constant function &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; above). The constant &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; function returns what file version is written and might be less than &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; in some configurations.</source>
          <target state="translated">상수 함수 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 는이 Storable 버전이 완전히 지원하는 가장 높은 파일 버전 번호를 나타내는 비교 가능한 숫자를 리턴합니다 (그러나 위 의 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; 대한 설명 참조 ). 상수 &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; 함수는 작성된 파일 버전을 리턴 하며 일부 구성에서 &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1404d0959d5fe2f0dd1fe9c942e64fc147050eb7" translate="yes" xml:space="preserve">
          <source>The constants for specific &lt;code&gt;code&lt;/code&gt; values can be imported individually or using the &lt;code&gt;:signal_h_si_code&lt;/code&gt; tag.</source>
          <target state="translated">특정 &lt;code&gt;code&lt;/code&gt; 값에 대한 상수는 개별적으로 또는 &lt;code&gt;:signal_h_si_code&lt;/code&gt; 태그를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9018d00ba0cf85500f9049cabc293077c6a815d2" translate="yes" xml:space="preserve">
          <source>The construct</source>
          <target state="translated">구조</target>
        </trans-unit>
        <trans-unit id="8226460345430ec3df47c2bd35c2d238766995a6" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt; , and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt; .</source>
          <target state="translated">위 예제에서 사용 된 구문 &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; 는 두 가지 목적을 가지고 있습니다. &lt;b&gt;먼저이&lt;/b&gt; 줄이 &lt;b&gt;xsubpp&lt;/b&gt; 에 의해 처리 될 때 Perl 스 니펫 &lt;code&gt;$v{timep}=$arg&lt;/code&gt; 가 평가됩니다. 둘째, 평가 된 스 니펫의 텍스트가 생성 된 C 파일 (C 주석 내부)에 출력됩니다! &lt;code&gt;char *host&lt;/code&gt; 행을 처리하는 동안 &lt;code&gt;$arg&lt;/code&gt; 는 &lt;code&gt;ST(0)&lt;/code&gt; 평가 되고 &lt;code&gt;$v{timep}&lt;/code&gt; 는 &lt;code&gt;ST(1)&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f2f29b3b2c632054cc482de2585e44d1631920b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt;, and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 사용 된 &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; 구문 은 두 가지 목적을 가지고 있습니다. 첫째,이 줄이 &lt;b&gt;xsubpp&lt;/b&gt; 에 의해 처리 될 때 Perl 스 니펫 &lt;code&gt;$v{timep}=$arg&lt;/code&gt; 가 평가됩니다. 둘째, 평가 된 스 니펫의 텍스트는 생성 된 C 파일 (C 주석 내부)로 출력됩니다! &lt;code&gt;char *host&lt;/code&gt; 라인을 처리하는 동안 &lt;code&gt;$arg&lt;/code&gt; 는 &lt;code&gt;ST(0)&lt;/code&gt; 평가 되고 &lt;code&gt;$v{timep}&lt;/code&gt; 는 &lt;code&gt;ST(1)&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b59007854896f819ee065a798da86e7867bce96e" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 생성자 는 빈 &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; 객체를 만들어 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1bad8668cdf1d431ad701326f6748ece18b79658" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 생성자 는 빈 &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; 객체를 만들어 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c2fcf35a44aabf097cd59f3a3854953c70e5fcd" translate="yes" xml:space="preserve">
          <source>The constructor can also accept additional parameters that define the object. Let's write a real constructor for the &lt;code&gt;File&lt;/code&gt; class we used earlier:</source>
          <target state="translated">생성자는 객체를 정의하는 추가 매개 변수를 사용할 수도 있습니다. 앞에서 사용한 &lt;code&gt;File&lt;/code&gt; 클래스 의 실제 생성자를 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3a88176407788666ff0021721dd4e56b3400cf3f" translate="yes" xml:space="preserve">
          <source>The constructor creates a new object and optionally initialises it with a set of handles.</source>
          <target state="translated">생성자는 새 객체를 만들고 선택적으로 핸들 세트로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="26002f2b8ad63b7adc28307355437aa48afa5d7b" translate="yes" xml:space="preserve">
          <source>The constructor for a &lt;code&gt;Net::Netrc&lt;/code&gt; object is not called new as it does not really create a new object. But instead is called &lt;code&gt;lookup&lt;/code&gt; as this is essentially what it does.</source>
          <target state="translated">&lt;code&gt;Net::Netrc&lt;/code&gt; 객체 의 생성자는 실제로 새 객체를 만들지 않으므로 new라고하지 않습니다. 그러나 이것이 기본적으로 &lt;code&gt;lookup&lt;/code&gt; 되는 작업이므로 조회 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="5e4047980f5ac3eb3127d3d68b5f254e9299a0fd" translate="yes" xml:space="preserve">
          <source>The constructor for all the singletons used to represent modules, distributions, authors, and bundles. If the object already exists, this method returns the object; otherwise, it calls the constructor.</source>
          <target state="translated">모듈, 배포판, 작성자 및 번들을 나타내는 데 사용되는 모든 싱글 톤의 생성자입니다. 객체가 이미 존재하는 경우이 메소드는 객체를 반환합니다. 그렇지 않으면 생성자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="392e17e9526fa6867e8438f1a219ca39e5568acc" translate="yes" xml:space="preserve">
          <source>The constructor must be passed a metadata structure.</source>
          <target state="translated">생성자는 메타 데이터 구조를 전달 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="a54cf785d15de998f3ac18ade864f218319b1ee1" translate="yes" xml:space="preserve">
          <source>The constructor of a generated class can be passed a list of</source>
          <target state="translated">생성 된 클래스의 생성자에게</target>
        </trans-unit>
        <trans-unit id="bb7df7aab984a9c0e691c8f805de279350cf56e0" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;Digest::MD5&lt;/code&gt; object which encapsulate the state of the MD5 message-digest algorithm.</source>
          <target state="translated">생성자는 MD5 메시지 요약 알고리즘의 상태를 캡슐화 하는 새로운 &lt;code&gt;Digest::MD5&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2e6b2441df01bfc969fd7dfde15484f966dcaf52" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; 객체를 반환 합니다. 경우 &lt;a href=&quot;../../term/ansicolor&quot;&gt;기간 : ANSIColor가&lt;/a&gt; 설치되어 있지 않은, 반환 undef를.</target>
        </trans-unit>
        <trans-unit id="4747d0a8e21ed88de854df16a2a22a83e805b50c" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; 객체를 반환 합니다. 경우 &lt;a href=&quot;Term::ANSIColor&quot;&gt;기간 : ANSIColor가&lt;/a&gt; 설치되어 있지 않은, 반환 undef를.</target>
        </trans-unit>
        <trans-unit id="972195b07373ba2fa384173c37fb399dc7626fb1" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; object.</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="64d08d3b354e3667ab5da2f82eaec44dd6d25ea5" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 객체를 반환 합니다. 경우 &lt;a href=&quot;../harness&quot;&gt;TAP :: 하네스가&lt;/a&gt; 더으로 작성되지 않습니다 &lt;code&gt;formatter&lt;/code&gt; &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 자동으로 생성됩니다. 다음 옵션 중 하나가 TAP :: Harness-&amp;gt; new에 제공된 경우 허용 된 키가있는 선택적 hashref를 허용하는이 생성자에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8909e70f1c9cdb1bc8623d8b0a2d889cffc98a88" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 객체를 반환 합니다. 경우 &lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: 하네스가&lt;/a&gt; 더으로 작성되지 않습니다 &lt;code&gt;formatter&lt;/code&gt; &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; 자동으로 생성됩니다. 다음 옵션 중 하나가 TAP :: Harness-&amp;gt; new에 제공된 경우 허용되는 키가있는 선택적 해시 참조를 허용하는이 생성자에 잘 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf8ec5d8f9e8688b8b1e013d18928a0b5fdbbeb" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Harness&lt;/code&gt; object. It accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">생성자는 새로운 &lt;code&gt;TAP::Harness&lt;/code&gt; 객체를 반환 합니다. 허용되는 키가 다음과 같은 선택적 해시 참조를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="093c7ac00d4bfb4c1a8deee532d1b8ad2334e8c0" translate="yes" xml:space="preserve">
          <source>The constructor returns some object that encapsulate the state of the message-digest algorithm. You can add data to the object and finally ask for the digest. The &quot;XXX&quot; should of course be replaced by the proper name of the digest algorithm you want to use.</source>
          <target state="translated">생성자는 메시지 요약 알고리즘의 상태를 캡슐화하는 일부 객체를 반환합니다. 객체에 데이터를 추가하고 마지막으로 다이제스트를 요청할 수 있습니다. 물론 &quot;XXX&quot;는 사용하려는 다이제스트 알고리즘의 올바른 이름으로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="b8c0174cc6aa4e80ad4122d0657361b0e191a979" translate="yes" xml:space="preserve">
          <source>The constructor should be passed a valid metadata structure but invalid structures are accepted. If no meta-spec version is provided, version 1.0 will be assumed.</source>
          <target state="translated">생성자에는 유효한 메타 데이터 구조가 전달되어야하지만 유효하지 않은 구조가 허용됩니다. 메타 스펙 버전이 제공되지 않으면 버전 1.0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cb4929a7c6855e45789fbb16fa26a8399b54ccaf" translate="yes" xml:space="preserve">
          <source>The content from the __DATA__ block is not filtered. This is a serious limitation, e.g. for the &lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt; module. See &lt;a href=&quot;http://search.cpan.org/perldoc?Switch#LIMITATIONS&quot;&gt;http://search.cpan.org/perldoc?Switch#LIMITATIONS&lt;/a&gt; for more.</source>
          <target state="translated">__DATA__ 블록의 콘텐츠는 필터링되지 않습니다. 이는 예를 들어 &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 모듈의 경우 심각한 제한 사항 입니다. 자세한 내용은 &lt;a href=&quot;http://search.cpan.org/perldoc?Switch#LIMITATIONS&quot;&gt;http://search.cpan.org/perldoc?Switch#LIMITATIONS&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4ebdab724a22632fec3a1d054882b1bc817c7d6" translate="yes" xml:space="preserve">
          <source>The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.</source>
          <target state="translated">here doc의 내용은 문자열이 백틱에 포함 된 것처럼 처리됩니다. 따라서 내용은 큰 따옴표로 묶은 다음 셸을 통해 실행 된 것처럼 보간되어 실행 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2c33213d12b4d00abe49d77a5bff9aee654312d3" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">버퍼에있는 텍스트 청크의 내용은 일반적으로 줄 바꿈 종결자를 포함하여 정확히 한 줄의 입력입니다. 그러나 그렇지 않은 경우도 있습니다. 버퍼의 옥텟은 UTF-8 또는 Latin-1로 해석 될 수 있습니다. &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; 함수 는 어떤 것을 알려줍니다. 이 스칼라 에는 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 사용하지 마십시오 .이 플래그와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6af50a9986dd8fc345d5bd2a482a8608eafdf212" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">버퍼에서 텍스트 청크의 내용은 일반적으로 줄 바꿈 종결자를 포함하여 정확히 하나의 완전한 입력 줄이지 만, 그렇지 않은 경우가 있습니다. 버퍼의 옥텟은 UTF-8 또는 Latin-1로 해석 될 수 있습니다. &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; 함수는 어느 것을 알려줍니다. 이 스칼라 에서 &lt;code&gt;SvUTF8&lt;/code&gt; 플래그를 사용하면 동의하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c50b9c6cd39ffa60fa752e0357613216ec7e1d3" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$/&lt;/code&gt; are used to determine what constitutes a line terminator.</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; 의 내용은 라인 종결자를 구성하는 것을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09777bcf55808641ba4d5a5b61fa0d9ce1740b32" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$@&lt;/code&gt; immediately after autodie triggered an exception. This may be useful when dealing with modules such as &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt; that set (but do not throw) &lt;code&gt;$@&lt;/code&gt; on error.</source>
          <target state="translated">autodie가 예외를 트리거 한 직후 &lt;code&gt;$@&lt;/code&gt; 의 내용 . 이는 오류시 &lt;code&gt;$@&lt;/code&gt; 를 설정하는 (하지만 던지지 않는) &lt;a href=&quot;Text::Balanced&quot;&gt;Text :: Balanced&lt;/a&gt; 와 같은 모듈을 다룰 때 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7ca5978cb2d9772e7d9f41db4210fa03ba32d12" translate="yes" xml:space="preserve">
          <source>The contents of SVs may be printed using the &lt;code&gt;SVf&lt;/code&gt; format, like so:</source>
          <target state="translated">SV의 내용은 다음과 같이 &lt;code&gt;SVf&lt;/code&gt; 형식을 사용하여 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18d18ed7c7a8db27a58a80fd58640cc3bbfe1bce" translate="yes" xml:space="preserve">
          <source>The contents of the Comment header field, if present. If no comment is present, the value will be undef. Note this is different from a zero length comment, which will return an empty string.</source>
          <target state="translated">주석 머리글 필드의 내용입니다 (있는 경우). 주석이 없으면 값이 정의되지 않습니다. 이것은 길이가 0 인 주석과 다르며 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f67589a8aeaaf0494de7c02234d42e486e771e87" translate="yes" xml:space="preserve">
          <source>The contents of the Name header field, if present. If no name is present, the value will be undef. Note this is different from a zero length name, which will return an empty string.</source>
          <target state="translated">존재하는 경우 이름 헤더 필드의 내용 이름이 없으면 값은 정의되지 않습니다. 이것은 길이가 0 인 이름과 다르며 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9456b1413183ce2a7cacbf69ac958ec33df9e078" translate="yes" xml:space="preserve">
          <source>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region</source>
          <target state="translated">위의 &quot;= begin : yetanotherformat&quot;... &quot;= end : yetanotherformat&quot;영역의 내용</target>
        </trans-unit>
        <trans-unit id="7bdc8b3d3c8ea3698e851bea6c870ef22be74842" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">문자열의 내용은 &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; 대한 호출을 사용하여 인수로 분할됩니다 . 와 마찬가지로 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , 글로벌 &lt;code&gt;@ARGV&lt;/code&gt; 은 건드리지 않는다.</target>
        </trans-unit>
        <trans-unit id="07cf397badd80566fee8d86ba0e84ac06f7a748f" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt;. As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">문자열의 내용은 &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; 호출을 사용하여 인수로 분할됩니다 . 와 마찬가지로 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , 글로벌 &lt;code&gt;@ARGV&lt;/code&gt; 은 건드리지 않는다.</target>
        </trans-unit>
        <trans-unit id="ee0a191734836657a10b5b7b1f37002c95e61a13" translate="yes" xml:space="preserve">
          <source>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</source>
          <target state="translated">문자열의 내용은 변하지 만 문자열의 본질은 변하지 않습니다. 펄은 문자열의 내용이 긍정을 나타내는 것보다 전화를 한 후에 더 이상 알지 못한다.</target>
        </trans-unit>
        <trans-unit id="fa23695f3fe9b71ce5ed23d56ccd05be2c1e1b36" translate="yes" xml:space="preserve">
          <source>The contents should be an integer; different bits of it are used for different pragmatic flags. Here's an example:</source>
          <target state="translated">내용은 정수 여야합니다. 그것의 다른 비트는 다른 실용적인 플래그에 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29b067c45824f7dfd004988f65509a605101a269" translate="yes" xml:space="preserve">
          <source>The context (void, scalar or list) for the return value(s) for &lt;code&gt;-&amp;gt;join()&lt;/code&gt; is determined at the time of thread creation.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;join()&lt;/code&gt; 대한 리턴 값에 대한 컨텍스트 (void, 스칼라 또는 목록) 는 스레드 작성시 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2981bb07b7171fe17187abbda366aca2482181b3" translate="yes" xml:space="preserve">
          <source>The context in which the subroutine was called by autodie; usually the same as the context in which you called the autodying subroutine. This can be 'list', 'scalar', or undefined (unknown). It will never be 'void', as &lt;code&gt;autodie&lt;/code&gt; always captures the return value in one way or another.</source>
          <target state="translated">autodie에 의해 서브 루틴이 호출 된 컨텍스트. 일반적으로 autodying 서브 루틴을 호출 한 컨텍스트와 동일합니다. '목록', '스칼라'또는 정의되지 않음 (알 수 없음) 일 수 있습니다. &lt;code&gt;autodie&lt;/code&gt; 는 항상 어떤 방식 으로든 반환 값을 캡처 하므로 '무효'가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ecdacee8e16379859c5cc73f585093cfac3b0ac5" translate="yes" xml:space="preserve">
          <source>The context object has API compatible implementations of the following methods:</source>
          <target state="translated">컨텍스트 개체에는 다음 메서드의 API 호환 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d48ce1ec215b9e3fdc0488fca135ada53527334" translate="yes" xml:space="preserve">
          <source>The context object is the primary interface for authors of testing tools written with &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. The context object represents the context in which a test takes place (File and Line Number), and provides a quick way to generate events from that context. The context object also takes care of sending events to the correct &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance.</source>
          <target state="translated">컨텍스트 개체는 &lt;a href=&quot;test2&quot;&gt;Test2로&lt;/a&gt; 작성된 테스트 도구 작성자를위한 기본 인터페이스입니다 . 컨텍스트 개체는 테스트가 수행되는 컨텍스트 (파일 및 줄 번호)를 나타내며 해당 컨텍스트에서 이벤트를 생성하는 빠른 방법을 제공합니다. 컨텍스트 개체는 이벤트를 올바른 &lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt; 인스턴스 로 보내는 작업도 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="cafef0e58c037c46bb556fc0f1a1471183c9edb3" translate="yes" xml:space="preserve">
          <source>The context type may also be used as the</source>
          <target state="translated">컨텍스트 유형은</target>
        </trans-unit>
        <trans-unit id="67c74c2a8a5b26d0759477b6c197cf9395cba8a0" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does &lt;code&gt;dTHX;&lt;/code&gt; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">Perl_warner의 컨텍스트 프리 버전은 Perl_warner_nocontext라고하며 추가 인수를 사용하지 않습니다. 대신 &lt;code&gt;dTHX;&lt;/code&gt; 스레드 로컬 저장소에서 컨텍스트를 가져옵니다. 우리는 &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; 성능이 저하 때문에 확장을 얻을 소스 호환성. (인수를 전달하는 것이 스레드 로컬 저장소에서 가져 오는 것보다 저렴합니다.)</target>
        </trans-unit>
        <trans-unit id="cd3e46d3e11cb302e5746c299ddd22b0f06326e3" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does dTHX; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">컨텍스트없는 버전의 Perl_warner를 Perl_warner_nocontext라고하며 추가 인수를 사용하지 않습니다. 대신 dTHX를 수행합니다. 스레드 로컬 스토리지에서 컨텍스트를 가져옵니다. 우리는 &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; 성능이 저하 때문에 확장을 얻을 소스 호환성. arg를 전달하는 것은 스레드 로컬 스토리지에서 가져 오는 것보다 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="427dbaaec2be0f9303d86d3fada6d103291e20da" translate="yes" xml:space="preserve">
          <source>The contexts where no warnings or errors are raised are:</source>
          <target state="translated">경고 나 오류가 발생하지 않는 컨텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a306525389293789c4d3b564d2695ad27f640911" translate="yes" xml:space="preserve">
          <source>The conversion from Perl to C is left as an exercise to the reader, but the prototype would be:</source>
          <target state="translated">Perl에서 C 로의 변환은 독자에게 연습으로 남겨 두지 만 프로토 타입은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dab7a329fdfbc3426218724b9a43e87edffc6ee" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt; . It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">복사 생성자는 뮤 테이터를 구현하도록 선언 된 함수를 호출하기 전에 만 호출됩니다 (예 : &lt;code&gt;++$b;&lt;/code&gt; 위의 코드에서 키 &lt;code&gt;'++'&lt;/code&gt; (또는 'nomethod', 네 번째 인수로 &lt;code&gt;'++'&lt;/code&gt; 를 전달한 ' nomethod')에 대해 선언 된 메소드 또는 자동 생성에 의해 &lt;code&gt;'+='&lt;/code&gt; 가 적용 됩니다. 등가 코드에서 &lt;code&gt;'+'&lt;/code&gt; 에 대한 메소드 호출로 증가 조작이 수행되는 경우 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1a338324ec1f9edaef696d6d917c941261b8a116" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt;. It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">복사 생성자는 뮤 테이터를 구현하기 위해 선언 된 함수를 호출하기 전에 만 호출됩니다 (예 : &lt;code&gt;++$b;&lt;/code&gt; 위 코드에서 &lt;code&gt;'++'&lt;/code&gt; 키 (또는 'nomethod', 네 번째 인수로 &lt;code&gt;'++'&lt;/code&gt; 전달)에 대해 선언 된 메서드를 통해 적용 되거나 자동 생성에 의해 &lt;code&gt;'+='&lt;/code&gt; 됩니다. 상응하는 코드에서 &lt;code&gt;'+'&lt;/code&gt; 에 대한 메서드 호출에 의해 증분 연산이 영향을받는 경우 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ed73a5b2044d7fb703c52c07bf589cfde908abd5" translate="yes" xml:space="preserve">
          <source>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</source>
          <target state="translated">Perl이 수정중인 데이터에 대한 다른 참조가 없기 때문에 불필요하다고 판단하면 복사 생성자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="535c9ed5919c829adefa54d7a3ea16590ff263e1" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="translated">핵심 &lt;a href=&quot;Devel::Peek&quot;&gt;Devel :: Peek&lt;/a&gt; 모듈을 사용하면 Perl 프로그램에서 SV를 검사 할 수 있습니다. 예를 들어 Perl이 상수 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 를 처리하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="bc11db58db7976be6cbb0391f46874d6c6c0bdfd" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="translated">핵심 &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP :: Tiny&lt;/a&gt; 모듈은 웹 리소스를 가져 와서 해당 콘텐츠를 문자열로 다시 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd210b745dfa94e566cd092061cca3c4c3e619ac" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</source>
          <target state="translated">핵심 &lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt; 모듈을 사용하면 Perl 프로그램에서 SV를 검사 할 수 있습니다. 예를 들어, Perl이 상수 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 를 어떻게 처리하는지 봅시다 .</target>
        </trans-unit>
        <trans-unit id="216872d0879be12be32ab51a2f74dd9e0b301e2c" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;archives&lt;/a&gt; or read the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq&lt;/a&gt;, or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">핵심 개발 팀 (Perl Porters라고도 함)은 돈으로 구매할 수있는 것보다 더 나은 소프트웨어를 무료로 생산하기 위해 노력하는 고도로 이타적인 개인 그룹입니다. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;아카이브&lt;/a&gt; 를 통해 보류중인 개발을 스누핑 하거나 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq를&lt;/a&gt; 읽 거나 perl5-porters-subscribe@perl.org에 구독 요청 (제목이없는 빈 메시지는 괜찮음)을 보내 메일 링리스트에 가입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="722caaf3f888051207be247f57e2eb71f8ea20ba" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/&quot;&gt;archives&lt;/a&gt; or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">핵심 개발 팀 (Perl Porters라고 함)은 돈으로 구매할 수있는 것보다 더 나은 소프트웨어를 무료로 생산하기 위해 노력하는 매우 이타적인 개인 그룹입니다. &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/&quot;&gt;아카이브&lt;/a&gt; 를 통해 보류중인 개발을 스누핑 하거나 perl5-porters-subscribe@perl.org에 구독 요청을 보내 메일 링리스트를 구독 할 수 있습니다 (제목이없는 빈 메시지는 괜찮습니다).</target>
        </trans-unit>
        <trans-unit id="0cd6f3115d2d6dbe91a070c10c729356bd227008" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt; , set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt; . On a Bourne-like shell, this can be done as</source>
          <target state="translated">코어 배포는 이제 유닉스 계열 플랫폼에서 병렬로 회귀 테스트를 실행할 수 있습니다. &lt;code&gt;make test&lt;/code&gt; 를 실행 하는 대신 환경에서 &lt;code&gt;TEST_JOBS&lt;/code&gt; 를 병렬로 실행할 테스트 수로 설정 하고 &lt;code&gt;make test_harness&lt;/code&gt; 를 실행 하십시오 . Bourne과 같은 쉘에서 다음과 같이 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b674b66d3912143b8c38b5c16cba55bf33d927a4" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt;, set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt;. On a Bourne-like shell, this can be done as</source>
          <target state="translated">코어 배포판은 이제 Unix와 유사한 플랫폼에서 회귀 테스트를 병렬로 실행할 수 있습니다. &lt;code&gt;make test&lt;/code&gt; 를 실행 하는 대신 환경에서 &lt;code&gt;TEST_JOBS&lt;/code&gt; 를 병렬로 실행할 테스트 수로 설정 하고 &lt;code&gt;make test_harness&lt;/code&gt; 를 실행 하십시오 . Bourne과 같은 쉘에서는 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cc3805e3a5e355489c3ee53c0ef93bf5066f34" translate="yes" xml:space="preserve">
          <source>The core provides a wrapper program,</source>
          <target state="translated">코어는 래퍼 프로그램을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e662bc8801eef788dff3d6316ec77e7ad811db79" translate="yes" xml:space="preserve">
          <source>The core uses the same testing style as the rest of Perl, a simple &quot;ok/not ok&quot; run through Test::Harness, but there are a few special considerations.</source>
          <target state="translated">코어는 Test :: Harness를 통해 실행되는 간단한 &quot;ok / not ok&quot;인 Perl의 나머지와 동일한 테스트 스타일을 사용하지만 몇 가지 특별한 고려 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ac8ff08d630fcfeea5350e81e0c2b799df3c84" translate="yes" xml:space="preserve">
          <source>The corpse of a &lt;b&gt;process&lt;/b&gt;, in the form of a file left in the &lt;b&gt;working directory&lt;/b&gt; of the process, usually as a result of certain kinds of fatal errors.</source>
          <target state="translated">a의 시체 &lt;b&gt;처리&lt;/b&gt; 파일의 형태는 남아 &lt;b&gt;작업 디렉토리&lt;/b&gt; 보통 치명적 오류의 특정 종류의 결과로, 프로세스의.</target>
        </trans-unit>
        <trans-unit id="ad72ec528dbf7e40ea844e46e3a129f3b3eadb6f" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</source>
          <target state="translated">올바른 코드는 &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d267e23c37d16b49140100273b7c13b82e17e524" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt;.</source>
          <target state="translated">올바른 코드는 &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7eb7322d9e711d10a989215f61754b35fdcb57a5" translate="yes" xml:space="preserve">
          <source>The correct procedure, then, is to use &lt;code&gt;newRV_noinc&lt;/code&gt; instead of &lt;code&gt;newRV_inc&lt;/code&gt; . Then, if and when the last reference is destroyed, the reference count of the SV will go to zero and it will be destroyed, stopping any memory leak.</source>
          <target state="translated">올바른 절차는 다음 사용하는 것입니다 &lt;code&gt;newRV_noinc&lt;/code&gt; 대신 &lt;code&gt;newRV_inc&lt;/code&gt; 을 . 그런 다음 마지막 참조가 파괴되면 SV의 참조 카운트가 0이되고 파괴되어 메모리 누수가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="e90480b056b891e1197a3bfca2f65f9341469925" translate="yes" xml:space="preserve">
          <source>The correspondence between OPs and</source>
          <target state="translated">OP와의 대응</target>
        </trans-unit>
        <trans-unit id="3e632bae0f91b7fe9b42695b7f4eb9541547d7ab" translate="yes" xml:space="preserve">
          <source>The corresponding bright foreground color attributes (colors 8 to 15) are:</source>
          <target state="translated">해당 밝은 전경색 속성 (8 ~ 15 색)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15d3a8f91abd0b678be46a5c74457eb9c1a22a59" translate="yes" xml:space="preserve">
          <source>The corresponding command to get the current value of &lt;code&gt;$version&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;$version&lt;/code&gt; 의 현재 값을 가져 오는 해당 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05b1215b3085d02b291dbd96e47ab01de8dfb44a" translate="yes" xml:space="preserve">
          <source>The corresponding values are interpreted as regular expressions. The &lt;code&gt;distribution&lt;/code&gt; related one will be matched against the canonical distribution name, e.g. &quot;AUTHOR/Foo-Bar-3.14.tar.gz&quot;.</source>
          <target state="translated">해당 값은 정규식으로 해석됩니다. &lt;code&gt;distribution&lt;/code&gt; 관련 하나는 정규 분포의 이름, 예를 들어 &quot;저자 / 푸 바-3.14.tar.gz&quot;에 대해 일치됩니다.</target>
        </trans-unit>
        <trans-unit id="128893376b086988df0b6fe82266dcff7ded3c2c" translate="yes" xml:space="preserve">
          <source>The corresponding values are references to functions which take three arguments: the first one is the</source>
          <target state="translated">해당 값은 세 개의 인수를 취하는 함수에 대한 참조입니다. 첫 번째는</target>
        </trans-unit>
        <trans-unit id="6d3c7b629f0ebabb7666a1418d689e5fcefefd4a" translate="yes" xml:space="preserve">
          <source>The count of the saved lines in the history (assuming &lt;code&gt;HistFile&lt;/code&gt; above).</source>
          <target state="translated">히스토리에 저장된 행의 수입니다 ( 위의 &lt;code&gt;HistFile&lt;/code&gt; 가정 ).</target>
        </trans-unit>
        <trans-unit id="8a76e9ed23620e2d0138b893f98a44b589dac036" translate="yes" xml:space="preserve">
          <source>The cpd tool detects cut-and-paste coding. If one instance of the cut-and-pasted code changes, all the other spots should probably be changed, too. Therefore such code should probably be turned into a subroutine or a macro.</source>
          <target state="translated">cpd 도구는 잘라 내기 및 붙여 넣기 코딩을 감지합니다. 잘라서 붙여 넣은 코드의 한 인스턴스가 변경되면 다른 모든 스팟도 변경해야합니다. 따라서 이러한 코드는 아마도 서브 루틴 또는 매크로로 바뀌어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e999a3fce2098896facdee408ae939b810f6fc0" translate="yes" xml:space="preserve">
          <source>The cperl PERL_PERTURB_KEYS_TOP hash strategy has a known problem with restricted hashes.</source>
          <target state="translated">cperl PERL_PERTURB_KEYS_TOP 해시 전략에는 제한된 해시와 관련된 알려진 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4315b91912980da8ee0d1d0ed73982372319566a" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt; , which is why there are no rules, only guidelines.</source>
          <target state="translated">성능을 고려할 때 중요한 것은 &lt;code&gt;Golden Bullet&lt;/code&gt; 과 같은 것이 없다는 것을 기억 하는 것입니다. 따라서 규칙이없고 지침 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe5e8a5c2d99ce7c51902edfccff2bd041c5e28d" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt;, which is why there are no rules, only guidelines.</source>
          <target state="translated">성능을 고려할 때 중요한 것은 &lt;code&gt;Golden Bullet&lt;/code&gt; 과 같은 것이 없다는 것을 기억 하는 것입니다. 이것이 규칙이없고 지침 만있는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="2b2f6d378553efd3b9ab7bab3a4069e081f7b24e" translate="yes" xml:space="preserve">
          <source>The crucial thing to understand about the Windows environment is that the command line you type in is processed twice before Perl sees it. First, your command shell (usually CMD.EXE) preprocesses the command line, to handle redirection, environment variable expansion, and location of the executable to run. Then, the perl executable splits the remaining command line into individual arguments, using the C runtime library upon which Perl was built.</source>
          <target state="translated">Windows 환경에 대해 알아야 할 중요한 사항은 입력 한 명령 줄이 Perl에 표시되기 전에 두 번 처리된다는 것입니다. 먼저 명령 셸 (일반적으로 CMD.EXE)은 명령 줄을 사전 처리하여 리디렉션, 환경 변수 확장 및 실행할 실행 파일의 위치를 ​​처리합니다. 그런 다음 perl 실행 파일은 Perl이 빌드 된 C 런타임 라이브러리를 사용하여 나머지 명령 행을 개별 인수로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="1bc259f8a74780b8f0344bb67ea81414fbf6762f" translate="yes" xml:space="preserve">
          <source>The crypt package distributed with Cygwin is a Linux compatible 56-bit DES crypt port by Corinna Vinschen.</source>
          <target state="translated">Cygwin과 함께 배포되는 암호화 패키지는 Corinna Vinschen의 Linux 호환 56 비트 DES 암호화 포트입니다.</target>
        </trans-unit>
        <trans-unit id="39208a8b75f909c397f1ded48c8402dc3fb7d1f8" translate="yes" xml:space="preserve">
          <source>The crypt() function is unimplemented due to excessive paranoia.</source>
          <target state="translated">과도한 편집증으로 인해 crypt () 함수가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="831281b1eb1b6cf65cdf498d326c123b4d2ac980" translate="yes" xml:space="preserve">
          <source>The csh_glob() function can also be exported, but you should not use it directly unless you really know what you are doing. It splits the pattern into words and feeds each one to bsd_glob(). Perl's own glob() function uses this internally.</source>
          <target state="translated">csh_glob () 함수도 내보낼 수 있지만 실제로 수행중인 작업을 모르면 직접 사용해서는 안됩니다. 패턴을 단어로 나누고 각각을 bsd_glob ()에 공급합니다. 펄 자신의 glob () 함수는 이것을 내부적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb0c5fc2762311ff2f0c2ca9c51463e63c575d45" translate="yes" xml:space="preserve">
          <source>The ctime() function provides a way of getting at the scalar sense of the original CORE::localtime() function.</source>
          <target state="translated">ctime () 함수는 원래 CORE :: localtime () 함수의 스칼라 의미를 얻는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc603efa123dedf5ee9218533c5f2218c02b0847" translate="yes" xml:space="preserve">
          <source>The cube root [C99].</source>
          <target state="translated">큐브 루트 [C99].</target>
        </trans-unit>
        <trans-unit id="64bb5be49b5cecef1e72ffa347e55d8d7f71bf40" translate="yes" xml:space="preserve">
          <source>The current Unicode definition of a Word Boundary matches between every white space character. Perl tailors this, starting in version 5.24, to generally not break up spans of white space, just as plain &lt;code&gt;\b&lt;/code&gt; has always functioned. This allows &lt;code&gt;\b{wb}&lt;/code&gt; to be a drop-in replacement for &lt;code&gt;\b&lt;/code&gt;, but with generally better results for natural language processing. (The exception to this tailoring is when a span of white space is immediately followed by something like U+0303, COMBINING TILDE. If the final space character in the span is a horizontal white space, it is broken out so that it attaches instead to the combining character. To be precise, if a span of white space that ends in a horizontal space has the character immediately following it have any of the Word Boundary property values &quot;Extend&quot;, &quot;Format&quot; or &quot;ZWJ&quot;, the boundary between the final horizontal space character and the rest of the span matches &lt;code&gt;\b{wb}&lt;/code&gt;. In all other cases the boundary between two white space characters matches &lt;code&gt;\B{wb}&lt;/code&gt;.)</source>
          <target state="translated">Word Boundary의 현재 유니 코드 정의는 모든 공백 문자간에 일치합니다. Perl은 버전 5.24부터 이것을 조정하여 보통 &lt;code&gt;\b&lt;/code&gt; 가 항상 작동 했던 것처럼 공백의 범위를 나누지 않도록 합니다. 이를 통해 &lt;code&gt;\b{wb}&lt;/code&gt; 드롭 인 교체 될 &lt;code&gt;\b&lt;/code&gt; , 그러나 일반적으로 자연어 처리에 대해 더 나은 결과를 제공합니다. (이 테일러링의 예외는 공백의 범위 바로 뒤에 U + 0303, COMBINING TILDE와 같은 것이 오는 경우입니다. 범위의 마지막 공백 문자가 수평 공백 인 경우 분할되어 대신 연결됩니다. 정확히 말하면 가로 공백으로 끝나는 공백의 범위에 바로 뒤에 오는 문자가있는 경우 단어 경계 속성 값 &quot;Extend&quot;, &quot;Format&quot;또는 &quot;ZWJ&quot;, 즉 최종 수평 공백 문자와 나머지 범위는 &lt;code&gt;\b{wb}&lt;/code&gt; 와 일치 합니다. 다른 모든 경우에는 두 공백 문자 사이의 경계가 &lt;code&gt;\B{wb}&lt;/code&gt; 와 일치 합니다.)</target>
        </trans-unit>
        <trans-unit id="64523d7c78b273edb939e95b2a44e78339d21a0e" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">현재 형식 이름은 변수 &lt;code&gt;$~&lt;/code&gt; ( &lt;code&gt;$FORMAT_NAME&lt;/code&gt; )에 저장되며 양식 형식 이름의 현재 맨 위는 &lt;code&gt;$^&lt;/code&gt; ( &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; )입니다. 현재 출력 페이지 번호는 &lt;code&gt;$%&lt;/code&gt; ( &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; )에 저장되고 페이지 의 줄 수는 &lt;code&gt;$=&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; )에 있습니다. 이 핸들의 출력을 자동 플러시할지 여부는 &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). 첫 페이지를 제외한 각 페이지 상단의 문자열 출력은 &lt;code&gt;$^L&lt;/code&gt; ( &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; )에 저장됩니다.). 이러한 변수는 파일 단위로 설정되므로 다른 변수로 select ()를 적용하여 변수에 영향을 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="15997f5af8679b322c9a721da40c3667459ea331" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt;), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt;). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt;), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt;). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt;). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt;). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">현재 형식 이름은 변수 &lt;code&gt;$~&lt;/code&gt; ( &lt;code&gt;$FORMAT_NAME&lt;/code&gt; )에 저장되고 양식 형식 이름의 현재 맨 위는 &lt;code&gt;$^&lt;/code&gt; ( &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; )에 있습니다. 현재 출력 페이지 번호는 &lt;code&gt;$%&lt;/code&gt; ( &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; )에 저장되고 페이지 의 행 수는 &lt;code&gt;$=&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; )에 저장됩니다. 이 핸들의 출력을 자동 플러시할지 여부는 &lt;code&gt;$|&lt;/code&gt; 저장됩니다. ( &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). 페이지 상단 (첫 번째 제외) 앞의 문자열 출력은 &lt;code&gt;$^L&lt;/code&gt; ( &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; )에 저장됩니다.). 이러한 변수는 파일 핸들별로 설정되므로 영향을 미치려면 다른 변수로 select ()해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbbf873260d45973f075c0f7d16575580f2c6333" translate="yes" xml:space="preserve">
          <source>The current hierarchy is:</source>
          <target state="translated">현재 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="824b38e0c77c472868114a17d1e97b269bb0ba11" translate="yes" xml:space="preserve">
          <source>The current implementation does not allow specification of the required version of the module.</source>
          <target state="translated">현재 구현에서는 필요한 버전의 모듈을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="282bec354d0f4d4b762dd47ad0eb5b6ecfd1f6ce" translate="yes" xml:space="preserve">
          <source>The current input line is normally in $_, not $0. It generally does not have the newline stripped. ($0 is the name of the program executed.) See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">현재 입력 라인은 일반적으로 $ 0가 아니라 $ _에 있습니다. 일반적으로 줄 바꿈이 제거되지 않습니다. ($ 0은 실행 된 프로그램의 이름입니다.) &lt;a href=&quot;perlvar&quot;&gt;perlvar를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18f618cc025364ce800e5f345611b3c1497a1ed6" translate="yes" xml:space="preserve">
          <source>The current kinds of Magic Virtual Tables are:</source>
          <target state="translated">현재 종류의 매직 가상 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c4fde69768c885a1c05aaf0e69e2380f88e2b66" translate="yes" xml:space="preserve">
          <source>The current leading implementation of Perl 6, Rakudo, released a &quot;useful, usable, 'early adopter'&quot; distribution of Perl 6 (called Rakudo Star) in July of 2010. Please see &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; for more information.</source>
          <target state="translated">현재 Rakudo Perl 6의 주요 구현은 2010 년 7 월에 Perl 6 (Rakudo Star라고 함)의 &quot;유용하고 사용 가능하며 초기 얼리 어답터&quot;배포판을 발표했습니다. 자세한 내용은 &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="translated">현재 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="cf758edb971b2b4dec99794c86a54d09eddea2b6" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;.</source>
          <target state="translated">현재 로케일은 가능한 &lt;code&gt;LC_NUMERIC&lt;/code&gt; (다음 단락에서 설명)를 제외하고 XS 코드에 노출됩니다 . 다른 범주에 대한 문제에 대한보고가 없습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ Perl은 시작시 항목을 초기화하여 현재 로케일이 해당 시점에 유효한 사용자 환경에 의해 표시되는 로케일이되도록합니다. &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;perllocale의 &quot;ENVIRONMENT&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22d3f495bb4240a9d3bab6ec75da601351d12c2b" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT in perllocale&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; (다음 단락에서 설명)를 제외하고 현재 로케일이 XS 코드에 노출됩니다 . 다른 범주에 대한 문제는보고되지 않았습니다. Perl은 현재 로케일이 당시 사용자 환경에 의해 표시되는 로케일이되도록 시작시 사물을 초기화합니다. &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;perllocale의 환경을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e14b6dd5c0c60379e0f9fc4367987da9456c3d" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional and Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">현재 로케일은 아래 설명 된 &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()에&lt;/a&gt; 의해 실행 시간에 설정 됩니다. 해당 함수가 프로그램 실행 과정에서 아직 호출되지 않은 경우 현재 로케일은 프로그램 시작시 유효한 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; 에 의해 결정된 것 입니다. 유효한 환경이없는 경우 현재 로케일은 시스템 기본값이 설정되어 있습니다. POSIX 시스템에서는 &quot;C&quot;로케일 일 가능성이 있지만 반드시 그런 것은 아닙니다. Windows에서 기본값은 컴퓨터의 &lt;code&gt;Control Panel-&amp;gt;Regional and Language Options&lt;/code&gt; (또는 현재 동등한 옵션)을 통해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="061c069ca3fcc48e2c1a6a5055f7be81ca6838c7" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">현재 로케일은 아래 설명 된 &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()에&lt;/a&gt; 의해 실행시 설정 됩니다. 프로그램 실행 과정에서 해당 함수가 아직 호출되지 않은 경우 현재 로케일은 프로그램 시작시 유효한 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 에 의해 결정된 것 입니다. 유효한 환경이 없으면 현재 로케일은 시스템 기본값이 설정된 값입니다. POSIX 시스템에서는 &quot;C&quot;로캘 일 수 있지만 반드시 그런 것은 아닙니다. Windows의 경우, 기본값은 컴퓨터의 &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (또는 이에 상응하는 기능)을 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f42f27fb52f98cb07c551fabc648053a689c30" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;functions/system&quot;&gt;system LIST&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">현재 로케일은 로케일 구분 &lt;a href=&quot;functions/system&quot;&gt;시스템&lt;/a&gt; 인 경우 시스템 LIST 또는 &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx //&lt;/a&gt; 와 같은 조작으로 Perl 외부로 갈 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="69e663f7c7a676b0d28d32e89828d9474ab1d29d" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;system()&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">현재 로케일은 &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;system ()&lt;/a&gt; 또는 &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;qx //&lt;/a&gt; 와 같은 작업으로 Perl 외부로 이동할 때 사용됩니다 ( 해당 작업이 로케일에 민감한 경우).</target>
        </trans-unit>
        <trans-unit id="ea51628874f50840c20248e49e31ecc39bc8aab0" translate="yes" xml:space="preserve">
          <source>The current major release of Perl is Perl 5, first released in 1994. It can run scripts from the previous major release, Perl 4 (March 1991), but has significant differences.</source>
          <target state="translated">Perl의 현재 주요 릴리스는 1994 년에 처음 릴리스 된 Perl 5입니다. 이전 주요 릴리스 인 Perl 4 (1991 년 3 월)에서 스크립트를 실행할 수 있지만 상당한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad75b57a59621fb77288b117b229032ac9f513f" translate="yes" xml:space="preserve">
          <source>The current naming convention is:</source>
          <target state="translated">현재 명명 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2e2b3b69c2218e4d8359acb1335a4024632d82a" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt; ) is restored at the end of</source>
          <target state="translated">Perl 내부 스택 ( &lt;code&gt;SP&lt;/code&gt; 참조 ) 의 현재 오프셋 은</target>
        </trans-unit>
        <trans-unit id="6ab9fb3b5f482c273ca6d801c743b02bcacec72c" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt;) is restored at the end of</source>
          <target state="translated">Perl 내부 스택 ( &lt;code&gt;SP&lt;/code&gt; 참조 ) 의 현재 오프셋 은</target>
        </trans-unit>
        <trans-unit id="c030186501458b34adb46e2d42aa7b81f218a056" translate="yes" xml:space="preserve">
          <source>The current page length (printable lines) of the currently selected output channel. The default is 60.</source>
          <target state="translated">현재 선택된 출력 채널의 현재 페이지 길이 (인쇄 가능한 라인). 기본값은 60입니다.</target>
        </trans-unit>
        <trans-unit id="3d4eb19bb10369473283d32cc7dd71a86ff46c90" translate="yes" xml:space="preserve">
          <source>The current page number of the currently selected output channel.</source>
          <target state="translated">현재 선택된 출력 채널의 현재 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="770296232bd3d822ead8ffe492b7e0e282b9f95e" translate="yes" xml:space="preserve">
          <source>The current phase of the perl interpreter.</source>
          <target state="translated">펄 인터프리터의 현재 단계.</target>
        </trans-unit>
        <trans-unit id="2864f23a19f0c83d2f66d97a56cf54892b44918f" translate="yes" xml:space="preserve">
          <source>The current process identifier is normally also available via the predefined $$ variable. Under fork() emulation however $$ may contain a pseudo-process identifier that is only meaningful to the Perl kill(), wait() and waitpid() functions. The Win32::GetCurrentProcessId() function will always return the regular Windows process id, even when called from inside a pseudo-process.</source>
          <target state="translated">현재 프로세스 식별자는 일반적으로 사전 정의 된 $$ 변수를 통해서도 사용할 수 있습니다. 그러나 fork () 에뮬레이션에서 $$는 Perl kill (), wait () 및 waitpid () 함수에만 의미있는 의사 프로세스 식별자를 포함 할 수 있습니다. Win32 :: GetCurrentProcessId () 함수는 의사 프로세스 내부에서 호출 된 경우에도 항상 일반 Windows 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2857cd700aaf0537f04949257bdb10786ea5148" translate="yes" xml:space="preserve">
          <source>The current set of characters after which a string may be broken to fill continuation fields (starting with &lt;code&gt;^&lt;/code&gt;) in a format. The default is &quot; \n-&quot;, to break on a space, newline, or a hyphen.</source>
          <target state="translated">문자열이 연속 필드 ( &lt;code&gt;^&lt;/code&gt; 로 시작)를 채우 도록 형식화 한 후의 현재 문자 세트입니다 . 공백, 줄 바꿈 또는 하이픈을 나누려면 기본값은 &quot;\ n-&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d0bc78c2888afaf94160d8cd4bd4fdc74663bf04" translate="yes" xml:space="preserve">
          <source>The current set of official keys is:</source>
          <target state="translated">현재 공식 키 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="981300e195cac4e7353f833304330d8ac58b67a9" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma에 의해 사용 가능한 현재 경고 점검 세트 . &lt;code&gt;$^H&lt;/code&gt; 및 &lt;code&gt;%^H&lt;/code&gt; 변수 와 동일한 범위를 갖습니다 . 정확한 값은 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; pragma 내부에있는 것으로 간주되며 Perl 버전간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff870c28a76abb15c6ef8bc6c01da1732cfc87c" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;use warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">&lt;code&gt;use warnings&lt;/code&gt; pragma에 의해 활성화 된 현재 경고 확인 집합입니다 . &lt;code&gt;$^H&lt;/code&gt; 및 &lt;code&gt;%^H&lt;/code&gt; 변수 와 동일한 범위를 갖습니다 . 정확한 값은 &lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; pragma 내부로 간주되며 Perl 버전간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e48b124af22e055d2f998460eddfa2b05c504d05" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;.</source>
          <target state="translated">특정 CV의 현재 설정은 &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt; 로 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="043e73127d721a29085be4df3900bb1371bf6328" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;.</source>
          <target state="translated">특정 CV에 대한 현재 설정은 &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt; 로 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b952480064e555e874a4e5bab67374e0afa43170" translate="yes" xml:space="preserve">
          <source>The current state is quite close to this target. Known limitations:</source>
          <target state="translated">현재 상태는이 목표에 매우 가깝습니다. 알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="ba6118e27828276e003be0b716e1e27e35775418" translate="yes" xml:space="preserve">
          <source>The current time, hires or not.</source>
          <target state="translated">현재 시간, 고용 여부.</target>
        </trans-unit>
        <trans-unit id="c893fdb58e68676d453e9772eca0458d9ee9ef15" translate="yes" xml:space="preserve">
          <source>The current value giving the maximum number of open but unclosed parenthetical groups there may be at any point during a regular expression compilation. The default is currently 1000 nested groups. You may adjust it depending on your needs and the amount of memory available.</source>
          <target state="translated">열려 있지만 닫히지 않은 괄호 그룹의 최대 수를 제공하는 현재 값은 정규식 컴파일 중 언제든지있을 수 있습니다. 기본값은 현재 1000 개의 중첩 된 그룹입니다. 필요와 사용 가능한 메모리 양에 따라 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc73114057d5a2e203bbe1e6af0220ea5c0d6452" translate="yes" xml:space="preserve">
          <source>The current value of &lt;a href=&quot;perlvar#%24%2C&quot;&gt;&lt;code&gt;$,&lt;/code&gt;&lt;/a&gt; (if any) is printed between each LIST item. The current value of &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt;, but that doesn't look as good).</source>
          <target state="translated">&lt;a href=&quot;perlvar#%24%2C&quot;&gt; &lt;code&gt;$,&lt;/code&gt; &lt;/a&gt; 의 현재 값 (있는 경우)이 각 LIST 항목 사이에 인쇄됩니다. &lt;a href=&quot;perlvar#%24%5C&quot;&gt; &lt;code&gt;$\&lt;/code&gt; &lt;/a&gt; 의 현재 값 (있는 경우)은 전체 LIST가 인쇄 된 후 인쇄됩니다. 인쇄 목록을 소요하기 때문에, LIST의 어떤 누구의 반환 목록 당신이 전달되는 서브 루틴을 포함하여,리스트 컨텍스트에서 평가 &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; . 해당 오른쪽 괄호가 인쇄에 대한 인수를 종료하지 않도록하려면 print 키워드 뒤에 왼쪽 괄호를 사용하지 않도록주의하십시오. 모든 인수를 괄호로 묶습니다 (또는 &lt;code&gt;+&lt;/code&gt; 를 삽입 하지만 좋지 않은 것 같습니다).</target>
        </trans-unit>
        <trans-unit id="8b45957d0c48ff5a61159add09d1cced4fe06354" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">각 LIST 항목 사이 에 &lt;code&gt;$,&lt;/code&gt; 의 현재 값 (있는 경우)이 인쇄됩니다. 전체 LIST가 인쇄 된 후 &lt;code&gt;$\&lt;/code&gt; (있는 경우) 의 현재 값 이 인쇄됩니다. print는 LIST를 가져 오기 때문에 리턴 목록을 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 로 전달하는 서브 루틴을 포함하여 LIST의 모든 내용이 목록 컨텍스트에서 평가됩니다 . 해당 오른쪽 괄호로 인쇄 인수를 종료하지 않으려면 print 키워드 뒤에 왼쪽 괄호를 붙이지 않도록주의하십시오. 모든 인수 주위에 괄호를 넣으십시오 (또는 &lt;code&gt;+&lt;/code&gt; 를 넣으십시오 . 그러나 좋지 않습니다).</target>
        </trans-unit>
        <trans-unit id="d3b381c8d22a96ce946901e90864741d92df1af5" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">각 LIST 항목 사이 에 &lt;code&gt;$,&lt;/code&gt; 의 현재 값 (있는 경우)이 인쇄됩니다. 전체 LIST가 인쇄 된 후 &lt;code&gt;$\&lt;/code&gt; (있는 경우) 의 현재 값 이 인쇄됩니다. print는 LIST를 가져 오기 때문에 리턴 목록을 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 로 전달하는 서브 루틴을 포함하여 LIST의 모든 내용이 목록 컨텍스트에서 평가됩니다 . 해당 오른쪽 괄호로 인쇄 인수를 종료하지 않으려면 print 키워드 뒤에 왼쪽 괄호를 붙이지 않도록주의하십시오. 모든 인수 주위에 괄호를 넣으십시오 (또는 &lt;code&gt;+&lt;/code&gt; 를 넣으십시오 . 그러나 좋지 않습니다).</target>
        </trans-unit>
        <trans-unit id="16a7c40e8bbfe13e91d735da741af8520eabede2" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$archname&lt;/code&gt; can be found with this command:</source>
          <target state="translated">&lt;code&gt;$archname&lt;/code&gt; 의 현재 값은 다음 명령으로 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db4a25bfed587546962de5c8d6543f967c92521a" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; accumulator for &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; lines. A format contains &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt; . After calling its format, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE,LIST&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; 행에 대한 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 누산기 의 현재 값입니다 . 형식에는 결과를 &lt;code&gt;$^A&lt;/code&gt; 넣는 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 호출이 포함 됩니다. 형식을 호출 한 후 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;$^A&lt;/code&gt; 의 내용을 인쇄 하고 비 웁니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; 직접 호출하지 않으면 &lt;code&gt;$^A&lt;/code&gt; 의 내용을 실제로 볼 수 없습니다 . &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 및 &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE, LIST를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf446124f3a4c45cac5e41b4dd3df5f6adedf891" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;write()&lt;/code&gt; accumulator for &lt;code&gt;format()&lt;/code&gt; lines. A format contains &lt;code&gt;formline()&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt;. After calling its format, &lt;code&gt;write()&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;formline()&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;perlfunc#formline-PICTURE%2CLIST&quot;&gt;&quot;formline PICTURE,LIST&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;format()&lt;/code&gt; 행에 대한 &lt;code&gt;write()&lt;/code&gt; 누산기 의 현재 값입니다 . 형식에는 결과를 &lt;code&gt;$^A&lt;/code&gt; 넣는 &lt;code&gt;formline()&lt;/code&gt; 호출이 포함 됩니다. 형식을 호출 한 후 &lt;code&gt;write()&lt;/code&gt; 는 &lt;code&gt;$^A&lt;/code&gt; 의 내용을 인쇄 하고 비 웁니다. 따라서 &lt;code&gt;formline()&lt;/code&gt; 직접 호출 하여 살펴 보지 않는 한 &lt;code&gt;$^A&lt;/code&gt; 의 내용을 실제로 볼 수 없습니다 . &lt;a href=&quot;perlfunc#formline-PICTURE%2CLIST&quot;&gt;perlfunc의 &lt;/a&gt;&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; 및 &quot;formline PICTURE, LIST&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08cef4c84f23112c510335f5bb9c61930fcb65b7" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its &lt;a href=&quot;perlrun#-Dletters&quot;&gt;command-line equivalent&lt;/a&gt;, you can use numeric or symbolic values, e.g. &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt;. See &lt;a href=&quot;perlrun#-Dnumber&quot;&gt;&quot;&lt;b&gt;-D&lt;/b&gt;&lt;i&gt;number&lt;/i&gt;&quot; in perlrun&lt;/a&gt;. The contents of this variable also affects the debugger operation. See &lt;a href=&quot;perldebguts#Debugger-Internals&quot;&gt;&quot;Debugger Internals&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="translated">디버깅 플래그의 현재 값입니다. 읽거나 설정할 수 있습니다. 해당 &lt;a href=&quot;perlrun#-Dletters&quot;&gt;명령 줄과&lt;/a&gt; 마찬가지로 숫자 또는 기호 값을 사용할 수 있습니다 (예 : &lt;code&gt;$^D = 10&lt;/code&gt; 또는 &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; . &lt;a href=&quot;perlrun#-Dnumber&quot;&gt;perlrun의 &lt;/a&gt;&quot; &lt;b&gt;-D &lt;/b&gt;&lt;i&gt;number&lt;/i&gt; &quot;를 참조하십시오 . 이 변수의 내용은 디버거 작업에도 영향을줍니다. &lt;a href=&quot;perldebguts#Debugger-Internals&quot;&gt;perldebguts의 &quot;디버거 내부&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed07dc52d8f87fe5efbcd1795acd592cb2bcdd55" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its command-line equivalent, you can use numeric or symbolic values, eg &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</source>
          <target state="translated">디버깅 플래그의 현재 값입니다. 읽거나 설정할 수 있습니다. 해당 명령 줄과 마찬가지로 숫자 또는 기호 값을 사용할 수 있습니다 (예 : &lt;code&gt;$^D = 10&lt;/code&gt; 또는 &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761048a9f6779920117c38b6975281ec2824cbaa" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;-c&lt;/b&gt; 스위치 와 연관된 플래그의 현재 값 일반적으로 &lt;b&gt;-MO = ...&lt;/b&gt; 와 함께 사용하여 코드가 컴파일 될 때 동작을 변경하도록 허용합니다 (예 : 정상 지연로드가 아닌 컴파일 시간 에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 로). &lt;code&gt;$^C = 1&lt;/code&gt; 설정 은 &lt;code&gt;B::minus_c&lt;/code&gt; 호출과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="8dafa28f68632a10855a57c5eacb6743b86c198f" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;-c&lt;/b&gt; 스위치 와 연관된 플래그의 현재 값 . 주로 &lt;b&gt;-MO = ...&lt;/b&gt; 와 함께 사용하여 코드가 컴파일 될 때 동작을 변경할 수 있도록합니다 (예 : 정상적인 지연로드가 아닌 컴파일 타임 에 &lt;code&gt;AUTOLOAD&lt;/code&gt; 로 변경). &lt;code&gt;$^C = 1&lt;/code&gt; 설정 은 &lt;code&gt;B::minus_c&lt;/code&gt; 호출과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="5468ce0ac69ee02e09a591df294df02b8e8e00dd" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">내부 편집 확장의 현재 값입니다. 전체 편집을 비활성화 하려면 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb25a57f6557411f85b4814f0d93efdbea2e3515" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;undef&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">inplace-edit 확장의 현재 값입니다. 내부 편집을 비활성화 하려면 &lt;code&gt;undef&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab0d30902e8f62034444f0c46f34be59caec65d2" translate="yes" xml:space="preserve">
          <source>The current value of the regex debugging flags. Set to 0 for no debug output even when the &lt;code&gt;re 'debug'&lt;/code&gt; module is loaded. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for details.</source>
          <target state="translated">정규식 디버깅 플래그의 현재 값입니다. &lt;code&gt;re 'debug'&lt;/code&gt; 모듈이로드 된 경우에도 디버그 출력이 없으면 0으로 설정하십시오 . 자세한 내용은 &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a22922d7a166dbc35ec6d0a0c534fd11892caf1b" translate="yes" xml:space="preserve">
          <source>The current value of the warning switch, initially true if &lt;b&gt;-w&lt;/b&gt; was used, false otherwise, but directly modifiable.</source>
          <target state="translated">경고 스위치의 현재 값으로, &lt;b&gt;-w&lt;/b&gt; 가 사용 된 경우 처음에는 true이고 , 그렇지 않으면 false이지만 직접 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="434ca8d76bd8ecc27a064789f98b19395ab4f212" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 표준의 최신 버전은 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b563eb1b6cfef1294ee2d2ec105a8fc001fb852" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;atan2&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;atan2&lt;/code&gt; 에 대한 최신 버전의 표준 은 &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6af70deb3b449e89c48e84135fbdeb7d79f07a9c" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 모듈의 현재 버전은 항상 웹 사이트 ( &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/)&lt;/a&gt; 에서 사용 가능 합니다. 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="b31c3cebc8faae4e8a4925e48535264d89073d95" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 현재 버전은 항상 웹 사이트 ( &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="f5a8854edfd01b7a5e559e1a5294ccbba9d0afe6" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 모듈의 현재 버전은 항상 웹 사이트 ( &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 사용 가능 합니다. 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="cbd165143fe6d4a52227133b4ee1638e509ed516" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;https://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 모듈의 현재 버전은 웹 사이트 ( &lt;a href=&quot;https://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;https://www.eyrie.org/~eagle/software/ansicolor/)&lt;/a&gt; 에서 항상 사용할 수 있습니다 . 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="a674a12f3426ba3d689c7c921dc0c45b179571fc" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 최신 버전은 웹 사이트 ( &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 항상 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9c2bb6087cce8c28cf4e7d17487f87fbaa02086" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 모듈의 최신 버전은 웹 사이트 ( &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 항상 사용할 수 있습니다 . 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="c47cd4fd8d9bd245ee61848360efac4088607cb6" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 스크립트의 현재 버전은 웹 사이트 ( &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 항상 구할 수 있습니다 . 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="7b5c546ea518bb4350e7bf7b54f3310abe5cc06c" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">이 스크립트의 현재 버전은 웹 사이트 ( &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/)&lt;/a&gt; 에서 항상 사용할 수 있습니다 . 또한 5.6.0부터 Perl 코어 배포의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="9d8fe5626c6979a9718f106c0652b7d905296f64" translate="yes" xml:space="preserve">
          <source>The current version was written by Graham Barr.</source>
          <target state="translated">현재 버전은 Graham Barr에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c32f08e82229236d88693ec9eaad5ec8a635209" translate="yes" xml:space="preserve">
          <source>The current working directory of the program is</source>
          <target state="translated">프로그램의 현재 작업 디렉토리는</target>
        </trans-unit>
        <trans-unit id="403572c903ddf0d90233f3ad9327b2e78dc32883" translate="yes" xml:space="preserve">
          <source>The currently active COP (control op) roughly representing the current statement in the source.</source>
          <target state="translated">소스의 현재 명령문을 대략적으로 나타내는 현재 활성 COP (control op)입니다.</target>
        </trans-unit>
        <trans-unit id="588f5e820c106e9822f858102bdf0e7ae9b574c7" translate="yes" xml:space="preserve">
          <source>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</source>
          <target state="translated">파일의 모든 줄을 처리하기위한 일반적인 Perl 방식은 한 번에 한 줄씩 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4504c4a63cdd557da723133c8d2b75666dc8630" translate="yes" xml:space="preserve">
          <source>The cwd() is the most natural form for the current architecture. For most systems it is identical to `pwd` (but without the trailing line terminator).</source>
          <target state="translated">cwd ()는 현재 아키텍처에서 가장 자연스러운 형태입니다. 대부분의 시스템에서 그것은`pwd`와 동일하다 (그러나 후행 터미네이터는 없다).</target>
        </trans-unit>
        <trans-unit id="40c9ebfbdf9a557c5ad182c1d60f03fd99fa74ef" translate="yes" xml:space="preserve">
          <source>The data argument passes in the value (if any) associated with the attribute. For example, if &lt;code&gt;&amp;amp;foo&lt;/code&gt; had been declared:</source>
          <target state="translated">데이터 인수는 속성과 연관된 값 (있는 경우)을 전달합니다. 예를 들어, &lt;code&gt;&amp;amp;foo&lt;/code&gt; 가 선언 된 경우 :</target>
        </trans-unit>
        <trans-unit id="4057a2800ea2edef8acd376fce4a738947ca16f2" translate="yes" xml:space="preserve">
          <source>The data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.</source>
          <target state="translated">특히 각 집계에 많은 양의 데이터가있는 경우 데이터를 명확한 구조로 집계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1737bbb402e005395886a66a62fefd166798f8a" translate="yes" xml:space="preserve">
          <source>The data is stored as a list of values from the time and times functions:</source>
          <target state="translated">데이터는 시간 및 시간 함수의 값 목록으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="083ecdb4eb83b1283f9d7370b6905eb300e214e7" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">바이트 스트림의 기본 유형이 알려진 경우 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 기능을 사용하여 데이터를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71f7b6c4c962003ad0e8bfcff7666dfb17bf3d56" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;unpack&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">데이터는 바이트 스트림의 기본 유형이 알려진 경우 &lt;code&gt;unpack&lt;/code&gt; 함수를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63af91535a394b6aa4a43c6ecef621c3c5bffb80" translate="yes" xml:space="preserve">
          <source>The data of the file is not immediately available. This attribute indicates that the file data has been physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</source>
          <target state="translated">파일의 데이터는 즉시 사용할 수 없습니다. 이 속성은 파일 데이터가 오프라인 저장소로 물리적으로 이동되었음을 나타냅니다. 이 속성은 계층 적 스토리지 관리 소프트웨어 인 원격 스토리지에서 사용됩니다. 응용 프로그램은이 속성을 임의로 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb2c0f943e4592858ab2d05373119174b2d2dda" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt; , so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">데이터가 유니 코드 문자열로 추가되어 디스크에 쓸 때 &lt;code&gt;Archive::Tar&lt;/code&gt; 의해 &lt;code&gt;:utf8&lt;/code&gt; 라인 규칙이 설정되지 않았 으므로 Perl은 문자열을 ISO-8859로 변환하려고했으나 실패했습니다. 작성된 파일은 이제 가비지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a586674f2132d76d932dd3ae8f2556dfbebc1fb6" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt;, so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">데이터는 유니 코드 문자열로 추가되었으며 디스크에 쓸 때 &lt;code&gt;:utf8&lt;/code&gt; 행 규칙이 &lt;code&gt;Archive::Tar&lt;/code&gt; 의해 설정되지 않았 으므로 Perl은 문자열을 ISO-8859로 변환하려고 시도했지만 실패했습니다. 이제 작성된 파일에 쓰레기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="93ccb288f67ba8fe0c8510721b3e70886d45432a" translate="yes" xml:space="preserve">
          <source>The date and day names in dates formatted by &lt;code&gt;strftime()&lt;/code&gt; could be manipulated to advantage by a malicious user able to subvert the &lt;code&gt;LC_DATE&lt;/code&gt; locale. (&quot;Look--it says I wasn't in the building on Sunday.&quot;)</source>
          <target state="translated">&lt;code&gt;strftime()&lt;/code&gt; 형식화 된 날짜의 날짜 및 요일 이름 은 &lt;code&gt;LC_DATE&lt;/code&gt; 로케일 을 파괴 할 수있는 악의적 인 사용자에 의해 조작 될 수 있습니다 . ( &quot;저는 일요일에 건물에 없었다고 말합니다.&quot;)</target>
        </trans-unit>
        <trans-unit id="c40b16f78ce75cc859be91a0613f27d3f68c2364" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; function. Without an argument &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; uses the current time.</source>
          <target state="translated">일의 날짜는 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 함수가 리턴 한 목록에 있습니다. 인수없이 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 은 현재 시간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1c7a95dfcca9858a8405f98faf2612dd1935a1f7" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;localtime&lt;/code&gt; function. Without an argument &lt;code&gt;localtime&lt;/code&gt; uses the current time.</source>
          <target state="translated">날짜는 &lt;code&gt;localtime&lt;/code&gt; 함수에서 반환 된 목록에 있습니다. 인수없이 &lt;code&gt;localtime&lt;/code&gt; 은 현재 시간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="32d7e957f2b60e8e8af1a45f78007f3a710223c2" translate="yes" xml:space="preserve">
          <source>The days of just flinging strings around are over. It's well established that modern programs need to be capable of communicating funny accented letters, and things like euro symbols. This means that programmers need new habits. It's easy to program Unicode capable software, but it does require discipline to do it right.</source>
          <target state="translated">현을 넘기는 시대는 끝났습니다. 현대 프로그램은 재미있는 악센트 문자와 유로 기호와 같은 것을 전달할 수 있어야한다는 것이 잘 확립되어 있습니다. 이것은 프로그래머에게 새로운 습관이 필요하다는 것을 의미합니다. 유니 코드 가능 소프트웨어를 프로그래밍하는 것은 쉽지만 제대로하려면 훈련이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7d9856be0d4d4aa47742843ac8ee15803c0a6dbf" translate="yes" xml:space="preserve">
          <source>The debugger does not currently work in conjunction with the &lt;b&gt;-W&lt;/b&gt; command-line switch, because it itself is not free of warnings.</source>
          <target state="translated">디버거 자체에는 경고 가 없으므로 현재 &lt;b&gt;-W&lt;/b&gt; 명령 줄 스위치 와 함께 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bff20683f233c3b1a43e85dddcc26c68e9457e08" translate="yes" xml:space="preserve">
          <source>The debugger has numerous options settable using the &lt;code&gt;o&lt;/code&gt; command, either interactively or from the environment or an rc file. (./.perldb or ~/.perldb under Unix.)</source>
          <target state="translated">디버거에는 대화식으로 또는 환경 또는 rc 파일에서 &lt;code&gt;o&lt;/code&gt; 명령을 사용하여 설정할 수있는 수많은 옵션이 있습니다 . (UNIX에서 ./.perldb 또는 ~ / .perldb)</target>
        </trans-unit>
        <trans-unit id="2b8f02d76c62b5ac783a580e7846d6536aa86d85" translate="yes" xml:space="preserve">
          <source>The debugger probably contains enough configuration hooks that you won't ever have to modify it yourself. You may change the behaviour of the debugger from within the debugger using its &lt;code&gt;o&lt;/code&gt; command, from the command line via the &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable, and from customization files.</source>
          <target state="translated">디버거에는 아마도 직접 구성 할 필요가없는 충분한 구성 후크가 포함되어있을 것입니다. &lt;code&gt;o&lt;/code&gt; 명령을 사용하여 디버거 내에서 , &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 환경 변수 를 통해 명령 행 에서, 사용자 정의 파일에서 디버거의 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24bc00b2a7165b041b9ffd101df7fc63fd2218dd" translate="yes" xml:space="preserve">
          <source>The debugger prompt is something like</source>
          <target state="translated">디버거 프롬프트는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="f8e855d0dba7087b2dc163f59ea22e7610600301" translate="yes" xml:space="preserve">
          <source>The debugging output at compile time looks like this:</source>
          <target state="translated">컴파일시 디버깅 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cc26823ddc27c25d44117d4b49405e558f3683c" translate="yes" xml:space="preserve">
          <source>The declared variable is not introduced (is not visible) until after the current statement. Thus,</source>
          <target state="translated">선언 된 변수는 현재 명령문 이후까지 소개되지 않습니다 (표시되지 않음). 그러므로,</target>
        </trans-unit>
        <trans-unit id="9ae51c467cb04a1b525475d0b1964978fbf97d39" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; as described above; interrupted &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">기본 &lt;code&gt;:perlio&lt;/code&gt; 레이어 는 위에서 설명한대로 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 를 재 시도합니다 . 중단 된 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 를 호출은 항상 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="cc07a8196664bfcb190df25e9665ffed3bb1d528" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; as described above; interrupted &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">기본 &lt;code&gt;:perlio&lt;/code&gt; 레이어 는 위에서 설명한대로 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;close&lt;/code&gt; 를 재 시도합니다 . 중단 된 &lt;code&gt;wait&lt;/code&gt; 및 &lt;code&gt;waitpid&lt;/code&gt; 호출은 항상 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="7af57631245798d230b9a42590aed5504edc7411" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">기본 &lt;code&gt;TIEHASH&lt;/code&gt; 메서드는 &quot;extra&quot;인수를 &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; 의해 참조되는 배열에서 오프셋 1부터 시작하여 tie ()에 저장합니다 . 이것은 위의 TIEHASH 서브 루틴에서와 동일한 스토리지 알고리즘입니다. 따라서 &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속 된 일반적인 패키지 는이 메소드를 덮어 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8f318f7bfa1b89c48af52e1a8f99d1af186c96f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;tied(%tiedhash)&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">기본 &lt;code&gt;TIEHASH&lt;/code&gt; 메서드는 &lt;code&gt;tied(%tiedhash)&lt;/code&gt; 참조하는 배열의 오프셋 1부터 시작하여 tie ()에 &quot;추가&quot;인수를 저장합니다 . 이것은 위의 TIEHASH 서브 루틴에서와 동일한 저장 알고리즘입니다. 따라서 &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; 에서 상속 된 일반적인 패키지 는이 메서드를 덮어 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5e1aaf469c61ad0505179ca4ef693920d67bf62" translate="yes" xml:space="preserve">
          <source>The default behavior for matching can be changed, using various modifiers. Modifiers that relate to the interpretation of the pattern are listed just below. Modifiers that alter the way a pattern is used by Perl are detailed in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">다양한 수정자를 사용하여 일치에 대한 기본 동작을 변경할 수 있습니다. 패턴 해석과 관련된 수정자는 바로 아래에 나열되어 있습니다. Perl에서 패턴이 사용되는 방식을 변경하는 수정자는 &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop의 &quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; 및 perlop의 &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;인용 된 구문 구문 분석의 Gory 세부 사항&quot;에 자세히 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bacf1d67275db56db4c207815d6942a42814176" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">기본 동작은과 복원 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 프라그 또는 블록 둘러싸의 마지막에 도달 할 때 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . 주 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 호출을 중첩하고, 내부 범위의 끝에서 바깥 쪽 범위의 규칙으로 돌아갑니다 내부 범위 내에서 적용되는 어떤 것을 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7e3af61d974b45e2899ef4868c4839bde44f6b43" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;no locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;use locale&lt;/code&gt;. Note that &lt;code&gt;use locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">기본 동작은 &lt;code&gt;no locale&lt;/code&gt; pragma를 사용하거나 &lt;code&gt;use locale&lt;/code&gt; 을 포함하는 블록 끝에 도달하면 복원 됩니다 . 참고 &lt;code&gt;use locale&lt;/code&gt; 호출은 중첩 및 내부 범위의 끝에서 바깥 쪽 범위의 규칙으로 돌아갑니다 내부 범위 내에서 적용되는 어떤 것을 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ebc252c3cc028e1614732f1daa492845981dc49a" translate="yes" xml:space="preserve">
          <source>The default behavior is to allow either VMS or Unix syntax on input and to return VMS syntax on output unless Unix syntax has been explicitly requested via the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL feature.</source>
          <target state="translated">기본 동작은 &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL 기능을 통해 Unix 구문이 명시 적으로 요청되지 않은 경우 입력시 VMS 또는 Unix 구문을 허용하고 출력에서 ​​VMS 구문을 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d9abf79a3fe513de5ab5f6341a0a6954a2315c50" translate="yes" xml:space="preserve">
          <source>The default behaviour for what</source>
          <target state="translated">무엇에 대한 기본 동작</target>
        </trans-unit>
        <trans-unit id="6dccc7bf2df4ee545fc6ed04ddf3f01c1358bdf3" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">파일 테스트 연산자의 기본 동작은 stat () 시스템 호출 제품군에서 반환 된 단순 모드 비트를 사용하는 것입니다. 그러나 많은 운영 체제에는 ACL (액세스 제어 목록)과 같이보다 복잡한 액세스 권한을 정의하는 추가 기능이 있습니다. 이러한 환경에서 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 하면 권한 연산자가 다른 도구와보다 일관된 결과를 반환하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1be0363bbe710d46dddb1e57d79fb15e7183b86" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;use filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">파일 테스트 연산자의 기본 동작은 stat () 계열의 시스템 호출에 의해 반환 된 단순 모드 비트를 사용하는 것입니다. 그러나 많은 운영 체제에는 ACL (액세스 제어 목록)과 같이보다 복잡한 액세스 권한을 정의하는 추가 기능이 있습니다. 이러한 환경의 &lt;code&gt;use filetest&lt;/code&gt; 하면 권한 연산자가 다른 도구와보다 일관된 결과를 반환하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f3d08e8e13d1af1b8292d5961459da70c0fafa4" translate="yes" xml:space="preserve">
          <source>The default blacklist for Locale::Maketext also prevents use of the following methods in bracket notation:</source>
          <target state="translated">Locale :: Maketext에 대한 기본 블랙리스트는 또한 대괄호 표기법으로 다음 방법을 사용하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1e443bdcb2163a4573139a1dc139dfc380443bd8" translate="yes" xml:space="preserve">
          <source>The default blacklist is [qw|ftp|], as &lt;code&gt;/bin/ftp&lt;/code&gt; is rather unreliable.</source>
          <target state="translated">&lt;code&gt;/bin/ftp&lt;/code&gt; 는 다소 신뢰할 수 없으므로 기본 블랙리스트는 [qw | ftp |] 입니다.</target>
        </trans-unit>
        <trans-unit id="ed0767b7e5643475189138ab836319b55629d878" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
          <target state="translated">기본 버퍼 크기는 4096입니다.</target>
        </trans-unit>
        <trans-unit id="8bc00fd19b1a0edf6b2c0d08377dcc6685c37357" translate="yes" xml:space="preserve">
          <source>The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&lt;code&gt;unix&lt;/code&gt; or platform low level layer is always pushed first).</source>
          <target state="translated">환경 변수 PERLIO를 공백으로 구분 된 계층 목록으로 설정하여 기본값을 대체 할 수 있습니다 ( &lt;code&gt;unix&lt;/code&gt; 또는 플랫폼 하위 레벨 계층이 항상 먼저 푸시 됨).</target>
        </trans-unit>
        <trans-unit id="34b91bbcac281ec343e20574aee63c504ba37c87" translate="yes" xml:space="preserve">
          <source>The default command shells on DOS descendant operating systems (such as they are) usually do not expand wildcard arguments supplied to programs. They consider it the application's job to handle that. This is commonly achieved by linking the application (in our case, perl) with startup code that the C runtime libraries usually provide. However, doing that results in incompatible perl versions (since the behavior of the argv expansion code differs depending on the compiler, and it is even buggy on some compilers). Besides, it may be a source of frustration if you use such a perl binary with an alternate shell that *does* expand wildcards.</source>
          <target state="translated">DOS 하위 운영 ​​체제 (예 : 운영 체제)의 기본 명령 쉘은 일반적으로 프로그램에 제공된 와일드 카드 인수를 확장하지 않습니다. 그들은 그것을 처리하는 것이 응용 프로그램의 일이라고 생각합니다. 이는 일반적으로 애플리케이션 (이 경우 perl)을 C 런타임 라이브러리가 일반적으로 제공하는 시작 코드와 연결하여 수행됩니다. 그러나 argv 확장 코드의 동작이 컴파일러에 따라 다르기 때문에 일부 컴파일러에서는 버그가 있기 때문에 그렇게하면 호환되지 않는 perl 버전이 생성됩니다. 또한 와일드 카드를 확장하는 대체 쉘과 같은 펄 바이너리를 사용하면 좌절의 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83afe3e15499ebffd14384524a4838c21ad9ac57" translate="yes" xml:space="preserve">
          <source>The default delivery policy of signals changed in Perl v5.8.0 from immediate (also known as &quot;unsafe&quot;) to deferred, also known as &quot;safe signals&quot;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more information.</source>
          <target state="translated">신호의 기본 전달 정책은 Perl v5.8.0에서 즉시 ( &quot;안전하지 않은&quot;이라고도 함)에서 &quot;안전한 신호&quot;라고도하는 지연으로 변경되었습니다. 자세한 내용은 &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b1ff51c2db16d895d3583e8ea3357f71cb7399" translate="yes" xml:space="preserve">
          <source>The default directory for this is the &lt;code&gt;plugins/CPAN::Plugin::Specfile&lt;/code&gt; directory in the</source>
          <target state="translated">이에 대한 기본 디렉토리는 다음의 &lt;code&gt;plugins/CPAN::Plugin::Specfile&lt;/code&gt; 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="e779baf9efd4d9532a5adc61d0ecb2fb82fd6ccb" translate="yes" xml:space="preserve">
          <source>The default exports of &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; do a complicated calculation when given a year value less than 1000. This leads to surprising results in many cases. See &lt;a href=&quot;#Year-Value-Interpretation&quot;&gt;&quot;Year Value Interpretation&quot;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;timelocal()&lt;/code&gt; 및 &lt;code&gt;timegm()&lt;/code&gt; 의 기본 내보내기는 1000보다 작은 연도 값을 지정하면 복잡한 계산을 수행합니다. 이로 인해 많은 경우 놀라운 결과가 발생합니다. 자세한 내용은 &lt;a href=&quot;#Year-Value-Interpretation&quot;&gt;&quot;연도 값 해석&quot;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f60de20ca32864441bb2ece16480b765adbc68d5" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">기본 파일 이름 변환은 대략 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f540cdd4f440c064d7b134e9369a41da6337cfdb" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;tr|/.|./|&lt;/code&gt;, swapping dots and slashes.</source>
          <target state="translated">기본 파일 이름 변환은 대략 &lt;code&gt;tr|/.|./|&lt;/code&gt; , 점과 슬래시 교체.</target>
        </trans-unit>
        <trans-unit id="e8b0d8e26001e75f3757789c285eac1caf4919f4" translate="yes" xml:space="preserve">
          <source>The default for &lt;code&gt;$svShare&lt;/code&gt; is &lt;code&gt;&quot;rw&quot;&lt;/code&gt; which provides the same sharing as using regular perl &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;$svShare&lt;/code&gt; 있다 &lt;code&gt;&quot;rw&quot;&lt;/code&gt; 일반 펄 사용하는 것과 동일한 공유 제공 &lt;code&gt;open()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189d94e0a4457922028f86938b0ce7520f054dc0" translate="yes" xml:space="preserve">
          <source>The default for this field, if it cannot be extracted, is to copy &lt;code&gt;$Config{osname}&lt;/code&gt;. The two may be differing in casing (OpenBSD vs openbsd).</source>
          <target state="translated">이 필드의 기본값은 추출 할 수없는 경우 &lt;code&gt;$Config{osname}&lt;/code&gt; 을 복사하는 것 입니다. 둘은 대소 문자가 다를 수 있습니다 (OpenBSD와 openbsd).</target>
        </trans-unit>
        <trans-unit id="141616a08e099cc503e54695ac44f2c439029e1f" translate="yes" xml:space="preserve">
          <source>The default for this option is off.</source>
          <target state="translated">이 옵션의 기본값은 해제입니다.</target>
        </trans-unit>
        <trans-unit id="841e53532f4d336433d317d532f99affc692102b" translate="yes" xml:space="preserve">
          <source>The default hash function has been modified with the intention of making it harder to infer the hash seed.</source>
          <target state="translated">기본 해시 함수는 해시 시드를 추론하기 어렵게하기 위해 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba4a564c2fb984db1b9ac70f6b103f10fd3f2c07" translate="yes" xml:space="preserve">
          <source>The default in Perl 5.8.0 and later is to automatically use the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">Perl 5.8.0 이상에서 기본값은 &lt;code&gt;:perlio&lt;/code&gt; 레이어 를 자동으로 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c5b539403338a04682d5065664097088c7ee8126" translate="yes" xml:space="preserve">
          <source>The default indent space length is three. You can use &lt;code&gt;indent_length&lt;/code&gt; to change the length.</source>
          <target state="translated">기본 들여 쓰기 공간 길이는 3입니다. &lt;code&gt;indent_length&lt;/code&gt; 를 사용하여 길이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c034d8cea0ccefbe74b407c47763a2d7febf85bd" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">프로그램 의 기본 입력 &lt;b&gt;스트림&lt;/b&gt; 으로, 가능한 경우 데이터의 출처를 신경 쓰지 않아야합니다. &lt;b&gt;파일 핸들 &lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; 에 의해 Perl 프로그램 내에서 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="aeb8819256c2fefb2deae155f9c497a4ece2df39" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="translated">프로그램 의 기본 입력 &lt;b&gt;스트림.&lt;/b&gt; 가능하면 데이터가 어디에서 오는지 신경 쓰지 않아야합니다. &lt;b&gt;파일 핸들 &lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; 에 의해 Perl 프로그램 내에서 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c65b453abcd65763f1788a5bfac88b6cf8e06702" translate="yes" xml:space="preserve">
          <source>The default input and pattern-searching space. The following pairs are equivalent:</source>
          <target state="translated">기본 입력 및 패턴 검색 공간. 다음 쌍은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cea52ce10c001ee673712587e9b895266781fd26" translate="yes" xml:space="preserve">
          <source>The default installation directory of Perl under PASE is /QOpenSys/perl. This can be modified if needed with Configure parameter -Dprefix=/some/dir.</source>
          <target state="translated">PASE에서 Perl의 기본 설치 디렉토리는 / QOpenSys / perl입니다. 필요한 경우 Configure 매개 변수 -Dprefix = / some / dir을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02bd4590e22b3fdced3d71cd3c3281cc1a0a660" translate="yes" xml:space="preserve">
          <source>The default installation location for this release uses the traditional UNIX directory layout under /usr/local. This is the recommended location for most users, and will leave the Apple-supplied Perl and its modules undisturbed.</source>
          <target state="translated">이 릴리스의 기본 설치 위치는 / usr / local의 기존 UNIX 디렉토리 레이아웃을 사용합니다. 대부분의 사용자에게 권장되는 위치이며 Apple에서 제공 한 Perl 및 해당 모듈은 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="2cf27b908bba58a1adbe27495a165db5ad0a8770" translate="yes" xml:space="preserve">
          <source>The default is 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b6e007f998a46a63459c07f21e8e579bcd3ddb9e" translate="yes" xml:space="preserve">
          <source>The default is 0;</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2fede1b14731afaa7b9b9368ecc641901f9fa509" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">&lt;a href=&quot;../warnings&quot;&gt;경고&lt;/a&gt; 가 활성화 되면 기본값은 1 이고, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="b58a909406f580df200ff808a155d67c594063fb" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">&lt;a href=&quot;warnings&quot;&gt;경고&lt;/a&gt; 가 활성화 되면 기본값은 1 이고 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="515832f976590cbb3c71bc0d7d3d0a86a107732b" translate="yes" xml:space="preserve">
          <source>The default is 1.</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="895305ba9904fa755bf8e86c105e9e415a01803b" translate="yes" xml:space="preserve">
          <source>The default is 15 seconds. If you set this value to 0, no timeout will occur, but this is not recommended.</source>
          <target state="translated">기본값은 15 초입니다. 이 값을 0으로 설정하면 시간 초과가 발생하지 않지만 권장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="df47c42104d45d72a320a61c09a39d1b3d97871e" translate="yes" xml:space="preserve">
          <source>The default is 1;</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f462ad28c3fd0db899a9c6ebf2e36d1b531777fa" translate="yes" xml:space="preserve">
          <source>The default is 4096.</source>
          <target state="translated">기본값은 4096입니다.</target>
        </trans-unit>
        <trans-unit id="32bc975de1e1a4635ed927b65955622d6412a442" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d612105f440a62563ca32f22b838324e618ccdeb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b05c3b862baf5dbb3b6628baf4b68b1570abdb4" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e7ce922e57105bce0e95e91cfca276a6a4bf1ac" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; for the root user and &lt;code&gt;0&lt;/code&gt; for normal users.</source>
          <target state="translated">루트 사용자 의 경우 기본값은 &lt;code&gt;1&lt;/code&gt; 이고 일반 사용자의 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96a31382338c2cce7d4e50686f56e0e9ff7debef" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bbf2b1ea0900573472d5b071e3de19f7567ee6bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b961dbd8be6b25800dc4b37b67546efccad28f8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bfbfc9925e2dd8470367ef4195617d71c6222d8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc194b0254a7cf1688815756a4f2837510b9b267" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a908c10942fd5ae6b565f1ce15f1bbfadcedfbe1" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40557fe038c23288a394f8bc56206a7b66f1744c" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;die&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb390eebfd5c04071c6f9ae432a01e30ec460a80" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt; .</source>
          <target state="translated">기본값은 &lt;code&gt;pod&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a27550390154dabd1f6cbb3ac3486e6b597d5bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;pod&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d0a0f1ca8eef2f6fbf6f39dbd7668ad5fbc612a" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_COMPRESSION.</source>
          <target state="translated">기본값은 Z_DEFAULT_COMPRESSION입니다.</target>
        </trans-unit>
        <trans-unit id="ae93ce6388b29eb983caf1def75b439a9873a0b9" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_STRATEGY.</source>
          <target state="translated">기본값은 Z_DEFAULT_STRATEGY입니다.</target>
        </trans-unit>
        <trans-unit id="c52e69ffb8153da22fcf2e0c6d6adcb6a6ff963d" translate="yes" xml:space="preserve">
          <source>The default is false.</source>
          <target state="translated">기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="b30329767ad59c2dc5630061d1ce79106ced2716" translate="yes" xml:space="preserve">
          <source>The default is no dictionary.</source>
          <target state="translated">기본값은 사전이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0eaff3b0b1b9eb661e7fc7bd656a07d77ba2a1ef" translate="yes" xml:space="preserve">
          <source>The default is not to cuddle.</source>
          <target state="translated">기본값은 포옹하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7226202181b27bad8c72a76152482ae3e839b2c6" translate="yes" xml:space="preserve">
          <source>The default is to simply return the event package name.</source>
          <target state="translated">기본값은 단순히 이벤트 패키지 이름을 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c65dc0d3752b5562d0e04006d66de6352709010" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">기본값은 &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; 을 사용하는 것 입니다. Win32 API가있는 시스템에서 &lt;code&gt;eventlog&lt;/code&gt; 는 &lt;code&gt;Win32::EventLog&lt;/code&gt; 를 사용할 수 있는지 확인하는 첫 번째 메커니즘으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae6954e08dfdc077f1f7dcc91f272e939cf877ea" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt;, &lt;code&gt;tcp&lt;/code&gt;, &lt;code&gt;udp&lt;/code&gt;, &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt;, &lt;code&gt;console&lt;/code&gt;. Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">기본값은 &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;pipe&lt;/code&gt; , &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; 을 시도 하는 것 입니다. Win32 API가있는 시스템에서는 &lt;code&gt;Win32::EventLog&lt;/code&gt; 를 사용할 수있는 경우 시도 할 첫 번째 메커니즘으로 &lt;code&gt;eventlog&lt;/code&gt; 가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="69bb3e1a426b5cc38eac62d98ea857e63ed9b5dd" translate="yes" xml:space="preserve">
          <source>The default iterator variable in a &lt;code&gt;foreach&lt;/code&gt; loop if no other variable is supplied.</source>
          <target state="translated">다른 변수가 제공되지 않은 경우 &lt;code&gt;foreach&lt;/code&gt; 루프 의 기본 반복자 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="375ddf0ab7799023484d02f8a221ca6afd3b2054" translate="yes" xml:space="preserve">
          <source>The default memory limit is 2Mib. You can adjust the maximum read cache size by supplying the &lt;code&gt;memory&lt;/code&gt; option. The argument is the desired cache size, in bytes.</source>
          <target state="translated">기본 메모리 제한은 2Mib입니다. &lt;code&gt;memory&lt;/code&gt; 옵션 을 제공하여 최대 읽기 캐시 크기를 조정할 수 있습니다 . 인수는 원하는 캐시 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="97d617432e38273ff2337188090afe707d321e91" translate="yes" xml:space="preserve">
          <source>The default method is ZIP_CM_DEFLATE.</source>
          <target state="translated">기본 방법은 ZIP_CM_DEFLATE입니다.</target>
        </trans-unit>
        <trans-unit id="d06faea5104288d8b0b633dc0567b8b191f0df74" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt; .</source>
          <target state="translated">새 구성 파일의 기본 이름은 &quot;libnet.cfg&quot;이며, -o 옵션 &lt;code&gt;-o newfile&lt;/code&gt; 을 사용하여 달리 지정하지 않는 한 기본적으로 현재 디렉토리에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="408dfa6f2b57602d832595e17787ee724e235423" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt;.</source>
          <target state="translated">새 구성 파일의 기본 이름은 &quot;libnet.cfg&quot;이며 -o 옵션 &lt;code&gt;-o newfile&lt;/code&gt; 을 사용하여 달리 지정하지 않는 한 기본적으로 현재 디렉토리에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e5074809750e6c620d635552cb416989d3d15b2" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt; , and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">-i 옵션 &lt;code&gt;-i oldfile&lt;/code&gt; 을 사용하여 달리 지정하지 않는 한 이전 구성 파일의 기본 이름은 기본적으로 &quot;libnet.cfg&quot;이며, 현재 디렉토리에서 먼저 검색 한 다음 모듈 경로에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="1fef6f94288b1eff625c2f95ef7ecffd1ba05913" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt;, and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">이전 구성 파일의 기본 이름은 -i 옵션 &lt;code&gt;-i oldfile&lt;/code&gt; 을 사용하여 달리 지정하지 않는 한 기본적으로 &quot;libnet.cfg&quot;이며 현재 디렉토리에서 먼저 검색 한 다음 모듈 경로에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="5eb6185afb472dae00827acf41154ba83b345446" translate="yes" xml:space="preserve">
          <source>The default normalizer just concatenates the arguments with character 28 in between. (In ASCII, this is called FS or control-\.) This always works correctly for functions with only one string argument, and also when the arguments never contain character 28. However, it can confuse certain argument lists:</source>
          <target state="translated">기본 노멀 라이저는 인수를 문자 28로 사이에 연결합니다. (ASCII에서는 이것을 FS 또는 control- \라고합니다.) 이것은 하나의 문자열 인수 만있는 함수와 인수에 문자 28이 포함되지 않은 경우에도 항상 올바르게 작동합니다. 그러나 특정 인수 목록을 혼동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39e82de8afe051a851d53770ae84cf3c68d41cb" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">기본 노멀 라이저는 이것을 &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; 와 같은 것으로 바꿉니다 . 후속 데이터 배열이 동일한 데이터를 포함하더라도 다른 위치에 저장 될 수 있다는 점을 제외하고는 괜찮습니다. 이 경우 &lt;code&gt;Memoize&lt;/code&gt; 는 인수가 동일하더라도 인수가 다르다고 생각합니다. 이 경우 다음과 같은 노멀 라이저가 적절합니다.</target>
        </trans-unit>
        <trans-unit id="82517263c6d17f4e83cb2dad91556a271e1fb059" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt;. That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">기본 노멀 라이저는 이것을 &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; 와 같은 것으로 바꿉니다 . 동일한 데이터를 포함하더라도 후속 숫자 배열이 다른 위치에 저장 될 수 있다는 점을 제외하면 괜찮습니다. 이런 일이 발생하면 &lt;code&gt;Memoize&lt;/code&gt; 는 인수가 동일하더라도 서로 다른 것으로 생각합니다. 이 경우 다음과 같은 노멀 라이저가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e5d60aed408340ddef56e731c14beba1f193a756" translate="yes" xml:space="preserve">
          <source>The default of building Perl statically may cause problems with complex applications like Tk: in that case consider building shared Perl</source>
          <target state="translated">Perl을 정적으로 빌드하는 기본값은 Tk와 같은 복잡한 응용 프로그램에서 문제를 일으킬 수 있습니다.이 경우 공유 Perl 작성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ac5f6413f6edd9db793b85ce42ea2d862be3c9a0" translate="yes" xml:space="preserve">
          <source>The default operator mask for a newly created compartment is the ':default' optag.</source>
          <target state="translated">새로 만든 구획의 기본 연산자 마스크는 ': default'optag입니다.</target>
        </trans-unit>
        <trans-unit id="cd7a35f6ae99c836f5d425b35999dec2510b2218" translate="yes" xml:space="preserve">
          <source>The default options gathered by Configure with the assistance of</source>
          <target state="translated">다음을 통해 Configure에서 수집 한 기본 옵션</target>
        </trans-unit>
        <trans-unit id="340bacd1cab82a806d284b26719b4d768c188a8d" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt; . You can use this stream explicitly, but the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">&lt;b&gt;표준 출력에&lt;/b&gt; 속하지 않는 불쾌한 말 의 기본 출력 &lt;b&gt;스트림&lt;/b&gt; 입니다 . output&amp;gt; &lt;b&gt;filehandle &lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; 에 의해 Perl 프로그램 내에 표시 됩니다. 이 스트림을 명시 적으로 사용할 수 있지만, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 내장 기능은 표준 오류 스트림에 자동으로 기록됩니다 (트랩되거나 달리 가로 채지 않는 한).&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9d2c9ac156cbf55108641e915b384d66d9246e77" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt;. You can use this stream explicitly, but the &lt;code&gt;die&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">&lt;b&gt;표준 출력에&lt;/b&gt; 속하지 않는 불쾌한 발언에 대한 기본 출력 &lt;b&gt;스트림&lt;/b&gt; 입니다 . 펄 프로그램 내에서 output&amp;gt; &lt;b&gt;filehandle &lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; 로 표시 됩니다. 명시 적으로이 스트림 만 사용할 수 있습니다 &lt;code&gt;die&lt;/code&gt; 하고 &lt;code&gt;warn&lt;/code&gt; (포획하거나 차단하지 않는 한) 내장 기능이 자동으로 표준 오류 스트림에 씁니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="aa254ec270a416bb3ac03f5a884b155a435c80cb" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">프로그램 의 기본 출력 &lt;b&gt;스트림&lt;/b&gt; 으로, 가능하면 데이터가 어디로 가는지 신경 쓰지 않아야합니다. &lt;b&gt;파일 핸들 &lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; 에 의해 Perl 프로그램 내에서 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="ce1dc62266e22cc3e68d183b4a85d64622b5e7d5" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="translated">프로그램 의 기본 출력 &lt;b&gt;스트림.&lt;/b&gt; 가능하면 데이터가 어디로 가는지 신경 쓰지 않아야합니다. &lt;b&gt;파일 핸들 &lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; 에 의해 Perl 프로그램 내에서 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="e96d4d616212a6cfd4d2816b5ab3f17c9db66319" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">자기 참조 구조의 기본 출력 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 에드 만에 중첩 된 참조 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab4464102ba1e6fbe0c2c60b9748efe43e91939d" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;eval&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">자기 참조 구조의 기본 출력 할 수 있습니다 &lt;code&gt;eval&lt;/code&gt; 에드 만에 중첩 된 참조 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5f2d9e51d87e9b71a9bd992e69d11af3ccda88f" translate="yes" xml:space="preserve">
          <source>The default path for perl binary is /QOpenSys/perl/bin/perl. You'll want to symlink /QOpenSys/usr/bin/perl to this file so you don't have to modify your path.</source>
          <target state="translated">perl 바이너리의 기본 경로는 / QOpenSys / perl / bin / perl입니다. / QOpenSys / usr / bin / perl을이 파일에 심볼릭 링크하여 경로를 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0e7903465e131bba24e8f9fa0f5926ebf1b8dce" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size for different platforms varies significantly, and is almost always far more than is needed for most applications. On Win32, Perl's makefile explicitly sets the default stack to 16 MB; on most other platforms, the system default is used, which again may be much larger than is needed.</source>
          <target state="translated">다른 플랫폼의 기본 스레드 당 스택 크기는 상당히 다양하며 대부분의 응용 프로그램에 필요한 것보다 훨씬 더 큽니다. Win32에서 Perl의 makefile은 기본 스택을 16MB로 명시 적으로 설정합니다. 대부분의 다른 플랫폼에서는 시스템 기본값이 사용되는데 이는 다시 필요한 것보다 훨씬 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02fbe3c9bc6d319100d5d82a643c83d45a2aaf27" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</source>
          <target state="translated">스레드 당 기본 스택 크기는 환경 변수 &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; 를 사용하여 애플리케이션 시작시 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94af03e91a740f430511958dbcda39a82148e50f" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt;:</source>
          <target state="translated">기본 스레드 별 스택 크기는 환경 변수 &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; 를 사용하여 응용 프로그램을 시작할 때 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d17c04396f5d2338f66524479b64e4296e2bc5c4" translate="yes" xml:space="preserve">
          <source>The default perl executable is flexible enough to support most usages. However, one may want something yet more flexible; for example, one may want to find Perl DLL relatively to the location of the EXE file; or one may want to ignore the environment when setting the Perl-library search patch, etc.</source>
          <target state="translated">기본 perl 실행 파일은 대부분의 사용법을 지원할만큼 유연합니다. 그러나 더 유연한 것을 원할 수도 있습니다. 예를 들어, EXE 파일의 위치와 관련하여 Perl DLL을 찾을 수 있습니다. 또는 Perl 라이브러리 검색 패치 등을 설정할 때 환경을 무시하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7009bdcf386245a7873fc69dc2c48c3bfdcf71d9" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.)</source>
          <target state="translated">새 파일이 작성 될 때 사용할 기본 권한. 실제 권한은 사용자의 umask에 의해 수정되므로 여기서 0666을 사용해야합니다. ( &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="81e2f33b41f0b680f7cab719bcc71740e182cd7b" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;perlfunc#umask&quot;&gt;&quot;umask&quot; in perlfunc&lt;/a&gt;.)</source>
          <target state="translated">새 파일이 생성 될 때 사용할 기본 권한입니다. 실제 권한은 사용자의 umask에 의해 수정되므로 여기서 0666을 사용해야합니다. ( &lt;a href=&quot;perlfunc#umask&quot;&gt;perlfunc의 &quot;umask&quot;를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="af672db5716c0b823ab6d08666d2a653d572eae5" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 연산의 결과가 자체적으로 &lt;code&gt;while&lt;/code&gt; 테스트 의 유일한 기준으로 테스트 될 때 다음 값 또는 입력 레코드를 넣는 기본 위치 입니다. 외부 &lt;code&gt;while&lt;/code&gt; 테스트, 이런 일은 발생하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="d37b151c3f1ab65346e3808827390e5bd84764e9" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readdir&lt;/code&gt; or &lt;code&gt;each&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">&lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;readline&lt;/code&gt; , &lt;code&gt;readdir&lt;/code&gt; 또는 &lt;code&gt;each&lt;/code&gt; 작업의 결과가 &lt;code&gt;while&lt;/code&gt; 테스트 의 유일한 기준으로 자체적으로 테스트 될 때 다음 값 또는 입력 레코드를 넣는 기본 위치 입니다. &lt;code&gt;while&lt;/code&gt; 테스트 밖에서는 이런 일이 일어나지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5df9208ed1f779ba0f9d5864d277d9b22483511" translate="yes" xml:space="preserve">
          <source>The default rendering is top-down, so they're not in execution order. This form reflects the way the stack is used to parse and evaluate expressions; the add operates on the two terms below it in the tree.</source>
          <target state="translated">기본 렌더링은 하향식이므로 실행 순서가 아닙니다. 이 형식은 스택을 사용하여 식을 구문 분석하고 평가하는 방식을 반영합니다. add는 트리에서 아래 두 용어에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2fc20ab6a2146e41cd4461ac23c56be7f29f5c25" translate="yes" xml:space="preserve">
          <source>The default rounding mode is 'even'. By using &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; you can get and set the default mode for subsequent rounding. The usage of &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; is no longer supported. The second parameter to the round functions then overrides the default temporarily.</source>
          <target state="translated">기본 반올림 모드는 '짝수'입니다. &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; 를 사용하여 이후 반올림에 대한 기본 모드를 가져오고 설정할 수 있습니다. 의 사용 &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; 더 이상 지원되지 않습니다. 그런 다음 반올림 함수의 두 번째 매개 변수는 기본값을 임시로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0c0082ed0ee0f68ac7247af3405f6e36532a7d14" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms</source>
          <target state="translated">기본 레이어 세트는 모든 플랫폼에서 적절한 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df981f37a11491520138a9699f03c2d8e3a6701d" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms.</source>
          <target state="translated">기본 레이어 세트는 모든 플랫폼에서 허용 가능한 결과를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="98f212f2163021f600388dfedb85757788b2ee77" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , used above, is the numerical comparison operator.</source>
          <target state="translated">기본 정렬 함수는 cmp, 문자열 비교이며 &lt;code&gt;(1, 2, 10)&lt;/code&gt; 을 &lt;code&gt;(1, 10, 2)&lt;/code&gt; 로 정렬 합니다. 위에서 사용한 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 은 숫자 비교 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="353560b1cc4cc620cb2f91f0d6a0c54645b715f0" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt;. &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;, used above, is the numerical comparison operator.</source>
          <target state="translated">기본 정렬 함수는 cmp, 문자열 비교이며 &lt;code&gt;(1, 2, 10)&lt;/code&gt; 을 &lt;code&gt;(1, 10, 2)&lt;/code&gt; 로 정렬 합니다. 위에서 사용 된 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 는 숫자 비교 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="d032c7cba8f64635473f913417491617017d4ca8" translate="yes" xml:space="preserve">
          <source>The default stringification for version objects returns exactly the same string as was used to create it, whether you used &lt;code&gt;new()&lt;/code&gt; or &lt;code&gt;qv()&lt;/code&gt;, with one exception. The sole exception is if the object was created using &lt;code&gt;qv()&lt;/code&gt; and the initializer did not have two decimal places or a leading 'v' (both optional), then the stringified form will have a leading 'v' prepended, in order to support round-trip processing.</source>
          <target state="translated">버전 객체에 대한 기본 문자열 화는 &lt;code&gt;new()&lt;/code&gt; 또는 &lt;code&gt;qv()&lt;/code&gt; 를 사용했는지 여부에 관계없이 한 가지 예외를 제외하고 이를 생성하는 데 사용 된 것과 정확히 동일한 문자열을 반환합니다 . 유일한 예외는 객체가 &lt;code&gt;qv()&lt;/code&gt; 사용하여 생성 되었고 이니셜 라이저에 소수점 이하 두 자리 또는 선행 'v'(둘 다 선택 사항)가없는 경우 문자열 화 된 형식은 지원을 위해 선행 'v'가 앞에 추가됩니다. 왕복 처리.</target>
        </trans-unit>
        <trans-unit id="baa9ec2a72f812d2fff5978a7051ec1d9ead2a46" translate="yes" xml:space="preserve">
          <source>The default subscript separator is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;.</source>
          <target state="translated">기본 첨자 구분 기호는 &quot;\ 034&quot;이며 &lt;b&gt;awk의&lt;/b&gt; SUBSEP와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="497fecb3c603ebf0c33d9ba37b78e38f23ed6d1f" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">기본 텍스트 포맷터는 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 입니다. Pod :: Usage의 기본 클래스는 &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt; 를 사전 설정하여 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fedbef30ad12f7c78358c3195161f7bf65ed2265" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">기본 텍스트 포맷터는 &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; 입니다. Pod :: Usage의 기본 클래스는 &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt; 를 사전 설정하여 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eca7e39567cc3a4e38f07441f8e4f7046f9b14f" translate="yes" xml:space="preserve">
          <source>The default type for the constants. If not specified &lt;code&gt;IV&lt;/code&gt; is assumed.</source>
          <target state="translated">상수의 기본 유형입니다. 지정하지 않으면 &lt;code&gt;IV&lt;/code&gt; 로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3a6f652439685a6a403073936eade467faa79602" translate="yes" xml:space="preserve">
          <source>The default typemap in the</source>
          <target state="translated">의 기본 타입 맵</target>
        </trans-unit>
        <trans-unit id="82f3cb0c641077271c3068ea9c85e22ba715cfbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;div_scale&lt;/code&gt; is 40.</source>
          <target state="translated">&lt;code&gt;div_scale&lt;/code&gt; 의 기본값 은 40입니다.</target>
        </trans-unit>
        <trans-unit id="609bf4918ead31f720f19323f5cf2348643f6d2e" translate="yes" xml:space="preserve">
          <source>The default value for CCHOME in the makefiles for Visual C++ may not be correct for some versions. Make sure the default exists and is valid.</source>
          <target state="translated">Visual C ++ 용 makefile에서 CCHOME의 기본값은 일부 버전에서 올바르지 않을 수 있습니다. 기본값이 존재하고 유효한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80bc06aeaa38f855546b7a2a3a5c29a6a05fdf78" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;30&lt;/code&gt; seconds.</source>
          <target state="translated">기본값은 &lt;code&gt;30&lt;/code&gt; 초입니다.</target>
        </trans-unit>
        <trans-unit id="1f34862d6782defbe2c5b2a0445c8f00de39fa4d" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">기본값은 &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; 및 &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; 입니다. INTERFACE_MACRO 키워드를 사용하는 경우 비어있는 기능 목록이있는 INTERFACE 키워드를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32834cb885f5de67f85718b2d51a3b3a71e20354" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt;. An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">기본값은 &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; 및 &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; 입니다. 함수 목록이 비어있는 INTERFACE 키워드는 INTERFACE_MACRO 키워드를 사용하는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ae2f809fd681df4fcb45c0c13d99a0283fc66b8" translate="yes" xml:space="preserve">
          <source>The definition used for complex arguments of atan2() is</source>
          <target state="translated">atan2 ()의 복잡한 인수에 사용 된 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6431fb44fb840f90a758f20a67dcf8b7a9374aa9" translate="yes" xml:space="preserve">
          <source>The del_dup() Method</source>
          <target state="translated">del_dup () 메소드</target>
        </trans-unit>
        <trans-unit id="4c063e0f96bfc07d5c7996a96961c2627b3a8bf5" translate="yes" xml:space="preserve">
          <source>The delimiter is used to determine the &lt;b&gt;exact&lt;/b&gt; whitespace to remove from the beginning of each line. All lines &lt;b&gt;must&lt;/b&gt; have at least the same starting whitespace (except lines only containing a newline) or perl will croak. Tabs and spaces can be mixed, but are matched exactly. One tab will not be equal to 8 spaces!</source>
          <target state="translated">구분 기호는 각 줄의 시작 부분에서 제거 할 &lt;b&gt;정확한&lt;/b&gt; 공백 을 결정하는 데 사용됩니다 . 모든 줄 에는 최소한 같은 시작 공백이 &lt;b&gt;있어야합니다&lt;/b&gt; (개행 만 포함 된 줄 제외). 그렇지 않으면 perl이 삐걱 거리게됩니다. 탭과 공백은 혼합 될 수 있지만 정확히 일치합니다. 하나의 탭은 8 개의 공백과 같지 않습니다!</target>
        </trans-unit>
        <trans-unit id="ed1ded41373481d9b3a2afdb892465f6f5d0d39d" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 에 제공된 분리 문자 는 &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; 중 하나가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="3c4b77b961d2e96dc174edd63ec1e4a27ffd7394" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 에 제공된 구분 기호 가 &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; 중 하나가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="0e6b6844fe43a8d8ec1aad6ff952638a46635ab3" translate="yes" xml:space="preserve">
          <source>The denizens of makemaker@perl.org.</source>
          <target state="translated">makemaker@perl.org의 이재민.</target>
        </trans-unit>
        <trans-unit id="04df92977d147f1a13e2b1c8b477d27313374630" translate="yes" xml:space="preserve">
          <source>The deprecated features will be grouped by the version of Perl in which they will be removed.</source>
          <target state="translated">더 이상 사용되지 않는 기능은 제거 될 Perl 버전별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1156b058c0b8098efde49eb59cb1671d23c2fe" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;&quot;Postfix Dereference Syntax&quot; in perlref&lt;/a&gt;.</source>
          <target state="translated">역 참조 사례 (메소드 호출 사례와 반대)는 &lt;code&gt;postderef&lt;/code&gt; 기능에 의해 다소 확장됩니다 . 해당 기능에 대한 자세한 내용은 &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;perlref의 &quot;Postfix Dereference Syntax&quot;를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6c12d31655a68b617bd8f8ac7d7b41ffa97d8df" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the experimental &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;Postfix Dereference Syntax in perlref&lt;/a&gt;.</source>
          <target state="translated">역 참조 사례 (메소드 호출 사례와 달리)는 실험적인 &lt;code&gt;postderef&lt;/code&gt; 기능에 의해 다소 확장됩니다 . 해당 기능에 대한 자세한 내용은 &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;perlref의 Postfix Dereference Syntax를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e1ecac0ff0943f872a0e4773ff40533e7fc7967" translate="yes" xml:space="preserve">
          <source>The description will also include tags for other special editions, like &quot;R2&quot;, &quot;Media Center&quot;, &quot;Tablet PC&quot;, or &quot;Starter Edition&quot;.</source>
          <target state="translated">설명에는 &quot;R2&quot;, &quot;Media Center&quot;, &quot;Tablet PC&quot;또는 &quot;Starter Edition&quot;과 같은 다른 특별판에 대한 태그도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c06b4b9a1d8e7058531ada60d67614dbcf01dfd0" translate="yes" xml:space="preserve">
          <source>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</source>
          <target state="translated">역 직렬화 중에 객체에서 역 직렬화 후크가 호출되었습니다. 하지만 기다립니다 : 역 직렬화하는 경우 아직 개체가 없습니다 ... 맞습니까?</target>
        </trans-unit>
        <trans-unit id="8a2f99ef5bda346c32f63e70a7361acb83da8b02" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">디자인 의도는 &lt;code&gt;\d&lt;/code&gt; 가 &quot;일반적인&quot;빅 엔디안 위치 10 진수 구문과 함께 안전하게 사용할 수있는 문자 세트와 정확하게 일치하도록하기위한 것입니다. 그들 '. 이 위치 표기법이 다른 유형의 &quot;숫자&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 와 일치하는 문자에 반드시 적용되는 것은 아니므로 &lt;code&gt;\d&lt;/code&gt; 와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f61094774e8ce7d5c193ad9edc881d479e0d9584" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">설계 의도는 &lt;code&gt;\d&lt;/code&gt; 가 &quot;일반&quot;빅 엔디안 위치 십진 구문과 함께 안전하게 사용할 수있는 문자 세트와 정확히 일치하도록하는 것입니다. 예를 들어 123은 1 개의 '100', 2 개의 '10', 3 개의 '를 의미합니다. ones '. 이 위치 표기법은 다른 유형의 &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 와 일치하는 문자에 반드시 적용되는 것은 아니므로 &lt;code&gt;\d&lt;/code&gt; 는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8a51af6f52e45aaf611688acf5b39dc61f9ae40" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;``&lt;/code&gt;&lt;/a&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">사용자의 욕구 양식의 파일 이름을 표현하는 &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; 명령 줄에 너무, 원인 문제를 인용되지 않은 : &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt; &lt;code&gt;``&lt;/code&gt; &lt;/a&gt; 명령 출력 캡처는 추측 게임을 수행 할 수 있습니다. &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; 문자열 은 환경 변수에 대한 참조 인 반면 &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 와 관련된 다른 것은 리디렉션이며 일반적으로 99 % 옳은 것으로 간주합니다. 물론 문제는 스크립트가 사용 가능한 유닉스 도구에 의존 할 수 없거나 발견 된 도구에 유닉스와 유사한 명령 줄 인수가 있다는 점입니다.</target>
        </trans-unit>
        <trans-unit id="d6ec3b1b57d74d9cf92c20c7537d430a4cb91982" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;code&gt;``&lt;/code&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">커맨드 라인에서 &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; 형식의 파일 이름을 표현하려는 사용자의 욕구 도 문제를 일으킨다 : &lt;code&gt;``&lt;/code&gt; 명령 출력 캡처는 추측 게임을 수행해야한다. 문자열 &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; 는 환경 변수에 대한 참조 인 반면, &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 와 관련된 다른 것은 리디렉션이며 일반적으로 99 % 올바른 것으로 가정합니다. 물론, 스크립트가 사용 가능한 유닉스 도구에 의존 할 수 없거나 발견 된 도구에 유닉스 계열 명령 줄 인수가 있다는 문제는 여전히 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="a11af240187e8ce0ea57c0f5d9817fa72798ba59" translate="yes" xml:space="preserve">
          <source>The desired exit status to pass to the &lt;b&gt;exit()&lt;/b&gt; function. This should be an integer, or else the string &quot;NOEXIT&quot; to indicate that control should simply be returned without terminating the invoking process.</source>
          <target state="translated">&lt;b&gt;exit ()&lt;/b&gt; 함수 에 전달할 원하는 종료 상태 입니다. 이것은 정수이거나 그렇지 않으면 호출 프로세스를 종료하지 않고 제어를 리턴해야 함을 표시하는 문자열 &quot;NOEXIT&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a47bdc95431692c8deb0f97084523a81a5887de3" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the corresponding value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the corresponding value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed.</source>
          <target state="translated">사용법 메시지를 인쇄 할 때 사용할 &quot;자세한 수준&quot;수준입니다. 해당 값이 0이면 포드 설명서의 &quot;SYNOPSIS&quot;섹션 만 인쇄됩니다. 해당 값이 1이면 &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;또는 &quot;OPTIONS AND ARGUMENTS&quot;섹션과 함께 &quot;SYNOPSIS&quot;섹션이 인쇄됩니다. 해당 값이 2 이상이면 전체 맨 페이지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="a260934a8f226c98347f68c3fcc330ccf45f5926" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed, using &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; if available; otherwise &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; is used for the formatting. For better readability, the all-capital headings are downcased, e.g. &lt;code&gt;SYNOPSIS&lt;/code&gt; =&amp;gt; &lt;code&gt;Synopsis&lt;/code&gt;.</source>
          <target state="translated">사용법 메시지를 인쇄 할 때 사용할 &quot;상세&quot;수준입니다. 값이 0이면 포드 문서의 &quot;SYNOPSIS&quot;섹션 만 인쇄됩니다. 값이 1이면 &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;또는 &quot;OPTIONS AND ARGUMENTS&quot;섹션과 함께 &quot;SYNOPSIS&quot;섹션이 인쇄됩니다. 해당 값이 2 이상 이면 가능한 경우 &lt;a href=&quot;perldoc&quot;&gt;perldoc을&lt;/a&gt; 사용하여 전체 맨 페이지가 인쇄 됩니다. 그렇지 않으면 &lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt; 가 형식화에 사용됩니다. 가독성을 높이기 위해 전체 대문자 제목은 다운 케이스로 표시됩니다 (예 : &lt;code&gt;SYNOPSIS&lt;/code&gt; =&amp;gt; &lt;code&gt;Synopsis&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="2b3e64d006f3001c3df4472f5962fd664df30c48" translate="yes" xml:space="preserve">
          <source>The desired level of verbosity to use:</source>
          <target state="translated">사용할 원하는 상세 레벨 :</target>
        </trans-unit>
        <trans-unit id="d21703722988891fb3f110d6e6d4a04ddd13048a" translate="yes" xml:space="preserve">
          <source>The destination directory is C:\Symbian\perl\X.Y.Z. For more details, see</source>
          <target state="translated">대상 디렉토리는 C : \ Symbian \ perl \ XYZ입니다. 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1f8c4d84dbcf0f5f2d69ca16b4ced3235af3fefd" translate="yes" xml:space="preserve">
          <source>The destination for the option must be an array or array reference.</source>
          <target state="translated">옵션의 대상은 배열 또는 배열 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="409e973fa41301f9011188be107ecc88ef0e437c" translate="yes" xml:space="preserve">
          <source>The details for those items which may deviate from what this emulation returns and what a native &lt;code&gt;nl_langinfo()&lt;/code&gt; would return are specified in &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N::Langinfo&lt;/a&gt;.</source>
          <target state="translated">이 에뮬레이션이 반환하는 항목과 기본 &lt;code&gt;nl_langinfo()&lt;/code&gt; 가 반환 하는 항목에서 벗어날 수있는 항목에 대한 세부 정보 는 &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N :: Langinfo에&lt;/a&gt; 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2940ce84da888fbb72c23c514c9cdd4e2c7bab4a" translate="yes" xml:space="preserve">
          <source>The detection algorithm works something like this:</source>
          <target state="translated">감지 알고리즘은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e261118eabba6fd9f550b8549a8f692c8f65be6" translate="yes" xml:space="preserve">
          <source>The develop phase's prereqs are libraries needed to work on the distribution's source code as its author does. These tools might be needed to build a release tarball, to run author-only tests, or to perform other tasks related to developing new versions of the distribution.</source>
          <target state="translated">개발 단계의 전제 조건은 작성자가하는 것처럼 배포판의 소스 코드에서 작업하는 데 필요한 라이브러리입니다. 이러한 도구는 릴리스 tarball을 빌드하거나 작성자 전용 테스트를 실행하거나 배포의 새 버전 개발과 관련된 기타 작업을 수행하는 데 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd0b50108607e59344e69b0de3bc9fd4f301247" translate="yes" xml:space="preserve">
          <source>The diagnostics Pragma</source>
          <target state="translated">진단 Pragma</target>
        </trans-unit>
        <trans-unit id="9e8272da23da05393615d77b37bcea56278deff5" translate="yes" xml:space="preserve">
          <source>The diagnostics of this test normally just refer to 'the object'. If you'd like them to be more specific, you can supply an $object_name (for example 'Test customer').</source>
          <target state="translated">이 테스트의 진단은 보통 '개체'를 참조합니다. 보다 구체적으로 지정하려면 $ object_name (예 : 'Test customer')을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67027b213e7e98e89fd8e5ebf75f4789f0806d73" translate="yes" xml:space="preserve">
          <source>The diagram below represents a single source stream, with the flow of source from a Perl script file on the left into the Perl parser on the right. This is how Perl normally operates.</source>
          <target state="translated">아래 다이어그램은 왼쪽의 Perl 스크립트 파일에서 오른쪽의 Perl 파서로의 소스 흐름과 함께 단일 소스 스트림을 나타냅니다. 이것이 Perl이 정상적으로 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="09d12bc25e1c17128a784d1b2ff7f2b3ea6c5f9e" translate="yes" xml:space="preserve">
          <source>The die on line 4 pops the context stack back down to the CxEVAL, leaving it as:</source>
          <target state="translated">라인 4의 다이는 컨텍스트 스택을 CxEVAL로 다시 팝하여 다음과 같이 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="930610eed704196a6c02e9606fed36fd7cdf0a59" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , and control returns to the top &lt;code&gt;docatch&lt;/code&gt; . This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">다이 는 컨텍스트 스택 에서 첫 번째 &lt;code&gt;CxEVAL&lt;/code&gt; 을 팝하고 &lt;code&gt;PL_restartop&lt;/code&gt; 을 설정 하고 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 을 수행하며 제어는 최상위 &lt;code&gt;docatch&lt;/code&gt; 로 리턴합니다 . 그런 다음 또 다른 3 단계 runops 레벨을 시작하여 라인 4에서 nextstate, pushmark 및 die ops를 실행합니다. 두 번째 &lt;code&gt;pp_die&lt;/code&gt; 가 호출 에서 C 호출 스택은 더 이상 내부에 있지 않더라도 위와 동일하게 보입니다. 내부 평가; 이것은 앞에서 언급 한 최적화 때문입니다. 그러나 컨텍스트 스택은 이제 다음과 같이 보입니다. 즉 상단 CxEVAL이 튀어 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbbbc185d1013ac982e3992e43afeb11193aeae4" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;, and control returns to the top &lt;code&gt;docatch&lt;/code&gt;. This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">다이 는 컨텍스트 스택 에서 첫 번째 &lt;code&gt;CxEVAL&lt;/code&gt; 을 팝하고 , &lt;code&gt;PL_restartop&lt;/code&gt; 에서 PL_restartop 을 설정 하고, &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 를 수행하고, 제어가 최상위 &lt;code&gt;docatch&lt;/code&gt; 로 돌아갑니다 . 그런 다음 다른 세 번째 수준의 runops 수준을 시작하여 라인 4에서 nextstate, pushmark 및 die ops를 실행합니다. 두 번째 &lt;code&gt;pp_die&lt;/code&gt; 가 호출 되는 시점 에서 C 호출 스택은 더 이상 안에 있지 않더라도 위와 똑같이 보입니다. 내부 평가; 이는 앞서 언급 한 최적화 때문입니다. 그러나 컨텍스트 스택은 이제 다음과 같이 표시됩니다. 즉, 최상위 CxEVAL이 팝된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="6ed5acbfe1a4a69e2eecb34b13c8306880da82cf" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt; , is that those generated subroutines:</source>
          <target state="translated">&lt;code&gt;gen_extract_tagged&lt;/code&gt; 에 의해 생성 된 &lt;code&gt;extract_tagged&lt;/code&gt; 와 익명 서브 루틴 의 차이점은 다음 과 같이 생성 된 서브 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="4192a9e6844188f610795705ae7b4477088fe04b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt;, is that those generated subroutines:</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 와 &lt;code&gt;gen_extract_tagged&lt;/code&gt; 에 의해 생성 된 익명 서브 루틴 의 차이점은 생성 된 서브 루틴이 다음과 같다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e6f28f40692ae97e2ea2e8080e59d267505ccf0" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;minlen&lt;/code&gt; and &lt;code&gt;minlenret&lt;/code&gt; can be seen in the following pattern:</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt; 과 &lt;code&gt;minlenret&lt;/code&gt; 의 차이점 은 다음과 같은 패턴으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8ae9fbf98646f2ef8526e7b39bf817f11262438" translate="yes" xml:space="preserve">
          <source>The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to represent languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of consecutive code points (so far the size of a block is some multiple of 16, like 128 or 256).</source>
          <target state="translated">블록과 스크립트의 차이점은 스크립트는 언어를 표현하는 데 필요한 코드 포인트 세트의 언어 적 개념에 더 가깝고, 블록은 유니 코드 코드 포인트 번호 매기기 및 연속 코드 포인트 블록으로 분리되는 인공물에 가깝습니다 ( 지금까지 블록의 크기는 128 또는 256과 같은 16의 배수입니다.</target>
        </trans-unit>
        <trans-unit id="4e0fd5df1eb8c3e578915cd6f8934c4fe5cf676a" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt; . Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">이 두 속성의 차이점은 여러 스크립트에서 사용되는 문자와 관련이 있습니다. 예를 들어 숫자 '0'에서 '9'는 전세계 여러 지역에서 사용됩니다. 이들은 &lt;code&gt;Common&lt;/code&gt; 이라는 스크립트에 배치됩니다 . 다른 문자는 몇 개의 스크립트에서만 사용됩니다. 예를 들어, &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; 은 가타카나와 히라가나와 같은 일본어 스크립트에서 사용되지만 다른 곳에서는 사용되지 않습니다. &lt;code&gt;Script&lt;/code&gt; 속성은 여러 스크립트에서 사용되는 모든 문자를 배치 &lt;code&gt;Common&lt;/code&gt; 스크립트를하는 동안 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성 장소 그 스크립트의 각에 몇 스크립트에서 사용되는 것과; 많은 스크립트에서 사용되는 것들에 대해서는 여전히 &lt;code&gt;Common&lt;/code&gt; 을 사용합니다. 따라서 두 가지 모두 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6e605910d48501bdad38af7496eb4f572c4cfa33" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt;. Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">이 두 속성의 차이점은 여러 스크립트에서 사용되는 문자와 관련이 있습니다. 예를 들어 '0'에서 '9'까지의 숫자는 세계 여러 지역에서 사용됩니다. &lt;code&gt;Common&lt;/code&gt; 이라는 스크립트에 배치됩니다 . 다른 문자는 몇 가지 스크립트에서만 사용됩니다. 예를 들어 &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; 은 일본어 문자 인 가타카나와 히라가나 모두에서 사용되지만 다른 곳에서는 사용되지 않습니다. &lt;code&gt;Script&lt;/code&gt; 속성은 여러 스크립트에서 사용되는 모든 문자를 배치 &lt;code&gt;Common&lt;/code&gt; 스크립트를하는 동안 &lt;code&gt;Script_Extensions&lt;/code&gt; 속성 장소 그 스크립트의 각에 몇 스크립트에서 사용되는 것과; 많은 스크립트에서 사용되는 것들에 대해 여전히 &lt;code&gt;Common&lt;/code&gt; 을 사용하고 있습니다. 따라서 두 가지 모두 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9cc2b3e05da478b77fc3b12b2fa311b0e5889311" translate="yes" xml:space="preserve">
          <source>The difference here is the addition of the temporary variable &lt;code&gt;$data&lt;/code&gt;. This is used to store a copy of the compressed data while it is being uncompressed.</source>
          <target state="translated">여기서 차이점은 임시 변수 &lt;code&gt;$data&lt;/code&gt; 가 추가 된 것입니다 . 압축 해제되는 동안 압축 된 데이터의 복사본을 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f324cedd823e628f1ed8025386bfb26cab3778ab" translate="yes" xml:space="preserve">
          <source>The difference is clear to see and the dereferencing approach is slower. While it managed to execute an average of 628,930 times a second during our test, the direct approach managed to run an additional 204,403 times, unfortunately. Unfortunately, because there are many examples of code written using the multiple layer direct variable access, and it's usually horrible. It is, however, minusculy faster. The question remains whether the minute gain is actually worth the eyestrain, or the loss of maintainability.</source>
          <target state="translated">차이점은 분명하고 역 참조 접근법은 느립니다. 테스트하는 동안 초당 평균 628,930 회를 실행했지만 직접 접근 방식은 불행히도 204,403 번을 추가로 실행했습니다. 불행히도, 다중 계층 직접 변수 액세스를 사용하여 작성된 코드의 예가 많기 때문에 일반적으로 끔찍합니다. 그러나 그 속도는 아주 빠릅니다. 미세한 이득이 실제로 눈의 피로를 감당할 가치가 있는지 또는 유지 보수성의 상실 여부는 여전히 의문입니다.</target>
        </trans-unit>
        <trans-unit id="c9d466e6cdc3e3b171ba671cc22acace7243054b" translate="yes" xml:space="preserve">
          <source>The difference is the sigil, that special character in front of the array name. The &lt;code&gt;$&lt;/code&gt; sigil means &quot;exactly one item&quot;, while the &lt;code&gt;@&lt;/code&gt; sigil means &quot;zero or more items&quot;. The &lt;code&gt;$&lt;/code&gt; gets you a single scalar, while the &lt;code&gt;@&lt;/code&gt; gets you a list.</source>
          <target state="translated">차이점은 배열 이름 앞에있는 특수 문자 인시길입니다. &lt;code&gt;$&lt;/code&gt; 수단 &quot;정확히 하나 개의 항목&quot;시길 반면 &lt;code&gt;@&lt;/code&gt; 수단 &quot;0 개 이상의 항목&quot;시길. &lt;code&gt;$&lt;/code&gt; 는 그동안 당신에게 하나의 스칼라를 얻을 &lt;code&gt;@&lt;/code&gt; 가 당신에게 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="82ff75d7fe49900a75f8b7a1628df2b78931946c" translate="yes" xml:space="preserve">
          <source>The difference to &lt;code&gt;incr_reset&lt;/code&gt; is that only text until the parse error occurred is removed.</source>
          <target state="translated">&lt;code&gt;incr_reset&lt;/code&gt; 의 차이점 은 구문 분석 오류가 발생할 때까지 텍스트 만 제거된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2b0921f524dbbf7564616e5853365d0c767bfc6" translate="yes" xml:space="preserve">
          <source>The digest can be delivered in three formats:</source>
          <target state="translated">다이제스트는 세 가지 형식으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0155d0c091234cee22dc790957626f27306487e0" translate="yes" xml:space="preserve">
          <source>The direction you must follow the great circle (also known as</source>
          <target state="translated">큰 원을 따라야하는 방향 (또는</target>
        </trans-unit>
        <trans-unit id="03d134305af0df1045ab396312ef86cfab55c5d9" translate="yes" xml:space="preserve">
          <source>The direction you would have to go from London to Tokyo (in radians, straight north being zero, straight east being pi/2).</source>
          <target state="translated">런던에서 도쿄로 가야 할 방향 (라디안, 직선 북쪽은 0, 직선 동쪽은 pi / 2).</target>
        </trans-unit>
        <trans-unit id="9159a72a045b505fc788bec97c5202fb7f87247c" translate="yes" xml:space="preserve">
          <source>The directory portion may or may not be returned with a trailing '/'.</source>
          <target state="translated">디렉토리 부분은 후행 '/'와 함께 리턴되거나 리턴되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd54b0e8774d4521e37e9c7dad7074640dfad53" translate="yes" xml:space="preserve">
          <source>The directory you are put into when you log in. On a Unix system, the name is often placed into &lt;code&gt;$ENV{HOME}&lt;/code&gt; or &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; by</source>
          <target state="translated">로그인 할 때 입력 한 디렉토리입니다. Unix 시스템에서 이름은 종종 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 또는 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f834768c044521ed2139a347066ecd1f6fd454d" translate="yes" xml:space="preserve">
          <source>The directory, if specified, must appear immediately following the &lt;b&gt;-x&lt;/b&gt; with no intervening whitespace.</source>
          <target state="translated">지정된 경우 디렉토리는 공백없이 &lt;b&gt;-x&lt;/b&gt; 바로 다음에 나타나야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f8724048da79577878989633dd2a49c69c9ec2" translate="yes" xml:space="preserve">
          <source>The display name describes the native Windows version, so even on a 32-bit Perl this function may return a &quot;Windows ... (64-bit)&quot; name when running on a 64-bit Windows.</source>
          <target state="translated">표시 이름은 기본 Windows 버전을 설명하므로 32 비트 Perl에서도이 함수는 64 비트 Windows에서 실행될 때 &quot;Windows ... (64 비트)&quot;이름을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33156bb6057d33c4b599fbfc979b33f776601d44" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;OBJECT&lt;/code&gt; and &lt;code&gt;LDFROM&lt;/code&gt;: &lt;code&gt;OBJECT&lt;/code&gt; is the make target, so make will try to build it. However, &lt;code&gt;LDFROM&lt;/code&gt; is what will actually be linked together to make the shared object or static library (SO/SL), so if you override it, make sure it includes what you want to make the final SO/SL, almost certainly including the XS basename with &lt;code&gt;$(OBJ_EXT)&lt;/code&gt; appended.</source>
          <target state="translated">구별 &lt;code&gt;OBJECT&lt;/code&gt; 및 &lt;code&gt;LDFROM&lt;/code&gt; : &lt;code&gt;OBJECT&lt;/code&gt; 는 make가 그것을 만들기 위해 노력할 것입니다, 그래서 메이크업의 대상입니다. 그러나 &lt;code&gt;LDFROM&lt;/code&gt; 은 공유 객체 또는 정적 라이브러리 (SO / SL)를 만들기 위해 실제로 함께 연결되는 것이므로이를 재정의하는 경우 XS를 포함하여 최종 SO / SL을 만들려는 항목이 포함되어 있는지 확인하십시오. &lt;code&gt;$(OBJ_EXT)&lt;/code&gt; 추가 된 기본 이름 .</target>
        </trans-unit>
        <trans-unit id="52decfdd93c450a71874ee33c51b4afa2f1bd5c0" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/GPL-2.0&quot;&gt;http://opensource.org/licenses/GPL-2.0&lt;/a&gt;).</source>
          <target state="translated">배포는 GNU General Public License 버전 2 ( &lt;a href=&quot;http://opensource.org/licenses/GPL-2.0&quot;&gt;http://opensource.org/licenses/GPL-2.0&lt;/a&gt; ) 조건에 따라 배포됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cba2181eae9ea18443bd663a1f8c3a87fbabe62" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU Lesser General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/LGPL-2.1&quot;&gt;http://opensource.org/licenses/LGPL-2.1&lt;/a&gt;).</source>
          <target state="translated">배포는 GNU Lesser General Public License 버전 2 ( &lt;a href=&quot;http://opensource.org/licenses/LGPL-2.1&quot;&gt;http://opensource.org/licenses/LGPL-2.1&lt;/a&gt; ) 조건에 따라 배포됩니다 .</target>
        </trans-unit>
        <trans-unit id="4888c0e08e74f6e2698369bc2f948843f746c57a" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is &lt;b&gt;not&lt;/b&gt; approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="translated">배포는 &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org에서&lt;/a&gt; 승인 &lt;b&gt;하지&lt;/b&gt; 않았지만 제한없이 배포 할 수 있는 라이선스에 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b18e66ed77e39494025272eb1fa0055f83f4e24c" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is not approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="translated">배포는 &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org에서&lt;/a&gt; 승인하지 않았지만 제한없이 배포 할 수 있는 라이선스에 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="32f50f8aa35b8ab9124cad20b747796d784792a1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under some other Open Source Initiative-approved license listed at &lt;a href=&quot;http://www.opensource.org/licenses/&quot;&gt;http://www.opensource.org/licenses/&lt;/a&gt;.</source>
          <target state="translated">배포판은 &lt;a href=&quot;http://www.opensource.org/licenses/&quot;&gt;http://www.opensource.org/licenses/에&lt;/a&gt; 나열된 다른 오픈 소스 이니셔티브 승인 라이센스에 따라 라이센스가 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78bde88df9f9ec717c7aea6abe37d463f7f3091" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Apache Software License version 1.1 (&lt;a href=&quot;http://opensource.org/licenses/Apache-1.1&quot;&gt;http://opensource.org/licenses/Apache-1.1&lt;/a&gt;).</source>
          <target state="translated">배포판은 Apache Software License 버전 1.1 ( &lt;a href=&quot;http://opensource.org/licenses/Apache-1.1&quot;&gt;http://opensource.org/licenses/Apache-1.1&lt;/a&gt; )에 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7de749c864adb80ca7d1e8d280af821d8d4c9935" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Artistic License version 1, as specified by the Artistic file in the standard perl distribution (&lt;a href=&quot;http://opensource.org/licenses/Artistic-Perl-1.0&quot;&gt;http://opensource.org/licenses/Artistic-Perl-1.0&lt;/a&gt;).</source>
          <target state="translated">배포는 표준 perl 배포 ( &lt;a href=&quot;http://opensource.org/licenses/Artistic-Perl-1.0&quot;&gt;http://opensource.org/licenses/Artistic-Perl-1.0&lt;/a&gt; ) 의 Artistic 파일에 지정된대로 Artistic License 버전 1에 따라 사용이 허가됩니다 .</target>
        </trans-unit>
        <trans-unit id="79ac3a668622bd0a049080f2c7b27295e3ec4b97" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the BSD 3-Clause License (&lt;a href=&quot;http://opensource.org/licenses/BSD-3-Clause&quot;&gt;http://opensource.org/licenses/BSD-3-Clause&lt;/a&gt;).</source>
          <target state="translated">배포는 BSD 3-Clause 라이선스 ( &lt;a href=&quot;http://opensource.org/licenses/BSD-3-Clause&quot;&gt;http://opensource.org/licenses/BSD-3-Clause&lt;/a&gt; )에 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9b566ce554e210d4ce11e3e299eeba816ff34110" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the MIT License (&lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;).</source>
          <target state="translated">배포는 MIT 라이센스 ( &lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;http://opensource.org/licenses/MIT&lt;/a&gt; )에 따라 라이센스가 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="3aac6612aedc9abedbc7808782068e6b14c9dad1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Mozilla Public License. (&lt;a href=&quot;http://opensource.org/licenses/MPL-1.0&quot;&gt;http://opensource.org/licenses/MPL-1.0&lt;/a&gt; or &lt;a href=&quot;http://opensource.org/licenses/MPL-1.1&quot;&gt;http://opensource.org/licenses/MPL-1.1&lt;/a&gt;)</source>
          <target state="translated">배포는 Mozilla Public License에 따라 사용이 허가되었습니다. ( &lt;a href=&quot;http://opensource.org/licenses/MPL-1.0&quot;&gt;http://opensource.org/licenses/MPL-1.0&lt;/a&gt; 또는 &lt;a href=&quot;http://opensource.org/licenses/MPL-1.1&quot;&gt;http://opensource.org/licenses/MPL-1.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="29ec48fe5b9db3aa7699bae9e6f37f57f64c6873" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL or the Artistic license.</source>
          <target state="translated">배포판은 perl 자체와 동일한 조건으로 복사 및 재배포 할 수 있습니다 (이것은 CPAN의 모듈에 대한 가장 일반적인 라이센스 옵션입니다). 이것은 사용자가 GPL 또는 Artistic 라이선스 중에서 선택할 수있는 이중 라이선스입니다.</target>
        </trans-unit>
        <trans-unit id="1f6a3b8d2999345748a288e76e75c0daa029db33" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL version 1 or the Artistic version 1 license.</source>
          <target state="translated">배포판은 perl 자체와 동일한 조건으로 복사 및 재배포 할 수 있습니다 (이것은 CPAN의 모듈에 대한 가장 일반적인 라이센스 옵션입니다). 이것은 사용자가 GPL 버전 1 또는 Artistic 버전 1 라이선스 중에서 선택할 수있는 이중 라이선스입니다.</target>
        </trans-unit>
        <trans-unit id="68561decd1a625d00c793764ccc0278b512e1101" translate="yes" xml:space="preserve">
          <source>The distribution may not be redistributed without special permission from the author and/or copyright holder.</source>
          <target state="translated">저자 및 / 또는 저작권 소유자의 특별한 허가없이 배포 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">CPAN dist의 분배 메타 데이터</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">번들 배포는 ​​다른 배포와 동일한 규칙을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">의 distroprefs 시스템 &lt;code&gt;CPAN.pm&lt;/code&gt; 은 하나에 YAML 파일에 추가 정보와 요리법을 지정하는 사용자를 허용함으로써이 문제를 해결</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">나누기 (/) 및 다음 기능</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">DOS, 대한 DJGPP 환경 &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; 및 &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">do-or-die 등가물은 간단히 Fatal의 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 루틴 을 호출 하여 대체 될 함수의 이름을 전달하여 설정됩니다. 이 방법으로 사용자 정의 함수와 재정의 가능한 CORE 연산자 ( &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 또는 프로토 타입을 통해 표현할 수없는 기타 내장 제외)를 모두 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89559d6a4bade96c4b212e54a4534bbb62aa15a" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;import&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">do-or-die 등가물은 Fatal의 &lt;code&gt;import&lt;/code&gt; 루틴 을 호출 하여 교체 할 함수의 이름을 전달 함으로써 간단히 설정됩니다 . 이러한 방식으로 사용자 정의 함수와 재정의 가능한 CORE 연산자 ( &lt;code&gt;exec&lt;/code&gt; , &lt;code&gt;system&lt;/code&gt; , &lt;code&gt;print&lt;/code&gt; 또는 프로토 타입을 통해 표현할 수없는 기타 내장 기능 제외)를 모두 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15384d55904491a7259b275ff7854d9b17c0ddff" translate="yes" xml:space="preserve">
          <source>The documentation below is only for the methods of the CPAN::Meta object. For information on the meaning of individual fields, consult the spec.</source>
          <target state="translated">아래 문서는 CPAN :: Meta 개체의 메서드에 대한 것입니다. 개별 필드의 의미에 대한 정보는 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Perl API에 대한 문서는 소스에서 사용되는 많은 매크로뿐만 아니라 일부 내부 함수의 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f1c9061e68c820097f175c9e3bd485176b2a01c2" translate="yes" xml:space="preserve">
          <source>The documentation of &lt;a href=&quot;Locale::Maketext&quot;&gt;Locale::Maketext&lt;/a&gt; advises that the standard bracket method &lt;code&gt;numf&lt;/code&gt; is limited and that you must override that for better results. It even suggests the use of &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;Locale::Maketext&quot;&gt;Locale :: Maketext&lt;/a&gt; 의 문서는 표준 대괄호 방법 &lt;code&gt;numf&lt;/code&gt; 가 제한적이며 더 나은 결과를 위해이를 재정의해야 한다고 조언합니다 . &lt;a href=&quot;Number::Format&quot;&gt;Number :: Format&lt;/a&gt; 사용을 제안합니다 .</target>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="translated">도트</target>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">도트 (또는 기간) &lt;code&gt;.&lt;/code&gt; 아마도 가장 많이 사용되는 문자 클래스 일 것입니다. 기본적으로 점은 개행을 제외한 모든 문자와 일치합니다. 이 기본값을 사용하여 줄 바꿈과 일치하도록 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">정규식 변수의 동적 인 특성은이 코드 비트에서 알 수 있듯이 해당 값이 포함 된 블록으로 제한됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">&lt;code&gt;newgetopt.pl&lt;/code&gt; 의 초기 개발은 1990 년 Perl 버전 4에서 시작되었습니다. 그 결과 개발 및 Getopt :: Long의 개발은 여러 단계를 거쳤습니다. 이전 버전과의 호환성은 항상 매우 중요했기 때문에 현재 버전의 Getopt :: Long은 오늘날 더 이상 필요하지 않거나 원하지 않는 많은 구성을 계속 지원합니다. 이 섹션에서는 이러한 '기능'중 일부에 대해 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">버그를 재현하는 것이 쉬울수록 수정 될 가능성이 높습니다. 문제를 복제 할 수있는 사람이 없으면 해결되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">재현 가능한 버그를 이해하기 쉬울수록 수정 될 가능성이 높습니다. 문제에 대한 통찰력은 많은 도움이 될 것입니다. 다시 말해, 문제를 분석하고 (가능한 한) 발견을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">자신 만의 소스 필터를 만들 수있는 가장 쉽고 이식성이 뛰어난 옵션은 Perl로 완전히 작성하는 것입니다. 이를 이전의 두 기술과 구별하기 위해이를 Perl 소스 필터라고합니다.</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">가장 쉬운 개념적 해결책은 파일의 행을 계산 한 다음 처음부터 시작하여 행 수 (마지막 N 빼기)를 새 파일로 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">가장 쉬운 방법은 Perl과 함께 제공 되는 &lt;code&gt;cpan&lt;/code&gt; 명령을 사용하여 CPAN이라는 모듈을 사용 하는 것입니다. 설치할 모듈 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cfa0d7d193c99cb54063076caae508cae649aa1" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">이를 수행하는 가장 쉬운 방법 은 CPAN 의 &lt;a href=&quot;Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; 모듈을 사용하여 비 차단 모드에서 키를 읽고 차단 하지 않음을 나타내는 -1 인수를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">이를 수행하는 가장 쉬운 방법은 &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey를&lt;/a&gt; 사용하여 비 차단 모드에서 키를 읽는 것입니다. 은 CPAN 모듈을 -1의 인수를 전달하여 차단하지 않도록 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b2853b05b0394d3d1c3bfe698cbfe924daa1822" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;B::Terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt; and CPAN module &amp;lt;B::Debug do.</source>
          <target state="translated">op 트리를 검사하는 가장 쉬운 방법은 파싱을 마친 후 Perl을 중지하고 트리에서 덤프하도록하는 것입니다. 이것이 바로 컴파일러가 &lt;a href=&quot;B::Terse&quot;&gt;B :: Terse&lt;/a&gt; , &lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt; 및 CPAN 모듈 &amp;lt;B :: Debug를 백엔드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">op 트리를 검사하는 가장 쉬운 방법은 구문 분석이 끝난 후 Perl을 중지하고 트리를 덤프하는 것입니다. 이것은 컴파일러가 &lt;a href=&quot;b/terse&quot;&gt;B :: Terse&lt;/a&gt; , &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; 및 &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; 백엔드와 정확히 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">사용할 매크로의 템플리트 세트를 얻는 가장 쉬운 방법 은 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 와 함께 &lt;code&gt;-g&lt;/code&gt; ( &lt;code&gt;--global&lt;/code&gt; ) 옵션을 지정하는 것입니다 (h2xs 참조 ).</target>
        </trans-unit>
        <trans-unit id="4c6326467cfffc66387125a93100da358b0b5c86" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt;) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">사용할 매크로 템플릿 세트를 얻는 가장 쉬운 방법 은 &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; 와 함께 &lt;code&gt;-g&lt;/code&gt; ( &lt;code&gt;--global&lt;/code&gt; ) 옵션을 지정하는 것입니다 (h2xs 참조 ).</target>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">입력 가능한 개별 문자를 지정하는 가장 쉬운 방법은 대괄호로 묶는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d739701e48fac0ec01f64967528c5978352a4aef" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt;, one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">서브 루틴이 인라인되었는지 확인하는 가장 쉬운 방법은 &lt;a href=&quot;B::Deparse&quot;&gt;B :: Deparse를 사용하는 것&lt;/a&gt; 입니다. &lt;code&gt;1&lt;/code&gt; 을 반환하는 두 개의 서브 루틴 , 하나는 &lt;code&gt;()&lt;/code&gt; 프로토 타입이 인라인되도록하고 다른 하나는없는 (명확성을 위해 분리 된 출력이 잘림)을 반환하는 다음 예제를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">서브 루틴이 인라인되었는지 확인하는 가장 쉬운 방법은 &lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse를 사용하는 것&lt;/a&gt; 입니다. &lt;code&gt;1&lt;/code&gt; 을 반환하는 두 개의 서브 루틴의 예를 고려하십시오 . 하나는 &lt;code&gt;()&lt;/code&gt; 프로토 타입을 사용하여 인라인되고 다른 하나는 (명확성을 위해 출력이 잘리지 않습니다) :</target>
        </trans-unit>
        <trans-unit id="0f8acfaed2cccc718ab47b22e571180e63f71aac" translate="yes" xml:space="preserve">
          <source>The easiest way to test is to do something like</source>
          <target state="translated">테스트하는 가장 쉬운 방법은 다음과 같은 작업을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a0eee7295ee278e006e907a6f9a925e3a5df708" translate="yes" xml:space="preserve">
          <source>The easist way to deal with this issue is to use the pre-defined &quot;utf8&quot; &lt;b&gt;DBM_Filter&lt;/b&gt; (see &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt;) that was designed to deal with this situation.</source>
          <target state="translated">이 문제를 처리하는 가장 쉬운 방법은 이 상황을 처리하도록 설계된 미리 정의 된 &quot;utf8&quot; &lt;b&gt;DBM_Filter&lt;/b&gt; ( &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt; 참조 )를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">쉬운 대답은 &quot;하지 마십시오!&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8aef9d5f47b23df02c1f4b866ddffffba9a2ae25" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;:std&lt;/code&gt; is not lexical as it modifies the layer stack of the global handles. If you wish to apply only this global effect and not the effect on handles that are opened in that scope, you can isolate the call to this pragma in its own lexical scope.</source>
          <target state="translated">&lt;code&gt;:std&lt;/code&gt; 의 효과 는 전역 핸들의 레이어 스택을 수정하므로 어휘가 아닙니다. 이 전역 효과 만 적용하고 해당 범위에서 열린 핸들에 대한 효과는 적용하지 않으려면 자체 어휘 범위에서이 pragma에 대한 호출을 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4605050fae7c9f6ca47b8c647d8260a448789c" translate="yes" xml:space="preserve">
          <source>The effect of multiple &lt;code&gt;-I&lt;/code&gt; options is to &lt;code&gt;unshift&lt;/code&gt; them onto &lt;code&gt;@INC&lt;/code&gt; from right to left. So for example:</source>
          <target state="translated">복수의 영향 &lt;code&gt;-I&lt;/code&gt; 옵션입니다 &lt;code&gt;unshift&lt;/code&gt; 에 그들을 &lt;code&gt;@INC&lt;/code&gt; 오른쪽에서 왼쪽으로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">&quot;failure_auto_handler&quot;를 사용하는 효과는 1) &quot;_&quot;로 시작하더라도 $ key를 컴파일하고 2) 새로운 hashref $ lh-&amp;gt; { 'failure_lex'}에 레코드가 있다는 점을 제외하면 AUTO 사전과 같습니다. 이 객체에 실패한 모든 키 중 키가 실제로 브라켓 코드처럼 유효하지 않고 존재하지 않는 메소드를 호출하지 않는 한 프로그램이 죽지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">이 과정의 효과적인 방법. 당신이 컴퓨터에있는 경우 동시에 여러 그룹에서 지원하는 회원은 공간이 당신에있는 그룹의 목록을 분리 준다. 첫 번째 숫자에 의해 반환되는 것과 &lt;code&gt;getegid()&lt;/code&gt; , 그리고에 의해 이후의 것들 &lt;code&gt;getgroups()&lt;/code&gt; , 하나의 수도 첫 번째 숫자와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="c57c7b93a855188d4ab0c627a896d86afd3718eb" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="translated">이 프로세스의 효과적인 가이드입니다. 여러 그룹의 멤버쉽을 동시에 지원하는 시스템에있는 경우, 사용자가 속한 그룹의 공백으로 구분 된 목록을 제공합니다. 첫 번째 숫자는 &lt;code&gt;getegid()&lt;/code&gt; 에서 반환 한 번호이고 후속 번호는 &lt;code&gt;getgroups()&lt;/code&gt; 에서 반환 한 번호이며 그 중 하나 는 다음과 같습니다. 첫 번째 숫자와 동일해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">이 과정의 효과적인 UID. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">&lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; 요소 는 특별합니다. 읽을 때 Perl의 현재 기본 장치 및 디렉토리를 반환하며, 설정되면 정의에 관계없이 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">이 요소는 해시이며 기본적으로 &lt;code&gt;()&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff2bffd6b7ca0e9e867ed8229203222ba2cd6dd2" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">요소는 해시이며 기본적으로 &lt;code&gt;()&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">요소는 스칼라이며 기본적으로 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 초기화됩니다 (그러나 &lt;a href=&quot;#Initializing-with-new&quot;&gt;new로 초기화&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f75fd8ea331a93e38c3ea51d7c4505b3a3d036f7" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;undef&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;&quot;Initializing with new&quot;&lt;/a&gt;).</source>
          <target state="translated">요소는 스칼라이며 기본적으로 &lt;code&gt;undef&lt;/code&gt; 로 초기화됩니다 ( &lt;a href=&quot;#Initializing-with-new&quot;&gt;&quot;새로 초기화&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">요소는 배열이며 기본적으로 &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52aeddd404b7b928ef7ca86f1f29047b71eeb8ca" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">요소는 배열이며 기본적으로 &lt;code&gt;()&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">요소의 값은 명명 된 클래스 또는 해당 서브 클래스 중 하나에 축복 된 참조 여야합니다. 요소는 기본적으로 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96e4b34c1d85fc2315f1a2e433a4a09c9e1219d5" translate="yes" xml:space="preserve">
          <source>The elements must be identical</source>
          <target state="translated">요소는 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">배열에서 얻는 요소는 배열 에서 단일 값을 가져 오기 때문에 &lt;code&gt;$&lt;/code&gt; 로 시작 합니다. 스칼라를 요청하면 스칼라를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 은 또한 플립 플롭 연산자의 3 도트 버전 이기 때문에 타원형 명령문은 더 큰 명령문의 일부인 표현식을 나타낼 수 없습니다 ( &lt;a href=&quot;perlop#Range-Operators&quot;&gt;perlop의 범위 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="81b37f465ff28273358e52fdc4fa0d8ce3005267" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement. These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="translated">타원형 문은 더 큰 문의 일부인 식을 나타낼 수 없습니다. 줄임표를 사용하려는 시도의 다음 예는 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">CPAN ID를 받았을 때받은 이메일은 Perl Authors Upload SErver 인 PAUSE에 로그인하는 방법을 알려줍니다. 거기의 메뉴에서 모듈을 CPAN에 업로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="327ff1bdde855523cde51b50cbe96fda9133ba11" translate="yes" xml:space="preserve">
          <source>The empty pattern &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">빈 패턴 &lt;code&gt;//&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4129d1babbccbe45b1d8ec086eee7286a139eb46" translate="yes" xml:space="preserve">
          <source>The encoding being specified.</source>
          <target state="translated">지정되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="64546adcd99f15ed4491ee50ced298a5f03d14c6" translate="yes" xml:space="preserve">
          <source>The encoding event is generated when a test file wants to specify the encoding to be used when formatting its output. This event is intended to be produced by formatter classes and used for interpreting test names, message contents, etc.</source>
          <target state="translated">인코딩 이벤트는 테스트 파일이 출력 형식을 지정할 때 사용할 인코딩을 지정하려고 할 때 생성됩니다. 이 이벤트는 포맷터 클래스에 의해 생성되고 테스트 이름, 메시지 내용 등을 해석하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">인코딩은 Encode 객체로 가정하고, 입력시 sv의 PV는 해당 인코딩에서 8 진수로 가정되며 sv는 유니 코드 (및 UTF-8)로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">인코딩은 Encode 객체로 가정되며, ssv의 PV는 인코딩 및 디코딩이 입력에서 (PV + * offset)이 가리키는 위치에서 시작되는 옥텟으로 가정됩니다. dsv는 ssv에서 디코딩 된 UTF-8 문자열을 연결합니다. 디코딩 출력에 문자열 tstr이 나타나거나 ssv의 PV에서 입력이 종료되면 디코딩이 종료됩니다. 오프셋 포인트가 ssv의 마지막 입력 위치로 수정 될 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2d9b11db298559d7d705aec3e36d98ebb2389cc" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for file system interfaces involving file names. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale_fs&quot;.</source>
          <target state="translated">파일 이름과 관련된 파일 시스템 인터페이스에 적합하다고 결정된 인코딩 이름입니다. &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 은이 인코딩을 &quot;locale_fs&quot;로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="050d2bf9033fce6c43078983175c16f9530f4831" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for the current locale. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale&quot;.</source>
          <target state="translated">현재 로케일에 적합한 것으로 판별 된 인코딩 이름입니다. &lt;a href=&quot;encode&quot;&gt;인코딩&lt;/a&gt; 은이 인코딩을 &quot;로케일&quot;로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">EBCDIC 플랫폼에서는 인코딩 pragma가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">요청 된 인코딩은 Encode 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc406e81e6f88430afa8892d13871c0d72a82fe4" translate="yes" xml:space="preserve">
          <source>The encoding that corresponds to ANSI varies between different editions of Windows. For many western editions of Windows ANSI corresponds to CP-1252 which is a character set similar to ISO-8859-1. Conceptually the ANSI character set is a similar concept to the POSIX locale CODESET so this module figures out what the ANSI code page is and make this available as $ENCODING_LOCALE and the &quot;locale&quot; Encoding alias.</source>
          <target state="translated">ANSI에 해당하는 인코딩은 Windows 버전에 따라 다릅니다. 많은 서부 버전의 Windows ANSI는 ISO-8859-1과 유사한 문자 집합 인 CP-1252에 해당합니다. 개념적으로 ANSI 문자 세트는 POSIX 로케일 CODESET와 유사한 개념이므로이 모듈은 ANSI 코드 페이지가 무엇인지 파악하고이를 $ ENCODING_LOCALE 및 &quot;locale&quot;인코딩 별칭으로 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; 및 &lt;code&gt;STDOUT&lt;/code&gt; 의 인코딩은 pragma에 대한 매개 변수로 개별적으로 설정 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6d62118e6065a9d454aaecd74844f2def3aa8534" translate="yes" xml:space="preserve">
          <source>The encodings to be used for reading and writing output to the a console. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know these encodings as &quot;console_in&quot; and &quot;console_out&quot;.</source>
          <target state="translated">콘솔에서 출력을 읽고 쓰는 데 사용할 인코딩입니다. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; 는 이러한 인코딩을 &quot;console_in&quot;및 &quot;console_out&quot;으로 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">이 모든 것의 최종 결과는 파일 이름 쌍의 목록입니다. 기본적으로 &lt;code&gt;globmap&lt;/code&gt; 이 반환합니다 . 이 예제에서 반환 된 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6253ff05c4cc919ddf707ca73edb1a406fe9c35" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt;. In this example the data structure returned will look like this</source>
          <target state="translated">이 모든 것의 최종 결과는 파일 이름 쌍의 목록입니다. 기본적으로 &lt;code&gt;globmap&lt;/code&gt; 이 반환합니다 . 이 예에서 반환 된 데이터 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fda9b67eec164f9ff303e259fb27be29ca04c85" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function.</source>
          <target state="translated">&lt;code&gt;pack()&lt;/code&gt; Perl 함수를 구현하는 엔진 .</target>
        </trans-unit>
        <trans-unit id="66180c8b26ee487f27a0dc49b26d2d5244b75b6e" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;next_in_list&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; are not used. This call should not be used; use &lt;code&gt;packlist&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;pack()&lt;/code&gt; Perl 함수를 구현하는 엔진 . 참고 : &lt;code&gt;next_in_list&lt;/code&gt; 매개 변수 및 &lt;code&gt;flags&lt;/code&gt; 는 사용되지 않습니다. 이 호출은 사용해서는 안됩니다. 사용 &lt;code&gt;packlist&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="463670dd77f9d4b250cfbf1933d859da20649fdf" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;unpack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;strbeg&lt;/code&gt;, &lt;code&gt;new_s&lt;/code&gt; and &lt;code&gt;ocnt&lt;/code&gt; are not used. This call should not be used, use &lt;code&gt;unpackstring&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;unpack()&lt;/code&gt; Perl 함수를 구현하는 엔진 . 참고 : &lt;code&gt;strbeg&lt;/code&gt; , &lt;code&gt;new_s&lt;/code&gt; 및 &lt;code&gt;ocnt&lt;/code&gt; 매개 변수 는 사용되지 않습니다. 이 호출은 사용 &lt;code&gt;unpackstring&lt;/code&gt; 대신 unpackstring을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">엔진 구현 pack () Perl 함수.</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">엔진 구현 pack () Perl 함수. 참고 : next_in_list 매개 변수 및 플래그는 사용되지 않습니다. 이 호출을 사용해서는 안됩니다. 대신 packlist를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1108f56aaa943f349a8b769e2a9d1fa1d3614cf4" translate="yes" xml:space="preserve">
          <source>The engine implementing the &lt;code&gt;unpack()&lt;/code&gt; Perl function.</source>
          <target state="translated">&lt;code&gt;unpack()&lt;/code&gt; Perl 함수를 구현하는 엔진 .</target>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">unpack () Perl 함수를 구현하는 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">unpack () Perl 함수를 구현하는 엔진. 참고 : 매개 변수 strbeg, new_s 및 ocnt는 사용되지 않습니다. 이 호출을 사용해서는 안됩니다. 대신 unpackstring을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">패턴이 컴파일 된 플래그의 엔진 전용 사본. 엔진이 하나를 수정하도록 선택하지 않는 한 일반적으로 이것은 &lt;code&gt;extflags&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="9ce2a132adf5c2ffffe82f2f2320a1ff022e1a1c" translate="yes" xml:space="preserve">
          <source>The entire file system is compressed such as via &quot;DoubleSpace&quot;.</source>
          <target state="translated">전체 파일 시스템은 &quot;DoubleSpace&quot;와 같이 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">태그를 사용하여 전체 getaddrinfo () 서브 시스템을 내보낼 수 있습니다 &lt;code&gt;:addrinfo&lt;/code&gt; ; getaddrinfo () 및 getnameinfo () 함수와 모든 &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; 및 &lt;code&gt;EAI_*&lt;/code&gt; 상수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="f9deffc2b03edaef07355a1dc99c65f075b4e32e" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt;; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt;, &lt;code&gt;NI_*&lt;/code&gt;, &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">전체한다 getaddrinfo () 서브 시스템은 태그를 사용하여 내보낼 수 있습니다 &lt;code&gt;:addrinfo&lt;/code&gt; ; 이것은 getaddrinfo () 및 getnameinfo () 함수와 모든 &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; 및 &lt;code&gt;EAI_*&lt;/code&gt; 상수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">프로그램이 실행되는 전체 하드웨어 및 소프트웨어 컨텍스트. 기계, 운영 체제, 라이브러리, 컴파일러 또는 시스템 구성 중 하나를 변경하면 플랫폼 종속 언어로 작성된 프로그램이 중단 될 수 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">전체 업그레이드 / 다운 그레이드는 아직 실험 중이며 예상대로 작동하지 않거나 버그가있을 수 있습니다. 다음과 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">환경은 별도의 스칼라 변수로 자동으로 사용 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_RL&lt;/code&gt; 은로드되는 ReadLine 클론을 제어합니다. 값이 false이면 더미 인터페이스가 사용됩니다. 값이 true이면 사용할 패키지 이름의 꼬리 (예 : &lt;code&gt;Perl&lt;/code&gt; 또는 &lt;code&gt;Gnu&lt;/code&gt; ) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="390b6e9b1745d2d828a2345d3a86cf8b0b336f56" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_RL&lt;/code&gt; 은로드되는 ReadLine 클론을 제어합니다. 값이 false이면 더미 인터페이스가 사용됩니다. 값이 true이면 사용할 패키지 이름 (예 : &lt;code&gt;Perl&lt;/code&gt; 또는 &lt;code&gt;Gnu&lt;/code&gt; )의 꼬리 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ee4db4f603bb2d952278fab3f0573c9f206b756" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; is set to &lt;code&gt;unsafe&lt;/code&gt; (see &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;&quot;PERL_SIGNALS&quot; in perlrun&lt;/a&gt;).</source>
          <target state="translated">환경 변수 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; 가 &lt;code&gt;unsafe&lt;/code&gt; 것으로 설정되었습니다 ( &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;perlrun의 &quot;PERL_SIGNALS&quot;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">에러 기능 [C99].</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">오류 수준은 '경고'또는 '오류'여야합니다.</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지 또는 객체는 기본적으로 가장 가까운 엔 클로징 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 제어를 리턴 하지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 때 예외로 사용됩니다 . 어떤 경우에, &lt;code&gt;croak_sv&lt;/code&gt; 기능이 정상적으로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4301dd87f0c694dc26ff0db9df44403205bacc19" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지 또는 객체는 기본적으로 가장 가까운 &lt;code&gt;eval&lt;/code&gt; 에 제어를 반환하는 예외로 사용 되지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다. 어떤 경우에, &lt;code&gt;croak_sv&lt;/code&gt; 기능이 정상적으로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">오류 메시지 또는 오브젝트는 기본적으로 표준 오류로 작성되지만 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지는 기본적으로 제어를 가장 가까운 엔 클로징 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 로 리턴하여 예외로 사용 되지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다. 어쨌든 &lt;code&gt;croak&lt;/code&gt; 함수는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b00b7771ac407f2dd89d3f22f11d4228e791df56" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">오류 메시지는 기본적으로 가장 가까운 &lt;code&gt;eval&lt;/code&gt; 에 제어를 반환하는 예외로 사용 되지만 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 핸들러에 의해 수정 될 수 있습니다. 어쨌든 &lt;code&gt;croak&lt;/code&gt; 함수는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">실패했을 때 &lt;b&gt;syscall에&lt;/b&gt; 의해 리턴 된 오류 번호 . Perl은 &lt;code&gt;$!&lt;/code&gt; 라는 이름으로 오류를 나타냅니다 . (또는 영어 모듈을 사용하는 경우 &lt;code&gt;$OS_ERROR&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c482150704e0bf7cda4048aa90adb166f9af2aa" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">오류 값은 dualvar입니다. &lt;code&gt;EAI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 오류가 발생하지 않으면 숫자로 0이되고 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="31b014cdbfece5798eb6937c7e465a37ae5041c3" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">오류 값은 dualvar입니다. &lt;code&gt;EAI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 호스트 및 서비스 이름은 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">오류 값은 이중 변수입니다. &lt;code&gt;EI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 오류가 발생하지 않으면 숫자로 0이되고 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">오류 값은 이중 변수입니다. &lt;code&gt;EI_*&lt;/code&gt; 오류 상수 와 비슷 하거나 사람이 읽을 수있는 오류 메시지 문자열로 인쇄 할 수 있습니다. 호스트 및 서비스 이름은 일반 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="69f6f9a5df3062e908bd0165d9c2b9fe0563d15c" translate="yes" xml:space="preserve">
          <source>The errors facet is a list instead of a single item, any number of errors can be listed. In this facet &lt;code&gt;details&lt;/code&gt; describes the error, or may contain the raw error message itself (such as an exception). In perl exception may be blessed objects, as such the raw data for this facet may contain nested items which are blessed.</source>
          <target state="translated">오류 패싯은 단일 항목이 아닌 목록이며, 여러 오류를 나열 할 수 있습니다. 이 패싯 &lt;code&gt;details&lt;/code&gt; 에서 오류를 설명하거나 원시 오류 메시지 자체 (예 : 예외)를 포함 할 수 있습니다. Perl에서는이 패싯에 대한 원시 데이터에 blessed 중첩 된 항목이 포함될 수 있으므로 blessed 개체가 예외 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce05d758ea509461baa38b741595abae13996ba5" translate="yes" xml:space="preserve">
          <source>The escape is the beginning or final end point of a range</source>
          <target state="translated">이스케이프는 범위의 시작 또는 끝 지점입니다.</target>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">평가 수정 자 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 는 대체 문자열을 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; 감싸고 평가 된 결과는 일치하는 하위 문자열로 대체됩니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="acb75763cbe80034d5f373af05d3a0392a02769b" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;s///e&lt;/code&gt; wraps an &lt;code&gt;eval{...}&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">평가 수정 자 &lt;code&gt;s///e&lt;/code&gt; 는 대체 문자열 주위에 &lt;code&gt;eval{...}&lt;/code&gt; 래핑 하고 평가 된 결과는 일치하는 하위 문자열로 대체됩니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="cfba3806303ac6dda3f30dd80fde49f7e2183210" translate="yes" xml:space="preserve">
          <source>The event from &lt;code&gt;ok(1, &quot;pass&quot;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ok(1, &quot;pass&quot;)&lt;/code&gt; 의 이벤트</target>
        </trans-unit>
        <trans-unit id="863be168c93a9b4e951447892af8574c10035f63" translate="yes" xml:space="preserve">
          <source>The event of a plan</source>
          <target state="translated">계획의 이벤트</target>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">이 매크로의 정확한 구현은 아키텍처 및 버전의 perl에 따라 다르며 반환 값은 호출마다 변경 될 수 있으므로 단일 perl 프로세스 기간 동안 만 값이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">정확한 줄 번호는 다를 수 있지만 경고 (W)가 줄 줄에서 오는 경우</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">정확한 줄 번호는 Perl 릴리스마다 다를 수 있습니다. 경고는 양성이며 무시할 수 있습니다. 나중의 C 컴파일러 릴리스에서는 경고가 사라져야합니다.</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">주소가 $ symref로 반환되는 정확한 방법은 현재 정의되어 있지 않습니다. 초기 요구 사항은 $ symref가 dl_install_xsub ()로 전달되고 이해 될 수 있어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos 필드의 정확한 의미는 다양하지만 일반적으로 사용자의 실제 이름 (로그인 이름과 반대) 및 사용자와 관련된 기타 정보를 포함합니다. 그러나 많은 시스템 사용자가이 정보를 변경할 수 있으므로 신뢰할 수 없으므로 $ gcos가 오염됩니다 ( &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). 같은 이유로 사용자의 암호화 된 비밀번호 및 로그인 쉘인 $ passwd 및 $ shell도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcos 필드의 정확한 의미는 다양하지만 일반적으로 사용자의 실제 이름 (로그인 이름과 반대) 및 사용자와 관련된 기타 정보를 포함합니다. 그러나 많은 시스템 사용자가이 정보를 변경할 수 있으므로 신뢰할 수 없으므로 $ gcos가 오염됩니다 ( &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; 참조 ). 같은 이유로 사용자의 암호화 된 비밀번호 및 로그인 쉘인 $ passwd 및 $ shell도 오염됩니다.</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">패턴에서 (?? {}) 및 (? {})가 얼마나 자주 실행되는지에 대한 정확한 규칙은 지정되지 않습니다. 성공적으로 일치하는 경우 DWIM이라고 가정 할 수 있으며 다른 메타 패턴과 마찬가지로 패턴의 허용 경로에서 적절한 횟수만큼 왼쪽에서 오른쪽으로 실행됩니다. 허용되지 않는 경로와 일치 실패가 패턴이 실행되는 횟수에 영향을주는 방식은 구체적으로 지정되지 않으며 패턴에 적용 할 수있는 최적화에 따라 다를 수 있으며 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf1655ab3b8310f5b318568059958f807b33f0d" translate="yes" xml:space="preserve">
          <source>The exact rules for how often &lt;code&gt;(??{})&lt;/code&gt; and &lt;code&gt;(?{})&lt;/code&gt; are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">패턴에서 &lt;code&gt;(??{})&lt;/code&gt; 및 &lt;code&gt;(?{})&lt;/code&gt; 가 실행되는 빈도에 대한 정확한 규칙 은 지정되지 않습니다. 성공적인 일치의 경우 DWIM을 가정하고 다른 메타 패턴과 마찬가지로 패턴의 허용 경로에서 적절한 횟수만큼 왼쪽에서 오른쪽 순서로 실행될 것이라고 가정 할 수 있습니다. 비 수락 경로 및 일치 실패가 패턴 실행 횟수에 미치는 영향은 구체적으로 지정되지 않았으며 패턴에 적용 할 수있는 최적화에 따라 달라질 수 있으며 버전마다 변경 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">단 하나의 &quot;= for&quot;단락을 사용하면 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb72ca6692327d6fee94ee24d9e91cba6dc1e016" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">TYPE 및 ATTRS의 정확한 의미와 인터페이스는 여전히 진화하고 있습니다. TYPE은 현재의 사용에 바인딩 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; 프라 그마 및 속성은 사용하여 처리하는 &lt;a href=&quot;attributes&quot;&gt;속성의&lt;/a&gt; 도를 통해, 펄 5.8.0부터, 프라그를, 또는 &lt;a href=&quot;Attribute::Handlers&quot;&gt;특성 :: 처리기&lt;/a&gt; 모듈. 자세한 내용 &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;은 perlsub의 &quot;my ()를 통한 개인 변수&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 Perl 5.8.0부터 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;../fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;../attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 Perl 5.8.0부터 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4b162d38593f0c61d02eda524507bf4fd01fab9" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;use constant&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#__PACKAGE__&quot;&gt;&lt;code&gt;__PACKAGE__&lt;/code&gt;&lt;/a&gt;. It is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or starting from Perl 5.8.0 also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">TYPE 및 ATTRS의 정확한 의미와 인터페이스는 여전히 진화하고 있습니다. TYPE은 &lt;a href=&quot;#__PACKAGE__&quot;&gt; &lt;code&gt;__PACKAGE__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;use constant&lt;/code&gt; 로&lt;/a&gt; 선언 된 상수 또는 __PACKAGE__ 일 수 있습니다. 그것은 현재의 사용에 바인딩 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; 프라 그마 및 속성은 사용하여 처리하는 &lt;a href=&quot;attributes&quot;&gt;속성의&lt;/a&gt; 프라그를, 또는 Perl 5.8.0에서도를 통해 시작 &lt;a href=&quot;Attribute::Handlers&quot;&gt;특성 :: 처리기&lt;/a&gt; 모듈. 자세한 내용 &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;은 perlsub의 &quot;my ()를 통한 개인 변수&quot;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 로 선언 된 상수 또는 __PACKAGE__ 일 수 있습니다. 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 Perl 5.8.0부터 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPE과 ATTRS의 정확한 의미와 인터페이스는 여전히 발전하고 있습니다. TYPE은 &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 로 선언 된 상수 또는 __PACKAGE__ 일 수 있습니다. 현재 pragma &lt;code&gt;fields&lt;/code&gt; 사용에 바인딩되어 있으며 &lt;code&gt;attributes&lt;/code&gt; pragma를 사용하거나 &lt;code&gt;Attribute::Handlers&lt;/code&gt; 모듈을 통해 Perl 5.8.0부터 속성을 처리 합니다. 세부 사항 및 &lt;a href=&quot;../fields&quot;&gt;필드&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;../attribute/handlers&quot;&gt;속성 :: Handlers &lt;/a&gt;&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;에 대해서는 perlsub에서 my ()를 통한 전용 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 정확한 문자 세트는 다양한 pragma 및 정규식 수정 자에 따라 다릅니다. &lt;code&gt;/a&lt;/code&gt; 정규식 수정자를 사용하여 일치를 ASCII 범위로 제한 할 수 있습니다 . &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23a6f9e0bca7b676930bcaa64329c3c867e0685e" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 &lt;code&gt;\w&lt;/code&gt; 와 일치하는 정확한 문자 집합은 다양한 pragma 및 정규식 수정 자에 따라 다릅니다. &lt;code&gt;/a&lt;/code&gt; 정규식 수정자를 사용하여 일치를 ASCII 범위로 제한 할 수 있습니다 . &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="319ae490a71e74c46be21bc09971371ff532d6a8" translate="yes" xml:space="preserve">
          <source>The example above uses &lt;code&gt;select()&lt;/code&gt;, but any similar mechanism should work analogously. &lt;code&gt;IO::Socket::IP&lt;/code&gt; takes care when creating new socket filehandles to preserve the actual file descriptor number, so such techniques as &lt;code&gt;poll&lt;/code&gt; or &lt;code&gt;epoll&lt;/code&gt; should be transparent to its reallocation of a different socket underneath, perhaps in order to switch protocol family between &lt;code&gt;PF_INET&lt;/code&gt; and &lt;code&gt;PF_INET6&lt;/code&gt;.</source>
          <target state="translated">위의 예제는 &lt;code&gt;select()&lt;/code&gt; 를 사용하지만 유사한 메커니즘은 유사하게 작동합니다. &lt;code&gt;IO::Socket::IP&lt;/code&gt; 는 실제 파일 설명자 번호를 보존하기 위해 새 소켓 파일 핸들을 만들 때주의를 기울입니다. 따라서 &lt;code&gt;poll&lt;/code&gt; 또는 &lt;code&gt;epoll&lt;/code&gt; 과 같은 기술은 아마도 &lt;code&gt;PF_INET&lt;/code&gt; 간에 프로토콜 패밀리를 전환하기 위해 아래에있는 다른 소켓의 재 할당에 투명해야합니다. 및 &lt;code&gt;PF_INET6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="130d6baa202fd58693c4e06f24211f73d068ae4b" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The &lt;code&gt;DEFINE&lt;/code&gt; group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">아래 예제는 이전에 제시된 부동 소수점 숫자에 대한 패턴을 사용하여이 기능을 보여줍니다. 두 번 이상 사용되는 세 가지 하위 패턴은 선택적 부호, 정수에 대한 숫자 시퀀스 및 소수입니다. 패턴 끝에 있는 &lt;code&gt;DEFINE&lt;/code&gt; 그룹에는 해당 정의가 포함됩니다. 소수 패턴은 정수 패턴을 재사용 할 수있는 첫 번째 장소입니다.</target>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">아래 예는 앞에서 제시 한 부동 소수점 숫자에 대한 패턴을 사용하여이 기능을 보여줍니다. 두 번 이상 사용되는 세 개의 하위 패턴은 선택적 부호, 정수의 숫자 시퀀스 및 소수입니다. 패턴 끝에있는 DEFINE 그룹에는 해당 정의가 포함됩니다. 소수 패턴은 정수 패턴을 재사용 할 수있는 첫 번째 위치입니다.</target>
        </trans-unit>
        <trans-unit id="c669b79bf926dbbee70a1aab0498c88f6e21bd08" translate="yes" xml:space="preserve">
          <source>The example below shows what you need if</source>
          <target state="translated">아래 예는 다음과 같은 경우 필요한 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 와 일치하는 문자 가 로케일에 의해 결정 되므로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 이 유효한 경우이 예제는 &lt;code&gt;$data&lt;/code&gt; 를 포함하지 않습니다 . Perl은 로케일 정의가 프로그램 외부의 데이터를 포함하므로 신뢰할 수없는 것으로 간주합니다. 당신이 로케일 인식 프로그램을 작성하고, 포함하는 정규 표현식과 론더 데이터를 원하는 경우 &lt;code&gt;\w&lt;/code&gt; 삽입하지 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 로케일을 같은 블록에 표현 앞서. 추가 토론 및 예 &lt;a href=&quot;perllocale#SECURITY&quot;&gt;는 perllocale의 보안을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36698f0de180b3f94fb468b665a41ca7be987afb" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;use locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt;, put &lt;code&gt;no locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;&quot;SECURITY&quot; in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">이 예제는 &lt;code&gt;use locale&lt;/code&gt; 이 유효한 경우 &lt;code&gt;$data&lt;/code&gt; untaint하지 않습니다. &lt;code&gt;\w&lt;/code&gt; 와 일치하는 문자 는 로케일에 의해 결정 되기 때문 입니다. Perl은 로케일 정의가 프로그램 외부의 데이터를 포함하기 때문에 신뢰할 수 없다고 간주합니다. 당신이 로케일 인식 프로그램을 작성하고, 포함하는 정규 표현식과 론더 데이터를 원하는 경우 &lt;code&gt;\w&lt;/code&gt; 삽입하지 &lt;code&gt;no locale&lt;/code&gt; 같은 블록에 표현 앞서. 추가 논의 및 예제 &lt;a href=&quot;perllocale#SECURITY&quot;&gt;는 perllocale의 &quot;보안&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">위의 예제는 펄 인터프리터에 대한 상대 경로를 사용하여 사용자 경로에서 첫 번째 버전을 가져옵니다. 예를 들어 perl5.14.1과 같은 특정 버전의 Perl을 원한다면 &lt;code&gt;#!&lt;/code&gt; 직접 배치해야합니다 ! 라인의 경로.</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">문서 시작 부분에 제공된 예제 (오류 처리기 및 이벤트 기반 프로그램)는 콜백에서 발생할 수있는 두 가지 주요 종류의 흐름 제어의 전형적인 예입니다. 그들 사이에는 매우 중요한 차이점이 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">예제는 몇 가지 측면을 보여줍니다. 처음 세 개의 쿼리는 모듈, 작성자 또는 배포를 직접 대상으로하며 정확히 하나의 결과를 산출합니다. 마지막 두 개는 정규 표현식을 사용하고 여러 결과를 산출합니다. 마지막은 모든 번들, 모듈, 작성자 및 배포를 동시에 대상으로합니다. 사용 가능한 결과가 두 개 이상인 경우 한 줄 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">이전 섹션의 예제는 성가신 약점을 보여줍니다. 우리는 3 글자 단어 나 4 글자 이하의 단어 만 일치 시켰습니다. &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; 와 같은 지루한 대안을 작성하지 않고 단어 또는 더 일반적으로 길이가 긴 문자열과 일치시킬 수 있기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="da6aadb818ba37828bf9750c2c1c42a56a0d0753" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt;.</source>
          <target state="translated">이전 섹션의 예는 성가신 약점을 보여줍니다. 3 글자 단어 또는 4 글자 이하의 단어 청크 만 일치 시켰습니다. &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; 와 같은 지루한 대안을 작성하지 않고도 단어 또는 더 일반적으로 모든 길이의 문자열을 일치시킬 수 있기를 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">예제는 다음을 구현하는 매우 간단한 클래스를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">예제는이 클래스가 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 의해 서로 다른 수준의 지원으로 구현 되었음을 보여줍니다 . 지원되는 모든 조합이 표시됩니다. 구현 간의 차이는 종종 매우 작습니다. 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cfc17e4302419b2090ffa8fca11900025b88c94" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">예제는 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; 의해 다양한 수준의 지원으로 구현 된이 클래스를 보여줍니다 . 지원되는 모든 조합이 표시됩니다. 구현 간의 차이는 종종 매우 작습니다. 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt; 의 우수한 캘린더 FAQ</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">뛰어난 Filter :: Util :: Call 모듈 (Paul Marquess 제작)은 소스 필터링에 유용한 Perl 인터페이스를 제공하지만, 너무 강력하고 단순하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">프로그램에서 정책을 체계화 할 수있는 조직 별 이메일 (예 : foo@yourcompany.com)은 예외입니다. 이 경우, 다음과 같이 스칼라 컨텍스트에서 $ ENV {USER}, $ ENV {LOGNAME} 및 getpwuid ($ &amp;lt;)를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b5fd23c00f654857837ce525e2feca5e5a60486" translate="yes" xml:space="preserve">
          <source>The exception to the above rule is when the left-hand string begins with &lt;code&gt;0&lt;/code&gt; and is longer than one character, in this case the magic increment</source>
          <target state="translated">위의 규칙에 대한 예외는 왼쪽 문자열이 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 한 문자보다 긴 경우입니다.이 경우 매직 증분</target>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">&quot;하나의 오염 된 값이 전체 표현을 오염시킨다&quot;는 원칙은 예외적으로 삼항 조건 연산자 &lt;code&gt;?:&lt;/code&gt; 입니다. 삼항 조건을 가진 코드부터</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">이 규칙의 예외는</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">이 규칙의 예외는 XSUB 함수에서 직접 Perl 서브 루틴을 호출하는 경우입니다. 이 경우 &lt;code&gt;dSP&lt;/code&gt; 매크로를 명시 적으로 사용할 필요가 없으며 자동으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">실행 순서는 &lt;code&gt;===&amp;gt;&lt;/code&gt; 마크로 표시되므로 &lt;code&gt;3 4 5 6&lt;/code&gt; (노드 &lt;code&gt;6&lt;/code&gt; 은 위 목록에 포함되지 않음)입니다. 즉, &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db1745f72327cdbec0c0f35f7353b51ef20c7bd5" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3 4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt;.</source>
          <target state="translated">실행 순서는 &lt;code&gt;===&amp;gt;&lt;/code&gt; 표시로 표시되므로 &lt;code&gt;3 4 5 6&lt;/code&gt; (노드 &lt;code&gt;6&lt;/code&gt; 은 위 목록에 포함되지 않음)입니다. 즉, &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">요약 : 파일 시스템 작동 방식을 익히십시오. 파일에 대한 권한은 해당 파일의 데이터에 발생할 수있는 일을 말합니다. 디렉토리에 대한 권한은 해당 디렉토리의 파일 목록에서 발생할 수있는 작업을 나타냅니다. 파일을 삭제하면 디렉토리에서 파일 이름이 제거됩니다 (따라서 작업은 파일이 아닌 디렉토리의 권한에 따라 다릅니다). 파일에 쓰려고하면 파일의 권한이 허용 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8bd1d5ba511947aaf27cf0898729cbcdb3363ec9" translate="yes" xml:space="preserve">
          <source>The existence of a rule does not imply selecting a test. You must still specify the tests to run.</source>
          <target state="translated">규칙이 있다고해서 테스트를 선택하는 것은 아닙니다. 여전히 실행할 테스트를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">실행 된 프로그램의 종료 코드</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">종료 상태 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit () 함수가 항상 즉시 종료되는 것은 아닙니다. 정의 된 &lt;code&gt;END&lt;/code&gt; 루틴을 먼저 호출 하지만이 &lt;code&gt;END&lt;/code&gt; 루틴 자체가 종료를 중단 할 수는 없습니다. 마찬가지로 호출해야하는 객체 소멸자가 실제 종료 전에 호출됩니다. &lt;code&gt;END&lt;/code&gt; 루틴 및 소멸자는 &lt;code&gt;$?&lt;/code&gt; 를 수정하여 종료 상태를 변경할 수 있습니다 . . 이것이 문제이면 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 를 호출 하여 END 및 소멸자 처리를 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit () 함수가 항상 즉시 종료되는 것은 아닙니다. 정의 된 &lt;code&gt;END&lt;/code&gt; 루틴을 먼저 호출 하지만이 &lt;code&gt;END&lt;/code&gt; 루틴 자체가 종료를 중단 할 수는 없습니다. 마찬가지로 호출해야하는 객체 소멸자가 실제 종료 전에 호출됩니다. &lt;code&gt;END&lt;/code&gt; 루틴 및 소멸자는 &lt;code&gt;$?&lt;/code&gt; 를 수정하여 종료 상태를 변경할 수 있습니다 . . 이것이 문제이면 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; 를 호출 하여 END 및 소멸자 처리를 피할 수 있습니다. 자세한 내용은 &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">실험적으로 &lt;code&gt;given&lt;/code&gt; 진술은</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">실험 &lt;code&gt;legacy&lt;/code&gt; 프라그 마는 &lt;code&gt;feature&lt;/code&gt; 프라그 마에 의해 삼켰다 .</target>
        </trans-unit>
        <trans-unit id="52d7e8e19cc3efaf2aec8d989a33421d70ed317d" translate="yes" xml:space="preserve">
          <source>The experimental declared_refs feature is not enabled</source>
          <target state="translated">실험용 declaration_refs 기능이 사용 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0ccc48fde094b67b79701d699ac45d91d085adcc" translate="yes" xml:space="preserve">
          <source>The experimental feature &lt;code&gt;&quot;(?[...])&quot;&lt;/code&gt; starting in v5.18 accomplishes this.</source>
          <target state="translated">v5.18부터 시작 되는 실험적 기능 &lt;code&gt;&quot;(?[...])&quot;&lt;/code&gt; 이이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="868cc46704185b2a446e1b7a62d0312275a48c48" translate="yes" xml:space="preserve">
          <source>The explanation above has omitted some detail; refer to UAX#24 &quot;Unicode Script Property&quot;: &lt;a href=&quot;https://www.unicode.org/reports/tr24&quot;&gt;https://www.unicode.org/reports/tr24&lt;/a&gt;.</source>
          <target state="translated">위의 설명은 일부 세부 사항을 생략했습니다. UAX # 24 &quot;유니 코드 스크립트 속성&quot;: &lt;a href=&quot;https://www.unicode.org/reports/tr24&quot;&gt;https://www.unicode.org/reports/tr24를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0349830ce8cbe97566441b2e1c5b4811ccfb44c1" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;'e'&lt;/code&gt; or &lt;code&gt;'E'&lt;/code&gt;, followed by an integer. So the exponent regexp is</source>
          <target state="translated">지수는 &lt;code&gt;'e'&lt;/code&gt; 또는 &lt;code&gt;'E'&lt;/code&gt; 뒤에 정수가옵니다. 따라서 지수 정규식은</target>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">지수는 &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 이며 정수가 뒤에옵니다. 지수 정규 표현식은</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">지수 연산자는 &quot;^&quot;가 아니라 &quot;**&quot;입니다. &quot;^&quot;는 C에서와 같이 XOR 연산자입니다. &lt;b&gt;awk&lt;/b&gt; 가 기본적으로 C와 호환되지 않는다는 느낌을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">식은 스칼라 컨텍스트에서 평가됩니다. 따라서 다음이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">ext / ODBM_File / odbm은 Tru64의 정적 libdbm 라이브러리의 알려진 버그로 인해 정적 빌드 (Configure -Uusedl)와 함께 실패하는 것으로 알려져 있습니다. 좋은 소식은 고급 DB2_File은 말할 것도없고 고급 NDBM_File도 제대로 작동하기 때문에 ODBM_File 확장명을 사용할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">확장 된 파일 테스트 기능은 파일 핸들이 아닌 연산자의 인수가 파일 이름 인 경우에만 Perl에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">확장은 동적으로 연결됩니다</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">확장명은 순수한 perl이므로 perl 실행 파일에 연결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">확장은 정적으로 펄 바이너리에 연결됩니다</target>
        </trans-unit>
        <trans-unit id="b14db60112e20420246ea9d3dec3923a929f96a3" translate="yes" xml:space="preserve">
          <source>The extracted information is stored in 5 entries in the &lt;code&gt;build&lt;/code&gt; hash:</source>
          <target state="translated">추출 된 정보는 &lt;code&gt;build&lt;/code&gt; 해시의 5 개 항목에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 구분자를 포함하여 추출 된 문자열 추출에 실패하면 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a2570abc8ab1be73d003248dd246a24a2fc5f319" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 구분 기호를 포함하는 추출 된 문자열입니다. 추출에 실패하면 &lt;code&gt;undef&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">추출 된 termcap 항목은 오브젝트에서 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="adf0aca1542de815275e994553ee7120f60337c3" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt;.</source>
          <target state="translated">추출 된 termcap 항목은 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; 로 오브젝트에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">추출 프로세스는 각 추출기를 순차적으로 텍스트 문자열에 적용하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">이러한 FILE *이 '내 보낸'사실은 (일반적으로 PerlIO에 새로운 : stdio &quot;계층&quot;을 밀어 넣어 *) 기록됩니다. 이는 원래 PerlIO *의 향후 PerlIO 작동에 영향을 줄 수 있습니다. 당신은 호출하지 않아야합니다 &lt;code&gt;fclose()&lt;/code&gt; 당신이 필요하지 않은 경우 파일에 &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; 은 PerlIO에서 연결을 해제 할 *. 연결 해제를 위해 PerlIO_importFILE ()을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">공장 자체는 인스턴스화되지 않습니다 (이것은</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">fastgetcwd () 함수는 cwd ()의 동의어로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3c06a8aa0a4d260ed2765600496ce1fc1ffcef9e" translate="yes" xml:space="preserve">
          <source>The feature logical name &lt;code&gt;PERL_VMS_VTF7_FILENAMES&lt;/code&gt; controls if UNICODE characters in Unix filenames are encoded in VTF-7 notation in the resulting OpenVMS file specification. [Currently under development]</source>
          <target state="translated">기능 논리 이름 &lt;code&gt;PERL_VMS_VTF7_FILENAMES&lt;/code&gt; 는 결과 OpenVMS 파일 사양에서 Unix 파일 이름의 UNICODE 문자가 VTF-7 표기법으로 인코딩되는지 여부를 제어합니다. [현재 개발 중]</target>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">기능 논리 이름 DECC $ FILENAME_UNIX_REPORT는 파일 스펙을 Unix에서 VMS 형식으로 변환 할 때 기존 Perl 동작을 수정하여 CRTL에 의해 현재 예상되는 확장 문자 처리 규칙을 따릅니다. &lt;code&gt;./.../&lt;/code&gt; 기능이 적용되면 Unix 경로 의 ./.../ 가 기존 VMS &lt;code&gt;[...]&lt;/code&gt; 대신 &lt;code&gt;[.^.^.^.]&lt;/code&gt; 로 변환 됩니다 . MakeMaker가 기대하는 것과 호환되도록 VMS 경로를 Unix 경로로 변환 할 수 없으면 변경되지 않은 상태로 전달되므로 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; 는 &lt;code&gt;[...]&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="cd427ddb1d40a440a4569bc32b983da79c223869" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt;. To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt;.</source>
          <target state="translated">기능 논리 이름 DECC $ FILENAME_UNIX_REPORT는 현재 CRTL에서 예상하는 확장 문자 처리 규칙을 따르기 위해 Unix에서 VMS 형식으로 파일 사양을 변환 할 때 기존 Perl 동작을 수정합니다. &lt;code&gt;./.../&lt;/code&gt; 기능이 적용되면 Unix 경로 의 ./.../ 가 기존 VMS &lt;code&gt;[...]&lt;/code&gt; 대신 &lt;code&gt;[.^.^.^.]&lt;/code&gt; 로 변환 됩니다 . MakeMaker가 예상하는 것과 호환되도록 VMS 경로를 Unix 경로로 변환 할 수없는 경우 변경되지 않은 상태로 전달되므로 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; 는 &lt;code&gt;[...]&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">이 기능은 &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; 로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b1fe35afa1a3972e367d70f65936f774e7c1fb4" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt;.</source>
          <target state="translated">이 기능은 &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; 로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">당신이 당신의 어머니와 아버지로부터 얻은 특징은, 예측할 수없이 혼합되었습니다. ( &lt;b&gt;상속&lt;/b&gt; 및 &lt;b&gt;단일 상속&lt;/b&gt; 도 참조하십시오 .) 컴퓨터 언어 (Perl 포함)에서 주어진 클래스에 여러 개의 직계 조상이나 &lt;b&gt;기본 클래스&lt;/b&gt; 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">아버지가 없다고 말하면 어머니에게서받은 특징. ( &lt;b&gt;상속&lt;/b&gt; 및 &lt;b&gt;다중 상속&lt;/b&gt; 도 참조하십시오 .) 컴퓨터 언어에서, 주어진 클래스가 하나의 직계 조상 또는 &lt;b&gt;기본 클래스를&lt;/b&gt; 가질 수 있도록 &lt;b&gt;클래스가&lt;/b&gt; 무성 생식 한다는 생각 . Perl은 그러한 제한을 제공하지 않지만, 원하는 경우 확실히 Perl을 프로그래밍 할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="587f845c68a8e5df6c3b5c11be163e859d4bde0c" translate="yes" xml:space="preserve">
          <source>The few places where stricter matching is used is in the middle of numbers, the &quot;name&quot; property, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">보다 엄격한 일치가 사용되는 몇 군데는 숫자 중간, &quot;이름&quot;속성 및 밑줄로 시작하거나 끝나는 Perl 확장 속성에 있습니다. 엄격한 일치는 공백 (단어가 아닌 문자에 인접한 경우 제외), 하이픈 및 내부 밑줄이 아닌 경우를 고려합니다.</target>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">&quot;@ *&quot;필드는 여러 줄의 잘리지 않은 값을 인쇄하는 데 사용할 수 있습니다. 그것은 그 자체로 줄에 나타나야하지만 (필요하지는 않지만) 마지막 줄 바꿈이 끊어 지지만 다른 모든 문자는 그대로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="90122eb3cf35f8e2aff21a4431fdb4311bb6f9c0" translate="yes" xml:space="preserve">
          <source>The field of Linguistics has expended a great deal of effort over the past century trying to find grammatical patterns which hold across languages; it's been a constant process of people making generalizations that should apply to all languages, only to find out that, all too often, these generalizations fail -- sometimes failing for just a few languages, sometimes whole classes of languages, and sometimes nearly every language in the world except English. Broad statistical trends are evident in what the &quot;average language&quot; is like as far as what its rules can look like, must look like, and cannot look like. But the &quot;average language&quot; is just as unreal a concept as the &quot;average person&quot; -- it runs up against the fact no language (or person) is, in fact, average. The wisdom of past experience leads us to believe that any given language can do whatever it wants, in any order, with appeal to any kind of grammatical categories wants -- case, number, tense, real or metaphoric characteristics of the things that words refer to, arbitrary or predictable classifications of words based on what endings or prefixes they can take, degree or means of certainty about the truth of statements expressed, and so on, ad infinitum.</source>
          <target state="translated">언어학 분야는 지난 세기 동안 여러 언어에 걸친 문법적 패턴을 찾기 위해 많은 노력을 기울였습니다. 모든 언어에 적용되어야하는 일반화를 만드는 사람들의 끊임없는 과정이었습니다. 이러한 일반화가 너무 자주 실패한다는 사실을 알게되었습니다. 때로는 몇 가지 언어, 때로는 전체 언어 클래스, 때로는 거의 모든 언어에 대해 실패합니다. 영어를 제외한 세계에서. 규칙이 어떻게 생겼는지, 생겼는지, 생겼을 수 없는지에 관한 한 &quot;평균 언어&quot;가 어떤 것인지에 대한 광범위한 통계 추세가 분명합니다. 그러나 &quot;평균적인 언어&quot;는 &quot;평균적인 사람&quot;만큼 비현실적인 개념입니다. 실제로 어떤 언어 (또는 사람)도 평균이 아니라는 사실에 반합니다.과거 경험의 지혜는 주어진 언어가 단어가 참조하는 것들의 대소 문자, 숫자, 시제, 실제 또는 은유 적 특성과 같은 모든 종류의 문법 범주가 원하는 모든 종류의 호소력과 함께 원하는 순서로 원하는 것을 할 수 있다고 믿게합니다. 어떤 어미 나 접두사를 취할 수 있는지, 표현 된 진술의 진실에 대한 확실성의 정도 또는 수단 등에 기초한 임의적이거나 예측 가능한 단어 분류, 등등.</target>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">필드는 아래에서 더 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="c46c3f9340cdb846123d0b6b0164cec0b439e50c" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in &lt;code&gt;S_parse_body&lt;/code&gt;, and the :offset (might be missing) tells how much inside the &lt;code&gt;S_parse_body&lt;/code&gt; the program counter was.</source>
          <target state="translated">필드는 탭으로 구분됩니다. 첫 번째 열은 깊이입니다 (0은 건너 뛰지 않은 가장 안쪽 프레임 임). hex : offset에서 hex는 프로그램 카운터가 &lt;code&gt;S_parse_body&lt;/code&gt; 에있는 위치이고 : offset (누락 될 수 있음)은 프로그램 카운터가 &lt;code&gt;S_parse_body&lt;/code&gt; 내부에 얼마나 있었는지 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">필드는 탭으로 구분됩니다. 첫 번째 열은 깊이입니다 (가장 튀지 않은 가장 안쪽의 프레임은 0 임). hex : offset에서 16 진은 프로그램 카운터가 S_parse_body에있는 위치이며, : offset (없을 수 있음)은 S_parse_body 내부에서 프로그램 카운터의 양을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f2427d714dfbcb812d5c2c0e464389b37b28e37a" translate="yes" xml:space="preserve">
          <source>The fields in the</source>
          <target state="translated">의 필드</target>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">이 줄에 나타날 수있는 관심 분야는</target>
        </trans-unit>
        <trans-unit id="834f0bb251e57720466af45a551b7e653c4d2d6b" translate="yes" xml:space="preserve">
          <source>The fields of the context struct and the arguments to the &lt;code&gt;cx_*&lt;/code&gt; functions are subject to change between perl releases, representing whatever is convenient or efficient for that release.</source>
          <target state="translated">컨텍스트 구조체의 필드와 &lt;code&gt;cx_*&lt;/code&gt; 함수에 대한 인수 는 perl 릴리스간에 변경 될 수 있으며 해당 릴리스에 대해 편리하거나 효율적인 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">파일</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">오류가 발생한 파일 (이름)</target>
        </trans-unit>
        <trans-unit id="801d0d7bebcd5bd5a38aa07b4d567dc82dc85f4a" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in. Defaults to the name of the current file being processed.</source>
          <target state="translated">오류가 발생한 파일 (이름)입니다. 기본값은 현재 처리중인 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">&lt;code&gt;perlio.c&lt;/code&gt; 파일 은 다음 레이어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">MANIFEST.SKIP 파일은 mkmanifest () 및 filecheck ()에 의해 무시되어야하는 파일의 정규식을 포함 할 수 있습니다. 정규식은 각 줄에 하나씩 표시되어야합니다. 빈 줄과 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 건너 뜁니다. 사용 &lt;code&gt;\#&lt;/code&gt; 당신은 시작하는 정규 표현식을 필요로하는 경우 &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4d65899438f61d608a7cb61bcc5fc30c8781c4" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">MANIFEST.SKIP 파일에는 mkmanifest () 및 filecheck ()에서 무시해야하는 파일의 정규식이 포함될 수 있습니다. 정규식은 각 줄에 하나씩 나타나야합니다. &lt;code&gt;#&lt;/code&gt; 로 시작하는 빈 줄과 줄 은 건너 뜁니다. 사용 &lt;code&gt;\#&lt;/code&gt; 당신은 시작하는 정규 표현식을 필요로하는 경우 &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">Makefile.PL 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Mytest.pm 파일은 다음과 같이 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">Unicode / Collate / allkeys.txt 파일은 &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt; 에서 그대로 복사되었습니다 . 이 파일에 대해 저작권 (C) 2001에서 2012 사이 유니 코드, 주식의 이용 약관에 따라 배포 &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a5f318824f5507113c28e19247cf8309413692" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2016 Unicode, Inc.; distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/terms_of_use.html&quot;&gt;http://www.unicode.org/terms_of_use.html&lt;/a&gt;</source>
          <target state="translated">Unicode / Collate / allkeys.txt 파일은 &lt;a href=&quot;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&lt;/a&gt; 에서 그대로 복사되었습니다 . 이 파일의 경우 Copyright (c) 2016 Unicode, Inc .; &lt;a href=&quot;http://www.unicode.org/terms_of_use.html&quot;&gt;http://www.unicode.org/terms_of_use.html&lt;/a&gt; 의 이용 약관에 따라 배포됩니다 .</target>
        </trans-unit>
        <trans-unit id="588cd9780438caba5355d1e82516b077a96efe46" translate="yes" xml:space="preserve">
          <source>The file in which the error occurred (eg, &lt;code&gt;myscript.pl&lt;/code&gt; or &lt;code&gt;MyTest.pm&lt;/code&gt;).</source>
          <target state="translated">오류가 발생한 파일 (예 : &lt;code&gt;myscript.pl&lt;/code&gt; 또는 &lt;code&gt;MyTest.pm&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">파일은</target>
        </trans-unit>
        <trans-unit id="e4567b3de0171c763b083662777b94d3405e1c0f" translate="yes" xml:space="preserve">
          <source>The file is a sparse file.</source>
          <target state="translated">파일이 스파 스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="10a1515b1fc6663ef9dea0c0281497256e9502ad" translate="yes" xml:space="preserve">
          <source>The file is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because often the application deletes the temporary file shortly after the handle is closed. In that case, the system can entirely avoid writing the data. Otherwise, the data will be written after the handle is closed.</source>
          <target state="translated">파일이 임시 저장소로 사용되고 있습니다. 파일 시스템은 충분한 캐시 메모리를 사용할 수있는 경우 대용량 저장소에 데이터를 다시 쓰는 것을 방지합니다. 왜냐하면 종종 응용 프로그램은 핸들이 닫힌 직후에 임시 파일을 삭제하기 때문입니다. 이 경우 시스템은 데이터 쓰기를 완전히 피할 수 있습니다. 그렇지 않으면 핸들이 닫힌 후에 데이터가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">파일 핸들이 닫히거나 프로그램이 종료되면 파일이 제거됩니다. 파일 이름에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">파일은 초기화 코드의 성공적인 실행을 나타 내기 위해 마지막 명령문으로 true를 리턴해야하므로 이러한 파일을 &lt;code&gt;1;&lt;/code&gt; 로 종료하는 것이 일반적입니다 . 확실하지 않으면 그렇지 않으면 true를 반환합니다. 그러나 &lt;code&gt;1;&lt;/code&gt; 을 넣는 것이 좋습니다 . 문을 더 추가하는 경우</target>
        </trans-unit>
        <trans-unit id="db479c8e212dd28f37cf11de532fb13a4706ab4c" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt;, in case you add more statements.</source>
          <target state="translated">파일은 모든 초기화 코드의 성공적인 실행을 나타 내기 위해 마지막 문으로 true를 반환해야하므로 이러한 파일을 &lt;code&gt;1;&lt;/code&gt; 로 종료하는 것이 일반적입니다 . 그렇지 않으면 true를 반환 할 것이라고 확신하지 않는 한. 그러나 &lt;code&gt;1;&lt;/code&gt; 을 넣는 것이 더 낫습니다 . , 문을 더 추가하는 경우.</target>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">VERSION_FROM에 이름이 지정된 파일은 Makefile에 대한 종속성으로 추가되지 않습니다. 이것은 실제로 정확하지는 않지만 개발 과정에서 파일의 작은 변화에 대해 Makefile을 다시 작성해야하는 것은 큰 고통입니다. 파일을 변경 한 후 Makefile에 올바른 버전 매크로가 포함되도록하려면 다음과 같은 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1264aef66e240939ce372646b5dc5401497e1664" translate="yes" xml:space="preserve">
          <source>The file or directory has an associated reparse point.</source>
          <target state="translated">파일 또는 디렉터리에 관련된 재분석 지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af548b827b63fa83aaea96b3b1471e3f70a720b8" translate="yes" xml:space="preserve">
          <source>The file or directory has no other attributes set. This attribute is valid only if used alone.</source>
          <target state="translated">파일 또는 디렉토리에 다른 속성이 설정되어 있지 않습니다. 이 속성은 단독으로 사용되는 경우에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2a20833b40e53533fae911a70eb77893d34ddc0e" translate="yes" xml:space="preserve">
          <source>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</source>
          <target state="translated">파일 또는 디렉토리는 아카이브 파일 또는 디렉토리입니다. 애플리케이션은이 속성을 사용하여 백업 또는 제거 할 파일을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3a28a2595e27b62a75bd273e98ef20b3ef8db95b" translate="yes" xml:space="preserve">
          <source>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</source>
          <target state="translated">파일 또는 디렉토리가 압축됩니다. 파일의 경우 이는 파일의 모든 데이터가 압축됨을 의미합니다. 디렉토리의 경우 이는 새로 생성 된 파일 및 하위 디렉토리의 기본값이 압축임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d84e09e4ae07a74635af247678d4e0053654f7b" translate="yes" xml:space="preserve">
          <source>The file or directory is encrypted. For a file, this means that all data streams in the file are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</source>
          <target state="translated">파일 또는 디렉토리가 암호화됩니다. 파일의 경우 이는 파일의 모든 데이터 스트림이 암호화됨을 의미합니다. 디렉토리의 경우 이는 암호화가 새로 생성 된 파일 및 하위 디렉토리에 대한 기본값임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97235d485d43a9b6726df3990eccad2157355604" translate="yes" xml:space="preserve">
          <source>The file or directory is hidden. It is not included in an ordinary directory listing.</source>
          <target state="translated">파일 또는 디렉토리가 숨겨져 있습니다. 일반 디렉토리 목록에는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="511d8ef3c0880481e73ffbe5546aad0ca9af7623" translate="yes" xml:space="preserve">
          <source>The file or directory is part of, or is used exclusively by, the operating system.</source>
          <target state="translated">파일 또는 디렉토리는 운영 체제의 일부이거나 운영 체제에서 독점적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50a862ef7b392abfc56ec7987f674bfc97e4e196" translate="yes" xml:space="preserve">
          <source>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</source>
          <target state="translated">파일 또는 디렉토리가 읽기 전용입니다. 응용 프로그램은 파일을 읽을 수 있지만 파일에 쓰거나 삭제할 수는 없습니다. 디렉토리의 경우 애플리케이션이 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">파일 리디렉션 문자 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;및 &quot;|&quot; 큰 따옴표로 인용 할 수 있습니다 (항상 그렇지는 않다는 제안이 있지만). 작은 따옴표는 쉘 또는 C 런타임에서 따옴표로 처리되지 않으며 쉘에 의해 제거되지 않습니다 (이 유형의 인용을 완전히 쓸모 없게 만들기 위해). 캐럿 &quot;^&quot;도 인용 문자로 작동하는 것으로 관찰되었지만 이는 쉘 기능인 것으로 보이며 캐럿이 명령 행에서 제거되지 않았으므로 Perl은 여전히이를 인식합니다 (C 런타임 단계는 처리하지 않습니다) 따옴표 문자로 캐럿).</target>
        </trans-unit>
        <trans-unit id="50901ff92251eec862c454e35476bb796a0417dd" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the &lt;code&gt;binmode()&lt;/code&gt; function to change the mode of the filehandle.</source>
          <target state="translated">File :: Temp에서 반환 된 파일은 이러한 모드를 사용할 수있는 경우 이진 모드로 열릴 것입니다. 정확하지 않은 경우 &lt;code&gt;binmode()&lt;/code&gt; 함수를 사용하여 파일 핸들의 모드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">File :: Temp에 의해 반환 된 파일은 이러한 모드를 사용할 수있는 경우 이진 모드로 열립니다. 정확하지 않으면 C를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce9457f95e305ab599387997a39303f4f4596d9a" translate="yes" xml:space="preserve">
          <source>The file specifications of &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; will be converted to &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[-]&lt;/code&gt;.</source>
          <target state="translated">의 파일 사양입니다 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;..&lt;/code&gt; 는 &lt;code&gt;[]&lt;/code&gt; 및 &lt;code&gt;[-]&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f1bf193f0391c5390c8fed583c48df05d19c307" translate="yes" xml:space="preserve">
          <source>The file system preserves Unicode in file names [true for &quot;NTFS&quot;].</source>
          <target state="translated">파일 시스템은 파일 이름에 유니 코드를 유지합니다 [ &quot;NTFS&quot;의 경우 참].</target>
        </trans-unit>
        <trans-unit id="4cb5efb93d11a4fd3e9514acb9b3c301836d1d02" translate="yes" xml:space="preserve">
          <source>The file system preserves the case of file names [usually true]. That is, it doesn't change the case of file names such as forcing them to upper- or lower-case.</source>
          <target state="translated">파일 시스템은 파일 이름의 대소 문자를 유지합니다 [보통 true]. 즉, 대문자 또는 소문자로 강제하는 등 파일 이름의 대소 문자를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a04a32c75b0e4d58abe85e387d4b6865a5c9ef55" translate="yes" xml:space="preserve">
          <source>The file system supports compression on a per-file basis [true for &quot;NTFS&quot;].</source>
          <target state="translated">파일 시스템은 파일 단위로 압축을 지원합니다 [ &quot;NTFS&quot;의 경우 참].</target>
        </trans-unit>
        <trans-unit id="0d32a15b0b05b7bd2cbe516ad58a7e5b3062c6e8" translate="yes" xml:space="preserve">
          <source>The file system supports setting Access Control Lists on files [true for &quot;NTFS&quot;].</source>
          <target state="translated">파일 시스템은 파일에 대한 액세스 제어 목록 설정을 지원합니다 [ &quot;NTFS&quot;의 경우 true].</target>
        </trans-unit>
        <trans-unit id="78fe12a81a2024d0eb3a6b039559611ea6c933d5" translate="yes" xml:space="preserve">
          <source>The file system supports the ability to not ignore the case of file names [but might ignore case the way you are using it]. That is, the file system has the ability to force you to get the letter case of a file's name exactly right to be able to open it. This is true for &quot;NTFS&quot; file systems, even though case in file names is usually still ignored.</source>
          <target state="translated">파일 시스템은 파일 이름의 대소 문자를 무시하지 않는 기능을 지원합니다 [그러나 사용하는 방식에 따라 대소 문자를 무시할 수 있습니다]. 즉, 파일 시스템은 파일 이름의 대소 문자를 정확하게 열 수 있도록 강제하는 기능이 있습니다. &quot;NTFS&quot;파일 시스템의 경우 파일 이름의 대소 문자가 일반적으로 여전히 무시되지만 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3318e11fa92791fcdb7d551f55db23d41576d211" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">파일 유형 또는 확장자는 길이가 0 인 경우에도 항상 VMS 형식 파일 사양에 있습니다. 즉, 기본적으로 &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt; 은 확장자가없는 파일에 후행 점을 반환하므로 Unix에서 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 가 표시되는 곳에 &quot;a&quot; 가 표시 &lt;code&gt;&quot;a.&quot;&lt;/code&gt; VMS에서. 그러나 환경에서 &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 기능 을 활성화하면 후행 점이 표시되지 않을 수 있습니다 (기능 논리 이름에 대한 CRTL 문서 참조).</target>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">파일 형식 또는 확장명은 길이가 0 인 경우에도 항상 VMS 형식 파일 사양에 있습니다. 이것은 기본적으로 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 이 확장자없이 파일에 후행 점을 반환하므로 Unix에서 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 가 표시되면 &quot;a&quot; 가 표시 &lt;code&gt;&quot;a.&quot;&lt;/code&gt; VMS에서. 그러나 환경에서 &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 기능을 사용 하면 후행 점이 표시되지 않을 수 있습니다 (기능 논리 이름에 대한 CRTL 문서 참조).</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">파일 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="913f7be6fa85f1e72e30e862d223c440b0b1e681" translate="yes" xml:space="preserve">
          <source>The file will not be indexed by the content indexing service.</source>
          <target state="translated">콘텐츠 인덱싱 서비스에서 파일을 인덱싱하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">파일 핸들은 일반적으로 부모에 대해 동작하지만 해당 파일 핸들에 대한 I / O는 자식 프로세스의 STDOUT / STDIN으로 파이프됩니다. 자식 프로세스에서는 파일 핸들이 열리지 않습니다. I / O는 새로운 STDOUT / STDIN에서 시작됩니다. 일반적으로 이는 setuid를 실행할 때와 같이 파이프 명령이 실행되는 방식을보다 세밀하게 제어하고 메타 문자에 대한 셸 명령을 스캔 할 필요가없는 경우 일반 파이프 열기와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92ee26a1481d9c364e91c69e1999f81d1550b5da" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">참조 횟수가 0에 도달하면 파일 핸들이 닫힙니다. &lt;a href=&quot;#my-VARLIST&quot;&gt; &lt;code&gt;my&lt;/code&gt; 로&lt;/a&gt; 선언 된 어휘 범위 변수 인 경우 일반적으로 둘러싸는 범위의 끝을 의미합니다. 그러나이 자동 닫기는 오류를 확인하지 않으므로 특히 작성에 사용되는 파일 핸들을 명시 적으로 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">참조 횟수가 0에 도달하면 파일 핸들이 닫힙니다. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 범위 변수 인 경우 일반적으로 둘러싸는 범위의 끝을 의미합니다. 그러나이 자동 닫기는 오류를 확인하지 않으므로 파일 핸들, 특히 쓰기에 사용되는 파일 핸들을 명시 적으로 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">참조 횟수가 0에 도달하면 파일 핸들이 닫힙니다. &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 로 선언 된 어휘 범위 변수 인 경우 일반적으로 둘러싸는 범위의 끝을 의미합니다. 그러나이 자동 닫기는 오류를 확인하지 않으므로 파일 핸들, 특히 쓰기에 사용되는 파일 핸들을 명시 적으로 닫는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">파일 핸들 STDIN, STDOUT 및 STDERR이 사전 정의되어 있습니다. (파일 핸들은 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 또한 지역 식별자가 아닌 글로벌로 해석 될 것이다 패키지를 제외하고 작동합니다.합니다) 추가 파일 핸들은 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 다른 사람의 사이에, 기능. 참조 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 과 &lt;a href=&quot;functions/open&quot;&gt;열&lt;/a&gt; 이에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="dabead5f141fbdd7cbaf6b6ee9ed1c9d5ac4b10f" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;open()&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details on this.</source>
          <target state="translated">STDIN, STDOUT 및 STDERR 파일 핸들이 미리 정의되어 있습니다. (파일 핸들 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 은 패키지를 제외하고는 작동합니다. 패키지는 전역이 아닌 로컬 식별자로 해석됩니다.) 다른 파일 들 중에서도 &lt;code&gt;open()&lt;/code&gt; 함수를 사용하여 추가 파일 핸들을 생성 할 수 있습니다 . 이에 대한 자세한 내용은 &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; 및 &lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc의 &quot;open&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">파일 핸들은 정수일 수도 있으며,이 경우 파일 디스크립터로 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">App :: Prove :: State가 읽는 데이터가 들어있는 데이터 저장소의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">이 확장과 함께 사용될 perllibrary의 파일 이름. 기본값은 libperl.a입니다.</target>
        </trans-unit>
        <trans-unit id="76201dda41fb8f7d14160ae0f46e9ddf9f7d7f60" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">1 인수 및 2 인수 형식의 &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; 에&lt;/a&gt; 전달 된 파일 이름 에는 선행 및 후행 공백이 삭제되고 일반 리디렉션 문자가 적용됩니다. &quot;매직 오픈&quot;이라고하는이 속성은 종종 좋은 효과를내는 데 사용될 수 있습니다. 사용자는 다음과 같은 파일 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">open ()의 한 인수 및 두 인수 형식으로 전달 된 파일 이름에는 선행 및 후행 공백이 삭제되고 일반 리디렉션 문자가 적용됩니다. &quot;매직 오픈&quot;이라고하는이 속성은 종종 좋은 효과를 내기 위해 사용될 수 있습니다. 사용자는 파일 이름을</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">파일들</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">&quot;qnx&quot;디렉토리의 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">파일 시스템은 액세스 타임 스탬프 나 변경 타임 스탬프 (휴대용 타임 스탬프가 수정 타임 스탬프임을 의미) 또는 타임 스탬프의 1 초 단위 (예 : FAT 파일 시스템은 시간 단위를 2 초로 제한 함)를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9640e3801c8da6fb8d4c4212946957e9fbfe8dbf" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;a href=&quot;perlfunc#link-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;link&lt;/code&gt;&lt;/a&gt;) nor symbolic links (&lt;a href=&quot;perlfunc#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#readlink-EXPR&quot;&gt;&lt;code&gt;readlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">파일 시스템은 하드 링크 ( &lt;a href=&quot;perlfunc#link-OLDFILE%2CNEWFILE&quot;&gt; &lt;code&gt;link&lt;/code&gt; &lt;/a&gt; ) 나 심볼릭 링크 ( &lt;a href=&quot;perlfunc#symlink-OLDFILE%2CNEWFILE&quot;&gt; &lt;code&gt;symlink&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#readlink-EXPR&quot;&gt; &lt;code&gt;readlink&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;perlfunc#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt; )를 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">파일 시스템은 하드 링크 ( &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ) 또는 기호 링크 ( &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; )를 지원하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Symbian 장치의 파일 시스템은 DOSish 구문, 콜론으로 경로와 구분 된 &quot;드라이브&quot;및 경로에 대한 백 슬래시를 사용합니다. 드라이브의 정확한 할당은 플랫폼마다 다를 수 있지만, 예를 들어 Series 60에서 C :는 (플래시) 기본 메모리로, D :는 RAM 드라이브로, E :는 메모리 카드 (MMC), Z :는 ROM. Series 80 D :는 메모리 카드입니다. 장치가 NUL :까지는 비트 버킷, COMx :는 직렬 회선, IRCOMx :는 IR 포트, TMP :는 C : \ System \ Temp 일 수 있습니다. 큰 따옴표로 묶인 백 슬래시를 두 배로 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">파일 테스트 연산자 &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 단순한 통계 버퍼보다 ​​더 많은 정보가 필요하므로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f0292fee7197d3e8ac530c889c496fd989569af" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">파일 테스트 연산자 &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 단순히 통계 버퍼보다 ​​더 많은 정보를 필요로하기 때문에 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">필터는 Perl 이 &lt;code&gt;DEBUG&lt;/code&gt; 환경 변수가 존재하는 경우에만 &amp;lt;DEBUG_BEGIN&amp;gt;과 &lt;code&gt;DEBUG_END&lt;/code&gt; 마커 사이의 코드를 구문 분석하도록 합니다. 즉 , &lt;code&gt;DEBUG&lt;/code&gt; 가 존재하면 위의 코드는 변경없이 필터를 통과해야합니다. Perl 파서는 그것들을 주석 라인으로 볼 것이기 때문에 마커 라인은있는 그대로 통과 될 수도 있습니다. 하면 &lt;code&gt;DEBUG&lt;/code&gt; 가 설정되어 있지 않은, 우리는 디버그 코드를 해제하는 방법이 필요합니다. 이를 달성하는 간단한 방법은 두 마커 사이의 선을 주석으로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">포함 된 필터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">필터가 적용됩니다</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">필터는 키에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">필터가 값에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">최종 &lt;code&gt;PUTBACK&lt;/code&gt; 은 함수를 종료하기 전에 Perl 스택을 일관된 상태로 두는 데 사용됩니다. &lt;code&gt;POPi&lt;/code&gt; 를 사용하여 스택의 반환 값을 팝했을 때 스택 포인터의 로컬 복사본 만 업데이트 했기 때문에이 작업이 필요 합니다. 기억 &lt;code&gt;PUTBACK&lt;/code&gt; 는 우리의 로컬 복사본와 동일하게 글로벌 스택 포인터를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">마지막 문자는 하이픈, 콜론 또는 마침표 일 수 없습니다. 이러한 문자로 끝나는 URL은 XHTML에서 허용하지만 일반 텍스트에서 추출하기 어색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">정규 괄호로 묶인 문자 클래스와 이것의 최종 차이점은 다중 문자 접기와 일치시킬 수 없다는 것입니다. 그러므로,</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">목록 할당의 마지막 요소는 배열 또는 해시 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee7b4f4630bbb2daf491aa012bc945e164b3e70" translate="yes" xml:space="preserve">
          <source>The final example shows that the characters &lt;code&gt;&quot;{&quot;&lt;/code&gt; and &lt;code&gt;&quot;}&quot;&lt;/code&gt; are metacharacters.</source>
          <target state="translated">마지막 예는 문자 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;}&quot;&lt;/code&gt; 가 메타 문자 임을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">마지막 줄 (인덱스 [242] 사용)은 유효한 유니 코드 최대 코드 포인트를 초과하는 모든 코드 포인트의 값에 &quot;No_Block&quot;값이 있음을 의미합니다. 이는 유니 코드가 존재하지 않는 블록에 사용하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">마지막 작업은 백 슬래시 문자를 사용하여 열린 대괄호 &lt;code&gt;[&lt;/code&gt; , 별표, 백 슬래시 또는 물음표 의 특수한 의미를 무효화합니다 . 순서대로 두 개의 백 슬래시는 특별한 의미가없는 문자로 백 슬래시를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">블록의 마지막 세미콜론은 목록의 마지막 쉼표와 마찬가지로 선택 사항입니다. 좋은 스타일 ( &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 참조 )은 한 줄짜리를 제외하고는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">마지막 세미콜론 (있는 경우)은 EXPR 값에서 또는 BLOCK 내에서 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701bfb8c787a64e7b1b253a3f8fa1a79c79b9b4d" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR.</source>
          <target state="translated">마지막 세미콜론 (있는 경우)은 EXPR 값에서 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f49a63a6bf839dcb9a9ccbe0a34339c52904e4c" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from within the BLOCK.</source>
          <target state="translated">마지막 세미콜론 (있는 경우)은 BLOCK 내에서 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">마지막 단계는 &lt;code&gt;test_test&lt;/code&gt; 를 호출 하여 &lt;a href=&quot;../builder&quot;&gt;Test :: Builder가&lt;/a&gt; 실제로 출력 한 것과 미리 선언 한 것을 비교 하고 결과를 &quot;ok&quot;또는 &quot;not ok&quot;(디버깅 사용)로 정상 출력에 다시보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a77ba1afa8fadab31ac1c8125c1a4cf3b74fcb5e" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">마지막 단계는 미리 선언 한 내용과 &lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder가&lt;/a&gt; 실제로 출력 한 내용을 단순히 비교하는 &lt;code&gt;test_test&lt;/code&gt; 를 호출 하고 결과를 &quot;ok&quot;또는 &quot;not ok&quot;(디버깅 포함)와 함께 일반 출력에 다시보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">마지막 단계는 &lt;code&gt;*.tar.gz&lt;/code&gt; 파일 glob 과 일치하는 각 파일 이름을 파생 된 Perl 정규식을 통해 차례로 전달하고이를 사용하여 출력 fileglob를 확장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">여기서 논의 할 마지막 두 수정자인 &lt;code&gt;//g&lt;/code&gt; 및 &lt;code&gt;//c&lt;/code&gt; 는 여러 개의 일치 항목과 관련됩니다. 수정 자 &lt;code&gt;//g&lt;/code&gt; 는 전역 일치를 나타내며 일치 연산자가 문자열 내에서 가능한 한 많이 일치하도록합니다. 스칼라 문맥에서 문자열에 대한 연속 호출 은 일치 하는 문자열 에서 &lt;code&gt;//g&lt;/code&gt; 점프하여 문자열의 위치를 ​​추적합니다. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="789fdded843f5a388c6234d5037a293bfbacec0d" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;/c&lt;/code&gt;, concern multiple matches. The modifier &lt;code&gt;/g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function.</source>
          <target state="translated">여기서 논의 할 마지막 두 가지 수정자인 &lt;code&gt;/g&lt;/code&gt; 및 &lt;code&gt;/c&lt;/code&gt; 는 다중 일치에 관한 것입니다. 수정 자 &lt;code&gt;/g&lt;/code&gt; 는 전역 일치를 나타내며 일치 연산자가 문자열 내에서 가능한 한 여러 번 일치 할 수 있도록합니다. 스칼라 컨텍스트에서 문자열에 대한 연속 호출 은 일치하는 항목에서 일치하는 항목으로 &lt;code&gt;/g&lt;/code&gt; 이동하여 문자열이 진행되는 동안 문자열의 위치를 ​​추적합니다. &lt;code&gt;pos()&lt;/code&gt; 함수로 위치를 얻거나 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68bb0429a21250927b8f2328dd69f3ab3c62b7fa" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange%28%29&quot;&gt;&quot;charinrange()&quot;&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">이 함수에 의해 반환 된 네 가지 요소 목록 의 마지막 네 번째 요소 ( &quot;block&quot;예제에서 &lt;code&gt;$default&lt;/code&gt; 에 할당 된 인덱스 [3] )는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 형식 유형 과 함께 사용됩니다 . 반환 된 반전 맵 데이터 구조를 해시와 같은 다른 구조로 변환하려는 응용 프로그램에도 유용 할 수 있습니다. 대부분의 코드 포인트가 속성 아래에 매핑되는 매핑을 제공합니다. 데이터 구조에 명시 적으로 나열되지 않은 코드 포인트가이 값에 매핑되는 규칙을 설정하면 잠재적으로 데이터 구조를 훨씬 더 작게 만들 수 있습니다. 이 함수에서 반환 된 데이터 구조를 구성 할 때이 값에 매핑되는 범위를 무시하면됩니다. 예를 들어 &lt;a href=&quot;#charinrange%28%29&quot;&gt;&quot;charinrange ()&quot;로&lt;/a&gt; 검색 할 수있는 데이터 구조로 변환하려면, 조정이 필요하지 않은 속성에 대해 다음 레시피를 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">이 함수에 의해 반환 된 네 개의 요소 목록에서 마지막 네 번째 요소 ( &quot;block&quot;예제에서 &lt;code&gt;$default&lt;/code&gt; 에 할당 된 인덱스 [3] )는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 형식 유형 과 함께 사용됩니다 . 반환 된 반전 맵 데이터 구조를 해시와 같은 다른 것으로 변환하려는 응용 프로그램에도 유용 할 수 있습니다. 대부분의 코드 포인트가 속성 아래에 매핑되는 매핑을 제공합니다. 데이터 구조에 명시 적으로 나열되지 않은 코드 포인트가이 값에 매핑되는 규칙을 설정하면 데이터 구조를 훨씬 더 작게 만들 수 있습니다. 이 함수에서 반환 된 데이터 구조에서 데이터 구조를 구성 할 때이 값에 매핑되는 범위를 무시하십시오. 예를 들어 &lt;a href=&quot;#charinrange()&quot;&gt;charinrange ()로&lt;/a&gt; 검색 가능한 데이터 구조로 변환하려면조정이 필요없는 속성의 경우이 레시피를 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">find_dup () 메소드</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">유니 코드의 첫 번째 (현재는 실패한) 목표는 모든 문자 레퍼토리를 고정 길이 정수로 매핑하여 프로그래머가 만족할 수 있도록하는 것이 었습니다. 각 문자는</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">&lt;b&gt;네임 스페이스&lt;/b&gt; 를 업로드 한 첫 번째 &lt;b&gt;PAUSE&lt;/b&gt; 작성자는 자동으로 해당 네임 스페이스 의 &lt;b&gt;기본 관리자&lt;/b&gt; 가됩니다 . &quot;선착순&quot;권한 은 해당 역할이 지정된 &lt;b&gt;기본 관리자&lt;/b&gt; 와 자동으로받은 &lt;b&gt;관리자&lt;/b&gt; 를 구별합니다 .&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">이 함수의 첫 번째 Perl 인수는 문자로 취급되고 변수 a에 지정되며 해당 주소는 함수 foo로 전달됩니다. 두 번째 Perl 인수는 문자열 포인터로 취급되어 변수 b에 지정됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="c3453154bc2cd37e63c9b0f3f784faca750ac354" translate="yes" xml:space="preserve">
          <source>The first alternative includes everything from the last pattern delimiter (&lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;(?:&quot;&lt;/code&gt; (described later),</source>
          <target state="translated">첫 번째 대안은 마지막 패턴 구분 기호 ( &lt;code&gt;&quot;(&quot;&lt;/code&gt; , &lt;code&gt;&quot;(?:&quot;&lt;/code&gt; (나중에 설명),</target>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">첫 번째와 두 번째 인수는 문자열, typeglob, typeglob 참조 또는 IO :: Handle;에서 상속되는 객체 일 수 있습니다. 그들은 모든 경우에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">첫 번째와 두 번째 양식은 작성중인 클래스의 이름을 명시 적으로 식별합니다. 세 번째 형식은 현재 패키지 이름을 클래스 이름으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;pointer&lt;/code&gt; 는 새로 할당 된 메모리를 가리키는 변수의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="80c48ff540490ea5dad5fc5e056d6677cb16264e" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">&lt;code&gt;setlocale()&lt;/code&gt; 의 첫 번째 인수 는 &lt;b&gt;범주를&lt;/b&gt; 제공하고 두 번째 인수 는 &lt;b&gt;로케일을 제공&lt;/b&gt; 합니다. 카테고리는 로케일 별 규칙을 적용하려는 데이터 처리 측면을 알려줍니다. 카테고리 이름은 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;&lt;/a&gt; 및 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;에서 설명&lt;/a&gt; 합니다. 로케일은 언어, 국가 또는 지역 및 코드 세트의 특정 조합에 해당하는 사용자 정의 정보 모음의 이름입니다. 로케일 이름 지정에 대한 힌트를 읽으십시오. 예에서와 같이 모든 시스템이 로케일을 명명하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">&lt;code&gt;setlocale()&lt;/code&gt; 의 첫 번째 인수 는 &lt;b&gt;category를&lt;/b&gt; 제공하고 두 번째 인수 는 &lt;b&gt;locale을 제공&lt;/b&gt; 합니다. 이 범주는 로케일 별 규칙을 적용하려는 데이터 처리 측면을 알려줍니다. 카테고리 이름은 &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; 및 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 에서 설명 합니다. 로케일은 언어, 국가 또는 지역 및 코드 세트의 특정 조합에 해당하는 사용자 정의 정보 콜렉션의 이름입니다. 로케일 이름 지정에 대한 힌트를 읽으십시오 (예에서와 같이 모든 시스템의 이름이 로케일 인 것은 아님).</target>
        </trans-unit>
        <trans-unit id="fede859d91b131301182a8f517e78fcd79928ade" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 의 첫 번째 인수 는 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 함수에 대한 코드 참조 이거나 각 파일에 대해 수행 할 작업을 설명하는 해시 참조입니다. 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;원하는 함수&quot;에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 의 첫 번째 인수 는 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 함수에 대한 코드 참조 이거나 각 파일에 대해 수행 할 작업을 설명하는 해시 참조입니다. 코드 참조는 아래 &lt;a href=&quot;#The-wanted-function&quot;&gt;의 원하는 기능에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c957468bac2255084a035a3220d83572a45006f" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;open&lt;/code&gt;, labeled FILEHANDLE in this reference, is usually a scalar variable. (Exceptions exist, described in &quot;Other considerations&quot;, below.) If the call to &lt;code&gt;open&lt;/code&gt; succeeds, then the expression provided as FILEHANDLE will get assigned an open</source>
          <target state="translated">이 참조에서 FILEHANDLE로 레이블이 지정된 &lt;code&gt;open&lt;/code&gt; 의 첫 번째 인수 는 일반적으로 스칼라 변수입니다. (아래의 &quot;기타 고려 사항&quot;에 설명 된 예외가 있습니다.) &lt;code&gt;open&lt;/code&gt; 호출이 성공하면 FILEHANDLE로 제공된 표현식에 열기가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">첫 번째 호출은 값이없는 필사자 SV를 작성하고 두 번째 호출은 기존 SV를 필사자 SV로 변환하여 ( &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 에 대한 호출을 연기 함 ) 세 번째 호출 은 기존 SV의 필사본 사본을 작성합니다. &lt;code&gt;sv_newmortal&lt;/code&gt; 은 새로운 SV에 값을주지 않기 때문에 일반적으로 &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; 등을 통해 값을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">첫 번째 호출은 결과, 즉 37을 스칼라 캐시에 캐시합니다. 두 번째는 목록 캐시에서 목록 &lt;code&gt;(37)&lt;/code&gt; 을 캐시합니다. 세 번째 호출은 실제 &lt;code&gt;complicated&lt;/code&gt; 함수를 호출하지 않습니다 . 스칼라 캐시에서 값 37을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">등록 된 첫 번째 콜백은 대기를위한 콜백입니다. 콜백은 입력 파일 핸들을 기다리는 무언가가있을 때까지 현재 이벤트 루프를 호출 할 것으로 예상됩니다. 전달 된 매개 변수는 두 번째 콜백의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="356bc7c1108ec743988bf0e03b81bb507c0cc12b" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="translated">foldcased 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 맨 위에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">접힌 버전의 첫 번째 코드 포인트가 반환됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="f94f6bc950fffc56630abef7e060753be71264b0" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="translated">소문자 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 맨 위에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="e520b61d264ebe77754743fca0b946c106ddd342" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more). It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="translated">소문자 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 맨 위에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 ). 제약 조건 &lt;code&gt;s &amp;lt; e&lt;/code&gt; 가 참인 경우 &lt;code&gt;e - 1&lt;/code&gt; 이상을 읽으려고 시도하지 않습니다 (이는 &lt;code&gt;-DDEBUGGING&lt;/code&gt; 빌드 에서 확인 됨 ). 입력 문자의 UTF-8 형식이 어떤 식 으로든 잘못된 경우 프로그램이 비뚤어 지거나 함수가 구현 재량에 따라 REPLACEMENT CHARACTER를 반환 할 수 있으며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">소문자 버전의 첫 번째 코드 포인트가 리턴됩니다 (단, 위에서 설명한대로 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="d7f11b85b3fd5fa2f0a6c5645eeff96adc2054e0" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="translated">타이틀 케이스 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 상단에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">제목이 지정된 버전의 첫 번째 코드 포인트가 반환됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="3acdfbd051e586c1763fcef89bd42028b50c7068" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="translated">대문자 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 맨 위에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="aa79c84ba894862a3bdfa5a898231ba1c669dc5c" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more.)</source>
          <target state="translated">대문자 버전의 첫 번째 코드 포인트가 반환됩니다 (그러나이 &lt;a href=&quot;#Character-case-changing&quot;&gt;섹션의 맨 위에&lt;/a&gt; 설명 된대로 더있을 수 있음에 유의하십시오 .)</target>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">대문자 버전의 첫 번째 코드 포인트가 리턴됩니다 (단, 위에서 설명한 것처럼 더있을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">첫 번째 열은 문자의 유니 코드 코드 포인트 (16 진 형식)를 제공하고 두 번째 열은 (유니 코드) 이름을 제공합니다. 세 번째 열은 문자와 일치하는 클래스를 나타냅니다 ( &lt;code&gt;\s&lt;/code&gt; 일치 를 변경하는 로케일이 없다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">표의 첫 번째 열은 속성의 이름입니다. 두 번째 열은 대체 이름 (있는 경우)과 주석 일 수 있습니다. 대체 이름은 첫 번째 열을 단순히 반복하지 않는 한 속성의 전체 이름입니다.이 경우 두 번째 열은 속성의 짧은 이름 (다른 경우)을 나타냅니다. 주석은 전체 이름의 항목에만 제공됩니다. 속성이 더 이상 사용되지 않는 경우 항목은 &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;위 섹션&lt;/a&gt; 의 표에서 사용 된 것과 같은 문자 ( 예 : &lt;b&gt;D&lt;/b&gt; 또는 &lt;b&gt;S)&lt;/b&gt; 로 플래그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a9e1d7bc901ecffb197db410cd69bf5871b1113" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. The annotations for binary properties include a list of the first few ranges that the property matches. To avoid any ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="translated">테이블의 첫 번째 열은 속성의 이름입니다. 두 번째 열은 대체 이름 (있는 경우)과 일부 주석입니다. 대체 이름은 단순히 첫 번째 열을 반복하지 않는 한 속성의 전체 이름입니다.이 경우 두 번째 열은 속성의 짧은 이름 (다른 경우)을 나타냅니다. 주석은 전체 이름 항목에만 제공됩니다. 이진 속성에 대한 주석에는 속성이 일치하는 처음 몇 개의 범위 목록이 포함됩니다. 모호함을 피하기 위해 SPACE 문자는 &lt;code&gt;\x20&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1eff62aa7ff2adaee41faf8fb6df470068a01954" translate="yes" xml:space="preserve">
          <source>The first column is a set of flags, the second column the return type, the third column the name. Columns after that are the arguments. The flags are documented at the top of</source>
          <target state="translated">첫 번째 열은 플래그 집합, 두 번째 열은 반환 유형, 세 번째 열은 이름입니다. 그 이후의 열은 인수입니다. 플래그는 맨 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">첫 번째 명령은 표준 출력과 표준 오류를 모두 임시 파일로 보냅니다. 두 번째 명령은 이전 표준 출력 만 전송하고 이전 표준 오류는 이전 표준 출력에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">@os_flavor의 첫 번째 요소는 주요 패밀리 (예 : Unix, Windows, VMS, OS / 2 등)이고 나머지는 하위 패밀리입니다.</target>
        </trans-unit>
        <trans-unit id="bf7e5d87f2410537daa86408c9c3f1321c88ab2f" translate="yes" xml:space="preserve">
          <source>The first entry in the string will run all tests in the top-level</source>
          <target state="translated">문자열의 첫 번째 항목은 최상위 수준의 모든 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">첫 번째 예제는 CPAN :: Module 클래스의 오브젝트에 의해 구동되고 두 번째 예제는 CPAN :: Distribution 클래스의 오브젝트에 의해 구동됩니다.</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">첫 번째 확장명은 포함 된 주석 &lt;code&gt;(?#text)&lt;/code&gt; 입니다. 이것은 의미에 영향을주지 않으면 서 주석을 정규 표현식에 포함시킵니다. 주석은 텍스트에 닫는 괄호가 없어야합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">첫 번째 추가 명령어는 DJGPP의 FNCASE 환경 변수를 설정하여 XS 유형 모듈에 대해 빌드해야하는 새 perl 바이너리가 올바르게 빌드되도록합니다. 두 번째 추가 명령어는 &quot;make test&quot;를 실행하기 전에 모듈 디렉토리에 perl 바이너리를 다시 빌드하므로 &quot;make&quot;로 빌드 한 새 모듈 코드로 테스트합니다. 세 번째 추가 명령어는 모듈 디렉토리에서 perl 바이너리를 표준 DJGPP 바이너리 디렉토리 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 에 설치하여 이전 perl 바이너리를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="238d815e97aa4aefd914191a6984e7eea1bebbe7" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt;, replacing your previous perl binary.</source>
          <target state="translated">첫 번째 추가 명령은 DJGPP의 FNCASE 환경 변수를 설정하여 XS 유형 모듈 용으로 빌드해야하는 새 펄 바이너리가 올바르게 빌드되도록합니다. 두 번째 추가 명령은 &quot;make test&quot;를 실행하기 전에 모듈 디렉토리에서 perl 바이너리를 다시 빌드하므로 &quot;make&quot;로 빌드 한 새 모듈 코드로 테스트 할 수 있습니다. 세 번째 추가 명령은 모듈 디렉토리의 perl 바이너리를 표준 DJGPP 바이너리 디렉토리 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 으로 설치하여 이전 perl 바이너리를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="9ae143bbfd14644c2528b32b8737fee2a5bff385" translate="yes" xml:space="preserve">
          <source>The first few lines tell you the modules that Net::FTP uses and their versions, this is useful data to me when a user reports a bug. The last seven lines show the communication with the server. Each line has three parts. The first part is the object itself, this is useful for separating the output if you are using multiple objects. The second part is either &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; to show data coming from the server or &lt;code&gt;&amp;amp;gt&amp;amp;gt&amp;amp;gt&amp;amp;gt&lt;/code&gt; to show data going to the server. The remainder of the line is the command being sent or response being received.</source>
          <target state="translated">처음 몇 줄은 Net :: FTP가 사용하는 모듈과 그 버전을 알려줍니다. 이것은 사용자가 버그를보고 할 때 유용한 데이터입니다. 마지막 7 줄은 서버와의 통신을 보여줍니다. 각 라인은 세 부분으로 구성됩니다. 첫 번째 부분은 객체 자체이며 여러 객체를 사용하는 경우 출력을 분리하는 데 유용합니다. 두 번째 부분은 서버에서 오는 데이터를 표시 하는 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 또는 서버로 이동하는 데이터를 표시하는 &lt;code&gt;&amp;amp;gt&amp;amp;gt&amp;amp;gt&amp;amp;gt&lt;/code&gt; 입니다. 라인의 나머지 부분은 전송중인 명령 또는 수신중인 응답입니다.</target>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">구조체의 처음 몇 멤버는 레이어의 호환성 검사 &quot;name&quot;, 인스턴스 별 데이터의 &lt;code&gt;malloc&lt;/code&gt; 크기 및 클래스의 속성 인 일부 플래그 (예 : 여부 등)에 대한 함수 테이블 크기를 제공합니다. 버퍼링 레이어), 다음 네 가지 기본 그룹에 속하는 기능을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">이들 중 처음 5 개는 이스케이프 시퀀스 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\F&lt;/code&gt; . 타이틀 케이스의 경우, 참조 &lt;a href=&quot;#Titlecase&quot;&gt;타이틀 케이스를&lt;/a&gt; ; Foldcase을 참조 &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="679923e26685f0bf8bfaf94ea7988b4c7276fdb8" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\F&lt;/code&gt;. For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;&quot;Foldcase&quot;&lt;/a&gt;.</source>
          <target state="translated">이들 중 처음 5 개는 이스케이프 시퀀스 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\F&lt;/code&gt; . Titlecase의 경우 &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;를&lt;/a&gt; 참조하십시오 . Foldcase의 경우 &lt;a href=&quot;#Foldcase&quot;&gt;&quot;Foldcase&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">첫 번째 형태는 가장 중요합니다</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">첫 번째 양식은</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">첫 번째 양식은 CPAN에 분배 된 CHECKSUMS 파일에 저장된 저자의 CPAN 디렉토리 내부 및 아래에 모든 분배 파일을 나열합니다. 리스팅이 서브 디렉토리로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">첫 번째 함수는 &lt;code&gt;strlen&lt;/code&gt; 을 사용하여 추가 할 문자열의 길이를 계산합니다 . 두 번째에서는 문자열 길이를 직접 지정합니다. 세 번째 함수는 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 와 같은 인수를 처리하고 형식화 된 출력을 추가합니다. 네 번째 함수는 &lt;code&gt;vsprintf&lt;/code&gt; 처럼 작동합니다 . va_list 인수 대신 SV 배열의 주소와 길이를 지정할 수 있습니다. 다섯 번째 기능은 첫 번째 SV에 저장된 문자열을 두 번째 SV에 저장된 문자열로 확장합니다. 또한 두 번째 SV가 문자열로 해석되도록합니다.</target>
        </trans-unit>
        <trans-unit id="090b5d34cd572296fdf844e61d55479b085e6558" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt;. In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;sprintf&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt;. You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">첫 번째 함수는 &lt;code&gt;strlen&lt;/code&gt; 을 사용하여 추가 할 문자열의 길이를 계산합니다 . 두 번째에서는 문자열 길이를 직접 지정합니다. 세 번째 함수는 &lt;code&gt;sprintf&lt;/code&gt; 와 같은 인수를 처리하고 형식화 된 출력을 추가합니다. 네 번째 함수는 &lt;code&gt;vsprintf&lt;/code&gt; 처럼 작동합니다 . va_list 인수 대신 SV 배열의 주소와 길이를 지정할 수 있습니다. 다섯 번째 함수는 첫 번째 SV에 저장된 문자열을 두 번째 SV에 저장된 문자열로 확장합니다. 또한 두 번째 SV가 문자열로 해석되도록합니다.</target>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">첫 번째 함수는 리터럴 문자열을 사용하고 두 번째 함수는 SV에 저장된 문자열을 사용합니다. 숨김은 해시 테이블이므로 &lt;code&gt;HV*&lt;/code&gt; 다시 얻습니다 . &lt;code&gt;flags&lt;/code&gt; 가 GV_ADD로 설정되어있는 경우 플래그는 새 패키지를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="753de98607835382ac405aaaec94b8f9df443117" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt;. The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">첫 번째 함수는 리터럴 문자열을 사용하고 두 번째 함수는 SV에 저장된 문자열을 사용합니다. 숨김은 해시 테이블 일 뿐이므로 &lt;code&gt;HV*&lt;/code&gt; 반환합니다 . &lt;code&gt;flags&lt;/code&gt; 가 GV_ADD로 설정되어있는 경우 플래그는 새 패키지를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">첫 번째는 버킷 체인 길이에 대한 데이터를 제공하고 페치 * miss *가 얼마나 많은 작업을 수행하는지에 대한 통찰력을 제공합니다. 이 경우 항목이 목록에 없는지 확인하기 전에 버킷의 모든 항목을 검사해야합니다. 항목이 해시에없는 삭제와 마찬가지로 삽입 성능도이 경우와 같습니다.</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">첫 번째 인터페이스는 객체 접근입니다. &lt;code&gt;IO::Dir&lt;/code&gt; 은 펄의 내장 디렉토리 읽기 루틴을 감싸는 래퍼 인 객체 생성자와 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">첫 번째는 0 개 이상의 문자 시퀀스와 일치 하는 별표 &lt;code&gt;*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">첫 번째는 '*'메타 문자입니다. 이것은 입력 파일 글로브와 일치하는 완전한 파일 이름으로 대체됩니다. 그래서</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">첫 번째는 '기본'형식이며 기본 및 실행 모드에서 모든 opcode를 인쇄하는 데 사용됩니다. 두 번째 goto-format은 분기가 발생할 때 실행 모드에서 사용됩니다. 실제 opcode가 아니며 닫는 중괄호처럼 보이도록 삽입됩니다. 트리 형식은 트리마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="32f6bb26a2f4ae1e809986ad78dbd60042fd1a3c" translate="yes" xml:space="preserve">
          <source>The first item is not fixable (except by upgrading to a later Visual Studio release), but it would be possible to work around the latter two items by using the Windows API functions &lt;code&gt;GetNumberFormat&lt;/code&gt; and &lt;code&gt;GetCurrencyFormat&lt;/code&gt;; patches welcome.</source>
          <target state="translated">첫 번째 항목은 수정할 수 없지만 (나중의 Visual Studio 릴리스로 업그레이드하는 경우 제외) Windows API 함수 &lt;code&gt;GetNumberFormat&lt;/code&gt; 및 &lt;code&gt;GetCurrencyFormat&lt;/code&gt; 을 사용하여 나머지 두 항목을 해결할 수 있습니다 . 패치를 환영합니다.</target>
        </trans-unit>
        <trans-unit id="34237558f2321ff711f52a04588fb6ee8079ad92" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="translated">첫 번째 행 (색인 [0] 포함)은 코드 포인트 0의 값이 &quot;Basic Latin&quot;임을 의미합니다. 두 번째 줄의 @blocks_ranges 열에있는 &quot;0x0080&quot;항목은 첫 번째 줄 &quot;Basic Latin&quot;의 값이 0에서 0x0080까지, 즉 127을 포함하지 않는 범위의 모든 코드 포인트로 확장됨을 의미합니다. 즉, 0에서 127까지의 코드 포인트는 모두 &quot;Basic Latin&quot;블록에 있습니다. 마찬가지로 0x0080에서 0x0100까지 (포함되지 않음) 범위의 모든 코드 포인트는 &quot;Latin-1 Supplement&quot;라는 이름의 블록에 있습니다. (반환은 이전 스타일의 블록 이름입니다. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style 대 새로운 스타일의 블록 이름 &quot;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">첫 번째 줄 (색인 [0] 포함)은 코드 포인트 0의 값이 &quot;기본 라틴어&quot;임을 의미합니다. 두 번째 줄의 @blocks_ranges 열에서 &quot;0x0080&quot;항목은 첫 번째 줄 &quot;Basic Latin&quot;의 값이 0에서 0x0080까지, 즉 127까지의 모든 코드 포인트까지 확장됨을 의미합니다. 즉, 0에서 127까지의 코드 포인트는 모두 &quot;기본 라틴어&quot;블록에 있습니다. 마찬가지로, 등 &quot;라틴 -1 보충&quot;라는 이름의 블록에있는 0x0100은 0x0080까지의 (포함되지하지만)의 범위에있는 모든 코드 포인트 (공지 반환은 이전 스타일 블록 이름이라고는; 참조 &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;대 이전 스타일을 새로운 스타일의 블록 이름&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">위의 첫 번째 행은 &lt;code&gt;TIMESTAMP&lt;/code&gt; 를 9 개의 요소 목록으로 정의 하며, 목록 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 에 의해 리턴됩니다 . 스칼라 컨텍스트에서 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 리턴 한 문자열로 설정하려면 명시 적 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 키워드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="69decd40a9a2c32528b6b5800434c2cba08678b1" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;localtime()&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;localtime()&lt;/code&gt; in scalar context, an explicit &lt;code&gt;scalar&lt;/code&gt; keyword is required.</source>
          <target state="translated">위의 첫 번째 줄은 &lt;code&gt;TIMESTAMP&lt;/code&gt; 를 목록 컨텍스트에서 &lt;code&gt;localtime()&lt;/code&gt; 에 의해 반환되는 9 개 요소 목록으로 정의합니다 . 스칼라 컨텍스트에서 &lt;code&gt;localtime()&lt;/code&gt; 반환 한 문자열로 설정하려면 명시 적 &lt;code&gt;scalar&lt;/code&gt; 키워드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">첫 번째 행은 인수 스펙의 오류가 조기에 발견되도록합니다. 응용 프로그램을 배송 할 때 첫 번째 줄은 주석 처리해야합니다. 두 번째 줄은 쓸모가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">여기서 첫 번째 행은 오프셋 / 길이 테이블에 45 개의 항목이 포함되어 있음을 나타냅니다. 각 항목은 &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; 로 표시된 정수 쌍입니다 . 항목은 1부터 시작하여 번호가 매겨 지므로 여기서 # 1 항목은 &lt;code&gt;1[4]&lt;/code&gt; 이고 항목 # 12는 &lt;code&gt;5[1]&lt;/code&gt; 입니다. &lt;code&gt;1[4]&lt;/code&gt; 는 레이블이 &lt;code&gt;1:&lt;/code&gt; ( &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ) 인 노드 가 사전 컴파일 된 정규식의 문자 위치 1에서 시작하며 길이가 4 자임을 나타냅니다 . 위치 12의 &lt;code&gt;5[1]&lt;/code&gt; 은 레이블이 &lt;code&gt;12:&lt;/code&gt; ( &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ) 인 노드 가 사전 컴파일 된 정규식의 문자 위치 5에서 시작하며 길이는 1 자임을 나타냅니다. &lt;code&gt;12[1]&lt;/code&gt; 위치 14의 12 [1] 은 &lt;code&gt;14:&lt;/code&gt; 레이블이 지정된 노드 ( &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; )가 사전 컴파일 된 정규식의 문자 위치 12에서 시작하며 길이는 1 자임을 나타냅니다 . --- 즉 , 사전 컴파일 된 정규식 의 &lt;code&gt;+&lt;/code&gt; 기호에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e2bf1de2c16e8c0adbab29364ba1219b9e1777c7" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[length]&lt;/code&gt;. Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt;. &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">여기서 첫 번째 줄은 오프셋 / 길이 테이블에 45 개의 항목이 포함되어 있음을 나타냅니다. 각 항목은 &lt;code&gt;offset[length]&lt;/code&gt; 로 표시되는 정수 쌍입니다 . 항목은 1로 시작하여 번호가 매겨져 있으므로 여기서 항목 # 1은 &lt;code&gt;1[4]&lt;/code&gt; 이고 항목 # 12는 &lt;code&gt;5[1]&lt;/code&gt; 입니다. &lt;code&gt;1[4]&lt;/code&gt; 는 레이블이 &lt;code&gt;1:&lt;/code&gt; 노드 ( &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; )가 정규식의 사전 컴파일 된 양식에서 문자 위치 1에서 시작하고 길이가 4 자임을 나타냅니다 . 위치 12의 &lt;code&gt;5[1]&lt;/code&gt; 은 레이블이 &lt;code&gt;12:&lt;/code&gt; ( &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ) 인 노드 가 사전 컴파일 된 정규식 형식의 문자 위치 5에서 시작하고 길이가 1 자임을 나타냅니다. &lt;code&gt;12[1]&lt;/code&gt; 위치 (14)는 노드가 표시된 것을 나타낸다 &lt;code&gt;14:&lt;/code&gt; 합니다 ( &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; )는 정규식의 프리 컴파일 된 형태의 문자 위치 12에서 시작하고, 1 개 문자의 길이 --- 그 즉, 미리 컴파일 된 정규식 의 &lt;code&gt;+&lt;/code&gt; 기호에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">첫 번째 줄은 불필요한 배열 변수 &lt;code&gt;@array&lt;/code&gt; 를 만들지 않는다는 점을 제외하고 다음 두 줄의 줄임말 입니다.</target>
        </trans-unit>
        <trans-unit id="7be109e4ec8d67123623c616eb3634806eefdaf2" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="translated">첫 번째 줄은 불필요한 배열 변수 &lt;code&gt;@array&lt;/code&gt; 를 생성하지 않는다는 점을 제외하고 다음 두 줄의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="45c7b267b0324e3ee08f49728c4657a96f3be74f" translate="yes" xml:space="preserve">
          <source>The first line is the plan - it specifies the number of tests I'm going to run so that it's easy to check that the test script didn't exit before running all the expected tests. The following lines are the test results - 'ok' for pass, 'not ok' for fail. Each test has a number and, optionally, a description. And that's it. Any language that can produce output like that on STDOUT can be used to write tests.</source>
          <target state="translated">첫 번째 줄은 계획입니다. 예상되는 모든 테스트를 실행하기 전에 테스트 스크립트가 종료되지 않았는지 쉽게 확인할 수 있도록 실행할 테스트 수를 지정합니다. 다음 줄은 테스트 결과입니다. 통과하면 'ok', 실패하면 'not ok'입니다. 각 테스트에는 번호와 선택적으로 설명이 있습니다. 그리고 그게 다야. STDOUT에서 이와 같은 출력을 생성 할 수있는 모든 언어를 사용하여 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cea67f4153eeb52ccd2e3da747660523e22317" translate="yes" xml:space="preserve">
          <source>The first line of a</source>
          <target state="translated">첫 번째 줄</target>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">커밋 메시지의 첫 번째 줄은 마침표가없는 간단한 설명이어야합니다. 전자 메일의 제목 줄보다 길어서는 안됩니다 (50 자 정도).</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">첫 번째 줄은 미리 컴파일 된 형식의 정규식을 보여줍니다. 두 번째는 컴파일 된 폼의 크기 (임의의 단위, 보통 4 바이트 워드)와 오프셋 / 길이 테이블에 할당 된 총 바이트 수 (보통 4+ &lt;code&gt;size&lt;/code&gt; * 8)를 보여줍니다. 다음 줄은 라벨을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="a20c750a487464791d892a303a995f218caaa79f" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt;*8. The next line shows the label</source>
          <target state="translated">첫 번째 줄은 미리 컴파일 된 정규식 형식을 보여줍니다. 두 번째는 컴파일 된 형식의 크기 (임의 단위, 일반적으로 4 바이트 단어)와 오프셋 / 길이 테이블에 할당 된 총 바이트 수 (일반적으로 4+ &lt;code&gt;size&lt;/code&gt; * 8)를 보여줍니다. 다음 줄은 라벨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">첫 번째 방법은 CPU 프로그램 카운터의 샘플을 주기적으로 가져 오며, 프로그램 카운터는 함수에 대해 생성 된 코드와 상관 될 수 있으므로 프로그램이 어떤 함수를 사용하고 있는지 통계적으로 볼 수 있습니다. 매우 작은 / 빠른 기능은 프로파일에 나타날 확률이 낮으며 주기적으로 프로그램을 중단 (일반적으로 밀리 초 단위로 다소 자주 수행됨)하여 결과를 왜곡시킬 수있는 추가 오버 헤드가 발생한다는 점에주의해야합니다. 첫 번째 문제는 코드를 더 오랫동안 실행하여 완화 할 수 있으며 (일반적으로 이것은 프로파일 링에 대한 좋은 아이디어입니다) 두 번째 문제는 일반적으로 프로파일 링 도구 자체에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">이름은</target>
        </trans-unit>
        <trans-unit id="0263570650724ebe71f62b454fad700a5d663c69" translate="yes" xml:space="preserve">
          <source>The first number doesn't really mean anything, but it has to be 1. It's the second number that's important.</source>
          <target state="translated">첫 번째 숫자는 아무 의미가 없지만 1이어야합니다. 중요한 두 번째 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">사용 가능한 세 가지 기술 중 첫 번째는 C로 필터를 완전히 작성하는 것입니다. 외부 모듈은 Perl에서 제공하는 소스 필터 후크와 직접 인터페이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">이들 중 첫 번째는 오버로드 된 연산자 구현을 제공하는 피연산자입니다.이 경우 &lt;code&gt;minus()&lt;/code&gt; 메서드가 호출되는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">이 두 함수 중 첫 번째 함수는 해시 테이블 항목이 있는지 확인하고 두 번째 함수는 해시 테이블 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">첫 번째 것은 컨텍스트에서 명시 적으로 전달되며, 예를 들어 스레드 빌드에 필요합니다. 두 번째는 암묵적으로 그렇게합니다. 혼합하지 마십시오. aTHX_를 전달하지 않으면 함수에서 첫 번째로 dTHX (또는 dVAR)를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째는 &lt;code&gt;&quot;format&quot;&lt;/code&gt; 입니다 . 이것은 복소수의 두 숫자 부분에 사용되는 sprintf () 스타일 형식 문자열입니다. 다소 시스템에 따라 다르지만 가장 자주 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; 해당합니다 . &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 로 설정하여 기본값으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d3fa9f9095d6ba6fd87e541115beff9437b3d9" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt;, which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt;. You can revert to the default by setting the &lt;code&gt;format&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">첫 번째 는 복소수의 두 숫자 부분에 사용되는 sprintf () 스타일 형식 문자열 인 &lt;code&gt;&quot;format&quot;&lt;/code&gt; 입니다. 시스템에 따라 다소 다르지만 대부분 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; 해당합니다 . &lt;code&gt;format&lt;/code&gt; 을 &lt;code&gt;undef&lt;/code&gt; 로 설정하여 기본값으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">첫 번째는 Perl 5.22의 B :: PADNAMELIST이고 이전 버전의 B :: AV입니다. 나머지는 현재 B :: AV 개체이지만 이후 버전에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="094fe85cd4712afd8983c54311ea1fc6e32b5e2d" translate="yes" xml:space="preserve">
          <source>The first parameter is a scalar into which, upon success, the wide character represented by the multi-byte string contained in the second parameter is stored. The optional third parameter is ignored if it is larger than the actual length of the second parameter string.</source>
          <target state="translated">첫 번째 매개 변수는 성공시 두 번째 매개 변수에 포함 된 멀티 바이트 문자열로 표시되는 와이드 문자가 저장되는 스칼라입니다. 선택적 세 번째 매개 변수가 두 번째 매개 변수 문자열의 실제 길이보다 크면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b59fd7f35cf6d9692928110737a220c45e66d67" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;UTF8fARG&lt;/code&gt; is a boolean: 1 if the string is in UTF-8; 0 if string is in native byte encoding (Latin1). The second parameter is the number of bytes in the string to print. And the third and final parameter is a pointer to the first byte in the string.</source>
          <target state="translated">&lt;code&gt;UTF8fARG&lt;/code&gt; 에 대한 첫 번째 매개 변수 는 부울입니다. 문자열이 UTF-8이면 1; 문자열이 기본 바이트 인코딩 (Latin1) 인 경우 0입니다. 두 번째 매개 변수는 인쇄 할 문자열의 바이트 수입니다. 세 번째이자 마지막 매개 변수는 문자열의 첫 번째 바이트에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">&lt;code&gt;globmap&lt;/code&gt; 의 첫 번째 매개 변수 인 &lt;code&gt;*.tar.gz&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="bbc40cbdc77266be7323541d7a55e0277f7ff986" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">&lt;code&gt;globmap&lt;/code&gt; 의 첫 번째 매개 변수 인 &lt;code&gt;*.tar.gz&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">각 항목의 첫 번째 부분은 {...} 사이의 언어 태그입니다. 그 뒤에 언어 또는 언어 그룹의 영어 이름이옵니다. 일반적으로 사용하지 않는 언어 태그는 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">보고서의 첫 부분에는 이미 어떤 서브 루틴을 가장 많이 사용하는지에 대한 중요한 정보가 표시되어 있습니다. 다음은 프로파일 링 된 소스 파일에 대한 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">첫 번째 단계는 인용 된 구문의 끝을 찾는 것입니다. 따라서 원본 구분 기호가 무엇인지 알 필요가 없도록 정규화 된 시작 및 끝 구분 기호 사이의 텍스트 복사본을 안전한 위치에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="52dc28c1ba280be3247117e934caac44df1ea80f" translate="yes" xml:space="preserve">
          <source>The first portions of this document contains instructions to cross-compile Perl for Android 2.0 and later, using the binaries provided by Google. The latter portions describe how to build perl native using one of the toolchains available on the Play Store.</source>
          <target state="translated">이 문서의 첫 부분에는 Google에서 제공하는 바이너리를 사용하여 Android 2.0 이상용 Perl을 크로스 컴파일하는 방법이 포함되어 있습니다. 후반부에서는 Play 스토어에서 제공되는 도구 모음 중 하나를 사용하여 펄 네이티브를 빌드하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">첫 번째 수량 자 '. *'는 전체 문자열 '모자에있는 고양이'를 일치시켜 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">첫 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 는 정규식 일치를 유지하면서 가능한 한 많은 문자열을 가져옵니다. 두 번째 수량 자 &lt;code&gt;.*&lt;/code&gt; 에는 문자열이 없으므로 0 번 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">첫 번째 이유는이 기술이</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">정규 표현식 은 대소 문자를 구분하므로 첫 번째 정규 표현식 &lt;code&gt;world&lt;/code&gt; 는 일치하지 않습니다. 문자열 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 에서 하위 문자열 &lt;code&gt;'o W'&lt;/code&gt; 가 발생 하기 때문에 두 번째 정규 표현식이 일치 합니다 . 공백 문자 ''는 정규 표현식에서 다른 문자와 같이 취급되며이 경우 일치해야합니다. 공백 문자가 없기 때문에 세 번째 정규 표현식 &lt;code&gt;'oW'&lt;/code&gt; 가 일치하지 않습니다. 네 번째 정규 표현식 &lt;code&gt;'World '&lt;/code&gt; 는 정규 표현식 의 끝에 공백이 있지만 문자열의 끝에는 없기 때문에 일치하지 않습니다. 여기서 교훈은 정규 표현식이 문자열의 일부와 일치해야한다는 것입니다</target>
        </trans-unit>
        <trans-unit id="d791e1a0374a959ba40ed9f40fd370a5d5a456cb" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;. The space character &lt;code&gt;' '&lt;/code&gt; is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &quot;&lt;code&gt;World &lt;/code&gt;&quot; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">정규 표현식 은 대소 문자를 구분하기 때문에 첫 번째 정규 표현식 &lt;code&gt;world&lt;/code&gt; 는 일치하지 않습니다. 두 번째 정규식 은 문자열 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 에 하위 문자열 &lt;code&gt;'o W'&lt;/code&gt; 가 발생 하기 때문에 일치 합니다 . 공백 문자 &lt;code&gt;' '&lt;/code&gt; 는 정규 표현식의 다른 문자처럼 취급되며이 경우 일치해야합니다. 공백 문자가 없기 때문에 세 번째 정규식 &lt;code&gt;'oW'&lt;/code&gt; 가 일치하지 않습니다. 네 번째 정규식 &quot; &lt;code&gt;World &lt;/code&gt; &quot;는 정규식 끝에 공백이 있지만 문자열 끝에는 없기 때문에 일치하지 않습니다. 여기서 교훈은 정규 표현식이 문자열의 일부와 일치해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">문자열이 &lt;code&gt;keep&lt;/code&gt; 보다 많기 때문에 첫 번째 정규 표현식이 일치하지 않습니다 . 두 번째 정규 표현식은 정확히 문자열이므로 일치합니다. 정규 표현식에서 &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 를 모두 사용 하면 전체 문자열이 일치하므로 일치하는 문자열과 일치하지 않는 문자열을 완벽하게 제어 할 수 있습니다. bert라는 이름의 동료를 찾고 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="467dd0993aab8207646a6fe07d7110c16e4ae880" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt;. Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">첫 번째 정규식은 문자열이 &lt;code&gt;keep&lt;/code&gt; 보다 더 많은 것을 가지고 있기 때문에 일치하지 않습니다 . 두 번째 정규식은 정확히 문자열이므로 일치합니다. 정규 표현식에서 &lt;code&gt;'^'&lt;/code&gt; 와 &lt;code&gt;'$'&lt;/code&gt; 를 모두 사용 하면 전체 문자열이 일치하도록 강제하므로 일치하는 문자열과 일치하지 않는 문자열을 완벽하게 제어 할 수 있습니다. 혼자서 끈으로 묶인 bert라는 동료를 찾고 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">첫 번째는 두 해시 모두 동일한 데이터를 포함하고 두 번째는 그렇지 않은 것으로보고합니다. 당신이 선호하는 것은 독자에게 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">첫 번째 섹션에서는 1003.1 사양의 POSIX 기능에 대해 설명합니다. 두 번째 섹션에서는 신호 객체, TTY 객체 및 기타 기타 객체에 대한 클래스를 설명합니다. 나머지 섹션에는 IEEE Std 1003.1b-1993을 따르는 조직의 다양한 상수 및 매크로가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">첫 번째 섹션은 다양한 C 데이터 유형을 이름에 맵핑하는데, ​​이는 다양한 Perl 유형과 다소 일치합니다. 두 번째 섹션에는 &lt;b&gt;xsubpp&lt;/b&gt; 가 입력 매개 변수를 처리 하는 데 사용 하는 C 코드가 포함되어 있습니다 . 세 번째 섹션에는 &lt;b&gt;xsubpp&lt;/b&gt; 가 출력 매개 변수를 처리 하는 데 사용 하는 C 코드가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">이 문서의 첫 번째 섹션은 항목 별 체크리스트를 제공합니다. 다음 섹션에서는 목록에있는 항목에 대한 자세한 설명을 제공합니다. 마지막 섹션 인 &quot;일반적인 함정&quot;은 CPAN 작성자가 가장 많이 저지른 실수 중 일부를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">첫 번째 통계 세트는 &quot;Good&quot;, &quot;Poor&quot;및 &quot;Bad&quot;로 변환 된 품질 점수 (점수 &amp;lt;= 1.05, 점수 &amp;lt;= 1.2, 점수&amp;gt; 1.2)를 포함하여 몇 가지 요약 통계 정보를 제공합니다. 자세한 내용은 bucket_stats ()의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">첫 번째 상황이 훨씬 더 자주 발생하므로 상용구를 다음과 같이 다시 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">첫 번째 상태는 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 및 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러 에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">첫 번째 단계는 다음 줄을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">이러한 행을 처리하는 첫 번째 단계는 16 진 데이터를 2 진으로 변환하여 체크섬을 확인하면서 4 개의 필드를 얻는 것입니다. 놀랍지 않습니다. 모든 것을 이진으로 변환 하는 간단한 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 호출로 시작할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3d051bbcc0b2bf5e763df328cc13763c82b21bfe" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;pack&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">이러한 라인을 처리하는 첫 번째 단계는 체크섬을 확인하면서 4 개의 필드를 얻기 위해 16 진수 데이터를 바이너리로 변환하는 것입니다. 당연합니다. 모든 것을 바이너리로 변환 하는 간단한 &lt;code&gt;pack&lt;/code&gt; 호출로 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">이 정규 표현식과 일치하는 첫 번째 문자열 위치 는 &lt;code&gt;programming&lt;/code&gt; 의 첫 번째 &lt;code&gt;'m'&lt;/code&gt; 입니다 . 이 위치에서 최소 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; 하나의 &lt;code&gt;'m'&lt;/code&gt; 과 일치합니다 . 두 번째 수량자는 &lt;code&gt;.*?&lt;/code&gt; 문자와 일치하지 않는 것을 선호한다면 문자열의 끝 앵커 &lt;code&gt;$&lt;/code&gt; 에 의해 제한되어 나머지 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5f895607d70ebcfe9c61321d68de376e6e1b258c" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;. At this position, the minimal &lt;code&gt;m{1,2}?&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt;. Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;'$'&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">이 정규 표현식이 일치 할 수있는 첫 번째 문자열 위치 는 &lt;code&gt;programming&lt;/code&gt; 의 첫 번째 &lt;code&gt;'m'&lt;/code&gt; 에 있습니다 . 이 위치에서 최소 &lt;code&gt;m{1,2}?&lt;/code&gt; 하나의 &lt;code&gt;'m'&lt;/code&gt; 과 일치합니다 . 두 번째 수량 자 &lt;code&gt;.*?&lt;/code&gt; 문자와 일치하지 않으려는 경우 나머지 문자열과 일치하도록 문자열 끝 앵커 &lt;code&gt;'$'&lt;/code&gt; 에 의해 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">정규 표현식을 작성하는 첫 번째 작업은 일치시킬 항목과 제외 할 대상을 결정하는 것입니다. 이 경우 정수와 부동 소수점 숫자를 모두 일치시키고 숫자가 아닌 문자열을 거부하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">이 &quot;= over&quot;... &quot;= back&quot;영역에 항목이 전혀없는 경우가 아니라면 &quot;= over&quot;명령 다음에 나오는 첫 번째 항목은 &quot;= item&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">첫 번째 스레드는 &lt;code&gt;$x&lt;/code&gt; 에서 잠금을 잡은 다음 두 번째 스레드가 약간의 작업을 수행 할 시간이있는 일시 정지 후에 &lt;code&gt;$y&lt;/code&gt; 에서 잠금을 잡으려고 시도합니다 . 한편 두 번째 스레드는 &lt;code&gt;$y&lt;/code&gt; 에서 잠금을 잡고 나중에 &lt;code&gt;$x&lt;/code&gt; 에서 잠금을 잡으려고 시도합니다 . 두 스레드에 대한 두 번째 잠금 시도가 차단되며 각 스레드는 다른 스레드가 잠금을 해제 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="1b0e5abdf339f37172dcc121e02e6f88bb538337" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt;, then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt;. Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt;, then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt;. The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">첫 번째 스레드는 &lt;code&gt;$x&lt;/code&gt; 에 대한 잠금을 확보 한 다음 두 번째 스레드가 작업을 수행 할 시간이있을 때 일시 중지 한 후 &lt;code&gt;$y&lt;/code&gt; 에 대한 잠금을 확보 합니다. 한편, 두 번째 스레드는 &lt;code&gt;$y&lt;/code&gt; 에 대한 잠금을 확보 한 다음 나중에 &lt;code&gt;$x&lt;/code&gt; 에 대한 잠금을 확보하려고합니다 . 두 스레드에 대한 두 번째 잠금 시도는 차단되며 각각 다른 스레드가 잠금을 해제 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">루프를 처음으로 수행하면 줄 0부터 끝까지 전체 파일을 다시 작성합니다. 루프를 두 번째로 수행하면 줄 1부터 끝까지 전체 파일을 다시 씁니다. 루프를 통해 세 번째로 전체 파일을 2 행에서 끝까지 다시 작성합니다. 등등.</target>
        </trans-unit>
        <trans-unit id="0d6a59a26170358aef33f4d3978afce2e252997e" translate="yes" xml:space="preserve">
          <source>The first two arguments taken by this method are the name of the symbol and the value which should be assigned to it. The optional third argument is a string specifying the symbol table to be used; 'GLOBAL' specifies the global symbol table, and any other string specifies the local symbol table. If this argument is omitted, the default symbol table for the object is used. &lt;code&gt;setsym&lt;/code&gt; returns TRUE if successful, and FALSE otherwise.</source>
          <target state="translated">이 메소드가 취하는 처음 두 개의 인수는 기호의 이름과 할당되어야하는 값입니다. 선택적 세 번째 인수는 사용할 기호 테이블을 지정하는 문자열입니다. 'GLOBAL'은 전역 기호 테이블을 지정하고 다른 문자열은 로컬 기호 테이블을 지정합니다. 이 인수를 생략하면 객체의 기본 기호 테이블이 사용됩니다. &lt;code&gt;setsym&lt;/code&gt; 은 성공하면 TRUE를 반환하고 그렇지 않으면 FALSE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">처음 두 필드는 sbrk (2) ed (ess-broken? :-)의 총 메모리 양과 사용 된 sbrk (2)의 수를 나타냅니다. 세 번째 숫자는 펄이 리턴 된 청크의 연속성에 대해 생각하는 것입니다. 이 숫자가 양수인 한 malloc ()은 sbrk (2)가 연속 메모리를 제공 할 가능성이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0819c6d2283041c7cfda116e5fb9ae13c3a8c8e6" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">처음 두 형식 은 &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;코드 포인트 인수&quot;&lt;/a&gt; 가 컴포지션 정규화에 의해 생성되지 않아야 하는 경우 &lt;b&gt;true를&lt;/b&gt; 반환 &lt;b&gt;합니다&lt;/b&gt; . 마지막 두 양식이 &lt;b&gt;true&lt;/b&gt; 를 반환 하려면이 사실을 유니 코드 데이터베이스에서 확인할 수없는 것이 추가로 필요합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">첫 번째 두 가지 형태로 반환 &lt;b&gt;진정한&lt;/b&gt; 경우 생성 &lt;a href=&quot;#code-point-argument&quot;&gt;코드 포인트 인수가&lt;/a&gt; 구성 정상화 발생하지 않음. 마지막 두 형식이 &lt;b&gt;true&lt;/b&gt; 를 반환 하려면 유니 코드 데이터베이스에서이 사실을 판별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">출력 문자열에서 대체 될 첫 번째 값 (일반적으로 커서 주소 지정 기능의 열)</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">명시적인 버전 번호를 포함하는 첫 번째 TAP 버전은 13입니다.</target>
        </trans-unit>
        <trans-unit id="23a0afbda307c4ae7b5c2196fca71616dba92438" translate="yes" xml:space="preserve">
          <source>The first version of this article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">이 기사의 첫 번째 버전은 원래 The Perl Journal # 11에 실 렸으며 저작권은 1998 The Perl Journal입니다. Jon Orwant와 The Perl Journal이 제공 한 것으로 보입니다. 이 문서는 Perl 자체와 동일한 조건으로 배포 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">이 문서의 첫 번째 버전은 여러 사람들이 유용한 제안을 한 Perl Monks에 게재되었습니다. 감사합니다, 펄 몽크 스</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">간접 객체가없는 첫 번째 버전은</target>
        </trans-unit>
        <trans-unit id="6781fdff7b279779b03d140931fe35f9d498c177" translate="yes" xml:space="preserve">
          <source>The first will run all test files in all first-level subdirectories and all subdirectories they contain. The second will run tests in only the</source>
          <target state="translated">첫 번째는 모든 첫 번째 수준 하위 디렉터리와 여기에 포함 된 모든 하위 디렉터리의 모든 테스트 파일을 실행합니다. 두 번째는</target>
        </trans-unit>
        <trans-unit id="4cf53ff13525a226bb832b26adcd06a8433dba05" translate="yes" xml:space="preserve">
          <source>The fix is to remove all Test::Builder1.5/2 related code. Either use the legacy Test::Builder API, or use Test2 directly.</source>
          <target state="translated">수정 사항은 모든 Test :: Builder1.5 / 2 관련 코드를 제거하는 것입니다. 레거시 Test :: Builder API를 사용하거나 Test2를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f2b513d7712476adb9fe5c913d728ae8bf500df8" translate="yes" xml:space="preserve">
          <source>The fix is to use the API specified in &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; to look at or modify state as needed.</source>
          <target state="translated">수정 사항은 &lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt; 에 지정된 API를 사용하여 필요에 따라 상태를 보거나 수정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">완전 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">완전 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e30f3c3943bfb47da6b22d33c6d6f3755c5c4c90" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">축어 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="0f14452e50daa176a2948e6c80e179269ad7ea89" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">축어 텍스트 및 코드에 사용할 고정 너비 글꼴입니다. 기본값은 &lt;code&gt;CW&lt;/code&gt; 입니다. 일부 시스템은 대신 &lt;code&gt;CR&lt;/code&gt; 을 원할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="67ad2fb87b3a3c9138524933b76f13bbb404b147" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;SVs_PADSTALE&lt;/code&gt; is cleared on lexicals each time the &lt;code&gt;my()&lt;/code&gt; is executed, and set on scope exit. This allows the &lt;code&gt;&quot;Variable $x is not available&quot;&lt;/code&gt; warning to be generated in evals, such as</source>
          <target state="translated">&lt;code&gt;SVs_PADSTALE&lt;/code&gt; 플래그 는 &lt;code&gt;my()&lt;/code&gt; 가 실행될 때마다 어휘 에서 지워지고 범위 종료시 설정됩니다. 이렇게하면 &lt;code&gt;&quot;Variable $x is not available&quot;&lt;/code&gt; 경고가 다음과 같은 평가에서 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239752a03e595c22089872230ac5d8660b72070d" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;UNICODE_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three of the above WARN flags; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three DISALLOW flags. &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; restricts the allowed inputs to the strict UTF-8 traditionally defined by Unicode. Similarly, &lt;code&gt;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; are shortcuts to select the above-Unicode and surrogate flags, but not the non-character ones, as defined in &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UNICODE_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt; 플래그 는 위의 세 가지 WARN 플래그를 모두 선택합니다. 및 &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; 는 세 DISALLOW 플래그를 선택합니다. &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; 는 허용 된 입력을 전통적으로 유니 코드로 정의 된 엄격한 UTF-8로 제한합니다. 마찬가지로 &lt;code&gt;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; 및 &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; 는 &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum # 9에&lt;/a&gt; 정의 된대로 위의 유니 코드 및 대리 플래그를 선택하는 바로 가기이지만 문자가 아닌 플래그는 선택하지 않습니다 . &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;perlunicode의 &quot;비 문자 코드 포인트&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">my ()가 실행될 때마다 어휘에서 SVs_PADSTALE 플래그가 지워지고 범위 종료시 설정됩니다. 이를 통해 다음과 같은 evals에서 'Variable $ x is not available'경고가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2aaf40e59e4745cf25b943d852f6d075ba40074" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;UTF8_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt;, and &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is also specified.)</source>
          <target state="translated">플래그의 &lt;code&gt;UTF8_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt; , &lt;code&gt;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; , &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt; , &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt; 및 &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; 는 각각의 카테고리에 제기되는 경고 메시지의 원인이되지만, 그렇지 않으면 코드 포인트가 유효한 것으로 간주 (안 기형)된다. 카테고리를 기형으로 처리하고 경고를 발생 시키려면 WARN 및 DISALLOW 플래그를 모두 지정하십시오. (그러나 어휘 적으로 비활성화되거나 &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 도 지정된 경우 경고가 발생하지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR 및 UTF8_WARN_SUPER 플래그는 해당 범주에 대해 경고 메시지가 발생하지만 그렇지 않으면 코드 포인트가 유효한 것으로 간주됩니다 (기형이 아님). 카테고리를 기형으로 취급하고 경고를 발생 시키려면 WARN 및 DISALLOW 플래그를 모두 지정하십시오. (단, 사 전적으로 사용하지 않거나 UTF8_CHECK_ONLY도 지정하면 경고가 발생하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">다른 것을 원하면 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 을 사용 하거나 POSIX :: SigRt에서 파생하여 자신 만의 &lt;code&gt;new()&lt;/code&gt; (연결된 해시 STORE 메소드를 정의 할 수 있음 ) &lt;code&gt;%SIGRT&lt;/code&gt; 는 &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; . 여기서 &lt;code&gt;$rtsig&lt;/code&gt; 범위는 0에서 &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="723ee765d373688ffd88695151d122551f3cfc41" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;local&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt;, or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt;, where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt;.</source>
          <target state="translated">플래그는 기본적으로 0으로 설정됩니다. 다른 것을 원하면 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 에서 &lt;code&gt;local&lt;/code&gt; 을 사용 하거나 POSIX :: SigRt에서 파생하여 자신의 &lt;code&gt;new()&lt;/code&gt; 정의 할 수 있습니다 . &lt;code&gt;%SIGRT&lt;/code&gt; 는 &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; . 여기서 &lt;code&gt;$rtsig&lt;/code&gt; 범위는 0에서 &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">flags 매개 변수는 필수입니다. 유효한 플래그 값은 R_CURSOR, R_FIRST, R_LAST, R_NEXT 및 R_PREV입니다.</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">플래그는 사전 순서와 대소 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">맛</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">부동 소수점 무한대는 서브 루틴 Inf ()로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b219578f1fed53f8498341e6252dcc91a786ab6d" translate="yes" xml:space="preserve">
          <source>The floating point number is taken and split first on the single decimal place, then each group of three digits to the right of the decimal makes up the next digit, and so on until the number of significant digits is exhausted, &lt;b&gt;plus&lt;/b&gt; enough trailing zeros to reach the next multiple of three.</source>
          <target state="translated">부동 소수점 숫자는 촬영과 하나의 소수 자리에 처음으로 분할 한 후 소수의 오른쪽에 세 자리의 각 그룹은 다음 숫자를 구성하는 등 유효 숫자의 수는 지쳐 때까지에 &lt;b&gt;플러스&lt;/b&gt; 충분한 후행 0으로 다음 3의 배수에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">모듈 개발자 만 볼 수있는 부분보다는 모듈 사용자에게 표시되는 스타일 요소에 중점을 둡니다. 그러나이 문서에 제시된 많은 지침을 외삽하여 모듈 내부에 성공적으로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">이 API의 클라이언트는 다음 &quot;공용&quot;전역 이름을 읽을 수 있습니다. 이것들은 &quot;읽기 전용&quot;으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">클라이언트가 다음 &quot;가상&quot;메소드를 정의 할 수 있습니다. 적절한 시점에 API에 의해 호출됩니다. 달리 지정하지 않는 한 디버그 API는 이러한 메소드의 비어 있고 작동하지 않는 기본 버전 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">다음은 % HASH 및 @ARRAY의 모든 값을 비효율적으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">다음 API 목록에는 함수가 포함되어 있으므로 수정 가능한 데이터에 대한 포인터를 명시 적으로 제공해야합니다 (C 포인터 또는 Perlish &lt;code&gt;GV *&lt;/code&gt; s). 위의 매크로가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 를 사용하는 경우 비슷한 함수가 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d7722c25bc63a475d0687db360090ccce2f038b0" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt;s). Where the above macros take &lt;code&gt;int&lt;/code&gt;, a similar function takes &lt;code&gt;int *&lt;/code&gt;.</source>
          <target state="translated">다음 API 목록에는 함수가 포함되어 있으므로 수정 가능한 데이터에 대한 포인터를 명시 적으로 제공해야합니다 (C 포인터 또는 Perlish &lt;code&gt;GV *&lt;/code&gt; ). 위의 매크로가 &lt;code&gt;int&lt;/code&gt; 를 사용하는 경우 유사한 함수가 &lt;code&gt;int *&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">다음 API는 현재 구현에서 Perl 내부의 일부를 사용합니다. 따라서 효율적이지만 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a57e29ab087cd96e1aaf0f9eb948df8f4a4939a" translate="yes" xml:space="preserve">
          <source>The following CVE reports were previously filed against File-Path and are believed to have been addressed:</source>
          <target state="translated">다음 CVE 보고서는 이전에 File-Path에 대해 제출되었으며 해결 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">다음 NNTP 명령은 패키지에서 지원되지 않으므로 그렇게 할 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">다음 RFC959 명령이 구현되지 않았습니다 :</target>
        </trans-unit>
        <trans-unit id="8ed1bcda5c1f977c3cd2bdcf823f30eee9e9931d" translate="yes" xml:space="preserve">
          <source>The following SDK and compiler configurations and Nokia phones were tested at some point in time (+ = compiled and PerlApp run, - = not), both for Perl 5.8.x and 5.9.x:</source>
          <target state="translated">다음 SDK 및 컴파일러 구성과 Nokia 휴대폰은 Perl 5.8.x 및 5.9.x 모두에 대해 특정 시점 (+ = 컴파일되고 PerlApp 실행,-= 아님)에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">다음 VMS 특정 정보는 &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; 의 일반 정보 외에도 표시된 &quot;특별한&quot;Perl 변수에 적용 됩니다. 충돌이있는 경우이 정보가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">다음과 같은 Win32 방법이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">다음 XS 코드는 ONC + TIRPC와 함께 사용되는 getnetconfigent () 함수를 보여줍니다. getnetconfigent () 함수는 C 구조에 대한 포인터를 리턴하며 아래에 표시된 C 프로토 타입을 갖습니다. 이 예제는 C 포인터가 Perl 참조가되는 방법을 보여줍니다. 펄은이 참조를 복된 대상에 대한 포인터라고 생각하고 대상에 대한 소멸자를 호출하려고 시도합니다. XS 소스에 소멸자가 제공되어 getnetconfigent ()가 사용하는 메모리를 비 웁니다. 이름이 &lt;b&gt;DESTROY로&lt;/b&gt; 끝나는 XSUB 함수를 지정하여 XS의 소멸자를 작성할 수 있습니다 . XS 소멸자를 사용하여 다른 XSUB에서 malloc 한 메모리를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">다음 XS 파일은 rpcb_gettime () 함수에 대한 가능한 인터페이스를 보여주는 XS 서브 루틴 또는 XSUB를 보여줍니다. 이 XSUB는 C와 Perl 간의 직접 변환을 나타내므로 Perl에서도 인터페이스를 유지합니다. 이 XSUB는 위에 표시된 사용법으로 Perl에서 호출됩니다. &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; 및 &lt;code&gt;XSUB.h&lt;/code&gt; 에 대한 처음 세 개의 #include 문 은 항상 XS 파일의 시작 부분에 있습니다. 이 방법과 다른 방법은이 문서의 뒷부분에서 확장 될 것입니다. 인터프리터 컨텍스트를보다 효율적으로 가져 오려면 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 에 #define이 있어야합니다 . 자세한 내용 은 &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d04933d03d9fe0141ffb2c1060f6f198f4e41d2" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt;, &lt;code&gt;perl.h&lt;/code&gt;, and &lt;code&gt;XSUB.h&lt;/code&gt;, will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">다음 XS 파일은 rpcb_gettime () 함수에 대한 하나의 가능한 인터페이스를 보여주는 XS 서브 루틴 또는 XSUB를 보여줍니다. 이 XSUB는 C와 Perl 간의 직접 변환을 나타내므로 Perl에서도 인터페이스를 유지합니다. 이 XSUB는 위에 표시된 사용법으로 Perl에서 호출됩니다. &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; 및 &lt;code&gt;XSUB.h&lt;/code&gt; 에 대한 처음 세 개의 #include 문 은 항상 XS 파일의 시작 부분에 있습니다. 이 접근 방식 및 기타 방법은이 문서의 뒷부분에서 확장 될 것입니다. 인터프리터 컨텍스트를보다 효율적으로 가져 오려면 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; 에 대한 #define이 있어야합니다 . 자세한 내용 은 &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">다음 XSUB를 사용하면 Perl 프로그램이 sin ()이라는 C 라이브러리 함수에 액세스 할 수 있습니다. XSUB는 단일 인수를 사용하고 단일 값을 반환하는 C 함수를 모방합니다.</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">다음 XSUB는 매개 변수를 특수하게 처리해야하는 C 함수용입니다. Perl 사용법이 먼저 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">다음 XSUB는 &lt;code&gt;SV *&lt;/code&gt; 리턴 유형을 니모닉으로 만 사용하고 CODE : 블록을 사용하여 프로그래머가 필요한 모든 코드를 제공했음을 컴파일러에 표시합니다. sv_newmortal () 호출은 반환 값을 undef로 초기화하여 기본 반환 값으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">다음 XSUB는 C rpcb_gettime () 함수를 호출하고 두 개의 출력 값인 timep 및 status를 Perl에 단일 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">다음 XSUB는 잘못된 C 코드를 생성합니다. &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러는 호출하는 코드로이 켜집니다 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 매개 변수 &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; 하지만, 실제 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 원하는 &lt;code&gt;timep&lt;/code&gt; 의 매개 변수 타입의 수 &lt;code&gt;time_t*&lt;/code&gt; 보다는 &lt;code&gt;time_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8ca7ce02dc17e5f491e4977939dfb34745c228" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char *host, time_t timep)&lt;/code&gt;, but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="translated">다음 XSUB는 잘못된 C 코드를 생성합니다. &lt;b&gt;은 xsubpp&lt;/b&gt; 컴파일러는 호출하는 코드로이 켜집니다 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 매개 변수 &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; 하지만, 실제 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 원하는 &lt;code&gt;timep&lt;/code&gt; 의 매개 변수 타입의 수 &lt;code&gt;time_t*&lt;/code&gt; 보다는 &lt;code&gt;time_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">다음은 Perl을 지원하는 Win32 다국어 편집기 / IDE입니다.</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">다음은 요청 된 추가 사항이지만 펄에서 구현하기가 매우 간단하여 추가를 꺼려했습니다.</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">다음은 모든 접근 자 메서드입니다. 즉, 자체적으로 작업을 수행하지 않고이 특정 일괄 변환에 대한 옵션을 포함하는 변환 개체의 내용 만 변경하면됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">다음은 POSIX / SUSv3에서도 정의되지만 불행히도 널리 구현되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">다음은 컴파일 및 / 또는 실행 실패의 일반적인 원인이며 Perl에는 일반적이지 않습니다. C FAQ는 취침 시간이 좋습니다. 가능한 한 많은 C 컴파일러와 플랫폼으로 변경 사항을 테스트하십시오. 어쨌든 우리는 공개적인 당황에서 자신을 구하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">다음이 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">다음은 ISO 8859-1 (Latin-1) 바이트에서 UTF-8 바이트로의 빠른 변환 및 그 이전 코드이며, 이전 Perl 5 버전에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">다음은 DB 기본 클래스의 메소드입니다. API는 상속 메커니즘을 통해 클라이언트를 추적하므로 클라이언트는 상속을 통해 이러한 메소드에 액세스해야합니다 (* 직접 호출하지 않음).</target>
        </trans-unit>
        <trans-unit id="10865635be3faf44cc57e9f25634d2220e52c67d" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">다음은 이러한 인터페이스입니다. 또한 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;&quot;유니 코드 버그 &quot;&quot;를&lt;/a&gt; 참조하십시오 . 현재 (v5.16.0부터) 이러한 모든 인터페이스에 대해 Perl은 단순히 바이트 문자열을 인수와 결과로 가정하거나 (더 이상 사용되지 않는) &lt;code&gt;encoding&lt;/code&gt; pragma가 사용 된 경우 UTF-8 문자열이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">다음은 그러한 인터페이스입니다. 또한 &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;유니 코드 버그를&lt;/a&gt; 참조하십시오 . 이러한 모든 인터페이스에서 Perl은 현재 (v5.16.0 기준) 바이트 문자열을 인수 및 결과 또는 (더 이상 사용되지 않는) &lt;code&gt;encoding&lt;/code&gt; pragma가 사용 된 경우 UTF-8 문자열로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">다음은 서브 루틴의 내장 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">다음은 변수에 내장 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="ff4fdef880964ea16866f7dda3f218be964bbbac" translate="yes" xml:space="preserve">
          <source>The following are unsupported due to the lack of mapping data.</source>
          <target state="translated">다음은 매핑 데이터가 부족하여 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">다음은 유효합니다 ($ t1 및 $ t2는 Time :: Piece 객체 임).</target>
        </trans-unit>
        <trans-unit id="cbc24e337c1d628f49530f574e24235d24a7392e" translate="yes" xml:space="preserve">
          <source>The following article by Sean M. Burke and Jordan Lachler first appeared in</source>
          <target state="translated">Sean M. Burke와 Jordan Lachler의 다음 기사는</target>
        </trans-unit>
        <trans-unit id="5045c4560d45f5e572e375de5ca429c353310df0" translate="yes" xml:space="preserve">
          <source>The following assume that the error has been copied into a separate scalar:</source>
          <target state="translated">다음은 오류가 별도의 스칼라에 복사되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">다음 속성은 WriteMakefile ()에 대한 인수 또는 명령 행에서 NAME = VALUE 쌍으로 지정 될 수 있습니다. 이후 버전의 MakeMaker에서 사용할 수있는 속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">다음 블록은 다소 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">다음 부울 메소드는 다음을 판별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">이 모듈에서 다음 bzip2 상수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">현재 다음 점검이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">다음 코드는 함수 매개 변수에 초기화 코드를 제공하는 방법을 보여줍니다. 초기화 코드는 출력에 추가되기 전에 컴파일러에서 큰 따옴표 안에 평가되므로 문자 그대로 [주로 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;\\&lt;/code&gt; ] 로 해석 해야하는 것은 백 슬래시로 보호해야합니다. 변수 &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; 및 &lt;code&gt;$type&lt;/code&gt; 은 typemaps에서와 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9746ef7b7145a5c34d6668413bb27b113b96441f" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, or &lt;code&gt;\\&lt;/code&gt;] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt;, &lt;code&gt;$arg&lt;/code&gt;, and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">다음 코드는 함수 매개 변수에 대한 초기화 코드를 제공하는 방법을 보여줍니다. 초기화 코드는 출력에 추가되기 전에 컴파일러에 의해 큰 따옴표로 평가되므로 문자 그대로 [주로 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;\\&lt;/code&gt; ] 해석되어야하는 모든 항목 은 백 슬래시로 보호되어야합니다. &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; 및 &lt;code&gt;$type&lt;/code&gt; 변수 는 타입 맵에서와 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">다음 코드는 모든 출력을 출력 바이트의 16 진수 덤프로 변환하는 출력 핸들을 엽니 다. 예를 들어 &quot;A&quot;는 &quot;41&quot;로 변환됩니다 (ASCII 기반 시스템의 경우 EBCDIC 플랫폼에서 &quot;A&quot;는 &quot;c1&quot;)</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">다음 코드는 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; 이라는 ASCII 문자열을 작성합니다 . 주석은 각 단계 후 문자열을 보여줍니다. 이 코드는 big-endian 또는 little-endian 시스템에서 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="036e8023d85aa6d81194f031f72a68fa7f59b794" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt;. The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">다음 코드는 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; 이라는 ASCII 문자열을 빌드합니다 . 주석은 각 단계 후에 문자열을 표시합니다. 이 코드는 빅 엔디안 또는 리틀 엔디안 머신에서 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">다음 코드는 단일 레벨 배열에서 작동합니다. 문자열 비교를 사용하며 정의 된 빈 문자열과 정의되지 않은 빈 문자열을 구별하지 않습니다. 다른 요구 사항이 있으면 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">다음 데이터 정렬은 모두 의미가 있으며 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 하는 경우 &quot;를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c757c0b2a139bcc3c8432fda1a1f80dbad9e220" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;.</source>
          <target state="translated">다음 데이터 정렬은 모두 의미가 있으며 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; 하면 이들 중 하나를 만날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">다음과 같은 명령 문자가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">다음 명령 행 스위치는 VMS에서 &lt;a href=&quot;perlrun&quot;&gt;perlrun에&lt;/a&gt; 설명 된 것과 다르게 작동합니다 . CRTL이 인용되지 않은 모든 문자열을 다운 케이스하기 때문에 대문자 스위치를 Perl에 전달하려면 명령 행에서 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">다음 명령은 NIST 테스트 벡터 &quot;abc&quot;와 같은 일반적인 입력에 대한 다이제스트를 계산하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">다음 컴파일 경고는 11.31 이전의 HP-UX 릴리즈에서 발생할 수 있지만 무해합니다.</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">다음 컴파일러 버전은 현재 IBM에서 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">다음의 복합 명령문을 사용하여 흐름을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b58da98f934bf4b5cdd1337624b0bd2ba9de07" translate="yes" xml:space="preserve">
          <source>The following compression formats are supported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;</source>
          <target state="translated">다음 압축 형식은 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 및 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">getaddrinfo () 또는 getnameinfo ()에 의해 다음 상수가 리턴 될 수 있습니다. 다른 것들은 OS에 의해 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">다음 상수는 $ xflags로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">다음 디버거가 실제로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="becc45c3efb50622f9f813d964b04c0775034a75" translate="yes" xml:space="preserve">
          <source>The following describes</source>
          <target state="translated">다음은 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">다음과 같은 방법 설명은 아직 개발 중입니다. 적절하게 문서화되지 않은 섹션은 코드를 참조하고 makemaker@perl.org 메일 링리스트에 큰 소리로 불평하십시오. 더 나은 패치를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">다음 문서는 치명적 경고를 사용하는 방법을 설명하지만 perl5 포터는 다운 스트림 사용자가 치명적인 범주의 선택을 변경할 수있는 방법이 없기 때문에 특히 다른 사람이 사용할 라이브러리 코드에 대한 위험을 이해하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">다음은 비트 벡터에서 설정된 비트 수를 효율적으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b85e86d2a59836c1bf602fd66fd49161e113bc9d" translate="yes" xml:space="preserve">
          <source>The following encodings are always available.</source>
          <target state="translated">다음 인코딩은 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb10534c1168ba80ae676bc74fad8ea1b177125" translate="yes" xml:space="preserve">
          <source>The following encodings are not supported as yet; some because they are rarely used, some because of technical difficulties. They may be supported by external modules via CPAN in the future, however.</source>
          <target state="translated">다음 인코딩은 아직 지원되지 않습니다. 일부는 거의 사용되지 않기 때문에 일부는 기술적 인 어려움으로 인해 발생합니다. 그러나 향후 CPAN을 통해 외부 모듈에서 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">다음 항목은 libnet 패키지에서 설치 및 테스트 중에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">다음 환경 변수는 Perl에만 해당되지 않습니다 . 데이터에 대한 애플리케이션의 의견을 제어하기위한 표준화 된 (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; 메소드의 일부입니다. Windows는 POSIX가 아니지만 Perl은 다음과 같이 설명합니다. 환경 변수에 의해 주어진 로케일이 유효하지 않으면, Perl은 우선 순위가 낮은 다음 로케일을 시도합니다. 유효하지 않은 경우 Windows에서 시스템 기본 로케일이 시도됩니다. 다른 모든 방법이 실패하면 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 로캘이 사용됩니다. 그래도 작동하지 않으면 무언가가 잘못되었지만 Perl은 로케일 설정에 관계없이 앞서 나 가려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">다음과 같은 동등성 ( &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; 가정 )</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">다음 오류 처리 메커니즘은 실험적인 것으로 간주되며 사용자의 보류중인 피드백에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31f04627eff0a8273cc4b4ecad29c912ce9d0e0e" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is consistent throughout all code paths EXCEPT in cases where the ROOT node is nonexistent. In version 2.11 the maintainers attempted to rectify this inconsistency but too many downstream modules encountered problems. In such case, if you require root node evaluation or error checking prior to calling &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt;, you should take additional precautions.</source>
          <target state="translated">다음 오류 처리 메커니즘은 ROOT 노드가 존재하지 않는 경우를 제외하고 모든 코드 경로에서 일관됩니다. 버전 2.11에서 유지 관리자는 이러한 불일치를 수정하려고 시도했지만 너무 많은 다운 스트림 모듈에 문제가 발생했습니다. 이 경우 &lt;code&gt;make_path&lt;/code&gt; 또는 &lt;code&gt;remove_tree&lt;/code&gt; 를 호출하기 전에 루트 노드 평가 또는 오류 검사가 필요한 경우 추가 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;_LONG_DOUBLE&lt;/code&gt; 의 Cygwin &lt;code&gt;#define&lt;/code&gt; 으로 인해 다음 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="21e6156937fd6a5960b9a95ea9a5b12a0208719f" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt;:</source>
          <target state="translated">다음 오류 때문에 Cygwin에서 발생 &lt;code&gt;#define&lt;/code&gt; 의 &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c8339d5177634294fee1f0a35f0053c9114caf8" translate="yes" xml:space="preserve">
          <source>The following errors were encountered while parsing the POD:</source>
          <target state="translated">POD를 구문 분석하는 동안 다음 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e6803ff3ff7c0a56cc9e903a6a90daace782e458" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations whose delimiters aren't single quotes (&lt;code&gt;&quot;'&quot;&lt;/code&gt;).</source>
          <target state="translated">다음 이스케이프 시퀀스는 보간하는 구문과 구분 기호가 작은 따옴표 ( &lt;code&gt;&quot;'&quot;&lt;/code&gt; ) 가 아닌 음역에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">보간하는 구문과 음역에서 다음 이스케이프 시퀀스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">다음 이스케이프 시퀀스는 음역에서는 보간하지 않는 구성에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">다음 예 는 &lt;code&gt;expect&lt;/code&gt; 대신 사용될 수있는 &lt;code&gt;eexpect&lt;/code&gt; 를 제외하고 지원되는 모든 키워드 및 구조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">다음 예제는 패턴에서 가능한 일치하는 모든 문자열을 계산합니다 (실제로 일치하지는 않음).</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">다음 예는 &lt;code&gt;SIGHUP&lt;/code&gt; 신호가 수신 될 때마다 자체 재시작되는 간단한 데몬을 구현합니다 . 실제 코드는 서브 루틴 &lt;code&gt;code()&lt;/code&gt; 에 있으며 디버깅 정보를 인쇄하여 작동한다는 것을 보여줍니다. 실제 코드로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="72ef6e9fa58ad7d92fd5d070a5b1ff44ddb10726" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt;, which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">다음 예제는 &lt;code&gt;SIGHUP&lt;/code&gt; 신호가 수신 될 때마다 자동으로 다시 시작되는 간단한 데몬을 구현합니다 . 실제 코드는 서브 루틴 &lt;code&gt;code()&lt;/code&gt; 에 위치하며, 작동 여부를 보여주기 위해 일부 디버깅 정보를 인쇄합니다. 실제 코드로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">다음 예제는 rpcb_gettime () 함수의 변형을 보여줍니다. 이 함수는 timep 변수를 출력 변수로만 사용하며 초기 내용은 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">다음 예는 PREINIT 후 입력 매개 변수 &lt;code&gt;timep&lt;/code&gt; 를 늦게 평가 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">다음 예제는 이 함수에 대한 별명 &lt;code&gt;FOO::gettime()&lt;/code&gt; 및 &lt;code&gt;BAR::getit()&lt;/code&gt; 를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">다음 예제는 &lt;code&gt;langinfo()&lt;/code&gt; 함수 자체와 &lt;code&gt;langinfo()&lt;/code&gt; 대한 인수로 사용할 세 개의 상수를 가져옵니다. 약식 첫 요일에 대한 상수 (일요일 번호는 일요일 = 1에서 시작 함) 및 긍정에 대한 두 개의 상수 현재 로케일의 예 / 아니오에 대한 부정적인 답변.</target>
        </trans-unit>
        <trans-unit id="fa3452b428040cf2c56efc56c05eb14116e2d423" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt;: a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">다음 예제는 &lt;code&gt;langinfo()&lt;/code&gt; 함수 자체와 &lt;code&gt;langinfo()&lt;/code&gt; 대한 인수로 사용할 세 개의 상수를 가져옵니다. 축약 된주의 첫 번째 요일에 대한 상수 (번호는 일요일 = 1부터 시작) 및 긍정에 대한 두 개의 상수 현재 로케일의 예 / 아니오 질문에 대한 부정적인 답변.</target>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">다음 예는 langinfo () 함수 자체와 langinfo ()에 대한 인수로 사용할 세 개의 상수를 가져옵니다. 약식 첫 요일에 대한 상수 (일요일 번호는 일요일 = 1에서 시작) 및 긍정에 대한 두 개의 상수 현재 로케일의 예 / 아니오에 대한 부정적인 답변.</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">다음 예제는 XS 코드를 시작하고 RPC라는 패키지에 모든 기능을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">다음 예제 는 모두이 모듈에서 다른 목록 축소 기능을 구현하기 &lt;code&gt;reduce&lt;/code&gt; 사용 하는 방법을 보여줍니다 . (실제로는 이와 같이 구현되지 않고 개별 C 함수에서보다 효율적인 방식으로 구현됩니다).</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">다음 예제는 동일하지만 코드가 복잡한 유형 맵을 사용하는 경우 첫 번째 예제가 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">다음 예제는 가정</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">다음 예제는 모든 작업을 기념비적 인 작업으로 보여 주려고하지 않으며 솔직히이 맨 페이지가 Perl의 내부 문서가되기를 원하지 않습니다. 이 예제는 원시 Perl 데이터 유형의 몇 가지 기본 사항을 보여 주며 대부분의 결정된 사람들이 길을 가기에 충분합니다. 가이드 와이어 나 안전망도없고 뾰족한 길도 없으므로이 시점부터 혼자 여행 할 수 있도록 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="6687cc4c1adb4921b8b4b2318949d366c6deb7ae" translate="yes" xml:space="preserve">
          <source>The following examples show standard binary, octal, decimal, and hexadecimal conversion. All examples return 250.</source>
          <target state="translated">다음 예제는 표준 2 진, 8 진, 10 진 및 16 진 변환을 보여줍니다. 모든 예는 250을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">다음 확장 계층은 perl과 함께 번들로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="162be8fe3d219b0d9c97c2e524d7220d440e0dd3" translate="yes" xml:space="preserve">
          <source>The following extra flags are added:</source>
          <target state="translated">다음과 같은 추가 플래그가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">실수와 복소수 모두에서 다음과 같은 추가 연산이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">다음과 같은 기능 번들을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">다음 파일은 런타임과 컴파일 타임에 약간의 오류를 유발할 것입니다.</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">다음과 같은 파일이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">다음 플래그 상수는 $ flags로 인식됩니다. OS가 제공하는 다른 플래그 상수가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">다음 플래그 상수는 $ hints 해시에서 인식됩니다. OS가 제공하는 다른 플래그 상수가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">csh 호환성을 위해 Perl 구현에 다음 플래그가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="50651d66e2238c03eee6171d8e3c138d824ff88d" translate="yes" xml:space="preserve">
          <source>The following flags and properties are for JSON::PP only. If you use any of these, you can't make your application run faster by replacing JSON::PP with JSON::XS. If you need these and also speed boost, you might want to try &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, a fork of JSON::XS by Reini Urban, which supports some of these (with a different set of incompatibilities). Most of these historical flags are only kept for backward compatibility, and should not be used in a new application.</source>
          <target state="translated">다음 플래그 및 속성은 JSON :: PP 전용입니다. 이들 중 하나를 사용하는 경우 JSON :: PP를 JSON :: XS로 대체하여 애플리케이션을 더 빠르게 실행할 수 없습니다. 이러한 기능과 속도 향상이 필요한 경우 Reini Urban의 JSON :: XS 포크 인 &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel :: JSON :: XS&lt;/a&gt; 를 사용해 볼 수 있습니다.이 중 일부는 서로 다른 비 호환성 세트를 지원합니다. 이러한 기록 플래그의 대부분은 이전 버전과의 호환성을 위해서만 유지되며 새 응용 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">다음 깃발은 좋을 것이지만 먼저 자신의 Augean 안정 마스터가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e731ee95c2996f14c508bcbd1c142f7cd0808c33" translate="yes" xml:space="preserve">
          <source>The following four convenience wrappers may be used to obtain one of the two values returned here. If both host and service names are required, this method is preferable to the following wrappers, because it will call &lt;code&gt;getnameinfo(3)&lt;/code&gt; only once.</source>
          <target state="translated">다음 네 가지 편의 래퍼를 사용하여 여기에 반환 된 두 값 중 하나를 얻을 수 있습니다. 호스트 및 서비스 이름이 모두 필요한 경우이 메서드는 &lt;code&gt;getnameinfo(3)&lt;/code&gt; 한 번만 호출하므로 다음 래퍼보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">다음 네 파일은 지금까지 설명한 모든 세부 정보를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 함수는 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV에 문자열을 복사합니다 . Perl이 문자열 길이를 계산할 수 있도록 length를 0으로 설정하십시오. &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="d572303a215881dcd48f5b462f35572b6b301a6c" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt;. Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 함수는 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV로 문자열을 복사합니다 . 길이를 0으로 설정하여 Perl이 문자열 길이를 계산하도록합니다. &lt;code&gt;classname&lt;/code&gt; 이 널이 아닌 경우 SV가 축복됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">다음 함수는 포인터 값을 복사합니다 (</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">다음 기능은 ODS-5 형식의 빌드 디스크에서 하드 링크가 활성화 된 64 비트 OpenVMS v8.2에서 빌드 된 Perls에서 사용할 수 있습니다. CRTL 지원은 기본적으로 OpenVMS v7.3-1부터 제공되며 더 나은 구성 지원으로이를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">다음 함수는 SV가 축복 된 객체에 대한 참조인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">다음 함수는 SV가 지정된 클래스에 축복이 있는지 테스트합니다. 상속 관계는 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">다음 함수는 SV가 지정된 클래스에서 파생되는지 테스트합니다. SV는 축복 된 객체에 대한 참조이거나 클래스 이름을 포함하는 문자열 일 수 있습니다. &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; 기능을 구현하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">다음 함수는 rv를 아직 업그레이드하지 않은 경우 참조로 업그레이드합니다. rv가 가리킬 새 SV를 만듭니다. &lt;code&gt;classname&lt;/code&gt; 이 널이 아닌 경우 SV는 지정된 클래스에 축복됩니다. SV가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">다음과 같은 기능</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">다음 함수는 모두 참조 값에서 유용한 활동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">다음 함수는 임시 파일 생성 시스템 호출의 mktemp () 제품군의 Perl 구현입니다.</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">64 비트 OpenVMS v8.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">64 비트 OpenVMS v8.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다. CRTL 지원은 기본적으로 OpenVMS v7.3-2부터 제공되며 더 나은 구성 지원으로이를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">VMS 7.2 이상에서 빌드 된 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">Dec C 5.2 이상으로 컴파일되고 VMS 7.0 이상을 실행하는 Perls에서 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">다음과 같은 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">다음 기능은 현재 문서화되어 있지 않습니다. 그중 하나를 사용하는 경우 문서를 작성하고 제출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">다음 기능은 &lt;code&gt;utf8::&lt;/code&gt; 패키지에서 Perl 코어 로 정의됩니다 . 이것들을 사용 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 을 사용할 필요는 없으며 실제로 UTF-8 소스 코드를 원하지 않는다면 말하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="04035437cedd81d97c7436275ce862e9db956a98" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;use utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">&lt;code&gt;utf8::&lt;/code&gt; 패키지는 Perl 코어에 의해 다음 함수가 정의됩니다 . 이를 &lt;code&gt;use utf8&lt;/code&gt; 을 사용 한다고 말할 필요는 없으며 실제로 UTF-8 소스 코드를 원하지 않는 한 실제로 그렇게 말해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Filter::Util::Call&lt;/code&gt; 의해 다음 기능이 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="880d841885ac667bfdecc26d11ccfd01c2ab96a8" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Filter::Util::Call&lt;/code&gt; 은 다음 함수를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">다음 기능이 기본적으로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">이 모듈에서 다음 기능을 내 보냅니다. 따라서 이러한 기능 (하지 방법) 참고주세요 &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; 암시 첫 번째 인수를 취할.</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">이 모듈은 &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; 및 &lt;code&gt;cond_broadcast&lt;/code&gt; 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8a286ac22b6e657ba87cab3b6eff4036bd887933" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt;, &lt;code&gt;shared_clone&lt;/code&gt;, &lt;code&gt;is_shared&lt;/code&gt;, &lt;code&gt;cond_wait&lt;/code&gt;, &lt;code&gt;cond_timedwait&lt;/code&gt;, &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">이 모듈은 &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; 및 &lt;code&gt;cond_broadcast&lt;/code&gt; 함수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">다음 기능은 요청에 의해서만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="6ff004aea51ff452f5a6a3680250ec66d08e006e" translate="yes" xml:space="preserve">
          <source>The following functions are not considered to be part of the public interface. They are documented here for the benefit of future maintainers of this module.</source>
          <target state="translated">다음 기능은 공용 인터페이스의 일부로 간주되지 않습니다. 이 모듈의 향후 유지 관리자를 위해 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">다음 함수는 이제 FastCalc.xs에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">다음 기능은 &lt;code&gt;Digest::MD5&lt;/code&gt; 모듈 에서 제공 합니다. 기본적으로 이러한 기능 중 어느 것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">다음과 같은 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">다음과 같은 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">이 모듈에서 다음 기능을 가져올 수 있습니다. 기본적으로 함수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">다음 함수는 문자열이 해당 정규화 형식인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">다음 함수는 Perl 값 목록과 구조를 나타내는 팩형 이진 문자열 사이를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">다음 함수는 공개 API의 일부로 플래그가 지정되었지만 현재 문서화되어 있지 않습니다. 인터페이스는 변경 될 수 있으므로 위험에 따라 사용하십시오. 이 문서에 나열되지 않은 기능은 공용으로 사용되지 않으며 어떤 상황에서도 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="824636764a16367a90dfdeffbf74adccac69c5cb" translate="yes" xml:space="preserve">
          <source>The following functions in the &lt;code&gt;POSIX&lt;/code&gt; module are no longer available: &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, and &lt;code&gt;isxdigit&lt;/code&gt;. The functions are buggy and don't work on UTF-8 encoded strings. See their entries in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;POSIX&lt;/code&gt; 모듈 의 다음 함수 는 더 이상 사용할 수 없습니다 : &lt;code&gt;isalnum&lt;/code&gt; , &lt;code&gt;isalpha&lt;/code&gt; , &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;isgraph&lt;/code&gt; , &lt;code&gt;islower&lt;/code&gt; , &lt;code&gt;isprint&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; , &lt;code&gt;isspace&lt;/code&gt; , &lt;code&gt;isupper&lt;/code&gt; , &lt;code&gt;isxdigit&lt;/code&gt; . 함수는 버그가 있으며 UTF-8로 인코딩 된 문자열에서 작동하지 않습니다. 자세한 내용은 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 항목 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">Perl 사본에 내장 된 소켓 지원 유형에 따라 다음 기능이 구현되거나 구현되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">다음 함수는 &lt;code&gt;$_&lt;/code&gt; 를 기본 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">다음 함수는 VMS 포트에서 구현되지 않았으며이를 호출하면 치명적 오류 (보통) 또는 정의되지 않은 동작 (드물게 희망)이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">다음 함수는 모두 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">다음과 같은 전역 변수가 경기장과 관련되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">다음은 벤치 마크 객체 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">다음 정보는 gcc 버전 2에 적용됩니다. gcc 버전 3에 맞게 적절하게 업데이트하는 자원 봉사자에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">기존 API와의 호환성을 위해 다음 인터페이스가 제공됩니다. 그것들은 새로운 코드에서 사용되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">다음은 포드 처리와 관련된 기타 요구 사항 및 제안의 긴 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">다음은이 C ++ 예제에 사용할 수있는 유형 맵의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">다음은 Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;의 오래된 c2ph.doc 문서입니다. 날짜 : 25 Jul 91 08:10:21 GMT</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">다음은 특정 버전의 Perl &lt;a href=&quot;deprecate&quot;&gt;이상으로&lt;/a&gt; 코어 모듈 을 폐기 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">콜백에 다음 키가 허용되었습니다. 이 키는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">다음 키는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">옵션 해시에서 다음 키가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="938c23249f0abe69d61c5caeb8c241a3b1c97b48" translate="yes" xml:space="preserve">
          <source>The following keys are valid, but only &lt;code&gt;version&lt;/code&gt; is required.</source>
          <target state="translated">다음 키가 유효하지만 &lt;code&gt;version&lt;/code&gt; 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">해시 참조 $ CPAN :: Config의 다음 키가 현재 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">현재 다음 레이어가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62e448414706bf58b56c68adcd155be3caa2f9f" translate="yes" xml:space="preserve">
          <source>The following license strings are also valid and indicate other licensing not described above:</source>
          <target state="translated">다음 라이센스 문자열도 유효하며 위에 설명되지 않은 다른 라이센스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Map&lt;/a&gt; 의 testsuite에서 다음 행을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">다음 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f188bcdc507d79e65b8c87878e9261e514ba50b4" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level</source>
          <target state="translated">정규식에 대한 다음 유니 코드 지원 기능 목록은 현재 핵심 Perl에서 직접 지원하는 모든 기능을 설명합니다. &quot;레벨</target>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">다음 정규식에 대한 유니 코드 지원 기능 목록은 코어 Perl에서 현재 직접 지원하는 모든 기능을 설명합니다. &quot;레벨 N&quot;및 섹션 번호는 2008 년 8 월부터 유니 코드 기술 표준 # 18, &quot;유니 코드 정규 표현식&quot;, 버전 13을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd9860b919a8b832481067980e3c3a381ec06f0c" translate="yes" xml:space="preserve">
          <source>The following list of license strings are valid:</source>
          <target state="translated">다음 라이센스 문자열 목록이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">해시 항목의 내용에 액세스하려면 항상 다음 매크로를 사용해야합니다. 이 매크로에 대한 인수는 두 번 이상 평가 될 수 있으므로 간단한 변수 여야합니다. 이 매크로에 대한 자세한 설명은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">다음 메소드는 모두 부울 값을 리턴하며 해당 서브 클래스에서 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">모든 &lt;code&gt;Digest::&lt;/code&gt; 모듈에 대해 다음 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">다음과 같은 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab4dd7b2f4575f0fcc3274141eab6c5a7ca9278" translate="yes" xml:space="preserve">
          <source>The following methods are mandatory: _new(), _str(), _add(), and _sub(). However, computations will be very slow without _mul() and _div().</source>
          <target state="translated">다음 메소드는 필수입니다. _new (), _str (), _add () 및 _sub (). 그러나 _mul () 및 _div () 없이는 계산이 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="translated">다음 방법은 파일 핸들별로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="translated">다음 메소드는 &lt;code&gt;TAP::Harness&lt;/code&gt; 를 서브 클래스하려는 경우 대체 할 수있는 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="6e9f03dd5d9f58ae4081f60a8239d90f2810d056" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt;.</source>
          <target state="translated">다음 메서드는 &lt;code&gt;TAP::Harness&lt;/code&gt; 하위 클래스를 지정하려는 경우 재정의 할 수있는 메서드 입니다.</target>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="translated">다음 방법은 선택 사항이며 기본 lib에 빠른 방법이있는 경우 정의 할 수 있습니다. 정의되지 않은 경우 Math :: BigInt는 순수한 Perl (따라서 느린) 폴백 루틴을 사용하여 다음을 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="translated">이 모듈에는 다음과 같은 방법이 제공됩니다. 각각은 객체 자체에 대한 참조를 암시 적 첫 번째 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="translated">다음과 같은 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="translated">2 이상의 API 버전에는 다음 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">다음 메소드는 perl에 내장 된 디렉토리 관련 기능에 대한 랩퍼입니다 (후행 'dir'은 이름에서 제거되었습니다). 이 기능에 대한 자세한 내용은 &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ded7f0c3574ed832e686f908708c74d7bfabfc4b" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">다음 메소드는 perl에 내장 된 디렉토리 관련 함수에 대한 래퍼입니다 (후행 'dir'은 이름에서 제거됨). 이러한 함수에 대한 자세한 내용은 &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="translated">다음 방법을 사용하여 대기열의 어느 곳에서나 항목을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="translated">다음 두 방법을 사용하여 두 원격 서버간에 파일을 전송하여이 두 서버를 서로 직접 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="translated">다음 메소드는 호출 방식에 따라 다른 결과를 리턴 할 수 있습니다. 사용자가 명시 적으로 &lt;code&gt;pasv&lt;/code&gt; 또는 &lt;code&gt;port&lt;/code&gt; 메소드 중 하나를 호출하면 이 메소드는</target>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="translated">그런 다음 위의 생성자가 반환 한 구획 객체에서 다음 방법을 사용할 수 있습니다. 개체 인수는 각 경우에 암시 적입니다.</target>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="translated">다음 방법은 FIFO를 기준으로 큐를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1107701eeb6d8dce0fd7fc1f42599acf6178ec38" translate="yes" xml:space="preserve">
          <source>The following methods implement this incremental parser.</source>
          <target state="translated">다음 메서드는이 증분 파서를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="translated">Math :: BigInt v1.70 이상에서 사용할 수 있도록 다음 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="280d5e97299a977b6fb2506b08e4d295925aa675" translate="yes" xml:space="preserve">
          <source>The following methods return a single value, which is the value for the corresponding entry in the distmeta structure. Values should be either undef or strings.</source>
          <target state="translated">다음 메서드는 distmeta 구조의 해당 항목에 대한 값인 단일 값을 반환합니다. 값은 undef 또는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e47bdf0bfe9cf16bdf842c1c20e389188ee7a3a8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they always hands up their work:</source>
          <target state="translated">다음 방법은 무조건 자체적으로 업그레이드됩니다. 즉, 업그레이드가 적용되면 항상 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="translated">다음 방법은 무조건 업그레이드됩니다. 즉, 업그레이드가 적용되는 경우 항상 작업을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="4d85840c9544f4d1a9475cb2562273ab62746e95" translate="yes" xml:space="preserve">
          <source>The following methods, while usable from anywhere, are primarily intended for developers wishing to subclass &lt;code&gt;autodie::exception&lt;/code&gt;, write code that registers custom error messages, or otherwise work closely with the &lt;code&gt;autodie::exception&lt;/code&gt; model.</source>
          <target state="translated">다음 메서드는 어디에서나 사용할 수 있지만 주로 &lt;code&gt;autodie::exception&lt;/code&gt; 을 하위 클래스 화 하거나 사용자 지정 오류 메시지를 등록하는 코드를 작성하거나 &lt;code&gt;autodie::exception&lt;/code&gt; 모델 과 밀접하게 작업 하려는 개발자를위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="translated">다음 모듈은 현재 bigint에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="translated">다음 모듈은 현재 bignum에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="translated">다음 이름은 Perl에 특별한 의미가 있습니다. 대부분의 문장 부호 이름에는 적절한 니모닉 또는 쉘의 유사체가 있습니다. 그럼에도 불구하고 긴 변수 이름을 사용하려면 다음과 같이 말하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">다음 옵션은 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 명령 에서 발생하는 영향에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="4a331658e3e1d7b8de900a2e68b72b832b1d4100" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">다음 옵션은 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 명령 에서 발생하는 작업에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">다음과 같은 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="translated">다음 옵션은 쌍으로 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="translated">다음 옵션은 기본 텍스트 포맷터로 전달됩니다. 자세한 내용은이 모듈의 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="translated">다음 옵션이 지원됩니다 : 중심점, 날짜, 고정식, 고정형, 고정형, 고정형, 따옴표, 릴리스, 섹션</target>
        </trans-unit>
        <trans-unit id="7fa87a7b90e6843371b98a42bf443c041138aacf" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function &lt;code&gt;foo()&lt;/code&gt; which may contain balanced parentheses as the argument.</source>
          <target state="translated">다음 패턴 은 균형 잡힌 괄호를 인수로 포함 할 수 있는 함수 &lt;code&gt;foo()&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="translated">다음 패턴은 인수로 균형 괄호를 포함 할 수있는 foo () 함수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="translated">다음 패턴은 괄호로 묶은 그룹과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="22ee5be8d1198dc109b222871c61596812e4d6af" translate="yes" xml:space="preserve">
          <source>The following people have all contributed to this document in some way, even if only for review.</source>
          <target state="translated">다음 사람들은 검토 용 일지라도 어떤 식 으로든이 문서에 모두 기여했습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="translated">다음 플랫폼은 &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src에&lt;/a&gt; 있는 표준 소스 코드 배포에서 Perl 5.12 (릴리스 릴리스 날짜 기준)를 빌드하는 것으로 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6907367840204c62b96dad2c2b4daa026466da81" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; know of any trouble.</source>
          <target state="translated">다음 플랫폼은 과거에 소스 (5.005_03 이하)에서 Perl을 빌드하는 것으로 알려져 있지만 하드웨어 / 소프트웨어 플랫폼이 드물거나 그렇지 않기 때문에 현재 릴리스에 대한 상태를 확인할 수 없었습니다. 이러한 플랫폼 또는 둘 다에서 활성 챔피언이 없습니다. 하지만 예전에는 작동 했으므로 계속해서 컴파일하고 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues에&lt;/a&gt; 문제가 있음을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="translated">다음 플랫폼은 과거 (5.005_03 이전) 소스에서 Perl을 빌드하는 것으로 알려져 있지만 하드웨어 / 소프트웨어 플랫폼이 드물거나 우리가 현재 버전으로 인해 현재 릴리스의 상태를 확인할 수 없었습니다. 이 플랫폼 또는 둘 다에서 적극적인 챔피언이 없습니다. 그들은 예전에는 일을 했으므로 계속해서 컴파일을 시도하고 perlbug@perl.org에 문제를 일으킨다.</target>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="translated">다음 플랫폼에는 &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html을&lt;/a&gt; 통해 사용 가능한 바이너리 만 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="translated">다음 플랫폼에는 &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; 를 통해 사용할 수있는 자체 소스 코드 배포 및 바이너리가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="translated">다음 플랫폼은 이전 버전의 Perl에서 지원되었지만 공식적으로 5.12부터 Perl의 소스 코드에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="translated">다음 플랫폼은 이전 버전의 Perl에서 지원되었지만 공식적으로 5.20부터 Perl의 소스 코드에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="translated">다음 플랫폼은 5.10까지 지원되었습니다. 그들은 여전히 ​​5.12에서 작동했지만 지원 코드는 5.14에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="translated">다음 플랫폼은 이전 릴리스 (5.6 및 5.7)와 함께 작동했지만 5.8.0 릴리스의 경우 시간에 맞춰 수정하거나 테스트하지 않았습니다. 이 중 다수가 5.8.0에서 제대로 작동 할 가능성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="translated">다음 pragma는 정의되어 있으며 자체 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="translated">다음과 같은 기본 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="dcbd438c6b1158dced15757e5785975c49cf130b" translate="yes" xml:space="preserve">
          <source>The following probably doesn't do what you expect:</source>
          <target state="translated">다음은 예상 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="translated">Haiku 개정판 28311에서는 다음과 같은 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="translated">다음은 파일 핸들에서 PerlIO 레이어 의 &lt;b&gt;이름&lt;/b&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="translated">다음 개정판이 지원됩니다. 기본값은 30입니다.</target>
        </trans-unit>
        <trans-unit id="4a818dfcd5c08f13e17285de1b0c0c9fdcdbac96" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 36.</source>
          <target state="translated">다음 버전이 지원됩니다. 기본값은 36입니다.</target>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="translated">다음 루틴을 가져 오도록 특별히 요청하면 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="translated">벤치 마크 모듈을 사용하는 경우 다음 루틴이 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="translated">다음 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="translated">&lt;code&gt;minus()&lt;/code&gt; 의 다음 샘플 구현 ( &lt;code&gt;Number&lt;/code&gt; 객체는 단순히 스칼라에 대한 참조로 축복받은 것으로 가정 )은 호출 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">다음 시퀀스 ( &lt;code&gt;\N&lt;/code&gt; 제외 )는 문자 클래스 내에서 또는 문자 클래스없이 작동합니다. 처음 6 개는 로캘을 인식하고 모두 유니 코드를 인식합니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d35a09553da6f576d42c5fa2490f9e35aa7f113" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt;) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">다음 시퀀스 ( &lt;code&gt;\N&lt;/code&gt; 제외 )는 문자 클래스 내에서 또는없이 작동합니다. 처음 6 개는 로케일을 인식하고 모두 유니 코드를 인식합니다. 자세한 내용은 &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9540b293755f2d5620dc9acad2cd13cee9e2ef96" translate="yes" xml:space="preserve">
          <source>The following set of functions all apply a given block of code to a list of values.</source>
          <target state="translated">다음 함수 세트는 모두 주어진 코드 블록을 값 목록에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="translated">다음 함수 세트는 모두 목록을 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="adf371bb48a28981de1ae9bebf30e1218065293c" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">&lt;a href=&quot;List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt; 에서 영감을 얻은 다음 함수 세트 는 짝수 크기의 쌍 목록을 사용합니다. 쌍은 해시의 키 / 값 연결이거나 값 목록 일 수 있습니다. 이 함수는 모두 쌍의 원래 순서를 유지하며 동일한 &quot;키&quot;값을 가진 여러 쌍으로 혼동되지 않으며 각 쌍의 첫 번째가 일반 문자열 일 필요도 없습니다.</target>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt; 에서 영감을 얻은 다음 함수 세트 는 짝수 크기의 쌍 목록을 사용합니다. 쌍은 해시의 키 / 값 연결 또는 값 목록 일 수 있습니다. 이 함수는 모두 원래 쌍의 순서를 유지하며 동일한 &quot;키&quot;값을 가진 여러 쌍으로 혼동되지 않으며 각 쌍의 첫 번째 문자열이 일반 문자열 일 필요도 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="translated">히스토리, 중단 점, 조치, 디버거 옵션 및 Perl 명령 행 옵션 &lt;b&gt;-w&lt;/b&gt; , &lt;b&gt;-I&lt;/b&gt; 및 &lt;b&gt;-e&lt;/b&gt; 설정이 현재 보존 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="translated">다음은 음의 인덱싱을 사용하여 나중에 사용하기 위해 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 구문 안에 재귀 패턴을 더 쉽게 포함시키는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9b2c5c0c58ad6eab6d4bc5753a307f626a410d1e" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;qr//&lt;/code&gt; construct for later use:</source>
          <target state="translated">다음은 네거티브 인덱싱을 사용하여 나중에 사용하기 위해 &lt;code&gt;qr//&lt;/code&gt; 구문 내부에 재귀 패턴을 더 쉽게 포함 할 수있는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="translated">다음은 해시에 대한 원시 참조 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="translated">다음과 같은 단일 진술 :</target>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="translated">다음과 같은 표준 정량자가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="translated">다음 구조는 perl의 정규식 엔진 에서 &lt;code&gt;pprivate&lt;/code&gt; 구조로 사용됩니다 . 펄에만 적용되기 때문에 다른 엔진 구현에 대한 호기심의 가치에 지나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="translated">이 모듈이로드되면 다음 서브 루틴을 일반적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39addea572ccdb746968405797f7ed6ce1f71c76" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">다음 하위 섹션에서는 기본 로케일 범주를 설명합니다. 이 외에도 일부 조합 범주에서는 한 번에 둘 이상의 기본 범주를 조작 할 수 있습니다. 이에 대한 논의는 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;환경&quot;&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">다음 하위 섹션에서는 기본 로캘 범주에 대해 설명합니다. 이 외에도 일부 조합 범주를 사용하면 한 번에 둘 이상의 기본 범주를 조작 할 수 있습니다. 이에 대한 설명은 &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dc5293bb808b42d229adc04604a47fcedbdefbc" translate="yes" xml:space="preserve">
          <source>The following symbolic constants for SHOWWINDOW are available (but not exported) from the Win32 module: SW_HIDE, SW_SHOWNORMAL, SW_SHOWMINIMIZED, SW_SHOWMAXIMIZED and SW_SHOWNOACTIVATE.</source>
          <target state="translated">다음 SHOWWINDOW 기호 상수는 Win32 모듈에서 사용할 수 있지만 내보낼 수는 없습니다 : SW_HIDE, SW_SHOWNORMAL, SW_SHOWMINIMIZED, SW_SHOWMAXIMIZED 및 SW_SHOWNOACTIVATE.</target>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="translated">다음 시스템에는 PA-RISC 1.1 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="translated">다음 시스템에는 PA-RISC 1.0 칩이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="translated">다음 표는 유니 코드 6.3에서 &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\h&lt;/code&gt; 및 &lt;code&gt;\v&lt;/code&gt; 와 일치하는 전체 문자 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="translated">다음 표는 유니 코드 3.2에서 가져온 것입니다.</target>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="translated">다음 표는 나눗셈의 결과와 나머지를 보여 주므로 위의 방정식이 적용됩니다. 일부 &quot;일반적인&quot;사례는 다음과 같은 추론을보다 명확하게 보여주기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="translated">다음 표는 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 설정에 따라 UNIX 및 DOS와 같은 플랫폼의 기본 계층을 요약합니다. .</target>
        </trans-unit>
        <trans-unit id="54678528be44b1241458a1af21612f2f6f5f0793" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt;:</source>
          <target state="translated">다음 표는 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 설정에 따라 UNIX 계열 및 DOS 계열 플랫폼의 기본 계층을 요약 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="translated">다음 표에는 C0 컨트롤 (0..31), ASCII 그래픽 (32..7e), 삭제 (7f), C1 컨트롤 (80..9f) 및 Latin- 1 (일명 ISO 8859-1) (a0..ff). ASCII에 대한 라틴어 1 확장자의 테이블 이름에는 대략적으로 해당하는 문자 이름이 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="translated">QNX 6.2.0에서 Perl 5.8.1에 대해 다음 테스트가 여전히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="translated">다음 테스트는 QNX4에서 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 세 함수는 정수, 부호없는 정수 또는 double을 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV로 복사합니다 . &lt;code&gt;classname&lt;/code&gt; 이 null이 아닌 경우 SV는 축복 입니다.</target>
        </trans-unit>
        <trans-unit id="9965745aff45be1a5967becd8cef0c33f9e335d4" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt;. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">다음 세 가지 함수는 정수, 부호없는 정수 또는 double을 참조가 &lt;code&gt;rv&lt;/code&gt; 인 SV로 복사합니다 . &lt;code&gt;classname&lt;/code&gt; 이 널이 아닌 경우 SV가 축복됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="translated">다음 세 가지 매크로는 처음에 메모리를 할당하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="translated">다음 두 호출은 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="translated">다음과 같은 유형의 변경은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="translated">다음 유형의 변경은 아래에 명시된 &quot;허용 할 수없는&quot;범주에 속하지 않는 한 허용 가능한 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="translated">&lt;code&gt;config()&lt;/code&gt; 를 전달하여 다음 값을 설정할 수 있습니다 에 해시에 대한 참조를 .</target>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="translated">다음 변수는 B :: Concise에 의해 정의됩니다. 그것들이 스타일로 사용될 때, 그들의 각각의 값은 각각의 opcode의 렌더링에 연결된다.</target>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="translated">다음 변수를 설정 &lt;b&gt;해야합니다&lt;/b&gt;-&amp;gt; new 생성자를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="translated">다음 변수는 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="translated">다음과 같이 구현되었습니다</target>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="translated">다음은 파일 시스템에서 허용되는 가장 긴 경로 이름의 최대 길이를 결정합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
