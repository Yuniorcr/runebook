<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="65f4de99dee3e085c7a32fb60bb9eaf5617a70cd" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value can be used as an indirect filehandle, usually the real filehandle name or an autovivified handle.</source>
          <target state="translated">FILEHANDLE은 값이 간접 파일 핸들, 일반적으로 실제 파일 핸들 이름 또는 자동 활성화 핸들로 사용될 수있는 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6788548cba81bf001baaa9f81e8e517a13289b" translate="yes" xml:space="preserve">
          <source>FILEHANDLE may be an expression whose value gives the name of the actual filehandle. Thus:</source>
          <target state="translated">FILEHANDLE은 값이 실제 파일 핸들의 이름을 제공하는 표현식 일 수 있습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="9fb4f1d17ef878fbfbe96076658397ad86bd5264" translate="yes" xml:space="preserve">
          <source>FILES</source>
          <target state="translated">FILES</target>
        </trans-unit>
        <trans-unit id="57b2849536a1efa1f62fdf190cadb1a10c11e6b6" translate="yes" xml:space="preserve">
          <source>FILL</source>
          <target state="translated">FILL</target>
        </trans-unit>
        <trans-unit id="9632a4abb88bdcc736407e7934b81d79fbb78781" translate="yes" xml:space="preserve">
          <source>FINDING YOUR WAY AROUND</source>
          <target state="translated">주변 길 찾기</target>
        </trans-unit>
        <trans-unit id="059c8321d5ceafe9f97e631f972d839dbaf5b1d5" translate="yes" xml:space="preserve">
          <source>FIONREAD requires a filehandle connected to a stream, meaning that sockets, pipes, and tty devices work, but</source>
          <target state="translated">FIONREAD에는 스트림에 연결된 파일 핸들이 필요합니다. 즉 소켓, 파이프 및 tty 장치는 작동하지만</target>
        </trans-unit>
        <trans-unit id="f1c14024d456e253b8073d3a89752d6ea8200326" translate="yes" xml:space="preserve">
          <source>FIRSTKEY and NEXTKEY methods go through the keys which were already read, not all the possible keys of the hash.</source>
          <target state="translated">FIRSTKEY 및 NEXTKEY 메서드는 해시의 가능한 모든 키가 아니라 이미 읽은 키를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="473f2fe7fb87993b779c2cc268a4bc8822c0f618" translate="yes" xml:space="preserve">
          <source>FIRSTKEY is always called in scalar context and it should just return the first key. values(), and each() in list context, will call FETCH for the returned keys.</source>
          <target state="translated">FIRSTKEY는 항상 스칼라 컨텍스트에서 호출되며 첫 번째 키만 반환해야합니다. 목록 컨텍스트의 values ​​() 및 each ()는 반환 된 키에 대해 FETCH를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="60763b7739ea9775822fa821fd5c68448c0e057f" translate="yes" xml:space="preserve">
          <source>FIRSTKEY this</source>
          <target state="translated">FIRSTKEY이</target>
        </trans-unit>
        <trans-unit id="e93a0a6500fe82ad7af1d937eb87befdc270cb77" translate="yes" xml:space="preserve">
          <source>FIRST_MAKEFILE</source>
          <target state="translated">FIRST_MAKEFILE</target>
        </trans-unit>
        <trans-unit id="df2badbb417734bff12c2cd1ce6852a857e8b49b" translate="yes" xml:space="preserve">
          <source>FLAG VALUES</source>
          <target state="translated">플래그 값</target>
        </trans-unit>
        <trans-unit id="ae5c9fb3c111122e22c6f658c74f989e6c74e9ee" translate="yes" xml:space="preserve">
          <source>FLAGS</source>
          <target state="translated">FLAGS</target>
        </trans-unit>
        <trans-unit id="fc54423d9b2090ad55b78aa71f44bd7d687a3b90" translate="yes" xml:space="preserve">
          <source>FLAGS FOR JSON::PP ONLY</source>
          <target state="translated">JSON :: PP 용 플래그 만 해당</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="73449ef74937cb8a715e6e9b0bcd4bb4e19f070f" translate="yes" xml:space="preserve">
          <source>FLOATING-POINT ENVIRONMENT</source>
          <target state="translated">부동 소수점 환경</target>
        </trans-unit>
        <trans-unit id="f41751eb3ffc92663591f0374ca80b48bbc39b5b" translate="yes" xml:space="preserve">
          <source>FMTEYEWTK</source>
          <target state="translated">FMTEYEWTK</target>
        </trans-unit>
        <trans-unit id="831a66be6f43bd545fdc4414e1f4b885b9c05bb7" translate="yes" xml:space="preserve">
          <source>FMT_GV</source>
          <target state="translated">FMT_GV</target>
        </trans-unit>
        <trans-unit id="15135a59c6851b66ea7afd388b7d51c193aa382b" translate="yes" xml:space="preserve">
          <source>FMT_NAME</source>
          <target state="translated">FMT_NAME</target>
        </trans-unit>
        <trans-unit id="5ebe3bdc53012abb0f99fe6d21ef451db1b6f344" translate="yes" xml:space="preserve">
          <source>FOO()</source>
          <target state="translated">FOO()</target>
        </trans-unit>
        <trans-unit id="29f93d09c4164c56d0a4360f7af9f4da5d683665" translate="yes" xml:space="preserve">
          <source>FOOTNOTES</source>
          <target state="translated">FOOTNOTES</target>
        </trans-unit>
        <trans-unit id="a27448e44064a3e71d47db864ec6590331ae24db" translate="yes" xml:space="preserve">
          <source>FOR MODULE AUTHORS</source>
          <target state="translated">모듈 저자</target>
        </trans-unit>
        <trans-unit id="49b71cfc6dbaeaf2d7271b35e698bcb55b689647" translate="yes" xml:space="preserve">
          <source>FORM</source>
          <target state="translated">FORM</target>
        </trans-unit>
        <trans-unit id="3f6103eba0b588dc2c4ca41ac7c6811788d10af9" translate="yes" xml:space="preserve">
          <source>FORMAT</source>
          <target state="translated">FORMAT</target>
        </trans-unit>
        <trans-unit id="197bc57f95ecd67e69c42b441c686af9b56b66a3" translate="yes" xml:space="preserve">
          <source>FORMAT CONTROL ATTRIBUTES</source>
          <target state="translated">형식 관리 속성</target>
        </trans-unit>
        <trans-unit id="8c6077236f8ea6885b307ca6cfaf9346871ddc06" translate="yes" xml:space="preserve">
          <source>FORMAT is the</source>
          <target state="translated">형식은</target>
        </trans-unit>
        <trans-unit id="9ca6f46e23cb251edb9f7e2a3f8e64a09e982c8e" translate="yes" xml:space="preserve">
          <source>FORMAT is the &lt;a href=&quot;http://man.he.net/man3/printf&quot;&gt;printf(3)&lt;/a&gt;-style format specifier (without the leading '%') to use to print the times. It defaults to '5.2f'.</source>
          <target state="translated">FORMAT은 시간을 인쇄하는 데 사용할 &lt;a href=&quot;http://man.he.net/man3/printf&quot;&gt;printf (3)&lt;/a&gt; 스타일 형식 지정자 (선행 '%'없음)입니다. 기본값은 '5.2f'입니다.</target>
        </trans-unit>
        <trans-unit id="ec5814e0479ce0db049db2be1669d632fac6aa3f" translate="yes" xml:space="preserve">
          <source>FORMATTERS</source>
          <target state="translated">FORMATTERS</target>
        </trans-unit>
        <trans-unit id="d660f8cca36ec17fdb320607d854df06b0b01126" translate="yes" xml:space="preserve">
          <source>FORMATTING SPECIFICATIONS</source>
          <target state="translated">사양 사양</target>
        </trans-unit>
        <trans-unit id="4b1e81e861fd516f97ae14bf47f22c76798cec81" translate="yes" xml:space="preserve">
          <source>FORTRAN print control.</source>
          <target state="translated">FORTRAN 인쇄 제어.</target>
        </trans-unit>
        <trans-unit id="d8b9930b588cfbff9ca8c2607a532bbe28f9a623" translate="yes" xml:space="preserve">
          <source>FORWARD COMPATIBILITY</source>
          <target state="translated">앞으로의 호환성</target>
        </trans-unit>
        <trans-unit id="cca2a0e16b252e41df41d698b7943121b4ce66e8" translate="yes" xml:space="preserve">
          <source>FREETMPS</source>
          <target state="translated">FREETMPS</target>
        </trans-unit>
        <trans-unit id="ac03725b51e3b18352fbcf923063a48e12b26314" translate="yes" xml:space="preserve">
          <source>FREQUENTLY ASKED QUESTIONS</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="6496f6c84e390b28e94f50597c1286993f14328b" translate="yes" xml:space="preserve">
          <source>FROM THE COMMAND LINE</source>
          <target state="translated">명령 줄에서</target>
        </trans-unit>
        <trans-unit id="8872dc813208d15328cb72820a6753a9ddec0776" translate="yes" xml:space="preserve">
          <source>FTP Archives for Perl Modules:</source>
          <target state="translated">Perl 모듈 용 FTP 아카이브 :</target>
        </trans-unit>
        <trans-unit id="13add5d8be99c7156e522d0830855d1224598c3d" translate="yes" xml:space="preserve">
          <source>FTP Client class</source>
          <target state="translated">FTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="99c6dd16cd765c469c507fe9b03fc9fa2810bf50" translate="yes" xml:space="preserve">
          <source>FTP Client data connection class</source>
          <target state="translated">FTP 클라이언트 데이터 연결 클래스</target>
        </trans-unit>
        <trans-unit id="d6fc2619f665877d169e9fca0155476e2dbf2fb4" translate="yes" xml:space="preserve">
          <source>FTP servers can work in passive or active mode. Active mode is when you want to transfer data you have to tell the server the address and port to connect to. Passive mode is when the server provide the address and port and you establish the connection.</source>
          <target state="translated">FTP 서버는 수동 또는 활성 모드에서 작동 할 수 있습니다. 활성 모드는 데이터를 전송하려는 경우 서버에 연결할 주소와 포트를 알려야합니다. 수동 모드는 서버가 주소와 포트를 제공하고 연결을 설정하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="36c1fe86d5964c4e743e91fc8cc4caa0733fb438" translate="yes" xml:space="preserve">
          <source>FTP servers usually listen on the same port number, port 21, as any other FTP server. But there is no reason why this has to be the case.</source>
          <target state="translated">FTP 서버는 일반적으로 다른 FTP 서버와 동일한 포트 번호 인 포트 21에서 수신합니다. 그러나 이것이 그럴 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4fa87de490d6c1ca8c48ecbbdf1e0921be54835" translate="yes" xml:space="preserve">
          <source>FTP stands for File Transfer Protocol. It is a way of transferring files between networked machines. The protocol defines a client (whose commands are provided by this module) and a server (not implemented in this module). Communication is always initiated by the client, and the server responds with a message and a status code (and sometimes with data).</source>
          <target state="translated">FTP는 파일 전송 프로토콜을 나타냅니다. 네트워크 컴퓨터간에 파일을 전송하는 방법입니다. 프로토콜은 클라이언트 (이 모듈에서 명령을 제공하는 클라이언트)와 서버 (이 모듈에서 구현되지 않음)를 정의합니다. 통신은 항상 클라이언트에 의해 시작되며 서버는 메시지 및 상태 코드 (때로는 데이터)로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="22cfaa805c4996e790b0842ae141ee601b2ec3b2" translate="yes" xml:space="preserve">
          <source>FULLPERL</source>
          <target state="translated">FULLPERL</target>
        </trans-unit>
        <trans-unit id="96bdd2a0e835c50d5a37670cae3294bb4a92551d" translate="yes" xml:space="preserve">
          <source>FULLPERLRUN</source>
          <target state="translated">FULLPERLRUN</target>
        </trans-unit>
        <trans-unit id="4175d73a603036c7ec596dfc807dbe11477db143" translate="yes" xml:space="preserve">
          <source>FULLPERLRUNINST</source>
          <target state="translated">FULLPERLRUNINST</target>
        </trans-unit>
        <trans-unit id="64aa9da551140f123645f6df265bdb9a6b198111" translate="yes" xml:space="preserve">
          <source>FUNCLIST</source>
          <target state="translated">FUNCLIST</target>
        </trans-unit>
        <trans-unit id="63425456f14a800f08b688a005e2e85f84241751" translate="yes" xml:space="preserve">
          <source>FUNCTION</source>
          <target state="translated">FUNCTION</target>
        </trans-unit>
        <trans-unit id="f8bdd6d62e62677a02e5dc952820aa27e8b6384e" translate="yes" xml:space="preserve">
          <source>FUNCTION DIFFERENCES</source>
          <target state="translated">기능 차이</target>
        </trans-unit>
        <trans-unit id="9633f16041f6cad3a579e87f0baed24ec359c5c9" translate="yes" xml:space="preserve">
          <source>FUNCTION IMPLEMENTATIONS</source>
          <target state="translated">기능 구현</target>
        </trans-unit>
        <trans-unit id="a54261bf699a2c75d951095758dc3d3d9845baef" translate="yes" xml:space="preserve">
          <source>FUNCTION SPECIFIC NOTES</source>
          <target state="translated">기능별 참고 사항</target>
        </trans-unit>
        <trans-unit id="7524394489df18e23f74e891bd713b273f05b69b" translate="yes" xml:space="preserve">
          <source>FUNCTIONAL INTERFACE</source>
          <target state="translated">기능적 인터페이스</target>
        </trans-unit>
        <trans-unit id="e0639bb5342fee4e8d445f26b3a0278cc2fe4679" translate="yes" xml:space="preserve">
          <source>FUNCTIONS</source>
          <target state="translated">FUNCTIONS</target>
        </trans-unit>
        <trans-unit id="256018c65b4eb744f4377a13a19d91631c659dd4" translate="yes" xml:space="preserve">
          <source>FUNCTIONS API</source>
          <target state="translated">기능 API</target>
        </trans-unit>
        <trans-unit id="a8b599c6c2d22b5945b690bad2739bb459f033f6" translate="yes" xml:space="preserve">
          <source>FUNCTIONS FOR REFERENCES</source>
          <target state="translated">참조를위한 기능</target>
        </trans-unit>
        <trans-unit id="546e2c9a8685e17aa5c5cf752632f067b0b1ac92" translate="yes" xml:space="preserve">
          <source>FURTHER READING</source>
          <target state="translated">추가 읽기</target>
        </trans-unit>
        <trans-unit id="78d5c48c1c95da4e4d7cfa29209f1e02bb56ed08" translate="yes" xml:space="preserve">
          <source>Facet for assertion amnesty.</source>
          <target state="translated">주장 사면을위한 패싯.</target>
        </trans-unit>
        <trans-unit id="b2a8373446df3ec05bd53275eaae62cc9a0b479e" translate="yes" xml:space="preserve">
          <source>Facet for errors that need to be shown.</source>
          <target state="translated">표시해야하는 오류에 대한 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="1c1d180871daee0cdbe4502f47ae51bbd4bb7509" translate="yes" xml:space="preserve">
          <source>Facet for events contains other events</source>
          <target state="translated">이벤트 패싯에 다른 이벤트가 포함됨</target>
        </trans-unit>
        <trans-unit id="70ea596fd77110f489e26ed692733bea3f136f34" translate="yes" xml:space="preserve">
          <source>Facet for hub actions and behaviors.</source>
          <target state="translated">허브 작업 및 동작에 대한 패싯.</target>
        </trans-unit>
        <trans-unit id="8324754e4bbbb6888e22aff420189d7b50e4e121" translate="yes" xml:space="preserve">
          <source>Facet for information a developer might care about.</source>
          <target state="translated">개발자가 관심을 가질 수있는 정보에 대한 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="83bfc95bb8ef012dee5214e2e8cc7a7e2fbd4d47" translate="yes" xml:space="preserve">
          <source>Facet for meta-data</source>
          <target state="translated">메타 데이터 용 패싯</target>
        </trans-unit>
        <trans-unit id="d8f415e842705d2158785c07b8927d1f8a027365" translate="yes" xml:space="preserve">
          <source>Facet for setting the plan</source>
          <target state="translated">계획 설정을위한 패싯</target>
        </trans-unit>
        <trans-unit id="58384918ecc4e085ca881ebf031c51a056d62901" translate="yes" xml:space="preserve">
          <source>Facet for the hubs an event passes through.</source>
          <target state="translated">이벤트가 통과하는 허브의 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="378b6d9594f99674003363daa56d4fa9a71b1ed2" translate="yes" xml:space="preserve">
          <source>Facet representing an assertion.</source>
          <target state="translated">주장을 나타내는 패싯.</target>
        </trans-unit>
        <trans-unit id="fda3a9c60d8ab31ff000b4864eefdcc4c00171ff" translate="yes" xml:space="preserve">
          <source>Facet that dictates how to render an event.</source>
          <target state="translated">이벤트를 렌더링하는 방법을 지시하는 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="a7b0db876f6c994e9f1b7e9e8a9af8dc92aba61e" translate="yes" xml:space="preserve">
          <source>Facet with event details.</source>
          <target state="translated">이벤트 세부 정보가있는 패싯.</target>
        </trans-unit>
        <trans-unit id="e1548e5421220de5c1180140cf1e5a982f5e3c0c" translate="yes" xml:space="preserve">
          <source>Facets are how events convey their purpose to the Test2 internals and formatters. An event without facets will have no intentional effect on the overall test state, and will not be displayed at all by most formatters, except perhaps to say that an event of an unknown type was seen.</source>
          <target state="translated">패싯은 이벤트가 Test2 내부 및 포맷터에 목적을 전달하는 방법입니다. 패싯이없는 이벤트는 전체 테스트 상태에 의도적 인 영향을주지 않으며 알 수없는 유형의 이벤트가 발견되었다는 것을 제외하고는 대부분의 포맷터에 의해 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe9935e956d4ac9064df2633764e8fb19e4ae925" translate="yes" xml:space="preserve">
          <source>Facets are produced by the &lt;code&gt;facet_data()&lt;/code&gt; subroutine, which you should nearly-always override. &lt;code&gt;facet_data()&lt;/code&gt; is expected to return a hashref where each key is the facet type, and the value is either a hashref with the data for that facet, or an array of hashrefs. Some facets must be defined as single hashrefs, some must be defined as an array of hashrefs, No facets allow both.</source>
          <target state="translated">패싯은 거의 항상 재정의해야하는 &lt;code&gt;facet_data()&lt;/code&gt; 서브 루틴에 의해 생성됩니다 . &lt;code&gt;facet_data()&lt;/code&gt; 는 각 키가 패싯 유형이고 값이 해당 패싯에 대한 데이터가있는 해시 참조 또는 해시 참조의 배열 인 해시 참조를 반환 할 것으로 예상됩니다. 일부 패싯은 단일 해시 참조로 정의되어야하고, 일부는 해시 참조의 배열로 정의되어야합니다. 패싯은 둘 다 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aab1b0862ad45abd6672f0567f6c68cf09c136e" translate="yes" xml:space="preserve">
          <source>Facilitate processing an opened filehandle of a compressed archive</source>
          <target state="translated">압축 된 아카이브의 열린 파일 핸들 처리 용이</target>
        </trans-unit>
        <trans-unit id="9d0a833e883c67f6559509334a96f848be9e54ed" translate="yes" xml:space="preserve">
          <source>Facilities</source>
          <target state="translated">Facilities</target>
        </trans-unit>
        <trans-unit id="0b8af03a8ba1e4c01fa3396b94568da207e2f7a3" translate="yes" xml:space="preserve">
          <source>Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP :: Parser 출력 객체를 생성하는 팩토리</target>
        </trans-unit>
        <trans-unit id="579d7f5c997d76bab3032c2c355897f70853da24" translate="yes" xml:space="preserve">
          <source>Failed tests</source>
          <target state="translated">실패한 테스트</target>
        </trans-unit>
        <trans-unit id="efe0353ca36e091772af60ca71316fe70ddeac9e" translate="yes" xml:space="preserve">
          <source>Failed to close in-place work file %s: %s</source>
          <target state="translated">내부 작업 파일 % s을 (를) 닫지 못했습니다. % s</target>
        </trans-unit>
        <trans-unit id="194bab90ff2f1dcc5e2c4e85ff7e0a9857bb0252" translate="yes" xml:space="preserve">
          <source>Failing tests</source>
          <target state="translated">실패한 테스트</target>
        </trans-unit>
        <trans-unit id="607919027b2a9b94755ff24dee0db004455fddf6" translate="yes" xml:space="preserve">
          <source>Failover to different communication modes by Nick Williams &amp;lt;</source>
          <target state="translated">Nick Williams의 다른 통신 모드로 장애 조치 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c563018d20418391a3a741571c4b388d5e704fb2" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt; . In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">&lt;code&gt;BEGINLIBPATH&lt;/code&gt; 를 통해 찾은 Perl DLL 이 1 단계에서로드 된 것과 다른 경우 실패합니다 . 예를 들어, 다른 프로세스가 &lt;code&gt;LIBPATH&lt;/code&gt; 또는 다른 값의 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 에서 프로세스를로드했을 수 있습니다 . 이 경우 하나 개의 요구 사항이 다른 프로세스 중 하나를 실행하지 않도록 시스템의 설정을 수정하거나 부하에서 DLL하는 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 와 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (9 월 2000 년 이후 커널 사용 가능).</target>
        </trans-unit>
        <trans-unit id="b6865060f0c3e431fc8e58dc7dfb075d96c65977" translate="yes" xml:space="preserve">
          <source>Fails if the Perl DLL found via &lt;code&gt;BEGINLIBPATH&lt;/code&gt; is different from what was loaded on step 1; e.g., another process could have loaded it from &lt;code&gt;LIBPATH&lt;/code&gt; or from a different value of &lt;code&gt;BEGINLIBPATH&lt;/code&gt;. In these cases one needs to modify the setting of the system so that this other process either does not run, or loads the DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; with &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (available with kernels after September 2000).</source>
          <target state="translated">&lt;code&gt;BEGINLIBPATH&lt;/code&gt; 를 통해 찾은 Perl DLL 이 1 단계에서로드 된 것과 다른 경우 실패합니다 . 예를 들어, 다른 프로세스가 &lt;code&gt;LIBPATH&lt;/code&gt; 또는 다른 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 값에서 로드했을 수 있습니다 . 이 경우 하나 개의 요구 사항이 다른 프로세스 중 하나를 실행하지 않도록 시스템의 설정을 수정하거나 부하에서 DLL하는 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 와 &lt;code&gt;LIBPATHSTRICT=T&lt;/code&gt; (9 월 2000 년 이후 커널 사용 가능).</target>
        </trans-unit>
        <trans-unit id="6c5f423c103a5bffe6de7613de2373184d36088d" translate="yes" xml:space="preserve">
          <source>Fails if the original</source>
          <target state="translated">원본이 실패하면 실패</target>
        </trans-unit>
        <trans-unit id="17027fe6c01c307085e08da87bcd8a7cbddca555" translate="yes" xml:space="preserve">
          <source>Fails if the original UTF-8 sequence cannot be represented in the native 8 bit encoding. On failure dies or, if the value of</source>
          <target state="translated">원래 UTF-8 시퀀스를 기본 8 비트 인코딩으로 표현할 수없는 경우 실패합니다. 실패시 사망하거나</target>
        </trans-unit>
        <trans-unit id="5e10cdcfe2f19c749e60e277e1c9015c94fdd67f" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;&quot;G_KEEPERR&quot; in perlcall&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;G_KEEPERR&lt;/code&gt; 플래그를 사용하여 전달 된 사용자 콜백이 실패하면 이 경고가 발생할 수도 있습니다. &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall의 &quot;G_KEEPERR&quot;을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd78511c1283702ad2bb60da575ac2d0ff18ab16" translate="yes" xml:space="preserve">
          <source>Failure of user callbacks dispatched using the &lt;code&gt;G_KEEPERR&lt;/code&gt; flag could also result in this warning. See &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;G_KEEPERR in perlcall&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;G_KEEPERR&lt;/code&gt; 플래그를 사용하여 디스패치 된 사용자 콜백에 실패하면 이 경고가 발생할 수 있습니다. &lt;a href=&quot;perlcall#G_KEEPERR&quot;&gt;perlcall의 G_KEEPERR을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e175cd49340e07a19035148ceef428c5e5467b03" translate="yes" xml:space="preserve">
          <source>Failure to find a next method will result in an exception being thrown (see below for alternatives).</source>
          <target state="translated">다음 방법을 찾지 못하면 예외가 발생합니다 (대안은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="331a7d40c82f32a89c55031f2f7712cfb5b3bd07" translate="yes" xml:space="preserve">
          <source>Fairly young with a focus on HTML5 and real-time web technologies such as WebSockets.</source>
          <target state="translated">HTML5 및 WebSockets와 같은 실시간 웹 기술에 중점을 둔 상당히 젊습니다.</target>
        </trans-unit>
        <trans-unit id="b3505bf50d858a8755043974e251138d06ee1ab4" translate="yes" xml:space="preserve">
          <source>Fake on-demand retrieval of outstanding PM messages. If &lt;code&gt;force&lt;/code&gt; is false, will not dispatch messages if a real message loop is known to be present. Returns number of messages retrieved.</source>
          <target state="translated">미해결 PM 메시지의 주문형 가짜 검색. 경우 &lt;code&gt;force&lt;/code&gt; 거짓 진정한 메시지 루프가 존재하는 것으로 알려져 경우, 메시지를 전달하지 않습니다. 검색된 메시지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b7d9017d82f8622025ae6965855a1db0b5bb68b" translate="yes" xml:space="preserve">
          <source>Fall-through</source>
          <target state="translated">Fall-through</target>
        </trans-unit>
        <trans-unit id="fab000fc839ca496f91ba067964c48702895aed4" translate="yes" xml:space="preserve">
          <source>Fallback Data::Dumper and Storable</source>
          <target state="translated">대체 데이터 :: 덤퍼 및 저장 가능</target>
        </trans-unit>
        <trans-unit id="2a4cf3efe7afe1d41140981a0335c8d83aa5d220" translate="yes" xml:space="preserve">
          <source>Fallback F</source>
          <target state="translated">폴백 F</target>
        </trans-unit>
        <trans-unit id="73f8b4fb3083d20a1f8a2c30b19bc54cad14826c" translate="yes" xml:space="preserve">
          <source>Fallback for &lt;code&gt;decode&lt;/code&gt; must return decoded string (sequence of characters) and takes a list of ordinal values as its arguments. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; 위한 폴백은 디코딩 된 문자열 (문자 시퀀스)을 반환해야하며 서수 값 목록을 인수로 사용합니다. 예를 들어 8 진수를 UTF-8로 디코딩하고 유효한 UTF-8이 아닌 바이트에 대한 폴백으로 ISO-8859-15를 사용하려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a969fb863f8d9f84c7595f93fb9e0917427160e1" translate="yes" xml:space="preserve">
          <source>Fallback for encoding -&amp;gt; unicode. When seen, enc2xs adds this character for the decode map only.</source>
          <target state="translated">인코딩-&amp;gt; 유니 코드 대체. 보시면, enc2xs는 디코드 맵에 대해서만이 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c7fc9099ef21900d77c14fd9245e820c2f3bcb05" translate="yes" xml:space="preserve">
          <source>Fallback for unicode -&amp;gt; encoding. When seen, enc2xs adds this character for the encode map only.</source>
          <target state="translated">유니 코드-&amp;gt; 인코딩의 대체. enc2xs는이 맵을 인코딩 맵에 대해서만 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9c5b502e30e454f9201574751906e3d638bd47ad" translate="yes" xml:space="preserve">
          <source>False [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">정규식에서 False [] 범위 &quot;% s&quot;; &amp;lt;-HERE (m / % s /)로 표시</target>
        </trans-unit>
        <trans-unit id="2d4bc2a882c589e2e3abf29bf34c6abd040f95e8" translate="yes" xml:space="preserve">
          <source>False by default. This will return true on events that should not be displayed by formatters.</source>
          <target state="translated">기본적으로 False입니다. 포맷터에 의해 표시되지 않아야하는 이벤트에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96cc126519ccb2cce10803355bc133ed10a33eb9" translate="yes" xml:space="preserve">
          <source>Family =&amp;gt; INT</source>
          <target state="translated">가족 =&amp;gt; INT</target>
        </trans-unit>
        <trans-unit id="cc390dbd71040b4339ecd1673e22c52149414722" translate="yes" xml:space="preserve">
          <source>Family-neutral IP socket supporting both IPv4 and IPv6</source>
          <target state="translated">IPv4 및 IPv6을 모두 지원하는 가족 중립 IP 소켓</target>
        </trans-unit>
        <trans-unit id="b4fab41a1c219c7c774d4d5b99f19bfff38b0e96" translate="yes" xml:space="preserve">
          <source>Fancy term for &lt;b&gt;tokenizing&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰 화를&lt;/b&gt; 위한 멋진 용어 .</target>
        </trans-unit>
        <trans-unit id="94700cb17db6026703f0124336c1c74248aa0c67" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;token&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰에&lt;/b&gt; 대한 멋진 용어 .</target>
        </trans-unit>
        <trans-unit id="ae38f29ac6b64f59f2ed532d4ca0474fdf64d92e" translate="yes" xml:space="preserve">
          <source>Fancy term for a &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;토큰업자를&lt;/b&gt; 위한 공상 기간 .</target>
        </trans-unit>
        <trans-unit id="f5c2b89d95eac3e9d7a030078747e18b17f8f9e8" translate="yes" xml:space="preserve">
          <source>Far More Than Everything You Ever Wanted To Know. An exhaustive treatise on one narrow topic, something of a super-&lt;b&gt;FAQ&lt;/b&gt;. See Tom for far more.</source>
          <target state="translated">당신이 알고 싶었던 것보다 훨씬 더. 하나의 좁은 주제, 철저한 &lt;b&gt;FAQ&lt;/b&gt; 에 대한 철저한 논문 . 훨씬 더 톰을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97102c70808de7b8e3d760ebf0b36147b801055a" translate="yes" xml:space="preserve">
          <source>FastCalc works exactly like Calc, in stores the numbers in decimal form, chopped into parts.</source>
          <target state="translated">FastCalc는 Calc와 똑같이 작동하며 숫자를 소수점 이하 자릿수로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="b4aa64ef3bff004eb3090e0a608393aba194c2eb" translate="yes" xml:space="preserve">
          <source>Fatal - Replace functions with equivalents which succeed or die</source>
          <target state="translated">치명적-성공하거나 죽는 등가물로 함수 교체</target>
        </trans-unit>
        <trans-unit id="7b51ba1a17fb15f440e9b23d89ba8c4efe01b4e8" translate="yes" xml:space="preserve">
          <source>Fatal VMS error (status=%d) at %s, line %d</source>
          <target state="translated">치명적인 VMS 오류 (상태 = % d) (% s, 줄 % d)</target>
        </trans-unit>
        <trans-unit id="c4d463e2edaea59c2a65ec5996b3a03a5976f772" translate="yes" xml:space="preserve">
          <source>Fatal Warnings</source>
          <target state="translated">치명적인 경고</target>
        </trans-unit>
        <trans-unit id="a4a739fca7ca0c79dbb282ff772c97aebe6957a9" translate="yes" xml:space="preserve">
          <source>Fcntl</source>
          <target state="translated">Fcntl</target>
        </trans-unit>
        <trans-unit id="e79e4cb9771eccd5b0301896c4fb88d90381fa77" translate="yes" xml:space="preserve">
          <source>Fcntl - load the C Fcntl.h defines</source>
          <target state="translated">Fcntl-C로드 Fcntl.h 정의</target>
        </trans-unit>
        <trans-unit id="5ba5c3a5081f69770fe71f342b75f8e639b7ddd9" translate="yes" xml:space="preserve">
          <source>FdGetOsFHandle</source>
          <target state="translated">FdGetOsFHandle</target>
        </trans-unit>
        <trans-unit id="01ed00607d92181e571c2670c20709d97c5c44ac" translate="yes" xml:space="preserve">
          <source>Features a comprehensive coverage of CJKV character sets and encodings along with many other issues faced by anyone trying to better support CJKV languages/scripts in all the areas of information processing.</source>
          <target state="translated">정보 처리의 모든 영역에서 CJKV 언어 / 스크립트를 더 잘 지원하려는 사람이 직면 한 다른 많은 문제와 함께 CJKV 문자 집합 및 인코딩에 대한 포괄적 인 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="229c2035f4aec78ea8439cfaab9ef160e590f22f" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; . This too has lexical effect.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;foo&quot;&lt;/code&gt; 을 사용 &lt;a href=&quot;functions/no&quot;&gt;하지 않으면&lt;/a&gt; 기능을 끌 수도 있습니다 . 이것도 어휘 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e379ae6e30b736192025420af358547c6ada5ad" translate="yes" xml:space="preserve">
          <source>Features can also be turned off by using &lt;code&gt;no feature &quot;foo&quot;&lt;/code&gt;. This too has lexical effect.</source>
          <target state="translated">&lt;code&gt;no feature &quot;foo&quot;&lt;/code&gt; 를 사용하여 기능을 끌 수도 있습니다 . 이것도 어휘 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03d65a3c6febccc90e9f30f5a749117a92b9dcc" translate="yes" xml:space="preserve">
          <source>February 28, 2013</source>
          <target state="translated">2013 년 2 월 28 일</target>
        </trans-unit>
        <trans-unit id="23cf501c0a2b5c8f4c1ddd40cb4a07d73b755042" translate="yes" xml:space="preserve">
          <source>February, 2004; by Chia-liang Kao: make cmpthese and timestr use time statistics for children instead of parent when the style is 'nop'.</source>
          <target state="translated">2004 년 2 월; Chia-liang Kao : 스타일이 'nop'일 때 cmpthese 및 timestr에서 부모 대신 어린이에 대한 시간 통계를 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d3095f775b3bd756ca42dc28dbbcb522fa556f5" translate="yes" xml:space="preserve">
          <source>Feel free to add any member data fields you need to keep track of things like current font, indentation, horizontal or vertical position, or whatever else you like. Be sure to read &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;PRIVATE METHODS AND DATA&lt;/a&gt; to avoid name collisions.</source>
          <target state="translated">현재 글꼴, 들여 쓰기, 가로 또는 세로 위치 또는 기타 원하는 항목을 추적하는 데 필요한 멤버 데이터 필드를 자유롭게 추가하십시오. 이름 충돌을 피하기 위해 &lt;a href=&quot;#PRIVATE-METHODS-AND-DATA&quot;&gt;개인 정보 및 데이터&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="70cbb102105e81fb1b4636c361737ff2e64d0599" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">Perl의 새 버전이 출시되고 버그가 여전히 존재하는 경우 &lt;a href=&quot;http://rt.perl.org&quot;&gt;http://rt.perl.org에서&lt;/a&gt; 버그에 대한 티켓을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="818e0f82dbbed731afa80bbab7b35df92f5cc034" translate="yes" xml:space="preserve">
          <source>Feel free to update the ticket about your bug on &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; if a new version of Perl is released and your bug is still present.</source>
          <target state="translated">새 버전의 Perl이 릴리스되고 버그가 여전히 존재하는 경우 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues에서&lt;/a&gt; 버그에 대한 티켓을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="36b9072d4d9d0784cf29d859c2595c262d17ce85" translate="yes" xml:space="preserve">
          <source>Felipe Gasper &amp;lt;felipe@felipegasper.com&amp;gt;</source>
          <target state="translated">Felipe Gasper &amp;lt;felipe@felipegasper.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fd7064e4dbef9d61b58b480cbcce388f810d38f0" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">지정된 번호의 캡처를 가져옵니다. &lt;code&gt;sv&lt;/code&gt; 를 반환하려면 스칼라로 설정해야합니다. 스칼라는 함수에서 반환되는 것이 아니라 인수로 전달됩니다. Perl이라고 부르면 이미 값을 저장하는 스칼라가 있으므로 다른 값을 만드는 것이 중복되기 때문입니다. 스칼라는 설정할 수 있습니다 &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; 보고, 친구 &lt;a href=&quot;perlapi&quot;&gt;perlapi을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48fd141ea5546433e7ee18f3519e592b58062912" translate="yes" xml:space="preserve">
          <source>Fetch a specified numbered capture. &lt;code&gt;sv&lt;/code&gt; should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it's called Perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with &lt;code&gt;sv_setsv&lt;/code&gt;, &lt;code&gt;sv_setpvn&lt;/code&gt; and friends, see &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">지정된 번호가 매겨진 캡처를 가져옵니다. &lt;code&gt;sv&lt;/code&gt; 는 반환 할 스칼라로 설정되어야합니다. 스칼라는 함수에서 반환되는 것이 아니라 인수로 전달됩니다. Perl이 이미 값을 저장할 스칼라를 가지고 있으므로 다른 값을 생성하는 것은 중복되기 때문입니다. 스칼라는 &lt;code&gt;sv_setsv&lt;/code&gt; , &lt;code&gt;sv_setpvn&lt;/code&gt; 및 friends 로 설정할 수 있습니다 . &lt;a href=&quot;perlapi&quot;&gt;perlapi를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb89725e8e52167503480d3ef11a278907f1601" translate="yes" xml:space="preserve">
          <source>Fetch an ARexx message from the host port. Returns an objrct of class Amiga::ARexx::Msg</source>
          <target state="translated">호스트 포트에서 ARexx 메시지를 가져옵니다. Amiga :: ARexx :: Msg 클래스의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="361d18ac190751239212937c28a02d801b3fdb96" translate="yes" xml:space="preserve">
          <source>Fetch and install dmake somewhere on your path.</source>
          <target state="translated">경로에 어딘가에 dmake를 가져오고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2ef1611403db02cc8268d0f9fa27bf2626bfc429" translate="yes" xml:space="preserve">
          <source>Fetch the value of a constant. Returns &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;$sConstantName&lt;/code&gt; is not the name of a constant supported by this module. Never sets &lt;code&gt;$!&lt;/code&gt; nor &lt;code&gt;$^E&lt;/code&gt;.</source>
          <target state="translated">상수 값을 가져옵니다. &lt;code&gt;$sConstantName&lt;/code&gt; 이이 모듈에서 지원하는 상수의 이름이 아닌 경우 &lt;code&gt;undef&lt;/code&gt; 를 반환 합니다. &lt;code&gt;$!&lt;/code&gt; 설정하지 마십시오 ! &lt;code&gt;$^E&lt;/code&gt; 도 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="06725480fea615d084c694cfa90098fe4e3f491f" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the INPUT section of the typemap.</source>
          <target state="translated">typemap의 INPUT 섹션 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d4a9ae8436e8d3cd5ef250d912f1bdeb9859c506" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the OUTPUT section of the typemap.</source>
          <target state="translated">typemap의 OUTPUT 섹션 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c736b0f8cda63c68f4e793293e1f7b1c4a83bcc7" translate="yes" xml:space="preserve">
          <source>Fetches an entry of the TYPEMAP section of the typemap.</source>
          <target state="translated">typemap의 TYPEMAP 섹션 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="804d920af683a75f739608bbcb40c81ec9c0980c" translate="yes" xml:space="preserve">
          <source>Fetches the file you requested and returns the full path to the file.</source>
          <target state="translated">요청한 파일을 가져오고 파일의 전체 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="827c97bde84978a3bb98e5034a1b606013a63c45" translate="yes" xml:space="preserve">
          <source>Fetches the pad name from the given index.</source>
          <target state="translated">주어진 인덱스에서 패드 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="71f58f8d922f796a2889048895e8dc9ffd8f6c42" translate="yes" xml:space="preserve">
          <source>Fetching network info</source>
          <target state="translated">네트워크 정보를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="96d83d9a37e933efbb23620fd66a3863f0d6f889" translate="yes" xml:space="preserve">
          <source>Fetching user and group info</source>
          <target state="translated">사용자 및 그룹 정보를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="70b0630621dc693a0b82b1ac72066204ea3cb1ff" translate="yes" xml:space="preserve">
          <source>Fiddling with the Perl stack from your C program</source>
          <target state="translated">C 프로그램에서 Perl 스택으로 처리</target>
        </trans-unit>
        <trans-unit id="9ae894619db092857c73b584dce0433ed00f6245" translate="yes" xml:space="preserve">
          <source>Field too wide in 'u' format in pack</source>
          <target state="translated">팩에서 'u'형식의 필드가 너무 넓습니다.</target>
        </trans-unit>
        <trans-unit id="5264e2b4a8e426bffe920139d4498e83c17f919e" translate="yes" xml:space="preserve">
          <source>FieldHash-based inside-out implementation. Object registry happens automatically. No destructor is needed and objects are thread safe.</source>
          <target state="translated">FieldHash 기반 내부 구현. 개체 레지스트리가 자동으로 발생합니다. 소멸자가 필요하지 않으며 객체는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="07d174584450454292329995c0541462f26066d7" translate="yes" xml:space="preserve">
          <source>Fields are as follows:</source>
          <target state="translated">필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d74e30558c4268af35bc2d593f402b9621c70e4" translate="yes" xml:space="preserve">
          <source>Fields in the &lt;a href=&quot;#STRUCTURE&quot;&gt;&quot;STRUCTURE&quot;&lt;/a&gt; section describe data elements, each of which has an associated data type as described herein. There are four primitive types: Boolean, String, List and Map. Other types are subtypes of primitives and define compound data structures or define constraints on the values of a data element.</source>
          <target state="translated">&lt;a href=&quot;#STRUCTURE&quot;&gt;&quot;구조&quot;&lt;/a&gt; 섹션 의 필드는 데이터 요소를 설명하며, 각 요소에는 여기에 설명 된 관련 데이터 유형이 있습니다. 기본 유형에는 부울, 문자열, 목록 및 맵의 네 가지가 있습니다. 다른 유형은 프리미티브의 하위 유형이며 복합 데이터 구조를 정의하거나 데이터 요소의 값에 대한 제약을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6d320afb6b0630e1ccda485797b8576696531e08" translate="yes" xml:space="preserve">
          <source>Fields that aren't applicable to the particular code point argument exist in the returned hash, and are empty.</source>
          <target state="translated">특정 코드 포인트 인수에 적용 할 수없는 필드는 반환 된 해시에 존재하며 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b39efda9ad6870df874aed2f0bbeddee020a37" translate="yes" xml:space="preserve">
          <source>Fifth:</source>
          <target state="translated">Fifth:</target>
        </trans-unit>
        <trans-unit id="f4f4e020ef73cd3f9c800d7b4c395570858c0611" translate="yes" xml:space="preserve">
          <source>Figures out the current line number in the XS file.</source>
          <target state="translated">XS 파일에서 현재 줄 번호를 알아냅니다.</target>
        </trans-unit>
        <trans-unit id="659f180bfdb0412ca17466a6655bb668ede0196b" translate="yes" xml:space="preserve">
          <source>Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">주어진 소스에 사용할 SourceHandler 객체를 알아냅니다.</target>
        </trans-unit>
        <trans-unit id="4b9b547e63da9c5d210106fd0343b71348efc18f" translate="yes" xml:space="preserve">
          <source>Figuring out the hexadecimal sequence of a Unicode character you want or deciphering someone else's hexadecimal Unicode regexp is about as much fun as programming in machine code. So another way to specify Unicode characters is to use the</source>
          <target state="translated">원하는 유니 코드 문자의 16 진수 시퀀스를 파악하거나 다른 사람의 16 진수 유니 코드 정규 표현식을 해독하는 것은 머신 코드에서 프로그래밍하는 것만 큼 재미 있습니다. 유니 코드 문자를 지정하는 또 다른 방법은</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="00acd6f7be2c3aca96cab1792dd9c533c4fb99b0" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt; : Perl module for the RPC extension.</source>
          <target state="translated">&lt;code&gt;RPC.pm&lt;/code&gt; 파일 : RPC 확장을위한 Perl 모듈.</target>
        </trans-unit>
        <trans-unit id="a012c4fa9de1752d421e1a0c810e66e54c1bc04d" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.pm&lt;/code&gt;: Perl module for the RPC extension.</source>
          <target state="translated">파일 &lt;code&gt;RPC.pm&lt;/code&gt; : RPC 확장을위한 Perl 모듈.</target>
        </trans-unit>
        <trans-unit id="2572733e62323918ecd19b3a5f28f1fad3d4a4e6" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt; : Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">File &lt;code&gt;RPC.xs&lt;/code&gt; : 일부 ONC + RPC 바인드 라이브러리 기능에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="d21d0a1f8e28ac4439c9ff42ce00b69859e99056" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;RPC.xs&lt;/code&gt;: Interface to some ONC+ RPC bind library functions.</source>
          <target state="translated">파일 &lt;code&gt;RPC.xs&lt;/code&gt; : 일부 ONC + RPC 바인드 라이브러리 기능에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0858ff16b7316b0da87cf27e491f57eeba0e7c11" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt; : Perl test program for the RPC extension.</source>
          <target state="translated">파일 &lt;code&gt;rpctest.pl&lt;/code&gt; : RPC 확장을위한 Perl 테스트 프로그램.</target>
        </trans-unit>
        <trans-unit id="b9b9f794d632ec2a1eb3d647f9b9b9ab58436d10" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;rpctest.pl&lt;/code&gt;: Perl test program for the RPC extension.</source>
          <target state="translated">&lt;code&gt;rpctest.pl&lt;/code&gt; 파일 : RPC 확장을위한 Perl 테스트 프로그램.</target>
        </trans-unit>
        <trans-unit id="89663ab01d6a733daa8d8f050b0e4c86205af531" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt; : Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">파일 형식 &lt;code&gt;typemap&lt;/code&gt; : RPC.xs 용 사용자 지정 형식 맵입니다. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="08279cd069867bec755240f0d6eb568b4f16393a" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;typemap&lt;/code&gt;: Custom typemap for RPC.xs. (cf. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;)</source>
          <target state="translated">파일 &lt;code&gt;typemap&lt;/code&gt; : RPC.xs에 대한 사용자 정의 typemap. (참조. &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0d73d8626a39dd86d3fe7032f41a3ecc0c3dd715" translate="yes" xml:space="preserve">
          <source>File Extraction Problems on Solaris.</source>
          <target state="translated">Solaris의 파일 추출 문제.</target>
        </trans-unit>
        <trans-unit id="ab608d2ad8085ce03268de7bd1b1cc78fcd297d4" translate="yes" xml:space="preserve">
          <source>File Globbing</source>
          <target state="translated">파일 글 로빙</target>
        </trans-unit>
        <trans-unit id="94f0aef527a940964fa9d548817f94f5c7e0d938" translate="yes" xml:space="preserve">
          <source>File Handle and Input/Output Stream Utilities</source>
          <target state="translated">파일 핸들 및 입력 / 출력 스트림 유틸리티</target>
        </trans-unit>
        <trans-unit id="2c21dac263de829a5861211698806d60572e8b18" translate="yes" xml:space="preserve">
          <source>File Input and Output</source>
          <target state="translated">파일 입출력</target>
        </trans-unit>
        <trans-unit id="ed7b317f92a6f66879f8f8669d4497dbe06ba062" translate="yes" xml:space="preserve">
          <source>File Names, File Systems and File Locking (see also File Handles)</source>
          <target state="translated">파일 이름, 파일 시스템 및 파일 잠금 (파일 핸들 참조)</target>
        </trans-unit>
        <trans-unit id="5c1cc1d41d3f3f53b541537cbb16ed14651ac798" translate="yes" xml:space="preserve">
          <source>File Naming Options</source>
          <target state="translated">파일 이름 지정 옵션</target>
        </trans-unit>
        <trans-unit id="a726cab0d7c518573e2f7003375fc21599153b1b" translate="yes" xml:space="preserve">
          <source>File Operations</source>
          <target state="translated">파일 작업</target>
        </trans-unit>
        <trans-unit id="7572853d675e9450d66b583e3f295602cd6e9a54" translate="yes" xml:space="preserve">
          <source>File Permissions on Cygwin</source>
          <target state="translated">Cygwin에 대한 파일 권한</target>
        </trans-unit>
        <trans-unit id="0f4d62f2c22e44d7f4ed81d343bbd5948187b552" translate="yes" xml:space="preserve">
          <source>File Positioning</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="caf0d3d658336bf20ddebae36071045171882da3" translate="yes" xml:space="preserve">
          <source>File attribute constants. Returned by &lt;code&gt;attrLetsToBits&lt;/code&gt; and used in the &lt;code&gt;$uFlags&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">파일 속성 상수. &lt;code&gt;attrLetsToBits&lt;/code&gt; 에 의해 반환되고 &lt;code&gt;CreateFile&lt;/code&gt; 의 &lt;code&gt;$uFlags&lt;/code&gt; 인수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="96516abc6bebff8831916b6857ba16f8d6fdd597" translate="yes" xml:space="preserve">
          <source>File blocksize</source>
          <target state="translated">파일 블록 크기</target>
        </trans-unit>
        <trans-unit id="9e1d825c16be42dcd9eac27ad46d89bd0981bbff" translate="yes" xml:space="preserve">
          <source>File can only be processed in a sequential manner.</source>
          <target state="translated">파일은 순차적으로 만 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e2776d2d7b4fdf0cd1f81238e59693ef37962888" translate="yes" xml:space="preserve">
          <source>File characteristic options:</source>
          <target state="translated">파일 특성 옵션 :</target>
        </trans-unit>
        <trans-unit id="2a98d820804906c7cbc4a39c07f594d33f47d588" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared message.</source>
          <target state="translated">보고서 본문이 포함 된 파일입니다. 준비된 메시지를 빠르게 보내려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1051fa7a3f3c8d871c9acc4c30e002dc5cc847" translate="yes" xml:space="preserve">
          <source>File containing the body of the report. Use this to quickly send a prepared report.</source>
          <target state="translated">보고서 본문이 포함 된 파일입니다. 이를 사용하여 준비된 보고서를 신속하게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1653ca6d1bd7cd87184004c951688277cfc7e58a" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt;ed, or should be deleted on &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파일의 링크가 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 되었거나 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 에서 삭제되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e7d76d456ba6834e47b16e8b42081256fccbf9d8" translate="yes" xml:space="preserve">
          <source>File has been &lt;code&gt;unlink()&lt;/code&gt;ed, or should be deleted on &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">파일이 &lt;code&gt;unlink()&lt;/code&gt; ed 또는 &lt;code&gt;close()&lt;/code&gt; 에 삭제되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f5f1c8650cee1864991294b341c02bd2c5622a" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;F_GETLK&lt;/code&gt; 명령을 사용한 파일 잠금 은 &lt;code&gt;ENOSYS&lt;/code&gt; 를 반환하는 스텁입니다 .</target>
        </trans-unit>
        <trans-unit id="bf0b815315c825f3269c03242b3b198ccea50919" translate="yes" xml:space="preserve">
          <source>File locking using the &lt;code&gt;F_GETLK&lt;/code&gt; command to &lt;code&gt;fcntl()&lt;/code&gt; is a stub that returns &lt;code&gt;ENOSYS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fcntl()&lt;/code&gt; &lt;code&gt;F_GETLK&lt;/code&gt; 명령을 사용하는 파일 잠금 은 &lt;code&gt;ENOSYS&lt;/code&gt; 를 반환하는 스텁입니다 .</target>
        </trans-unit>
        <trans-unit id="dfa00f1ae5815d6eaab80150e5fdb0f9d6b07ccd" translate="yes" xml:space="preserve">
          <source>File names are case insensitive, but case preserving. A pathname that contains a backslash or drive letter is a Win32 pathname, and not subject to the translations applied to POSIX style pathnames, but cygwin will warn you, so better convert them to POSIX.</source>
          <target state="translated">파일 이름은 대소 문자를 구분하지 않지만 대소 문자를 유지합니다. 백 슬래시 또는 드라이브 문자가 포함 된 경로 이름은 Win32 경로 이름이며 POSIX 스타일 경로 이름에 적용된 변환은 적용되지 않지만 cygwin은 경고하므로 POSIX로 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b9dd24c17d5e17210a1ec27701054547639bdec" translate="yes" xml:space="preserve">
          <source>File names on Mac OS X will at the OS-level be converted to NFD-form. A file created by passing a NFC-filename will come in NFD-form from readdir(). See &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; for details of NFD/NFC.</source>
          <target state="translated">Mac OS X의 파일 이름은 OS 수준에서 NFD 형식으로 변환됩니다. NFC 파일 이름을 전달하여 생성 된 파일은 readdir ()에서 NFD 형식으로 제공됩니다. NFD / NFC에 대한 자세한 내용은 &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d54cd453577fef9dfe80492dac9d8160d18c32b6" translate="yes" xml:space="preserve">
          <source>File option flag constants. Used in the &lt;code&gt;$uFlags&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">파일 옵션 플래그 상수. &lt;code&gt;CreateFile&lt;/code&gt; 의 &lt;code&gt;$uFlags&lt;/code&gt; 인수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5919b0472cf28437e422bab84192d0873dd39a7" translate="yes" xml:space="preserve">
          <source>File or pipe to print line number info to. If it is a pipe (say, &lt;code&gt;|visual_perl_db&lt;/code&gt;), then a short message is used. This is the mechanism used to interact with a slave editor or visual debugger, such as the special &lt;code&gt;vi&lt;/code&gt; or &lt;code&gt;emacs&lt;/code&gt; hooks, or the &lt;code&gt;ddd&lt;/code&gt; graphical debugger.</source>
          <target state="translated">줄 번호 정보를 인쇄 할 파일 또는 파이프. 파이프 인 경우 (예 : &lt;code&gt;|visual_perl_db&lt;/code&gt; ) 짧은 메시지가 사용됩니다. 이것은 특수 &lt;code&gt;vi&lt;/code&gt; 또는 &lt;code&gt;emacs&lt;/code&gt; 후크 또는 &lt;code&gt;ddd&lt;/code&gt; 그래픽 디버거 와 같은 슬레이브 편집기 또는 시각적 디버거와 상호 작용하는 데 사용되는 메커니즘 입니다.</target>
        </trans-unit>
        <trans-unit id="f440d36d60fd2a51c020f6cb4de72889008d2bd8" translate="yes" xml:space="preserve">
          <source>File paths in a MANIFEST always use Unix conventions (ie. /) even if you're not on Unix.</source>
          <target state="translated">MANIFEST의 파일 경로는 Unix를 사용하지 않더라도 항상 Unix 규칙 (예 : /)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7dc956feddc3d2623d44caf49dd0d8e0007cbbed" translate="yes" xml:space="preserve">
          <source>File processing option. Takes one or more of the following (in a comma-separated list if there's more than one)</source>
          <target state="translated">파일 처리 옵션. 다음 중 하나 이상을 가져옵니다 (둘 이상인 경우 쉼표로 구분 된 목록).</target>
        </trans-unit>
        <trans-unit id="d55fcbf3081365ea2dbdf9c282d44d6f2691df69" translate="yes" xml:space="preserve">
          <source>File record attributes. Takes one of the following:</source>
          <target state="translated">파일 레코드 속성. 다음 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8f41398b31aa302780598177a116cea6dc3fa88e" translate="yes" xml:space="preserve">
          <source>File record format. Takes one of the following:</source>
          <target state="translated">파일 레코드 형식. 다음 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10f7a88505dbe3f5824d9ceaa62700ff84c27915" translate="yes" xml:space="preserve">
          <source>File sharing constants. Used in the &lt;code&gt;$uShare&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="translated">파일 공유 상수. &lt;code&gt;CreateFile&lt;/code&gt; 의 &lt;code&gt;$uShare&lt;/code&gt; 인수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f11680d8841bb7f976e1fe18696bfa60b7ed127" translate="yes" xml:space="preserve">
          <source>File sharing options. Choose one of the following:</source>
          <target state="translated">파일 공유 옵션. 다음 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="d684db983e8b5220e9565d325f0ae9bbe13b32e7" translate="yes" xml:space="preserve">
          <source>File size in bytes</source>
          <target state="translated">바이트 단위의 파일 크기</target>
        </trans-unit>
        <trans-unit id="c37e8261b4c2e82f199fe5efaafed18a68582d21" translate="yes" xml:space="preserve">
          <source>File specifications</source>
          <target state="translated">파일 사양</target>
        </trans-unit>
        <trans-unit id="4007cbed1dac0ce1704758796b77f5a74a2f4ba7" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">와일드 카드를 포함하는 파일 스펙은 명령 행과 Perl globs 내에서 모두 허용됩니다 (예 : &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ). 와일드 카드 파일 스펙이 VMS 구문을 사용하는 경우 결과 파일 스펙은 VMS 구문을 따릅니다. 유닉스 스타일 파일 스펙이 전달되면 유닉스 스타일 파일 스펙이 리턴됩니다. 유닉스 쉘에 대한 와일드 카드 글 로빙의 동작과 유사하게, perl 프로그램 명령 행 인수 주위에 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 를 사용하여 명령 행 와일드 카드를 이스케이프 할 수 있습니다 . 그러나 argv의 C 처리에 의해 수행되는 &lt;code&gt;&quot;&lt;/code&gt; 문자 의 제거 때문에 argv를 처리 할 수 ​​있습니다. 이와 같은 구문을 피해야합니다 (파일이 들어있는 디렉토리에서)</target>
        </trans-unit>
        <trans-unit id="b9816c97101d5dbae273f4de135cc76301a683d5" translate="yes" xml:space="preserve">
          <source>File specifications containing wildcards are allowed both on the command line and within Perl globs (e.g. &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt;). If the wildcard filespec uses VMS syntax, the resultant filespecs will follow VMS syntax; if a Unix-style filespec is passed in, Unix-style filespecs will be returned. Similar to the behavior of wildcard globbing for a Unix shell, one can escape command line wildcards with double quotation marks &lt;code&gt;&quot;&lt;/code&gt; around a perl program command line argument. However, owing to the stripping of &lt;code&gt;&quot;&lt;/code&gt; characters carried out by the C handling of argv you will need to escape a construct such as this one (in a directory containing the files</source>
          <target state="translated">와일드 카드를 포함하는 파일 사양은 명령 줄과 Perl glob (예 : &lt;code&gt;&amp;lt;*.c&amp;gt;&lt;/code&gt; ) 모두에서 허용 됩니다. 와일드 카드 파일 사양이 VMS 구문을 사용하는 경우 결과 파일 사양은 VMS 구문을 따릅니다. Unix 스타일 파일 사양이 전달되면 Unix 스타일 파일 사양이 반환됩니다. 하나는 큰 따옴표로 명령 줄 와일드 카드를 탈출 할 수있는 유닉스 셸 와일드 카드 대체 (globbing)의 동작과 유사 &lt;code&gt;&quot;&lt;/code&gt; 펄 프로그램 명령 행 인수 주위가. 그러나,의 제거로 인해 &lt;code&gt;&quot;&lt;/code&gt; 자하는 변수는 argv의 처리 C에 의해 수행 당신은 것입니다 이와 같은 구조를 이스케이프해야합니다 (파일이 포함 된 디렉토리에서</target>
        </trans-unit>
        <trans-unit id="a1068e78c1a68e0282abb193b14dbb089a1a5b4e" translate="yes" xml:space="preserve">
          <source>File system characteristics constants. Placed in the &lt;code&gt;$ouFsFlags&lt;/code&gt; argument to &lt;code&gt;GetVolumeInformation&lt;/code&gt;.</source>
          <target state="translated">파일 시스템 특성 상수. &lt;code&gt;GetVolumeInformation&lt;/code&gt; 의 &lt;code&gt;$ouFsFlags&lt;/code&gt; 인수에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="2125f6818b6fbbdb018675e8c02915ed59c3e1f9" translate="yes" xml:space="preserve">
          <source>File system control operations. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;.</source>
          <target state="translated">파일 시스템 제어 작업. &lt;code&gt;DeviceIoControl&lt;/code&gt; 에 대한 &lt;code&gt;$uIoControlCode&lt;/code&gt; 인수에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f27043a55dfbf95c6c91cec59ce3a34dd5e54519" translate="yes" xml:space="preserve">
          <source>File systems might vary in what encoding is to be used for filenames. Since this module has no way to actually figure out what the is correct it goes with the best guess which is to assume filenames are encoding according to the current locale. Users are advised to always specify UTF-8 as the locale charset.</source>
          <target state="translated">파일 시스템은 파일 이름에 사용할 인코딩이 다를 수 있습니다. 이 모듈은 실제로 올바른 것이 무엇인지 알아낼 방법이 없기 때문에 파일 이름이 현재 로케일에 따라 인코딩되고 있다고 가정하는 최선의 추측과 함께 진행됩니다. 사용자는 항상 로케일 문자 세트로 UTF-8을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa8c7530b6eaca2532adfa79d220d7c301f8b86e" translate="yes" xml:space="preserve">
          <source>File tests</source>
          <target state="translated">파일 테스트</target>
        </trans-unit>
        <trans-unit id="2e67adde1ffcac9182fdc414ea1c59b8537d99ba" translate="yes" xml:space="preserve">
          <source>File to output the results to instead of sending as an email. Useful particularly when running perlbug on a machine with no direct internet connection.</source>
          <target state="translated">이메일로 보내지 않고 결과를 출력 할 파일입니다. 인터넷에 직접 연결되지 않은 컴퓨터에서 perlbug를 실행할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c4f076ba5b3985d1e9a4302dcb8d52cb294c95e" translate="yes" xml:space="preserve">
          <source>File to output the results to. Defaults to &lt;b&gt;perlbug.rep&lt;/b&gt;.</source>
          <target state="translated">결과를 출력 할 파일입니다. 기본값은 &lt;b&gt;perlbug.rep&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8524b9f3585575ad7dfc6698bc36a14994079bf5" translate="yes" xml:space="preserve">
          <source>File to save your history?</source>
          <target state="translated">역사를 저장하는 파일?</target>
        </trans-unit>
        <trans-unit id="1e509862932466ee82e463191172e37b3cea6512" translate="yes" xml:space="preserve">
          <source>File type -- numeric, but comparable to exported constants -- see Archive::Tar's documentation</source>
          <target state="translated">파일 유형-숫자이지만 내 보낸 상수와 비교 가능-Archive :: Tar의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb575a41b8c42befee7e0cd23f0879559755be1" translate="yes" xml:space="preserve">
          <source>File type constants. Returned by &lt;code&gt;GetFileType&lt;/code&gt;.</source>
          <target state="translated">파일 유형 상수. &lt;code&gt;GetFileType&lt;/code&gt; 에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="568294b0f0962c9dce2ed86a0644f0e488d0d8e1" translate="yes" xml:space="preserve">
          <source>File/Spec.pm</source>
          <target state="translated">File/Spec.pm</target>
        </trans-unit>
        <trans-unit id="0197048641dc3512ca3dbea2bb733e20d4882d0f" translate="yes" xml:space="preserve">
          <source>File::Basename</source>
          <target state="translated">File::Basename</target>
        </trans-unit>
        <trans-unit id="7643855ad41fd167cd1d19d2fc94a1d9a81f520d" translate="yes" xml:space="preserve">
          <source>File::Basename - Parse file paths into directory, filename and suffix.</source>
          <target state="translated">File :: Basename-파일 경로를 디렉토리, 파일 이름 및 접미사로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a8d61a1262a25e3e4a3b5f743fafe0ce5ae8780f" translate="yes" xml:space="preserve">
          <source>File::Compare</source>
          <target state="translated">File::Compare</target>
        </trans-unit>
        <trans-unit id="d243fbac9648f0d6978bc733f70a7d07c623feba" translate="yes" xml:space="preserve">
          <source>File::Compare - Compare files or filehandles</source>
          <target state="translated">File :: Compare-파일 또는 파일 핸들 비교</target>
        </trans-unit>
        <trans-unit id="fb8db5002f44755b6149a0ab982916a8075daf8b" translate="yes" xml:space="preserve">
          <source>File::Compare was written by Nick Ing-Simmons. Its original documentation was written by Chip Salzenberg.</source>
          <target state="translated">File :: Compare는 Nick Ing-Simmons에 의해 작성되었습니다. 원본 문서는 Chip Salzenberg가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="e84e49c86f519c366047d4a68a91823d7167c285" translate="yes" xml:space="preserve">
          <source>File::Compare::cmp is a synonym for File::Compare::compare. It is exported from File::Compare only by request.</source>
          <target state="translated">File :: Compare :: cmp는 File :: Compare :: compare와 동의어입니다. 요청한 경우에만 File :: Compare에서 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="cced95c8b6209ce495a6cd5c577674c5e6e53b3a" translate="yes" xml:space="preserve">
          <source>File::Compare::compare and its sibling functions return 0 if the files are equal, 1 if the files are unequal, or -1 if an error was encountered.</source>
          <target state="translated">File :: Compare :: compare 및 형제 함수는 파일이 같으면 0을, 파일이 같지 않으면 1을, 오류가 발생한 경우 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="def94ece5481d3beb5558118d685c1a96647aecc" translate="yes" xml:space="preserve">
          <source>File::Compare::compare_text does a line by line comparison of the two files. It stops as soon as a difference is detected. compare_text() accepts an optional third argument: This must be a CODE reference to a line comparison function, which returns 0 when both lines are considered equal. For example:</source>
          <target state="translated">File :: Compare :: compare_text는 두 파일을 한 줄씩 비교합니다. 차이가 감지되는 즉시 중지됩니다. compare_text ()는 선택적 세 번째 인수를 허용합니다. 이것은 행 비교 함수에 대한 CODE 참조 여야합니다. 두 행이 모두 동일하다고 간주되면 0을 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc3cb79c7383464148f9e6e9b35dc66828ee89ef" translate="yes" xml:space="preserve">
          <source>File::Copy</source>
          <target state="translated">File::Copy</target>
        </trans-unit>
        <trans-unit id="054808322e1fad4b177e7be1b21dbd651d7b51df" translate="yes" xml:space="preserve">
          <source>File::Copy - Copy files or filehandles</source>
          <target state="translated">File :: Copy-파일 또는 파일 핸들 복사</target>
        </trans-unit>
        <trans-unit id="f2e6bb244559c9a61df5a32393bbd55e499cf28c" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt; .</source>
          <target state="translated">File :: Copy는 또한 &lt;code&gt;syscopy&lt;/code&gt; 루틴을 제공합니다 .이 루틴은 첫 번째 매개 변수에 지정된 파일을 두 번째 매개 변수에 지정된 파일에 복사하여 OS 별 속성 및 파일 구조를 유지합니다. Unix 시스템의 경우 이는 OS 별 속성을 유지하지 않는 간단한 &lt;code&gt;copy&lt;/code&gt; 루틴 과 동일 합니다. VMS 시스템의 경우 &lt;code&gt;rmscopy&lt;/code&gt; 루틴을 호출합니다 (아래 참조). OS / 2 시스템의 경우 &lt;code&gt;syscopy&lt;/code&gt; XSUB를 직접 호출합니다 . Win32 시스템의 경우 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="54b31fb1c73438315d9d76e490580acedf76b91a" translate="yes" xml:space="preserve">
          <source>File::Copy also provides the &lt;code&gt;syscopy&lt;/code&gt; routine, which copies the file specified in the first parameter to the file specified in the second parameter, preserving OS-specific attributes and file structure. For Unix systems, this is equivalent to the simple &lt;code&gt;copy&lt;/code&gt; routine, which doesn't preserve OS-specific attributes. For VMS systems, this calls the &lt;code&gt;rmscopy&lt;/code&gt; routine (see below). For OS/2 systems, this calls the &lt;code&gt;syscopy&lt;/code&gt; XSUB directly. For Win32 systems, this calls &lt;code&gt;Win32::CopyFile&lt;/code&gt;.</source>
          <target state="translated">File :: Copy는 또한 첫 번째 매개 변수에 지정된 파일을 두 번째 매개 변수에 지정된 파일에 복사하여 OS 별 속성 및 파일 구조를 유지 하는 &lt;code&gt;syscopy&lt;/code&gt; 루틴을 제공합니다 . Unix 시스템의 경우 이는 OS 별 속성을 보존하지 않는 단순 &lt;code&gt;copy&lt;/code&gt; 루틴 과 동일 합니다. VMS 시스템의 경우 &lt;code&gt;rmscopy&lt;/code&gt; 루틴을 호출합니다 (아래 참조). OS / 2 시스템의 경우 &lt;code&gt;syscopy&lt;/code&gt; XSUB를 직접 호출합니다 . Win32 시스템의 경우 &lt;code&gt;Win32::CopyFile&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="67f88864b88bba7acff99452234fd97bf0f47f99" translate="yes" xml:space="preserve">
          <source>File::Copy was written by Aaron Sherman</source>
          <target state="translated">File :: Copy는 Aaron Sherman에 의해 작성되었습니다</target>
        </trans-unit>
        <trans-unit id="f01a5358f4ca69063ca392607e003dc733b2597f" translate="yes" xml:space="preserve">
          <source>File::DosGlob</source>
          <target state="translated">File::DosGlob</target>
        </trans-unit>
        <trans-unit id="5c17116d51c1f03e40c8b694ba6c585eabe2a321" translate="yes" xml:space="preserve">
          <source>File::DosGlob - DOS like globbing and then some</source>
          <target state="translated">File :: DosGlob-DOS와 같은 DOS</target>
        </trans-unit>
        <trans-unit id="bfa471141e1f7096bf78ca1f82e51c1164281798" translate="yes" xml:space="preserve">
          <source>File::Fetch</source>
          <target state="translated">File::Fetch</target>
        </trans-unit>
        <trans-unit id="dcff4894464604256beca2d13f60a2e0200dbabf" translate="yes" xml:space="preserve">
          <source>File::Fetch - A generic file fetching mechanism</source>
          <target state="translated">File :: Fetch-일반 파일 가져 오기 메커니즘</target>
        </trans-unit>
        <trans-unit id="c8dc9651ac05b80071b1feb534cf5a5de8f9de03" translate="yes" xml:space="preserve">
          <source>File::Fetch is a generic file fetching mechanism.</source>
          <target state="translated">File :: Fetch는 일반적인 파일 가져 오기 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="2cb1276427ae5064c5b11d564d8f990a7923f8fb" translate="yes" xml:space="preserve">
          <source>File::Fetch is able to fetch a variety of uris, by using several external programs and modules.</source>
          <target state="translated">File :: Fetch는 여러 외부 프로그램 및 모듈을 사용하여 다양한 URI를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="652b8a474fd7bf89a6c10654387f68b029ba4afc" translate="yes" xml:space="preserve">
          <source>File::Find</source>
          <target state="translated">File::Find</target>
        </trans-unit>
        <trans-unit id="dabbc689655c180a270054bdf94079c67c56996d" translate="yes" xml:space="preserve">
          <source>File::Find - Traverse a directory tree.</source>
          <target state="translated">File :: Find-디렉토리 트리를 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="602f452d2b6cab137b630932705ec11b4fbc5825" translate="yes" xml:space="preserve">
          <source>File::Find used to produce incorrect results if called recursively. During the development of perl 5.8 this bug was fixed. The first fixed version of File::Find was 1.01.</source>
          <target state="translated">File :: Find를 재귀 적으로 호출하면 잘못된 결과를 생성하는 데 사용됩니다. perl 5.8을 개발하는 동안이 버그가 수정되었습니다. File :: Find의 첫 번째 고정 버전은 1.01입니다.</target>
        </trans-unit>
        <trans-unit id="cf7493e2714621d4472c83b7fb17367a3f07e0e0" translate="yes" xml:space="preserve">
          <source>File::Find::Rule</source>
          <target state="translated">File::Find::Rule</target>
        </trans-unit>
        <trans-unit id="fdabb48d19b73dd4070bb82d3a9c90ab1b81880a" translate="yes" xml:space="preserve">
          <source>File::Glob</source>
          <target state="translated">File::Glob</target>
        </trans-unit>
        <trans-unit id="8d9f792f087977bcc4f2c40334cf6983814a1f4b" translate="yes" xml:space="preserve">
          <source>File::Glob - Perl extension for BSD glob routine</source>
          <target state="translated">File :: Glob-BSD glob 루틴을위한 Perl 확장</target>
        </trans-unit>
        <trans-unit id="5c88309ce18d22b575a2e92f21ed146adc833a5f" translate="yes" xml:space="preserve">
          <source>File::Glob::bsd_glob() implements the FreeBSD glob(3) routine, which is a superset of the POSIX glob() (described in IEEE Std 1003.2 &quot;POSIX.2&quot;). bsd_glob() takes a mandatory &lt;code&gt;pattern&lt;/code&gt; argument, and an optional &lt;code&gt;flags&lt;/code&gt; argument, and returns a list of filenames matching the pattern, with interpretation of the pattern modified by the &lt;code&gt;flags&lt;/code&gt; variable.</source>
          <target state="translated">File :: Glob :: bsd_glob ()는 FreeBSD glob (3) 루틴을 구현합니다. FreeBSD glob (3) 루틴은 POSIX glob ()의 상위 세트입니다 (IEEE Std 1003.2 &quot;POSIX.2&quot;에 설명되어 있음). bsd_glob ()는 필수 &lt;code&gt;pattern&lt;/code&gt; 인수와 선택적 &lt;code&gt;flags&lt;/code&gt; 인수를 사용하고 &lt;code&gt;flags&lt;/code&gt; 변수에 의해 수정 된 패턴을 해석하여 패턴과 일치하는 파일 이름 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f87067e2d659155bfc6a9854ce51bc4675107538" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() was removed</source>
          <target state="translated">File :: Glob :: glob ()이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="1d1ec8d2c1b6a1f048a3125e50262ab2025f6341" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() will disappear</source>
          <target state="translated">File :: Glob :: glob ()이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="53041d7596d97d11a152927840695227b7f906a6" translate="yes" xml:space="preserve">
          <source>File::Glob::glob() will disappear in perl 5.30. Use File::Glob::bsd_glob() instead.</source>
          <target state="translated">File :: Glob :: glob ()은 perl 5.30에서 사라집니다. 대신 File :: Glob :: bsd_glob ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca454d7c1a5b19f064af8b037120ba60d6c7a525" translate="yes" xml:space="preserve">
          <source>File::GlobMapper</source>
          <target state="translated">File::GlobMapper</target>
        </trans-unit>
        <trans-unit id="7f7d175bf488aed0eb444cb11c08455ad8599ba6" translate="yes" xml:space="preserve">
          <source>File::GlobMapper - Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">File :: GlobMapper-입력 및 출력 파일을 허용하도록 파일 Glob 확장</target>
        </trans-unit>
        <trans-unit id="1ee8431a726a8a5ed8c4e143748ae9ecf3b924c2" translate="yes" xml:space="preserve">
          <source>File::Path</source>
          <target state="translated">File::Path</target>
        </trans-unit>
        <trans-unit id="1686306ed7a2e3c93f30ae5144bea665fa4f6ad8" translate="yes" xml:space="preserve">
          <source>File::Path - Create or remove directory trees</source>
          <target state="translated">File :: Path-디렉토리 트리 작성 또는 제거</target>
        </trans-unit>
        <trans-unit id="e96111b9d00440bfa3194f5f2b0d6ee8ef1d305a" translate="yes" xml:space="preserve">
          <source>File::Path::Tiny</source>
          <target state="translated">File::Path::Tiny</target>
        </trans-unit>
        <trans-unit id="a4ef679a008a6f84865a9e072a31d15ade694f3b" translate="yes" xml:space="preserve">
          <source>File::Remove</source>
          <target state="translated">File::Remove</target>
        </trans-unit>
        <trans-unit id="315013b7403b971bbccc00acbcaa29af9f35ca59" translate="yes" xml:space="preserve">
          <source>File::Spec</source>
          <target state="translated">File::Spec</target>
        </trans-unit>
        <trans-unit id="e03ff856a0868930dbc9cd6d64ff461d1bdaaabc" translate="yes" xml:space="preserve">
          <source>File::Spec &amp;lt;= 0.83 has a bug where the file part of catfile is not canonicalized. This override fixes that bug.</source>
          <target state="translated">File :: Spec &amp;lt;= 0.83에는 catfile의 파일 부분이 정규화되지 않은 버그가 있습니다. 이 재정의는 해당 버그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5c2545f01462091353041ce999852a980063ef93" translate="yes" xml:space="preserve">
          <source>File::Spec - portably perform operations on file names</source>
          <target state="translated">File :: Spec-파일 이름에 대한 작업을 이식 가능하게 수행</target>
        </trans-unit>
        <trans-unit id="9959b013bbb548a84f49a147644db4f6f8b5d759" translate="yes" xml:space="preserve">
          <source>File::Spec for AmigaOS</source>
          <target state="translated">파일 :: 아미가 OS 사양</target>
        </trans-unit>
        <trans-unit id="377c35de2ed196f9c5385b1edfdc4eb6ca2a2256" translate="yes" xml:space="preserve">
          <source>File::Spec for Mac OS (Classic)</source>
          <target state="translated">Mac OS 용 File :: Spec (클래식)</target>
        </trans-unit>
        <trans-unit id="e9dc37ac681ea880968c6d2c9418018b55ac8a4a" translate="yes" xml:space="preserve">
          <source>File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">Unix 용 File :: Spec, 다른 File :: Spec 모듈의 기본</target>
        </trans-unit>
        <trans-unit id="2230f7295f7621836cbf459a68fa7d245b56ed9e" translate="yes" xml:space="preserve">
          <source>File::Spec should now recognise an Amiga style absolute path as well as an Unix style one. Relative paths must always be Unix style.</source>
          <target state="translated">File :: Spec은 이제 Amiga 스타일의 절대 경로와 Unix 스타일의 절대 경로를 인식해야합니다. 상대 경로는 항상 Unix 스타일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d3e2d6a2a684c855af3654d42b2d52642b0b206" translate="yes" xml:space="preserve">
          <source>File::Spec wrappers</source>
          <target state="translated">File :: Spec 래퍼</target>
        </trans-unit>
        <trans-unit id="57d505f90f23c581eff3d8fd504c98b55b80e3f3" translate="yes" xml:space="preserve">
          <source>File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2, File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker</source>
          <target state="translated">파일 :: Spec, 파일 :: Spec :: Unix, 파일 :: Spec :: Mac, 파일 :: Spec :: OS2, 파일 :: Spec :: Win32, 파일 :: Spec :: VMS, ExtUtils :: MakeMaker</target>
        </trans-unit>
        <trans-unit id="6d1ab27caf0a586b7f11d8ddbe66da5da11dfe66" translate="yes" xml:space="preserve">
          <source>File::Spec::AmigaOS</source>
          <target state="translated">File::Spec::AmigaOS</target>
        </trans-unit>
        <trans-unit id="f6e69f2aec454b070b65436d8f6402978ebd5c22" translate="yes" xml:space="preserve">
          <source>File::Spec::AmigaOS - File::Spec for AmigaOS</source>
          <target state="translated">File::Spec::AmigaOS - File::Spec for AmigaOS</target>
        </trans-unit>
        <trans-unit id="641add72b7fdbf25abb0c07f6fb8252f0c914b3a" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin</source>
          <target state="translated">File::Spec::Cygwin</target>
        </trans-unit>
        <trans-unit id="cdfed1a8102059cb23af35a0f86b67871164f579" translate="yes" xml:space="preserve">
          <source>File::Spec::Cygwin - methods for Cygwin file specs</source>
          <target state="translated">File :: Spec :: Cygwin-Cygwin 파일 스펙에 대한 메소드</target>
        </trans-unit>
        <trans-unit id="e72fdb6ea5dc0105bf8962f6650693bd46fc1242" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc</source>
          <target state="translated">File::Spec::Epoc</target>
        </trans-unit>
        <trans-unit id="eb8693815ec649d283b89619fb500489b50c284c" translate="yes" xml:space="preserve">
          <source>File::Spec::Epoc - methods for Epoc file specs</source>
          <target state="translated">File :: Spec :: Epoc-Epoc 파일 스펙을위한 메소드</target>
        </trans-unit>
        <trans-unit id="58ab258073f8844f58a13c0e540afd7c70528044" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions</source>
          <target state="translated">File::Spec::Functions</target>
        </trans-unit>
        <trans-unit id="5200acce0e1b5700ec3f6c1ce8b085a9594ec913" translate="yes" xml:space="preserve">
          <source>File::Spec::Functions - portably perform operations on file names</source>
          <target state="translated">File :: Spec :: Functions-파일 이름에 대한 작업을 이식 가능하게 수행</target>
        </trans-unit>
        <trans-unit id="fc6db1e1b5de7797ac516f96a446cab61cfc0d6a" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac</source>
          <target state="translated">File::Spec::Mac</target>
        </trans-unit>
        <trans-unit id="d79a8c64b96c6d94516d88b113e5eac3b9da4ad8" translate="yes" xml:space="preserve">
          <source>File::Spec::Mac - File::Spec for Mac OS (Classic)</source>
          <target state="translated">File :: Spec :: Mac-File :: Spec for Mac OS (클래식)</target>
        </trans-unit>
        <trans-unit id="dd2e7ffeaaea8af26591abffe1ee1b6f540db20c" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2</source>
          <target state="translated">File::Spec::OS2</target>
        </trans-unit>
        <trans-unit id="40e2993be3fcfb49e9dff0bf954a4b4fc18277d7" translate="yes" xml:space="preserve">
          <source>File::Spec::OS2 - methods for OS/2 file specs</source>
          <target state="translated">File :: Spec :: OS2-OS / 2 파일 스펙을위한 메소드</target>
        </trans-unit>
        <trans-unit id="f7a8d4f1ec9c1ccc3e150ac09fa9f67a10dfcb83" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix</source>
          <target state="translated">File::Spec::Unix</target>
        </trans-unit>
        <trans-unit id="0d7acdcbd611107237cca4df6cbd4c594405934d" translate="yes" xml:space="preserve">
          <source>File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules</source>
          <target state="translated">File :: Spec :: Unix-File :: Spec Unix 용, 다른 File :: Spec 모듈 용 기본</target>
        </trans-unit>
        <trans-unit id="bf21f77214d880322c14e8ee35bc09087fde112d" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS</source>
          <target state="translated">File::Spec::VMS</target>
        </trans-unit>
        <trans-unit id="c14aa057f43f4a505144d4210ab15e571114fe16" translate="yes" xml:space="preserve">
          <source>File::Spec::VMS - methods for VMS file specs</source>
          <target state="translated">File :: Spec :: VMS-VMS 파일 스펙에 대한 메소드</target>
        </trans-unit>
        <trans-unit id="2822248f9e471c31171c089c3fdd48b3debb74f9" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32</source>
          <target state="translated">File::Spec::Win32</target>
        </trans-unit>
        <trans-unit id="080364c33593182b7f7f657492fb3b2d46eb857c" translate="yes" xml:space="preserve">
          <source>File::Spec::Win32 - methods for Win32 file specs</source>
          <target state="translated">File :: Spec :: Win32-Win32 파일 사양의 메소드</target>
        </trans-unit>
        <trans-unit id="e0fd4afcd716107e17e677aa59b46d6470fb899a" translate="yes" xml:space="preserve">
          <source>File::Temp</source>
          <target state="translated">File::Temp</target>
        </trans-unit>
        <trans-unit id="3fe450162cf54232d01afd15746195856bbdbb84" translate="yes" xml:space="preserve">
          <source>File::Temp - return name and handle of a temporary file safely</source>
          <target state="translated">File :: Temp-임시 파일의 이름과 핸들을 안전하게 반환</target>
        </trans-unit>
        <trans-unit id="d91ecfa6abec25b99ed11c8b2d5f3accbd385c89" translate="yes" xml:space="preserve">
          <source>File::chdir</source>
          <target state="translated">File::chdir</target>
        </trans-unit>
        <trans-unit id="e83a936a3382a41b1f3f93e3d07a775dcb299d22" translate="yes" xml:space="preserve">
          <source>File::stat</source>
          <target state="translated">File::stat</target>
        </trans-unit>
        <trans-unit id="9639e61c73c9c60e6cfa27fbe83124dab13c12b1" translate="yes" xml:space="preserve">
          <source>File::stat - by-name interface to Perl's built-in stat() functions</source>
          <target state="translated">File :: stat-Perl의 내장 stat () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="3aaa59844e5f806feadbfe38925fb866e1cd3f21" translate="yes" xml:space="preserve">
          <source>File::stat ignores VMS ACLs</source>
          <target state="translated">File :: stat는 VMS ACL을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="99fb53931e742958a9e4d829323954f481f89cc9" translate="yes" xml:space="preserve">
          <source>File::stat ignores use filetest 'access'</source>
          <target state="translated">File :: stat는 filetest 'access'사용을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ef5f659600c421b89a34289668dcda4b8fde8960" translate="yes" xml:space="preserve">
          <source>FileCache</source>
          <target state="translated">FileCache</target>
        </trans-unit>
        <trans-unit id="dd4dfad3675618140d4d83ded99b3dd8deb7df16" translate="yes" xml:space="preserve">
          <source>FileCache - keep more files open than the system permits</source>
          <target state="translated">FileCache-시스템이 허용하는 것보다 많은 파일을 열어 둡니다</target>
        </trans-unit>
        <trans-unit id="a5cc97ff5fda266750b3dee9900ddf98823854aa" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">FileCache는 파일을 닫아야하는 경우 현재 파일 오프셋을 저장하지 않습니다. 파일을 다시 열면 오프셋은 원래 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 파일 모드 에서 지정한대로 입니다. 이것은 버그로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e560be1c46271875fcf2c02c89a0fafd349042ff" translate="yes" xml:space="preserve">
          <source>FileCache does not store the current file offset if it finds it necessary to close a file. When the file is reopened, the offset will be as specified by the original &lt;code&gt;open&lt;/code&gt; file mode. This could be construed to be a bug.</source>
          <target state="translated">FileCache는 파일을 닫아야하는 경우 현재 파일 오프셋을 저장하지 않습니다. 파일이 다시 &lt;code&gt;open&lt;/code&gt; 오프셋은 원래 열린 파일 모드 에서 지정한대로 됩니다. 이것은 버그로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f533c3cd15e297fdf4aabaf6ece0f9c1be27a5" translate="yes" xml:space="preserve">
          <source>FileHandle</source>
          <target state="translated">FileHandle</target>
        </trans-unit>
        <trans-unit id="794819fbb3c9526c54cbc3cce598cbc494f7c4eb" translate="yes" xml:space="preserve">
          <source>FileHandle - supply object methods for filehandles</source>
          <target state="translated">FileHandle-파일 핸들을위한 객체 메소드 제공</target>
        </trans-unit>
        <trans-unit id="caccd2fd17d3701ac8d56515a20a8537c819133d" translate="yes" xml:space="preserve">
          <source>Filehandle %s opened only for input</source>
          <target state="translated">입력 용으로 만 열린 파일 핸들 % s</target>
        </trans-unit>
        <trans-unit id="452cce9d01c3fa809d5699a1472cfe4e819be842" translate="yes" xml:space="preserve">
          <source>Filehandle %s opened only for output</source>
          <target state="translated">출력용으로 만 열린 파일 핸들 % s</target>
        </trans-unit>
        <trans-unit id="843eb3eeb3ed68dd4ce2373716c6a0c575f1c73d" translate="yes" xml:space="preserve">
          <source>Filehandle %s reopened as %s only for input</source>
          <target state="translated">파일 핸들 % s이 (가) 입력 용으로 만 % s (으)로 다시 열렸습니다.</target>
        </trans-unit>
        <trans-unit id="fc7038d4dbae8378dfacc2e299daf12024b15451" translate="yes" xml:space="preserve">
          <source>Filehandle STDIN reopened as %s only for output</source>
          <target state="translated">파일 핸들 STDIN이 출력용으로 만 % s로 다시 열렸습니다.</target>
        </trans-unit>
        <trans-unit id="3e986485fa2d06cffe03b4cb5d722b8847e7c236" translate="yes" xml:space="preserve">
          <source>Filehandles</source>
          <target state="translated">Filehandles</target>
        </trans-unit>
        <trans-unit id="d3712e0344c29c9b6fcd8cd69a7b601cf8888c11" translate="yes" xml:space="preserve">
          <source>Filehandles into commands are also known as</source>
          <target state="translated">명령에 대한 파일 처리는 다음과 같이 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="745059e953a17e849a5f1d5cc58b8c65a4690f8b" translate="yes" xml:space="preserve">
          <source>Filehandles returned by these functions support the seekable methods.</source>
          <target state="translated">이러한 함수에 의해 반환 된 파일 핸들은 검색 가능한 메소드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d917728ca0ac0c4b9a39ce3d45425ec35d9ebdc0" translate="yes" xml:space="preserve">
          <source>Filename Case</source>
          <target state="translated">파일명 케이스</target>
        </trans-unit>
        <trans-unit id="fb7a4b255171595818c7e230dab6fcf171fbaa94" translate="yes" xml:space="preserve">
          <source>Filenames</source>
          <target state="translated">Filenames</target>
        </trans-unit>
        <trans-unit id="9fd1eebd086da1a91988827a7bacbfddddd4cb35" translate="yes" xml:space="preserve">
          <source>Filenames can be picked arbitrarily; &lt;code&gt;CPAN.pm&lt;/code&gt; always reads all files (in alphabetical order) and takes the key &lt;code&gt;match&lt;/code&gt; (see below in</source>
          <target state="translated">파일 이름은 임의로 선택할 수 있습니다. &lt;code&gt;CPAN.pm&lt;/code&gt; 는 항상 (알파벳 순서) 모든 파일을 읽고 키 소요 &lt;code&gt;match&lt;/code&gt; (아래 참조</target>
        </trans-unit>
        <trans-unit id="c9784173a96e4b1510622cabd6602208c753b868" translate="yes" xml:space="preserve">
          <source>Filenames with * and ? will be glob expanded.</source>
          <target state="translated">* 및?가 포함 된 파일 이름 glob 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5cddfd74101a38239a8348d8bb2b2793e6fb31" translate="yes" xml:space="preserve">
          <source>Fileno</source>
          <target state="translated">Fileno</target>
        </trans-unit>
        <trans-unit id="048ca477f6d313575e8e768358930dd94a0805a0" translate="yes" xml:space="preserve">
          <source>Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?</source>
          <target state="translated">가져 오려는 파일에 예약 문자 또는 비 ASCII 문자가 있습니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="119c6ebf5f034a0bdf47e2ccf4a4a00d52bae121" translate="yes" xml:space="preserve">
          <source>Files and Filesystems</source>
          <target state="translated">파일과 파일 시스템</target>
        </trans-unit>
        <trans-unit id="1b66cfb0249a670160094a9d9a1226caf17ef912" translate="yes" xml:space="preserve">
          <source>Files and I/O</source>
          <target state="translated">파일과 I / O</target>
        </trans-unit>
        <trans-unit id="dc090aa9a69fc8ac0e7b03719c86dccf85d1fb26" translate="yes" xml:space="preserve">
          <source>Files can be &quot;renamed&quot; between file systems and the file contents and some attributes will be moved. Directories can only be renamed within one file system. If there is already a file or directory named &lt;code&gt;$sNewName&lt;/code&gt;, then &lt;code&gt;MoveFile&lt;/code&gt; will fail.</source>
          <target state="translated">파일 시스템과 파일 내용간에 파일 이름이 &quot;이름 변경&quot;될 수 있으며 일부 속성이 이동됩니다. 디렉토리는 하나의 파일 시스템 내에서만 이름을 바꿀 수 있습니다. 이미 파일 또는 명명 된 디렉토리가있는 경우 &lt;code&gt;$sNewName&lt;/code&gt; 하고 &lt;code&gt;MoveFile&lt;/code&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5bcfdef82017aca1b62d322f75f45269c52cebb0" translate="yes" xml:space="preserve">
          <source>Files older than v2.0 will have the one of the version numbers &quot;-1&quot;, &quot;0&quot; or &quot;1&quot;. No minor number was used at that time.</source>
          <target state="translated">v2.0 이전의 파일은 버전 번호 &quot;-1&quot;, &quot;0&quot;또는 &quot;1&quot;중 하나입니다. 당시에는 마이너 번호가 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ce0b65cbec28e6a52a00f89d26a974e92b387838" translate="yes" xml:space="preserve">
          <source>Files opened without an encoding argument will be in UTF-8:</source>
          <target state="translated">인코딩 인수없이 열린 파일은 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="646de437489432c391060b841f63b51dd2e343a9" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt; -able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">&lt;code&gt;mmap()&lt;/code&gt; 하지 않은 파일 은 &lt;code&gt;:perlio&lt;/code&gt; 레이어 와 같이 동작합니다 . 쓰기를 위한 &lt;code&gt;mmap()&lt;/code&gt; 에는 추가적인 하우스 키핑 (파일 확장)이 필요하기 때문에 &lt;code&gt;:perlio&lt;/code&gt; 레이어 처럼 쓰기도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="24cde58079ede41bb0ed81d8b77089f0773128f0" translate="yes" xml:space="preserve">
          <source>Files which are not &lt;code&gt;mmap()&lt;/code&gt;-able revert to behaving like the &lt;code&gt;:perlio&lt;/code&gt; layer. Writes also behave like the &lt;code&gt;:perlio&lt;/code&gt; layer, as &lt;code&gt;mmap()&lt;/code&gt; for write needs extra house-keeping (to extend the file) which negates any advantage.</source>
          <target state="translated">&lt;code&gt;mmap()&lt;/code&gt; 하지 않은 파일 은 &lt;code&gt;:perlio&lt;/code&gt; 레이어 처럼 동작합니다 . 쓰기는 &lt;code&gt;mmap()&lt;/code&gt; for write가 추가 하우스 키핑 (파일 확장을 위해)이 필요하기 때문에 &lt;code&gt;:perlio&lt;/code&gt; 레이어 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="7adb6736cf2c9ae017b128f98738ffbae0e58655" translate="yes" xml:space="preserve">
          <source>Fill</source>
          <target state="translated">Fill</target>
        </trans-unit>
        <trans-unit id="a4b96b98ba0acc4a2c64164e14e7284859d739a2" translate="yes" xml:space="preserve">
          <source>Fill &lt;code&gt;sv&lt;/code&gt; with current working directory</source>
          <target state="translated">현재 작업 디렉토리로 &lt;code&gt;sv&lt;/code&gt; 채우기</target>
        </trans-unit>
        <trans-unit id="a624b168584689d4ad50d72852da812cefd7de42" translate="yes" xml:space="preserve">
          <source>Fill the sv with current working directory</source>
          <target state="translated">현재 작업 디렉토리로 sv을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="7c991b879751864162456f044ae4b061287a9ddd" translate="yes" xml:space="preserve">
          <source>Fill up memory with a byte pattern (a byte repeated over and over again) that hopefully catches attempts to access uninitialized memory.</source>
          <target state="translated">초기화되지 않은 메모리에 액세스하려는 시도를 잡아내는 바이트 패턴 (반복 반복되는 바이트)으로 메모리를 채우십시오.</target>
        </trans-unit>
        <trans-unit id="1caa98b8fe4b092dfaf90807d48e36c7313a1fe3" translate="yes" xml:space="preserve">
          <source>Filter DBM keys/values</source>
          <target state="translated">DBM 키 / 값 필터링</target>
        </trans-unit>
        <trans-unit id="49db338137c69e197263cbd2a2a02d160fa11306" translate="yes" xml:space="preserve">
          <source>Filter for DBM_Filter</source>
          <target state="translated">DBM_Filter에 대한 필터</target>
        </trans-unit>
        <trans-unit id="155bc63929438bf5891026e88a669c019cfee1eb" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match /(LIST|OF|PATTERNS)/. Note that with this form the patterns are joined by '|' and you cannot supply a list of files, instead the test files are obtained from the MANIFEST.</source>
          <target state="translated">모든 테스트 파일이 / (LIST | OF | PATTERNS) /와 일치하도록 파일 목록을 필터링하십시오. 이 형식에서 패턴은 '|'로 연결됩니다. 파일 목록을 제공 할 수 없으며 대신 MANIFEST에서 테스트 파일을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d5a596c0ce5a2b7a7aba6646e13f8fdc098b26bf" translate="yes" xml:space="preserve">
          <source>Filter the file list so that all the test files run match PATTERN. Note that this form is distinct from the &lt;b&gt;-re LIST OF PATTERNS&lt;/b&gt; form below in that it allows the file list to be provided as well.</source>
          <target state="translated">모든 테스트 파일이 PATTERN과 일치하도록 파일 목록을 필터링하십시오. 이 양식은 파일 목록도 제공 할 수 있다는 점에서 아래 &lt;b&gt;의 -re LIST OF PATTERNS&lt;/b&gt; 양식과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="42d3a31d1c9ff4adea6e61106fd398bfebcdb7bc" translate="yes" xml:space="preserve">
          <source>Filter::Simple</source>
          <target state="translated">Filter::Simple</target>
        </trans-unit>
        <trans-unit id="8902388c9d4dcc551448da4cca3d317ed63a6414" translate="yes" xml:space="preserve">
          <source>Filter::Simple - Simplified source filtering</source>
          <target state="translated">Filter :: Simple-단순화 된 소스 필터링</target>
        </trans-unit>
        <trans-unit id="4d594a2e8094dc15ca9e42ca0d84c3e0a33987d2" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;How it works&lt;/a&gt;) which would normally replace any &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple 은 일반적으로 명시 적으로 선언 한 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴을 대체 &lt;a href=&quot;#How-it-works&quot;&gt;하는&lt;/a&gt; 모듈에 대한 특수 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 서브 루틴 ( 작동 방식 참조 )을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="55a67bc6b5c9e931b9cfc1d00997088616960c2d" translate="yes" xml:space="preserve">
          <source>Filter::Simple generates a special &lt;code&gt;import&lt;/code&gt; subroutine for your module (see &lt;a href=&quot;#How-it-works&quot;&gt;&quot;How it works&quot;&lt;/a&gt;) which would normally replace any &lt;code&gt;import&lt;/code&gt; subroutine you might have explicitly declared.</source>
          <target state="translated">Filter :: Simple 은 일반적으로 명시 적으로 선언 한 &lt;code&gt;import&lt;/code&gt; 서브 루틴을 대체하는 모듈에 대한 특수 &lt;code&gt;import&lt;/code&gt; 서브 루틴을 생성합니다 ( &lt;a href=&quot;#How-it-works&quot;&gt;&quot;작동 방식&quot;참조&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="5b045aab2dc3c12f8983dd3d86529beb5ee5d291" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt; . For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple은 이제 Perl5-Porters에 의해 유지 보수됩니다. perl과 함께 제공 되는 &lt;code&gt;perlbug&lt;/code&gt; 도구를 통해 버그를 제출 하십시오. 사용법 지시 사항은 &lt;code&gt;perldoc perlbug&lt;/code&gt; 또는 &lt;code&gt;man perlbug&lt;/code&gt; 를 읽으십시오 . 대부분 다른 내용은 &amp;lt;perl5-porters@perl.org&amp;gt;에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="5efffe4d78970f8e0d9b73652dcdf366fc15a91e" translate="yes" xml:space="preserve">
          <source>Filter::Simple is now maintained by the Perl5-Porters. Please submit bug via the &lt;code&gt;perlbug&lt;/code&gt; tool that comes with your perl. For usage instructions, read &lt;code&gt;perldoc perlbug&lt;/code&gt; or possibly &lt;code&gt;man perlbug&lt;/code&gt;. For mostly anything else, please contact &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">Filter :: Simple은 이제 Perl5-Porters에 의해 유지됩니다. perl과 함께 제공 되는 &lt;code&gt;perlbug&lt;/code&gt; 도구를 통해 버그를 제출 하십시오. 사용 지침은 &lt;code&gt;perldoc perlbug&lt;/code&gt; 또는 &lt;code&gt;man perlbug&lt;/code&gt; 를 참조하십시오 . 대부분의 경우 &amp;lt;perl5-porters@perl.org&amp;gt;로 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="19879ac495533ad1077ba2c41a6a1388fc0daf98" translate="yes" xml:space="preserve">
          <source>Filter::Simple supports this type of filtering by automatically exporting the &lt;code&gt;FILTER_ONLY&lt;/code&gt; subroutine.</source>
          <target state="translated">Filter :: Simple은 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 서브 루틴 을 자동으로 내보내 이러한 유형의 필터링을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="7738927e99aa19b5661cca71074c5a3666ddd066" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call</source>
          <target state="translated">Filter::Util::Call</target>
        </trans-unit>
        <trans-unit id="7dc52ff0d48741e56609be222232752914b7f609" translate="yes" xml:space="preserve">
          <source>Filter::Util::Call - Perl Source Filter Utility Module</source>
          <target state="translated">Filter :: Util :: Call-펄 소스 필터 유틸리티 모듈</target>
        </trans-unit>
        <trans-unit id="04afd517e71c6ed7b121bd0e3b2068ee5c553269" translate="yes" xml:space="preserve">
          <source>Filter_Key_Push</source>
          <target state="translated">Filter_Key_Push</target>
        </trans-unit>
        <trans-unit id="2601ba4f6f8e8afb00fbd46ca3a26e97043b25fc" translate="yes" xml:space="preserve">
          <source>Filter_Push</source>
          <target state="translated">Filter_Push</target>
        </trans-unit>
        <trans-unit id="0a1a4c0dfa7b456e4ecab8567d85b94d3dafc1a1" translate="yes" xml:space="preserve">
          <source>Filter_Value_Push</source>
          <target state="translated">Filter_Value_Push</target>
        </trans-unit>
        <trans-unit id="0cabe77e4a0f9142f83082a357c9dd9516395a45" translate="yes" xml:space="preserve">
          <source>Filtering only specific components of source code</source>
          <target state="translated">소스 코드의 특정 구성 요소 만 필터링</target>
        </trans-unit>
        <trans-unit id="0d724af3cdfe968bbaf60122abf6756e0bff8902" translate="yes" xml:space="preserve">
          <source>Filtering only the code parts of source code</source>
          <target state="translated">소스 코드의 코드 부분 만 필터링</target>
        </trans-unit>
        <trans-unit id="064b3406638df42c905600b3e499487ada8eb46b" translate="yes" xml:space="preserve">
          <source>Filters Included</source>
          <target state="translated">포함 된 필터</target>
        </trans-unit>
        <trans-unit id="c7c6a6ca2fc222f307864374baefcbe6fd304196" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a DWIM-ish string equality or &lt;code&gt;undef&lt;/code&gt; test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">값 목록을 필터링하여 DWIM-ish 문자열 같음 또는 &lt;code&gt;undef&lt;/code&gt; 테스트 로 판단되는 후속 중복을 제거 합니다. 고유 한 요소의 순서를 유지하고 중복 집합의 첫 번째 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6f26bfb39da45fe446ab2ace33aa6a4dfb8d959e" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a numerical equality test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">수치 동등성 테스트로 판단한대로 값 목록을 필터링하여 후속 중복 항목을 제거합니다. 고유 한 요소의 순서를 유지하고 중복 집합의 첫 번째 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e2e1b8102595dc1b879e1156836436fadd592ceb" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by a string equality test. Preserves the order of unique elements, and retains the first value of any duplicate set.</source>
          <target state="translated">문자열 동등성 테스트에서 판단한대로 값 목록을 필터링하여 후속 중복을 제거합니다. 고유 한 요소의 순서를 유지하고 중복 집합의 첫 번째 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="700795207cadfd27a83211dfeea9a61a315dd6d9" translate="yes" xml:space="preserve">
          <source>Filters a list of values to remove subsequent duplicates, as judged by an integer numerical equality test. Preserves the order of unique elements, and retains the first value of any duplicate set. Values in the returned list will be coerced into integers.</source>
          <target state="translated">정수 수치 동등성 테스트에서 판단한대로 값 목록을 필터링하여 후속 중복 항목을 제거합니다. 고유 한 요소의 순서를 유지하고 중복 집합의 첫 번째 값을 유지합니다. 반환 된 목록의 값은 정수로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5a48634134a41cfb47919ca0620c4a4eb370a44f" translate="yes" xml:space="preserve">
          <source>Filters can be created in two main ways</source>
          <target state="translated">필터는 두 가지 주요 방법으로 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3f0a8fb43e79067faffa3f02bee42380f1453b8" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt; .</source>
          <target state="translated">모든 것을 필터링합니다. &lt;code&gt;FILTER&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2bbcb71b4ba53e50f605e87980abfc0509da65aa" translate="yes" xml:space="preserve">
          <source>Filters everything. Identical in effect to &lt;code&gt;FILTER&lt;/code&gt;.</source>
          <target state="translated">모든 것을 필터링합니다. &lt;code&gt;FILTER&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dff7559e7e19f13b99b80c4310a808291f2993fd" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; 의해 해석되는 것처럼 Perl 인용 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="afc20f79a9a572c35fd24561f6a83d84c1928e1a" translate="yes" xml:space="preserve">
          <source>Filters only Perl quotelikes (as interpreted by &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt;).</source>
          <target state="translated">Perl 인용구 만 필터링합니다 ( &lt;code&gt;&amp;amp;Text::Balanced::extract_quotelike&lt;/code&gt; 로 해석 됨 ).</target>
        </trans-unit>
        <trans-unit id="d46715be5a6c7c637a101bd3fb514ca34a022fd4" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the first half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl 인용문의 패턴 리터럴 부분 만 필터링합니다 (예 : &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 의 첫 번째 절반 인 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 의 내용 ).</target>
        </trans-unit>
        <trans-unit id="d870e55b5ec07b87a5f7e4519042304d42ec2f31" translate="yes" xml:space="preserve">
          <source>Filters only the pattern literal parts of a Perl quotelike (i.e. the contents of a &lt;code&gt;qr//&lt;/code&gt; or an &lt;code&gt;m//&lt;/code&gt;, the first half of an &lt;code&gt;s///&lt;/code&gt;).</source>
          <target state="translated">Perl quotelike의 패턴 리터럴 부분 만 필터링합니다 (예 : &lt;code&gt;qr//&lt;/code&gt; 또는 &lt;code&gt;m//&lt;/code&gt; 의 내용 , &lt;code&gt;s///&lt;/code&gt; 전반부 ).</target>
        </trans-unit>
        <trans-unit id="9d6c7da3a59381ce364937477b0de797b35ca66f" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;, the second half of an &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Perl 인용문의 문자열 리터럴 부분 만 필터링합니다 (즉, 문자열 리터럴의 내용, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 의 절반, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 후반 ).</target>
        </trans-unit>
        <trans-unit id="20f3795aaefe54c90ea0bd4135d4048324d2a28b" translate="yes" xml:space="preserve">
          <source>Filters only the string literal parts of a Perl quotelike (i.e. the contents of a string literal, either half of a &lt;code&gt;tr///&lt;/code&gt;, the second half of an &lt;code&gt;s///&lt;/code&gt;).</source>
          <target state="translated">Perl quotelike의 문자열 리터럴 부분 만 필터링합니다 (즉, 문자열 리터럴의 내용, &lt;code&gt;tr///&lt;/code&gt; 의 절반, &lt;code&gt;s///&lt;/code&gt; 후반부 ).</target>
        </trans-unit>
        <trans-unit id="21c3fceb1f21a8d2c7a7604d5f15909ba3c4e6bc" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="2dd5107f13a5a36c0e20ccaa94005d515585510f" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="8d0e4690844c0e997ddfae93ebb04be08becd5b9" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="63d1267df0fbacd4b2081c851758f74bcc49c06b" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="73c4703434d54b35a96afa23550eee383050c8e7" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">인용 부호, POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="67191f1183b6941ed0c22be475d8782510da690a" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, comments, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">인용 부호, POD, 주석 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="6768e7cdb67b7548d17f5b47c853204a354ef8a8" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">인용 부호, POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드의 해당 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="58ed29de26d37c777bddc03a8e289c5c5c06ef78" translate="yes" xml:space="preserve">
          <source>Filters only those sections of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">인용 부호, POD 또는 &lt;code&gt;__DATA__&lt;/code&gt; 가 아닌 소스 코드 섹션 만 필터링 합니다.</target>
        </trans-unit>
        <trans-unit id="a835e84e6476a3627bf2cb0ac10839ce913c16ff" translate="yes" xml:space="preserve">
          <source>Final $ should be \$ or $name</source>
          <target state="translated">마지막 $는 \ $ 또는 $ name이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c5efd60aef7150698692bd9522cefaa126df2ec" translate="yes" xml:space="preserve">
          <source>Finally there is the 'default', and the related 'default_get' and 'default_set' options. These options control the &quot;default&quot; object which is provided by the class interface to the methods. Setting &lt;code&gt;default_get&lt;/code&gt; to true tells the constructor to return the default object if it is defined. Setting &lt;code&gt;default_set&lt;/code&gt; to true tells the constructor to make the default object the constructed object. Setting the &lt;code&gt;default&lt;/code&gt; option is like setting both to true. This is used primarily internally and probably isn't interesting to any real user.</source>
          <target state="translated">마지막으로 'default'와 관련 'default_get'및 'default_set'옵션이 있습니다. 이 옵션은 클래스 인터페이스가 메소드에 제공하는 &quot;기본&quot;오브젝트를 제어합니다. &lt;code&gt;default_get&lt;/code&gt; 을 true로 설정 하면 생성자가 기본 오브젝트가 정의 된 경우이를 리턴하도록 지시합니다. &lt;code&gt;default_set&lt;/code&gt; 을 true로 설정 하면 생성자가 기본 객체를 생성 된 객체로 만들도록 지시합니다. &lt;code&gt;default&lt;/code&gt; 옵션을 설정하는 것은 둘 다 true로 설정하는 것과 같습니다. 이것은 주로 내부적으로 사용되며 실제 사용자에게는 흥미가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b793b4c7037146e44c6ebbd985a0e8b5eea1bc2d" translate="yes" xml:space="preserve">
          <source>Finally,</source>
          <target state="translated">Finally,</target>
        </trans-unit>
        <trans-unit id="c007289d889b2ac012d30249ede8e24355c7610c" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; 은 웹 서버에 PSGI 미들웨어, 헬퍼 및 어댑터를 포함하는 Perl 모듈 및 툴킷 으로, 계속 실행할 수있는 스크립트를 쉽게 배포하고 사용하는 웹 서버와 관련하여 유연성을 제공합니다. 기존 CGI 스크립트는 최소한의 변경으로 이러한 유연성과 성능을 즐기거나 최신 Perl 웹 프레임 워크와 함께 사용하여 Perl을 사용하여 웹 서비스를 작성하고 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="458f93c6634aea5d4fadc6ced58e859af016d537" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; is a Perl module and toolkit that contains PSGI middleware, helpers and adapters to web servers, allowing you to easily deploy scripts which can continue running, and provides flexibility with regards to which web server you use. It can allow existing CGI scripts to enjoy this flexibility and performance with minimal changes, or can be used along with modern Perl web frameworks to make writing and deploying web services with Perl a breeze.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; 은 PSGI 미들웨어, 헬퍼 및 어댑터를 웹 서버에 포함하는 Perl 모듈 및 툴킷 으로, 계속 실행할 수있는 스크립트를 쉽게 배포 할 수 있으며 사용하는 웹 서버와 관련하여 유연성을 제공합니다. 기존 CGI 스크립트가 최소한의 변경으로 이러한 유연성과 성능을 즐길 수 있도록하거나 최신 Perl 웹 프레임 워크와 함께 사용하여 Perl로 웹 서비스를 쉽게 작성하고 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44941dad1d15df314302a9115d5bc5d8a2ec4415" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to a non-0 value if the external program</source>
          <target state="translated">마지막으로 &lt;code&gt;$?&lt;/code&gt; 외부 프로그램의 경우 0이 아닌 값으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec318bbb4a97f05c20b43c3d365fb178815d120" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$?&lt;/code&gt; may be set to non-0 value if the external program</source>
          <target state="translated">마지막으로 &lt;code&gt;$?&lt;/code&gt; 외부 프로그램 인 경우 0이 아닌 값으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92dd49b4407ac7414e31cf79437fb39879d44f34" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">마지막으로 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 은 참조를 정확하게 트래버스합니다.</target>
        </trans-unit>
        <trans-unit id="66c1abb8f12ea81297c1b86ceb245b7ba4213937" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">마지막으로 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용하십시오&lt;/a&gt; . 비트 연산자에도 영향을줍니다. 일반적으로 피연산자와 결과는 &lt;b&gt;부호없는&lt;/b&gt; 정수 로 처리 되지만 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 를 &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 합니다. 피연산자와 결과가 &lt;b&gt;서명&lt;/b&gt; 됩니다. 이는 무엇보다도 ~ 0이 -1이고 -2 &amp;amp; -5가 -6임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4298e2e9c529f41f2c9de7ef565329b328f06ed5" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;LC_CTYPE&lt;/code&gt; affects the (deprecated) POSIX character-class test functions--&lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; , and so on. For example, if you move from the &quot;C&quot; locale to a 7-bit ISO 646 one, you may find--possibly to your surprise--that &lt;code&gt;&quot;|&quot;&lt;/code&gt; moves from the &lt;code&gt;POSIX::ispunct()&lt;/code&gt; class to &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . Unfortunately, this creates big problems for regular expressions. &quot;|&quot; still means alternation even though it matches &lt;code&gt;\w&lt;/code&gt; . Starting in v5.22, a warning will be raised when such a locale is switched into. More details are given several paragraphs further down.</source>
          <target state="translated">마지막으로 &lt;code&gt;LC_CTYPE&lt;/code&gt; 은 (더 이상 사용되지 않는) POSIX 문자 클래스 테스트 함수 ( &lt;code&gt;POSIX::isalpha()&lt;/code&gt; , &lt;code&gt;POSIX::islower()&lt;/code&gt; 등 ) 에 영향을줍니다. 예를 들어 &quot;C&quot;로캘에서 7 비트 ISO 646 로캘로 이동하면 놀랍게도 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 로부터 이동 &lt;code&gt;POSIX::ispunct()&lt;/code&gt; 에 클래스 &lt;code&gt;POSIX::isalpha()&lt;/code&gt; . 불행히도 이것은 정규 표현식에 큰 문제를 일으 킵니다. &quot;|&quot; &lt;code&gt;\w&lt;/code&gt; 와 일치하더라도 대체를 의미 합니다. v5.22부터는 해당 로케일이 전환 될 때 경고가 발생합니다. 자세한 내용은 여러 단락을 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d41a6a4619356e1937fb9383734f7392b639a1de" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Perl_setlocale&lt;/code&gt; works under all circumstances, whereas plain &lt;code&gt;setlocale&lt;/code&gt; can be completely ineffective on some platforms under some configurations.</source>
          <target state="translated">마지막으로 &lt;code&gt;Perl_setlocale&lt;/code&gt; 은 모든 상황에서 작동하는 반면 일반 &lt;code&gt;setlocale&lt;/code&gt; 은 일부 구성에서 일부 플랫폼에서 완전히 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a072e67c07cec137145f02eb0728c6abe18c863" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;lock&lt;/code&gt; will traverse up references exactly</source>
          <target state="translated">마지막으로 &lt;code&gt;lock&lt;/code&gt; 은 참조를 정확하게 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="1e32346666d60836d8d3015ff2538a7278da0426" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;use integer;&lt;/code&gt; also has an additional affect on the bitwise operators. Normally, the operands and results are treated as &lt;b&gt;unsigned&lt;/b&gt; integers, but with &lt;code&gt;use integer;&lt;/code&gt; the operands and results are &lt;b&gt;signed&lt;/b&gt;. This means, among other things, that ~0 is -1, and -2 &amp;amp; -5 is -6.</source>
          <target state="translated">마지막으로 &lt;code&gt;use integer;&lt;/code&gt; 또한 비트 연산자에 추가 영향을 미칩니다. 일반적으로 피연산자와 결과는 &lt;b&gt;부호없는&lt;/b&gt; 정수 로 처리 되지만 &lt;code&gt;use integer;&lt;/code&gt; 를 사용합니다. 피연산자와 결과는 &lt;b&gt;서명&lt;/b&gt; 됩니다. 이것은 무엇보다도 ~ 0이 -1이고 -2 &amp;amp; -5가 -6임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="863cc6df01692aa36bb18136100716eadd4c9578" translate="yes" xml:space="preserve">
          <source>Finally, any other list of arguments is taken as a new list value for the KEY variable discarding the previous value.</source>
          <target state="translated">마지막으로, 다른 인수 목록은 이전 값을 버리는 KEY 변수의 새 목록 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5736dff3a318282c51e7671e4d8cd7e83294c7ec" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">마지막으로, 일반적으로 과도한 양의 마크 업을 사용하지 마십시오. 여기와 &lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man&lt;/a&gt; 에 문서화 된 것처럼 Perl 변수, 함수 이름, 맨 페이지 참조 등을 마크 업으로 장식하지 않고 안전하게 남겨 둘 수 있으며 POD 변환기가이를 알아낼 것입니다. 이렇게하면 나중에 문서를 훨씬 쉽게 편집 할 수 있습니다. 기존의 많은 번역자들이 L &amp;lt;&amp;gt;로 래핑 될 때 전자 메일 주소로 잘못된 작업을 수행하므로 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2782a08306f78a46a43ca3f4245df407dada422a" translate="yes" xml:space="preserve">
          <source>Finally, as a general note, try not to use an excessive amount of markup. As documented here and in &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt;, you can safely leave Perl variables, function names, man page references, and the like unadorned by markup and the POD translators will figure it out for you. This makes it much easier to later edit the documentation. Note that many existing translators will do the wrong thing with e-mail addresses when wrapped in L&amp;lt;&amp;gt;, so don't do that.</source>
          <target state="translated">마지막으로, 일반적으로 과도한 양의 마크 업을 사용하지 마십시오. 여기 및 &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; 에 설명 된대로 마크 업에 의해 비공식적으로 Perl 변수, 함수 이름, 매뉴얼 페이지 참조 등을 그대로두면 POD 번역가가이를 파악할 수 있습니다. 따라서 나중에 문서를 훨씬 쉽게 편집 할 수 있습니다. 기존의 많은 번역가들이 L &amp;lt;&amp;gt;에 싸여있을 때 전자 우편 주소로 잘못된 일을하므로 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="09dd5948c51d9dbe80c668a49680794506b31bfd" translate="yes" xml:space="preserve">
          <source>Finally, because Perl is frequently (but not always, and certainly not by definition) an interpreted language, you can write your programs and test them without an intermediate compilation step, allowing you to experiment and test/debug quickly and easily. This ease of experimentation flattens the learning curve even more.</source>
          <target state="translated">마지막으로 Perl은 해석 언어 인 경우가 많지만 (항상 그런 것은 아니며 정의에 의한 것은 아님) 중간 컴파일 단계없이 프로그램을 작성하고 테스트 할 수 있으므로 빠르고 쉽게 실험하고 테스트 / 디버그 할 수 있습니다. 이러한 실험의 용이성은 학습 곡선을 더욱 평평하게합니다.</target>
        </trans-unit>
        <trans-unit id="cc57fb18e220062e45c185e13f725e4b2cd6843f" translate="yes" xml:space="preserve">
          <source>Finally, create a Pull Request on GitHub from your branch to blead as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&lt;/a&gt;.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&lt;/a&gt; 의 GitHub 설명서에 설명 된대로 브랜치에서 blead로 GitHub에 Pull Request를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="4a510065fc482271aa62171fe6b3a6de41010a11" translate="yes" xml:space="preserve">
          <source>Finally, documentation intended for core Perl developers lives in the</source>
          <target state="translated">마지막으로 핵심 Perl 개발자를위한 문서는</target>
        </trans-unit>
        <trans-unit id="ef0d2a6fbc127dfe3fabf24f53dec0be787cb458" translate="yes" xml:space="preserve">
          <source>Finally, for backward (and we do mean &quot;backward&quot;) compatibility, Perl permits these unnecessary but widely-supported conversions:</source>
          <target state="translated">마지막으로, 이전 버전과의 호환성을 위해 Perl은 다음과 같이 불필요하지만 널리 지원되는 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b81575352f8aab412fd4cb07d0470076b14f1f18" translate="yes" xml:space="preserve">
          <source>Finally, here is yet another way to do comma-separated value parsing:</source>
          <target state="translated">마지막으로 쉼표로 구분 된 값 구문 분석을 수행하는 또 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="834a9815bc42b39ddd5279d8456b87a013959fa0" translate="yes" xml:space="preserve">
          <source>Finally, here's an example of the full typemap file for mapping C strings of the &lt;code&gt;char *&lt;/code&gt; type to Perl scalars/strings:</source>
          <target state="translated">마지막으로, &lt;code&gt;char *&lt;/code&gt; 타입 의 C 문자열 을 Perl 스칼라 / 문자열 에 매핑하기위한 전체 타입 맵 파일의 예입니다 :</target>
        </trans-unit>
        <trans-unit id="bba57917092f0217e7811ec4321a57605d773dd9" translate="yes" xml:space="preserve">
          <source>Finally, if the command line ends with '&amp;amp;', the entire command is run in the background as an asynchronous subprocess.</source>
          <target state="translated">마지막으로 명령 행이 '&amp;amp;'로 끝나면 전체 명령이 백그라운드에서 비동기 서브 프로세스로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e49365bee26ebdbc8e5446418348a20a97dc14c" translate="yes" xml:space="preserve">
          <source>Finally, if you feel like a real challenge, have a go at writing a full-blown Perl macro preprocessor as a source filter. Borrow the useful features from the C preprocessor and any other macro processors you know. The tricky bit will be choosing how much knowledge of Perl's syntax you want your filter to have.</source>
          <target state="translated">마지막으로, 실제 도전과 같은 느낌이 든다면 본격적인 Perl 매크로 프리 프로세서를 소스 필터로 작성하십시오. C 프리 프로세서와 알고있는 다른 매크로 프로세서에서 유용한 기능을 차용하십시오. 까다로운 부분은 필터에 원하는 Perl 구문에 대한 지식을 얼마나 많이 선택 하는가입니다.</target>
        </trans-unit>
        <trans-unit id="88728c279fead59f6cd8637f346aa4a89bc4ca1d" translate="yes" xml:space="preserve">
          <source>Finally, it searches down the C3 MRO list until it reaches the contextually enclosing class, then searches further down the MRO list for the next method with the same name as the contextually enclosing method.</source>
          <target state="translated">마지막으로, C3 MRO 목록이 컨텍스트로 둘러싸인 클래스에 도달 할 때까지 C3 MRO 목록을 검색 한 다음 컨텍스트로 묶는 메소드와 동일한 이름을 가진 다음 메소드에 대한 MRO 목록을 추가로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d8f4b0ff247923b3eb8f0e0514234b9fa893f6fd" translate="yes" xml:space="preserve">
          <source>Finally, it's possible to override localtime and gmtime everywhere, by including the ':override' tag in the import list:</source>
          <target state="translated">마지막으로 가져 오기 목록에 ': override'태그를 포함하여 모든 곳에서 localtime 및 gmtime을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5aad188b46d292eb5dea6e10dfb430bbcea6367" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that Perl might not be the right tool for every job. You're a much better advocate if your claims are reasonable and grounded in reality. Dogmatically advocating anything tends to make people discount your message. Be honest about possible disadvantages to your choice of Perl since any choice has trade-offs.</source>
          <target state="translated">마지막으로 Perl이 모든 작업에 적합한 도구는 아닙니다. 당신의 주장이 합리적이고 현실에 근거를 둔다면 훨씬 더 옹호자입니다. 독단적으로 옹호하는 것은 사람들이 귀하의 메시지를 할인하는 경향이 있습니다. 어떤 선택에도 타협이 있기 때문에 Perl 선택에 대한 가능한 단점에 대해 솔직하십시오.</target>
        </trans-unit>
        <trans-unit id="12d654760faef187bf9fcd2c080146c42b559499" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that subpatterns created inside a DEFINE block count towards the absolute and relative number of captures, so this:</source>
          <target state="translated">마지막으로 DEFINE 블록 내에서 생성 된 하위 패턴은 캡처의 절대 및 상대 수로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e50add68bf383c512c89d12d1f1fbdacf62aaedc" translate="yes" xml:space="preserve">
          <source>Finally, let's get those four fields. By now, you shouldn't have any problems with the first three fields - but how can we use the byte count of the data in the first field as a length for the data field? Here the codes &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; come to the rescue, as they permit jumping back and forth in the string to unpack.</source>
          <target state="translated">마지막으로,이 네 가지 분야를 살펴 보겠습니다. 지금까지 처음 세 필드에는 아무런 문제가 없어야합니다. 그러나 첫 번째 필드의 데이터 바이트 수를 데이터 필드의 길이로 어떻게 사용할 수 있습니까? 여기에서 코드 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;X&lt;/code&gt; 는 압축을 풀기 위해 현에서 앞뒤로 점프 할 수있게 해주므로 구조에옵니다.</target>
        </trans-unit>
        <trans-unit id="4c63136357795194b6348dcbe928896e7138655b" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">마지막으로 분해와 관련된 대부분의 속성은 &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bb929b935f9baf3ae2ecaa9eade20a81808b33d" translate="yes" xml:space="preserve">
          <source>Finally, most properties related to decomposition are accessible via &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;.</source>
          <target state="translated">마지막으로, 분해와 관련된 대부분의 속성은 &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de4b908f9ba516df7dd4589f61d68201fc354294" translate="yes" xml:space="preserve">
          <source>Finally, on NFS file systems the link count of the file handle does not always go to zero immediately after unlinking. Currently, this command is expected to fail on NFS disks.</source>
          <target state="translated">마지막으로 NFS 파일 시스템에서 파일 핸들의 링크 수는 링크 해제 직후에 항상 0이되지는 않습니다. 현재이 명령은 NFS 디스크에서 실패 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="c0056d49190cd844d22da94e2f6a73f54ba22274" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">마지막으로 루프가 종료되면 ( 큐에 0 또는 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가있어 종료 메모 역할을 함) 통지를 자식에게 전달하고 자식을 만든 경우 종료 될 때까지 기다립니다 ( 27 행 및 30 행).</target>
        </trans-unit>
        <trans-unit id="32fe94e035cd45ddddcda4070bc6753cb09716c1" translate="yes" xml:space="preserve">
          <source>Finally, once the loop terminates (because we got a 0 or &lt;code&gt;undef&lt;/code&gt; in the queue, which serves as a note to terminate), we pass on the notice to our child, and wait for it to exit if we've created a child (lines 27 and 30).</source>
          <target state="translated">마지막으로 루프가 종료되면 (종료 할 메모 역할을하는 대기열에 0 또는 &lt;code&gt;undef&lt;/code&gt; 가 있으므로) 알림을 자식에게 전달하고 자식을 만들었 으면 종료 될 때까지 기다립니다 ( 27 행과 30 행).</target>
        </trans-unit>
        <trans-unit id="d4b58a368a203e349112a813fb51574ad5df46e1" translate="yes" xml:space="preserve">
          <source>Finally, quoted strings cannot span multiple lines. The general rule is that the identifier must be a string literal. Stick with that, and you should be safe.</source>
          <target state="translated">마지막으로 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 없습니다. 일반적으로 식별자는 문자열 리터럴이어야합니다. 그걸 지키면 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="826093a59348aea220454d887a381ab8cec4085f" translate="yes" xml:space="preserve">
          <source>Finally, see the published Unicode Standard (page numbers are from version 6.0.0), including these specific annexes and technical reports:</source>
          <target state="translated">마지막으로 다음과 같은 별첨 및 기술 보고서를 포함하여 게시 된 유니 코드 표준 (페이지 번호는 버전 6.0.0)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e4fc718922fd33861fef8abc551f702371be5ab" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">마지막으로 일부 내장 (예 : &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )을 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0028dee23b87898288cc766ae53749c2f4ecb87" translate="yes" xml:space="preserve">
          <source>Finally, some built-ins (e.g. &lt;code&gt;exists&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;) can't be overridden.</source>
          <target state="translated">마지막으로 일부 내장 기능 (예 : &lt;code&gt;exists&lt;/code&gt; 또는 &lt;code&gt;grep&lt;/code&gt; )은 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbb0bc03e6c567aa9d048447baa9b177ddc77752" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;b&gt;-i&lt;/b&gt; switch does not impede execution when no files are given on the command line. In this case, no backup is made (the original file cannot, of course, be determined) and processing proceeds from STDIN to STDOUT as might be expected.</source>
          <target state="translated">마지막으로, &lt;b&gt;-i&lt;/b&gt; 스위치는 명령 행에 파일이 제공되지 않은 경우 실행을 방해하지 않습니다. 이 경우 백업이 작성되지 않고 (원래 파일을 결정할 수 없음) 예상대로 STDIN에서 STDOUT으로 처리가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="6e903744590309f2cbd34fe629a8e6cdbf621b80" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">마지막으로 &lt;code&gt;//&lt;/code&gt; 일치하는 기본 구분 기호는 &lt;code&gt;'m'&lt;/code&gt; 을 앞에 두어 임의의 구분 기호로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="042bc8fcc5c7d7efd6780c2133d47ab6beba3218" translate="yes" xml:space="preserve">
          <source>Finally, the Mytest.xs file should look something like this:</source>
          <target state="translated">마지막으로 Mytest.xs 파일은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c759b85c1874191b3c67e6077ecccb7f1cac3596" translate="yes" xml:space="preserve">
          <source>Finally, the Perl community as a whole recognizes that respect for ownership of code, respect for artistic control, proper credit, and active effort to prevent unintentional code skew or communication gaps is vital to the health of the community and Perl itself. Members of a community should not normally have to resort to rules and laws to deal with each other, and this document, although it contains rules so as to be clear, is about an attitude and general approach. The first step in any dispute should be open communication, respect for opposing views, and an attempt at a compromise. In nearly every circumstance nothing more will be necessary, and certainly no more drastic measure should be used until every avenue of communication and discussion has failed.</source>
          <target state="translated">마지막으로, Perl 커뮤니티는 코드 소유권에 대한 존중, 예술적 통제, 적절한 신용에 대한 존중 및 의도하지 않은 코드 왜곡 또는 의사 소통 격차를 방지하기위한 적극적인 노력이 커뮤니티와 Perl 자체의 건강에 매우 중요하다는 것을 인식합니다. 공동체 구성원은 일반적으로 서로를 다루기 위해 규칙과 법률에 의지 할 필요가 없으며,이 문서는 명확하게 규칙이 포함되어 있지만 태도와 일반적인 접근 방식에 관한 것입니다. 분쟁의 첫 단계는 공개 커뮤니케이션, 반대 의견에 대한 존중 및 타협 시도입니다. 거의 모든 상황에서 더 이상 필요한 것은 없으며, 의사 소통과 토론의 모든 길이 실패 할 때까지 더 이상 과감한 조치를 취해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="64c2b89b8066b657581a5a8b0c2006c676558b10" translate="yes" xml:space="preserve">
          <source>Finally, the context stack pointer is actually decremented by &lt;code&gt;CX_POP(cx)&lt;/code&gt;. After this point, it's possible that that the current context frame could be overwritten by other contexts being pushed. Although things like ties and &lt;code&gt;DESTROY&lt;/code&gt; are supposed to work within a new context stack, it's best not to assume this. Indeed on debugging builds, &lt;code&gt;CX_POP(cx)&lt;/code&gt; deliberately sets &lt;code&gt;cx&lt;/code&gt; to null to detect code that is still relying on the field values in that context frame. Note in the &lt;code&gt;pp_leavesub()&lt;/code&gt; example above, we grab &lt;code&gt;blk_sub.retop&lt;/code&gt;</source>
          <target state="translated">마지막으로 컨텍스트 스택 포인터는 실제로 &lt;code&gt;CX_POP(cx)&lt;/code&gt; 의해 감소합니다 . 이 시점 이후에는 푸시되는 다른 컨텍스트가 현재 컨텍스트 프레임을 덮어 쓸 수 있습니다. ties 및 &lt;code&gt;DESTROY&lt;/code&gt; 와 같은 것들은 새로운 컨텍스트 스택 내에서 작동해야 하지만 이것을 가정하지 않는 것이 가장 좋습니다. 실제로 디버깅 빌드에서 &lt;code&gt;CX_POP(cx)&lt;/code&gt; 는 해당 컨텍스트 프레임의 필드 값에 여전히 의존하는 코드를 감지하기 위해 의도적으로 &lt;code&gt;cx&lt;/code&gt; 를 null로 설정합니다 . 위 의 &lt;code&gt;pp_leavesub()&lt;/code&gt; 예제 에서 blk_sub.retop 을 가져 &lt;code&gt;blk_sub.retop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73b5ad0b05d4d0374aa60aaf0eda94d058db5ae7" translate="yes" xml:space="preserve">
          <source>Finally, the documentation. The job is never done until the paperwork is over, so let's describe the change we've just made. The relevant place is</source>
          <target state="translated">마지막으로 문서. 서류 작업이 끝날 때까지 작업이 완료되지 않으므로 방금 변경 한 내용을 설명하겠습니다. 관련 장소는</target>
        </trans-unit>
        <trans-unit id="80876825b2c59d50931c0454f32d3120b5201e0a" translate="yes" xml:space="preserve">
          <source>Finally, the following set of approaches was offered by Jeffrey Friedl, whose article in issue #5 of The Perl Journal talks about this very matter.</source>
          <target state="translated">마지막으로 Jeffrey Friedl은 Perl Journal 5 호 기사에서이 문제에 대해 다음과 같은 접근 방식을 제시했습니다.</target>
        </trans-unit>
        <trans-unit id="3dff018de1b9478268177e77483e9300bee06c55" translate="yes" xml:space="preserve">
          <source>Finally, the message also can happen under the &lt;code&gt;/x&lt;/code&gt; regex modifier when the &lt;code&gt;\N&lt;/code&gt; is separated by spaces from the &lt;code&gt;{&lt;/code&gt;, in which case, remove the spaces.</source>
          <target state="translated">마지막으로, &lt;code&gt;\N&lt;/code&gt; 이 &lt;code&gt;{&lt;/code&gt; 와 공백으로 분리 될 때 &lt;code&gt;/x&lt;/code&gt; 정규식 수정 자 아래에서 메시지가 발생할 수도 있습니다.이 경우 공백을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0a5ec48900bcd82fa327a360a4d32095f98f60a4" translate="yes" xml:space="preserve">
          <source>Finally, the modifier may be used with all of the forms mentioned above:</source>
          <target state="translated">마지막으로, 수정자는 위에서 언급 한 모든 형식과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778ba92f0eda34f1617f29aaf6a42ae17012b6e9" translate="yes" xml:space="preserve">
          <source>Finally, the multiple-angle-bracket form does</source>
          <target state="translated">마지막으로 다중 앵글 브래킷 양식은</target>
        </trans-unit>
        <trans-unit id="69cd41be402812aa1fc1573ee80c91588133088e" translate="yes" xml:space="preserve">
          <source>Finally, there is &lt;code&gt;cx_topblock(cx)&lt;/code&gt;, which acts like a super-&lt;code&gt;nextstate&lt;/code&gt; as regards to resetting various vars to their base values. It is used in places like &lt;code&gt;pp_next&lt;/code&gt;, &lt;code&gt;pp_redo&lt;/code&gt; and &lt;code&gt;pp_goto&lt;/code&gt; where rather than exiting a scope, we want to re-initialise the scope. As well as resetting &lt;code&gt;PL_stack_sp&lt;/code&gt; like &lt;code&gt;nextstate&lt;/code&gt;, it also resets &lt;code&gt;PL_markstack_ptr&lt;/code&gt;, &lt;code&gt;PL_scopestack_ix&lt;/code&gt; and &lt;code&gt;PL_curpm&lt;/code&gt;. Note that it doesn't do a &lt;code&gt;FREETMPS&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;cx_topblock(cx)&lt;/code&gt; 는 다양한 vars를 기본 값으로 재설정하는 것과 관련하여 super- &lt;code&gt;nextstate&lt;/code&gt; 처럼 작동 합니다. 그것은 같은 장소에서 사용되는 &lt;code&gt;pp_next&lt;/code&gt; , &lt;code&gt;pp_redo&lt;/code&gt; 및 &lt;code&gt;pp_goto&lt;/code&gt; 오히려 범위를 종료하는 것보다, 우리가 다시 초기화 범위에 원하는 위치. &lt;code&gt;PL_stack_sp&lt;/code&gt; 와 같이 &lt;code&gt;nextstate&lt;/code&gt; 를 재설정 할뿐만 아니라 &lt;code&gt;PL_markstack_ptr&lt;/code&gt; , &lt;code&gt;PL_scopestack_ix&lt;/code&gt; 및 &lt;code&gt;PL_curpm&lt;/code&gt; 도 재설정합니다 . &lt;code&gt;FREETMPS&lt;/code&gt; 는 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="63f8e8ad12d75d623f33e44387f1b276ef571892" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt; , or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt; , this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt; s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt; .</source>
          <target state="translated">마지막으로 &lt;code&gt;LOGOP&lt;/code&gt; 또는 논리 연산이 있습니다. 유사한 &lt;code&gt;LISTOP&lt;/code&gt; 이 하나 이상의 아이를 가지고 있지만, 그것은이없는 &lt;code&gt;op_last&lt;/code&gt; 필드 : 당신이 따라야 할 수 있도록 &lt;code&gt;op_first&lt;/code&gt; 다음 &lt;code&gt;OpSIBLING&lt;/code&gt; 의 체인 자체가 마지막 자식을 찾을 수 있습니다. 대신 &lt;code&gt;op_other&lt;/code&gt; 필드 가 있으며 ,이 필드는 아래 설명 된 &lt;code&gt;op_next&lt;/code&gt; 필드 와 비슷 하며 대체 실행 경로를 나타냅니다. &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; 같은 연산자 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; 들. 일반적으로,주의 &lt;code&gt;op_other&lt;/code&gt; 가 의 직접 아이들의 가리하지 않을 수 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b751f83017cbd5bbf78b027bd8e55f818cb0e53" translate="yes" xml:space="preserve">
          <source>Finally, there is a &lt;code&gt;LOGOP&lt;/code&gt;, or logic op. Like a &lt;code&gt;LISTOP&lt;/code&gt;, this has one or more children, but it doesn't have an &lt;code&gt;op_last&lt;/code&gt; field: so you have to follow &lt;code&gt;op_first&lt;/code&gt; and then the &lt;code&gt;OpSIBLING&lt;/code&gt; chain itself to find the last child. Instead it has an &lt;code&gt;op_other&lt;/code&gt; field, which is comparable to the &lt;code&gt;op_next&lt;/code&gt; field described below, and represents an alternate execution path. Operators like &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; are &lt;code&gt;LOGOP&lt;/code&gt;s. Note that in general, &lt;code&gt;op_other&lt;/code&gt; may not point to any of the direct children of the &lt;code&gt;LOGOP&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;LOGOP&lt;/code&gt; 또는 논리 연산이 있습니다. 유사한 &lt;code&gt;LISTOP&lt;/code&gt; 이 하나 이상의 아이를 가지고 있지만, 그것은이없는 &lt;code&gt;op_last&lt;/code&gt; 필드 : 당신이 따라야 할 수 있도록 &lt;code&gt;op_first&lt;/code&gt; 다음 &lt;code&gt;OpSIBLING&lt;/code&gt; 의 체인 자체가 마지막 자식을 찾을 수 있습니다. 대신 그것은 갖는다 &lt;code&gt;op_other&lt;/code&gt; 받는 필적 필드 &lt;code&gt;op_next&lt;/code&gt; 의 필드 설명을하고, 다른 실행 경로를 나타낸다. &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; 와 같은 연산자 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; 들. 일반적으로,주의 &lt;code&gt;op_other&lt;/code&gt; 가 의 직접 아이들의 가리하지 않을 수 있습니다 &lt;code&gt;LOGOP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7cdec53bb27d155c030f9892a0eeb03fd88eb1" translate="yes" xml:space="preserve">
          <source>Finally, there is also an entirely different approach by unpacking big endian shorts and packing them in the reverse byte order:</source>
          <target state="translated">마지막으로 빅 엔디안 반바지를 풀고 역 바이트 순서로 포장하여 완전히 다른 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="453b0692eb90c0dfa9ea5982b6a592f258b890f5" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt; . (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">마지막으로 실제로 필터링을 수행하는 코드가 있습니다. 이 유형의 Perl 소스 필터의 경우 모든 필터링은 &lt;code&gt;filter()&lt;/code&gt; 라는 메소드에서 수행됩니다 . 클로저를 사용하여 Perl 소스 필터를 작성할 수도 있습니다. 자세한 내용은 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 매뉴얼 페이지를 참조하십시오. Perl 파서가 처리 할 다른 소스 행이 필요할 때마다 호출됩니다. &lt;code&gt;filter()&lt;/code&gt; 메소드는, 차례로 사용하여 소스 스트림으로부터 판독 라인 &lt;code&gt;filter_read()&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="f63b79d41e03c44ce7102b1bce3292ba0ca343a6" translate="yes" xml:space="preserve">
          <source>Finally, there is the code that actually does the filtering. For this type of Perl source filter, all the filtering is done in a method called &lt;code&gt;filter()&lt;/code&gt;. (It is also possible to write a Perl source filter using a closure. See the &lt;code&gt;Filter::Util::Call&lt;/code&gt; manual page for more details.) It's called every time the Perl parser needs another line of source to process. The &lt;code&gt;filter()&lt;/code&gt; method, in turn, reads lines from the source stream using the &lt;code&gt;filter_read()&lt;/code&gt; function.</source>
          <target state="translated">마지막으로 실제로 필터링을 수행하는 코드가 있습니다. 이러한 유형의 Perl 소스 필터의 경우 모든 필터링은 &lt;code&gt;filter()&lt;/code&gt; 라는 메서드에서 수행됩니다 . (클로저를 사용하여 Perl 소스 필터를 작성할 수도 있습니다. 자세한 내용은 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.) Perl 파서가 처리 할 다른 소스 라인이 필요할 때마다 호출됩니다. 그러면 &lt;code&gt;filter()&lt;/code&gt; 메서드는 &lt;code&gt;filter_read()&lt;/code&gt; 함수를 사용하여 소스 스트림에서 행을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="b70b6b76ef8b9f1c2f4e8ed6e19c93e5bed492e5" translate="yes" xml:space="preserve">
          <source>Finally, this technique can be used to implement a sort on a keyvalue pair list; e.g.:</source>
          <target state="translated">마지막으로이 기술을 사용하여 키 값 쌍 목록에 대한 정렬을 구현할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="dff384a2e72772724b586203a02673aa837c967d" translate="yes" xml:space="preserve">
          <source>Finally, using accessors makes inheritance much simpler. Subclasses can use the accessors rather than having to know how a parent class is implemented internally.</source>
          <target state="translated">마지막으로 접근자를 사용하면 상속이 훨씬 간단 해집니다. 서브 클래스는 부모 클래스가 내부적으로 어떻게 구현되는지 알 필요없이 접근자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de55aa6b3e2509718d66dd5a0030529d86bf08c" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;Class::Tiny&quot;&gt;Class :: Tiny가&lt;/a&gt; 있습니다. 이 모듈은 진정으로 그 이름에 걸 맞습니다. 그것은 믿을 수 없을 정도로 최소한의 API를 가지고 있으며 최신 Perl에 전혀 의존하지 않습니다. 그래도 처음부터 자신의 OO 코드를 작성하는 것보다 사용하기가 훨씬 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="a0ee269426b10540758eda6f3baa910232cd84eb" translate="yes" xml:space="preserve">
          <source>Finally, we have &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt;. This module truly lives up to its name. It has an incredibly minimal API and absolutely no dependencies on any recent Perl. Still, we think it's a lot easier to use than writing your own OO code from scratch.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny가&lt;/a&gt; 있습니다. 이 모듈은 그 이름 그대로입니다. API는 매우 작고 최근 Perl에 전혀 의존하지 않습니다. 여전히, 우리는 처음부터 자신의 OO 코드를 작성하는 것보다 사용하기가 훨씬 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="80f162582be94b96acbf3901ff2dad6e5237d61d" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">마지막으로, &lt;code&gt;filter&lt;/code&gt; 또는 anonymous 서브 처리가 완료되면 &lt;code&gt;$_&lt;/code&gt; 사용하여 필터링 된 소스를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="879473db2990543f072d8e3f8060a5f6514793f3" translate="yes" xml:space="preserve">
          <source>Finally, when &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are finished processing, they are expected to return the filtered source using &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;filter&lt;/code&gt; 또는 익명 하위 처리가 완료되면 &lt;code&gt;$_&lt;/code&gt; 사용하여 필터링 된 소스를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="237e2517518e5a7e38bf850e59773fff293d743f" translate="yes" xml:space="preserve">
          <source>Finally, you can append an optional third argument, in &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, where</source>
          <target state="translated">마지막으로 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;,&lt;i&gt;arg2&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; 선택적 세 번째 인수를 추가 할 수 있습니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="e97f51f439c9ae965cec0b2dc4c4355eaa28a624" translate="yes" xml:space="preserve">
          <source>Finally, you should then delete the remote smoke-me branch:</source>
          <target state="translated">마지막으로 원격 smoke-me 브랜치를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="694939534870b0a1edb23c3bf281899ee38f8c47" translate="yes" xml:space="preserve">
          <source>Finally, you'll need to copy the extension's Perl library module to the</source>
          <target state="translated">마지막으로, 확장의 Perl 라이브러리 모듈을</target>
        </trans-unit>
        <trans-unit id="860f05ae24e478a14a3acf15fc650e6557c5de7d" translate="yes" xml:space="preserve">
          <source>Find POD documents in directory trees</source>
          <target state="translated">디렉토리 트리에서 POD 문서 찾기</target>
        </trans-unit>
        <trans-unit id="e1857def4ee2d2eb29e93e010b1a0b29040a49b1" translate="yes" xml:space="preserve">
          <source>Find a named lexical anywhere in a chain of nested pads. Add fake entries in the inner pads if it's found in an outer one.</source>
          <target state="translated">중첩 된 패드 체인에서 어휘 이름이 지정된 어휘를 찾으십시오. 외부 패드에서 발견되면 내부 패드에 가짜 항목을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4564f34f47e157e7d1dad65f67463f62f1be357a" translate="yes" xml:space="preserve">
          <source>Find an area of Perl that seems interesting to you, and see if you can work out how it works. Scan through the source, and step over it in the debugger. Play, poke, investigate, fiddle! You'll probably get to understand not just your chosen area but a much wider range of</source>
          <target state="translated">당신에게 흥미로워지는 Perl 영역을 찾고 그것이 어떻게 작동하는지 알아보십시오. 소스를 스캔하고 디버거에서 소스를 살펴 봅니다. 플레이, 찌르기, 조사, 바이올린! 당신은 아마 당신이 선택한 지역뿐만 아니라 훨씬 더 넓은 범위를 이해하게 될 것입니다</target>
        </trans-unit>
        <trans-unit id="b0f962c203daff2b574f4bbd4661b46cb058cc00" translate="yes" xml:space="preserve">
          <source>Find and return the variable that is named &lt;code&gt;$_&lt;/code&gt; in the lexical scope of the currently-executing function. This may be a lexical &lt;code&gt;$_&lt;/code&gt; , or will otherwise be the global one.</source>
          <target state="translated">현재 실행중인 함수의 어휘 범위에서 이름이 &lt;code&gt;$_&lt;/code&gt; 인 변수를 찾아 반환합니다 . 이것은 어휘 &lt;code&gt;$_&lt;/code&gt; 일 수도 있고 그렇지 않으면 전역일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3987e57a4047735115abd7670e17ea834246318" translate="yes" xml:space="preserve">
          <source>Find close matches to the named modules that you think you might have mistyped. This requires the optional installation of Text::Levenshtein or Text::Levenshtein::Damerau.</source>
          <target state="translated">잘못 입력했을 수 있다고 생각되는 명명 된 모듈과 가까운 일치 항목을 찾습니다. Text :: Levenshtein 또는 Text :: Levenshtein :: Damerau를 선택적으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="418498cca51e97a1b0d2b4c89d2b05e75464656f" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">계획이 정의되었는지 확인하십시오. &lt;code&gt;$plan&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (계획이 설정되지 않음), &lt;code&gt;no_plan&lt;/code&gt; (결정되지 않은 테스트 수) 또는 정수 (예상 테스트 수)입니다.</target>
        </trans-unit>
        <trans-unit id="b7a3095b5282b9401d12f20b31b6ecddeb954040" translate="yes" xml:space="preserve">
          <source>Find out whether a plan has been defined. &lt;code&gt;$plan&lt;/code&gt; is either &lt;code&gt;undef&lt;/code&gt; (no plan has been set), &lt;code&gt;no_plan&lt;/code&gt; (indeterminate # of tests) or an integer (the number of expected tests).</source>
          <target state="translated">계획이 정의되었는지 확인합니다. &lt;code&gt;$plan&lt;/code&gt; 은 &lt;code&gt;undef&lt;/code&gt; (계획이 설정되지 않음), &lt;code&gt;no_plan&lt;/code&gt; ( 미확정 테스트 수) 또는 정수 (예상 테스트 수)입니다.</target>
        </trans-unit>
        <trans-unit id="7ca0c65ce5ae45823f61afddf86cef29c2b9896f" translate="yes" xml:space="preserve">
          <source>Find the best mirrors you could be using and use them for the current session.</source>
          <target state="translated">사용할 수있는 최상의 미러를 찾아 현재 세션에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="299f4826369de8d05aca882ad20a8c23e29f25dd" translate="yes" xml:space="preserve">
          <source>Find the directory name</source>
          <target state="translated">디렉토리 이름 찾기</target>
        </trans-unit>
        <trans-unit id="6ff33fe789ed52358ad4a6f6237332d2d9560dc4" translate="yes" xml:space="preserve">
          <source>Find the first (leftmost) occurrence of a sequence of bytes within another sequence. This is the Perl version of &lt;code&gt;strstr()&lt;/code&gt;, extended to handle arbitrary sequences, potentially containing embedded &lt;code&gt;NUL&lt;/code&gt; characters (&lt;code&gt;NUL&lt;/code&gt; is what the initial &lt;code&gt;n&lt;/code&gt; in the function name stands for; some systems have an equivalent, &lt;code&gt;memmem()&lt;/code&gt;, but with a somewhat different API).</source>
          <target state="translated">다른 시퀀스 내에서 첫 번째 (가장 왼쪽) 바이트 시퀀스를 찾습니다. 이것은 임의의 시퀀스를 처리하도록 확장 된 &lt;code&gt;strstr()&lt;/code&gt; 의 Perl 버전으로 , 잠재적으로 포함 된 &lt;code&gt;NUL&lt;/code&gt; 문자 를 포함 합니다 ( &lt;code&gt;NUL&lt;/code&gt; 은 함수 이름 의 초기 &lt;code&gt;n&lt;/code&gt; 이 의미하는 것입니다. 일부 시스템에는 동등한 &lt;code&gt;memmem()&lt;/code&gt; 이 있지만 약간 다른 API).</target>
        </trans-unit>
        <trans-unit id="4ac57f2d73d65d94cbdbe0755aabac6325af065d" translate="yes" xml:space="preserve">
          <source>Find the general category of a numeric codepoint.</source>
          <target state="translated">숫자 코드 포인트의 일반 범주를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c8f2ac7f85f4a8cad43d51157f3d77d5c06e4db0" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches &lt;code&gt;uninit_sv&lt;/code&gt;. So roughly speaking, if a unary operator (such as &lt;code&gt;OP_COS&lt;/code&gt;) generates a warning, then following the direct child of the op may yield an &lt;code&gt;OP_PADSV&lt;/code&gt; or &lt;code&gt;OP_GV&lt;/code&gt; that gives the name of the undefined variable. On the other hand, with &lt;code&gt;OP_ADD&lt;/code&gt; there are two branches to follow, so we only print the variable name if we get an exact match. &lt;code&gt;desc_p&lt;/code&gt; points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">운영자가 &quot;초기화되지 않은 값 사용&quot;경고를 발생시킨 정의되지 않은 변수 (있는 경우)의 이름을 찾으십시오. match가 true이면 해당 값이 &lt;code&gt;uninit_sv&lt;/code&gt; 와 일치하는 경우에만 이름을 반환합니다 . 대략적으로 말하면 단항 연산자 (예 : &lt;code&gt;OP_COS&lt;/code&gt; )가 경고를 생성하면 op의 직계 자식을 따라 &lt;code&gt;OP_GV&lt;/code&gt; 정의되지 않은 변수의 이름을 제공 하는 &lt;code&gt;OP_PADSV&lt;/code&gt; 또는 OP_GV 가 생성 될 수 있습니다 . 반면에 &lt;code&gt;OP_ADD&lt;/code&gt; 에는 따라야 할 두 가지 분기가 있으므로 정확히 일치하는 경우에만 변수 이름을 인쇄합니다. &lt;code&gt;desc_p&lt;/code&gt; 는 작업에 대한 설명이 들어있는 문자열 포인터를 가리 킵니다. 필요한 경우 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49c3913d7af3c4d57a065a7a52f55890db2015f" translate="yes" xml:space="preserve">
          <source>Find the name of the undefined variable (if any) that caused the operator to issue a &quot;Use of uninitialized value&quot; warning. If match is true, only return a name if its value matches uninit_sv. So roughly speaking, if a unary operator (such as OP_COS) generates a warning, then following the direct child of the op may yield an OP_PADSV or OP_GV that gives the name of the undefined variable. On the other hand, with OP_ADD there are two branches to follow, so we only print the variable name if we get an exact match. desc_p points to a string pointer holding the description of the op. This may be updated if needed.</source>
          <target state="translated">연산자가 &quot;초기화되지 않은 값 사용&quot;경고를 발생시키는 정의되지 않은 변수 (있는 경우)의 이름을 찾으십시오. match가 true이면 해당 값이 uninit_sv와 일치하는 경우에만 이름을 반환합니다. 대략적으로 말하면, 단항 연산자 (예 : OP_COS)가 경고를 생성하면 op의 직접 하위를 따라 정의되지 않은 변수의 이름을 제공하는 OP_PADSV 또는 OP_GV가 생성 될 수 있습니다. 반면에 OP_ADD에는 두 가지 분기가 있으므로 정확히 일치하는 경우에만 변수 이름을 인쇄합니다. desc_p는 op에 대한 설명을 담고있는 문자열 포인터를 가리 킵니다. 필요한 경우 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac43fb4e0d5bd1c0782abaa41490e339609fd8c" translate="yes" xml:space="preserve">
          <source>Find the position of the lexical &lt;code&gt;$_&lt;/code&gt; in the pad of the currently-executing function. Returns the offset in the current pad, or &lt;code&gt;NOT_IN_PAD&lt;/code&gt; if there is no lexical &lt;code&gt;$_&lt;/code&gt; in scope (in which case the global one should be used instead). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; is likely to be more convenient.</source>
          <target state="translated">현재 실행중인 함수의 패드에서 어휘 &lt;code&gt;$_&lt;/code&gt; 의 위치를 ​​찾으십시오 . 현재 패드의 오프셋 또는 범위에 어휘 &lt;code&gt;$_&lt;/code&gt; 가없는 경우 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 를 반환합니다 (이 경우 전역 오프셋을 대신 사용해야 함). &lt;a href=&quot;#find_rundefsv&quot;&gt;find_rundefsv&lt;/a&gt; 가 더 편리 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="449a6849d1b11914b85fc078a256f3db73a2b32b" translate="yes" xml:space="preserve">
          <source>Find the start position where a regex match should be attempted, or possibly if the regex engine should not be run because the pattern can't match. This is called, as appropriate, by the core, depending on the values of the &lt;code&gt;extflags&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">정규식 일치를 시도하거나 패턴이 일치하지 않아서 정규식 엔진을 실행하지 않아야하는 시작 위치를 찾으십시오. 이것은 적절하게 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;extflags&lt;/code&gt; 멤버 값에 따라 코어에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6483e76c333ac42379066b4aedb6e408fdbe129b" translate="yes" xml:space="preserve">
          <source>FindBin</source>
          <target state="translated">FindBin</target>
        </trans-unit>
        <trans-unit id="24c31d2b2286d66b429b3c123e559310944ed2de" translate="yes" xml:space="preserve">
          <source>FindBin - Locate directory of original perl script</source>
          <target state="translated">FindBin-원래 펄 스크립트의 디렉토리를 찾습니다</target>
        </trans-unit>
        <trans-unit id="4369a8a5c4e42e43d5e7bb66ccfd1c78f33f275a" translate="yes" xml:space="preserve">
          <source>FindBin - optional module which deals with paths relative to the source file.</source>
          <target state="translated">FindBin-소스 파일과 관련된 경로를 처리하는 선택적 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="f086fc99759a8e3bb0203cfe84782842d1a193aa" translate="yes" xml:space="preserve">
          <source>FindBin is supported as part of the core perl distribution. Please send bug reports to &amp;lt;</source>
          <target state="translated">FindBin은 핵심 perl 배포의 일부로 지원됩니다. 버그 신고를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9448bfafc842c027dacc4896519d4bae55c41c99" translate="yes" xml:space="preserve">
          <source>Finding IANA Character Set Registry names</source>
          <target state="translated">IANA 문자 세트 레지스트리 이름 찾기</target>
        </trans-unit>
        <trans-unit id="eef2fdb8cb6b261375ae8d62a702d5b95f90b35a" translate="yes" xml:space="preserve">
          <source>Finding Magic</source>
          <target state="translated">마법 찾기</target>
        </trans-unit>
        <trans-unit id="e4f6c5e89298ef6e35e80792cf1b54756849aae5" translate="yes" xml:space="preserve">
          <source>Finding and running system commands made easy</source>
          <target state="translated">손쉬운 시스템 명령 찾기 및 실행</target>
        </trans-unit>
        <trans-unit id="96480ceeb561d8e5864564872e9b2a46637a4002" translate="yes" xml:space="preserve">
          <source>Finding locales</source>
          <target state="translated">로케일 찾기</target>
        </trans-unit>
        <trans-unit id="3153f313a1b462b04bbeda7ea0617a540d2d82e4" translate="yes" xml:space="preserve">
          <source>Finding out your status</source>
          <target state="translated">귀하의 상태 확인</target>
        </trans-unit>
        <trans-unit id="87d12ac1eef851da5ad3ec16ab4427086784516f" translate="yes" xml:space="preserve">
          <source>Finding packages and VERSION</source>
          <target state="translated">패키지 및 버전 찾기</target>
        </trans-unit>
        <trans-unit id="192a400dd7758944da905f5786b9b1af628198e2" translate="yes" xml:space="preserve">
          <source>Finding the end</source>
          <target state="translated">끝 찾기</target>
        </trans-unit>
        <trans-unit id="6d70dab88d530f69df03bc2322d08f1cd465a479" translate="yes" xml:space="preserve">
          <source>Finds the executables PERL and FULLPERL</source>
          <target state="translated">PERL 및 FULLPERL 실행 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cb3d12363ae65c418567d25fa6af068fa57bcd89" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for &lt;code&gt;type&lt;/code&gt; matching the SV. See &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">SV와 일치하는 &lt;code&gt;type&lt;/code&gt; 대한 매직 포인터를 찾습니다 . &lt;code&gt;&lt;a href=&quot;#sv_magic&quot;&gt;&quot;sv_magic&quot;&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22bcd7072415a74f9601a9db40691f4be186016b" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer for type matching the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV와 일치하는 유형의 마술 포인터를 찾습니다. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25d979215bfecc25b84803c1f222b66fe8c9e2ae" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt; . See &lt;code&gt;sv_magicext&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대해 주어진 &lt;code&gt;vtbl&lt;/code&gt; 을 사용하여 &lt;code&gt;type&lt;/code&gt; 의 마술 포인터를 찾습니다 . &lt;code&gt;sv_magicext&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1508cd21f25aec8c8ff0233e3ab9fa73bbb76820" translate="yes" xml:space="preserve">
          <source>Finds the magic pointer of &lt;code&gt;type&lt;/code&gt; with the given &lt;code&gt;vtbl&lt;/code&gt; for the &lt;code&gt;SV&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#sv_magicext&quot;&gt;&quot;sv_magicext&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SV&lt;/code&gt; 에 대해 지정된 &lt;code&gt;vtbl&lt;/code&gt; 을 사용하여 &lt;code&gt;type&lt;/code&gt; 의 매직 포인터를 찾습니다 . &lt;code&gt;&lt;a href=&quot;#sv_magicext&quot;&gt;&quot;sv_magicext&quot;&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c909b138eba89ecfbd86df4c9d170ac78d4a3820" translate="yes" xml:space="preserve">
          <source>Finland</source>
          <target state="translated">Finland</target>
        </trans-unit>
        <trans-unit id="267b05432936f6d23e350d21b3fe892d9d8dbea3" translate="yes" xml:space="preserve">
          <source>Fire the debugger up again on your script and we'll look at the help menu. There's a couple of ways of calling help: a simple '&lt;b&gt;h&lt;/b&gt;' will get the summary help list, '&lt;b&gt;|h&lt;/b&gt;' (pipe-h) will pipe the help through your pager (which is (probably 'more' or 'less'), and finally, '&lt;b&gt;h h&lt;/b&gt;' (h-space-h) will give you the entire help screen. Here is the summary page:</source>
          <target state="translated">스크립트에서 디버거를 다시 시작하면 도움말 메뉴가 표시됩니다. 도움말을 호출하는 몇 가지 방법이 있습니다. 간단한 ' &lt;b&gt;h&lt;/b&gt; '는 요약 도움말 목록을 가져오고 ' &lt;b&gt;| h&lt;/b&gt; '(pipe-h)는 호출기를 통해 도움말을 파이프합니다 (아마도 'more'또는 'less'). 마지막으로 ' &lt;b&gt;hh&lt;/b&gt; '(h-space-h)는 전체 도움말 화면을 제공합니다. 요약 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cef42e83f0eb4f1a99e0bddde90be004038a21df" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 에서 개별 파일을 성공적으로로드했을 때 발생합니다 . 디스크에서 파일을 읽고 내용을 평가 한 후에이 프로브가 시작됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; -style 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="757a897afd699db960721899607f96100462820d" translate="yes" xml:space="preserve">
          <source>Fires when Perl has successfully loaded an individual file, whether from &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;. This probe fires after the file is read from disk and its contents evaluated. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt;-style names.</source>
          <target state="translated">Perl이 &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 에서 개별 파일을 성공적으로로드하면 실행 됩니다. 이 프로브는 디스크에서 파일을 읽고 내용을 평가 한 후에 실행됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; 스타일 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7704de478a9404e667918d6d09d2c1e3a1cb6a87" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt; -style names.</source>
          <target state="translated">Perl이 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 에서 개별 파일을로드하려고 할 때 발생합니다 . 이 프로브는 파일을 디스크에서 읽기 전에 시작됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; -style 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9f10e7adabcd669986aa11e5c555213012ea407" translate="yes" xml:space="preserve">
          <source>Fires when Perl is about to load an individual file, whether from &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;. This probe fires before the file is read from disk. The filename argument is converted to local filesystem paths instead of providing &lt;code&gt;Module::Name&lt;/code&gt;-style names.</source>
          <target state="translated">Perl이 &lt;code&gt;use&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;do&lt;/code&gt; 에서 개별 파일을로드하려고 할 때 발생합니다 . 이 프로브는 디스크에서 파일을 읽기 전에 실행됩니다. filename 인수는 &lt;code&gt;Module::Name&lt;/code&gt; 스타일 이름 을 제공하는 대신 로컬 파일 시스템 경로로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="49d7fed0e266f24545d9104466ab74b18bdd8f35" translate="yes" xml:space="preserve">
          <source>Firewalls can be categorized into three basic types.</source>
          <target state="translated">방화벽은 세 가지 기본 유형으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00bc27da396d3a81b2819430816be98253f7657" translate="yes" xml:space="preserve">
          <source>First In, First Out. See also &lt;b&gt;LIFO&lt;/b&gt;. Also a nickname for a &lt;b&gt;named pipe&lt;/b&gt;.</source>
          <target state="translated">선입 선출. &lt;b&gt;LIFO&lt;/b&gt; 도 참조하십시오 . &lt;b&gt;명명 된 파이프&lt;/b&gt; 의 별명이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="8fe7145d9c6c14d380f19ecbb52aad0be3d15872" translate="yes" xml:space="preserve">
          <source>First available in Perl 5.10.1 (the 5.10.0 version behaved differently), binary &lt;code&gt;~~&lt;/code&gt; does a &quot;smartmatch&quot; between its arguments. This is mostly used implicitly in the &lt;code&gt;when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, although not all &lt;code&gt;when&lt;/code&gt; clauses call the smartmatch operator. Unique among all of Perl's operators, the smartmatch operator can recurse. The smartmatch operator is &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt; and its behavior is subject to change.</source>
          <target state="translated">Perl 5.10.1 (5.10.0 버전과 다르게 동작)에서 처음 사용할 수있는 binary &lt;code&gt;~~&lt;/code&gt; 는 인수간에 &quot;스마트 매치&quot;를 수행합니다. 이것은 대부분의 내재적 사용되는 &lt;code&gt;when&lt;/code&gt; 에 기술 된 구조 &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; 아니지만 모든 &lt;code&gt;when&lt;/code&gt; 절이 smartmatch 오퍼레이터를 호출한다. 모든 Perl 운영자 중 고유 한 smartmatch 운영자는 재귀 할 수 있습니다. 스마트 매치 연산자는 &lt;a href=&quot;perlpolicy#experimental&quot;&gt;실험&lt;/a&gt; 중이며 동작은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63af0ded76d246a89c78d019ed5af7004abaf7ca" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command, followed by $(TO_UNIX), which defaults to a null command under UNIX, and will convert files in distribution directory to UNIX format otherwise. Next it runs &lt;code&gt;tar&lt;/code&gt; on that directory into a tarfile and deletes the directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음, $ (PREOP) 명령은 기본적으로 널 명령으로 설정되고, $ (TO_UNIX)가 뒤에 오는 UNIX의 경우 널 명령으로 설정되며, 그렇지 않으면 분배 디렉토리의 파일을 UNIX 형식으로 변환합니다. 그 다음으로 실행 &lt;code&gt;tar&lt;/code&gt; tar 파일에 해당 디렉토리에와 디렉토리를 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다.</target>
        </trans-unit>
        <trans-unit id="2af22b932d239ecb2692524f84027e701417e610" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Next it runs &lt;code&gt;shar&lt;/code&gt; on that directory into a sharfile and deletes the intermediate directory again. Finishes with a command $(POSTOP) which defaults to a null command. Note: For shdist to work properly a &lt;code&gt;shar&lt;/code&gt; program that can handle directories is mandatory.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음 $ (PREOP) 명령은 기본적으로 널 명령입니다. 다음 으로 해당 디렉토리 에서 &lt;code&gt;shar&lt;/code&gt; 를 sharfile로 실행 하고 중간 디렉토리를 다시 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다. 참고 : shdist이 제대로 작동 할 수있는 &lt;code&gt;shar&lt;/code&gt; 디렉토리를 처리 할 수있는 프로그램이 필수입니다.</target>
        </trans-unit>
        <trans-unit id="32b6865bf0f3ae68c2cf337647431ed6a911b654" translate="yes" xml:space="preserve">
          <source>First does a distdir. Then a command $(PREOP) which defaults to a null command. Runs &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; on that directory into a zipfile. Then deletes that directory. Finishes with a command $(POSTOP) which defaults to a null command.</source>
          <target state="translated">먼저 distdir을 수행합니다. 그런 다음 $ (PREOP) 명령은 기본적으로 널 명령입니다. 실행 &lt;code&gt;$(ZIP) $(ZIPFLAGS)&lt;/code&gt; ZipFile를에 그 디렉토리에. 그런 다음 해당 디렉토리를 삭제합니다. 기본적으로 널 명령으로 설정된 $ (POSTOP) 명령으로 완료합니다.</target>
        </trans-unit>
        <trans-unit id="94aa237f5671c72c12a3009e96b0d0c3b639055e" translate="yes" xml:space="preserve">
          <source>First example to &lt;code&gt;use deprecate;&lt;/code&gt; was &lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;use deprecate;&lt;/code&gt; 를 사용하는 첫 번째 예입니다 . 이었다 &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87237cd69962d954afc8149676070ba7e99a30f3" translate="yes" xml:space="preserve">
          <source>First is the &quot;transitional compilation environment&quot;, described in lfcompile64(5). According to the man page,</source>
          <target state="translated">먼저 lfcompile64 (5)에 설명 된 &quot;전환 컴파일 환경&quot;입니다. 매뉴얼 페이지에 따르면</target>
        </trans-unit>
        <trans-unit id="39f2e43e592aba75880c16ffdbd2296c6893e732" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">우선 모든 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 는 세 번째 매개 변수 유형 (이 경우 'CODE')을 가져옵니다 . &lt;code&gt;attributes.pm&lt;/code&gt; 은 호출자의 네임 스페이스 (여기서는 'main')에 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 라는 서브 루틴이 있는지 확인합니다 . 이 경우 서브 루틴 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 가 필요합니다. 그런 다음 &quot;나쁜 특성&quot;을 사용했는지 확인하기 위해이 메소드가 호출됩니다. 이 예제에서 서브 루틴 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7822424c868e3dc633b16628199202fe7a79904" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;import&lt;/code&gt; gets the type of the third parameter ('CODE' in this case). &lt;code&gt;attributes.pm&lt;/code&gt; checks if there is a subroutine called &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; in the caller's namespace (here: 'main'). In this case a subroutine &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; is required. Then this method is called to check if you have used a &quot;bad attribute&quot;. The subroutine call in this example would look like</source>
          <target state="translated">먼저 &lt;code&gt;import&lt;/code&gt; 는 세 번째 매개 변수의 유형 (이 경우 'CODE')을 가져옵니다 . &lt;code&gt;attributes.pm&lt;/code&gt; 은 호출자의 네임 스페이스 (여기서는 'main')에 &lt;code&gt;MODIFY_&amp;lt;reftype&amp;gt;_ATTRIBUTES&lt;/code&gt; 라는 서브 루틴이 있는지 확인합니다 . 이 경우 서브 루틴 &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; 가 필요합니다. 그런 다음 &quot;불량 속성&quot;을 사용했는지 확인하기 위해이 메서드가 호출됩니다. 이 예제의 서브 루틴 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5edeb3fa4c30eb9326cfd6ee3072f89d302a7fb" translate="yes" xml:space="preserve">
          <source>First of all note that if you're doing this for security reasons (to avoid people seeing passwords, for example) then you should rewrite your program so that critical information is never given as an argument. Hiding the arguments won't make your program completely secure.</source>
          <target state="translated">우선 보안상의 이유로이 작업을 수행하는 경우 (예를 들어 사람들이 암호를 보지 않도록) 중요한 정보가 인수로 제공되지 않도록 프로그램을 다시 작성해야합니다. 논쟁을 숨기더라도 프로그램이 완전히 안전하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="02342cfce74aa40ebbe7459fd67794792aa8eda6" translate="yes" xml:space="preserve">
          <source>First of all note that you have full access to the Symbian device when using Perl: you can do a lot of damage to your device (like removing system files) unless you are careful. Please do take backups before doing anything.</source>
          <target state="translated">우선 Perl을 사용할 때 Symbian 장치에 완전히 액세스 할 수 있습니다.주의하지 않으면 장치 파일을 제거하는 등 장치에 많은 손상을 줄 수 있습니다. 무엇이든하기 전에 백업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="82d1faba2416c529064d9e355ea5a87b152dcd77" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;use strict;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;use warnings;&lt;/code&gt;&lt;/a&gt;?</source>
          <target state="translated">우선, &lt;a href=&quot;strict&quot;&gt; &lt;code&gt;use strict;&lt;/code&gt; &lt;/a&gt; 사용해 보셨습니까? 및 &lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;use warnings;&lt;/code&gt; &lt;/a&gt;?</target>
        </trans-unit>
        <trans-unit id="1463803ecb1c9b404836c68a0992ffedefb430c0" translate="yes" xml:space="preserve">
          <source>First of all, have you tried using the &lt;b&gt;-w&lt;/b&gt; switch?</source>
          <target state="translated">우선, &lt;b&gt;-w&lt;/b&gt; 스위치 를 사용해 &lt;b&gt;보셨습니까&lt;/b&gt; ?</target>
        </trans-unit>
        <trans-unit id="a4f52d54cf15399bdc6e2cfb2dc28b7c88455e40" translate="yes" xml:space="preserve">
          <source>First of all, however, you</source>
          <target state="translated">그러나 우선, 당신은</target>
        </trans-unit>
        <trans-unit id="83147c6de1b08740dd2da15332f4959df7841375" translate="yes" xml:space="preserve">
          <source>First of all, there's a few things you can do to make your life a lot more straightforward when it comes to debugging perl programs, without using the debugger at all. To demonstrate, here's a simple script, named &quot;hello&quot;, with a problem:</source>
          <target state="translated">우선, 디버거를 전혀 사용하지 않고 펄 프로그램을 디버깅 할 때 삶을 훨씬 간단하게 만들기 위해 할 수있는 몇 가지가 있습니다. 다음은 문제가있는 &quot;hello&quot;라는 간단한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="04c84bafcaec13f658619ad91db4027ae060911a" translate="yes" xml:space="preserve">
          <source>First of all, when doing a match, one may get no run-time output even if debugging is enabled. This means that the regex engine was never entered and that all of the job was therefore done by the optimizer.</source>
          <target state="translated">우선, 일치하는 경우 디버깅이 활성화되어 있어도 런타임 출력이 나타나지 않을 수 있습니다. 이는 정규식 엔진이 입력되지 않았으므로 모든 작업이 최적화 프로그램에 의해 수행되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="960494596b28f0ed04786d5db795d0496594f162" translate="yes" xml:space="preserve">
          <source>First off, you must have zlib 1.0.5 or better.</source>
          <target state="translated">먼저 zlib 1.0.5 이상이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="69ce5e02622d1bff00c96b8c962f42da114efb4f" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;&quot;Internal Functions&quot;&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">첫 번째 문제 : 어떤 함수가 공개 API 함수가 될지 그리고 어떤 함수가 비공개가 될지 결정하는 것입니다. 이름이 &lt;code&gt;S_&lt;/code&gt; 로 시작하는 모든 함수 는 비공개입니다 ( &quot;비밀&quot;또는 &quot;정적&quot;의 경우 &quot;S&quot;). 다른 모든 함수는 &quot;Perl_&quot;로 시작하지만 함수가 &quot;Perl_&quot;로 시작한다고해서 API의 일부임을 의미하지는 않습니다. ( &lt;a href=&quot;#Internal-Functions&quot;&gt;&quot;내부 함수&quot;&lt;/a&gt; 참조 ) 함수가 API의 일부 &lt;b&gt;인지 확인&lt;/b&gt; 하는 가장 쉬운 방법 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 에서 해당 항목을 찾는 것 입니다. &lt;a href=&quot;perlapi&quot;&gt;perlapi에&lt;/a&gt; 존재하는 경우 API의 일부입니다. 그렇지 않은 경우 (예 : 확장을 위해 필요함) 문제를 &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues에&lt;/a&gt; 제출하여 왜 그렇게해야한다고 생각하는지 설명 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5548dc2d3eeb7fa10ed6d62335952f1161d1be5c" translate="yes" xml:space="preserve">
          <source>First problem: deciding which functions will be public API functions and which will be private. All functions whose names begin &lt;code&gt;S_&lt;/code&gt; are private (think &quot;S&quot; for &quot;secret&quot; or &quot;static&quot;). All other functions begin with &quot;Perl_&quot;, but just because a function begins with &quot;Perl_&quot; does not mean it is part of the API. (See &lt;a href=&quot;#Internal-Functions&quot;&gt;Internal Functions&lt;/a&gt;.) The easiest way to be &lt;b&gt;sure&lt;/b&gt; a function is part of the API is to find its entry in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;. If it exists in &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, it's part of the API. If it doesn't, and you think it should be (i.e., you need it for your extension), send mail via &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; explaining why you think it should be.</source>
          <target state="translated">첫 번째 문제 : 공개 API 함수가 될 함수와 비공개 함수를 결정합니다. 이름이 &lt;code&gt;S_&lt;/code&gt; 로 시작하는 모든 함수 는 개인용입니다 ( &quot;secret&quot;또는 &quot;static&quot;에 대해 &quot;S&quot;를 생각하십시오). 다른 모든 함수는 &quot;Perl_&quot;로 시작하지만 함수가 &quot;Perl_&quot;로 시작한다고해서 이것이 API의 일부라는 의미는 아닙니다. &lt;a href=&quot;#Internal-Functions&quot;&gt;내부 함수를&lt;/a&gt; 참조하십시오 . 함수가 API의 일부 &lt;b&gt;인지 확인&lt;/b&gt; 하는 가장 쉬운 방법 은 &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; 에서 해당 항목을 찾는 것 입니다. &lt;a href=&quot;perlapi&quot;&gt;perlapi에&lt;/a&gt; 존재 하면 API의 일부입니다. 그렇지 않다면 생각해야한다고 생각하는 경우 (즉, 확장에 필요한 경우) &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; 를 통해 왜 생각 해야하는지 설명하는 메일을 보내 십시오.</target>
        </trans-unit>
        <trans-unit id="6d90388b269f11ed13790611d5c39ef23068273b" translate="yes" xml:space="preserve">
          <source>First release of port to 5.16.3.</source>
          <target state="translated">5.16.3에 대한 첫 번째 포트 릴리스.</target>
        </trans-unit>
        <trans-unit id="6c6d177453ba632a0301eb097966ff6e4ecd7e13" translate="yes" xml:space="preserve">
          <source>First runs the &lt;code&gt;get&lt;/code&gt; method to make sure the distribution is downloaded and unpacked. Changes to the directory where the distribution has been unpacked and runs the external commands &lt;code&gt;perl
Makefile.PL&lt;/code&gt; or &lt;code&gt;perl Build.PL&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; there.</source>
          <target state="translated">먼저 &lt;code&gt;get&lt;/code&gt; 메소드를 실행하여 분배가 다운로드되고 압축 해제되었는지 확인하십시오. 분배 포장을 풀고 설치와 외부 명령을 실행 한 디렉토리로 변경 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 이나 &lt;code&gt;perl Build.PL&lt;/code&gt; 하고 &lt;code&gt;make&lt;/code&gt; 가.</target>
        </trans-unit>
        <trans-unit id="8990c7669972aeb5dbf3f8f7c6f26f615b1eba3b" translate="yes" xml:space="preserve">
          <source>First try</source>
          <target state="translated">첫 시도</target>
        </trans-unit>
        <trans-unit id="8c24340fb0abf478cd12d4c9a81be46a9b570102" translate="yes" xml:space="preserve">
          <source>First version July 22, 1998; last revised November 21, 2001.</source>
          <target state="translated">최초 버전 1998 년 7 월 22 일; 2001 년 11 월 21 일 최종 개정.</target>
        </trans-unit>
        <trans-unit id="31fb5f76604a7e6f413356e0c06e90b3583d1c3f" translate="yes" xml:space="preserve">
          <source>First we need to create a temporary new branch for these changes and switch into it:</source>
          <target state="translated">먼저 이러한 변경 사항에 대한 임시 새 분기를 만들고 전환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed5b85580c1cc1af9d07f10dd52a32a103df1c0f" translate="yes" xml:space="preserve">
          <source>First we start with which characters to include. We call this collection of characters</source>
          <target state="translated">먼저 포함 할 문자로 시작합니다. 우리는이 캐릭터 모음을</target>
        </trans-unit>
        <trans-unit id="f0bcb6253b995340d8661abf6d3eb20fd1447df3" translate="yes" xml:space="preserve">
          <source>First you extract the keys from the hashes into lists, then solve the &quot;removing duplicates&quot; problem described above. For example:</source>
          <target state="translated">먼저 해시에서 키를 목록으로 추출한 다음 위에서 설명한 &quot;중복 제거&quot;문제를 해결하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2044f5e8e1c516409eb219e4d2d2da652d96754d" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w
checkfiles.pl %*.c&lt;/code&gt; ). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">먼저 BS2000 명령 줄 프롬프트 ( '*')가 나타납니다. 여기에 매개 변수를 입력 할 수 있습니다 (예 : &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (이중 백 슬래시를 참고하십시오!) 또는 &lt;code&gt;-w&lt;/code&gt; 및 Perl 스크립트의 이름. &lt;code&gt;/&lt;/code&gt; 로 시작하는 파일 이름 은 Posix 파일 시스템에서 검색되고 다른 파일 이름 은 BS2000 파일 시스템에서 검색됩니다. 파일 이름 앞에 &lt;code&gt;%&lt;/code&gt; 를 넣으면 와일드 카드를 사용할 수도 있습니다 (예 : &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ). 명령 행 프롬프트의 추가 가능성에 대해서는 C / C ++ 매뉴얼을 읽으십시오 (PARAMETER-PROMPTING 찾기).</target>
        </trans-unit>
        <trans-unit id="0e1074481eb31b2beb0a93b170e055ca8fbaf015" translate="yes" xml:space="preserve">
          <source>First you get the BS2000 commandline prompt ('*'). Here you may enter your parameters, e.g. &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (note the double backslash!) or &lt;code&gt;-w&lt;/code&gt; and the name of your Perl script. Filenames starting with &lt;code&gt;/&lt;/code&gt; are searched in the Posix filesystem, others are searched in the BS2000 filesystem. You may even use wildcards if you put a &lt;code&gt;%&lt;/code&gt; in front of your filename (e.g. &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt;). Read your C/C++ manual for additional possibilities of the commandline prompt (look for PARAMETER-PROMPTING).</source>
          <target state="translated">먼저 BS2000 명령 줄 프롬프트 ( '*')가 나타납니다. 여기에 매개 변수를 입력 할 수 있습니다. 예 : &lt;code&gt;-e 'print &quot;Hello World!\\n&quot;;'&lt;/code&gt; (이중 백 슬래시에 유의하십시오!) 또는 &lt;code&gt;-w&lt;/code&gt; 및 Perl 스크립트 이름. &lt;code&gt;/&lt;/code&gt; 로 시작하는 파일 이름 은 Posix 파일 시스템에서 검색되고 다른 파일은 BS2000 파일 시스템에서 검색됩니다. 파일 이름 앞에 &lt;code&gt;%&lt;/code&gt; 를 넣으면 와일드 카드를 사용할 수도 있습니다 (예 : &lt;code&gt;-w checkfiles.pl %*.c&lt;/code&gt; ). 명령 줄 프롬프트의 추가 가능성에 대해서는 C / C ++ 설명서를 읽으십시오 (PARAMETER-PROMPTING 찾기).</target>
        </trans-unit>
        <trans-unit id="69813602a455899e097cd99c025cf3e1ca0fd741" translate="yes" xml:space="preserve">
          <source>First you'll need to know how to convert between C types and Perl types, with newSViv() and sv_setnv() and newAV() and all their friends. They're described in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">먼저 newSViv () 및 sv_setnv () 및 newAV () 및 모든 친구와 함께 C 유형과 Perl 유형 간 변환 방법을 알아야합니다. 그것들은 &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; 와 &lt;a href=&quot;perlapi&quot;&gt;perlapi에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d47635cc5b345a29da6fbd6f1b60ef579fbee7af" translate="yes" xml:space="preserve">
          <source>First,</source>
          <target state="translated">First,</target>
        </trans-unit>
        <trans-unit id="d7c19c1fc6c3dbafd3921057c37d39372855cf85" translate="yes" xml:space="preserve">
          <source>First, adding the new possessive &lt;code&gt;+&lt;/code&gt; to any quantifier finds the longest match and does not backtrack. That's important since you want to handle any angle brackets through the recursion, not backtracking. The group &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; finds one or more non-angle brackets without backtracking.</source>
          <target state="translated">먼저, 새로운 소유 &lt;code&gt;+&lt;/code&gt; 를 수량 자에 추가하면 가장 긴 일치 항목을 찾고 역 추적하지 않습니다. 역 추적이 아닌 재귀를 통해 앵글 브래킷을 처리하려고하기 때문에 중요합니다. &lt;code&gt;[^&amp;lt;&amp;gt;]++&lt;/code&gt; 그룹 은 역 추적없이 하나 이상의 앵글이없는 괄호를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="50b1a9b57fc0e96ef3cb9ee0ed192e6dd3187f0f" translate="yes" xml:space="preserve">
          <source>First, an easy one. Rather than having debugging code that is all-or-nothing, it would be much more useful to be able to control which specific blocks of debugging code get included. Try extending the syntax for debug blocks to allow each to be identified. The contents of the &lt;code&gt;DEBUG&lt;/code&gt; environment variable can then be used to control which blocks get included.</source>
          <target state="translated">먼저 쉬운 일입니다. 전혀 또는 전혀 디버깅 코드를 사용하지 않고 디버깅 코드의 특정 블록이 포함되도록 제어하는 ​​것이 훨씬 유용합니다. 디버그 블록의 구문을 확장하여 각각을 식별 할 수 있도록하십시오. 그런 다음 &lt;code&gt;DEBUG&lt;/code&gt; 환경 변수 의 내용을 사용하여 포함 할 블록을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1e59ee032bf3e9e20cd69af8996ee89b862626" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; . (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .)</source>
          <target state="translated">먼저, 모듈이 시스템에 없는지 확인하십시오. &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 을 시도하십시오 . ( &quot;Foo&quot;를 모듈 이름으로 &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="7b89c936bc5ff3bf6eeb7c0528bfdef316cf1b24" translate="yes" xml:space="preserve">
          <source>First, are you sure that the module isn't already on your system? Try &lt;code&gt;perl -MFoo -e 1&lt;/code&gt;. (Replace &quot;Foo&quot; with the name of the module; for instance, &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt;.)</source>
          <target state="translated">먼저 모듈이 시스템에없는 것이 확실합니까? &lt;code&gt;perl -MFoo -e 1&lt;/code&gt; 을 시도하십시오 . ( &quot;Foo&quot;를 모듈 이름으로 &lt;code&gt;perl -MCGI::Carp -e 1&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="5ebaf97085b1af9a8aca032d5654d4392116d444" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">먼저 CPAN에서 모듈 패키지를 다운로드하십시오 (예 : &quot;쉼표로 구분 된 값&quot;텍스트 패키지, Text-CSV-0.01.tar.gz). 그런 다음 패키지의 내용을 디스크의 특정 위치로 확장하십시오. 대부분의 CPAN 모듈은 내부 디렉토리 구조로 빌드되므로 일반적으로 DJGPP 설치의 루트에서 확장하는 것이 안전합니다. 어떤 사람들은 / usr / src (예 : &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ) 아래에 소스 트리를 찾는 것을 선호 하지만, 펄 소스 코드와 같은 디렉토리 아래 * EXCEPT *가 가장 논리적으로 보이는 곳에 둘 수 있습니다. CPAN의 대부분의 모듈에는 적용되지 않는 perl 소스 트리에있는 모듈에 적용되는 특수 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4cf2a47c74d08c7608aab2490244eccf86d59a1" translate="yes" xml:space="preserve">
          <source>First, download the module package from CPAN (e.g., the &quot;Comma Separated Value&quot; text package, Text-CSV-0.01.tar.gz). Then expand the contents of the package into some location on your disk. Most CPAN modules are built with an internal directory structure, so it is usually safe to expand it in the root of your DJGPP installation. Some people prefer to locate source trees under /usr/src (i.e., &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt;), but you may put it wherever seems most logical to you, *EXCEPT* under the same directory as your perl source code. There are special rules that apply to modules which live in the perl source tree that do not apply to most of the modules in CPAN.</source>
          <target state="translated">먼저 CPAN에서 모듈 패키지를 다운로드합니다 (예 : &quot;쉼표로 구분 된 값&quot;텍스트 패키지, Text-CSV-0.01.tar.gz). 그런 다음 패키지의 내용을 디스크의 특정 위치로 확장합니다. 대부분의 CPAN 모듈은 내부 디렉토리 구조로 빌드되므로 일반적으로 DJGPP 설치의 루트에서 확장하는 것이 안전합니다. 어떤 사람들은 / usr / src (즉, &lt;code&gt;($DJDIR)/usr/src&lt;/code&gt; ) 아래에 소스 트리를 찾는 것을 선호 하지만, 펄 소스 코드와 같은 디렉토리 아래에 * EXCEPT *처럼 가장 논리적으로 보이는 곳에 둘 수 있습니다. CPAN의 대부분의 모듈에 적용되지 않는 perl 소스 트리에있는 모듈에 적용되는 특수 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd8c84d305c51b13e814aea0158d4e7f9348781" translate="yes" xml:space="preserve">
          <source>First, ensure that you've found an actual bug. Second, ensure you've found an actual bug.</source>
          <target state="translated">먼저 실제 버그를 발견했는지 확인하십시오. 둘째, 실제 버그를 발견했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ae1f5078345edb7a706a89221e3d6b7ce9cef2cd" translate="yes" xml:space="preserve">
          <source>First, export the path to the SDK into the build environment:</source>
          <target state="translated">먼저 SDK 경로를 빌드 환경으로 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="f736b2c3892c2f343a0b6266829dd11c79e488a9" translate="yes" xml:space="preserve">
          <source>First, get rid of the libperl.dylib:</source>
          <target state="translated">먼저 libperl.dylib를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="152625e23957ee1b161f4b03465822ac30d6d72d" translate="yes" xml:space="preserve">
          <source>First, it can be confusing to read. In the above example, it's not clear if &lt;code&gt;save&lt;/code&gt; is a method provided by the &lt;code&gt;File&lt;/code&gt; class or simply a subroutine that expects a file object as its first argument.</source>
          <target state="translated">첫째, 읽기가 혼란 스러울 수 있습니다. 위의 예에서, &lt;code&gt;save&lt;/code&gt; 가 &lt;code&gt;File&lt;/code&gt; 클래스에 의해 제공되는 메소드 인지 또는 파일 오브젝트를 첫 번째 인수로 예상하는 서브 루틴인지는 확실하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d7b42a2c11d81d6afadf3ea1e473b60b0c267e3" translate="yes" xml:space="preserve">
          <source>First, it determines the linearized C3 MRO of the object or class it is being called on.</source>
          <target state="translated">먼저, 호출중인 오브젝트 또는 클래스의 선형화 된 C3 MRO를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="fb4ac5a946a8d4958fc6dfdd3a7c2b8f9b12b58f" translate="yes" xml:space="preserve">
          <source>First, let's look at reading it in from a file. This is something like adding a row at a time. We'll assume that there's a flat file in which each line is a row and each word an element. If you're trying to develop an @AoA array containing all these, here's the right way to do that:</source>
          <target state="translated">먼저 파일에서 읽어 보도록하겠습니다. 한 번에 행을 추가하는 것과 같습니다. 각 줄이 행이고 각 단어가 요소 인 플랫 파일이 있다고 가정합니다. 이 모든 것을 포함하는 @AoA 배열을 개발하려는 경우 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78e2d97b2606f5e4646f167be6edb794b2d59b32" translate="yes" xml:space="preserve">
          <source>First, make a local branch and switch to it:</source>
          <target state="translated">먼저 로컬 브랜치를 만들고 전환합니다.</target>
        </trans-unit>
        <trans-unit id="7e9e25e60917815bcdbb3181b9454d4fd283b6a1" translate="yes" xml:space="preserve">
          <source>First, make sure you have the latest &lt;b&gt;cpan-mac&lt;/b&gt; distribution ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ), which has utilities for doing all of the steps. Read the cpan-mac directions carefully and install it. If you choose not to use cpan-mac for some reason, there are alternatives listed here.</source>
          <target state="translated">먼저 모든 단계를 수행하기위한 유틸리티 가있는 최신 &lt;b&gt;cpan-mac&lt;/b&gt; 배포판 ( &lt;a href=&quot;http://www.cpan.org/authors/id/CNANDOR/&quot;&gt;http://www.cpan.org/authors/id/CNANDOR/&lt;/a&gt; ) 이 있는지 확인 하십시오. cpan-mac 지시 사항을주의해서 읽고 설치하십시오. 어떤 이유로 cpan-mac을 사용하지 않기로 선택한 경우 여기에 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff45e7f3f7ac11b2b708c0549868f02253d3144" translate="yes" xml:space="preserve">
          <source>First, please read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; for details on hacking the Perl core. That document covers many details on how to create a good patch.</source>
          <target state="translated">먼저 Perl 코어 해킹에 대한 자세한 내용은 &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; 을 참조하십시오. 이 문서는 좋은 패치를 만드는 방법에 대한 많은 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="5e4209086a0693a3c62d398c3fd3a79469cf0aa1" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;유니 코드 보안 고려 사항을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7f75f2ff97115a58ce045c83a79898c0c702db3b" translate="yes" xml:space="preserve">
          <source>First, read &lt;a href=&quot;https://www.unicode.org/reports/tr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;https://www.unicode.org/reports/tr36&quot;&gt;유니 코드 보안 고려 사항을&lt;/a&gt; 읽어 보십시오 .</target>
        </trans-unit>
        <trans-unit id="1be4fd7c33f5ba283ee1991244bc33bbae5e14ad" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt; , and gives you a reference to that array.</source>
          <target state="translated">먼저 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 은 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 포함하는 익명 배열을 만들고 해당 배열에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2c9778c828ac452ecd15f39d014e052e50b62a3b" translate="yes" xml:space="preserve">
          <source>First, remember that &lt;code&gt;[1, 2, 3]&lt;/code&gt; makes an anonymous array containing &lt;code&gt;(1, 2, 3)&lt;/code&gt;, and gives you a reference to that array.</source>
          <target state="translated">먼저 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 은 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 포함하는 익명 배열을 만들고 해당 배열에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1aab1dc764048d005c10306d35fb8721fb57f5b8" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;Finding locales&quot;&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">먼저 &lt;a href=&quot;#Finding-locales&quot;&gt;&quot;로케일 찾기&quot;&lt;/a&gt; 에 대한이 문서의 앞부분을 참조하십시오 . 이는 시스템에서 실제로 지원되는 로케일, 더 중요한 것은 설치되어있는 로케일을 찾는 방법을 알려줍니다. 예제 오류 메시지에서 로케일에 영향을 미치는 환경 변수는 중요도가 감소하는 순서대로 나열됩니다 (설정되지 않은 변수는 중요하지 않음). 따라서 LC_ALL을 &quot;En_US&quot;로 설정하는 것은 오류 메시지에 표시된 것처럼 잘못된 선택이어야합니다. 먼저 먼저 나열된 로케일 설정을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab31ac192075d493669c9807b4d74587336e2089" translate="yes" xml:space="preserve">
          <source>First, see earlier in this document about &lt;a href=&quot;#Finding-locales&quot;&gt;Finding locales&lt;/a&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having LC_ALL set to &quot;En_US&quot; must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.</source>
          <target state="translated">먼저이 문서의 앞부분에서 &lt;a href=&quot;#Finding-locales&quot;&gt;로캘 찾기&lt;/a&gt; 에 대해 참조하십시오 . 시스템에서 실제로 지원되는 로케일을 찾는 방법을 알려줍니다. 예제 오류 메시지에서 로케일에 영향을주는 환경 변수는 중요도가 감소하는 순서대로 나열되며 설정되지 않은 변수는 중요하지 않습니다. 따라서 LC_ALL을 &quot;En_US&quot;로 설정하면 오류 메시지에 표시된대로 잘못된 선택이되어야합니다. 먼저 로케일 설정을 먼저 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c27578c07f284f149f1e59f8dc0cd46db350e08e" translate="yes" xml:space="preserve">
          <source>First, see the answer to &quot;Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?&quot;.</source>
          <target state="translated">먼저, &quot;내가 얻는 숫자 (예 : 19.95) 대신 십진수 (예 : 19.9499999999999)를 얻는 이유는 무엇입니까?&quot;에 대한 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7929df02929344c4da8c51ff70c78d4168b4050" translate="yes" xml:space="preserve">
          <source>First, type &lt;code&gt;ppm&lt;/code&gt; from a shell and see whether ActiveState's PPM repository has your module. If so, you can install it with &lt;code&gt;ppm&lt;/code&gt; and you won't have to bother with any of the other steps here. You might be able to use the CPAN instructions from the &quot;Unix or Linux&quot; section above as well; give it a try. Otherwise, you'll have to follow the steps below.</source>
          <target state="translated">먼저 쉘에서 &lt;code&gt;ppm&lt;/code&gt; 을 입력 하고 ActiveState의 PPM 저장소에 모듈이 있는지 확인하십시오. 그렇다면 &lt;code&gt;ppm&lt;/code&gt; 으로 설치할 수 있으며 여기에서 다른 단계를 수행 할 필요가 없습니다. 위의 &quot;Unix 또는 Linux&quot;섹션에서 CPAN 명령어를 사용할 수도 있습니다. 시도 해봐. 그렇지 않으면 아래 단계를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="4cf149afbf1f752337e23fcd4bf31955a925b612" translate="yes" xml:space="preserve">
          <source>First, we can calculate the plan dynamically using the &lt;code&gt;plan()&lt;/code&gt; function.</source>
          <target state="translated">먼저 &lt;code&gt;plan()&lt;/code&gt; 함수를 사용하여 계획을 동적으로 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="faab21d0b75e81479aa73f86a04f0c512fa41039" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt; .</source>
          <target state="translated">먼저 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 포함하여 여러 함수를 필터 네임 스페이스로 내 보냅니다. 위에 표시된 필터는 &lt;code&gt;filter_add()&lt;/code&gt; 및 &lt;code&gt;filter_read()&lt;/code&gt; 함수 중 두 가지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b7666b71edfd993b3751616f817f20d8eb76a68d" translate="yes" xml:space="preserve">
          <source>First, we include the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module, which exports a number of functions into your filter's namespace. The filter shown above uses two of these functions, &lt;code&gt;filter_add()&lt;/code&gt; and &lt;code&gt;filter_read()&lt;/code&gt;.</source>
          <target state="translated">먼저 필터의 네임 스페이스로 여러 함수를 내보내는 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 모듈을 포함합니다. 위에 표시된 필터는 이러한 함수 중 두 가지 인 &lt;code&gt;filter_add()&lt;/code&gt; 및 &lt;code&gt;filter_read()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7bf86c04e9a07ad8ffe5ebc09738e5cc682edbbb" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt; . A repeat count unpacks all 12 shorts:</source>
          <target state="translated">먼저, 우리는이 명예로운 16 비트 CPU가 리틀 엔디안 순서를 사용하므로 하위 바이트가 하위 주소에 저장되는 이유에 주목합니다. 그러한 (부호없는) short를 풀려면 코드 &lt;code&gt;v&lt;/code&gt; 를 사용해야합니다 . 반복 횟수는 12 개의 반바지를 모두 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="08bfd01e98e4edde23ed3f05bac3b5bc4b695e5c" translate="yes" xml:space="preserve">
          <source>First, we note that this time-honored 16-bit CPU uses little-endian order, and that's why the low order byte is stored at the lower address. To unpack such a (unsigned) short we'll have to use code &lt;code&gt;v&lt;/code&gt;. A repeat count unpacks all 12 shorts:</source>
          <target state="translated">먼저,이 유서 깊은 16 비트 CPU는 리틀 엔디안 순서를 사용하므로 하위 주소에 하위 바이트가 저장됩니다. 그러한 (서명되지 않은) 짧은 것을 풀기 위해 우리는 코드 &lt;code&gt;v&lt;/code&gt; 를 사용해야 할 것 입니다. 반복 횟수는 12 개의 반바지를 모두 풉니 다.</target>
        </trans-unit>
        <trans-unit id="5ec66f264026749a912802e1ee6df172076171fc" translate="yes" xml:space="preserve">
          <source>First, we'll look at the &lt;code&gt;Perl_yylex&lt;/code&gt; function in the lexer. We want to look for &lt;code&gt;case 'x'&lt;/code&gt;, where x is the first character of the operator. (Incidentally, when looking for the code that handles a keyword, you'll want to search for &lt;code&gt;KEY_foo&lt;/code&gt; where &quot;foo&quot; is the keyword.) Here is the code that handles assignment (there are quite a few operators beginning with &lt;code&gt;=&lt;/code&gt;, so most of it is omitted for brevity):</source>
          <target state="translated">먼저 어휘 분석기 의 &lt;code&gt;Perl_yylex&lt;/code&gt; 함수를 살펴 보겠습니다 . 우리는 &lt;code&gt;case 'x'&lt;/code&gt; 를 찾고자합니다. 여기서 x는 연산자의 첫 번째 문자입니다. (부수적으로 키워드를 처리하는 코드를 &lt;code&gt;KEY_foo&lt;/code&gt; 때 &quot;foo&quot;가 키워드 인 KEY_foo 를 검색 할 수 있습니다.) 다음은 할당을 처리하는 코드입니다 ( &lt;code&gt;=&lt;/code&gt; 로 시작하는 연산자가 상당히 많으므로 대부분 간결함을 위해 생략 됨) :</target>
        </trans-unit>
        <trans-unit id="d040ecc2c88831fcb5be8f38daefabb27bdc8362" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;&quot;Running&quot;&lt;/a&gt;.</source>
          <target state="translated">첫째, 어쨌든 op 트리는 무엇입니까? op 트리는 파싱에 대한 섹션에서 본 것처럼 프로그램의 파싱 된 표현이며, &lt;a href=&quot;#Running&quot;&gt;&quot;Running&quot;&lt;/a&gt; 에서 보았 듯이 Perl이 프로그램을 실행하기 위해 거치는 일련의 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="e1ae10fa25857645a38bd9df4324915b8e49d413" translate="yes" xml:space="preserve">
          <source>First, what is the op tree, anyway? The op tree is the parsed representation of your program, as we saw in our section on parsing, and it's the sequence of operations that Perl goes through to execute your program, as we saw in &lt;a href=&quot;#Running&quot;&gt;Running&lt;/a&gt;.</source>
          <target state="translated">먼저 op 트리는 무엇입니까? 우리는 구문 분석에 대한 우리의 섹션에서 본대로 영업 나무는, 프로그램의 구문 분석 된 표현이며, 펄은 우리가 본대로, 프로그램을 실행하기 위해 거치는 작업의 순서의 &lt;a href=&quot;#Running&quot;&gt;실행&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd0da866187697a74c7a4d585f209f050b0a6ff" translate="yes" xml:space="preserve">
          <source>First:</source>
          <target state="translated">First:</target>
        </trans-unit>
        <trans-unit id="cd289dddd1b3873e3f239eb60db04e88470eea20" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; . This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt; ) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">첫째 때 &lt;code&gt;inflate&lt;/code&gt; 아닌 다른 상태에 돌아왔다 &lt;code&gt;Z_OK&lt;/code&gt; 또는 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 을 . 이는 압축 된 데이터 스트림의 끝에 도달 했거나 ( &lt;code&gt;Z_STREAM_END&lt;/code&gt; ) 압축 된 데이터에 오류가 있음을 의미합니다. 두 경우 모두 압축 된 데이터를 계속 읽을 필요가 없으므로 두 루프가 모두 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="580dea99b6376e56628cd97fc38cd26b362ae9be" translate="yes" xml:space="preserve">
          <source>Firstly when &lt;code&gt;inflate&lt;/code&gt; has returned a status other than &lt;code&gt;Z_OK&lt;/code&gt; or &lt;code&gt;Z_BUF_ERROR&lt;/code&gt;. This means that either the end of the compressed data stream has been reached (&lt;code&gt;Z_STREAM_END&lt;/code&gt;) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.</source>
          <target state="translated">먼저 &lt;code&gt;inflate&lt;/code&gt; 이 &lt;code&gt;Z_OK&lt;/code&gt; 또는 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; 이외의 상태를 반환 했을 때 . 이는 압축 된 데이터 스트림의 끝에 도달 했거나 ( &lt;code&gt;Z_STREAM_END&lt;/code&gt; ) 압축 된 데이터에 오류가 있음을 의미합니다. 두 경우 모두 압축 된 데이터를 계속 읽을 필요가 없으므로 두 루프가 모두 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e91097a50eee7fb0157c9c563333af1f9aad192e" translate="yes" xml:space="preserve">
          <source>Firstly with &lt;code&gt;uncompress&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;uncompress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c691ee82803b4a1c09fe4ae85950833e593adf1e" translate="yes" xml:space="preserve">
          <source>Firstly, copy the source and build a native copy of perl for your host system. Then, in the source to be cross compiled:</source>
          <target state="translated">먼저 소스를 복사하고 호스트 시스템에 대한 기본 perl 사본을 빌드하십시오. 그런 다음 소스에서 크로스 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="b281be44ff171ec4ca97b3cec7cdd79193f13686" translate="yes" xml:space="preserve">
          <source>Firstly, here is code that uses &lt;code&gt;retr&lt;/code&gt; to uncompressed a file as it is read from the FTP Server.</source>
          <target state="translated">첫째, 다음은 FTP 서버에서 읽을 때 파일을 압축 해제하기 위해 &lt;code&gt;retr&lt;/code&gt; 을 사용하는 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="429b0e6343c2120d22b3e87cee9b0d4bae245bf0" translate="yes" xml:space="preserve">
          <source>Firstly, the code is considerably more complex than with the previous example.</source>
          <target state="translated">첫째, 코드는 이전 예제보다 훨씬 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="276509a617a885ae6ba6cc6313c1176be3ee48f5" translate="yes" xml:space="preserve">
          <source>Firstly, when either &lt;code&gt;filter&lt;/code&gt; or the anonymous sub are called, a local copy of &lt;code&gt;$_&lt;/code&gt; will automatically be created. It will always contain the empty string at this point.</source>
          <target state="translated">먼저, &lt;code&gt;filter&lt;/code&gt; 또는 익명 서브가 호출되면 &lt;code&gt;$_&lt;/code&gt; 의 로컬 사본 이 자동으로 작성됩니다. 이 시점에서 항상 빈 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2cac4ae7495bba4659c20ff2b612b63d1529752e" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">먼저 기존 코드의 기준 시간을 설정해야합니다.이 시간은 신뢰할 수 있고 반복 가능해야합니다. &lt;code&gt;Benchmark&lt;/code&gt; 를 사용 하거나 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 이 단계 Devel :: NYTProf 모듈 또는 이와 유사한 것을 사용하거나 Unix 시스템 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 유틸리티 중 적절한 것입니다. 더 긴 벤치마킹 및 프로파일 링 모듈 목록과 추가 권장 사항은이 문서의 기본을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0912ace39576f3bff8ff6347fdfed9f37c93af54" translate="yes" xml:space="preserve">
          <source>Firstly, you need to establish a baseline time for the existing code, which timing needs to be reliable and repeatable. You'll probably want to use the &lt;code&gt;Benchmark&lt;/code&gt; or &lt;code&gt;Devel::NYTProf&lt;/code&gt; modules, or something similar, for this step, or perhaps the Unix system &lt;code&gt;time&lt;/code&gt; utility, whichever is appropriate. See the base of this document for a longer list of benchmarking and profiling modules, and recommended further reading.</source>
          <target state="translated">첫째, 기존 코드의 기준 시간을 설정해야합니다.이 시간은 안정적이고 반복 가능해야합니다. 이 단계 에서 &lt;code&gt;Benchmark&lt;/code&gt; 또는 &lt;code&gt;Devel::NYTProf&lt;/code&gt; 모듈 또는 이와 유사한 것을 사용하거나 Unix 시스템 &lt;code&gt;time&lt;/code&gt; 유틸리티 중 적절한 것을 사용하고 싶을 것입니다. 벤치마킹 및 프로파일 링 모듈의 더 긴 목록과 권장되는 추가 자료는이 문서의베이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda4e517cc99c618a0166c7c1427ce12e089520b" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">특별히 명명 된 5 개의 코드 블록이 실행중인 Perl 프로그램의 시작과 끝에 실행됩니다. 이들은 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; 입니다 , &lt;code&gt;INIT&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 블록입니다.</target>
        </trans-unit>
        <trans-unit id="17ff08381265b477655a45e70fb5ae3e698605cc" translate="yes" xml:space="preserve">
          <source>Five specially named code blocks are executed at the beginning and at the end of a running Perl program. These are the &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, and &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">특별히 명명 된 5 개의 코드 블록은 실행중인 Perl 프로그램의 시작과 끝에서 실행됩니다. 이들은 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; 및 &lt;code&gt;END&lt;/code&gt; 블록입니다.</target>
        </trans-unit>
        <trans-unit id="c722bf4ef529e4eded31ce8c62d796cc90fbd29c" translate="yes" xml:space="preserve">
          <source>Fix as many discovered bugs as possible. Document all the bugs which are not fixed, and all the failures with unknown reasons. Inspect the produced logs</source>
          <target state="translated">발견 된 버그를 가능한 많이 수정하십시오. 수정되지 않은 모든 버그와 알 수없는 이유로 모든 실패를 기록하십시오. 생성 된 로그 검사</target>
        </trans-unit>
        <trans-unit id="df44dd4e66d3cab9cceb66ab9337728c16a604cb" translate="yes" xml:space="preserve">
          <source>Fix bugs!</source>
          <target state="translated">버그 수정!</target>
        </trans-unit>
        <trans-unit id="d9d2b0f6093e9267469793bea33648599961e32d" translate="yes" xml:space="preserve">
          <source>Fix exec, and exit in &quot;forked&quot; subprocesses.</source>
          <target state="translated">exec를 수정하고 &quot;forked&quot;하위 프로세스에서 종료합니다.</target>
        </trans-unit>
        <trans-unit id="f9517d098aab673cc930fe5f552eaf1cd6c8267f" translate="yes" xml:space="preserve">
          <source>Fix inheritance of environment variables by subprocesses.</source>
          <target state="translated">하위 프로세스에 의한 환경 변수의 상속을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="ae5904c927a01dfd60190d4b60c8207a1973b7d9" translate="yes" xml:space="preserve">
          <source>Fix issue where kill was using the wrong kind of process ID</source>
          <target state="translated">kill이 잘못된 종류의 프로세스 ID를 사용하는 문제 수정</target>
        </trans-unit>
        <trans-unit id="9bc92e3cff9e6a0dbd7ac3e0c0e26e4976790465" translate="yes" xml:space="preserve">
          <source>Fix issue with newlib's unlink, which could cause infinite loops.</source>
          <target state="translated">무한 루프가 발생할 수있는 newlib의 연결 해제 문제를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b83649da6d49364618a24bf1f42332f131fef232" translate="yes" xml:space="preserve">
          <source>Fixed characters</source>
          <target state="translated">고정 문자</target>
        </trans-unit>
        <trans-unit id="8fb62c73dff6424fec02bbefb83788e346747c19" translate="yes" xml:space="preserve">
          <source>Fixed existing link to YAML discussion thread to point to new &lt;a href=&quot;http://nntp.x.perl.org/group/&quot;&gt;http://nntp.x.perl.org/group/&lt;/a&gt; site.</source>
          <target state="translated">새로운 &lt;a href=&quot;http://nntp.x.perl.org/group/&quot;&gt;http://nntp.x.perl.org/group/&lt;/a&gt; 사이트 를 가리 키도록 YAML 토론 스레드에 대한 기존 링크를 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="30f24223efa38b1e0c821d29e1e2ff7c73dc2563" translate="yes" xml:space="preserve">
          <source>Fixed header size</source>
          <target state="translated">고정 헤더 크기</target>
        </trans-unit>
        <trans-unit id="1612bd15c9421b6746280d95829fe2d2256c0953" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.007</source>
          <target state="translated">버전에서 수정 됨 : 0.007</target>
        </trans-unit>
        <trans-unit id="f610e5ac87fab90f9565500603b8bb2a7f5611de" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.012</source>
          <target state="translated">버전에서 수정 됨 : 0.012</target>
        </trans-unit>
        <trans-unit id="cd7cd10c589a3c1a03bf67a931ca237c61708446" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.025</source>
          <target state="translated">버전에서 수정 됨 : 0.025</target>
        </trans-unit>
        <trans-unit id="7a6fc7d1e7bb925f0e155f6d3f8f4dd7c55cff80" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.04</source>
          <target state="translated">버전에서 수정 됨 : 0.04</target>
        </trans-unit>
        <trans-unit id="838194fc7cb5c547a3b4bbbf33000d2979b011eb" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.07</source>
          <target state="translated">버전에서 수정 됨 : 0.07</target>
        </trans-unit>
        <trans-unit id="1cda70e9024dd56f02f35dcb5eb32f0c7fbf2708" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.12</source>
          <target state="translated">버전에서 수정 됨 : 0.12</target>
        </trans-unit>
        <trans-unit id="f51cff993c578c025a312a4daf87907ca66414a9" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.15</source>
          <target state="translated">버전에서 수정 됨 : 0.15</target>
        </trans-unit>
        <trans-unit id="21e2f5911aadd9d8733160e7a729bf6a6f49643e" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.2.5</source>
          <target state="translated">버전에서 수정 됨 : 0.2.5</target>
        </trans-unit>
        <trans-unit id="9b7c26595c9e0a4a54b1ef55fb178f6deeee31ff" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.35</source>
          <target state="translated">버전에서 수정 됨 : 0.35</target>
        </trans-unit>
        <trans-unit id="91bd05ad86efd33899ea3b32b7ed1a482bc6997f" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.43</source>
          <target state="translated">버전에서 수정 됨 : 0.43</target>
        </trans-unit>
        <trans-unit id="e4082202243548ced8a0d06b10b7e9ffd11225f9" translate="yes" xml:space="preserve">
          <source>Fixed in version: 0.45</source>
          <target state="translated">버전에서 수정 됨 : 0.45</target>
        </trans-unit>
        <trans-unit id="fd7762ab1f09d953c6f1610b6340e1b5f2b6d726" translate="yes" xml:space="preserve">
          <source>Fixed in version: 1.1.4</source>
          <target state="translated">버전에서 수정 됨 : 1.1.4</target>
        </trans-unit>
        <trans-unit id="fdb1364271d22264a4012395e53d8c7918c07fa7" translate="yes" xml:space="preserve">
          <source>Fixed in version: 1.11</source>
          <target state="translated">버전에서 수정 됨 : 1.11</target>
        </trans-unit>
        <trans-unit id="388c87de5e532d033e7c749d0900a68a3b45fb12" translate="yes" xml:space="preserve">
          <source>Fixed in version: 2.15</source>
          <target state="translated">버전에서 수정 됨 : 2.15</target>
        </trans-unit>
        <trans-unit id="f9a93260b08de69ccea121c2ab5c95665512b9b8" translate="yes" xml:space="preserve">
          <source>Fixed some dead links to point to active resources.</source>
          <target state="translated">활성 리소스를 가리 키도록 일부 죽은 링크를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="ecfb2a96b4b5f73e1fa6089350af79bfe24ae8f4" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">Tels에 의한 고정, 속도 향상 및 향상 &lt;a href=&quot;http://bloodgate.com&quot;&gt; http://bloodgate.com&lt;/a&gt; 2001-2003에 . Tels 2004-2007에 의한 추가 간소화 (api_version 1 등).</target>
        </trans-unit>
        <trans-unit id="330c21b294e09432feca3391543087a4db397d9c" translate="yes" xml:space="preserve">
          <source>Fixed, sped-up and enhanced by Tels http://bloodgate.com 2001-2003. Further streamlining (api_version 1 etc.) by Tels 2004-2007.</source>
          <target state="translated">Tels http://bloodgate.com 2001-2003에 의해 수정, 속도 향상 및 향상되었습니다. Tels 2004-2007에 의한 추가 간소화 (api_version 1 등).</target>
        </trans-unit>
        <trans-unit id="405b043abf0e87a42c31429945169f0dd7c5d88d" translate="yes" xml:space="preserve">
          <source>Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.</source>
          <target state="translated">Tels 2001-2007에 의해 수정, 속도 향상, 간소화 및 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ca59c972a528af8e7a14352bd6c37f9e70222bb" translate="yes" xml:space="preserve">
          <source>Fixed-length mode. Leave-blanks mode.</source>
          <target state="translated">고정 길이 모드. 공백 모드.</target>
        </trans-unit>
        <trans-unit id="f1659338bac13f477d12cd7d829279169513026b" translate="yes" xml:space="preserve">
          <source>Fixed-length record format.</source>
          <target state="translated">고정 길이 레코드 형식.</target>
        </trans-unit>
        <trans-unit id="959687f22ec208a2b336a28e627dad8c7a247264" translate="yes" xml:space="preserve">
          <source>Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">고정 테이블 크기, 고정 키 길이 해싱</target>
        </trans-unit>
        <trans-unit id="d34a8295ae4d44653579918a6b463ec2c7d9fc59" translate="yes" xml:space="preserve">
          <source>Fixes up numerous file and directory macros to insure VMS syntax regardless of input syntax. Also makes lists of files comma-separated.</source>
          <target state="translated">입력 구문에 관계없이 VMS 구문을 보장하기 위해 수많은 파일 및 디렉토리 매크로를 수정합니다. 또한 파일 목록을 쉼표로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="d40ac06cf36190f3752a227ce1d3e621fc0665b2" translate="yes" xml:space="preserve">
          <source>Fixing security issues and user-visible bugs in the core</source>
          <target state="translated">핵심 보안 문제 및 사용자가 볼 수있는 버그 수정</target>
        </trans-unit>
        <trans-unit id="29642e3ca9418aa5ace5fd4900eeec9b27f8007e" translate="yes" xml:space="preserve">
          <source>Fixing system locale configuration</source>
          <target state="translated">시스템 로케일 구성 수정</target>
        </trans-unit>
        <trans-unit id="73cc249f918f8969b3fba39295da9b9b7fa5e26c" translate="yes" xml:space="preserve">
          <source>Flag bits modifying the behavior of an object handle and accessed via &lt;code&gt;GetHandleInformation&lt;/code&gt; and &lt;code&gt;SetHandleInformation&lt;/code&gt;.</source>
          <target state="translated">개체 핸들의 동작을 수정하고 &lt;code&gt;GetHandleInformation&lt;/code&gt; 및 &lt;code&gt;SetHandleInformation&lt;/code&gt; 을 통해 액세스하는 플래그 비트 입니다.</target>
        </trans-unit>
        <trans-unit id="daddf7d8bd736866de91cc44a32f0bc29d86f601" translate="yes" xml:space="preserve">
          <source>Flags =&amp;gt; $uFlags</source>
          <target state="translated">플래그 =&amp;gt; $ uFlags</target>
        </trans-unit>
        <trans-unit id="d83689a42f870aeb8b820eedd460f0c265e2f627" translate="yes" xml:space="preserve">
          <source>Flags are ORed together values, such as &lt;code&gt;MSG_BCAST&lt;/code&gt;, &lt;code&gt;MSG_OOB&lt;/code&gt;, &lt;code&gt;MSG_TRUNC&lt;/code&gt;. The default value for the flags is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">플래그는 &lt;code&gt;MSG_BCAST&lt;/code&gt; , &lt;code&gt;MSG_OOB&lt;/code&gt; , &lt;code&gt;MSG_TRUNC&lt;/code&gt; 와 같이 OR로 연결된 값 입니다. 플래그의 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86b4613698349d05ae2cbeb0e1d73fba54ce4b08" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;&quot;Using regular expressions in Perl&quot; in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;perlretut의 &quot;Perl에서 정규식 사용&quot;에&lt;/a&gt; 자세히 설명 된 플래그 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6014390aa4fd7e389a7243e9000e4c32cd912a43" translate="yes" xml:space="preserve">
          <source>Flags described further in &lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;Using regular expressions in Perl in perlretut&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;perlretut#Using-regular-expressions-in-Perl&quot;&gt;perlretut에서 Perl에서 정규 표현식 사용에&lt;/a&gt; 자세히 설명 된 플래그 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95cffe720f5843720b2f2791ed48ac4c103a313f" translate="yes" xml:space="preserve">
          <source>Flags may be one of:</source>
          <target state="translated">플래그는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adc8e7329bf4555216d7a3bfa9cef9955718902b" translate="yes" xml:space="preserve">
          <source>Flags. Use one of:</source>
          <target state="translated">깃발. 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6103463409204cb527cdac9c41a9a07b15e276a0" translate="yes" xml:space="preserve">
          <source>Flavors of Perl numeric operations</source>
          <target state="translated">Perl 숫자 연산의 풍미</target>
        </trans-unit>
        <trans-unit id="8b3926c9cc6bcbb663057b65eb8ebe30826dbb42" translate="yes" xml:space="preserve">
          <source>Floating Point Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용한 부동 소수점 이상</target>
        </trans-unit>
        <trans-unit id="5a5e19070c0cf7a423dbae9f66841c3fabf1ca2c" translate="yes" xml:space="preserve">
          <source>Floating point Numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cdc8e382e56841728abcd2d046d6a53518ddf43c" translate="yes" xml:space="preserve">
          <source>Floating point anomalies on BS2000</source>
          <target state="translated">BS2000의 부동 소수점 이상</target>
        </trans-unit>
        <trans-unit id="6458d7358a6010e05479d7d3065fd1dc70e53021" translate="yes" xml:space="preserve">
          <source>Floating point comparisons which handle the &lt;code&gt;NaN&lt;/code&gt; [C99].</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 을 처리하는 부동 소수점 비교 [C99]</target>
        </trans-unit>
        <trans-unit id="12643a69610ec7d65c380165a5bf7f423a31ce49" translate="yes" xml:space="preserve">
          <source>Floating point constants are truncated to integer. All parts and results of expressions are also truncated.</source>
          <target state="translated">부동 소수점 상수는 정수로 잘립니다. 식의 모든 부분과 결과도 잘립니다.</target>
        </trans-unit>
        <trans-unit id="cede3872ee4aa83d2bda6798fe8042b21fbcd8fe" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; , for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">부동 소수점 값에는 특수 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 이 포함됩니다. 무한대 및 숫자가 아닌 . 무한대도 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8d0ea7718d52d1572fd73c8242126ae8862128" translate="yes" xml:space="preserve">
          <source>Floating point values include the special values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;, for infinity and not-a-number. The infinity can be also negative.</source>
          <target state="translated">부동 소수점 값에는 무한대 및 숫자가 아닌 특수 값 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 이 포함됩니다 . 무한대는 음수 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="709713db0a0caca978c5c319c22711e133d5178a" translate="yes" xml:space="preserve">
          <source>Floating-point Arithmetic</source>
          <target state="translated">부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="c49d97794f62dac628d25ae12fcfb3dd4f71313b" translate="yes" xml:space="preserve">
          <source>Floating-point numbers are only approximations to what a mathematician would call real numbers. There are infinitely more reals than floats, so some corners must be cut. For example:</source>
          <target state="translated">부동 소수점 숫자는 수학자가 실수라고 부르는 것에 대한 근사치 일뿐입니다. 수레보다 무한히 많은 실수가 있으므로 일부 모서리를 잘라야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6477529bc9646ecedaf8e4ae8b6c8d51a8bc8383" translate="yes" xml:space="preserve">
          <source>Floppy, Zip, Offline Mode</source>
          <target state="translated">플로피, 우편, 오프라인 모드</target>
        </trans-unit>
        <trans-unit id="8adaf25b2605056f2e07d65e18faabac22731925" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz</source>
          <target state="translated">플로리안 라 비츠</target>
        </trans-unit>
        <trans-unit id="15fba67b0eee19071b7f3acb8dc1d2691dff0393" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz &amp;lt;flora@cpan.org&amp;gt;, 2010.</source>
          <target state="translated">Florian Ragwitz &amp;lt;flora@cpan.org&amp;gt;, 2010.</target>
        </trans-unit>
        <trans-unit id="cc546391510adffd5d42495f4fcd24b543fc28de" translate="yes" xml:space="preserve">
          <source>Florian Ragwitz &amp;lt;rafl@debian.org&amp;gt;</source>
          <target state="translated">Florian Ragwitz &amp;lt;rafl@debian.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7c936d7c5a91dca9198671c84f6c29001e1635e0" translate="yes" xml:space="preserve">
          <source>Flush</source>
          <target state="translated">Flush</target>
        </trans-unit>
        <trans-unit id="8a27fc117a1fc8843011dfb82df5f33f7d437936" translate="yes" xml:space="preserve">
          <source>Flush any buffered write data. May possibly be called on readable handles too. Should return 0 on success, -1 on error.</source>
          <target state="translated">버퍼링 된 쓰기 데이터를 비 웁니다. 읽기 가능한 핸들에서도 호출 될 수 있습니다. 성공하면 0을, 에러이면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="209099cf56b373e5745037d20085b43c5b416a14" translate="yes" xml:space="preserve">
          <source>Flush the cache.</source>
          <target state="translated">캐시를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ea0600877c74e6c0fe89bbd3afcee971963f892" translate="yes" xml:space="preserve">
          <source>Flushes all pending output into the compressed file.</source>
          <target state="translated">보류중인 모든 출력을 압축 파일로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="082adecce9ec5788047efdf4da353f56b28da59d" translate="yes" xml:space="preserve">
          <source>Flushes any cached buffers to disk.</source>
          <target state="translated">캐시 된 버퍼를 디스크에 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="0946db717a74209041c8e2e8789decc09b0c8c1a" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data and then closes the output file/buffer.</source>
          <target state="translated">보류중인 압축 데이터를 플러시 한 다음 출력 파일 / 버퍼를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="cd9697be2c5b575554432a6587a955d4836a8e65" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">보류중인 압축 데이터를 &lt;code&gt;$output&lt;/code&gt; 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="3ff0666143651d5f03566ea681f5c75e80fe909d" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt;.</source>
          <target state="translated">보류중인 압축 데이터를 &lt;code&gt;$output&lt;/code&gt; 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="3085611069b17b4d4af56b56fce73f275cd2d511" translate="yes" xml:space="preserve">
          <source>Flushes any pending compressed data to the output file/buffer.</source>
          <target state="translated">보류중인 압축 데이터를 출력 파일 / 버퍼로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="4773551f475406069f00051e9d104d3a35f79ad2" translate="yes" xml:space="preserve">
          <source>Flushes the directory cache.</source>
          <target state="translated">디렉토리 캐시를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="928fef4d7417d4484f1f3fc7a84c5c97a0c10f03" translate="yes" xml:space="preserve">
          <source>Foldcase</source>
          <target state="translated">Foldcase</target>
        </trans-unit>
        <trans-unit id="8b66e3d01ed62d27bcca95567dd515e099e2e9d3" translate="yes" xml:space="preserve">
          <source>Follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; 의 지침을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="630bce1629a6b0e8bb4da21f695760c25a3efb55" translate="yes" xml:space="preserve">
          <source>Follow the instructions and links on:</source>
          <target state="translated">다음의 지시 사항과 링크를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="444ce8dc04bb6c539c04e93cd526f6da5b1561ad" translate="yes" xml:space="preserve">
          <source>Follow the instructions in</source>
          <target state="translated">의 지침을 따르십시오</target>
        </trans-unit>
        <trans-unit id="e85aee671a6a0df6df7d5aaa8c5a698b13785622" translate="yes" xml:space="preserve">
          <source>Follow the messages ... and you're done.</source>
          <target state="translated">메시지를 따르십시오 ... 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="e08690a98d641e3cbc8171b5ab25389a2271c13b" translate="yes" xml:space="preserve">
          <source>Follow the normal instructions for building perl; e.g, enter bash, run the Configure script, then use &quot;gmake&quot; to build perl.</source>
          <target state="translated">Perl 빌드에 대한 일반적인 지시 사항을 따르십시오. 예를 들어, bash를 입력하고 Configure 스크립트를 실행 한 다음 &quot;gmake&quot;를 사용하여 perl을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="864440f25ee94f2eebf5d9e755372bbba17b62ef" translate="yes" xml:space="preserve">
          <source>Followed by a view command to see where we are:</source>
          <target state="translated">다음 위치에보기 명령이옵니다.</target>
        </trans-unit>
        <trans-unit id="1a41044e3e9273867bb8cc0dfd68db2b82f20837" translate="yes" xml:space="preserve">
          <source>Following bisection you may wish to configure, build and test perl at commits identified by the bisection process. Sometimes, particularly with older perls, &lt;code&gt;make&lt;/code&gt; may fail during this process. In this case you may be able to patch the source code at the older commit point. To do so, please follow the suggestions provided in &lt;a href=&quot;perlhack#Building-perl-at-older-commits&quot;&gt;&quot;Building perl at older commits&quot; in perlhack&lt;/a&gt;.</source>
          <target state="translated">이분법 후에는 이분법 프로세스에 의해 식별 된 커밋에서 perl을 구성, 빌드 및 테스트 할 수 있습니다. 때로는 특히 오래된 perls의 경우이 프로세스 중에 &lt;code&gt;make&lt;/code&gt; 가 실패 할 수 있습니다. 이 경우 이전 커밋 지점에서 소스 코드를 패치 할 수 있습니다. 그렇게하려면 &lt;a href=&quot;perlhack#Building-perl-at-older-commits&quot;&gt;perlhack의 &quot;이전 커밋에서 perl 빌드&quot;에&lt;/a&gt; 제공된 제안을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="d2431a18b10300a9cb947cadd732f97519440b32" translate="yes" xml:space="preserve">
          <source>Following codes are same.</source>
          <target state="translated">다음 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1a1472c72b3b35650919410041b1e204b2d5f373" translate="yes" xml:space="preserve">
          <source>Following the normal convention of sixteen-color emulators, this module provides a pair of attributes for each color. For every normal color (0 through 7), the corresponding bright color (8 through 15) is obtained by prepending the string &lt;code&gt;bright_&lt;/code&gt; to the normal color name. For example, &lt;code&gt;red&lt;/code&gt; is color 1 and &lt;code&gt;bright_red&lt;/code&gt; is color 9. The same applies for background colors: &lt;code&gt;on_red&lt;/code&gt; is the normal color and &lt;code&gt;on_bright_red&lt;/code&gt; is the bright color. Capitalize these strings for the constant interface.</source>
          <target state="translated">16 색 에뮬레이터의 일반적인 규칙에 따라이 모듈은 각 색상에 대한 한 쌍의 속성을 제공합니다. 모든 일반 색상 (0 ~ 7)에 대해 문자열 &lt;code&gt;bright_&lt;/code&gt; 를 일반 색상 이름 앞에 붙여 해당 밝은 색상 (8 ~ 15)을 얻습니다 . 예를 들어, &lt;code&gt;red&lt;/code&gt; 은 색상 1이고 &lt;code&gt;bright_red&lt;/code&gt; 는 색상 9입니다. 배경색에도 동일하게 적용됩니다. &lt;code&gt;on_red&lt;/code&gt; 는 일반 색상이고 &lt;code&gt;on_bright_red&lt;/code&gt; 는 밝은 색상입니다. 일정한 인터페이스를 위해이 문자열을 대문자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="339a6f2fa2aeea3b1c39c8b8cdd86cfc5ca212f8" translate="yes" xml:space="preserve">
          <source>Following the optimizer information is a dump of the offset/length table, here split across several lines:</source>
          <target state="translated">옵티 마이저 정보 다음에는 오프셋 / 길이 테이블의 덤프가 있습니다. 여기서 여러 줄로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="122efc697c2e89462f088f0feebaa5c870210258" translate="yes" xml:space="preserve">
          <source>Follows VMS naming conventions for executable files. If the name passed in doesn't exactly match an executable file, appends</source>
          <target state="translated">실행 파일에 대한 VMS 명명 규칙을 따릅니다. 전달 된 이름이 실행 파일과 정확히 일치하지 않으면 추가</target>
        </trans-unit>
        <trans-unit id="fcc0b02fa7c86000beeb89a30eaf5629188e75a8" translate="yes" xml:space="preserve">
          <source>Foo.pm</source>
          <target state="translated">Foo.pm</target>
        </trans-unit>
        <trans-unit id="da5d4e2f7dabe2f03b8a59da35c55f83a0e24606" translate="yes" xml:space="preserve">
          <source>Foo.txt</source>
          <target state="translated">Foo.txt</target>
        </trans-unit>
        <trans-unit id="d715482d55fabe025e318c022fd82a1c933e4100" translate="yes" xml:space="preserve">
          <source>Foo.xs</source>
          <target state="translated">Foo.xs</target>
        </trans-unit>
        <trans-unit id="df808fb24c9efb33a59855928a13b51fb91724c1" translate="yes" xml:space="preserve">
          <source>Foo/Bar.pm</source>
          <target state="translated">Foo/Bar.pm</target>
        </trans-unit>
        <trans-unit id="ac143ab3d1c17f2a31332e229167b913e207dde2" translate="yes" xml:space="preserve">
          <source>Foo::Bar</source>
          <target state="translated">Foo::Bar</target>
        </trans-unit>
        <trans-unit id="cdf8cb90a5029548db08a3400753c839b0a8694f" translate="yes" xml:space="preserve">
          <source>Footers</source>
          <target state="translated">Footers</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="d69332b2911636a58346ec04cf4c168ff3905a2a" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">&quot;안전하지 않은 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot;메시지의 경우 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 를 설정해야합니다. 를 알려진 값으로 설정해야하며 경로의 각 디렉토리는 소유자 및 그룹이 아닌 다른 사람이 절대적이고 쓸 수 없어야합니다. 실행 파일의 경로 이름이 정규화 된 경우에도이 메시지가 표시 될 수 있습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="458ce0be0117f196e68aa4441aff2c235ffca77c" translate="yes" xml:space="preserve">
          <source>For &quot;Insecure &lt;code&gt;$ENV{PATH}&lt;/code&gt;&quot; messages, you need to set &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; to a known value, and each directory in the path must be absolute and non-writable by others than its owner and group. You may be surprised to get this message even if the pathname to your executable is fully qualified. This is</source>
          <target state="translated">&quot;안전하지 않은 &lt;code&gt;$ENV{PATH}&lt;/code&gt; &quot;메시지의 경우 &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; 를 알려진 값으로 설정해야하며 경로의 각 디렉토리는 절대적이어야하며 소유자 및 그룹이 아닌 다른 사용자가 쓸 수 없어야합니다. 실행 파일의 경로 이름이 정규화 된 경우에도이 메시지가 표시되면 놀랄 수 있습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="714f0a7ac0b9ec15987d10f44460eec1efc59934" translate="yes" xml:space="preserve">
          <source>For &quot;big&quot; data stores (i.e. ones that exceed available memory) consider using one of the DB modules to store it on disk instead of in RAM. This will incur a penalty in access time, but that's probably better than causing your hard disk to thrash due to massive swapping.</source>
          <target state="translated">&quot;큰&quot;데이터 저장소 (예 : 사용 가능한 메모리를 초과하는 데이터 저장소)의 경우 DB 모듈 중 하나를 사용하여 RAM 대신 디스크에 저장하는 것이 좋습니다. 이로 인해 액세스 시간이 단축 될 수 있지만 대규모 스와핑으로 인해 하드 디스크가 스래쉬되는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="216bed6df8bedc927acdb0d380e3ce0b17cdad4f" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of digits to show, including those prior to the decimal point and those after it; for example:</source>
          <target state="translated">&quot;g&quot;및 &quot;G&quot;의 경우 소수점 앞 자릿수 및 그 뒤 자릿수를 포함하여 표시 할 최대 자릿수를 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a648af0ad15c0dfdeff44093b0ccaf3206a57268" translate="yes" xml:space="preserve">
          <source>For &quot;g&quot; and &quot;G&quot;, this specifies the maximum number of significant digits to show; for example:</source>
          <target state="translated">&quot;g&quot;및 &quot;G&quot;의 경우 표시 할 최대 유효 자릿수를 지정합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0f35f055609ac0e205f7abbab4e89f59e70313b8" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt; , which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">256 색 에뮬레이터의 경우이 모듈은 &lt;code&gt;ansi0&lt;/code&gt; ~ &lt;code&gt;ansi15&lt;/code&gt; 를 추가로 제공합니다.이 색상은 16 색 에뮬레이터의 색상 0 ~ 15와 동일하지만 256 색 이스케이프 구문 인 &lt;code&gt;grey0&lt;/code&gt; ~ &lt;code&gt;grey23&lt;/code&gt; 을 사용 하여 거의 검은 색에서 거의 흰색, RGB 색상의 집합입니다. RGB 색상은 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="a433027d577c25f33bfe8c1ce8c632502b230d50" translate="yes" xml:space="preserve">
          <source>For 256-color emulators, this module additionally provides &lt;code&gt;ansi0&lt;/code&gt; through &lt;code&gt;ansi15&lt;/code&gt;, which are the same as colors 0 through 15 in sixteen-color emulators but use the 256-color escape syntax, &lt;code&gt;grey0&lt;/code&gt; through &lt;code&gt;grey23&lt;/code&gt; ranging from nearly black to nearly white, and a set of RGB colors. The RGB colors are of the form &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; where</source>
          <target state="translated">256 색 에뮬레이터의 경우이 모듈은 추가로 &lt;code&gt;ansi0&lt;/code&gt; ~ &lt;code&gt;ansi15&lt;/code&gt; 를 제공합니다 . 이는 16 색 에뮬레이터의 색상 0 ~ 15와 동일하지만 256 색 이스케이프 구문, &lt;code&gt;grey0&lt;/code&gt; ~ &lt;code&gt;grey23&lt;/code&gt; ( 거의 검은 색에서 거의 흰색까지)을 사용합니다. RGB 색상 세트. RGB 색상은 &lt;code&gt;rgb&lt;i&gt;RGB&lt;/i&gt;&lt;/code&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="9dba65b3ab3aa02b8076d20aa76888328be8a5c9" translate="yes" xml:space="preserve">
          <source>For 256-color terminals, the recognized foreground colors are:</source>
          <target state="translated">256 색 터미널의 경우 인식되는 전경색은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5d9dc655e83477215f485473f4a8c147ee45bb5" translate="yes" xml:space="preserve">
          <source>For 5.11.0 and later, B::RV is abolished, and IVs can be used to store references, and a new type B::REGEXP is introduced, giving this structure:</source>
          <target state="translated">5.11.0 이상에서는 B :: RV가 폐지되고 IV를 사용하여 참조를 저장하고 새로운 유형 B :: REGEXP가 도입되어 다음 구조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3b9459bd4ecaaeabf24e953c1001374ffa8f984" translate="yes" xml:space="preserve">
          <source>For 5.9.0 and earlier, PVLV is a direct subclass of PVMG, and BM is still present as a distinct type, so the base of this diagram is</source>
          <target state="translated">5.9.0 이하의 경우 PVLV는 PVMG의 직접 서브 클래스이며 BM은 여전히 ​​고유 한 유형으로 존재하므로이 다이어그램의 기본은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afcd88ba3a43999bb13c6a0581bba573aa2225e9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 위해 ,</target>
        </trans-unit>
        <trans-unit id="b67046d89d36d48c7efd6e356e0580695c3d2279" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, you write</source>
          <target state="translated">들어 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; , 당신은 쓰기</target>
        </trans-unit>
        <trans-unit id="bb349f3962801c59d331a216fd1e10a8dbe12696" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt; , 정수 인수의 내부 스택은 지금까지 사용되는 압축을 푼. 당신은 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f07249c48d21c67ab8413541e063aa7a291c88" translate="yes" xml:space="preserve">
          <source>For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;y&lt;/code&gt; is provided as a synonym for &lt;code&gt;tr&lt;/code&gt;.</source>
          <target state="translated">들면 &lt;b&gt;나오지&lt;/b&gt; 헌신, &lt;code&gt;y&lt;/code&gt; 동의어로 제공된다 &lt;code&gt;tr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12aacf89124604a604d76e2c1ffa17f7f2f13984" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, you have to be more elaborate:</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; , 당신은 더 정교한 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33083321ae1d2e32225ec575a8dfdad8fc51bef0" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8b70fae6950aa7895e620a82de485cc8ac6c8f65" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 위해 , 당신은 쓴다</target>
        </trans-unit>
        <trans-unit id="68b84a9c646a03b6d82fe08053257a1d8dc4ee20" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , 정수 인수의 내부 스택은 지금까지 사용되는 압축을 푼. 당신은 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6bfa42e2fbb77bda7d82e8856005087ade0aff" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">들어 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f6f91e66939fc35306c48af011860c291352dd16" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, you write</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 위해 , 당신은 쓴다</target>
        </trans-unit>
        <trans-unit id="9437652f34a1038c4388b97e25d520817a521814" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, an internal stack of integer arguments unpacked so far is used. You write &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">의 경우 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , 정수 인수의 내부 스택은 지금까지 사용되는 압축을 푼. 당신은 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c5e92c976c0b87d55fa26353e0a93acdc6c1ce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt; -based distributions, use the --install_base option:</source>
          <target state="translated">들어 &lt;code&gt;Build.PL&lt;/code&gt; 이 분포 기반의 --install_base 옵션을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="4ecf98761e1a3b107c4b1b90f83825ea697cbbba" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Build.PL&lt;/code&gt;-based distributions, use the --install_base option:</source>
          <target state="translated">들어 &lt;code&gt;Build.PL&lt;/code&gt; 이 분포 기반의 --install_base 옵션을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="c829467e9c4b40b28176534e89832125f74b7e18" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_PTROBJ is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_PTROBJ는 T_PTRREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3f0884055516afc34f2b13593cc64878ec3fa103" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REFOBJ is optimized to a T_REFREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_REFOBJ는 T_REFREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1484118e1397c1b2c2710771f398a13c8a642ded" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DESTROY&lt;/code&gt; XSUBs only, a T_REF_IV_PTR is optimized to a T_PTRREF. This means the class check is skipped.</source>
          <target state="translated">들어 &lt;code&gt;DESTROY&lt;/code&gt; 에만있는 XSUB하는 T_REF_IV_PTR는 T_PTRREF에 최적화되어 있습니다. 이것은 클래스 확인을 건너 뛰는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="66b2f35d5f8f8421c2121030f67ed492cb7aab30" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;.</source>
          <target state="translated">들어 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 없이 코드 &quot;이름 |&quot; 일부에서는 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 코드 만 발생할 수 있습니다. 즉, 저자는 &quot; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0f87c65e7fff8eb6f507b6ea128ab017e2cdc4d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; codes without a &quot;name|&quot; part, only &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; and &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; codes may occur. That is, authors should not use &quot;&lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">들어 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 없이 코드 &quot;이름 |&quot; 부분, &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 코드 만 발생할 수 있습니다. 즉, 작성자는 &quot; &lt;code&gt;L&amp;lt;B&amp;lt;Foo::Bar&amp;gt;&amp;gt;&lt;/code&gt; &quot;를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="45be8d936a33aec210b53bde0ce7f71408df21fa" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt; -based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 기반 배포의 경우 Makefile을 생성 할 때 INSTALL_BASE 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d9c46fd3bfeb22a99c449a7ef39ec2d82f1f5fd" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Makefile.PL&lt;/code&gt;-based distributions, use the INSTALL_BASE option when generating Makefiles:</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 기반 배포의 경우 Makefile을 생성 할 때 INSTALL_BASE 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6affbdccf85e4a86ac6e1ea88088cb893b7138f5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt; , it is a fatal error if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">들면 &lt;code&gt;\N{NAME}&lt;/code&gt; 경우에는 치명적인 에러가 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 유효하고 입력 이름이 그 (255 서수 그 위에 예) 바이트에 맞지 않는 문자이다.</target>
        </trans-unit>
        <trans-unit id="56c98115c3b61593c6a9cc1d27a8a4d0986a1864" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;\N{NAME}&lt;/code&gt;, it is a fatal error if &lt;code&gt;use bytes&lt;/code&gt; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).</source>
          <target state="translated">들면 &lt;code&gt;\N{NAME}&lt;/code&gt; 경우에는 치명적인 에러가 &lt;code&gt;use bytes&lt;/code&gt; 유효하고 입력 이름이 그 (255 서수 그 위에 예) 바이트에 맞지 않는 문자이다.</target>
        </trans-unit>
        <trans-unit id="ea67c402005690cbe6252230aeb1b9e29463940b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;last&lt;/code&gt;, you have to be more elaborate and put braces around it:</source>
          <target state="translated">들어 &lt;code&gt;last&lt;/code&gt; , 당신은 정교하고 주위에 괄호를 넣어 더 있어야합니다 :</target>
        </trans-unit>
        <trans-unit id="e79cd427b6a6f27bc463bdbb4440a5f8655fa529" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm answers a question as soon as the timeout is reached for the next byte in the input stream. In this mode you can use the &lt;code&gt;reuse&lt;/code&gt; parameter to decide what will happen with a question-answer pair after it has been used. In the default case (reuse=0) it is removed from the array, avoiding being used again accidentally. If you want to answer the question &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; several times, then it must be included in the array at least as often as you want this answer to be given. Setting the parameter &lt;code&gt;reuse&lt;/code&gt; to 1 makes this repetition unnecessary.</source>
          <target state="translated">들어 &lt;code&gt;mode=anyorder&lt;/code&gt; CPAN.pm은 제한 시간이 입력 스트림의 다음 바이트에 대한 도달 가능한 한 빨리 질문에 응답합니다. 이 모드에서는 &lt;code&gt;reuse&lt;/code&gt; 매개 변수를 사용하여 질문-응답 쌍이 사용 된 후 발생하는 상황을 결정할 수 있습니다 . 기본 경우 (reuse = 0) 실수로 다시 사용되지 않도록 어레이에서 제거됩니다. 당신이 질문에 대답하려면 &lt;code&gt;Do you really want to &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; that&lt;/code&gt; 여러 번, 그것은 종종 당신이 대답이 주어질 원하는만큼 적어도 배열에 포함되어야합니다. 매개 변수 &lt;code&gt;reuse&lt;/code&gt; 을 1로 설정 하면이 반복이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c8630b83e11b62d7083ae08d4bcbe9c6233a2fe" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;mode=deterministic&lt;/code&gt; , the CPAN.pm injects the corresponding answer as soon as the stream matches the regular expression.</source>
          <target state="translated">위해 &lt;code&gt;mode=deterministic&lt;/code&gt; 상기 CPAN.pm의 주입 또는 스트림 정규식과 일치 자마자 상응 않음.</target>
        </trans-unit>
        <trans-unit id="92e601981acde6d883af496a8f5b209e79aaf450" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;redo&lt;/code&gt;, just double the braces:</source>
          <target state="translated">를 들어 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;redo&lt;/code&gt; , 그냥 괄호를 두 배로 :</target>
        </trans-unit>
        <trans-unit id="ef14d5377f916291fb2a9d24329993be66568e7c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt; /&lt;code&gt;sigaction&lt;/code&gt; , use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</source>
          <target state="translated">용 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; , 사용 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c6ef77a69497373d8f3b5756e0eb701254fe1dc" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;signal&lt;/code&gt;/&lt;code&gt;sigaction&lt;/code&gt;, use &lt;code&gt;rsignal(signo, handler)&lt;/code&gt;.</source>
          <target state="translated">용 &lt;code&gt;signal&lt;/code&gt; / &lt;code&gt;sigaction&lt;/code&gt; , 사용 &lt;code&gt;rsignal(signo, handler)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ab0c714668cca72c9c6d7568133eb235eee645" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; 2 (or higher), the filename should end in '.json'. &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt; is the default JSON backend. Using another JSON backend requires &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 2.5 or later and you must set the &lt;code&gt;$ENV{PERL_JSON_BACKEND}&lt;/code&gt; to a supported alternate backend like &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt;.</source>
          <target state="translated">들면 &lt;code&gt;version&lt;/code&gt; 2 (또는 그 이상)의 파일명이 '.json &quot;로 끝나야한다. &lt;a href=&quot;JSON::PP&quot;&gt;JSON :: PP&lt;/a&gt; 는 기본 JSON 백엔드입니다. 다른 JSON 백엔드를 사용하려면 &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 2.5 이상이 필요 하며 &lt;code&gt;$ENV{PERL_JSON_BACKEND}&lt;/code&gt; 을 &lt;a href=&quot;JSON::XS&quot;&gt;JSON :: XS&lt;/a&gt; 와 같이 지원되는 대체 백엔드로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65c2fddde0dcb7e596a58cd7354413b00cdbb867" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; greater than or equal to 2, the string will be serialized as JSON. For &lt;code&gt;version&lt;/code&gt; less than 2, the string will be serialized as YAML. In both cases, the same rules are followed as in the &lt;code&gt;save()&lt;/code&gt; method for choosing a serialization backend.</source>
          <target state="translated">들면 &lt;code&gt;version&lt;/code&gt; 2 이상, 문자열 JSON으로 연재한다. 들어 &lt;code&gt;version&lt;/code&gt; 2 이상의 문자열은 YAML로 연재됩니다. 두 경우 모두 직렬화 백엔드를 선택하기위한 &lt;code&gt;save()&lt;/code&gt; 메서드 에서와 동일한 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b66f10f5f611d13a272f684c07136d9442ecc4a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;version&lt;/code&gt; less than 2, the filename should end in '.yml'. &lt;a href=&quot;CPAN::Meta::Converter&quot;&gt;CPAN::Meta::Converter&lt;/a&gt; is used to generate an older metadata structure, which is serialized to YAML. CPAN::Meta::YAML is the default YAML backend. You may set the &lt;code&gt;$ENV{PERL_YAML_BACKEND}&lt;/code&gt; to a supported alternative backend, though this is not recommended due to subtle incompatibilities between YAML parsers on CPAN.</source>
          <target state="translated">들어 &lt;code&gt;version&lt;/code&gt; 2 이상의 파일 이름은 '.yml'로 끝나야합니다. &lt;a href=&quot;CPAN::Meta::Converter&quot;&gt;CPAN :: Meta :: Converter&lt;/a&gt; 는 YAML로 직렬화되는 이전 메타 데이터 구조를 생성하는 데 사용됩니다. CPAN :: Meta :: YAML은 기본 YAML 백엔드입니다. &lt;code&gt;$ENV{PERL_YAML_BACKEND}&lt;/code&gt; 을 지원되는 대체 백엔드로 설정할 수 있지만 이는 CPAN의 YAML 파서 간의 미묘한 비 호환성으로 인해 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a61181a75805f7799b6c0c697c05f83d8dd25596" translate="yes" xml:space="preserve">
          <source>For BigInts, no padding occurs.</source>
          <target state="translated">BigInts의 경우 패딩이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a198a8cc7df6e759ce28837fe6aa6551a85a48c7" translate="yes" xml:space="preserve">
          <source>For C99 and later compilers, these correspond to things like &lt;code&gt;INT_MAX&lt;/code&gt;, which are available to the C code. But these constants, furnished by Perl, allow code compiled on earlier compilers to portably have access to the same constants.</source>
          <target state="translated">C99 이상 컴파일러의 경우 C 코드에서 사용할 수있는 &lt;code&gt;INT_MAX&lt;/code&gt; 와 같은 항목에 해당 합니다. 그러나 Perl에서 제공하는 이러한 상수를 사용하면 이전 컴파일러에서 컴파일 된 코드가 이식 가능하게 동일한 상수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159007f5b1b467e0716f482dcfafb34641ca6593" translate="yes" xml:space="preserve">
          <source>For CPAN distributions, you can assume that the XS types defined by the perl core are already available. Additionally, the core typemap has default XS types for a large number of C types. For example, if you simply return a &lt;code&gt;char *&lt;/code&gt; from your XSUB, the core typemap will have this C type associated with the T_PV XS type. That means your C string will be copied into the PV (pointer value) slot of a new scalar that will be returned from your XSUB to Perl.</source>
          <target state="translated">CPAN 분배의 경우 perl 코어에 의해 정의 된 XS 유형이 이미 사용 가능한 것으로 가정 할 수 있습니다. 또한 코어 유형 맵에는 많은 C 유형에 대한 기본 XS 유형이 있습니다. 예를 들어 XSUB에서 단순히 &lt;code&gt;char *&lt;/code&gt; 를 반환 하면 코어 유형 맵에는이 C 유형이 T_PV XS 유형과 연결됩니다. 즉, C 문자열이 새 스칼라의 PV (포인터 값) 슬롯에 복사되어 XSUB에서 Perl로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="067800c18ab159aedbe7176e2a1ed014fc0ab19b" translate="yes" xml:space="preserve">
          <source>For CPerlMode, see &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&lt;/a&gt;</source>
          <target state="translated">CPerlMode의 경우 &lt;a href=&quot;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode&quot;&gt;http://www.emacswiki.org/cgi-bin/wiki/CPerlMode를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e12f48bd95a450fad76910cdbdd13b43b481003" translate="yes" xml:space="preserve">
          <source>For Haiku specific problems contact the HaikuPorts developers: &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</source>
          <target state="translated">Haiku 특정 문제는 HaikuPorts 개발자에게 문의하십시오. &lt;a href=&quot;http://ports.haiku-files.org/&quot;&gt;http://ports.haiku-files.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa725456deafc0e9398eb1c8777ad30635d6763" translate="yes" xml:space="preserve">
          <source>For Irix 6.2 with perl threads, you have to have the following patches installed:</source>
          <target state="translated">perl 스레드가있는 Irix 6.2의 경우 다음 패치를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a36b859180dd2062331e5d0956bbf601eda4340d" translate="yes" xml:space="preserve">
          <source>For Loops</source>
          <target state="translated">루프</target>
        </trans-unit>
        <trans-unit id="f525ec14cf3a7406a3fd20ef6618215772bcd0e1" translate="yes" xml:space="preserve">
          <source>For Mac OS X see README.macosx</source>
          <target state="translated">Mac OS X의 경우 README.macosx를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eed4676ab31dbcb6f11dfd095f0c73b413f8978b" translate="yes" xml:space="preserve">
          <source>For Math::BigInt objects, no padding occurs.</source>
          <target state="translated">Math :: BigInt 개체의 경우 패딩이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d38d4d7cfb9b600d5802da277c23639b1baaadfc" translate="yes" xml:space="preserve">
          <source>For OS/2 just use</source>
          <target state="translated">OS / 2의 경우</target>
        </trans-unit>
        <trans-unit id="ce1ecc333508fb99ea251c3b1fc189bc1c2a1790" translate="yes" xml:space="preserve">
          <source>For Perl 5.9.4 or later, this module's effect is lexical.</source>
          <target state="translated">Perl 5.9.4 이상의 경우이 모듈의 효과는 어휘입니다.</target>
        </trans-unit>
        <trans-unit id="e030cb0c555e8c70da95992616dd7168e848f991" translate="yes" xml:space="preserve">
          <source>For Perl versions prior to 5.9.4, this module affects the whole script, instead of inside its lexical block.</source>
          <target state="translated">5.9.4 이전의 Perl 버전의 경우이 모듈은 어휘 블록 내부가 아닌 전체 스크립트에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="123b8c1601c884b5764bece329526a87e1364285" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , see the next section.</source>
          <target state="translated">위에서 설명한 것보다 빠른 Perls 또는 문자열이 &lt;code&gt;unicode_strings&lt;/code&gt; 범위를 벗어난 함수에 전달되는 경우 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f0e9fab4a1b7e92028bd04a307df33da9707d95" translate="yes" xml:space="preserve">
          <source>For Perls earlier than those described above, or when a string is passed to a function outside the scope of &lt;code&gt;unicode_strings&lt;/code&gt;, see the next section.</source>
          <target state="translated">위에서 설명한 것보다 이전의 Perls의 경우 또는 문자열이 &lt;code&gt;unicode_strings&lt;/code&gt; 범위 밖의 함수에 전달되는 경우 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51e9cd46d8dc985ae6ee50db0816aefe5399b510" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see</source>
          <target state="translated">RFC 1950, 1951 및 1952에 대해서는</target>
        </trans-unit>
        <trans-unit id="e866e04431ebd2a55ea722b05274f955f01d07ee" translate="yes" xml:space="preserve">
          <source>For RFC 1950, 1951 and 1952 see &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1950.html&quot;&gt;http://www.faqs.org/rfcs/rfc1950.html&lt;/a&gt;, &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1951.html&quot;&gt;http://www.faqs.org/rfcs/rfc1951.html&lt;/a&gt; and &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="translated">RFC 1950, 1951 및 1952의 경우 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1950.html&quot;&gt;http://www.faqs.org/rfcs/rfc1950.html&lt;/a&gt; , &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1951.html&quot;&gt;http://www.faqs.org/rfcs/rfc1951.html&lt;/a&gt; 및 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/를&lt;/a&gt; 참조 하십시오 . rfcs / rfc1952.html</target>
        </trans-unit>
        <trans-unit id="79d250a5e514d12306957ae3038fcbffa25a0e46" translate="yes" xml:space="preserve">
          <source>For SV-heads, the first slot in each arena is reserved, and holds a link to the next arena, some flags, and a note of the number of slots. Snaked through each arena chain is a linked list of free items; when this becomes empty, an extra arena is allocated and divided up into N items which are threaded into the free list.</source>
          <target state="translated">SV- 헤드의 경우 각 경기장의 첫 번째 슬롯이 예약되며 다음 경기장, 일부 플래그 및 슬롯 수에 대한 링크를 보유합니다. 각 경기장 체인을 통해 무료로 제공되는 링크 된 목록이 있습니다. 이것이 비워지면, 여분의 경기장이 할당되고 자유 목록에 스레드되는 N 개의 항목으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="d83cc596cefab565f5916e26bce4790ad8fbd819" translate="yes" xml:space="preserve">
          <source>For Solaris 2.6 and onwards, there are two different ways for 32-bit applications to manipulate large files (files whose size is &amp;gt; 2GByte). (A 64-bit application automatically has largefile support built in by default.)</source>
          <target state="translated">Solaris 2.6 이상에서는 32 비트 응용 프로그램이 큰 파일 (크기가 2GB 이상인 파일)을 조작하는 두 가지 방법이 있습니다. 64 비트 응용 프로그램에는 기본적으로 큰 파일 지원 기능이 자동으로 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd5fe06604a74e02ef8359829b5b43f385d6346" translate="yes" xml:space="preserve">
          <source>For Storable files the rule is that they must be constructed such that &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; returns an array reference and the array elements represent one distropref object each. The conversion from YAML would look like so:</source>
          <target state="translated">저장 가능 파일의 경우 &lt;code&gt;Storable::retrieve(file)&lt;/code&gt; 가 배열 참조를 리턴하고 배열 요소가 각각 하나의 distropref 오브젝트를 표시하도록 구성해야합니다. YAML에서의 변환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72dfa7009d0195f370727c265fe04b54add44bed" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;&lt;/a&gt;.</source>
          <target state="translated">Titlecase의 경우 &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f58ed6574a36d30b785f4f498f48637179894cd" translate="yes" xml:space="preserve">
          <source>For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;.</source>
          <target state="translated">타이틀 케이스을 참조 &lt;a href=&quot;#Titlecase&quot;&gt;타이틀 케이스를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="805f6202ade256f373021f2e5892254d89bc09aa" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive,</source>
          <target state="translated">3.1에서 3.1.1 사이의 유니 코드 버전의 경우</target>
        </trans-unit>
        <trans-unit id="04defd080a27e1372a9c1dbe8cf6a89380139dd2" translate="yes" xml:space="preserve">
          <source>For Unicode versions between 3.1 and 3.1.1 inclusive, this field is empty unless there is a special folding for Turkic languages, in which case</source>
          <target state="translated">3.1에서 3.1.1 사이의 유니 코드 버전의 경우 Turkic 언어에 대한 특수 접기가 없으면이 필드는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee5d030e77aa7ec603a17bf82531f5a250c7f69" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;:unix:perlio&quot; or &quot;:stdio&quot;. Configure is set up to prefer the &quot;:stdio&quot; implementation if the system's library provides for fast access to the buffer (not common on modern architectures); otherwise, it uses the &quot;:unix:perlio&quot; implementation.</source>
          <target state="translated">&quot;: unix : perlio&quot;또는 &quot;: stdio&quot;와 동일한 Unix 플랫폼의 경우. Configure는 시스템 라이브러리가 버퍼에 대한 빠른 액세스를 제공하는 경우 &quot;: stdio&quot;구현을 선호하도록 설정됩니다 (현대 아키텍처에서는 일반적이지 않음). 그렇지 않으면 &quot;: unix : perlio&quot;구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cbc319b6a7e7bbc5b0a21fcef4a3c90f8aa75d2f" translate="yes" xml:space="preserve">
          <source>For Unix platforms that will be the equivalent of &quot;unix perlio&quot; or &quot;stdio&quot;. Configure is set up to prefer the &quot;stdio&quot; implementation if the system's library provides for fast access to the buffer; otherwise, it uses the &quot;unix perlio&quot; implementation.</source>
          <target state="translated">&quot;unix perlio&quot;또는 &quot;stdio&quot;와 동등한 Unix 플랫폼의 경우. 시스템 라이브러리가 버퍼에 빠르게 액세스 할 수있는 경우 &quot;stdio&quot;구현을 선호하도록 Configure가 설정됩니다. 그렇지 않으면 &quot;unix perlio&quot;구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8e7684d2c33a7c1793ba874a5f04310e9d4fc" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the Fcntl module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">WHENCE를 들어, 당신은 또한 상수를 사용할 수 있습니다 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 는 은 fcntl 모듈에서 (파일, 현재 위치, 파일의 끝의 시작). 상수 사용은 0, 1 및 2에 의존하는 것보다 이식성이 뛰어납니다. 예를 들어 &quot;systell&quot;함수를 정의하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4713c9fe1d32698f610a4455023de1df0dafca06" translate="yes" xml:space="preserve">
          <source>For WHENCE, you may also use the constants &lt;code&gt;SEEK_SET&lt;/code&gt;, &lt;code&gt;SEEK_CUR&lt;/code&gt;, and &lt;code&gt;SEEK_END&lt;/code&gt; (start of the file, current position, end of the file) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module. Use of the constants is also more portable than relying on 0, 1, and 2. For example to define a &quot;systell&quot; function:</source>
          <target state="translated">WHENCE를 들어, 당신은 또한 상수를 사용할 수 있습니다 &lt;code&gt;SEEK_SET&lt;/code&gt; , &lt;code&gt;SEEK_CUR&lt;/code&gt; , 그리고 &lt;code&gt;SEEK_END&lt;/code&gt; 는 로부터 (파일, 현재 위치, 파일의 끝의 시작) &lt;a href=&quot;fcntl&quot;&gt;은 fcntl의&lt;/a&gt; 모듈. 상수 사용은 0, 1, 2에 의존하는 것보다 더 이식성이 뛰어납니다. 예를 들어 &quot;systell&quot;함수를 정의하려면 :</target>
        </trans-unit>
        <trans-unit id="9c6f354666b012fb0b17a8266f1f19a75a5cd7ea" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">Windows의 경우 바이너리 버전의 Perl, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstrawberryperl.com%2f&quot;&gt;Strawberry Perl&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActivePerl을&lt;/a&gt; 번들 C 컴파일러와 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f693188a9ab8e985eb42e0efe6af6a9b973fe16" translate="yes" xml:space="preserve">
          <source>For Windows, use a binary version of Perl, &lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt; and &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; come with a bundled C compiler.</source>
          <target state="translated">Windows의 경우 바이너리 버전의 Perl을 사용하고, &lt;a href=&quot;http://strawberryperl.com/&quot;&gt;Strawberry Perl&lt;/a&gt; 및 &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; 은 번들 C 컴파일러와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ddebad79af1e1455a2ecfd8699251bd717e5556f" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">모든 MakeMaker 메서드에 대한 전체 설명은 &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils :: MM_Unix를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4096062d54d81319c0a84a69e9fb5a2773f4aae4" translate="yes" xml:space="preserve">
          <source>For a complete description of all MakeMaker methods see &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;.</source>
          <target state="translated">모든 MakeMaker 메소드에 대한 자세한 설명은 &lt;a href=&quot;mm_unix&quot;&gt;ExtUtils :: MM_Unix를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f3ff924d2e8af712b8d94ac227d4cdb31a1d1a1" translate="yes" xml:space="preserve">
          <source>For a complete description of the PerlIO abstraction, consult &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;.</source>
          <target state="translated">PerlIO 추상화에 대한 자세한 설명은 &lt;a href=&quot;perlapio&quot;&gt;perlapio를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc9dbf2a0896fe69103f2db77a57c60a5869908f" translate="yes" xml:space="preserve">
          <source>For a complete list of features check &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">기능 점검 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; 의 전체 목록을 보려면 .</target>
        </trans-unit>
        <trans-unit id="99ae84c904dc87594aba13edffb373bf48c2a651" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">Tom Christiansen의 vi 구성 파일의 전체 버전은 vi 에뮬레이터의 표준 벤치 마크 파일 인 &lt;a href=&quot;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz를&lt;/a&gt; 참조 하십시오 . 이 파일은 Berkeley의 최신 vi 버전 인 nvi와 함께 최상으로 실행되며 내장 Perl 인터프리터를 사용하여 빌드 할 수 있습니다 ( &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/ 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="537d1bfba604bd0eb2268586149eaf40c35ff3c1" translate="yes" xml:space="preserve">
          <source>For a complete version of Tom Christiansen's vi configuration file, see &lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&lt;/a&gt; , the standard benchmark file for vi emulators. The file runs best with nvi, the current version of vi out of Berkeley, which incidentally can be built with an embedded Perl interpreter--see &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/&lt;/a&gt; .</source>
          <target state="translated">Tom Christiansen의 vi 구성 파일의 전체 버전은 vi 에뮬레이터의 표준 벤치 마크 파일 인 &lt;a href=&quot;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz&quot;&gt;http://www.cpan.org/authors/id/T/TO/TOMC/scripts/toms.exrc.gz를&lt;/a&gt; 참조 하십시오 . 이 파일은 Berkeley에서 나온 vi의 현재 버전 인 nvi에서 가장 잘 실행되며, 부수적으로 내장 된 Perl 인터프리터로 빌드 할 수 있습니다 ( &lt;a href=&quot;http://www.cpan.org/src/misc/&quot;&gt;http://www.cpan.org/src/misc/ 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="705318b135eb6a59cbff8cc7756ef8640468bf71" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">포괄적 인 날짜 및 시간 표현 은 CPAN 의 &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="666016f5dbbd95bef8b212430bb2473fc2b4dcb2" translate="yes" xml:space="preserve">
          <source>For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module on CPAN.</source>
          <target state="translated">포괄적 인 날짜 및 시간 표현 은 CPAN 의 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16eedbead27a5bc94e1ec2e16fa1f6580882483a" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;MemLevel&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;MemLevel&lt;/code&gt; 의 의미와 유효 값에 대한 정의 는</target>
        </trans-unit>
        <trans-unit id="a1e24d70e0b1f2c78e32cfdc770b1dd79ea05b81" translate="yes" xml:space="preserve">
          <source>For a definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;WindowBits&lt;/code&gt; 의 의미와 유효 값에 대한 정의 는</target>
        </trans-unit>
        <trans-unit id="e1dffbb7b106a3b121865266cc8508e33d6967ff" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&lt;/a&gt;</source>
          <target state="translated">변수에 대한 설명은 Porting 폴더에 기록 된 용어집 파일을 보거나 URL을 사용하십시오. &lt;a href=&quot;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/Glossary&quot;&gt;http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting /용어 사전&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6062949904481f0e001f1e56a47c4953d0a38335" translate="yes" xml:space="preserve">
          <source>For a description of the variables, please have a look at the Glossary file, as written in the Porting folder, or use the url: https://github.com/Perl/perl5/blob/blead/Porting/Glossary</source>
          <target state="translated">변수에 대한 설명은 Porting 폴더에 작성된 Glossary 파일을 보거나 다음 URL을 사용하십시오. https://github.com/Perl/perl5/blob/blead/Porting/Glossary</target>
        </trans-unit>
        <trans-unit id="522716bff942007c71b30eff73794b6a193c83f7" translate="yes" xml:space="preserve">
          <source>For a detailed description of calling conventions from C to Perl, consult &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">C에서 Perl 로의 호출 규칙에 대한 자세한 설명은 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6a785d30d6f70115ae56148dad0b5f07adc9c9" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3F-Why-does-i-clobber-protected-files%3F-Isn%27t-this-a-bug-in-Perl%3F&quot;&gt;&quot;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?&quot; in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">파일 권한 및 &lt;b&gt;-i&lt;/b&gt; 와 관련된 문제에 대한 설명 은 &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3F-Why-does-i-clobber-protected-files%3F-Isn%27t-this-a-bug-in-Perl%3F&quot;&gt;&quot;Perl이 읽기 전용 파일을 삭제하도록 허용하는 이유는 무엇입니까? -i는 파일을 보호하는 이유는 무엇입니까? Perl의 버그가 아닙니까?&quot;를 참조하십시오. perlfaq5에서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb11e0b0c0d1be60a6f42c39836c50cc82216796" translate="yes" xml:space="preserve">
          <source>For a discussion of issues surrounding file permissions and &lt;b&gt;-i&lt;/b&gt;, see &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl? in perlfaq5&lt;/a&gt;.</source>
          <target state="translated">파일 권한 및 &lt;b&gt;-i&lt;/b&gt; 관련 문제에 대한 설명 &lt;a href=&quot;perlfaq5#Why-does-Perl-let-me-delete-read-only-files%3f-Why-does--i-clobber-protected-files%3f-Isn't-this-a-bug-in-Perl%3f&quot;&gt;은 Perl에서 읽기 전용 파일을 삭제하는 이유는 무엇입니까?를&lt;/a&gt; 참조하십시오 . -i clobber로 파일을 보호하는 이유는 무엇입니까? 이것은 Perl의 버그가 아닌가? perlfaq5에서 .</target>
        </trans-unit>
        <trans-unit id="c17a0e02c18fc6ec53a4e2d1835d5c3756570710" translate="yes" xml:space="preserve">
          <source>For a full definition of the meaning and valid values for &lt;code&gt;WindowBits&lt;/code&gt; refer to the</source>
          <target state="translated">&lt;code&gt;WindowBits&lt;/code&gt; 의 의미와 유효 값에 대한 전체 정의 는</target>
        </trans-unit>
        <trans-unit id="ab6b2ccf022ed8c112662e8962e31264cb2b6d19" translate="yes" xml:space="preserve">
          <source>For a list of known issues, visit:</source>
          <target state="translated">알려진 문제 목록을 보려면 다음 사이트를 방문하십시오 :</target>
        </trans-unit>
        <trans-unit id="e95ee6825d4d62b379fa548316d0c1e1647b716e" translate="yes" xml:space="preserve">
          <source>For a lot of situations, like interfacing to an error handler, this may be a perfectly adequate solution.</source>
          <target state="translated">오류 처리기와의 인터페이스와 같은 많은 상황에서 이것은 완벽한 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fb5d513c6711626eae157d1505b4fda1465fce" translate="yes" xml:space="preserve">
          <source>For a module, this is generally where the documentation of the interfaces provided by the module goes, usually in the form of a list with an &lt;code&gt;=item&lt;/code&gt; for each interface. Depending on how many interfaces there are, you may want to put that documentation in separate METHODS, FUNCTIONS, CLASS METHODS, or INSTANCE METHODS sections instead and save the DESCRIPTION section for an overview.</source>
          <target state="translated">모듈의 경우, 일반적으로 모듈이 제공하는 인터페이스의 문서화는 일반적으로 각 인터페이스에 대해 &lt;code&gt;=item&lt;/code&gt; 이있는 목록 형식으로되어 있습니다. 인터페이스의 수에 따라 해당 설명서를 별도의 방법, 기능, 클래스 방법 또는 인스턴스 방법 섹션에 배치하고 설명을 위해 설명 섹션을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d4f8c4cd53b34a329bab7f01392ac51898bdf5" translate="yes" xml:space="preserve">
          <source>For a more complete explanation of 64-bit issues, see the &quot;Solaris 64-bit Developer's Guide&quot; at &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt;</source>
          <target state="translated">64 비트 문제에 대한 자세한 내용은 &lt;a href=&quot;http://docs.sun.com/&quot;&gt;http://docs.sun.com/&lt;/a&gt; 의 &quot;Solaris 64 비트 개발자 안내서&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e2c5e657d81bf42c0416b6bb7cf83065d719466" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt; , like for example the &lt;code&gt;dl_load_flags&lt;/code&gt; , not honored by &lt;code&gt;XSLoader&lt;/code&gt; .</source>
          <target state="translated">더 복잡한 인터페이스는 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 참조하십시오 . 많은 (대부분의) 기능 &lt;code&gt;DynaLoader&lt;/code&gt; 은 구현되지 않습니다 &lt;code&gt;XSLoader&lt;/code&gt; 예를 들어 같은 &lt;code&gt;dl_load_flags&lt;/code&gt; 영광하지 &lt;code&gt;XSLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a54563befbfb9741b74c08411d734d73a701db49" translate="yes" xml:space="preserve">
          <source>For a more complicated interface, see &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;. Many (most) features of &lt;code&gt;DynaLoader&lt;/code&gt; are not implemented in &lt;code&gt;XSLoader&lt;/code&gt;, like for example the &lt;code&gt;dl_load_flags&lt;/code&gt;, not honored by &lt;code&gt;XSLoader&lt;/code&gt;.</source>
          <target state="translated">더 복잡한 인터페이스는 &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader를&lt;/a&gt; 참조하십시오 . 많은 (대부분의) 기능 &lt;code&gt;DynaLoader&lt;/code&gt; 은 구현되지 않습니다 &lt;code&gt;XSLoader&lt;/code&gt; 예를 들어 같은 &lt;code&gt;dl_load_flags&lt;/code&gt; 영광하지 &lt;code&gt;XSLoader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c134a320b4cf48bdf8f6ab3775da940622ed9a6" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">자세한 내용 은 CPAN의 &lt;a href=&quot;Unicode::Semantics&quot;&gt;Unicode :: Semantics&lt;/a&gt; 를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="5cd2b461432789a1d128d890e829743972bfea8c" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, see &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;Unicode::Semantics&lt;/a&gt; on CPAN.</source>
          <target state="translated">자세한 내용 은 CPAN의 &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Semantics&quot;&gt;유니 코드 :: 시맨틱&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="734d1e26906ca381487d708f04f33fc705057ebb" translate="yes" xml:space="preserve">
          <source>For a more featureful version of this program, you should look to the</source>
          <target state="translated">이 프로그램의보다 기능적인 버전을 보려면</target>
        </trans-unit>
        <trans-unit id="6cc9a4597b12d4f9cbe49ad17ba062101c23d9dc" translate="yes" xml:space="preserve">
          <source>For a multi-line string, you can apply the regular expression to each logical line in the string by adding the &lt;code&gt;/m&lt;/code&gt; flag (for &quot;multi-line&quot;). With the &lt;code&gt;/m&lt;/code&gt; flag, the &lt;code&gt;$&lt;/code&gt; matches</source>
          <target state="translated">여러 줄 문자열의 경우 &lt;code&gt;/m&lt;/code&gt; 플래그 를 추가하여 ( &quot;다 줄&quot;) 문자열의 각 논리 줄에 정규식을 적용 할 수 있습니다 . 와 &lt;code&gt;/m&lt;/code&gt; 플래그는 &lt;code&gt;$&lt;/code&gt; 의 일치</target>
        </trans-unit>
        <trans-unit id="853ea4ea0b4a8a77b8f91e4b9431c81b99fef254" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;a href=&quot;File::Copy#move&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; function look at the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">플랫폼 독립적 인 &lt;a href=&quot;File::Copy#move&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt; 기능의 경우 &lt;a href=&quot;File::Copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6bf5a779844f3ff794b0be678bf9271933d780d" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;../file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">플랫폼 독립적 &lt;code&gt;move&lt;/code&gt; 기능에 대해서는 &lt;a href=&quot;../file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="fab0333533e228e4f9c3f37bd78da5462c6d46ad" translate="yes" xml:space="preserve">
          <source>For a platform independent &lt;code&gt;move&lt;/code&gt; function look at the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module.</source>
          <target state="translated">플랫폼 독립적 &lt;code&gt;move&lt;/code&gt; 기능에 대해서는 &lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="9fe5f7ac43651f01500eab4dab5aa1857bdfdac3" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;File::Spec::Unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;File::Spec::Mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;File::Spec::OS2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;File::Spec::Win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;File::Spec::VMS&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 함수에 대한 참조는 전체 세트를 포함하고 다른 플랫폼의 모듈에 상속되는 &lt;a href=&quot;File::Spec::Unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt; 를 참조하십시오 . 자세한 내용은 &lt;a href=&quot;File::Spec::Mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt; , &lt;a href=&quot;File::Spec::OS2&quot;&gt;File :: Spec :: OS2&lt;/a&gt; , &lt;a href=&quot;File::Spec::Win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt; 또는 &lt;a href=&quot;File::Spec::VMS&quot;&gt;File :: Spec :: VMS를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f487551c011cbdc8bfa8463318b0aee937e41d35" translate="yes" xml:space="preserve">
          <source>For a reference of available functions, please consult &lt;a href=&quot;unix&quot;&gt;File::Spec::Unix&lt;/a&gt;, which contains the entire set, and which is inherited by the modules for other platforms. For further information, please see &lt;a href=&quot;mac&quot;&gt;File::Spec::Mac&lt;/a&gt;, &lt;a href=&quot;os2&quot;&gt;File::Spec::OS2&lt;/a&gt;, &lt;a href=&quot;win32&quot;&gt;File::Spec::Win32&lt;/a&gt;, or &lt;a href=&quot;vms&quot;&gt;File::Spec::VMS&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 함수에 대한 참조는 &lt;a href=&quot;unix&quot;&gt;File :: Spec :: Unix&lt;/a&gt; 를 참조하십시오. File :: Spec :: Unix 는 전체 세트를 포함하고 다른 플랫폼의 모듈에 의해 상속됩니다. 자세한 내용은 &lt;a href=&quot;mac&quot;&gt;File :: Spec :: Mac&lt;/a&gt; , &lt;a href=&quot;os2&quot;&gt;File :: Spec :: OS2&lt;/a&gt; , &lt;a href=&quot;win32&quot;&gt;File :: Spec :: Win32&lt;/a&gt; 또는 &lt;a href=&quot;vms&quot;&gt;File :: Spec :: VMS를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9c9e2ecd1a16426e5e2b2966118c8ee32aab8e" translate="yes" xml:space="preserve">
          <source>For a regular expression to match, the</source>
          <target state="translated">정규식이 일치하려면</target>
        </trans-unit>
        <trans-unit id="12a058b2c4bc4051745b895283da9f14f036e153" translate="yes" xml:space="preserve">
          <source>For a shorter message you can use &lt;code&gt;carp()&lt;/code&gt; or &lt;code&gt;croak()&lt;/code&gt; which report the error as being from where your module was called. &lt;code&gt;shortmess()&lt;/code&gt; returns the contents of this error message. There is no guarantee that that is where the error was, but it is a good educated guess.</source>
          <target state="translated">더 짧은 메시지의 경우, &lt;code&gt;carp()&lt;/code&gt; 또는 &lt;code&gt;croak()&lt;/code&gt; 을 사용하여 모듈이 호출 된 위치에서 발생한 오류를보고 할 수 있습니다 . &lt;code&gt;shortmess()&lt;/code&gt; 는이 오류 메시지의 내용을 반환합니다. 그것이 오류가 발생한 곳이라는 보장은 없지만 교육을 잘받은 추측입니다.</target>
        </trans-unit>
        <trans-unit id="fb0c681298006459cb4148344c2595f821ef7745" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">간단한 메모리 덤프의 경우 몇 바이트를 16 진 숫자 쌍으로 압축 해제하고 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 을 사용하여 16 바이트의 줄 간격으로 기존 간격을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ccb1c1f18575521b9ef05aa8422ef0eb387743f9" translate="yes" xml:space="preserve">
          <source>For a simple memory dump we unpack some bytes into just as many pairs of hex digits, and use &lt;code&gt;map&lt;/code&gt; to handle the traditional spacing - 16 bytes to a line:</source>
          <target state="translated">간단한 메모리 덤프를 위해 우리는 몇 쌍의 16 진수 숫자로 일부 바이트를 풀고, 한 줄에 16 바이트 인 전통적인 간격을 처리하기 위해 &lt;code&gt;map&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b2806550c8443279c35452efc8ac267d0d3adceb" translate="yes" xml:space="preserve">
          <source>For a string not starting with a colon, the string exactly matches the package and subroutine that threw the exception. For example, &lt;code&gt;MyModule::log&lt;/code&gt;. If the string does not contain a package name, &lt;code&gt;CORE::&lt;/code&gt; is assumed.</source>
          <target state="translated">콜론으로 시작하지 않는 문자열의 경우 문자열은 예외를 발생시킨 패키지 및 서브 루틴과 정확히 일치합니다. 예를 들면 &lt;code&gt;MyModule::log&lt;/code&gt; 입니다. 문자열에 패키지 이름이 포함되지 않은 경우 &lt;code&gt;CORE::&lt;/code&gt; 로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="474b374fb568d2c64a0a26b261b680939a644f1e" translate="yes" xml:space="preserve">
          <source>For a string that does start with a colon, if the subroutine throwing the exception</source>
          <target state="translated">콜론으로 시작하는 문자열의 경우, 서브 루틴이 예외를 발생시키는 경우</target>
        </trans-unit>
        <trans-unit id="a9983d9987e6ef65795138624e5828a8ab90649d" translate="yes" xml:space="preserve">
          <source>For a summary of common filehandle operations such as these, see &lt;a href=&quot;perlintro#Files-and-I%2FO&quot;&gt;&quot;Files and I/O&quot; in perlintro&lt;/a&gt;.</source>
          <target state="translated">이와 같은 일반적인 파일 핸들 작업에 대한 요약은 &lt;a href=&quot;perlintro#Files-and-I%2FO&quot;&gt;perlintro의 &quot;파일 및 I / O&quot;를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="026cee18f593cdbc6cd7c55d97ff71525a5c1f08" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or &lt;code&gt;unlink_on_destroy&lt;/code&gt; was modified after creation. Note that if a temp directory is your current directory, it cannot be removed - a warning will be given in this case. &lt;code&gt;chdir()&lt;/code&gt; out of the directory before letting the object go out of scope.</source>
          <target state="translated">임시 디렉토리 객체의 경우 생성자에서 CLEANUP 인수를 사용하거나 (그리고 false로 설정) &lt;code&gt;unlink_on_destroy&lt;/code&gt; 가 생성 후 수정 되지 않는 한 디렉토리가 제거됩니다 . 임시 디렉토리가 현재 디렉토리이면 제거 할 수 없습니다.이 경우 경고가 표시됩니다. 객체가 범위를 벗어나도록하기 전에 디렉토리에서 &lt;code&gt;chdir()&lt;/code&gt; 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e678ac9367be7209ea98d2129135c603f780f7f5" translate="yes" xml:space="preserve">
          <source>For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or C</source>
          <target state="translated">임시 디렉토리 객체의 경우 생성자에서 CLEANUP 인수를 사용하지 않고 (또는 false로 설정하지 않은 경우) 디렉토리가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0e148eb23ba15eaf53b9aed2b26acd83d3960120" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">더욱 강력한 가져 오기 기능은 &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fb4aa2117d863e4ff4ee47b2be92089f4f6d542" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">아직 더 강력한 가져 오기 기능에 대해서는 &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;perlmod&quot;&gt;perlmod를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99100d6030ac9440264e837ee275b962c9e0a325" translate="yes" xml:space="preserve">
          <source>For a yet-more-powerful import facility, see &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">더욱 강력한 가져 오기 기능은 &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 및 &lt;a href=&quot;../perlmod&quot;&gt;perlmod를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12d37a3337ef055e2912d9c372185cda516b253c" translate="yes" xml:space="preserve">
          <source>For abbreviated and full length days of the week and months of the year:</source>
          <target state="translated">축약 된 전체 길이 요일 및 연중 월 :</target>
        </trans-unit>
        <trans-unit id="23a93e384211636cb7b918f38dba4af06dd07c92" translate="yes" xml:space="preserve">
          <source>For absolute paths, some cleanup is done, to ensure that the volume name isn't immediately followed by updirs. This is invalid, because this would go beyond &quot;root&quot;. Generally, these cases are handled like their Unix counterparts:</source>
          <target state="translated">절대 경로의 경우 볼륨 이름 바로 다음에 updir이 없도록 일부 정리가 수행됩니다. 이것은 &quot;루트&quot;를 넘어 서기 때문에 유효하지 않습니다. 일반적으로 이러한 경우는 Unix 대응처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="de74cc30b9d5ee8d61e142d3f7218703345c5703" translate="yes" xml:space="preserve">
          <source>For accessing ftp servers behind such firewalls you usually need to set the environment variable &lt;code&gt;FTP_PASSIVE&lt;/code&gt; or the config variable ftp_passive to a true value.</source>
          <target state="translated">이러한 방화벽 뒤의 ftp 서버에 액세스하려면 일반적으로 환경 변수 &lt;code&gt;FTP_PASSIVE&lt;/code&gt; 또는 구성 변수 ftp_passive를 true 값 으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e841dd02723243da9bd704ad42284da8ce16a1a4" translate="yes" xml:space="preserve">
          <source>For additional guidance on the naming of modules, please consult:</source>
          <target state="translated">모듈 이름 지정에 대한 추가 지침은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4892803f30a1551edad3f36449d4dfea0cc9e9" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either</source>
          <target state="translated">특정 시스템에보다 정확한 추가 정보는 다음 중 하나를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df5c3063e1e7bfc9c45afac4a1ff3ef3df54c7f4" translate="yes" xml:space="preserve">
          <source>For additional information that may be more accurate for your specific system, see either &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man(5)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man(7)&lt;/a&gt; depending on your system manual section numbering conventions.</source>
          <target state="translated">특정 시스템에 대해 더 정확한 추가 정보는 시스템 설명서 섹션 번호 지정 규칙에 따라 &lt;a href=&quot;http://man.he.net/man5/man&quot;&gt;man (5)&lt;/a&gt; 또는 &lt;a href=&quot;http://man.he.net/man7/man&quot;&gt;man (7)&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a5a320ada3dc4a8bf88fe25047c87af995b7a83" translate="yes" xml:space="preserve">
          <source>For affected functions, the simple strategy to avoid data corruption is to always make the encoding of the exchanged data explicit. Choose an encoding that you know the extension can handle. Convert arguments passed to the extensions to that encoding and convert results back from that encoding. Write wrapper functions that do the conversions for you, so you can later change the functions when the extension catches up.</source>
          <target state="translated">영향을받는 기능의 경우 데이터 손상을 피하는 간단한 전략은 항상 교환 된 데이터의 인코딩을 명시 적으로 만드는 것입니다. 확장 프로그램이 처리 할 수있는 인코딩을 선택하십시오. 확장에 전달 된 인수를 해당 인코딩으로 변환하고 결과를 해당 인코딩에서 다시 변환하십시오. 변환을 수행하는 랩퍼 함수를 ​​작성하여 확장이 따라 올 때 나중에 함수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="615225b2c41ede3ced593276d5e4d897d1d4111d" translate="yes" xml:space="preserve">
          <source>For alignment commands, a &lt;code&gt;count&lt;/code&gt; of 0 is equivalent to a &lt;code&gt;count&lt;/code&gt; of 1; both are no-ops.</source>
          <target state="translated">정렬 명령의 경우 &lt;code&gt;count&lt;/code&gt; 0은 &lt;code&gt;count&lt;/code&gt; 1 과 같습니다 . 둘 다 아니야.</target>
        </trans-unit>
        <trans-unit id="317a7397e46e0f3311065cf89b919865f2fa40b0" translate="yes" xml:space="preserve">
          <source>For all Perl keywords, a &lt;code&gt;CORE::&lt;/code&gt; prefix will force the built-in function to be used, even if it has been overridden or would normally require the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma. Despite appearances, this has nothing to do with the CORE package, but is part of Perl's syntax.</source>
          <target state="translated">모든 Perl 키워드에 대해 &lt;code&gt;CORE::&lt;/code&gt; 접두어는 대체되거나 &lt;a href=&quot;feature&quot;&gt;기능&lt;/a&gt; pragma가 필요한 경우에도 내장 함수를 사용하도록합니다 . 외관에도 불구하고 이것은 CORE 패키지와 관련이 없지만 Perl 구문의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="5654c5499f83106c9fbc91a4a0b159f7465964f0" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt; , Perl will first try to match the regexp with the &lt;code&gt;a&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;a&lt;/code&gt; present. For the quantifier &lt;code&gt;*&lt;/code&gt; , we get the following:</source>
          <target state="translated">이러한 모든 한정자에 대해 Perl은 가능한 많은 문자열을 일치 시키면서도 정규 표현식이 성공하도록 허용합니다. 따라서와 &lt;code&gt;/a?.../&lt;/code&gt; , 펄은 처음으로 정규 표현식과 일치하려고합니다 &lt;code&gt;a&lt;/code&gt; 선물을; 실패 할 경우, 펄이없이 정규 표현식을 일치하려고합니다 &lt;code&gt;a&lt;/code&gt; 존재. 수량 자 &lt;code&gt;*&lt;/code&gt; 의 경우 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c8d03f9e49df228290537d529cbf4990c0671b80" translate="yes" xml:space="preserve">
          <source>For all of these quantifiers, Perl will try to match as much of the string as possible, while still allowing the regexp to succeed. Thus with &lt;code&gt;/a?.../&lt;/code&gt;, Perl will first try to match the regexp with the &lt;code&gt;'a'&lt;/code&gt; present; if that fails, Perl will try to match the regexp without the &lt;code&gt;'a'&lt;/code&gt; present. For the quantifier &lt;code&gt;'*'&lt;/code&gt;, we get the following:</source>
          <target state="translated">이러한 모든 수량 자에 대해 Perl은 정규 표현식이 성공할 수 있도록 허용하면서 가능한 한 많은 문자열을 일치 시키려고합니다. 따라서 &lt;code&gt;/a?.../&lt;/code&gt; 를 사용 하면 Perl은 먼저 정규식을 &lt;code&gt;'a'&lt;/code&gt; 와 일치 시키려고합니다 . 이것이 실패하면 Perl은 &lt;code&gt;'a'&lt;/code&gt; 가 없는 정규 표현식과 일치 시키려고합니다 . 수량 자 &lt;code&gt;'*'&lt;/code&gt; 의 경우 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="230fb8eb56a362692b30784cae41866149fb8d70" translate="yes" xml:space="preserve">
          <source>For all other systems it defaults to 0.</source>
          <target state="translated">다른 모든 시스템의 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2b3be3625a22c5493e08ee37b2b7c03a9c3eeed2" translate="yes" xml:space="preserve">
          <source>For an alternate representation of digits, for the radix character used between the integer and the fractional part of decimal numbers, the group separator string for large-ish floating point numbers (yes, the final two are redundant with &lt;a href=&quot;posix#localeconv&quot;&gt;POSIX::localeconv()&lt;/a&gt;):</source>
          <target state="translated">숫자의 대체 표현의 경우 정수와 소수의 소수 부분 사이에 사용되는 기수 문자의 경우 큰 부동 소수점 숫자에 대한 그룹 구분자 문자열 (예, 마지막 두 개는 &lt;a href=&quot;posix#localeconv&quot;&gt;POSIX :: localeconv ()&lt;/a&gt; 와 중복 됨 ) :</target>
        </trans-unit>
        <trans-unit id="2e88409e21116c6609cbafa0cf03db229fac1d32" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt; . For an autoloaded subroutine without a stub, GvCV() of the result may be zero.</source>
          <target state="translated">GV가없는 자동로드 서브 루틴의 경우 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; 경우에도 GV를 작성합니다 . 스텁이없는 자동로드 서브 루틴의 경우 결과의 GvCV ()가 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44153398dcf07d8feee0f56cbeb2ca6ed0e81196" translate="yes" xml:space="preserve">
          <source>For an autoloaded subroutine without a GV, will create a GV even if &lt;code&gt;level &amp;lt; 0&lt;/code&gt;. For an autoloaded subroutine without a stub, &lt;code&gt;GvCV()&lt;/code&gt; of the result may be zero.</source>
          <target state="translated">GV가없는 자동로드 된 서브 루틴의 경우 &lt;code&gt;level &amp;lt; 0&lt;/code&gt; 경우에도 GV를 생성합니다 . 스텁이없는 자동로드 된 서브 루틴 의 경우 결과의 &lt;code&gt;GvCV()&lt;/code&gt; 는 0이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9633677d1ed3a18e80dde705c855341e6f6f1ec2" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">출력의 예는 &lt;a href=&quot;Devel::Peek&quot;&gt;Devel :: Peek를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fce8b2cbb90270479552270e5bb2cd555b023f38" translate="yes" xml:space="preserve">
          <source>For an example of its output, see &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt;.</source>
          <target state="translated">출력 예는 &lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a82a650eab82474d19ec3ef8108ffe5370503228" translate="yes" xml:space="preserve">
          <source>For an example of the use of Net::FTP see</source>
          <target state="translated">Net :: FTP 사용 예는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bda70344f536c3a618951e75f8672661f9576c18" translate="yes" xml:space="preserve">
          <source>For an excellent all-around resource on the care and feeding of regular expressions, see the book</source>
          <target state="translated">정규 표현식의 관리 및 먹이기에 대한 훌륭한 만능 리소스는 책을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca7f7d7124f6e693d58d8f8e7a5726f3c3d7d898" translate="yes" xml:space="preserve">
          <source>For an individual module:</source>
          <target state="translated">개별 모듈의 경우 :</target>
        </trans-unit>
        <trans-unit id="e7eb2c9e0a9fd3fe5a6939bf4841e243661494a7" translate="yes" xml:space="preserve">
          <source>For an up-to-date list of plugins available, please check CPAN:</source>
          <target state="translated">사용 가능한 최신 플러그인 목록은 CPAN을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cbc0f0a5a1b385be37d862973bb36b0e683cb185" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt; .</source>
          <target state="translated">CPAN 사이트의 최신 목록은 &lt;a href=&quot;http://www.cpan.org/SITES&quot;&gt;http://www.cpan.org/SITES&lt;/a&gt; 또는 &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f8d2f0deaef3e0e49b686044d018ef1fecb88ca" translate="yes" xml:space="preserve">
          <source>For an up-to-date listing of CPAN sites, see &lt;a href=&quot;https://www.cpan.org/SITES&quot;&gt;https://www.cpan.org/SITES&lt;/a&gt; or &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES&lt;/a&gt;.</source>
          <target state="translated">CPAN 사이트의 최신 목록은 &lt;a href=&quot;https://www.cpan.org/SITES&quot;&gt;https://www.cpan.org/SITES&lt;/a&gt; 또는 &lt;a href=&quot;ftp://www.cpan.org/SITES&quot;&gt;ftp://www.cpan.org/SITES를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b089e20c1565cbb5757e1f93796b566e25654df" translate="yes" xml:space="preserve">
          <source>For another example using &lt;code&gt;IO::Poll&lt;/code&gt; and &lt;code&gt;Net::LibAsyncNS&lt;/code&gt;, see the</source>
          <target state="translated">&lt;code&gt;IO::Poll&lt;/code&gt; 및 &lt;code&gt;Net::LibAsyncNS&lt;/code&gt; 를 사용하는 또 다른 예 는</target>
        </trans-unit>
        <trans-unit id="2a44adc0de3b8707fce2595b82fd4151cd924248" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change &lt;code&gt;CvOUTSIDE&lt;/code&gt; of that CV from &lt;code&gt;old_cv&lt;/code&gt; to &lt;code&gt;new_cv&lt;/code&gt; if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">패드 변경 임의의 익명의 CVS &lt;code&gt;CvOUTSIDE&lt;/code&gt; 으로부터의 CV &lt;code&gt;old_cv&lt;/code&gt; 에 &lt;code&gt;new_cv&lt;/code&gt; 필요. 새로 컴파일 된 CV를 기존 CV 구조체로 이동해야 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d33a39ca090b8a159c7f5059badc4bd7ae75ac58" translate="yes" xml:space="preserve">
          <source>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to new_cv if necessary. Needed when a newly-compiled CV has to be moved to a pre-existing CV struct.</source>
          <target state="translated">패드에있는 임의의 CV의 경우 필요한 경우 해당 CV의 CvOUTSIDE를 old_cv에서 new_cv로 변경하십시오. 새로 컴파일 된 CV를 기존 CV 구조체로 이동해야 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a477cbd70fca9ccf72bc4fea464de24ee1323a5a" translate="yes" xml:space="preserve">
          <source>For any of the above listed attributes, case is not significant.</source>
          <target state="translated">위에 나열된 속성에 대해서는 대소 문자가 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03cdf2cd57fb98494228a618ca150d5e64571b39" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt; , or by wrapping it with parentheses or braces.</source>
          <target state="translated">디버거 프롬프트에 입력 한 텍스트의 경우 추가 처리 전에 선행 및 후행 공백이 먼저 제거됩니다. 디버거 명령이 자신의 프로그램에서 일부 기능과 일치하는 경우 디버거 명령처럼 보이지 않는 것 (예 : Leading과 같은 것) 만 함수 앞에 추가하십시오 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; 또는 괄호 나 괄호로 묶어서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b820379547056e253ff549ed899ea5e188fbe0e7" translate="yes" xml:space="preserve">
          <source>For any text entered at the debugger prompt, leading and trailing whitespace is first stripped before further processing. If a debugger command coincides with some function in your own program, merely precede the function with something that doesn't look like a debugger command, such as a leading &lt;code&gt;;&lt;/code&gt; or perhaps a &lt;code&gt;+&lt;/code&gt;, or by wrapping it with parentheses or braces.</source>
          <target state="translated">디버거 프롬프트에 입력 된 텍스트의 경우 추가 처리 전에 선행 및 후행 공백이 먼저 제거됩니다. 디버거 명령이 자체 프로그램의 일부 기능과 일치하는 경우, 선행 &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; , 또는 괄호 나 중괄호로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="5f345c4981dc60d036c3d28eb6a32e02870746a6" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">모든 참조 유형에 대해 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; 가 검사됩니다 (아래 참조). 이 변수는 코드 참조 일 것으로 예상되며 현재 매개 변수가 전달됩니다.이 함수가 존재하지 않거나 (변수가 undef 인 경우), &lt;code&gt;Carp&lt;/code&gt; 로 반복 되거나 예외가 발생하면 건너 뜁니다. 잉어는 다음 옵션으로 넘어갑니다. 그렇지 않으면 검사가 중지되고 반환 된 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59d104c59f183c270405bd88f8a633e59e8f7fcf" translate="yes" xml:space="preserve">
          <source>For any type of reference, &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is checked (see below). This variable is expected to be a code reference, and the current parameter is passed in. If this function doesn't exist (the variable is undef), or it recurses into &lt;code&gt;Carp&lt;/code&gt;, or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used.</source>
          <target state="translated">모든 유형의 참조에 대해 &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; 가 선택됩니다 (아래 참조). 이 변수는 코드 참조 일 것으로 예상되며 현재 매개 변수가 전달됩니다.이 함수가 존재하지 않거나 (변수가 undef 임) &lt;code&gt;Carp&lt;/code&gt; 로 반복 되거나 예외가 발생하면이를 건너 뜁니다. 잉어는 다음 옵션으로 이동합니다. 그렇지 않으면 검사가 중지되고 반환 된 문자열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36e7ed4a969818cfa2aa043eb8a07c31ce2abf8d" translate="yes" xml:space="preserve">
          <source>For any version object which is initialized with multiple decimal places (either quoted or if possible v-string), or initialized using the &lt;a href=&quot;version#qv%28%29&quot;&gt;qv()&lt;/a&gt; operator, the stringified representation is returned in a normalized or reduced form (no extraneous zeros), and with a leading 'v':</source>
          <target state="translated">여러 소수 자릿수 (따옴표 또는 가능한 경우 v- 문자열)로 초기화되거나 &lt;a href=&quot;version#qv%28%29&quot;&gt;qv ()&lt;/a&gt; 연산자를 사용하여 초기화 된 모든 버전 객체의 경우 문자열 표현은 정규화 또는 축소 형식 (외부 0 없음)으로 반환됩니다. 선행 'v':</target>
        </trans-unit>
        <trans-unit id="7fa27de554c50c9df409ef4245d850e6b4403907" translate="yes" xml:space="preserve">
          <source>For applications using database backends, the standard &lt;code&gt;DBIx&lt;/code&gt; namespace has tries to help with keeping things nippy, not least because it tries to</source>
          <target state="translated">데이터베이스 백엔드를 사용하는 응용 프로그램의 경우 표준 &lt;code&gt;DBIx&lt;/code&gt; 네임 스페이스는 최소한 다음을 시도하기 때문에 문제를 해결하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="6520acef19e880d0e0ded68b3e58665471c2f6a0" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt; module, where additional documentation can be found.</source>
          <target state="translated">Extension 제작자를 위해 MakeMaker는 여러 Makefile 대상을 제공합니다. 대부분의 지원은 추가 문서를 찾을 수있는 &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt; 모듈에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1bce7a5486f7524150794956c47fe07d202d9af7" translate="yes" xml:space="preserve">
          <source>For authors of extensions MakeMaker provides several Makefile targets. Most of the support comes from the ExtUtils::Manifest module, where additional documentation can be found.</source>
          <target state="translated">확장 프로그램 작성자를 위해 MakeMaker는 여러 개의 Makefile 대상을 제공합니다. 대부분의 지원은 추가 문서를 찾을 수있는 ExtUtils :: Manifest 모듈에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="22bf05bb17e4a865ba888114b8b9f35fd176e0a9" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt; , for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt; , and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt; .</source>
          <target state="translated">이전 버전과의 호환성 (Perl 5.6과의 호환성)을 위해 지금까지 언급 한 복합 형태를 사용하지 않고 쓰기 가능한 모든 속성 의 이름 앞에 &lt;code&gt;Is&lt;/code&gt; 또는 &lt;code&gt;Is_&lt;/code&gt; 가 붙을 수 있으므로 예를 들어 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 는 &lt;code&gt;\P{Lu}&lt;/code&gt; 와 같습니다. &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 은 &lt;code&gt;\p{Arabic}&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e6f8997b0405898deebf35ed5de7d2d35e93f64e" translate="yes" xml:space="preserve">
          <source>For backward compatibility (with ancient Perl 5.6), all properties writable without using the compound form mentioned so far may have &lt;code&gt;Is&lt;/code&gt; or &lt;code&gt;Is_&lt;/code&gt; prepended to their name, so &lt;code&gt;\P{Is_Lu}&lt;/code&gt;, for example, is equal to &lt;code&gt;\P{Lu}&lt;/code&gt;, and &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; is equal to &lt;code&gt;\p{Arabic}&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성 (고대 Perl 5.6 사용)을 위해 지금까지 언급 한 복합 형식을 사용하지 않고 쓸 수있는 모든 속성에는 이름 앞에 &lt;code&gt;Is&lt;/code&gt; 또는 &lt;code&gt;Is_&lt;/code&gt; 가 추가 될 수 있으므로 예를 들어 &lt;code&gt;\P{Is_Lu}&lt;/code&gt; 는 &lt;code&gt;\P{Lu}&lt;/code&gt; 와 같습니다. 및 &lt;code&gt;\p{IsScript:Arabic}&lt;/code&gt; 같다 &lt;code&gt;\p{Arabic}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="801eea6f48c31944eef870e82f2becb1739f362a" translate="yes" xml:space="preserve">
          <source>For backward compatibility reasons defining just PERL_GLOBAL_STRUCT doesn't actually hide all symbols inside a big global struct: some PerlIO_xxx vtables are left visible. The PERL_GLOBAL_STRUCT_PRIVATE then hides everything (see how the PERLIO_FUNCS_DECL is used).</source>
          <target state="translated">이전 버전과의 호환성을 위해 PERL_GLOBAL_STRUCT 만 정의하면 실제로 큰 전역 구조체 안에 모든 기호가 숨겨지지 않습니다. 일부 PerlIO_xxx vtable은 표시됩니다. 그런 다음 PERL_GLOBAL_STRUCT_PRIVATE는 모든 것을 숨 깁니다 (PERLIO_FUNCS_DECL 사용 방법 참조).</target>
        </trans-unit>
        <trans-unit id="e59de1fc73fecfb78c070b75065d56f22077db4d" translate="yes" xml:space="preserve">
          <source>For backward compatibility with older implementations that didn't support anonymous globs, &lt;code&gt;Symbol::ungensym&lt;/code&gt; is also provided. But it doesn't do anything.</source>
          <target state="translated">익명 글로브를 지원하지 않는 이전 구현과의 호환성을 위해 &lt;code&gt;Symbol::ungensym&lt;/code&gt; 도 제공됩니다. 그러나 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1875b2cf9d0a9f2703d0d978c0e4f011fb418414" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt; .</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;alternate&lt;/code&gt; (이전 이름)를 &lt;code&gt;variable&lt;/code&gt; 의 별명으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7db95484ae8f465f4ba0bfd96939032aa4269a8b" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;alternate&lt;/code&gt; (old name) can be used as an alias for &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;alternate&lt;/code&gt; (이전 이름)를 &lt;code&gt;variable&lt;/code&gt; 의 별칭으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a69034e83ea0d1a42d93d489742ef68d2660151" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the &lt;code&gt;name=&amp;gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;name=&amp;gt;value&lt;/code&gt; 쌍을 포함하는 해시에 대한 참조로 매개 변수를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3148562bf6a9aa8595388062dcaa9f8f17ba0473" translate="yes" xml:space="preserve">
          <source>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&amp;gt;value pairs.</source>
          <target state="translated">이전 버전과의 호환성을 위해 이름 =&amp;gt; 값 쌍을 포함하는 해시에 대한 참조로 매개 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec61a0442a19b1bc3402a65ad2b4e4eaf169d23" translate="yes" xml:space="preserve">
          <source>For backward-compatibility, if the PADNAMEt_OUTER flag is set, the FLAGS method adds the SVf_FAKE flag, too.</source>
          <target state="translated">하위 호환성을 위해 PADNAMEt_OUTER 플래그가 설정된 경우 FLAGS 메서드는 SVf_FAKE 플래그도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="345abbc3eef47b853413a18eb3df89f5eb02f40e" translate="yes" xml:space="preserve">
          <source>For backwards compatibility in callbacks.</source>
          <target state="translated">콜백에서 이전 버전과의 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="fc612a7ead920771085f353b3e4c345acbc9a4da" translate="yes" xml:space="preserve">
          <source>For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:</source>
          <target state="translated">이전 버전과의 호환성을 위해 Math :: BigFloat에 사용할 다른 스토리지 클래스를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5515551787402a0e5935331cd95604ada3a19af4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;In&lt;/code&gt; prefix may be omitted if there is no naming conflict with a script or any other property, and you can even use an &lt;code&gt;Is&lt;/code&gt; prefix instead in those cases. But don't do this for new code because your code could break in new releases, and this has already happened: There was a time in very early Unicode releases when &lt;code&gt;\p{Hebrew}&lt;/code&gt; would have matched the</source>
          <target state="translated">이전 버전과의 호환성 을 위해 스크립트 또는 다른 속성과 이름이 충돌하지 않으면 &lt;code&gt;In&lt;/code&gt; 접두사가 생략 될 수 있으며 대신 이러한 경우 &lt;code&gt;Is&lt;/code&gt; 접두사를 사용할 수도 있습니다 . 그러나 코드가 새 릴리스에서 중단 될 수 있으므로 새 코드에 대해서는이 작업을 수행하지 마십시오. 이미 발생했습니다. &lt;code&gt;\p{Hebrew}&lt;/code&gt; 가 초기 릴리스 와 일치 했을 때 초기 유니 코드 릴리스에 시간이있었습니다 .</target>
        </trans-unit>
        <trans-unit id="8221b631540f7fb41054f5d592fba788a0c89204" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, this error is also available as &lt;code&gt;$Archive::Tar::error&lt;/code&gt; although it is much recommended you use the method call instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해이 오류는 &lt;code&gt;$Archive::Tar::error&lt;/code&gt; 로도 사용할 수 있지만 대신 메소드 호출을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="04c26648635d004dc1846a0436ba6682f4177e2f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_bin&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_bin&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b83ee316e5b3391a5d7939b8d9c91163c18f189" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_hex&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_hex&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="36110c740cb1d17f9559cf294dd0deb0c3ace7b6" translate="yes" xml:space="preserve">
          <source>For backwards compatibility. Use &lt;code&gt;grok_oct&lt;/code&gt; instead.</source>
          <target state="translated">이전 버전과의 호환성을 위해. 대신 &lt;code&gt;grok_oct&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31ce154734530fbfe5db4b0523f628ba63c57438" translate="yes" xml:space="preserve">
          <source>For best results compile the C file below with the same options as the Perl DLL. However, a lot of functionality will work even if the executable is not an EMX applications, e.g., if compiled with</source>
          <target state="translated">최상의 결과를 얻으려면 아래 Perl DLL과 동일한 옵션으로 C 파일을 컴파일하십시오. 그러나 실행 파일이 EMX 응용 프로그램이 아닌 경우에도 많은 기능이 작동합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3d5f802bf9952ee74baf54e5c421227e48fa981f" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;&quot;RSX&quot;&lt;/a&gt;) as well, see</source>
          <target state="translated">최상의 결과를 얻으려면 EMX pdksh를 사용하십시오. 표준 바이너리 (5.2.14 이상)는 DOS ( &lt;a href=&quot;#RSX&quot;&gt;&quot;RSX&quot;포함&lt;/a&gt; )에서도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9e295c225a2c063ef46517c1ea68fc0b9b4d3dfb" translate="yes" xml:space="preserve">
          <source>For best results use EMX pdksh. The standard binary (5.2.14 or later) runs under DOS (with &lt;a href=&quot;#RSX&quot;&gt;RSX&lt;/a&gt;) as well, see</source>
          <target state="translated">최상의 결과를 얻으려면 EMX pdksh를 사용하십시오. 표준 바이너리 (5.2.14 이상)는 DOS ( &lt;a href=&quot;#RSX&quot;&gt;RSX 포함&lt;/a&gt; )에서도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0811095fb18bd277912b660d1d859a6e53803d" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic.</source>
          <target state="translated">대규모 프로젝트의 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; 는 비즈니스 로직 구현에 집중할 수있는 다양한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="485ae73f79d1afbd4e51bbd788b440af01136078" translate="yes" xml:space="preserve">
          <source>For bigger projects, &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; provides a rich set of features that will let you focus on implementing your business logic. &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt; provides a nice alternative to &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; when you want a lot of features but need faster compile time or to avoid XS.</source>
          <target state="translated">대규모 프로젝트의 경우 &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt; 는 비즈니스 로직 구현에 집중할 수있는 다양한 기능을 제공합니다. &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt; 는 많은 기능을 원하지만 더 빠른 컴파일 시간이 필요하거나 XS를 피해야 할 때 &lt;a href=&quot;moose&quot;&gt;Moose에&lt;/a&gt; 대한 좋은 대안을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5b33560e28b1291edf22e615119f480a2b62681f" translate="yes" xml:space="preserve">
          <source>For bit fields, it returns a hash ref containing details about the field. The same reference will be returned for all bit positions that make up the bit field; so for example these both return the same hash ref:</source>
          <target state="translated">비트 필드의 경우 필드에 대한 세부 정보가 포함 된 해시 참조를 반환합니다. 비트 필드를 구성하는 모든 비트 위치에 대해 동일한 참조가 반환됩니다. 예를 들어 둘 다 동일한 해시 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d59e13b49a3ea8a677214c0ffa9c8aba3e39fb3c" translate="yes" xml:space="preserve">
          <source>For blocks see &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&lt;/a&gt;</source>
          <target state="translated">블록은 &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/Blocks.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/Blocks.txt를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6af4234a6a3a035875ec423a946acfcba1e657d0" translate="yes" xml:space="preserve">
          <source>For building and installing non-XS modules, all you need is a working perl under DJGPP. Non-XS modules do not require re-linking the perl binary, and so are simpler to build and install.</source>
          <target state="translated">비 XS 모듈을 빌드하고 설치하려면 DJGPP에서 작동하는 펄만 있으면됩니다. 비 XS 모듈은 perl 바이너리를 다시 연결하지 않아도되므로 빌드 및 설치가 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="bae42e060753892a262ac6235f3d580be0d729e0" translate="yes" xml:space="preserve">
          <source>For building perl to support Oracle, it needs to be linked with libcl and libpthread. So even if your perl is an unthreaded build, these libraries might be required. See &quot;Oracle on HP-UX&quot; below.</source>
          <target state="translated">Oracle을 지원하기 위해 perl을 빌드하려면 libcl 및 libpthread와 링크되어야합니다. 따라서 perl이 스레드되지 않은 빌드 인 경우에도 이러한 라이브러리가 필요할 수 있습니다. 아래 &quot;Oracle on HP-UX&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae71424b7af33e662d7ce3e8063ed7f56ae7be34" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisions, look at the &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">대소 문자를 구분하지 않는 비교 는 Perl v5.16 이상에서 사용 가능한 &lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt; 대소 문자 구분 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2c9f18069c14b8953e6086438f1569f7befce24" translate="yes" xml:space="preserve">
          <source>For case-insensitive comparisons, look at the &lt;a href=&quot;perlfunc#fc&quot;&gt;&quot;fc&quot; in perlfunc&lt;/a&gt; case-folding function, available in Perl v5.16 or later:</source>
          <target state="translated">대소 문자를 구분하지 않는 비교 는 Perl v5.16 이상에서 사용할 수있는 &lt;a href=&quot;perlfunc#fc&quot;&gt;perlfunc&lt;/a&gt; 대소 문자 구분 기능 의 &quot;fc&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb5c1d99fc673348b120d9a851d1117c6607188" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">대소 문자를 구분하지 않으려면 두 문자를 모두 대문자 / 소문자 대신 유니 코드의 &quot;casefolding&quot;을 사용 &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;하십시오&lt;/a&gt; ( http://www.unicode.org/unicode/reports/tr21/(Case Mappings) 참조 ).</target>
        </trans-unit>
        <trans-unit id="844ac956827b7b88b1f14a571dd1efe3bff10e90" translate="yes" xml:space="preserve">
          <source>For case-insensitiveness, the &quot;casefolding&quot; of Unicode is used instead of upper/lowercasing both the characters, see &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr21/&quot;&gt;https://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (Case Mappings).</source>
          <target state="translated">대소 문자를 구분하지 않으려면 두 문자를 모두 대문자 / 소문자 대신 유니 코드의 &quot;대소 문자 구분&quot;이 사용됩니다 . &lt;a href=&quot;https://www.unicode.org/unicode/reports/tr21/&quot;&gt;https://www.unicode.org/unicode/reports/tr21/&lt;/a&gt; (대소 문자 매핑)을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="724ee81f8304298ce7234758616a260234c90146" translate="yes" xml:space="preserve">
          <source>For changes significant enough to warrant a</source>
          <target state="translated">보증 할만큼 중요한 변경의 경우</target>
        </trans-unit>
        <trans-unit id="b3dbbc26b46cd95b55d97892c7e30b541879c832" translate="yes" xml:space="preserve">
          <source>For clarity, you should already have been using &lt;code&gt;\t&lt;/code&gt; to specify a literal tab, and &lt;code&gt;\t&lt;/code&gt; is unaffected by &lt;code&gt;/xx&lt;/code&gt;.</source>
          <target state="translated">명확성을 위해 이미 &lt;code&gt;\t&lt;/code&gt; 를 사용하여 리터럴 탭을 지정 했어야 하며 &lt;code&gt;\t&lt;/code&gt; 는 &lt;code&gt;/xx&lt;/code&gt; 의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3357a4c3d096539100edeae44fe0fc63f41c1eb0" translate="yes" xml:space="preserve">
          <source>For cloning empty array or hash refs, the following may also be used:</source>
          <target state="translated">빈 배열 또는 해시 참조 복제에는 다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="066974b34c56796aa4147b1a5208072b1da06843" translate="yes" xml:space="preserve">
          <source>For code points above 255 ...</source>
          <target state="translated">255 이상의 코드 포인트의 경우 ...</target>
        </trans-unit>
        <trans-unit id="4c34d997e245e8b3d1bd93691addc32a9edcde31" translate="yes" xml:space="preserve">
          <source>For code points below 256 ...</source>
          <target state="translated">256 미만의 코드 포인트의 경우 ...</target>
        </trans-unit>
        <trans-unit id="52fc59bd49cfa06cf9318166c80386309a2f14db" translate="yes" xml:space="preserve">
          <source>For compactness, '&lt;b&gt;*&lt;/b&gt;' is used as a wildcard instead of showing all possible combinations. For example, entries like:</source>
          <target state="translated">압축하기 위해 ' &lt;b&gt;*&lt;/b&gt; '가 가능한 모든 조합을 표시하는 대신 와일드 카드로 사용됩니다. 예를 들어 다음과 같은 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c09a91ddfd48857b97077c2773ecb81af6bc79f" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">특정 언어와 비교하려면 종종 두 언어로 작은 프로젝트를 만들고 결과를 비교하는 것이 가장 좋습니다 . 언어는 구문 이상의 것이기 때문에 각 언어의 모든 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;리소스&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ced2a540dc94c886c1cbe6db66090842cbab20ed" translate="yes" xml:space="preserve">
          <source>For comparisons to a specific language it is often best to create a small project in both languages and compare the results, make sure to use all the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt; of each language, as a language is far more than just it's syntax.</source>
          <target state="translated">특정 언어와의 비교를 위해 두 언어로 된 작은 프로젝트를 만들고 결과를 비교하는 것이 가장 좋은 경우가 많습니다 . 언어는 구문 이상의 의미를 갖기 때문에 각 언어의 모든 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;리소스&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5928beb9ec422a398dc240b1a98fb88a78eacc43" translate="yes" xml:space="preserve">
          <source>For compatibility with</source>
          <target state="translated">와의 호환성을 위해</target>
        </trans-unit>
        <trans-unit id="c8f850be2ede8c9aabb5e0eb4de353aba7ade37a" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt;, which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt;. The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt;.</source>
          <target state="translated">Perl의 다른 부분과의 호환성을 위해 &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;위 섹션&lt;/a&gt; 의 표에 제공된 모든 단일 형식 이 인식됩니다. 그러나 일부 Perl 확장과 유니 코드 속성 사이에는 약간의 모호성이 있으며, 모두 공식 유니 코드 속성을 위해 조용히 해결됩니다. 놀라움을 피하려면 아래 표에 나열된 양식에 대해서만 &lt;code&gt;prop_invmap()&lt;/code&gt; 을 사용해야 하며 권장되지 않는 양식은 생략합니다. 영향을받는 형식은 유니 코드 속성에 해당하는 Perl 단일 형식입니다. 예를 들어 &lt;code&gt;\p{sc}&lt;/code&gt; 는 &lt;code&gt;\p{gc=sc}&lt;/code&gt; 해당하는 단일 형식이며 , &lt;code&gt;prop_invmap()&lt;/code&gt; 에서 짧은 이름을 가진 &lt;code&gt;Script&lt;/code&gt; 속성 으로 처리됩니다. 이다 &lt;code&gt;sc&lt;/code&gt; . 이 표는 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 단어로 시작하는 INFO 열의 현재 모호성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a7092eb766c083ed1177ee219bb4e03d914e1567" translate="yes" xml:space="preserve">
          <source>For compatibility with other parts of Perl, all the single forms given in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt; are recognized. BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property. To avoid surprises, you should only use &lt;code&gt;prop_invmap()&lt;/code&gt; for forms listed in the table below, which omits the non-recommended ones. The affected forms are the Perl single form equivalents of Unicode properties, such as &lt;code&gt;\p{sc}&lt;/code&gt; being a single-form equivalent of &lt;code&gt;\p{gc=sc}&lt;/code&gt; , which is treated by &lt;code&gt;prop_invmap()&lt;/code&gt; as the &lt;code&gt;Script&lt;/code&gt; property, whose short name is &lt;code&gt;sc&lt;/code&gt; . The table indicates the current ambiguities in the INFO column, beginning with the word &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; .</source>
          <target state="translated">Perl의 다른 부분과의 호환성을 위해 &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;위 섹션&lt;/a&gt; 의 표에 제공된 모든 단일 형식 이 인식됩니다. 그러나 일부 Perl 확장과 유니 코드 속성 사이에는 약간의 모호성이 있으며, 이들 모두는 공식적인 유니 코드 속성을 위해 자동으로 해결됩니다. 놀라움을 피하기 위해 아래 표에 나열된 양식 에만 &lt;code&gt;prop_invmap()&lt;/code&gt; 을 사용해야 합니다 ( 권장되지 않음). 영향을받는 형식은 &lt;code&gt;\p{sc}&lt;/code&gt; 와 같은 단일 형식의 Unicode 속성에 해당하는 Perl 단일 형식에 해당합니다. &lt;code&gt;\p{gc=sc}&lt;/code&gt; 와 같은 단일 형식에 해당 합니다. &lt;code&gt;prop_invmap()&lt;/code&gt; 의해 짧은 이름 인 &lt;code&gt;Script&lt;/code&gt; 속성 으로 처리됩니다. 이다 &lt;code&gt;sc&lt;/code&gt; . 이 테이블은 &lt;code&gt;&quot;NOT&quot;&lt;/code&gt; 단어로 시작하여 INFO 열의 현재 모호성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e8f8cf45418f21110ef02ba18a8fe7b0e0a35cfe" translate="yes" xml:space="preserve">
          <source>For compatibility with perl scripts written for the Unix environment, Plan 9 Perl uses the POSIX signal emulation provided in Plan 9's ANSI POSIX Environment (APE). Signal stacking isn't supported. The signals provided are:</source>
          <target state="translated">Unix 환경 용으로 작성된 perl 스크립트와의 호환성을 위해 Plan 9 Perl은 Plan 9의 ANSI POSIX Environment (APE)에서 제공되는 POSIX 신호 에뮬레이션을 사용합니다. 신호 스태킹은 지원되지 않습니다. 제공되는 신호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7ddc7130612083ca6f3d06a09409b25b9346875" translate="yes" xml:space="preserve">
          <source>For compatibility with popular C library functions, Perl implementations of the mkstemp() family of functions are provided. These are, mkstemp(), mkstemps(), mkdtemp() and mktemp().</source>
          <target state="translated">널리 사용되는 C 라이브러리 함수와의 호환성을 위해 mkstemp () 함수 계열의 Perl 구현이 제공됩니다. mkstemp (), mkstemps (), mkdtemp () 및 mktemp ()입니다.</target>
        </trans-unit>
        <trans-unit id="d25b76835899d4044aad201d72be6ea01f31876a" translate="yes" xml:space="preserve">
          <source>For compatibility with the old B::Terse, this module also adds a method named &lt;code&gt;terse&lt;/code&gt; to B::OP and B::SV objects. The B::SV method is largely compatible with the old one, though authors of new software might be advised to choose a more user-friendly output format. The B::OP &lt;code&gt;terse&lt;/code&gt; method, however, doesn't work well. Since B::Terse was first written, much more information in OPs has migrated to the scratchpad datastructure, but the &lt;code&gt;terse&lt;/code&gt; interface doesn't have any way of getting to the correct pad. As a kludge, the new version will always use the pad for the main program, but for OPs in subroutines this will give the wrong answer or crash.</source>
          <target state="translated">이전 B :: Terse와의 호환성을 위해이 모듈은 &lt;code&gt;terse&lt;/code&gt; 라는 메소드 를 B :: OP 및 B :: SV 객체에 추가합니다. B :: SV 방법은 기존 방법과 대부분 호환되지만 새 소프트웨어 제작자는보다 사용자 친화적 인 출력 형식을 선택하도록 권장 할 수 있습니다. 그러나 B :: OP &lt;code&gt;terse&lt;/code&gt; 방법은 제대로 작동하지 않습니다. B :: Terse가 처음 작성되었으므로 OP의 더 많은 정보가 스크래치 패드 데이터 구조로 마이그레이션되었지만 &lt;code&gt;terse&lt;/code&gt; 인터페이스에는 올바른 패드를 가져올 수있는 방법이 없습니다. kludge로서, 새로운 버전은 항상 메인 프로그램에 패드를 사용하지만 서브 루틴의 OP에 대해서는 잘못된 응답이나 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="67ec1b88f948f8864ab885d448e428104a1f5cbb" translate="yes" xml:space="preserve">
          <source>For compiling, you need following:</source>
          <target state="translated">컴파일하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c3582fce0d2ea8e40bba69ca7dfa38ec981ba20" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt; . This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt; .</source>
          <target state="translated">완전성을 위해 여기 &lt;code&gt;asynch_close&lt;/code&gt; 가 있습니다. 해시 &lt;code&gt;Mapping&lt;/code&gt; 에서 항목을 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9211f9a6bd70a952eb9e084b22fff2574a69c350" translate="yes" xml:space="preserve">
          <source>For completeness, here is &lt;code&gt;asynch_close&lt;/code&gt;. This shows how to remove the entry from the hash &lt;code&gt;Mapping&lt;/code&gt;.</source>
          <target state="translated">완전성을 위해 여기에 &lt;code&gt;asynch_close&lt;/code&gt; 가 있습니다. 이것은 해시 &lt;code&gt;Mapping&lt;/code&gt; 에서 항목을 제거하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1c043d0855883cdf3536e0246bdff4dcd9fcd74e" translate="yes" xml:space="preserve">
          <source>For consistency with common usage, perl's Configure script performs some minor manipulations on the operating system name and version number as reported by uname. Here's a partial translation table:</source>
          <target state="translated">일반적인 사용법과 일관성을 유지하기 위해 perl의 Configure 스크립트는 uname에 의해보고 된대로 운영 체제 이름 및 버전 번호를 약간 조작합니다. 다음은 부분 번역 표입니다.</target>
        </trans-unit>
        <trans-unit id="c929174990d09b02dcdbbabbaa2a02596a638c93" translate="yes" xml:space="preserve">
          <source>For constant subroutines, returns the constant SV returned by the subroutine.</source>
          <target state="translated">상수 서브 루틴의 경우 서브 루틴이 리턴 한 상수 SV를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e387ea14df2d8d86cc5babf9af2677b505e2619" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt; &quot; or &quot;&lt;code&gt;@&lt;/code&gt; &quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">보간을 수행하는 구문의 경우 &quot; &lt;code&gt;$&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;@&lt;/code&gt; &quot;로 시작하는 변수 가 보간됩니다. &lt;code&gt;$a[3]&lt;/code&gt; 또는 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 과 같은 첨자 변수 도 배열 및 해시 슬라이스와 같이 보간됩니다. 그러나 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 와 같은 메소드 호출 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d824f17a668c6fb9730318bb144f77718695736e" translate="yes" xml:space="preserve">
          <source>For constructs that do interpolate, variables beginning with &quot;&lt;code&gt;$&lt;/code&gt;&quot; or &quot;&lt;code&gt;@&lt;/code&gt;&quot; are interpolated. Subscripted variables such as &lt;code&gt;$a[3]&lt;/code&gt; or &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; are also interpolated, as are array and hash slices. But method calls such as &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; are not.</source>
          <target state="translated">보간을 수행하는 구성의 경우 &quot; &lt;code&gt;$&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;@&lt;/code&gt; &quot;로 시작하는 변수 가 보간됩니다. &lt;code&gt;$a[3]&lt;/code&gt; 또는 &lt;code&gt;$href-&amp;gt;{key}[0]&lt;/code&gt; 과 같은 첨자 변수 도 배열 및 해시 슬라이스와 마찬가지로 보간됩니다. 그러나 &lt;code&gt;$obj-&amp;gt;meth&lt;/code&gt; 와 같은 메서드 호출 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec376fd19b0ff28e80aef02d1aa6f9c7cab7d82a" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; , or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), the right part needs another pair of delimiters such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">세 부분으로 된 구분 기호 ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; )가있는 구문의 경우 검색이 한 번 더 반복됩니다. 첫 번째 구분 기호가 구두점이 아닌 경우 세 구분 기호는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 와 같아야합니다 !!! 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr)))&lt;/a&gt;&lt;/code&gt; ,이 경우 상기 제 구분자 왼쪽 종료와 동시에 오른쪽 부분을 개시한다. 왼쪽 부분이 괄호로 묶여 (즉 , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 구분되는 경우 오른쪽 부분에는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s(){}&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[]//&lt;/a&gt;&lt;/code&gt; 와 같은 다른 구분 기호 쌍이 필요합니다.. 이 경우 두 부분 사이에 공백과 주석이 허용되지만 주석은 최소한 하나의 공백 문자 뒤에 와야합니다. 그렇지 않으면 주석의 시작으로 예상되는 문자는 오른쪽 부분의 시작 구분자로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f740e18c473e8e61739f44b26934139fa90e6b" translate="yes" xml:space="preserve">
          <source>For constructs with three-part delimiters (&lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;, and &lt;code&gt;tr///&lt;/code&gt;), the search is repeated once more. If the first delimiter is not an opening punctuation, the three delimiters must be the same, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;tr)))&lt;/code&gt;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), the right part needs another pair of delimiters such as &lt;code&gt;s(){}&lt;/code&gt; and &lt;code&gt;tr[]//&lt;/code&gt;. In these cases, whitespace and comments are allowed between the two parts, although the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.</source>
          <target state="translated">세 부분으로 된 구분 기호 ( &lt;code&gt;s///&lt;/code&gt; , &lt;code&gt;y///&lt;/code&gt; 및 &lt;code&gt;tr///&lt;/code&gt; )가있는 구성의 경우 검색이 한 번 더 반복됩니다. 첫 번째 구분 기호가 여는 구두점이 아닌 경우 세 구분 기호는 동일해야합니다 (예 : &lt;code&gt;s!!!&lt;/code&gt; 및 &lt;code&gt;tr)))&lt;/code&gt; ,이 경우 두 번째 구분 기호는 왼쪽 부분을 종료하고 오른쪽 부분을 한 번에 시작합니다. 왼쪽 부분이 괄호 구두점으로 구분 된 경우 (즉 , &lt;code&gt;()&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 오른쪽 부분에는 &lt;code&gt;s(){}&lt;/code&gt; 및 &lt;code&gt;tr[]//&lt;/code&gt; 과 같은 다른 구분 기호 쌍이 필요합니다.. 이 경우 주석은 적어도 하나의 공백 문자 뒤에 와야하지만 두 부분 사이에 공백과 주석이 허용됩니다. 그렇지 않으면 주석의 시작으로 예상되는 문자가 오른쪽 부분의 시작 구분자로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343bf25e2927a4e247fde284894e20f4a2092df4" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</source>
          <target state="translated">편의상 &lt;code&gt;GLOB_CSH&lt;/code&gt; 는 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7db168533be63e476cbf03e4ddcd8399688a0c04" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;GLOB_CSH&lt;/code&gt; is a synonym for &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;GLOB_CSH&lt;/code&gt; 는 &lt;code&gt;GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40732251f5c21be8c597889848a82040a77a373e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;IO::File&lt;/code&gt; exports the O_XXX constants from the Fcntl module, if this module is available.</source>
          <target state="translated">편의상 &lt;code&gt;IO::File&lt;/code&gt; 은이 모듈을 사용할 수있는 경우 Fcntl 모듈에서 O_XXX 상수를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="38a10ffe4a20ca5792a7fd00b9c73d9ce59a1dd3" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... most-recently assigned; i.e. the &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... associated with the rightmost closing parenthesis used in the match).</source>
          <target state="translated">편의를 위해, 펄 설정 &lt;code&gt;$+&lt;/code&gt; 번호가 최고에 유지 문자열 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 다소 관련 할당 얻었다 (그리고 &lt;code&gt;$^N&lt;/code&gt; 의 값에 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 가장 최근이 할당 즉, &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...는 경기에서 사용되는 가장 오른쪽 닫는 괄호와 관련이 있습니다).</target>
        </trans-unit>
        <trans-unit id="9011b98b95f15cd4a087ddfce8ee15dfdd0721aa" translate="yes" xml:space="preserve">
          <source>For convenience, Perl sets &lt;code&gt;$+&lt;/code&gt; to the string held by the highest numbered &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,... that got assigned (and, somewhat related, &lt;code&gt;$^N&lt;/code&gt; to the value of the &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,... most-recently assigned;</source>
          <target state="translated">편의상 Perl은 &lt;code&gt;$+&lt;/code&gt; 를 할당 된 가장 높은 숫자 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...가 보유한 문자열로 설정합니다 (그리고 약간 관련이있는 &lt;code&gt;$^N&lt;/code&gt; 은 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 가장 최근에 할당 된 값 ;</target>
        </trans-unit>
        <trans-unit id="fb5611347ffd15c1223ef802d0edf52fb7e73b41" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; ) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">편의상 &lt;code&gt;'code...'&lt;/code&gt; 필터링 작업 중에 Filter :: Simple은 모든 자리 표시 자와 일치하는 미리 컴파일 된 정규식을 포함하고 식별자를 캡처 하는 패키지 변수 ( &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; )를 제공합니다. 자리 표시 자 내에서 자리 표시자는 필요에 따라 소스 코드 내에서 이동하고 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a977f7d9164e482b657b3b8fb97633309d91ddb" translate="yes" xml:space="preserve">
          <source>For convenience, during a &lt;code&gt;'code...'&lt;/code&gt; filtering operation, Filter::Simple provides a package variable (&lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt;) that contains a pre-compiled regex that matches any placeholder...and captures the identifier within the placeholder. Placeholders can be moved and re-ordered within the source code as needed.</source>
          <target state="translated">편의를 위해 &lt;code&gt;'code...'&lt;/code&gt; 필터링 작업 중에 Filter :: Simple은 모든 자리 표시 자와 일치하는 미리 컴파일 된 정규식을 포함하고 식별자를 캡처 하는 패키지 변수 ( &lt;code&gt;$Filter::Simple::placeholder&lt;/code&gt; )를 제공합니다. 자리 표시 자 내에서. 플레이스 홀더는 필요에 따라 소스 코드 내에서 이동하고 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a034c7b9883166db2c708f0dc5f543d0d6c5f5c5" translate="yes" xml:space="preserve">
          <source>For conversion of code points potentially larger than will fit in a character, use &lt;a href=&quot;#NATIVE_TO_UNI&quot;&gt;&quot;NATIVE_TO_UNI&quot;&lt;/a&gt;.</source>
          <target state="translated">문자에 맞는 것보다 더 큰 코드 포인트를 변환하려면 &lt;a href=&quot;#NATIVE_TO_UNI&quot;&gt;&quot;NATIVE_TO_UNI&quot;를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ab53246447ba99db18af65b753a1b02f0b27488" translate="yes" xml:space="preserve">
          <source>For conversion of code points potentially larger than will fit in a character, use &lt;a href=&quot;#UNI_TO_NATIVE&quot;&gt;&quot;UNI_TO_NATIVE&quot;&lt;/a&gt;.</source>
          <target state="translated">문자에 맞는 것보다 더 큰 코드 포인트를 변환하려면 &lt;a href=&quot;#UNI_TO_NATIVE&quot;&gt;&quot;UNI_TO_NATIVE&quot;를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4adefa4b79abf45088dcb0ac2e06a348c35319" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; .</source>
          <target state="translated">변환을 위해 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 및 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5d0e531ca755bbadc32f76a7bbbf87909f5f1d0" translate="yes" xml:space="preserve">
          <source>For conversion we have &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; and &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt;.</source>
          <target state="translated">변환을 위해 &lt;code&gt;Cygwin::win_to_posix_path()&lt;/code&gt; 및 &lt;code&gt;Cygwin::posix_to_win_path()&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d928fe0051212f2f8da39a8b5bc221435184fd0" translate="yes" xml:space="preserve">
          <source>For copyright</source>
          <target state="translated">저작권</target>
        </trans-unit>
        <trans-unit id="1a0a72b7c53bc47eff73c9a1bbea76977d805414" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">동아시아 반자 및 전자 문자를 올바르게 처리하려면 &lt;a href=&quot;Text::WrapI18N&quot;&gt;Text :: WrapI18N을&lt;/a&gt; 참조하십시오 . 더 자세한 컨트롤 : &lt;a href=&quot;Text::Format&quot;&gt;Text :: Format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eecebe67970e7a41398f09174a7fb5bf129f3a9" translate="yes" xml:space="preserve">
          <source>For correct handling of East Asian half- and full-width characters, see &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text::WrapI18N&lt;/a&gt;. For more detailed controls: &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text::Format&lt;/a&gt;.</source>
          <target state="translated">동아시아 반자 및 전자 문자를 올바르게 처리하려면 &lt;a href=&quot;http://search.cpan.org/perldoc/Text::WrapI18N&quot;&gt;Text :: WrapI18N을&lt;/a&gt; 참조하십시오 . 더 자세한 컨트롤 : &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Format&quot;&gt;Text :: Format&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e192d740cc4683287225288711c73e147509978a" translate="yes" xml:space="preserve">
          <source>For custom ops the type is returned from the registration, and it is up to the registree to ensure it is accurate. The value returned will be one of the &lt;code&gt;OA_&lt;/code&gt;* constants from</source>
          <target state="translated">사용자 지정 작업의 경우 유형은 등록에서 반환되며 정확한지 확인하는 것은 레지스트리 트리에 달려 있습니다. 반환 된 값은 다음의 &lt;code&gt;OA_&lt;/code&gt; * 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="5605d690fc41e9584f8f39d50fb58f9b59b16327" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">날짜 및 시간 처리에 대해서는 CPAN의 많은 관련 모듈을 참조하십시오. 포괄적 인 날짜 및 시간 표현은 &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f77b308a2ac839fd33563f9a552da3eeb4daa9" translate="yes" xml:space="preserve">
          <source>For date and time processing look at the many related modules on CPAN. For a comprehensive date and time representation look at the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module.</source>
          <target state="translated">날짜 및 시간 처리에 대해서는 CPAN의 많은 관련 모듈을보십시오. 포괄적 인 날짜 및 시간 표현은 &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07b6da6b04aa2922da90bdf4ba16ff504d7726a7" translate="yes" xml:space="preserve">
          <source>For debugging of CPAN data there is the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; command which takes the same arguments as make/test/install and outputs each object's Data::Dumper dump. If an argument looks like a perl variable and contains one of &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , it is eval()ed and fed to Data::Dumper directly.</source>
          <target state="translated">CPAN 데이터의 디버깅에는 make / test / install과 동일한 인수를 사용하여 각 오브젝트의 Data :: Dumper 덤프를 출력 하는 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 명령이 있습니다. 인수가 perl 변수처럼 보이고 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 중 하나를 포함 하는 경우 eval ()되어 Data :: Dumper에 직접 공급됩니다.</target>
        </trans-unit>
        <trans-unit id="8a807f2c9fb85faf8c9ac5d861d440bcf8bfce3c" translate="yes" xml:space="preserve">
          <source>For debugging the code of CPAN.pm itself in interactive mode, some debugging aid can be turned on for most packages within CPAN.pm with one of</source>
          <target state="translated">대화식 모드에서 CPAN.pm 코드 자체를 디버깅하기 위해 CPAN.pm 내의 대부분의 패키지에 대해 다음 중 하나를 사용하여 일부 디버깅 지원을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc61b5871895f28ad48638872dd4fd8cf1a53e5e" translate="yes" xml:space="preserve">
          <source>For decimal versions, an integer portion (no leading 0), a decimal point, and one or more digits to the right of the decimal are all required.</source>
          <target state="translated">10 진수 버전의 경우 정수 부분 (선행 0 없음), 소수점 및 소수점 오른쪽에있는 하나 이상의 숫자가 모두 필요합니다.</target>
        </trans-unit>
        <trans-unit id="012acad439f571a1fc425f25a48809ae662859e2" translate="yes" xml:space="preserve">
          <source>For decimal versions:</source>
          <target state="translated">10 진수 버전의 경우 :</target>
        </trans-unit>
        <trans-unit id="e18adf48baa2e5602e7386e7898a8696aea38703" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides &lt;a href=&quot;Time::HiRes#ualarm-%28-%24useconds-%5B%2C-%24interval_useconds-%5D-%29&quot;&gt;&lt;code&gt;ualarm&lt;/code&gt;&lt;/a&gt;. You may also use Perl's four-argument version of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; leaving the first three arguments undefined, or you might be able to use the &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; interface to access &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer(2)&lt;/a&gt; if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 더 세밀한 지연을 위해 &lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt; 모듈 (CPAN에서 시작하고 표준 배포의 Perl 5.8 부분에서 시작)은 &lt;a href=&quot;Time::HiRes#ualarm-%28-%24useconds-%5B%2C-%24interval_useconds-%5D-%29&quot;&gt; &lt;code&gt;ualarm&lt;/code&gt; 을&lt;/a&gt; 제공합니다 . 또한 Perl의 4 개 인수 버전의 &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 를 사용하여 처음 3 개의 인수를 정의하지 않은 채로 두거나 시스템에서 지원하는 경우 &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer (2)&lt;/a&gt; 에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2375819172a576f1b09ffc97251059479964eff9" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides &lt;a href=&quot;Time::HiRes#usleep-%28-%24useconds-%29&quot;&gt;&lt;code&gt;usleep&lt;/code&gt;&lt;/a&gt;. You may also use Perl's four-argument version of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; leaving the first three arguments undefined, or you might be able to use the &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; interface to access &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer(2)&lt;/a&gt; if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 더 세밀한 지연을 위해 &lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt; 모듈 (CPAN에서 시작하고 표준 배포의 Perl 5.8 부분부터 시작)은 &lt;a href=&quot;Time::HiRes#usleep-%28-%24useconds-%29&quot;&gt; &lt;code&gt;usleep&lt;/code&gt; 을&lt;/a&gt; 제공합니다 . 또한 Perl의 4 개 인수 버전의 &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 를 사용하여 처음 3 개의 인수를 정의하지 않은 채로 두거나 시스템에서 지원하는 경우 &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 &lt;a href=&quot;http://man.he.net/man2/setitimer&quot;&gt;setitimer (2)&lt;/a&gt; 에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb5d5a55a6b1cad338bb173db36952043185ac23" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8에서 시작)은 ualarm ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd003af05b2132ba4b881a232af5e4cee8933eae" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides ualarm(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8에서 시작)은 ualarm ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템이 지원하는 경우 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="048bc05974c11cb3f14983d6e8a4de95a334014e" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8 부분에서 시작)은 usleep ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템에서 지원하는 경우 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d999a8a7adf00f409cdbfb2fc0969a34ea071e33" translate="yes" xml:space="preserve">
          <source>For delays of finer granularity than one second, the Time::HiRes module (from CPAN, and starting from Perl 5.8 part of the standard distribution) provides usleep(). You may also use Perl's four-argument version of select() leaving the first three arguments undefined, or you might be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface to access setitimer(2) if your system supports it. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">1 초보다 세분화 된 지연 시간을 위해 Time :: HiRes 모듈 (CPAN 및 표준 배포의 Perl 5.8 부분에서 시작)은 usleep ()을 제공합니다. 첫 번째 세 개의 인수를 정의하지 않은 상태로 Perl의 4 인수 버전의 select ()를 사용 하거나 시스템에서 지원하는 경우 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 인터페이스를 사용하여 setitimer (2)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="880c0e9f515e34271c2c3b119d8f343dab33b21c" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt; , see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 을 실행하는 데 필요한 종속성 은 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56efd43ff2633084d0c4fb894544829d1847b596" translate="yes" xml:space="preserve">
          <source>For dependencies that are required in order to run &lt;code&gt;Makefile.PL&lt;/code&gt;, see &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; 실행에 필요한 종속성 은 &lt;code&gt;CONFIGURE_REQUIRES&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25b652017d6aba87f803b1349ff4840587bb26a8" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;&quot;OP-RELATED CLASSES&quot;&lt;/a&gt;.</source>
          <target state="translated">이러한 개체의 클래스 계층 구조 및 개체에서 호출 할 수있는 메서드에 대한 설명은 아래의 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; 및 &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;&quot;OP-RELATED CLASSES&quot;를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a1506155c00ca0b29e754a84c95c6d4d84c08eb" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;&quot;SV-RELATED CLASSES&quot;&lt;/a&gt;.</source>
          <target state="translated">이러한 개체의 클래스 계층 구조 및 개체에서 호출 할 수있는 메서드에 대한 설명은 아래의 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;&quot;OVERVIEW OF CLASSES&quot;&lt;/a&gt; 및 &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;&quot;SV-RELATED CLASSES&quot;를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33634f235f0082e4181888900b85711db47d8f18" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">이러한 객체의 클래스 계층 구조 및 해당 객체에서 호출 할 수있는 메소드에 대한 설명은 아래 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;의 클래스&lt;/a&gt; 및 &lt;a href=&quot;#OP-RELATED-CLASSES&quot;&gt;OP- 관련 클래스 &lt;/a&gt;의 개요를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3b2ae9d73ddeeda58bc4e13e54cb8a6fed8f14d" translate="yes" xml:space="preserve">
          <source>For descriptions of the class hierarchy of these objects and the methods that can be called on them, see below, &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;OVERVIEW OF CLASSES&lt;/a&gt; and &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV-RELATED CLASSES&lt;/a&gt;.</source>
          <target state="translated">이러한 객체의 클래스 계층 구조 및 해당 객체에서 호출 할 수있는 메소드에 대한 설명은 아래 &lt;a href=&quot;#OVERVIEW-OF-CLASSES&quot;&gt;의 클래스&lt;/a&gt; 및 &lt;a href=&quot;#SV-RELATED-CLASSES&quot;&gt;SV 관련 클래스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ec22c5e89b166831180c8fd7d61e1db96cf2000" translate="yes" xml:space="preserve">
          <source>For deserialisation there are only two cases to consider: either nonstandard tagging was used, in which case &lt;code&gt;allow_tags&lt;/code&gt; decides, or objects cannot be automatically be deserialised, in which case you can use postprocessing or the &lt;code&gt;filter_json_object&lt;/code&gt; or &lt;code&gt;filter_json_single_key_object&lt;/code&gt; callbacks to get some real objects our of your JSON.</source>
          <target state="translated">deserialization의 경우 고려해야 할 두 가지 경우 만 있습니다. 비표준 태그 지정이 사용 된 경우 &lt;code&gt;allow_tags&lt;/code&gt; 가 결정하거나 객체를 자동으로 deserialize 할 수없는 경우 사후 처리 또는 &lt;code&gt;filter_json_object&lt;/code&gt; 또는 &lt;code&gt;filter_json_single_key_object&lt;/code&gt; 콜백을 사용하여 실제 객체를 가져올 수 있습니다. 귀하의 JSON.</target>
        </trans-unit>
        <trans-unit id="ae8371a2b6a91f80da291b64adb024dd9ea39e6b" translate="yes" xml:space="preserve">
          <source>For details on typemaps: &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">타입 맵에 대한 자세한 내용 : &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="826700f3b65927540e360eda58122d1f12e92b58" translate="yes" xml:space="preserve">
          <source>For details, please see &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&lt;/a&gt; .</source>
          <target state="translated">자세한 내용은 &lt;code&gt;Unicode mapping issues and notes:&lt;/code&gt; ( &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/DEVANAGA.TXT)&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6890c04c351eed8402cc96040025e018355d7713" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt; .</source>
          <target state="translated">자세한 내용은 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98a64169dc734a8fe4119fbf2902257cf31763af" translate="yes" xml:space="preserve">
          <source>For details, see &lt;code&gt;perldoc ppport.h&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;perldoc ppport.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4be1d326997ed9e19e7a04e776dc614ee400c4f2" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2da6125e37beb908e4b87a83be8efad53c88ed6a" translate="yes" xml:space="preserve">
          <source>For details, see the description for &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;은 perlapi의 &quot;uvchr_to_utf8_flags&quot;에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4cabeb3c36ea2c5a3fbd884ca6fe8ba5049b92" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">고유 한 배열을 작성하려는 개발자의 경우 필요한 메소드가 아래에 간략하게 정의되어 있습니다. 예제 코드뿐만 아니라 자세한 설명 은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8316eda6036e10f32d157be6bef162675363fcbc" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied arrays, the required methods are briefly defined below. See the &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">자신의 묶인 배열을 작성하려는 개발자를 위해 필요한 메서드가 아래에 간략하게 정의되어 있습니다. 자세한 설명과 예제 코드 는 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d33242068f9073573772617185fa7b62c43ab672" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">고유 한 해시를 작성하려는 개발자의 경우 필요한 메소드가 아래에 간략하게 정의되어 있습니다. 예제 코드뿐만 아니라 자세한 설명 은 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53d3c2e123f9e22a4cc720388ad65b46d722f606" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied hashes, the required methods are briefly defined below. See the &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section for more detailed descriptive, as well as example code:</source>
          <target state="translated">자신의 연결된 해시를 작성하려는 개발자를 위해 필요한 메서드가 아래에 간략하게 정의되어 있습니다. 자세한 설명과 예제 코드 는 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6d44567c847615da73e4dc3fbe1131bc5a3e2c2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자신의 연결 핸들 클래스를 작성하려는 개발자를 위해 메소드가 아래에 요약되어 있습니다. &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션 은 이것들을 문서화 할뿐만 아니라 샘플 코드도 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cfab23da22f4cecd199b96340524fcbe57be2da2" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-handle classes, the methods are summarized below. The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자신의 묶인 핸들 클래스를 작성하려는 개발자를 위해 메서드가 아래에 요약되어 있습니다. &lt;a href=&quot;perltie&quot;&gt;perltie의&lt;/a&gt; 섹션에서는 이러한 문서화하지만,뿐만 아니라 샘플 코드가 아니라 :</target>
        </trans-unit>
        <trans-unit id="928786a6337e41cc2160d3e1f5e15f742b97fa65" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자체 스칼라 클래스를 작성하려는 개발자를 위해 메소드가 아래에 요약되어 있습니다. &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; 섹션 은 이것들을 문서화 할뿐만 아니라 샘플 코드도 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="44a8d6f6fe6dd4abebf057c19fabf3ddbd2841d0" translate="yes" xml:space="preserve">
          <source>For developers wishing to write their own tied-scalar classes, the methods are summarized below. The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section not only documents these, but has sample code as well:</source>
          <target state="translated">자신의 묶인 스칼라 클래스를 작성하려는 개발자를 위해 메서드가 아래에 요약되어 있습니다. &lt;a href=&quot;perltie&quot;&gt;perltie의&lt;/a&gt; 섹션에서는 이러한 문서화하지만,뿐만 아니라 샘플 코드가 아니라 :</target>
        </trans-unit>
        <trans-unit id="0cff3dbfb52c9f4d663ef8f25c758142a479cc70" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt;bufend&quot;&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">버퍼를 직접 검사하기 위해 변수 &lt;a href=&quot;#PL_parser-%3Ebufend&quot;&gt;&quot;PL_parser-&amp;gt; bufend&quot;&lt;/a&gt; 는 버퍼의 끝을 가리 킵니다. 현재 렉싱 위치는 &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt; bufptr&quot;&lt;/a&gt; 에 의해 지정됩니다 . 이러한 포인터를 직접 사용하는 것이 일반적으로 일반 스칼라 수단을 통해 스칼라를 검사하는 것보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="83e90c795a8afb6a6c9de6553439d8f6cbbf665f" translate="yes" xml:space="preserve">
          <source>For direct examination of the buffer, the variable &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt;bufend&lt;/a&gt; points to the end of the buffer. The current lexing position is pointed to by &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;. Direct use of these pointers is usually preferable to examination of the scalar through normal scalar means.</source>
          <target state="translated">버퍼를 직접 검사하기 위해 변수 &lt;a href=&quot;#PL_parser-%3ebufend&quot;&gt;PL_parser-&amp;gt; bufend&lt;/a&gt; 는 버퍼의 끝을 가리 킵니다. 현재 lexing 위치는 &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr로 지정&lt;/a&gt; 됩니다. 보통 스칼라 수단을 통해 스칼라를 검사하기 위해서는 이러한 포인터를 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="13c49c22472e027f068753f3e29a491152b0010b" translate="yes" xml:space="preserve">
          <source>For distributions that use</source>
          <target state="translated">사용하는 배포판</target>
        </trans-unit>
        <trans-unit id="985017370413b179ae3946fe35f99a058dfef566" translate="yes" xml:space="preserve">
          <source>For doing I/O it is suggested that you use the autotranslating features of PerlIO, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">I / O를 수행하려면 PerlIO의 자동 &lt;a href=&quot;perluniintro&quot;&gt;번역&lt;/a&gt; 기능을 사용하는 것이 좋습니다 ( perluniintro 참조) .</target>
        </trans-unit>
        <trans-unit id="f6c6fdf9044dc1cd6c013956178bb36e51e123a3" translate="yes" xml:space="preserve">
          <source>For dotted decimals:</source>
          <target state="translated">점으로 구분 된 소수의 경우 :</target>
        </trans-unit>
        <trans-unit id="f34dd79d1671e29d1a48a8679e05577208a886df" translate="yes" xml:space="preserve">
          <source>For dotted-decimal versions, a leading 'v' is required, with three or more sub-versions of no more than three digits. A leading 0 (zero) before the first sub-version (in the above example, '1') is also prohibited.</source>
          <target state="translated">점으로 구분 된 10 진수 버전의 경우 3 자리 이하의 하위 버전이 3 개 이상인 선행 'v'가 필요합니다. 첫 번째 하위 버전 (위의 예에서 '1') 앞에 오는 0 (영)도 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="ce51f0686aa7fd04915057c8a38b4ba2a606bb7b" translate="yes" xml:space="preserve">
          <source>For double-quoted strings, the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation and escapes are processed.</source>
          <target state="translated">큰 따옴표로 묶인 문자열의 경우 &lt;code&gt;\Q&lt;/code&gt; 의 인용은 보간 및 이스케이프 처리 후 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="812614d64656fd03480d177dcb159cfedfd0b074" translate="yes" xml:space="preserve">
          <source>For dynamic extensions at build/link time</source>
          <target state="translated">빌드 / 링크시 동적 확장 용</target>
        </trans-unit>
        <trans-unit id="c0153ffdb0839d7060eac410231aabcc8768cf39" translate="yes" xml:space="preserve">
          <source>For dynamic extensions at load time</source>
          <target state="translated">로드시 동적 확장 용</target>
        </trans-unit>
        <trans-unit id="7153807fff58e3cc6dcc7b6391711735f5c48fc7" translate="yes" xml:space="preserve">
          <source>For each component, we mention environment variables related to each installation directory. Either choose directories to match your values of the variables, or create/append-to variables to take into account the directories.</source>
          <target state="translated">각 구성 요소에 대해 각 설치 디렉토리와 관련된 환경 변수를 언급합니다. 변수 값과 일치하는 디렉토리를 선택하거나 디렉토리를 고려할 변수를 작성 / 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="de6d45e2b8e4280d7556487f705375ab5958c2c9" translate="yes" xml:space="preserve">
          <source>For each currently defined drive letter, a &lt;code&gt;'\0'&lt;/code&gt;-terminated string of the path to the root of its file system is constructed. All of these strings are concatenated into a single larger string and an extra terminating &lt;code&gt;'\0'&lt;/code&gt; is added. This larger string is returned in &lt;code&gt;$osBuffer&lt;/code&gt;. Note that this includes drive letters that have been defined but that have no file system, such as drive letters assigned to unformatted partitions.</source>
          <target state="translated">현재 정의 된 각 드라이브 문자 에 대해 파일 시스템의 루트 경로 의 &lt;code&gt;'\0'&lt;/code&gt; 문자열이 구성됩니다. 이 모든 문자열은 하나의 큰 문자열로 연결되고 추가로 끝나는 &lt;code&gt;'\0'&lt;/code&gt; 이 추가됩니다. 이 큰 문자열은 &lt;code&gt;$osBuffer&lt;/code&gt; 반환됩니다 . 여기에는 포맷되지 않은 파티션에 할당 된 드라이브 문자와 같이 정의되었지만 파일 시스템이없는 드라이브 문자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8371507ff701446b1827e00e5e462be60a5389" translate="yes" xml:space="preserve">
          <source>For each define, this gives a reference to an array of op names that use the flag.</source>
          <target state="translated">각 정의에 대해 플래그를 사용하는 작업 이름 배열에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ba4c925cffa4324c85082d132c7153102054ac63" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is added to @INC in front of $dir. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and adds these directories to @INC.</source>
          <target state="translated">LIST의 각 디렉토리 (여기서는 $ dir)에서 lib 모듈은 $ dir / $ archname / auto라는 디렉토리가 존재하는지 확인합니다. 그렇다면 $ dir / $ archname 디렉토리는 해당 아키텍처 특정 디렉토리로 가정되며 $ dir 앞에 @INC에 추가됩니다. lib.pm은 또한 $ dir / $ version 및 $ dir / $ version / $ archname이라는 디렉토리가 있는지 확인하고이 디렉토리를 @INC에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d6c50d0e6a86403f83c942ee394e8555abc0ddcd" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC.</source>
          <target state="translated">LIST의 각 디렉토리 (여기서는 $ dir)에서 lib 모듈은 $ dir / $ archname / auto라는 디렉토리가 존재하는지 확인합니다. 그렇다면 $ dir / $ archname 디렉토리는 해당 아키텍처 특정 디렉토리로 가정되며 @INC에서도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9b55b36de0f652d038ba1cdb31f1b3a1791c2037" translate="yes" xml:space="preserve">
          <source>For each directory in LIST (called $dir here) the lib module also checks to see if a directory called $dir/$archname/auto exists. If so the $dir/$archname directory is assumed to be a corresponding architecture specific directory and is also deleted from @INC. lib.pm also checks if directories called $dir/$version and $dir/$version/$archname exist and deletes these directories from @INC.</source>
          <target state="translated">LIST의 각 디렉토리 (여기서는 $ dir이라고 함)에 대해 lib 모듈은 $ dir / $ archname / auto라는 디렉토리가 있는지도 확인합니다. 그렇다면 $ dir / $ archname 디렉토리는 해당 아키텍처 특정 디렉토리로 간주되며 @INC에서도 삭제됩니다. lib.pm은 또한 $ dir / $ version 및 $ dir / $ version / $ archname이라는 디렉토리가 있는지 확인하고 이러한 디렉토리를 @INC에서 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d3b570115f1b3f6cab2450c47d487f4ae062c54b" translate="yes" xml:space="preserve">
          <source>For each instance of amnesty the &lt;code&gt;details&lt;/code&gt; field explains why amnesty was granted.</source>
          <target state="translated">각 사면 사례에 대해 &lt;code&gt;details&lt;/code&gt; 필드에 사면이 부여 된 이유가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c500f7aea9ecaf66833169bb60bfa93a088a3dfe" translate="yes" xml:space="preserve">
          <source>For each key, an example is provided followed by a description. The description begins with the version of spec in which the key was added or in which the definition was modified, whether the key is</source>
          <target state="translated">각 키에 대해 설명과 함께 예제가 제공됩니다. 설명은 키가 추가되었는지 여부에 관계없이 키가 추가되었거나 정의가 수정 된 사양의 버전으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="64daaac0c21c762b1798b346c0a1931a0dd72bc6" translate="yes" xml:space="preserve">
          <source>For each library that is found, an appropriate directive for a linker options file is generated. The return values are space-separated strings of these directives, rather than elements used on the linker command line.</source>
          <target state="translated">발견 된 각 라이브러리에 대해 링커 옵션 파일에 대한 적절한 지시문이 생성됩니다. 반환 값은 링커 명령 줄에 사용 된 요소가 아니라 공백으로 구분 된 이러한 지시문의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3313c88e144064867d27f9004bd8e9beaf19e663" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b
)/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; flag, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">각 줄에 대해 &lt;code&gt;PARSER&lt;/code&gt; 루프는 먼저 일련의 숫자와 단어 경계를 일치 시키려고 시도합니다. 이 일치는 마지막 일치가 중단 된 위치 (또는 첫 번째 일치에서 문자열의 시작)에서 시작해야합니다. 이후 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 용도 &lt;code&gt;c&lt;/code&gt; 문자열이 정규 표현식에 일치하지 않는 경우 펄 다른 패턴을 시도하는 동일한 위치에 있지 리셋 POS () 및 다음 검색이 시작 않고, 플래그.</target>
        </trans-unit>
        <trans-unit id="1e5961cf88fc461e10eaeb188dad6082abb09771" translate="yes" xml:space="preserve">
          <source>For each line, the &lt;code&gt;PARSER&lt;/code&gt; loop first tries to match a series of digits followed by a word boundary. This match has to start at the place the last match left off (or the beginning of the string on the first match). Since &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; uses the &lt;code&gt;c&lt;/code&gt; modifier, if the string does not match that regular expression, perl does not reset pos() and the next match starts at the same position to try a different pattern.</source>
          <target state="translated">각 줄에 대해 &lt;code&gt;PARSER&lt;/code&gt; 루프는 먼저 일련의 숫자와 단어 경계를 일치 시키려고합니다. 이 경기는 마지막 경기가 중단 된 위치 (또는 첫 경기의 문자열 시작 부분)에서 시작해야합니다. 이후 &lt;code&gt;m/ \G( \d+\b )/gcx&lt;/code&gt; 용도 &lt;code&gt;c&lt;/code&gt; 문자열이 정규 표현식에 일치하지 않는 경우 펄 다른 패턴을 시도하는 동일한 위치에 있지 리셋 POS () 및 다음 검색이 시작 않으며, 개질제.</target>
        </trans-unit>
        <trans-unit id="fd6cfb118370f50c9c42bb5e390e24e86523c86f" translate="yes" xml:space="preserve">
          <source>For each line-style ('concise', 'terse', 'linenoise', etc.) there are 3 format-specs which control how OPs are rendered.</source>
          <target state="translated">각 선 스타일 ( '간결한', 'terse', 'linenoise'등)에는 OP가 렌더링되는 방법을 제어하는 ​​3 가지 형식 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ef94716a1f5652ad5d33bb69a0e70bcd8744c37" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&quot;(있는 경우)&quot;로 표시된 각 필드에서 성공시 기본값은 빈 문자열입니다. 실패하면,이 값들 (남은 텍스트 제외)은 모두 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="891b5f8726a4abe2a560a861ed1100968e0d0403" translate="yes" xml:space="preserve">
          <source>For each of the fields marked &quot;(if any)&quot; the default value on success is an empty string. On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&quot;(있는 경우)&quot;로 표시된 각 필드의 경우 성공 기본값은 빈 문자열입니다. 실패시 이러한 모든 값 (나머지 텍스트 제외)은 &lt;code&gt;undef&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4fdf0186b6bb5a61b6cf887ce8022d9f1ed87feb" translate="yes" xml:space="preserve">
          <source>For each of these three lists, the collection of signals set to be trapped is checked before trapping; if your architecture does not implement a particular signal, it will not be trapped but rather silently ignored.</source>
          <target state="translated">이 세 가지 목록 각각에 대해 트래핑되도록 설정된 신호 수집이 트래핑 전에 확인됩니다. 아키텍처가 특정 신호를 구현하지 않으면 트랩되지 않고 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ee92e857afe43bd5c799c71bf04f7d8761b4690e" translate="yes" xml:space="preserve">
          <source>For each such format, &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;ord($char)%16&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt;. For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt;, the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt;. Use only these specific hex characters with this format.</source>
          <target state="translated">이러한 각 형식에 대해 &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; 은 4 비트의 결과를 생성합니다. 알파벳이 아닌 문자의 경우 결과는 입력 문자의 최하위 비트 4 개 &lt;code&gt;ord($char)%16&lt;/code&gt; 예 : ord ($ char) % 16)를 기반으로 합니다. 특히 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 문자 는 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 바이트와 ​​마찬가지로 니블 0 및 1을 생성합니다 . 문자 &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; 의 경우 결과는 일반적인 16 진수와 호환되므로 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 모두 니블 &lt;code&gt;0xA==10&lt;/code&gt; 생성합니다 . 이 형식에는 이러한 특정 16 진 문자 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c00c059a52bac42904c37c4c2fb8927b36fa4f53" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">이러한 각 형식에 대해 pack ()은 4 비트의 결과를 생성합니다. 알파벳이 아닌 문자의 경우 결과는 입력 문자의 4 개 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 합니다. 특히, &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 문자 는 바이트 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 같이 nybbles 0 및 1을 생성합니다 . &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; 문자 의 경우 결과는 일반적인 16 진 숫자와 호환되므로 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 는 nybble &lt;code&gt;0xA==10&lt;/code&gt; 생성합니다 . 이 형식의 특정 16 진 문자 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8b61b8ba63bd2e7b3403785e0beac1c665bb76ab" translate="yes" xml:space="preserve">
          <source>For each such format, pack() generates 4 bits of result. With non-alphabetical characters, the result is based on the 4 least-significant bits of the input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate nybbles 0 and 1, as do bytes &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; . For characters &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; , the result is compatible with the usual hexadecimal digits, so that &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;A&quot;&lt;/code&gt; both generate the nybble &lt;code&gt;0xA==10&lt;/code&gt; . Use only these specific hex characters with this format.</source>
          <target state="translated">이러한 각 형식에 대해 pack ()은 4 비트의 결과를 생성합니다. 알파벳이 아닌 문자의 경우 결과는 입력 문자의 4 개 최하위 비트, 즉 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%16&lt;/a&gt;&lt;/code&gt; 합니다. 특히, &lt;code&gt;&quot;0&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 문자 는 바이트 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 과 같이 nybbles 0 및 1을 생성합니다 . &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;..&quot;F&quot;&lt;/code&gt; 문자 의 경우 결과는 일반적인 16 진 숫자와 호환되므로 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 는 nybble &lt;code&gt;0xA==10&lt;/code&gt; 생성합니다 . 이 형식의 특정 16 진 문자 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56bab3e1fc980d5c9adf77a55a7a575a655bbcbb" translate="yes" xml:space="preserve">
          <source>For earlier Perls, a QP encoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">이전 Perls의 경우 ASCII 및 EBCDIC 플랫폼 모두에서 작동하는 QP 인코더는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4008829801fc42279d6aea1087db0de93d9c0e6" translate="yes" xml:space="preserve">
          <source>For ease of access, the Perl manual has been split up into several sections.</source>
          <target state="translated">쉬운 접근을 위해 Perl 매뉴얼은 여러 섹션으로 나뉘어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2508ccfe05f4a37451a9fb33f66c8f8a0dd451f8" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt; .</source>
          <target state="translated">SEEK_ * 상수 (검색 () 및 sysseek (), 예 : SEEK_END) 및 S_I * 상수 (chmod () 및 stat ())도 가져 오기가 용이합니다. 개별적으로 가져 오거나 태그 &lt;code&gt;:&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;:mode&lt;/code&gt; 를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="080c953fd655148a5acb6735a1808c4238e35fff" translate="yes" xml:space="preserve">
          <source>For ease of use also the SEEK_* constants (for seek() and sysseek(), e.g. SEEK_END) and the S_I* constants (for chmod() and stat()) are available for import. They can be imported either separately or using the tags &lt;code&gt;:seek&lt;/code&gt; and &lt;code&gt;:mode&lt;/code&gt;.</source>
          <target state="translated">사용의 편의를 위해 SEEK_ * 상수 (seek () 및 sysseek () 용, 예 : SEEK_END) 및 S_I * 상수 (chmod () 및 stat () 용)도 가져 오기에 사용할 수 있습니다. 별도로 가져 오거나 &lt;code&gt;:seek&lt;/code&gt; 및 &lt;code&gt;:mode&lt;/code&gt; 태그를 사용하여 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c36f5b62afea33d1be2e3590e8d7005448aa361a" translate="yes" xml:space="preserve">
          <source>For easier debugging, you may prefer to always use the commas when not setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a warning.</source>
          <target state="translated">보다 쉬운 디버깅을 위해 $ Term :: ANSIColor :: AUTORESET 또는 PUSHCOLOR / POPCOLOR를 설정하지 않을 때 경고가 아닌 치명적인 컴파일 오류가 발생하도록 항상 쉼표를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="98fbe6111f30281308f810d30686560db37e9754" translate="yes" xml:space="preserve">
          <source>For editors: if you're on Unix you probably have vi or a vi clone already, and possibly an emacs too, so you may not need to download anything. In any emacs the cperl-mode (M-x cperl-mode) gives you perhaps the best available Perl editing mode in any editor.</source>
          <target state="translated">에디터 : Unix를 사용하는 경우 vi 또는 vi 복제본이 있고 아마도 emacs가있을 수 있으므로 아무것도 다운로드하지 않아도됩니다. 모든 emacs에서 cperl-mode (Mx cperl-mode)는 모든 편집기에서 가장 유용한 Perl 편집 모드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5aa663054769a993f1d5b54fdeaaf504f9f0a5ea" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, Perl takes a conservative view of whether data is tainted. If an expression contains tainted data, any subexpression may be considered tainted, even if the value of the subexpression is not itself affected by the tainted data.</source>
          <target state="translated">효율성상의 이유로 Perl은 데이터의 오염 여부를 보수적으로 고려합니다. 표현식에 오염 된 데이터가 포함 된 경우 하위 표현식의 값이 오염 된 데이터의 영향을받지 않는 경우에도 하위 표현식이 오염 된 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d03294b4e14b45668b8c5e5b3dfd1364498c9a" translate="yes" xml:space="preserve">
          <source>For efficiency, consider using &lt;code&gt;newSVpvn&lt;/code&gt; instead.</source>
          <target state="translated">효율성을 &lt;code&gt;newSVpvn&lt;/code&gt; 대신 newSVpvn을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="586297e0f4c9f862517187fc9706a3d0c6dfe92d" translate="yes" xml:space="preserve">
          <source>For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">강조하기 위해 코드 포인트와 전혀 일치하지 않는 속성은 표 다음의 별도 섹션에도 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f3b14d486219cf0d85fabf0e9eb85e0b88039e" translate="yes" xml:space="preserve">
          <source>For encodings that are implemented by the &lt;code&gt;Encode::XS&lt;/code&gt; module, &lt;code&gt;CHECK&lt;/code&gt;&lt;code&gt;==&lt;/code&gt;&lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; puts &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; into &lt;code&gt;perlqq&lt;/code&gt; fallback mode.</source>
          <target state="translated">에 의해 구현되는 인코딩을 위해 &lt;code&gt;Encode::XS&lt;/code&gt; 모듈 &lt;code&gt;CHECK&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;Encode::FB_PERLQQ&lt;/code&gt; 풋의 &lt;code&gt;encode&lt;/code&gt; 및 &lt;code&gt;decode&lt;/code&gt; 에 &lt;code&gt;perlqq&lt;/code&gt; 모드 폴백.</target>
        </trans-unit>
        <trans-unit id="5dbd88840e300bb2976ee7b89691796d725de54c" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">더 나은 제어를 위해 &lt;a href=&quot;Test::Most&quot;&gt;Test :: Most를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0461c72db1796ac384c3743d40421d6d728a24" translate="yes" xml:space="preserve">
          <source>For even better control look at &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test::Most&lt;/a&gt;.</source>
          <target state="translated">더 나은 제어를 위해서는 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Most&quot;&gt;Test :: Most를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6de84b40d8c9c92b7839fff9ac4fcc2776aacc0f" translate="yes" xml:space="preserve">
          <source>For even faster execution, you could do:</source>
          <target state="translated">더 빠른 실행을 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들면</target>
        </trans-unit>
        <trans-unit id="6b398db36194244f1d9cc63256c82345fa029b47" translate="yes" xml:space="preserve">
          <source>For example &quot;not ok 23 - hole count # TODO insufficient donuts&quot; would result in this structure:</source>
          <target state="translated">예를 들어 &quot;not ok 23-hole count # TODO insufficient donuts&quot;는 다음과 같은 구조로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a5d3ee5d1b4b93034c4647239c3af6ae67c5bde3" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt; , and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">예를 들어 &lt;code&gt;Carp&lt;/code&gt; 자체는 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열되어 있습니다. 따라서에서 전체 스택 역 추적 &lt;code&gt;confess&lt;/code&gt; 내부에 시작되지 않습니다 &lt;code&gt;Carp&lt;/code&gt; , 및 호출에서 짧은 메시지 &lt;code&gt;croak&lt;/code&gt; 라인에 배치되지 &lt;code&gt;croak&lt;/code&gt; 불렀다.</target>
        </trans-unit>
        <trans-unit id="521fa6026ce8939c8d285bb972a9f7bcfff4cab1" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;Carp&lt;/code&gt; itself is listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;. Therefore the full stack backtrace from &lt;code&gt;confess&lt;/code&gt; will not start inside of &lt;code&gt;Carp&lt;/code&gt;, and the short message from calling &lt;code&gt;croak&lt;/code&gt; is not placed on the line where &lt;code&gt;croak&lt;/code&gt; was called.</source>
          <target state="translated">예를 들어 &lt;code&gt;Carp&lt;/code&gt; 자체는 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 나열됩니다 . 따라서에서 전체 스택 역 추적 &lt;code&gt;confess&lt;/code&gt; 내부에 시작되지 않습니다 &lt;code&gt;Carp&lt;/code&gt; , 및 호출에서 짧은 메시지 &lt;code&gt;croak&lt;/code&gt; 라인에 배치되지 &lt;code&gt;croak&lt;/code&gt; 불렀다.</target>
        </trans-unit>
        <trans-unit id="ace2b7f25e1af57e029dcfd910f2807f801a5827" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt; ) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">예를 들어 , &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 오버레이 ( &lt;code&gt;U+0344&lt;/code&gt; )를 갖는 TIBETAN VOWEL SIGN VOCALIC RR 은 NFD에서 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; 입니다. 이 경우 &lt;code&gt;0FB2 0F80&lt;/code&gt; ( &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) 대신에, 검출 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . 삽입 된 &lt;code&gt;0344&lt;/code&gt; 는 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 을 불 연속적으로 만들고 수축 부족 &lt;code&gt;0FB2 0F71&lt;/code&gt; 은 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 이 감지되는 것을 금지 합니다.</target>
        </trans-unit>
        <trans-unit id="5b3b5d05e6eb63eda24be82cac42fbd12530ed9c" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; with &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; (&lt;code&gt;U+0344&lt;/code&gt;) is &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; in NFD. In this case &lt;code&gt;0FB2 0F80&lt;/code&gt; (&lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt;) is detected, instead of &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt;. Inserted &lt;code&gt;0344&lt;/code&gt; makes &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; discontiguous and lack of contraction &lt;code&gt;0FB2 0F71&lt;/code&gt; prohibits &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; from being detected.</source>
          <target state="translated">예 &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC RR&lt;/code&gt; 로 &lt;code&gt;COMBINING TILDE OVERLAY&lt;/code&gt; ( &lt;code&gt;U+0344&lt;/code&gt; )이다 &lt;code&gt;0FB2 0344 0F71 0F80&lt;/code&gt; NFD있다. 이 경우 &lt;code&gt;0FB2 0F80&lt;/code&gt; ( &lt;code&gt;TIBETAN VOWEL SIGN VOCALIC R&lt;/code&gt; ) 대신에, 검출 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; . 삽입 된 &lt;code&gt;0344&lt;/code&gt; 는 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 을 불 연속적으로 만들고 수축 부족 &lt;code&gt;0FB2 0F71&lt;/code&gt; 은 &lt;code&gt;0FB2 0F71 0F80&lt;/code&gt; 이 감지되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="30e72f699aeed60ccae59fad4d360b3c19491b02" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; , instead of just &lt;code&gt;U+1F80&lt;/code&gt; . This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">예를 들어 &lt;code&gt;U+1F88&lt;/code&gt; 은 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; 대신 U + 1F00 U + 03B9 와 &lt;code&gt;U+1F80&lt;/code&gt; . 이 차이는 주로 특정 수정자를 가진 특정 그리스어 대문자의 경우에 중요합니다. 전체 대소 문자는 문자를 분해하고 단순 대소 문자는 문자를 단일 문자로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="90b883def1af1c1a868a945977d2d26ca0ae5dc6" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;U+1F88&lt;/code&gt; is equivalent to &lt;code&gt;U+1F00 U+03B9&lt;/code&gt;, instead of just &lt;code&gt;U+1F80&lt;/code&gt;. This difference matters mainly for certain Greek capital letters with certain modifiers: the Full case-folding decomposes the letter, while the Simple case-folding would map it to a single character.</source>
          <target state="translated">예를 들어 &lt;code&gt;U+1F88&lt;/code&gt; 은 &lt;code&gt;U+1F00 U+03B9&lt;/code&gt; 대신 U + 1F00 U + 03B9 와 &lt;code&gt;U+1F80&lt;/code&gt; 합니다. 이 차이는 주로 특정 수정자가있는 특정 그리스 대문자에 중요합니다. 전체 대 / 소문자 접는 문자를 분해하는 반면 단순 대 / 소문자 접는 단일 문자에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b565d7aeb5a29ca8ef10bd80a27e15b4565fe687" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;ilogb(20)&lt;/code&gt; is 4, as an integer.</source>
          <target state="translated">예를 들어 &lt;code&gt;ilogb(20)&lt;/code&gt; 는 정수로 4입니다.</target>
        </trans-unit>
        <trans-unit id="214bce966a0b82f5da24e7d2944d4f30b962d2dd" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;logb(20)&lt;/code&gt; is 4, as a floating point number.</source>
          <target state="translated">예를 들어 &lt;code&gt;logb(20)&lt;/code&gt; 은 부동 소수점 숫자로 4입니다.</target>
        </trans-unit>
        <trans-unit id="ba3539c7ce6418ebe27c9aacef03ad1ef9e8f077" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;gdbm_file&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;gdbm_file&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER 연결 해시는 다음과 같이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="b1b87712e77039600d0bb5eadd729b52754dd4ad" translate="yes" xml:space="preserve">
          <source>For example a &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER tied hash will die with something like:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/GDBM_File&quot;&gt;GDBM_File&lt;/a&gt; GDBM_READER 연결 해시는 다음과 같이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="318807e1faa6370da68f94b91a578d4d9a1a925f" translate="yes" xml:space="preserve">
          <source>For example a template of &lt;code&gt;testXXXXXX&lt;/code&gt; and suffix of &lt;code&gt;.dat&lt;/code&gt; would generate a file similar to</source>
          <target state="translated">예를 들어 &lt;code&gt;testXXXXXX&lt;/code&gt; 의 템플릿 과 &lt;code&gt;.dat&lt;/code&gt; 의 접미사는 다음 과 유사한 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="74bb45479d65e581a981105236dd80b5a848028d" translate="yes" xml:space="preserve">
          <source>For example a template of C</source>
          <target state="translated">예를 들어 C의 템플릿</target>
        </trans-unit>
        <trans-unit id="cdc25bb52677c33d7412ae881f68406f010eba12" translate="yes" xml:space="preserve">
          <source>For example after the following program:</source>
          <target state="translated">예를 들어 다음 프로그램 이후 :</target>
        </trans-unit>
        <trans-unit id="22c45cfbac1c695f1bfa7c0643b1ffc692ad7e5a" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt; .</source>
          <target state="translated">예를 들어 &lt;code&gt;=head1&lt;/code&gt; 이전에 POD 파일에 &lt;code&gt;=head2&lt;/code&gt; 가있는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="6de621c77744b42e19d169bcbfad2ade8e3c01f0" translate="yes" xml:space="preserve">
          <source>For example if there is a &lt;code&gt;=head2&lt;/code&gt; in the POD file prior to a &lt;code&gt;=head1&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;=head1&lt;/code&gt; 이전에 POD 파일에 &lt;code&gt;=head2&lt;/code&gt; 가있는 경우 .</target>
        </trans-unit>
        <trans-unit id="0c9f1ca436392d899e51a2acc5e1317d1e2a72ba" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fethanschoonover.com%2fsolarized&quot;&gt;Solarized&lt;/a&gt; 색상은 다음을 사용하여 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5022ccbe5240d64fbbb13f709a591ad35027c5e" translate="yes" xml:space="preserve">
          <source>For example the &lt;a href=&quot;https://ethanschoonover.com/solarized&quot;&gt;Solarized&lt;/a&gt; colors can be mapped with:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://ethanschoonover.com/solarized&quot;&gt;Solarized&lt;/a&gt; 색상은 다음과 같이 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313b954d842d0bc62b1462fc60b81d6d65b41bbd" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt; , and &lt;code&gt;Latin Extended-B&lt;/code&gt; . On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">예를 들어 Latin &lt;b&gt;스크립트&lt;/b&gt; 는 &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt; , &lt;code&gt;Latin Extended-A&lt;/code&gt; 및 &lt;code&gt;Latin Extended-B&lt;/code&gt; 와 같은 여러 &lt;b&gt;블록에&lt;/b&gt; 분산되어 있습니다 . 반면, 라틴 스크립트에는 &lt;code&gt;Basic Latin&lt;/code&gt; 블록 의 모든 문자 (ASCII라고도 함)가 포함되어 있지 않습니다. 숫자 나 문장 부호와 같은 문자 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="44972a585eb47fd3c1cfd9cd70932eb7157d7010" translate="yes" xml:space="preserve">
          <source>For example the Latin &lt;b&gt;script&lt;/b&gt; is spread over several &lt;b&gt;blocks&lt;/b&gt;, such as &lt;code&gt;Basic Latin&lt;/code&gt;, &lt;code&gt;Latin 1 Supplement&lt;/code&gt;, &lt;code&gt;Latin Extended-A&lt;/code&gt;, and &lt;code&gt;Latin Extended-B&lt;/code&gt;. On the other hand, the Latin script does not contain all the characters of the &lt;code&gt;Basic Latin&lt;/code&gt; block (also known as ASCII): it includes only the letters, and not, for example, the digits nor the punctuation.</source>
          <target state="translated">예를 들어 라틴 &lt;b&gt;스크립트&lt;/b&gt; 는 &lt;code&gt;Basic Latin&lt;/code&gt; , &lt;code&gt;Latin 1 Supplement&lt;/code&gt; , &lt;code&gt;Latin Extended-A&lt;/code&gt; 및 &lt;code&gt;Latin Extended-B&lt;/code&gt; 와 같은 여러 &lt;b&gt;블록에&lt;/b&gt; 걸쳐 있습니다 . 반면 라틴 스크립트에는 &lt;code&gt;Basic Latin&lt;/code&gt; 블록 (ASCII라고도 함) 의 모든 문자가 포함되어 있지 않습니다 . 예를 들어 숫자 나 구두점이 아닌 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="82ef4144af1f8de5f1e9ae8b466d94344115ab2d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; excludes items listed in &lt;code&gt;no_index&lt;/code&gt; when searching for POD, meaning files in these directories will not converted to HTML and made public - which is useful if you have example or test PODs that you don't want the search engine to go through.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; 는 POD를 검색 할 때 &lt;code&gt;no_index&lt;/code&gt; 에 나열된 항목을 제외합니다 . 즉, 이러한 디렉토리의 파일은 HTML로 변환되지 않고 공개되지 않습니다. 예를 들어 POD를 테스트하거나 POD를 테스트하는 경우 유용합니다. 검색 엔진이 통과하는 것을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6812d6ccb69fe61a2edf14ef55d513765cc75692" translate="yes" xml:space="preserve">
          <source>For example, &lt;b&gt;-COE&lt;/b&gt; and &lt;b&gt;-C6&lt;/b&gt; will both turn on UTF-8-ness on both STDOUT and STDERR. Repeating letters is just redundant, not cumulative nor toggling.</source>
          <target state="translated">예를 들어, &lt;b&gt;-COE&lt;/b&gt; 및 &lt;b&gt;-C6&lt;/b&gt; 것 STDOUT 및 STDERR 모두 UTF-8 호에 두 차례. 반복되는 문자는 중복되거나 토글되지 않고 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="e66983239615f4463efa1593676357175c070f41" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;-2&quot;..&quot;2&quot;&lt;/code&gt; is the same as &lt;code&gt;-2..2&lt;/code&gt;, and &lt;code&gt;&quot;2.18&quot;..&quot;3.14&quot;&lt;/code&gt; produces &lt;code&gt;2, 3&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&quot;-2&quot;..&quot;2&quot;&lt;/code&gt; 는 &lt;code&gt;-2..2&lt;/code&gt; 와 같고 &lt;code&gt;&quot;2.18&quot;..&quot;3.14&quot;&lt;/code&gt; 는 &lt;code&gt;2, 3&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5fe6d9c5c68e102fdd57d245db85bb6c1c51a595" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;01&quot;..&quot;04&quot;&lt;/code&gt; produces &lt;code&gt;&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;&lt;/code&gt;, and &lt;code&gt;&quot;00&quot;..&quot;-1&quot;&lt;/code&gt; produces &lt;code&gt;&quot;00&quot;&lt;/code&gt; through &lt;code&gt;&quot;99&quot;&lt;/code&gt; - this may seem surprising, but see the following rules for why it works this way. To get dates with leading zeros, you can say:</source>
          <target state="translated">예를 들어, &lt;code&gt;&quot;01&quot;..&quot;04&quot;&lt;/code&gt; 생성 &lt;code&gt;&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;00&quot;..&quot;-1&quot;&lt;/code&gt; 생성 &lt;code&gt;&quot;00&quot;&lt;/code&gt; 을 통해를 &lt;code&gt;&quot;99&quot;&lt;/code&gt; -이 보일 수도 놀랍지 만 왜 이런 식으로 작동하는지에 대한 다음 규칙을 참조하십시오. 앞에 0이있는 날짜를 얻으려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b2d2aa7ae22fcbe14979eb61870192c4dd7f04" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;a&quot;..&quot;--&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;a&quot;..&quot;zz&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;..&quot;xx&quot;&lt;/code&gt; produces &lt;code&gt;&quot;0&quot;&lt;/code&gt; through &lt;code&gt;&quot;99&quot;&lt;/code&gt;, and &lt;code&gt;&quot;aaa&quot;..&quot;--&quot;&lt;/code&gt; returns the empty list.</source>
          <target state="translated">예를 들어, &lt;code&gt;&quot;a&quot;..&quot;--&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;a&quot;..&quot;zz&quot;&lt;/code&gt; 와 같고 , &lt;code&gt;&quot;0&quot;..&quot;xx&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 에서 &lt;code&gt;&quot;99&quot;&lt;/code&gt; 까지, &lt;code&gt;&quot;aaa&quot;..&quot;--&quot;&lt;/code&gt; 는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd2c9b68575feddafd5a08ad5dafea23856e19ad" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&quot;ax&quot;..&quot;az&quot;&lt;/code&gt; produces &lt;code&gt;&quot;ax&quot;, &quot;ay&quot;, &quot;az&quot;&lt;/code&gt;, but &lt;code&gt;&quot;*x&quot;..&quot;az&quot;&lt;/code&gt; produces only &lt;code&gt;&quot;*x&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;&quot;ax&quot;..&quot;az&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;ax&quot;, &quot;ay&quot;, &quot;az&quot;&lt;/code&gt; 를 생성하지만 &lt;code&gt;&quot;*x&quot;..&quot;az&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;*x&quot;&lt;/code&gt; 만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="29e6ab6115ba236468a1784dbaded696c523a4aa" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;$+{foo}&lt;/code&gt; is equivalent to &lt;code&gt;$1&lt;/code&gt; after the following match:</source>
          <target state="translated">예를 들어, &lt;code&gt;$+{foo}&lt;/code&gt; 는 다음 일치 후 &lt;code&gt;$1&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="222cd952b129bcca43a9663919abeeb392a2e171" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; will work as expected (in that it will find something like '..\lib\File/DosGlob.pm' alright). Note that all path components are case-insensitive, and that backslashes and forward slashes are both accepted, and preserved. You may have to double the backslashes if you are putting them in literally, due to double-quotish parsing of the pattern by perl.</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;..\\l*b\\file/*glob.p?&amp;gt;&lt;/code&gt; 는 예상대로 작동합니다 ( '.. \ lib \ File / DosGlob.pm'과 같은 것을 찾을 수 있습니다). 모든 경로 구성 요소는 대소 문자를 구분하지 않으며 백 슬래시와 슬래시가 모두 허용 및 유지됩니다. 펄로 패턴을 큰 따옴표로 묶기 때문에 백 슬래시를 문자 그대로 넣으면 백 슬래시를 두 배로 늘려야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="062393ae2c2d73fa3bc2e3a2d91a68adfcd83483" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-oLaTeX&lt;/code&gt; currently tries all of the following classes: Pod::Perldoc::ToLaTeX Pod::Perldoc::Tolatex Pod::Perldoc::ToLatex Pod::Perldoc::ToLATEX Pod::Simple::LaTeX Pod::Simple::latex Pod::Simple::Latex Pod::Simple::LATEX Pod::LaTeX Pod::latex Pod::Latex Pod::LATEX.</source>
          <target state="translated">예를 들어 &lt;code&gt;-oLaTeX&lt;/code&gt; 는 현재 다음 클래스를 모두 시도합니다. Pod :: Perldoc :: ToLaTeX Pod :: Perldoc :: Tolatex Pod :: Perldoc :: ToLatex Pod :: Perldoc :: ToLATEX Pod :: Simple :: LaTeX Pod : : 단순 :: 라텍스 포드 :: 단순 :: 라텍스 포드 :: 단순 :: LATEX 포드 :: 라텍스 포드 :: 라텍스 포드 :: 라텍스 포드 :: LATEX.</target>
        </trans-unit>
        <trans-unit id="77a1e585a487cc3bfbbd51ad5e562a48a610c1cd" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; will turn on taint mode. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; will run &lt;code&gt;Devel::Cover&lt;/code&gt; for each test.</source>
          <target state="translated">예를 들어, &lt;code&gt;HARNESS_PERL_SWITCHES=-T&lt;/code&gt; 는 오염 모드를 켭니다. &lt;code&gt;HARNESS_PERL_SWITCHES=-MDevel::Cover&lt;/code&gt; 는 각 테스트마다 &lt;code&gt;Devel::Cover&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="86e52df63e27db421ca6b9e4dc513368b0a83476" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt; , so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; , so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">예를 들어 &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 는 사용 가능한 첫 번째 유니 코드 릴리스 인 &lt;code&gt;1.1&lt;/code&gt; 이므로이 속성은 모든 유효한 &quot;*&quot;버전에 적용됩니다. 반면, &lt;code&gt;U+1EFF&lt;/code&gt; 는 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 가 될 때 버전 5.1까지 할당되지 않았 으므로 일치하는 유일한 &quot;*&quot;는 5.1, 5.2 이상입니다.</target>
        </trans-unit>
        <trans-unit id="b293a722d09747451b766a52031476e1ba81af2d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;U+0041&lt;/code&gt;&lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; was present in the very first Unicode release available, which is &lt;code&gt;1.1&lt;/code&gt;, so this property is true for all valid &quot;*&quot; versions. On the other hand, &lt;code&gt;U+1EFF&lt;/code&gt; was not assigned until version 5.1 when it became &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt;, so the only &quot;*&quot; that would match it are 5.1, 5.2, and later.</source>
          <target state="translated">예를 들어, &lt;code&gt;U+0041&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER A&quot;&lt;/code&gt; 는 사용 가능한 최초의 유니 코드 릴리스 인 &lt;code&gt;1.1&lt;/code&gt; 에 존재 하므로이 속성은 모든 유효한 &quot;*&quot;버전에 대해 true입니다. 반면 &lt;code&gt;U+1EFF&lt;/code&gt; 는 &lt;code&gt;&quot;LATIN SMALL LETTER Y WITH LOOP&quot;&lt;/code&gt; 가되었을 때 버전 5.1까지 할당되지 않았 으므로 일치하는 &quot;*&quot;는 5.1, 5.2 이상입니다.</target>
        </trans-unit>
        <trans-unit id="346cf35fe7206ef61916e68c2ca5d063324557a7" translate="yes" xml:space="preserve">
          <source>For example, Foo::Bar becomes Foo-Bar.</source>
          <target state="translated">예를 들어 Foo :: Bar는 Foo-Bar가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cd802fd235063bdbe8cd10be2c1b9866e7e9d" translate="yes" xml:space="preserve">
          <source>For example, MyExpirePolicy::TIEHASH might create an object that contains a regular Perl hash (which it will to store the cached values) and some extra information about the arguments and how old the data is and things like that. Let us call this object `C'.</source>
          <target state="translated">예를 들어 MyExpirePolicy :: TIEHASH는 일반 Perl 해시 (캐시 된 값을 저장)와 인수에 대한 추가 정보 및 데이터의 수명 및 이와 유사한 사항을 포함하는 오브젝트를 작성할 수 있습니다. 이 객체를`C '라고하자.</target>
        </trans-unit>
        <trans-unit id="7e2c26a54a82719f79b06117790e2637ab0e300f" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt; .</source>
          <target state="translated">예를 들어, &lt;code&gt;Moose&lt;/code&gt; 클래스는 &lt;code&gt;with&lt;/code&gt; 를 사용하여 &lt;code&gt;Moo&lt;/code&gt; 역할을 &lt;code&gt;extends&lt;/code&gt; 하거나 사용하여 &lt;code&gt;Moo&lt;/code&gt; 클래스를 서브 클래스화할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1743f8be5bc24aa84fbb2597cf9ba3fce287be4" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;Moose&lt;/code&gt; class can subclass a &lt;code&gt;Moo&lt;/code&gt; class using &lt;code&gt;extends&lt;/code&gt; or consume a &lt;code&gt;Moo&lt;/code&gt; role using &lt;code&gt;with&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Moose&lt;/code&gt; 클래스는 &lt;code&gt;extends&lt;/code&gt; 를 사용하여 &lt;code&gt;Moo&lt;/code&gt; 클래스를 하위 클래스로 만들 거나 &lt;code&gt;with&lt;/code&gt; 를 사용하여 &lt;code&gt;Moo&lt;/code&gt; 역할을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="557d3fcd9902744d46a8cb542c3d28eade0c9716" translate="yes" xml:space="preserve">
          <source>For example, a directive consisting of this:</source>
          <target state="translated">예를 들어 다음으로 구성된 지시문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf2744eaf270dcbbff1985c2b73c221de5631d9d" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt; , sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">예를 들어, 유용한 진단 메시지를 나타내는 &lt;code&gt;like()&lt;/code&gt; 버전은 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54553804eb65ab331e5083c6d74eeb123e188def" translate="yes" xml:space="preserve">
          <source>For example, a version of &lt;code&gt;like()&lt;/code&gt;, sans the useful diagnostic messages, could be written as:</source>
          <target state="translated">예를 들어 유용한 진단 메시지 가없는 &lt;code&gt;like()&lt;/code&gt; 버전은 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4218fb9c51483864cd6b3fb02448d68465452ff" translate="yes" xml:space="preserve">
          <source>For example, an XSUB</source>
          <target state="translated">예를 들어 XSUB</target>
        </trans-unit>
        <trans-unit id="cce56f257ff2d1a6e195376cb7b5f349fe5b4b57" translate="yes" xml:space="preserve">
          <source>For example, as of Oct 31, 2009, the CPAN index file contained these module-distribution mappings:</source>
          <target state="translated">예를 들어 2009 년 10 월 31 일 현재 CPAN 색인 파일에는 다음과 같은 모듈 배포 매핑이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7132575485b1cfbea0394c9ac448d0a435204db7" translate="yes" xml:space="preserve">
          <source>For example, both options given below are equivalent to setting &lt;code&gt;ReuseAddr&lt;/code&gt;.</source>
          <target state="translated">예를 들어 아래에 제공된 두 옵션은 &lt;code&gt;ReuseAddr&lt;/code&gt; 설정과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d908226f910991ef51ebc57880107e99b08586dc" translate="yes" xml:space="preserve">
          <source>For example, consider the code below:</source>
          <target state="translated">예를 들어 아래 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ec1791bd29717623df33288ef02efc342f0cf537" translate="yes" xml:space="preserve">
          <source>For example, consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that</source>
          <target state="translated">예를 들어 다음 시나리오를 고려하십시오. 타사 C 애플리케이션과 공유해야하는 DBM 데이터베이스가 있습니다. C 애플리케이션은 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8190f04d38d06a461e096583cfda36d375198e8e" translate="yes" xml:space="preserve">
          <source>For example, consider:</source>
          <target state="translated">예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="120867ef674bae56ea0364ba96f034264719d15f" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;dir&lt;/code&gt; of 'lib' and &lt;code&gt;prefix&lt;/code&gt; of 'lib', the return value is a hashref of the form:</source>
          <target state="translated">예를 들어 'lib'의 &lt;code&gt;dir&lt;/code&gt; 과 'lib'의 &lt;code&gt;prefix&lt;/code&gt; 가 주어지면 반환 값은 다음 형식의 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c1377b5d79a1a1b8f2eb1b799a03d844580027b4" translate="yes" xml:space="preserve">
          <source>For example, given the string:</source>
          <target state="translated">예를 들어 다음과 같은 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f7eb35077596ec97c395fa31a4c9dc65c12237" translate="yes" xml:space="preserve">
          <source>For example, here all the areas that are taken literally are underlined with a &quot;^&quot;, and all the in-bracket special regions are underlined with an X:</source>
          <target state="translated">예를 들어, 여기에 문자 그대로 취해진 모든 영역에는 &quot;^&quot;가 밑줄로 표시되고 모든 브래킷 특수 영역에는 X가 밑줄로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="282f0060364377e323c90656e8982dd19487e634" translate="yes" xml:space="preserve">
          <source>For example, here is a loop that inserts index producing entries before any line containing a certain pattern:</source>
          <target state="translated">예를 들어, 다음은 특정 패턴을 포함하는 행 앞에 색인 생성 항목을 삽입하는 루프입니다.</target>
        </trans-unit>
        <trans-unit id="c309481bf35b9a661995259865d469413fa7c131" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; statement (until the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">예를 들어, BANG.pm이라는 모듈의 최소 소스 코드 필터는 다음과 같습니다. 단순히 시퀀스의 모든 발생을 변환 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 시퀀스에 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt; 'BANG' if $BANG&lt;/code&gt; 후속 코드의 어느 부분에 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG;&lt;/code&gt; 진술 (다음에 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; &lt;a href=&quot;../functions/no&quot;&gt;없을&lt;/a&gt; 때까지 ; 진술이있는 경우) :</target>
        </trans-unit>
        <trans-unit id="1a7d21d7fdba8993fa8f320558eb8943554fa8e9" translate="yes" xml:space="preserve">
          <source>For example, here is a minimal source code filter in a module named BANG.pm. It simply converts every occurrence of the sequence &lt;code&gt;BANG\s+BANG&lt;/code&gt; to the sequence &lt;code&gt;die 'BANG' if $BANG&lt;/code&gt; in any piece of code following a &lt;code&gt;use BANG;&lt;/code&gt; statement (until the next &lt;code&gt;no BANG;&lt;/code&gt; statement, if any):</source>
          <target state="translated">예를 들어, 다음은 BANG.pm이라는 모듈의 최소 소스 코드 필터입니다. &lt;code&gt;use BANG;&lt;/code&gt; 다음에 오는 코드에서 &lt;code&gt;die 'BANG' if $BANG&lt;/code&gt; 시퀀스 &lt;code&gt;BANG\s+BANG&lt;/code&gt; 모든 발생을 시퀀스 다이 'BANG'으로 변환합니다 . 성명서 (다음에 &lt;code&gt;no BANG;&lt;/code&gt; 때까지 ; 성명서 (있는 경우)) :</target>
        </trans-unit>
        <trans-unit id="deab4a0dbceae95053981957ee52dc40c226b6c1" translate="yes" xml:space="preserve">
          <source>For example, here is a sample filter that adds a trailing NULL character to all strings before they are written to the DBM file, and removes the trailing NULL when they are read from the DBM file</source>
          <target state="translated">예를 들어, 다음은 DBM 파일에 쓰기 전에 모든 문자열에 후행 NULL 문자를 추가하고 DBM 파일에서 읽을 때 후행 NULL을 제거하는 샘플 필터입니다.</target>
        </trans-unit>
        <trans-unit id="2ff6a04c682bedfc2159947b94ad35c5e1653401" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$a&lt;/code&gt; is an object blessed into a package declaring</source>
          <target state="translated">예를 들어 &lt;code&gt;$a&lt;/code&gt; 가 패키지 선언에 축복 된 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="e47691ce5bbf77ccdd2c65322eb9ae19daa34236" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; , and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; , then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt; .</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 로부터 상속 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; (순차), &lt;code&gt;B&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 의해 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; 다음 루틴 &lt;code&gt;D::plus_sub&lt;/code&gt; 동작을 구현하기 위해 호출 될 &lt;code&gt;+&lt;/code&gt; 를 위한 패키지의 개체 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ff3217e3f10be1d713ebcee2d82c19ffe203ca1" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; (in that order), &lt;code&gt;B&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; with &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; overloads &lt;code&gt;+&lt;/code&gt; by &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt;, then the subroutine &lt;code&gt;D::plus_sub&lt;/code&gt; will be called to implement operation &lt;code&gt;+&lt;/code&gt; for an object in package &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 로부터 상속 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; (순차), &lt;code&gt;B&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;\&amp;amp;D::plus_sub&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 의 과부하 &lt;code&gt;+&lt;/code&gt; 의해 &lt;code&gt;&quot;plus_meth&quot;&lt;/code&gt; 다음 루틴 &lt;code&gt;D::plus_sub&lt;/code&gt; 동작을 구현하기 위해 호출 될 &lt;code&gt;+&lt;/code&gt; 를 위한 패키지 &lt;code&gt;A&lt;/code&gt; 의 개체 .</target>
        </trans-unit>
        <trans-unit id="fdb8e022d3a14d860cf1eee66a67b7f130110122" translate="yes" xml:space="preserve">
          <source>For example, if a user accepts only 'ca' (Catalan) and 'es' (Spanish), and the documents/interfaces you have available are just in German, Italian, and Chinese, then the user will most likely want the Italian one (and not the Chinese or German one!), instead of getting nothing. So &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; returns a list containing 'it' (Italian).</source>
          <target state="translated">예를 들어 사용자가 'ca'(카탈로니아 어) 및 'es'(스페인어) 만 허용하고 사용 가능한 문서 / 인터페이스가 독일어, 이탈리아어 및 중국어로되어있는 경우 사용자는 이탈리아어를 원할 것입니다. (중국이나 독일은 아닙니다!) 대신 아무것도 얻지 못합니다. 따라서 &lt;code&gt;panic_languages('ca', 'es')&lt;/code&gt; 는 'it'(이탈리아어)가 포함 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd033dcdd253bc51f444e9213dde5da48cee293c" translate="yes" xml:space="preserve">
          <source>For example, if all the characters in the sequence are Greek, or Common, or Inherited, this function will return TRUE, provided any decimal digits in it are from the same block of digits in Common. (These are the ASCII digits &quot;0&quot;..&quot;9&quot; and additionally a block for full width forms of these, and several others used in mathematical notation.) For scripts (unlike Greek) that have their own digits defined this will accept either digits from that set or from one of the Common digit sets, but not a combination of the two. Some scripts, such as Arabic, have more than one set of digits. All digits must come from the same set for this function to return TRUE.</source>
          <target state="translated">예를 들어 시퀀스의 모든 문자가 그리스어, 공통 또는 상속 된 경우이 함수는 공통의 동일한 자릿수 블록에서 온 10 진수 인 경우 TRUE를 반환합니다. (이는 ASCII 숫자 &quot;0&quot;.. &quot;9&quot;이며 추가로 전체 너비 형식에 대한 블록 및 수학 표기법에 사용되는 여러 다른 블록입니다.) 자체 숫자가 정의 된 스크립트 (그리스어와 달리)의 경우 다음 중 하나를 허용합니다. 해당 세트 또는 공통 숫자 세트 중 하나의 숫자이지만 둘의 조합은 아닙니다. 아랍어와 같은 일부 스크립트에는 둘 이상의 숫자 세트가 있습니다. 이 함수가 TRUE를 반환하려면 모든 숫자가 동일한 집합에서 나와야합니다.</target>
        </trans-unit>
        <trans-unit id="36b2730284efb7215764ff65ce5779181405a788" translate="yes" xml:space="preserve">
          <source>For example, if both input and out are chosen to be &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR will also have &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; set. On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt;, a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt;.</source>
          <target state="translated">예를 들어 입력과 출력이 모두 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 으로 선택되면 &lt;code&gt;:std&lt;/code&gt; 는 STDIN, STDOUT 및 STDERR도 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 설정 됨을 의미합니다 . 반면에 출력 만 &lt;code&gt;:encoding(koi8r)&lt;/code&gt; 에 선택되면 &lt;code&gt;:std&lt;/code&gt; 는 STDOUT 및 STDERR 만 &lt;code&gt;koi8r&lt;/code&gt; 에있게 합니다.</target>
        </trans-unit>
        <trans-unit id="886940312d9491ca5ffc8d712e7908d39622ad09" translate="yes" xml:space="preserve">
          <source>For example, if no tests have run &lt;code&gt;is_passing()&lt;/code&gt; will be true because even though a suite with no tests is a failure you can add a passing test to it and start passing.</source>
          <target state="translated">예를 들어, 실행 된 테스트가없는 경우 &lt;code&gt;is_passing()&lt;/code&gt; 은 true입니다. 테스트가없는 스위트가 실패하더라도 통과 테스트를 추가하고 통과를 시작할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f350820f8a15ee234a6d0b5f40ef9ca061810978" translate="yes" xml:space="preserve">
          <source>For example, if the bug is present on &lt;code&gt;HEAD&lt;/code&gt; but wasn't in 5.10.0, &lt;code&gt;git&lt;/code&gt; will learn about this when you enter:</source>
          <target state="translated">예를 들어 버그가 &lt;code&gt;HEAD&lt;/code&gt; 에 있지만 5.10.0에는없는 경우 다음을 입력하면 &lt;code&gt;git&lt;/code&gt; 이 이에 대해 학습합니다.</target>
        </trans-unit>
        <trans-unit id="8759c901db12e35962f36dbb59c087c3f752959f" translate="yes" xml:space="preserve">
          <source>For example, if you add a Unicode string like</source>
          <target state="translated">예를 들어 다음과 같은 유니 코드 문자열을 추가하면</target>
        </trans-unit>
        <trans-unit id="32c9f1310448f772c98938afaa753d6c8ad8468a" translate="yes" xml:space="preserve">
          <source>For example, if you have 4 C functions multiply(), divide(), add(), subtract() all having the signature:</source>
          <target state="translated">예를 들어, 4 개의 C 함수 multiply (), divide (), add (), subtract ()가 모두 서명을 가진 경우 :</target>
        </trans-unit>
        <trans-unit id="4a173ebec9470f66747de7c5eefed0eb1d0d01a0" translate="yes" xml:space="preserve">
          <source>For example, if you have a uuencoded and compressed source file, it is possible to stack a uudecode filter and an uncompression filter like this:</source>
          <target state="translated">예를 들어, uuencoded 및 압축 소스 파일이있는 경우 다음과 같이 uudecode 필터와 압축 해제 필터를 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9372470a314912841e718aa7d95049e68d683c3" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msx on by default, simply put</source>
          <target state="translated">예를 들어, 모든 정규식에 기본적으로 / msx를 설정하려면 간단히</target>
        </trans-unit>
        <trans-unit id="743af917ca6acb088488514506f78e5a56610546" translate="yes" xml:space="preserve">
          <source>For example, if you want all your regular expressions to have /msxx on by default, simply put</source>
          <target state="translated">예를 들어 모든 정규식에 기본적으로 / msxx를 설정하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4909c84cf33294d068c280ab4acd84ce25b4c18c" translate="yes" xml:space="preserve">
          <source>For example, if you wanted a function to make a new hash and return a reference to it, you have these options:</source>
          <target state="translated">예를 들어, 새로운 해시를 만들고 참조를 반환하는 함수를 원한다면 다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c2555ae4677f2fae349053aea4869881467feea" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the &lt;code&gt;SvIVX&lt;/code&gt; slot, you can't just do &lt;code&gt;SvROK_off&lt;/code&gt;, as that will leak the referent.</source>
          <target state="translated">당신의 스칼라는 참조이며, 당신이 수정할 경우 예를 들어, &lt;code&gt;SvIVX&lt;/code&gt; 의 슬롯을, 당신은 할 수 없다 &lt;code&gt;SvROK_off&lt;/code&gt; 을 그 지시 대상을 누출로.</target>
        </trans-unit>
        <trans-unit id="a570ae33985ad610c93d2b21ee03162407502a4d" translate="yes" xml:space="preserve">
          <source>For example, if your scalar is a reference and you want to modify the SvIVX slot, you can't just do SvROK_off, as that will leak the referent.</source>
          <target state="translated">예를 들어 스칼라가 참조이고 SvIVX 슬롯을 수정하려는 경우 SvROK_off 만 수행 할 수 없습니다. 그러면 참조가 유출됩니다.</target>
        </trans-unit>
        <trans-unit id="85a3de5be37b1e7d1156f1cef62afbe6c76e2823" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has a reference count of one. Then you call &lt;code&gt;newRV_inc&lt;/code&gt; , passing it the just-created SV. This returns the reference as a new SV, but the reference count of the SV you passed to &lt;code&gt;newRV_inc&lt;/code&gt; has been incremented to two. Now you return the reference from the XSUB routine and forget about the SV. But Perl hasn't! Whenever the returned reference is destroyed, the reference count of the original SV is decreased to one and nothing happens. The SV will hang around without any way to access it until Perl itself terminates. This is a memory leak.</source>
          <target state="translated">예를 들어, XSUB 함수에서 참조를 리턴한다고 가정하십시오. XSUB 루틴 내에서 처음에는 참조 카운트가 1 인 SV를 만듭니다. 그런 다음 &lt;code&gt;newRV_inc&lt;/code&gt; 를 호출 하여 방금 만든 SV에 전달합니다. 참조를 새 SV로 반환하지만 &lt;code&gt;newRV_inc&lt;/code&gt; 에 전달한 SV의 참조 카운트 가 2로 증가했습니다. 이제 XSUB 루틴에서 참조를 반환하고 SV는 잊어 버립니다. 그러나 펄은 그렇지 않았습니다! 반환 된 레퍼런스가 파괴 될 때마다 원래 SV의 레퍼런스 카운트가 1로 줄어들고 아무 일도 일어나지 않습니다. SV는 Perl 자체가 종료 될 때까지 어떤 방법으로도 액세스 할 수 없습니다. 이것은 메모리 누수입니다.</target>
        </trans-unit>
        <trans-unit id="21d2cc6afcf04419580fbfc3f6b2421473912245" translate="yes" xml:space="preserve">
          <source>For example, imagine you want to return a reference from an XSUB function. Inside the XSUB routine, you create an SV which initially has just a single reference, owned by the XSUB routine. This reference needs to be disposed of before the routine is complete, otherwise it will leak, preventing the SV from ever being destroyed. So to create an RV referencing the SV, it is most convenient to pass the SV to &lt;code&gt;newRV_noinc()&lt;/code&gt;, which consumes that reference. Now the XSUB routine no longer owns a reference to the SV, but does own a reference to the RV, which in turn owns a reference to the SV. The ownership of the reference to the RV is then transferred by the process of returning the RV from the XSUB.</source>
          <target state="translated">예를 들어 XSUB 함수에서 참조를 반환한다고 가정합니다. XSUB 루틴 내에서 처음에는 XSUB 루틴이 소유 한 단일 참조 만있는 SV를 만듭니다. 이 참조는 루틴이 완료되기 전에 폐기되어야합니다. 그렇지 않으면 누출되어 SV가 파괴되는 것을 방지합니다. 따라서 SV를 참조하는 RV를 생성하려면 해당 참조를 사용하는 &lt;code&gt;newRV_noinc()&lt;/code&gt; SV를 전달하는 것이 가장 편리합니다 . 이제 XSUB 루틴은 더 이상 SV에 대한 참조를 소유하지 않지만 RV에 대한 참조를 소유하며, 차례로 SV에 대한 참조를 소유합니다. RV에 대한 참조의 소유권은 XSUB에서 RV를 반환하는 프로세스에 의해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb2e2ef894e1ed98060074d6b4776bf06e4d3ee" translate="yes" xml:space="preserve">
          <source>For example, intuition tells you that this XS code:</source>
          <target state="translated">예를 들어, 직감은이 XS 코드를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="74d92c0f78a3f35d2b66123bb54771dbbcbaaae8" translate="yes" xml:space="preserve">
          <source>For example, it might return these data (among others) for the difference between 5.008000 and 5.008001:</source>
          <target state="translated">예를 들어 5.008000과 5.008001의 차이에 대해 다음 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8932a840658bb617ebb44a7bc96b426c503bdff7" translate="yes" xml:space="preserve">
          <source>For example, let's say that you have a long-running database server daemon that you want folks to be able to access from the Web, but only if they go through a CGI interface. You'd have a small, simple CGI program that does whatever checks and logging you feel like, and then acts as a Unix-domain client and connects to your private server.</source>
          <target state="translated">예를 들어, 사람들이 CGI 인터페이스를 통과하는 경우에만 웹에서 액세스 할 수있는 장기 실행 데이터베이스 서버 데몬이 있다고 가정 해 봅시다. 확인 및 로깅을 수행하고 유닉스 도메인 클라이언트로 작동하고 개인 서버에 연결하는 작고 간단한 CGI 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ba35baedd2bab7b0f63f6847d21e1fa348e167" translate="yes" xml:space="preserve">
          <source>For example, let's say you'd like to have your</source>
          <target state="translated">예를 들어,</target>
        </trans-unit>
        <trans-unit id="194fc6778319983cc9c4ca8c95042faf96fb7b65" translate="yes" xml:space="preserve">
          <source>For example, let's take a GUI driven program. It has a semaphore that it uses to synchronize access to the display, so only one thread is ever drawing at once. Handy, but of course you don't want any thread to start drawing until things are properly set up. In this case, you can create a semaphore with a counter set to zero, and up it when things are ready for drawing.</source>
          <target state="translated">예를 들어, GUI 기반 프로그램을 보자. 디스플레이에 대한 액세스를 동기화하는 데 사용되는 세마포어가 있으므로 한 번에 하나의 스레드 만 그려집니다. 편리하지만, 물건이 제대로 설정 될 때까지 실을 그리기를 원하지 않습니다. 이 경우 카운터를 0으로 설정하여 세마포어를 만들 수 있으며 물건을 그릴 준비가되면 위로 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c15f9bd991e32fcb9fda0fc1d672dd96785374" translate="yes" xml:space="preserve">
          <source>For example, line 2 below is wrong because it does not have at least 2 spaces, but lines 1 and 3 are fine because they have at least 2:</source>
          <target state="translated">예를 들어 아래의 2 행은 공백이 2 개 이상 없기 때문에 잘못되었지만 1 행과 3 행은 2 개 이상이므로 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="b5cc0c799c8ac490a734bb661c428c57117107e1" translate="yes" xml:space="preserve">
          <source>For example, many newer useful APIs are not present in OS/2 v2; many PM-related APIs require DLLs not available on floppy-boot setup.</source>
          <target state="translated">예를 들어, OS / 2 v2에는 최신의 유용한 API가 많이 없습니다. 많은 PM 관련 API에는 플로피 부팅 설정에서 사용할 수없는 DLL이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc5f27a11595298226b5ecd1db6f9aeef4a5b4ec" translate="yes" xml:space="preserve">
          <source>For example, on Unix this would escape any single-quotes in $text and put single-quotes around the whole thing.</source>
          <target state="translated">예를 들어, 유닉스에서 이것은 $ text에서 작은 따옴표를 이스케이프 처리하고 모든 것을 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="609e914fb8a944506b94ed39a0575be3c2f1f46e" translate="yes" xml:space="preserve">
          <source>For example, on a poorly equipped computer,</source>
          <target state="translated">예를 들어, 제대로 장착되지 않은 컴퓨터에서</target>
        </trans-unit>
        <trans-unit id="e6ea05a8d9aa3d31bd0e3e1d1aa6044dba6a83b8" translate="yes" xml:space="preserve">
          <source>For example, parsing a L&amp;lt;Foo/&quot;Bar&quot;&amp;gt; link will produce a start-token with a &quot;to&quot; attribute with the value &quot;Foo&quot;, a &quot;type&quot; attribute with the value &quot;pod&quot;, and a &quot;section&quot; attribute with the value &quot;Bar&quot;.</source>
          <target state="translated">예를 들어, L &amp;lt;Foo / &quot;Bar&quot;&amp;gt; 링크를 구문 분석하면 값이 &quot;Foo&quot;인 &quot;to&quot;속성, 값이 &quot;pod&quot;인 &quot;type&quot;속성 및 &quot;section&quot;이있는 시작 토큰이 생성됩니다. 값이 &quot;Bar&quot;인 속성.</target>
        </trans-unit>
        <trans-unit id="7ea4a776edac8c6f6bfd35b979f9a6514e0b64fe" translate="yes" xml:space="preserve">
          <source>For example, parsing this paragraph of Pod:</source>
          <target state="translated">예를 들어 Pod의이 단락을 파싱합니다.</target>
        </trans-unit>
        <trans-unit id="4d8ed73a29aeabbe37200513a23647bf9812ba11" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">예를 들어 오버로드 된 수학 연산자를 구현하는 클래스를 작성해야하고 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 과 매우 유사한 기능을하는 고유 한 pragma를 제공한다고 가정하십시오 . 이 코드를 원합니다</target>
        </trans-unit>
        <trans-unit id="6daf57bf99f1fc518b402ca174d25b0d54e1f1c0" translate="yes" xml:space="preserve">
          <source>For example, say you need to create a class implementing overloaded mathematical operators, and would like to provide your own pragma that functions much like &lt;code&gt;use integer;&lt;/code&gt; You'd like this code</source>
          <target state="translated">예를 들어, 오버로드 된 수학 연산자를 구현하는 클래스를 만들어야하고 &lt;code&gt;use integer;&lt;/code&gt; 과 매우 유사한 기능을하는 고유 한 pragma를 제공하고 싶다고 가정 해 보겠습니다 . 이 코드를 원합니다.</target>
        </trans-unit>
        <trans-unit id="7fbbe0aa9845cec520a90786e8524e8299625199" translate="yes" xml:space="preserve">
          <source>For example, setting prefix_pattern to &lt;code&gt;--|-|\+|\/&lt;/code&gt; and long_prefix_pattern to &lt;code&gt;--|\/&lt;/code&gt; would add Win32 style argument handling.</source>
          <target state="translated">예를 들어 prefix_pattern을 &lt;code&gt;--|-|\+|\/&lt;/code&gt; 하고 long_prefix_pattern을 &lt;code&gt;--|\/&lt;/code&gt; 하면 Win32 스타일 인수 처리가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="83cdc2b87550c2073421ee9d7b2b562b30e21210" translate="yes" xml:space="preserve">
          <source>For example, suppose that a C function is declared as</source>
          <target state="translated">예를 들어, C 함수가 다음과 같이 선언되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3032721d2a0b9447ee105fd0f58af3c782c7c78e" translate="yes" xml:space="preserve">
          <source>For example, suppose that you have a module, A, which already has an import function:</source>
          <target state="translated">예를 들어, 이미 가져 오기 기능이있는 모듈 A가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="5d59fda06c904abab606e40ac19199fab2edd4c9" translate="yes" xml:space="preserve">
          <source>For example, suppose the start tag &quot;/para&quot; introduces a paragraph, which then continues until the next &quot;/endpara&quot; tag or until another &quot;/para&quot; tag is encountered:</source>
          <target state="translated">예를 들어 시작 태그 &quot;/ para&quot;에 단락이 도입되었다고 가정하면 다음 &quot;/ endpara&quot;태그까지 또는 다른 &quot;/ para&quot;태그가 나타날 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="722e9b7fb9ae1447f9773a346a88fa54f1637a70" translate="yes" xml:space="preserve">
          <source>For example, suppose under the previous example, the memory footprints were</source>
          <target state="translated">예를 들어, 이전 예에서 메모리 공간이</target>
        </trans-unit>
        <trans-unit id="05d893596622d4a80e535a21a12a1aee563b93bd" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a document that starts out:</source>
          <target state="translated">예를 들어, 시작하는 문서가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="bffbbe302261255488cedcaf66d413bfbf36c6ca" translate="yes" xml:space="preserve">
          <source>For example, the</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="15b6b18c244e053f8f3ff342944215804ef30809" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;redundant&lt;/code&gt; category of warnings was introduced in Perl-5.22. This warning flags certain instances of superfluous arguments to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;sprintf&lt;/code&gt;. But if your code was running warnings-free on earlier versions of</source>
          <target state="translated">예를 들어, 경고 의 &lt;code&gt;redundant&lt;/code&gt; 범주는 Perl-5.22에서 도입되었습니다. 이 경고는 &lt;code&gt;printf&lt;/code&gt; 및 &lt;code&gt;sprintf&lt;/code&gt; 에 대한 불필요한 인수의 특정 인스턴스에 플래그를 지정 합니다. 그러나 코드가 이전 버전에서 경고없이 실행 되었다면</target>
        </trans-unit>
        <trans-unit id="f5d6ac4af7dc4fb8891b91e976475ba9ad84c4ec" translate="yes" xml:space="preserve">
          <source>For example, the basic Perl does not have any of the DB libraries (db, dbm, ndbm, gdsm). You can add these using iPKGui, however, you need to set environment variable LD_LIBRARY_PATH to the appropriate value:</source>
          <target state="translated">예를 들어, 기본 Perl에는 DB 라이브러리 (db, dbm, ndbm, gdsm)가 없습니다. iPKGui를 사용하여 추가 할 수 있지만 환경 변수 LD_LIBRARY_PATH를 적절한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d69b1ef2c6e689b8d2716ba15838bfbcaba3b14" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;TO_JSON&lt;/code&gt; method will convert all &lt;a href=&quot;uri&quot;&gt;URI&lt;/a&gt; objects to JSON strings when serialised. The fact that these values originally were &lt;a href=&quot;uri&quot;&gt;URI&lt;/a&gt; objects is lost.</source>
          <target state="translated">예를 들어 다음 &lt;code&gt;TO_JSON&lt;/code&gt; 메서드는 직렬화 될 때 모든 &lt;a href=&quot;uri&quot;&gt;URI&lt;/a&gt; 개체를 JSON 문자열 로 변환합니다 . 이러한 값이 원래 &lt;a href=&quot;uri&quot;&gt;URI&lt;/a&gt; 개체 라는 사실 은 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="52828c35e04550c449cacfba26c2cecd5cb47850" translate="yes" xml:space="preserve">
          <source>For example, the following code maintains a private counter, incremented each time the gimme_another() function is called:</source>
          <target state="translated">예를 들어 다음 코드는 gimme_another () 함수가 호출 될 때마다 증가하는 개인 카운터를 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0efd5077b028dc94a3c2fa546515dce13ec61" translate="yes" xml:space="preserve">
          <source>For example, the following computes the same number as the System V sum program:</source>
          <target state="translated">예를 들어, 다음은 System V sum 프로그램과 동일한 숫자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="312666aef465c3fff18fcf5fe469393b97e6fd3d" translate="yes" xml:space="preserve">
          <source>For example, the following determines whether the interpreter is in global destruction:</source>
          <target state="translated">예를 들어, 다음은 인터프리터가 전역 파괴 상태인지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="19d3a9f832bfede9ec03750347c230d365e34605" translate="yes" xml:space="preserve">
          <source>For example, the following extracts substrings that are valid Perl variables:</source>
          <target state="translated">예를 들어, 다음은 유효한 Perl 변수 인 하위 문자열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f07ff2eac86996a294f8c340a4f99d7c05265d15" translate="yes" xml:space="preserve">
          <source>For example, the following filter detects concatenated pairs of strings/quotelikes and reverses the order in which they are concatenated:</source>
          <target state="translated">예를 들어, 다음 필터는 연결된 문자열 / quotelike 쌍을 감지하고 연결된 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="20cac958ebe1f19afdb2a4ff648a2eabdded8f61" translate="yes" xml:space="preserve">
          <source>For example, the following relations hold:</source>
          <target state="translated">예를 들어 다음 관계가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c2a812e2e3e862d2489a82a90a6fe426ea8bc" translate="yes" xml:space="preserve">
          <source>For example, the following will do the trick:</source>
          <target state="translated">예를 들어 다음은 트릭을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f63138afdd9a0a71216e6347fa743354dbc2c04b" translate="yes" xml:space="preserve">
          <source>For example, the following would cause &lt;a href=&quot;Thread::Queue&quot;&gt;Thread::Queue&lt;/a&gt; to create a empty, shared array reference via &lt;code&gt;&amp;amp;shared([])&lt;/code&gt;, copy the elements 'foo', 'bar' and 'baz' from &lt;code&gt;@ary&lt;/code&gt; into it, and then place that shared reference onto the queue:</source>
          <target state="translated">예를 들어, 다음은 &lt;a href=&quot;Thread::Queue&quot;&gt;Thread :: Queue&lt;/a&gt; 가 &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; 를 통해 빈 공유 배열 참조를 &lt;code&gt;@ary&lt;/code&gt; 에서 'foo', 'bar'및 'baz'요소를 복사 한 다음 배치합니다. 큐에 대한 공유 참조 :</target>
        </trans-unit>
        <trans-unit id="e39332b0891fe5b116748687d101665a0ac3bf59" translate="yes" xml:space="preserve">
          <source>For example, the following would cause &lt;a href=&quot;queue&quot;&gt;Thread::Queue&lt;/a&gt; to create a empty, shared array reference via &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; , copy the elements 'foo', 'bar' and 'baz' from &lt;code&gt;@ary&lt;/code&gt; into it, and then place that shared reference onto the queue:</source>
          <target state="translated">예를 들어, 다음은 &lt;a href=&quot;queue&quot;&gt;Thread :: Queue&lt;/a&gt; 가 &lt;code&gt;&amp;amp;shared([])&lt;/code&gt; 를 통해 빈 공유 배열 참조를 작성하고 &lt;code&gt;@ary&lt;/code&gt; 에서 'foo', 'bar'및 'baz'요소를 복사하는 원인이됩니다. 한 다음 배치합니다. 큐에 대한 공유 참조 :</target>
        </trans-unit>
        <trans-unit id="b374940ca0db0d2f4bb2b6f65a2a95e7ad343e48" translate="yes" xml:space="preserve">
          <source>For example, the hypothetical &lt;code&gt;My::Object&lt;/code&gt;&lt;code&gt;FREEZE&lt;/code&gt; method might use the objects &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; members to encode the object:</source>
          <target state="translated">예를 들어, 가상의 &lt;code&gt;My::Object&lt;/code&gt; &lt;code&gt;FREEZE&lt;/code&gt; 메서드는 개체 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 멤버를 사용하여 개체를 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74318882ba84561a544011d5b07567896cc6c6f2" translate="yes" xml:space="preserve">
          <source>For example, the template &lt;code&gt;x[L]&lt;/code&gt; skips as many bytes as in a packed long, and the template &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; unpacks twice whatever $t (when variable-expanded) unpacks. If the template in brackets contains alignment commands (such as &lt;code&gt;x![d]&lt;/code&gt; ), its packed length is calculated as if the start of the template had the maximal possible alignment.</source>
          <target state="translated">예를 들어, 템플릿 &lt;code&gt;x[L]&lt;/code&gt; 은 압축 된 길이만큼 바이트를 건너 뛰고 &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; 템플릿은 $ t (변수 확장시)의 압축이 풀릴 때마다 두 번 압축을 풉니 다. 대괄호 안의 템플릿에 정렬 명령 (예 : &lt;code&gt;x![d]&lt;/code&gt; )이 포함되어 있으면 템플릿 시작 부분에 가능한 최대 정렬이있는 것처럼 압축 길이가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad7d3321639bfd6129622f7b3e2fafa5dfc8f43" translate="yes" xml:space="preserve">
          <source>For example, the template &lt;code&gt;x[L]&lt;/code&gt; skips as many bytes as in a packed long, and the template &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; unpacks twice whatever $t (when variable-expanded) unpacks. If the template in brackets contains alignment commands (such as &lt;code&gt;x![d]&lt;/code&gt;), its packed length is calculated as if the start of the template had the maximal possible alignment.</source>
          <target state="translated">예를 들어, 템플릿 &lt;code&gt;x[L]&lt;/code&gt; 은 패킹 된 길이만큼의 바이트를 건너 뛰고 템플릿 &lt;code&gt;&quot;$t X[$t] $t&quot;&lt;/code&gt; $ t (변수 확장시)의 압축을 풀 때마다 두 번 압축을 풉니 다. 괄호 안의 템플릿에 정렬 명령 (예 : &lt;code&gt;x![d]&lt;/code&gt; )이 포함 된 경우 압축 된 길이는 템플릿의 시작에 가능한 최대 정렬이있는 것처럼 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7b531e77c163b8c2ffdb3ee7640976837b2cd8" translate="yes" xml:space="preserve">
          <source>For example, the two are equivalent:</source>
          <target state="translated">예를 들어, 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="37ab708b8a37671c040bc6173605339df847f5d8" translate="yes" xml:space="preserve">
          <source>For example, this</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="ffa32009eba3582341257eb08ec5bfc4995b6930" translate="yes" xml:space="preserve">
          <source>For example, this Pod source:</source>
          <target state="translated">예를 들어 다음 Pod 소스는 ​​다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6751e73c6b01b59d5dba968e1ce44f9db2bd48e6" translate="yes" xml:space="preserve">
          <source>For example, this Pod text:</source>
          <target state="translated">예를 들어이 포드 텍스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3defe2b1e9069ae388a99caeefdfba166f4eafb" translate="yes" xml:space="preserve">
          <source>For example, this program</source>
          <target state="translated">예를 들어이 프로그램</target>
        </trans-unit>
        <trans-unit id="6361c0f3a8383561486e71f9f602b08950af7cfb" translate="yes" xml:space="preserve">
          <source>For example, this program detects duplicate words, even when they span line breaks (but not paragraph ones). For this example, we don't need &lt;code&gt;/s&lt;/code&gt; because we aren't using dot in a regular expression that we want to cross line boundaries. Neither do we need &lt;code&gt;/m&lt;/code&gt; because we don't want caret or dollar to match at any point inside the record next to newlines. But it's imperative that $/ be set to something other than the default, or else we won't actually ever have a multiline record read in.</source>
          <target state="translated">예를 들어,이 프로그램은 줄 바꿈에 걸쳐 있지만 단락 단락이 아닌 경우에도 중복 단어를 감지합니다. 이 예제에서는 라인 경계를 넘길 정규 표현식에 도트를 사용하지 않기 때문에 &lt;code&gt;/s&lt;/code&gt; 가 필요하지 않습니다 . &lt;code&gt;/m&lt;/code&gt; 도 필요하지 않습니다캐럿이나 달러가 줄 바꿈 옆의 레코드 내부에서 일치하지 않기 때문에 하지 않습니다. 그러나 $ /를 기본값 이외의 것으로 설정해야합니다. 그렇지 않으면 실제로 여러 줄 레코드를 읽지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd82174af8f3a036da73ea77435fa503303e9e8" translate="yes" xml:space="preserve">
          <source>For example, this reports that the handle smells IOish (but please don't really do this!):</source>
          <target state="translated">예를 들어, 핸들이 IOish 냄새가 나는 것으로보고되지만 실제로는 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ef3a161073bd310ed2cbade0af56c0a0b5004f38" translate="yes" xml:space="preserve">
          <source>For example, this will print out $foo every time line 53 is passed:</source>
          <target state="translated">예를 들어, 53 행이 지날 때마다 $ foo를 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="37db6b23559a046a4f0ce04003e403434ab611a3" translate="yes" xml:space="preserve">
          <source>For example, to accept a new directive &quot;=method&quot;, you'd presumably use:</source>
          <target state="translated">예를 들어, 새 지시문 &quot;= method&quot;를 수락하려면 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9605a513ac289376aa334b379fb4d5b13b111824" translate="yes" xml:space="preserve">
          <source>For example, to cause the previous filter to filter only up to a line of the form:</source>
          <target state="translated">예를 들어, 이전 필터가 양식의 한 줄까지만 필터링하게하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="300d70e414e6ea43611e3ca2af00e9302dad6ae4" translate="yes" xml:space="preserve">
          <source>For example, to convert ASCII/Latin1 to code page 037 take the output of the second numbers column from the output of recipe 2 (modified to add &lt;code&gt;&quot;\&quot;&lt;/code&gt; characters), and use it in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; like so:</source>
          <target state="translated">예를 들어 ASCII / Latin1을 코드 페이지 037로 변환하려면 레시피 2 ( &lt;code&gt;&quot;\&quot;&lt;/code&gt; 문자 를 추가하도록 수정)의 출력에서 ​​두 번째 숫자 열의 출력을 가져 와서 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 에서 사용하십시오. .</target>
        </trans-unit>
        <trans-unit id="0d0bbbad4828d035dbc86fe1cd280346bc8f5d82" translate="yes" xml:space="preserve">
          <source>For example, to convert ASCII/Latin1 to code page 037 take the output of the second numbers column from the output of recipe 2 (modified to add &lt;code&gt;&quot;\&quot;&lt;/code&gt; characters), and use it in &lt;code&gt;tr///&lt;/code&gt; like so:</source>
          <target state="translated">예를 들어 ASCII / Latin1을 코드 페이지 037로 변환하려면 레시피 2의 출력 ( &lt;code&gt;&quot;\&quot;&lt;/code&gt; 문자 를 추가하도록 수정 됨)에서 두 번째 숫자 열의 출력을 가져 와서 &lt;code&gt;tr///&lt;/code&gt; 과 같이 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd7243dc5fc5fca757ae08f0881832e542544924" translate="yes" xml:space="preserve">
          <source>For example, to convert ISO-8859-1 data into a string in Perl's internal format:</source>
          <target state="translated">예를 들어 ISO-8859-1 데이터를 Perl의 내부 형식으로 된 문자열로 변환하려면 :</target>
        </trans-unit>
        <trans-unit id="a6cd7eef61c208f99d59f8caa4d148fd7c2f1727" translate="yes" xml:space="preserve">
          <source>For example, to convert a string from Perl's internal format into ISO-8859-1, also known as Latin1:</source>
          <target state="translated">예를 들어, 문자열을 Perl의 내부 형식에서 Latin1이라고도하는 ISO-8859-1로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e7afc76698552bd4261769a00bd251fb42909a" translate="yes" xml:space="preserve">
          <source>For example, to create a new Perl variable called &quot;dberror&quot; that contains both the numeric and descriptive string error values, you could use the following code:</source>
          <target state="translated">예를 들어 숫자 및 설명 문자열 오류 값을 모두 포함하는 &quot;dberror&quot;라는 새 Perl 변수를 작성하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d9b81a8771c07736a765b8d4696ec4b2677d0a" translate="yes" xml:space="preserve">
          <source>For example, to define a property that covers both the Japanese syllabaries (hiragana and katakana), you can define</source>
          <target state="translated">예를 들어, 일본어 음절 (히라가나 및 가타카나)을 모두 포함하는 속성을 정의하려면</target>
        </trans-unit>
        <trans-unit id="e2cb81580d4ab01621fb850e0ae4ed1624280f45" translate="yes" xml:space="preserve">
          <source>For example, to extract an HTML link (which should not contain nested links) use:</source>
          <target state="translated">예를 들어 HTML 링크 (내포 된 링크를 포함하지 않아야 함)를 추출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c87052aad8c5be2f19681e4d2c2a7fd4fe520629" translate="yes" xml:space="preserve">
          <source>For example, to extract an arbitrary XML tag, but ignore &quot;empty&quot; elements:</source>
          <target state="translated">예를 들어, 임의의 XML 태그를 추출하지만 &quot;빈&quot;요소는 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="9cc0a6697b30109ed6291482e3cc85911a7299a8" translate="yes" xml:space="preserve">
          <source>For example, to find out how many tests unexpectedly succeeded (TODO tests which passed when they shouldn't):</source>
          <target state="translated">예를 들어, 예기치 않게 성공한 테스트 수 (TODO 테스트는 실패했을 때 통과 한 테스트)를 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1cae119c444d0ffb7547a1a1d5509bf58d292d18" translate="yes" xml:space="preserve">
          <source>For example, to grab non-empty comments into $1, one should use either one of these:</source>
          <target state="translated">예를 들어, 비어 있지 않은 주석을 $ 1로 가져 오려면 다음 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f5822a45f1a22d6936b76b83b1a65e30286619c" translate="yes" xml:space="preserve">
          <source>For example, to grab non-empty comments into &lt;code&gt;$1&lt;/code&gt;, one should use either one of these:</source>
          <target state="translated">예를 들어 비어 있지 않은 주석을 &lt;code&gt;$1&lt;/code&gt; 로 가져 오려면 다음 중 하나를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c4d3c94000a25722026dce3134a2430f0552ee1" translate="yes" xml:space="preserve">
          <source>For example, to replace the aggregator I would</source>
          <target state="translated">예를 들어, 애그리 게이터를 교체하려면</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
