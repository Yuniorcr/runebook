<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 크거나 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">왼쪽 인수가 숫자보다 오른쪽 인수보다 작 으면 이진 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 이 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">이진수 &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; 는 오른쪽 인수로 지정된 비트 수만큼 왼쪽으로 시프트 된 왼쪽 인수의 값을 반환합니다. 인수는 정수 여야합니다. ( &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;정수 산술&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작거나 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">이항 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작은 지, 같은지 또는 큰지에 따라 -1, 0 또는 1을 반환합니다. 플랫폼 이 숫자가 아닌 &lt;code&gt;NaN&lt;/code&gt; 을 숫자 값으로 지원하는 경우 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 와 함께 사용하면 undef가 반환됩니다. &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 무엇이든 ( &lt;code&gt;NaN&lt;/code&gt; 조차도 ) 아니므로 5는 false를 반환합니다. &lt;code&gt;NaN != NaN&lt;/code&gt; 처럼 NaN 은 true를 반환합니다 &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 는 두 숫자를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">이항 &lt;code&gt;&quot;**&quot;&lt;/code&gt; 은 지수 연산자입니다. 이 때문에, 더욱 긴밀하게 단항 마이너스보다는 결합 &lt;code&gt;-2**4&lt;/code&gt; 입니다 &lt;code&gt;-(2**4)&lt;/code&gt; ,하지 &lt;code&gt;(-2)**4&lt;/code&gt; . (이것은 실제로 내부에서 두 배로 작동하는 C의 &lt;code&gt;pow(3)&lt;/code&gt; 함수를 사용하여 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 는 두 숫자의 합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">이진 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 은 쉼표 연산자입니다. 스칼라 컨텍스트에서는 왼쪽 인수를 평가하고 해당 값을 버린 다음 오른쪽 인수를 평가하여 해당 값을 반환합니다. 이것은 C의 쉼표 연산자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 두 숫자의 차이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">이진 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 두 개의 문자열을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">이진 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 은 범위 연산자이며 컨텍스트에 따라 실제로 두 개의 다른 연산자입니다. 목록 컨텍스트에서 왼쪽 값에서 오른쪽 값까지 세는 값 목록 (1 씩 증가)을 반환합니다. 왼쪽 값이 오른쪽 값보다 크면 빈 목록을 반환합니다. range 연산자는 &lt;code&gt;foreach (1..10)&lt;/code&gt; 루프 를 작성 하고 배열에서 슬라이스 작업을 수행하는 데 유용 합니다. 현재 구현에서 범위 연산자를 &lt;code&gt;foreach&lt;/code&gt; 루프 에서 표현식으로 사용하면 임시 배열이 작성되지 않지만 이전 버전의 Perl은 다음과 같이 작성할 때 많은 메모리를 소모 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">이진수 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 는 두 숫자를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수와 숫자가 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">이항 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 은 스칼라 식을 패턴 일치에 바인딩합니다. 특정 작업 은 기본적으로 &lt;code&gt;$_&lt;/code&gt; 문자열을 검색하거나 수정합니다 . 이 연산자는 다른 문자열에서 이러한 종류의 작업을 수행합니다. 올바른 주장은 검색 패턴, 대체 또는 음역입니다. 왼쪽 인수는 기본 &lt;code&gt;$_&lt;/code&gt; 대신 검색, 대체 또는 음역되어야합니다 . 스칼라 문맥에서 사용될 때, 반환 값은 일반적으로 연산의 성공을 나타냅니다. 예외는 교체 (있는 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; )과 음역 ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 포함) &lt;code&gt;/r&lt;/code&gt; 원인 (비파괴) 옵션, &lt;b&gt;R을&lt;/b&gt;eturn 값은 대체 결과입니다. 목록 컨텍스트의 동작은 특정 연산자에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like 연산자&lt;/a&gt; 를 참조하고 이러한 연산자를 사용하는 예제는 &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">이항 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 은 비트 단위로 XOR 된 피연산자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">이항 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 는 두 주변 표현식의 논리적 연결을 반환합니다. 우선 순위가 매우 낮은 것을 제외하고는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 같습니다 . 이것은 단락을 의미합니다. 올바른 표현은 왼쪽 표현이 참인 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 는 왼쪽 인수가 오른쪽 인수보다 작거나 같거나 큰지 여부에 따라 -1, 0 또는 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">이진 &lt;code&gt;&quot;eq&quot;&lt;/code&gt; 는 왼쪽 인수가 문자열과 오른쪽 인수와 같은 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 크거나 같으면 이진 &lt;code&gt;&quot;ge&quot;&lt;/code&gt; 가 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 큰 경우 이진 &lt;code&gt;&quot;gt&quot;&lt;/code&gt; 는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">이항 &lt;code&gt;&quot;le&quot;&lt;/code&gt; 은 왼쪽 인수가 오른쪽 인수보다 작거나 같은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열보다 오른쪽 인수보다 작 으면 이진 &lt;code&gt;&quot;lt&quot;&lt;/code&gt; 가 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">왼쪽 인수가 문자열과 오른쪽 인수가 같지 않으면 이진 &lt;code&gt;&quot;ne&quot;&lt;/code&gt; 이 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">이항 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 은 두 주변 표현식의 논리적 분리를 반환합니다. &lt;code&gt;||&lt;/code&gt; 와 같습니다. 우선 순위가 매우 낮습니다. 이것은 제어 흐름에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">이항 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 는 반복 연산자입니다. 스칼라 컨텍스트에서 또는 왼쪽 피연산자가 괄호로 묶이지 않은 경우 오른쪽 피연산자가 지정한 횟수만큼 반복 된 왼쪽 피연산자로 구성된 문자열을 반환합니다. 목록 컨텍스트에서 왼쪽 피연산자가 괄호로 묶이거나 &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; 구성된 목록 인 경우 목록을 반복합니다. 오른쪽 피연산자가 0이거나 음수이면 (음수에 경고 발생) 컨텍스트에 따라 빈 문자열 또는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">이항 &lt;code&gt;&quot;xor&quot;&lt;/code&gt; 는 두 주변 표현식의 배타적 논리합을 반환합니다. 물론 단락 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">이진 &lt;code&gt;&quot;|&quot;&lt;/code&gt; OR 피연산자를 비트 단위로 함께 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">이진 &lt;code&gt;&quot;||&quot;&lt;/code&gt; 단락 논리 OR 연산을 수행합니다. 즉, 왼쪽 피연산자가 true이면 오른쪽 피연산자도 평가되지 않습니다. 스칼라 또는 목록 컨텍스트는 평가되는 경우 오른쪽 피연산자로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">이항 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 는 인수간에 스마트 매치를 수행합니다. 스마트 매칭은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">이진 역 호환성; 이 함수는 매크로이지만 &lt;code&gt;Perl_&lt;/code&gt; 구현 (내 보낸)도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">일부 독점 플랫폼에 대한 이진 배포는 &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; 디렉토리 에서 찾을 수 있습니다 . 이들은 표준 배포의 일부가 아니기 때문에 다양한 방식으로 기본 perl 포트와 다를 수 있습니다. 차이점이 무엇인지 보려면 해당 릴리스 노트를 확인해야합니다. 이러한 차이는 긍정적 (예 : perl의 소스 릴리스에서 지원되지 않는 특정 플랫폼의 기능에 대한 확장)이거나 부정적 일 수 있습니다 (예 : perl의 최신 소스 릴리스를 기반으로 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">이진 설치 관리자는 바탕 화면에 유용한 개체가 포함 된 폴더를 만듭니다. 이진 설치 프로그램 작업의 일부 측면을 변경해야하는 경우 파일을 자유롭게 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">이진 문자열 (바이트 문자열)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">바인딩 연산자</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">매크로에서 여러 명령문을 함께 바인딩</target>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind (2)와 마찬가지로 네트워크 주소를 소켓에 바인딩합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind (2)와 마찬가지로 네트워크 주소를 소켓에 바인딩합니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. NAME은 소켓에 적합한 유형의 압축 된 주소 여야합니다. &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;소켓 : perlipc의 클라이언트 / 서버 통신&lt;/a&gt; 의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell, Andrew D. 쓰레드 프로그래밍에 대한 소개. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 : &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; ( 온라인 권장)</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">비트 보완 연산자 ~ 및 vec ()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">비트 문자열</target>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">비트는 메모리 세계의 원자입니다. 개별 비트에 대한 액세스는 최후의 수단으로 또는 데이터를 처리하는 가장 편리한 방법이기 때문에 사용해야 할 수도 있습니다. 비트 문자열 (비) 패킹은 일련의 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 문자를 포함하는 문자열 과 각각 8 비트 그룹을 포함하는 일련의 바이트 사이를 변환 합니다. 이것은 바이트의 내용이 비트 열로 쓰여질 수있는 두 가지 방법이 있다는 점을 제외하고는 거의 들리는 것처럼 간단합니다. 주석이 달린 바이트를 보자.</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">파일 &lt;b&gt;소유자&lt;/b&gt; 가 다른 사람에 대한 액세스를 허용하거나 허용하지 않도록 설정하거나 설정하지 않은 비트입니다 . 이 플래그 비트는 파일에 대해 물어볼 때 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 내장에서 반환 하는 &lt;b&gt;모드&lt;/b&gt; 워드의 일부입니다 . 유닉스 시스템에서는</target>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">모든 크기의 비트 열은 비트 연산자 ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ) 로 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">비트와</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">비트 단위 및 독점 또는</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">비트 문자열 연산자</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">다른 일을하는 청크 사이에 빈 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">축복받은 참고 문헌과 클래스 개체</target>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">지정된 패키지에 SV를 축복합니다. SV는 RV 여야합니다. 패키지는 숨김으로 지정해야합니다 ( &lt;code&gt;gv_stashpv()&lt;/code&gt; 참조 ). SV의 참조 카운트는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">맹목적으로 전달되는 va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">가변적으로 매크로를 사용하여 맹목적으로</target>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">블록 이름은 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; 또는 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; 와 같이 복합 형식으로 일치합니다 . 대부분의 다른 속성과 달리, 일부 블록 이름 만 유니 코드로 정의 된 짧은 이름을 갖습니다. 그러나 Perl은 (약간, 더 이상 권장하지 않음) 지름길을 제공합니다. 예를 들어 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; 또는 &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; 와 같이 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">보고서 본문. 명령 행 또는 &lt;b&gt;-f&lt;/b&gt; 파일에 포함되지 않은 경우 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)에는이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 기울임 꼴 (아마도 실제로는 비스듬한) 버전입니다. Pod :: Man은 이것을 가지고 있다고 가정하지 않으며 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. 일부 시스템 (예 : Solaris)에는이 글꼴을 &lt;code&gt;CX&lt;/code&gt; 로 사용할 수 있습니다 . troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 체 버전. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. &lt;b&gt;troff&lt;/b&gt; 출력 에만 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">고정 폭 글꼴의 굵은 체 버전. 기본값은 &lt;code&gt;CB&lt;/code&gt; 입니다. troff (1) 출력에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">부울 이 매개 변수가 true이면 필수 모듈 (또는 올바른 버전)이 없으면 치명적입니다. &lt;code&gt;perl Makefile.PL&lt;/code&gt; 은 사용자에게 누락 된 종속성을 알려주는 대신 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">부울 이 매개 변수가 true이면 전제 조건이 stdout으로 인쇄되고 MakeMaker가 종료됩니다. 출력 형식은 평가 가능한 해시 참조입니다.</target>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">부울 메소드</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">부울 연산자</target>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">부울 옵션 :</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">부울 값. false 인 경우 테스트가 실행되는 동안 표시되는 &lt;code&gt;X/Y&lt;/code&gt; 테스트 카운트를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">부울을 만드는 규칙을 포함해야한다고 MakeMaker에 알려주는 부울입니다. 이것은 MakeMaker에 의해 스위치로 자동 처리됩니다. 사용자는 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">부울. 하위 디렉토리로 내려가는 것을 금지하는 속성.</target>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">클래스 &lt;code&gt;two_refs1&lt;/code&gt; 에 축복 된 두 &quot;객체&quot; 는 배열에 대한 참조, 따라서</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated"># 1과 # 2는 $ data가 완전히 유효한 UTF-8 문자열로 구성되도록하지만 # 2만이 UTF8 플래그를 켭니다. # 1은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">두 &lt;code&gt;bstr()&lt;/code&gt; 및 &lt;code&gt;bsstr()&lt;/code&gt; 뿐만 아니라 오버로드를 통해 캐릭터 라인 화 자동으로 현재 최고의 '+'를 놓습니다. 이전 코드는 '+3'을 반환하고 새 코드는 '3'을 반환합니다. 이것은 Perl과 일관성을 유지하고 &lt;code&gt;cmp&lt;/code&gt; (특히 과부하가 걸리는 경우)가 예상대로 작동하도록하는 것입니다. 또한 &lt;code&gt;Test.pm&lt;/code&gt; 및 &lt;a href=&quot;../test/more&quot;&gt;Test :: More의&lt;/a&gt; 문제를 해결 하여 인수를 비교하기 전에 문자열 로 묶 습니다.</target>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">두 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 및 &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 반환합니다 &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에 있지 않으며 (NFC는 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; 이며) &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 는 NFC에 있습니다.</target>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">지원되는 범위를 벗어난 날짜가 제공된 경우 &lt;code&gt;timelocal()&lt;/code&gt; 및 &lt;code&gt;timegm()&lt;/code&gt; 둘 다 사라 집니다.</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">두 &lt;code&gt;wrap()&lt;/code&gt; 와 &lt;code&gt;fill()&lt;/code&gt; 하나의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">두 Perl 함수 모두 첫 번째 매개 변수로 오브젝트를 예상합니다. 생성 된 C ++ 코드에서 오브젝트를 &lt;code&gt;THIS&lt;/code&gt; 라고 하며이 오브젝트 에서 메소드 호출이 수행됩니다. 따라서 C ++ 코드에서 blue () 및 set_blue () 메소드는 다음과 같이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">YAML.pm과 YAML :: Syck는 모두 코드를 역 직렬화 할 수 있습니다. 보안 위험이있는 문자열 평가가 필요하므로이 옵션을 사용하여 CPAN :: DeferredCode를 통해 코드의 직렬화 해제를 활성화하거나 비활성화 할 수 있습니다. (참고 : 이것은 perl 5.6에서는 작동하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">둘 다 나쁘고 부러지고 운반 할 수 없습니다. 올바른 PTR2IV () 매크로를 사용하십시오. 마찬가지로 PTR2UV (), PTR2NV (), INT2PTR () 및 NUM2PTR ()이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">두 가지 노력 모두 자원 봉사자를 환영합니다. 펄 자체의 연기 테스트에 참여하려면 &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/를&lt;/a&gt; 방문 하십시오 . CPAN 모듈의 연기 테스트를 시작하려면 &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; 또는 &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org를&lt;/a&gt; 방문 하십시오 . / DIST / CPAN-기자 / .</target>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">두 형태 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">두 함수 모두 &lt;code&gt;gettimeofday&lt;/code&gt; 와 같은 동등한 정보를 리턴 하지만 다른 표현을 리턴합니다 . &lt;code&gt;NVtime&lt;/code&gt; 및 &lt;code&gt;U2time&lt;/code&gt; 이라는 이름 은 운영 체제와 독립적이므로 주로 선택되었습니다. ( &lt;code&gt;gettimeofday&lt;/code&gt; 는 Unix 중심이지만 Win32 및 VMS와 같은 일부 플랫폼에는 에뮬레이션이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">install () 및 uninstall ()은 ExtUtils :: MakeMaker가 perl 모듈의 설치 및 제거를 처리하는 방식에 따라 다릅니다. 범용 도구로 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">숫자 및 문자열 값이 모두 허용되지만 문자열 값은 대소 문자를 구분합니다. 이 설정의 기본값은 &quot;RANDOM&quot;또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">위의 두 문자는 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; &lt;code&gt;\x09&lt;/code&gt; 와 일치 하지만 \ x09 는 다음과 같습니다. 실수로 경고가 발생합니다 ( &lt;code&gt;re 'strict'&lt;/code&gt; 하에 ).</target>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">읽기 및 쓰기 액세스</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">두 루틴 모두 작동 된 해시에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">둘 다 &quot;$ x&quot;, 하나의 공백, &quot;?&quot;, 하나의 공백, &quot;:&quot;, 하나의 공백, &quot;$ z&quot;로 구성되는 모노 스페이스 (c [ode] 스타일) 텍스트를 나타냅니다. 차이점은 후자의 경우 S 코드에서 해당 공간은 &quot;정상&quot;공간이 아니라 비 공백 공간이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">stringify와 bstr ()은 이제 선행 '+'를 삭제합니다. 이전 코드는 '+1.23'을 반환하고 새 코드는 '1.23'을 반환합니다. 추론 및 자세한 내용 은 &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; 의 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">두 스타일 모두 실제 파일 핸들의 객체 또는 유형 글로브와 함께 작동합니다. (일부 상황에서는 문자열을 사용할 수도 있지만 위험합니다.)</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">여기서 두 서브 루틴은 스칼라 컨텍스트에서 호출되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">양쪽 &lt;code&gt;$key&lt;/code&gt; 와 &lt;code&gt;$value&lt;/code&gt; 매개 변수는 키 / 값 쌍으로 설정됩니다 데이터베이스에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">모두 &lt;code&gt;FETCH&lt;/code&gt; 기능을 보내고하고는 &lt;code&gt;EXISTS&lt;/code&gt; 기능은 동일한 서명이 : 인수는 &lt;code&gt;$key, $data&lt;/code&gt; ; $ data는 tie () 중 인수로 제공된 값과 같습니다. 값이 없으면 두 함수 모두 빈 목록을 반환해야합니다. 경우 &lt;code&gt;EXISTS&lt;/code&gt; 기능은 다른 &lt;code&gt;FETCH&lt;/code&gt; 보내고 기능, 그것은 성공에 TRUE 값을 반환해야합니다. &lt;code&gt;FETCH&lt;/code&gt; 키가 유효한지 보내고 기능은 의도 된 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">두 &lt;code&gt;\p&lt;/code&gt; 상대방은 항상 유니 코드 규칙이 유효하다고 가정합니다. ASCII 플랫폼에서 이는 128에서 255까지의 코드 포인트가 Latin-1이라고 가정하며 로케일이 Latin-1 또는 UTF-8이 아니라면 로케일 규칙에서 코드 포인트를 사용하는 것이 현명하지 않다는 것을 의미합니다. 반대로 POSIX 문자 클래스는 로케일 규칙에서 유용합니다. 다음과 같이 실제 규칙의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">모두 &lt;code&gt;filter&lt;/code&gt; 방법은 사용할</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Store 및 Fetch 필터는 모두 &lt;code&gt;$_&lt;/code&gt; 조작 합니다.</target>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">두 함수 모두 지정된 함수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">기본 프로세스와 포크 프로세스가 동일한 STDIN, STDOUT 및 STDERR 파일 핸들을 공유합니다. 두 프로세스 모두 한 번에 액세스하려고하면 이상한 일이 발생할 수 있습니다. 자녀의 파일 핸들을 닫거나 다시 열 수도 있습니다. open ()으로 파이프를 열어이 문제를 해결할 수 있지만 일부 시스템에서는 하위 프로세스가 상위 프로세스보다 오래 지속될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">기본 프로세스와 백그라운드 프로세스 ( &quot;하위&quot;프로세스)는 모두 동일한 STDIN, STDOUT 및 STDERR 파일 핸들을 공유합니다. 둘 다 한 번에 액세스하려고하면 이상한 일이 발생할 수 있습니다. 자녀를 위해 문을 닫거나 다시 열 수 있습니다. 파이프 를 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 이 문제를 해결할 수 있지만 ( &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조 ) 일부 시스템에서는 하위 프로세스가 상위 프로세스보다 오래 지속될 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">특수 매핑과 일반 매핑이 모두</target>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">이 두 XS 선언은 &lt;code&gt;char*&lt;/code&gt; C 유형에 해당하지만 의미가 서로 다릅니다 ( &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">이 두 가지 방법 모두 첫 번째 인수로 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 을 자동으로 삽입 하고 (다른 인수가 제공되지 않은 경우) &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">이 두 가지 문제를 모두 해결할 수 있습니다. 예를 들어, 객체에 대한 참조에 해시 역 참조를 오버로드하려면</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">wdayname (일)과 monname (월) 모두 일의 이름을 색인하는 데 사용할 목록을 전달할 수 있습니다. 실제로 로케일을 설치하거나 사용하지 않고 특정 형식의 현지화를 구현해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">최하위 UTF-8 디코딩 루틴. UTF-8 (또는 UTF-EBCDIC) 인코딩으로 가정되며 더 이상 &lt;code&gt;curlen&lt;/code&gt; bytes가 아닌 문자열 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 의 첫 번째 문자의 원시 코드 포인트 값을 리턴합니다 . &lt;code&gt;*retlen&lt;/code&gt; ( &lt;code&gt;retlen&lt;/code&gt; 이 NULL이 아닌 경우 )은 해당 문자의 길이 (바이트)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">한글 음절의 경계는 다음의 Jamo 동작에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin, Joseph, David Kirschen, Alan Langerman 및 Susan LoVerso. 마하에서 프로그래밍. 애디슨-웨슬리, 1994 년, ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">이전 단계의 결과로 오는 감사, 버그 보고서, 증오 메일 및 스팸에 대해 스스로를 보호하십시오. 선한 행동은 처벌받지 말아야합니다!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">명명 된 캡처 그룹을 참조 할 때는 중괄호가 필요하지만 절대 또는 상대 번호가 지정된 그룹은 선택 사항입니다. 작은 문자열을 연결하여 정규식을 만들 때 중괄호가 더 안전합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; 가 있고 &lt;code&gt;$a&lt;/code&gt; 에 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 포함되어 있고 &lt;code&gt;$b&lt;/code&gt; 에 &lt;code&gt;&quot;37&quot;&lt;/code&gt; 이 포함되어 있으면 &lt;code&gt;/\g137/&lt;/code&gt; 을 얻게 되며 아마도 의도하지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">대괄호 표기법은 Locale :: Maketext의 중요한 기능입니다. sprintf 형식을 대신 할 대괄호 표기법을 의미합니다. 대괄호 표기법으로 수행하는 모든 작업은 하위 블록으로 수행 할 수 있지만 대괄호 표기법은 훨씬 간결합니다.</target>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">대괄호 표기법은 소형 &quot;템플릿&quot;시스템과 유사합니다 ( &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; 의 의미에서 기본 텍스트는 그대로 그대로 전달되지만 특수 영역의 텍스트는 특별히 해석 C ++ 템플릿의 의미가 아닌 의 의미)과 유사합니다. 대괄호 표기법에서는 중괄호 ( &quot;{...}&quot;)가 아닌 대괄호 ( &quot;[...]&quot;)를 사용하여 특별히 해석되는 섹션을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">대괄호 표기법은 다음 섹션에서 설명합니다. 문자열을 대괄호 표기법으로 컴파일하려고하면 문자열이 구문 상 유효하지 않은 경우 (예 : 대괄호를 올바르게 조정하지 않음) 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">공백이거나 공백으로 만 구성된 대괄호 그룹은 무시됩니다. (예 : &quot;[]&quot;, &quot;[]&quot;또는 리턴 및 / 또는 탭 및 / 또는 공백이있는 [및 a].</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">브라켓 문자 클래스</target>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">&lt;code&gt;regnode_charclass&lt;/code&gt; 로 묶인 문자 클래스는 regnode_charclass 로 표시됩니다 . 구조 , 4 바이트 인수와 그에 따라 Latin1 범위의 문자가 클래스에 포함되는 32 바이트 (256 비트) 비트 맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">기호 참조 주위의 대괄호는 항상 문자열 내에있는 것처럼 식별자 또는 변수 이름을 나머지 표현식에서 분리하는 역할을합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">브래킷은 균형을 유지해야합니다. 모든 개방형 브래킷에는 일치하는 근접 브래킷이 하나씩 있어야하며 그 반대도 마찬가지입니다. 따라서 이들은 모두 &lt;b&gt;유효하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt; (초기 버전), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">브래드 애플 턴 &amp;lt;bradapp@enteract.com&amp;gt;, 마렉 루찰 &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">브랜든 L. 블랙, &amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; 벗어남 블록.</target>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">이 모듈의 경우 프로그램의 실행을 브레이크 &lt;code&gt;autouse&lt;/code&gt; d는 조기 완료 될 것으로 예상하고 일부 초기화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">유니 코드 규칙에 따라 텍스트를 줄로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">재사용 가능한 코드를 하나 이상의 개별 모듈 파일로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">줄 바꿈 가능한 줄은 다음과 &lt;code&gt;:&lt;/code&gt; 표시됩니다 . 중단 점이있는 줄은 &lt;code&gt;b&lt;/code&gt; 로 표시되고 작업이 &lt;code&gt;a&lt;/code&gt; 줄은 a 로 표시됩니다 . 실행하려고하는 줄은 &lt;code&gt;==&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">돌파</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">DBM 파일과 해시 간의 바인딩을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">변수와 패키지 사이의 바인딩을 끊습니다. (참조 &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;넥타이&lt;/a&gt; .) 변수가 연결되지 않은 경우는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powers에는 Memoize와 작동하도록 설계되었으며 가장 최근에 사용 된 데이터의 만료를 제공 하는 &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; 모듈이 있습니다. 캐시는 고정 된 수의 항목으로 유지되며 새 데이터가 들어 오면 가장 최근에 사용 된 데이터가 만료됩니다. &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">간단히 말해서 &lt;code&gt;/l&lt;/code&gt; 은 문자 일치를 패턴 일치 실행시 적용되는 &lt;b&gt;L&lt;/b&gt; ocale 의 문자 세트로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">일반적으로 패턴과 문자열을 일치시키는 작업에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">고장난 시스템</target>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">현재 어휘 분석중인 텍스트를 고려중인 청크를 포함하는 버퍼 스칼라. 이것은 항상 일반 문자열 스칼라입니다 ( &lt;code&gt;SvPOK&lt;/code&gt; 가 true 인 경우). 일반적인 스칼라 수단에 의해 스칼라로 사용되지는 않습니다. 대신 아래 설명 된 포인터 변수로 버퍼를 직접 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">버그 리포트 및 기타 피드백이 가장 환영합니다.</target>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">많은 사람들이 제공하는 버그 보고서, 패치 및 잔소리-모두 감사합니다! &amp;amp; nested_quotewords ()가 유용하다는 것을 보증 해 주신 Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt;에게 감사의 말을 전하고 오류 점검에 대해 걱정하지 말라고 알려 주신 Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; -당신은 거기에 있어야했다).</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Peter John Acklam의 버그 수정 &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">CPAN RT 시스템을 통해 버그 (및 새로운 기능에 대한 요청)를 작성자에게보고 할 수 있습니다. &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">버그 / 기능 요청</target>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">해결하지 않을 버그. :-)</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl을 사용하여 이상 현상 빌드</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">빌드 FAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">AmigaOS에서 Perl에 대한 전제 조건 빌드</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">주어진 디렉토리 아래의 트리에서 distroprefs 파일을 찾는 반복자를 빌드하십시오. 트리 내에서 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; 와 일치하는 디렉토리 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">OS / 2, &lt;a href=&quot;perlos2&quot;&gt;perlos2에&lt;/a&gt; 대한 빌드 지시 사항</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">의는 Win32에 대한 작성 지침 &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt; , 또는에서 니 환경에서 &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">매뉴얼 페이지도 작성</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">시스템 구축</target>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">스칼라 &lt;code&gt;dsv&lt;/code&gt; 에 표시 가능한 스칼라 &lt;code&gt;sv&lt;/code&gt; 의 버전을 빌드하십시오 . 표시 가능한 버전은 최대 &lt;code&gt;pvlim&lt;/code&gt; 바이트 길이입니다 (더 긴 경우 나머지는 잘리고 &quot;...&quot;가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">스칼라로 빌드 &lt;code&gt;dsv&lt;/code&gt; 에 표시 가능한 버전의 문자열 &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; 을 . 표시 가능한 버전은 최대 &lt;code&gt;pvlim&lt;/code&gt; 바이트 길이입니다 (더 긴 경우 나머지는 잘리고 &quot;...&quot;가 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">OS / 390에서 Perl 빌드, 테스트, 설치</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Windows 플랫폼 용 빌더 클래스</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Irix에서 32 비트 Perl 빌드</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Irix에서 64 비트 Perl 빌드</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">AIX에서 동적 확장 빌드</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">AIX &amp;lt;5L에서 동적 확장 빌드</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">HP-UX에서 동적 확장 작성</target>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">DOS에서 비 XS 모듈 빌드</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">WinCE 용 Perl 구축</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">DOS에서 펄 구축하기</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">DOS에서 Perl에 대한 전제 조건 빌드</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">DOS에서 XS 모듈 구축</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">소스에서 PA-RISC에 64 비트 가능 gcc를 빌드하는 것은 HP C-ANSI C 컴파일러가 있거나 이미 작동중인 gcc의 64 비트 바이너리가있는 경우에만 가능합니다. 펄의 최상의 성능은 HP의 기본 컴파일러로 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">이진 배포판 만들기</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">정규 표현식 작성</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">LP64 펄 구축</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">건물 관습</target>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">사용자 지정 _.EXE_ 파일 작성</target>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">설치하는 perl의 버전이 시스템에 이미 있고 사용 중인지 또는 아직 사용되지 않은 새 버전인지에 따라 빌드가 다르게 진행되어야합니다. 아래 설명은 버전이 새로운 것으로 가정하므로 DLL을 설치하고</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Irix에서 스레드로 빌드</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">내장 속성</target>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">내장 연산자 및 기능</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">내장 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">번들 인코딩 :: 로케일</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">번들은 CPAN 패키지에서 특별히 취급됩니다. 'bundle :: Tkkit'설치 (이러한 번들이 존재한다고 가정)하면 CPAN은 포드의 CONTENTS 섹션에 모든 모듈을 설치합니다. 준수 번들 파일을 @INC 경로에 배치하여 고유 번들을 로컬로 설치할 수 있습니다. 쉘 인터페이스에서 사용 가능한 autobundle () 명령은 현재 설치된 모든 모듈을 스냅 샷 번들 파일에 포함 시켜서 수행합니다.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">그러나 (예측 가능한 미래에) 포드는 포드 작성자가 위의 &quot;= 항목&quot;-클러스터 구조가 어떤 그룹을 의미하는지 구별 할 수있는 방법을 제공하지 않습니다. 따라서 포맷터는 다음과 같이 포맷해야합니다.</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">그러나 나는 메인 코드를 작동시키는 작업에서 다소 혼란을 겪고 있다고 생각합니다. 메시지에서 원하는 단어를 정확히 결정할 수 있기 전에 프로그램을 몇 번 가지고 놀아야한다는 사실에 대해서는 아무 말도하지 않습니다. 이 경우 세 줄의 코드를 변경해야합니다 : 해당 키로 maketext를 호출 한 다음 ThisProject / I18N / en.pm의 두 줄로 변경하십시오).</target>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">그러나 유니 코드의 의도는 기존 문자 세트 표준과 실습을 통합하는 것이며, 기존의 여러 표준에는 단일 문자가 있으며 이는 ISO-8859-1과 같은 일부 조합과 동일한 의미를 갖습니다. 예를 들어, 유니 코드가 등장 할 때 &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; 는 이미이 표준에있었습니다. 따라서 유니 코드는이를 단일 문자로 레퍼토리에 추가했습니다. 그러나이 문자는 유니 코드에 의해 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; 문자와 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 문자로 구성된 시퀀스와 동등한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">그러나 경고가 순서입니다. 다음을 사용하여 숫자를 복사 할 때 얕은 사본 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">그러나 모든 수정자는 여전히 모든 구성 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">그러나 당신이 잘 알겠지만, 이것은 독자에게 꽤 거칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">그러나 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;entry&lt;/code&gt; 에서 CJK 통합 표의 문자에 대한 가중치 할당 은 여전히 ​​유효합니다. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 가이 키의 값으로 명시 적으로 전달 되면 CJK 통합 표의 문자의 가중치는 정의되지 않은 것으로 처리됩니다. 그러나 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8 인 경우 &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">그러나 첫 번째 블록에서 &lt;code&gt;ok&lt;/code&gt; 가 두 번째 블록에서 &lt;code&gt;skip&lt;/code&gt; 이 호출되는 것처럼 정확하게 여러 번 호출 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">그러나 둘 다 빈 목록을 할당하거나 % HASH 또는 @ARRAY를 정의하는 것보다 느립니다. 이는 집계를 비우는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">그러나 그를 귀찮게하지 마십시오, 그는 은퇴했다.</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">그러나 넣지 마십시오</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">그러나 typemap 파일의 수정 불가능한 버그 (고정으로 인해 기존 CPAN 모듈이 많이 손상됨)로 인해 &lt;code&gt;AV *&lt;/code&gt; 의 참조 횟수 가 제대로 감소하지 않습니다. 따라서 위의 XSUB는 호출 될 때마다 메모리를 누출시킵니다. &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; 및 &lt;code&gt;SVREF&lt;/code&gt; (일반 &lt;code&gt;SV *&lt;/code&gt; 가 아닌 스칼라 참조를 나타냄)에 대해 동일한 문제가 있습니다 . perl 5.16으로 시작하는 perls의 XS 코드에서 참조 유형을 올바르게 처리하는 버전으로 이러한 유형의 유형 맵을 재정의 할 수 있습니다. 당신에 &lt;code&gt;TYPEMAP&lt;/code&gt; 의 섹션 수행</target>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">그러나 문자가 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 와 같이 리터럴로 지정 가능한 경우이를 사용하는 것이 가장 쉽습니다 . 구체적이지 않은 경우 부작용이 문제가되지 않으면 use &lt;code&gt;\N{}&lt;/code&gt; 사용할 수 있습니다 . &lt;code&gt;\xZZ&lt;/code&gt; 대신 &lt;code&gt;\N{U+ZZ}&lt;/code&gt; 를 사용하여 16 진수로 모든 문자를 지정하십시오 . &lt;code&gt;\N{}&lt;/code&gt; 은 유니 코드 이름이므로 항상 유니 코드 문자를 제공합니다. &lt;code&gt;\N{U+41}&lt;/code&gt; 은 유니 코드 코드 포인트가 &lt;code&gt;0x41&lt;/code&gt; 인 문자 이므로 모든 플랫폼에서 &lt;code&gt;'A'&lt;/code&gt; 입니다. 부작용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">그러나 failure_handler_auto는 죽거나 다른 것 대신에 $ key를 컴파일하여 캐싱합니다.</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">그러나 간단한 해결책이 있습니다. &lt;code&gt;Sub::Name&lt;/code&gt; 모듈 은 perl internals에 도달하여 익명 서브 루틴에 이름을 지정합니다. 간단히 이렇게하십시오 :</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">그러나 &quot;directory&quot;의 경우, 기본 &lt;code&gt;quant&lt;/code&gt; 방법이 &quot;directory&quot;의 복수가 &quot;directorys&quot;라고 생각하지 않도록 &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; 원할 것입니다. 다음과 같이 음수 형식을 지정하면 출력이 더 나아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">그러나 지금은 이러한 모든 유형의 데이터 구조에 공통적 인 일반적인 문제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">그러나 다른 언어의 경우 ( &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13에서 자세히 설명 함)&lt;/a&gt; ) 간단한 &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; 로는 충분하지 않습니다. 특히 문제가있는 슬라브어 언어의 경우, 숫자, 명사 인용 형식, 문장의 구문이 해당 명사 슬롯에 표시되는 경우 및 성별을 제공하는 방법이 필요할 수 있습니다. 그 방법은 그 숫자가 그 명사구에 어떤 문법적 숫자로 투영되는지, 그리고 어떤 경우와 성별이 정상적인 경우와 성별을 무시할 것인지를 결정하는 책임이있다. 그런 다음 필요한 모든 활용 형태를 제공하는 어휘집에서 명사를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">그러나 일부 프로세서 / 포맷의 경우이를 쉽게 제어 할 수 없습니다. HTML 예제와 마찬가지로 여러 모호한 &amp;lt;a name = &quot;의 동작</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">그러나 일반적으로 블록은 중괄호라고도하는 중괄호로 구분됩니다. 이 구문 구조를 BLOCK이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">그러나 클라이언트가 &quot;i-Mingo&quot;또는 &quot;x-mingo&quot;또는 &quot;Fr&quot;을 요청하면 % greetings의 조회가 실패합니다. 그게 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">그러나 문서가 시작되면 :</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">그러나 Pod :: Simple :: Methody를 서브 클래 싱하는 경우 &quot;= head1 Hi there&quot;가 표시되면 대신이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">그러나 이것을 시도하면 :</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">그러나 &lt;code&gt;START&lt;/code&gt; 부터 &lt;code&gt;END&lt;/code&gt; 까지 의 중첩 된 발생을 원하면 이 단원의 균형 조정 텍스트 일치에 대한 질문에 설명 된 문제에 대비할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">그러나 &lt;code&gt;\005&lt;/code&gt; 를 사용 하여 TAB을 의미하거나 &lt;code&gt;\xC1&lt;/code&gt; 을 &quot;A&quot; 를 의미 하거나 &lt;code&gt;\xDF&lt;/code&gt; 를 사용하여 &quot;&amp;yuml;&quot;( 분음이있는 작은 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ) 를 의미하는 코드를 작성하면 코드가 제대로 작동 할 수 있습니다 ASCII 플랫폼이 아닌 EBCDIC 플랫폼. 아무도 ASCII 플랫폼에서 코드를 실행하지 않으려는 경우 좋습니다. 그러나이 문서의 편견은 EBCDIC과 ASCII 시스템 사이에서 이식 가능한 코드를 작성하는 것입니다. 다시 말하지만, 관심있는 모든 문자를 키보드에서 쉽게 입력 할 수 있다면 ASCII에 대해 아무것도 알 필요가 없지만 많은 키보드는 &lt;code&gt;\xDF&lt;/code&gt; 문자를 직접 입력하는 것을 쉽게 허용하지 않기 때문에 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; 사용하여 간접적으로 지정하십시오.탈출 순서. 이러한 경우 ASCII / 유니 코드 문자 집합에 대해 가장 쉽게 알 수 있습니다. 작은 &quot;&amp;yuml;&quot;가 &lt;code&gt;U+00FF&lt;/code&gt; 이면이를 대신 &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; 로 지정 하고 컴퓨터가 자동으로 플랫폼에서 &lt;code&gt;\xDF&lt;/code&gt; 번역 하도록하고 &lt;code&gt;\xFF&lt;/code&gt; ASCII에서 xFF . 또는 이름으로 지정할 수 있습니다. &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 와 함께 작은 문자 Y 를 입력하면 숫자를 알 필요가 없습니다. 어느 쪽이든 작동하지만 유니 코드에 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">그러나 펄 프로그래머라면 구조 오프셋 프린터보다 훨씬 더 놀라운 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">그러나 어쨌든 기능과 운영 체제를 별도로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">그러나 필요한 경우를 대비하여 ...</target>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">하지만이 특정 예에서는 아마도</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">그러나 실제로 다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">그러나 XSUB 자체의 특정 필드에도 동일한 정보를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">그러나 어휘 적으로 선언 된 집계에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">그러나 &quot;Neque&quot;, &quot;Porro&quot;및 &quot;Quisquam Est&quot;의 세 가지 (관련 또는 동등한) 항목에 대한 논의가 될 수 있으며 그 다음에 모든 항목을 설명하는 단락과 &quot;Ut Enim&quot;이라는 새 항목이 있습니다. 이 경우 다음과 같이 형식을 지정하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">그러나 Perl 6에서는 전혀 작동하지 않습니다. 대신 (병렬화 가능) &lt;code&gt;any&lt;/code&gt; 연산자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">그러나 다음과 같은 경우에는 삐걱 거릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">그러나 기본 인코딩을 먼저 설정하지 않은 상태 에서 베어 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 를 사용하지 마십시오 . 그렇지 않으면, Perl은 당신이 가지고있는 많은, 많은, 많은 맛의 텍스트 파일을 알 수 없으며, Perl은 파일의 데이터를 작업 할 수있는 실제 문자로 올바르게 매핑하는 방법을 모를 것입니다. 를 포함한 다른 일반적인 인코딩 형식 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , 심지어 &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . 인코딩에 대한 자세한 내용은 &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">그러나이 마지막 세 매크로는 &lt;code&gt;SvPOK()&lt;/code&gt; 가 true 인 경우에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">그러나 이것이 문자열의 문자 중 하나가 UTF-8로 인코딩되어 있거나 문자의 코드 포인트가 0xFF (255) 또는 0x80 (128)보다 크거나 문자열에 있음을 의미하지는 않습니다. 모든 문자. 모든 &lt;code&gt;is_utf8()&lt;/code&gt; 은 내부 &quot;utf8ness&quot;플래그의 값을 반환하는 것입니다. &lt;code&gt;$string&lt;/code&gt; . 플래그가 꺼져 있으면 스칼라의 바이트는 단일 바이트 인코딩으로 해석됩니다. 플래그가 켜져 있으면 스칼라의 바이트는 문자의 (가변 길이, 잠재적으로 멀티 바이트) UTF-8 인코딩 코드 포인트로 해석됩니다. UTF-8로 인코딩 된 문자열에 추가 된 바이트는 자동으로 UTF-8로 업그레이드됩니다. 비 UTF-8 및 UTF-8 스칼라가 혼합 된 경우 (큰 따옴표 삽입, 명시 적 연결 또는 printf / sprintf 매개 변수 대체) 결과는 바이트 문자열의 사본이 UTF로 업그레이드 된 것처럼 UTF-8로 인코딩됩니다. -8 : 예를 들어</target>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">그러나 v5.16 이전에는 원하는 문자 세트에 대해 명시해야합니다. &lt;code&gt;:full&lt;/code&gt; 이름은 공식 유니 코드 문자 이름, 별명, 또는 시퀀스, 모두가 공유 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">그러나 모든 운영 체제가 명령 출력의 포크 또는 캡처를 지원하지는 않으므로이 복잡한 설명은 이식성이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">그러나 일부 모듈은이 만트라로 구축 할 수 없습니다. 환경, 추가 인수 또는 대화식을 통해 사용자로부터 일부 추가 데이터를 얻으려고 시도합니다. 따라서 Phalanx100과 같은 대형 번들 또는 Plagger와 같은 많은 종속성을 가진 모듈의 설치를 방해합니다.</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">그러나 그것을 문자열 화하면 텍스트 내용 만 얻습니다.</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">그러나 예를 들어 전달하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">그러나 오염 테스트는 지금까지만 가능합니다. 때로는 데이터의 오염을 제거해야합니다. 값을 해시의 키로 사용하여 값을 보존 할 수 있습니다. 그렇지 않으면 오염 메커니즘을 우회하는 유일한 방법은 정규식 일치에서 하위 패턴을 참조하는 것입니다. Perl은 비 오염 패턴으로 $ 1, $ 2 등을 사용하여 하위 문자열을 참조하면 해당 패턴을 작성할 때 수행 한 작업을 알고 있다고 가정합니다. 그것은 약간의 생각을 사용한다는 것을 의미합니다. 맹목적으로 아무것도 막지 않거나 전체 메커니즘을 물리칩니다. 변수에 잘못된 문자가 있는지 확인하는 대신 변수에 &quot;좋은&quot;값이있는 올바른 문자 만 있는지 확인하는 것이 좋습니다. 생각하지 못한 나쁜 캐릭터를 놓치기가 너무 쉽기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">그러나 특정 상황에서는 모호한 구문이 생성 될 수 있으므로 직접 메소드 호출 방식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">그러나 그것은 맞지 않을 것입니다. 적어도 당신이 바라고있는 방식은 아닙니다. 문자열에 123이 없다고 주장합니다. 다음은 일반적인 기대와 달리 패턴이 일치하는 이유를 명확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">그러나 두 번째 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 가 앞서 가고 있습니다. 템플릿에 간단한 리터럴 문자열을 사용하지 않습니다. 아마도 우리는 소개해야 할 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">그러나 그것은별로 예쁘지 않습니다. 장기적으로는 다음과 같은 작업을 수행하는 것이 더 간단하거나 명확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">그러나 그것은 비효율적입니다. 더 좋은 방법은 다음과 같이 프로그램을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">그러나 HERE_TARGET은 여백에 대해 여전히 플러시되어야합니다. 들여 쓰기를 원하면 들여 쓰기를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">그러나 다음 코드는 매우 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">그러나이 솔루션 만 작동하는 경우가 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">그러나 어떤 캐릭터 세트를 사용하고 있는지 알고 싶을 수도 있습니다. 가능한 한 가지 예는 성능이 중요한 내부 루프에서 &lt;a href=&quot;#SORTING&quot;&gt;정렬하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">그러나 &lt;b&gt;둘 다&lt;/b&gt; 임시 파일이 될 필요는 없습니다 ... 교착 상태없이 다음과 같이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">그러나 그들은 임의로 길 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">그러나 이들은 여러 개의 (공백이 아닌) 줄에 걸쳐있을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">그러나 교차로가 &lt;code&gt;\p{Thai}&lt;/code&gt; 에만 적용되므로 코드를 읽는 사람이 기대할 수있는 효과는 없습니다. Laotian을 제외한 . 구성 요소 조각을 괄호로 묶으면 이와 같은 함정을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">그러나 이것은 적어도 사람이 기대할 수있는 방식과 일치하지 않습니다. 보간 된 &lt;code&gt;$a99a&lt;/code&gt; 삽입하고 정규 표현식의 전체 텍스트를 확인한 후에 만 ​​역 참조가 역효과를 낸 것이 분명합니다. 하위 식 &lt;code&gt;(\w+)&lt;/code&gt; 이 1 번을 &lt;code&gt;$a99a&lt;/code&gt; 의 그룹 을 한 등급 씩 내 렸습니다 . 상대 역 참조를 사용하면이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">그러나 이것은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">그러나 이식성 경고를 피하려면 ( &lt;a href=&quot;functions/use&quot;&gt;사용&lt;/a&gt; 참조) ) 다음을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 대기 :하지 않습니다 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 단지 바이트 시퀀스를 반환? 결국이 숫자 문자열을 C 코드에 전달하여 결국 숫자가 아닌 포인터를 기대할 수 있습니까? 답은 간단하다 : 우리는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 에 의해 리턴 된 바이트로부터 숫자 주소를 얻어야한다 .</target>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">그러나 우리가 불확실한 단어를 가지고 있다면 어떨까요? 이것은 &lt;code&gt;//g&lt;/code&gt; 가 만든 일종의 작업 입니다. 모든 단어를 추출하려면 간단한 정규식 &lt;code&gt;(\w+)&lt;/code&gt; 하고 &lt;code&gt;/(\w+)/g&lt;/code&gt; 하여 모든 일치 항목을 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">그러나 때 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 대신에 사용된다 &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">그러나 끝에 다음 줄이 추가되면</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">그러나 &lt;code&gt;$a = $b + $c&lt;/code&gt; 대한 실제 컴파일 트리 다릅니다. 일부 노드</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">그러나 다음과 같이 호출하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">그러나 실제로 두 번의 파이프 호출을 할 필요는 없습니다. socketpair () 시스템 호출이 있으면이 모든 것이 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">그러나 귀하의 정책에 명시되어 있지 않는 한 여전히 이것이 올바른지에 대한 가정을 할 수는 없습니다. 사용자에게 물어 보는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">그러나 여전히 재미있는 select ()가 있습니다. 따라서 FileHandle 모듈을 사용하십시오. 이제 소문자 메소드 이름을 사용하여 이러한 특수 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">그러나 &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; 사용하여 지시문을 추출하면 '&amp;gt;'문자가 코드 블록의 가장 바깥 레벨에서 구분 된 것으로 취급되므로 지시문이 올바르게 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">클래스 메서드 호출하여 &lt;code&gt;Math::Complex::display_format&lt;/code&gt; 하고 하나가 공급 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 인수로, 당신은 기본 표시 스타일, 오버라이드 (override) &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . 인수를 제공하지 않으면 현재 설정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">대조적으로</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">일반적으로 CPAN 다이제스트 모듈은 Base64 출력을 채우지 &lt;b&gt;않습니다&lt;/b&gt; . 이러한 다이제스트를 올바르게 채워진 Base64 인코딩이 필요한 다른 소프트웨어에 공급할 때 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">일반적으로 OS / 2 API에 대한 모든 호출은 $ ^ E를 재설정하여 실패를 표시해야합니다. OS / 2 API를 호출하는 모든 Perl 액세스 가능 함수는 두 가지 클래스로 나눌 수 있습니다. 일부 API 오류가 발생하면 일부 die (), 다른 하나는 잘못된 리턴 값을 통해 오류를보고합니다 (물론 Perl과 관련이 없습니다) 액세스 가능한 기능</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">관례 적으로 점검 루틴의 이름은 &lt;code&gt;ck_*&lt;/code&gt; 입니다. 일반적으로 &lt;code&gt;new*OP&lt;/code&gt; 서브 루틴 (또는 &lt;code&gt;convert&lt;/code&gt; )에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">일반적으로 각 테스트에는 순서대로 번호가 할당됩니다. 이것은 대부분 자동으로 수행됩니다. 그러나 각 테스트에 이름을 지정하는 것이 종종 유용합니다. 어느 쪽이 좋을까요?</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">기본적으로 &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; 은 압축 해제됩니다</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">기본적으로 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 는 zlib 라이브러리 버전 1.2.5의 개인 복사본으로 빌드됩니다. (참조</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">기본적으로 &lt;code&gt;Hash::Util&lt;/code&gt; 은 아무것도 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e2116155b494da50686ee8fd22c6f8af75259f" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;List::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">기본적으로 &lt;code&gt;List::Util&lt;/code&gt; 은 서브 루틴을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c8967b9c380cc8af7979a94b2f6e12071d5756c" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Scalar::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">기본적으로 &lt;code&gt;Scalar::Util&lt;/code&gt; 은 서브 루틴을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a85c45889f6bd96a07b3072c70fdac86872c8e7" translate="yes" xml:space="preserve">
          <source>By default CPAN Meta specification &lt;code&gt;1.4&lt;/code&gt; is used. In order to use CPAN Meta specification &lt;code&gt;2.0&lt;/code&gt; , indicate with &lt;code&gt;meta-spec&lt;/code&gt; the version you want to use.</source>
          <target state="translated">기본적으로 CPAN 메타 사양 &lt;code&gt;1.4&lt;/code&gt; 가 사용됩니다. CPAN 메타 사양 사용하려면 &lt;code&gt;2.0&lt;/code&gt; 으로 표시 &lt;code&gt;meta-spec&lt;/code&gt; 사용하려는 버전.</target>
        </trans-unit>
        <trans-unit id="8bc161a96f1f3872cf0bfff0e6212dcccea74651" translate="yes" xml:space="preserve">
          <source>By default Perl does not use the &lt;code&gt;malloc()&lt;/code&gt; included with the Perl source, because it was slower and not entirely thread-safe. If you want to force Perl to build with the old -Dusemymalloc define this.</source>
          <target state="translated">기본적으로 Perl 은 느리고 전적으로 스레드 안전하지 않기 때문에 Perl 소스에 포함 된 &lt;code&gt;malloc()&lt;/code&gt; 사용하지 않습니다 . 펄이 이전 -Dusemymalloc으로 빌드하도록하려면 이것을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1261dc25c0b95e8495b666b1c3497fb4bd944f86" translate="yes" xml:space="preserve">
          <source>By default Perl uses 64 bit integers. If you want to use smaller 32 bit integers, define this symbol.</source>
          <target state="translated">기본적으로 Perl은 64 비트 정수를 사용합니다. 더 작은 32 비트 정수를 사용하려면이 기호를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8741f41b3847fc8e6d6ed4c668a3b8923660d9" translate="yes" xml:space="preserve">
          <source>By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML. You can change it by calling</source>
          <target state="translated">기본적으로 Pod :: Simple :: HTML은 HTML 맨 위에 더미 앵커를 추가합니다. 전화로 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="63d675d5fb6fc8fe769b7759c86a5571aae789b8" translate="yes" xml:space="preserve">
          <source>By default floating point numbers substituted inside strings use the dot (&quot;.&quot;) as the decimal separator. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, and POSIX::setlocale() has been called, the character used for the decimal separator is affected by the LC_NUMERIC locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">기본적으로 문자열 안에서 대체되는 부동 소수점 숫자는 점 ( &quot;.&quot;)을 소수점 구분 기호로 사용합니다. 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 효과이며, POSIX :: setlocale에 ()가 호출되어, 소수 세퍼레이터에 사용하는 문자는 LC_NUMERIC 로케일에 의해 영향을 받는다. &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="dadc258ff54a1a05b69b778084fc2dfc7494a970" translate="yes" xml:space="preserve">
          <source>By default it does nothing.</source>
          <target state="translated">기본적으로 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4033d9fb012c9ab68d72ab1a3b85a5a59eb68724" translate="yes" xml:space="preserve">
          <source>By default it just prints the stubs, but you can set the global $Devel::SelfStubber::JUST_STUBS to 0 and it will print out the entire module with the stubs positioned correctly.</source>
          <target state="translated">기본적으로 스텁 만 인쇄하지만 전역 $ Devel :: SelfStubber :: JUST_STUBS를 0으로 설정하면 스텁이 올바르게 배치 된 전체 모듈이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cfe07b0874e5c860a9ad1e8fd1566639cad34f" translate="yes" xml:space="preserve">
          <source>By default it writes to &lt;code&gt;cwd()&lt;/code&gt; , but you can override that by specifying the &lt;code&gt;to&lt;/code&gt; argument:</source>
          <target state="translated">기본적으로 &lt;code&gt;cwd()&lt;/code&gt; 기록 하지만 다음을 지정하여이를 무시할 수 있습니다. &lt;code&gt;to&lt;/code&gt; 인수 이를 .</target>
        </trans-unit>
        <trans-unit id="27c6146d97f6523b1856790ae4b8a285b8e3db7e" translate="yes" xml:space="preserve">
          <source>By default no Unix2 extra field is created.</source>
          <target state="translated">기본적으로 Unix2 추가 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ab606593d4a9d45e75e4256f15600160e7bc2fa" translate="yes" xml:space="preserve">
          <source>By default no UnixN extra field is created.</source>
          <target state="translated">기본적으로 UnixN 추가 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee18fc042b3c569119417a51774089c404eb248f" translate="yes" xml:space="preserve">
          <source>By default no extended time field is created.</source>
          <target state="translated">기본적으로 확장 시간 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebb685a0031880a3b5e0df98008f367fed554c4e" translate="yes" xml:space="preserve">
          <source>By default no opmask is in effect and any code can be compiled.</source>
          <target state="translated">기본적으로 opmask는 적용되지 않으며 모든 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a6e64907872a01e02add6a8ea23d69c4a6e77e" translate="yes" xml:space="preserve">
          <source>By default only the &lt;code&gt;langinfo()&lt;/code&gt; function is exported.</source>
          <target state="translated">기본적으로 &lt;code&gt;langinfo()&lt;/code&gt; 함수 만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="d98ec28c38227dc5b1c1a5373143946764c67c67" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP::Parser::SourceHandler::Executable&lt;/a&gt; class will create a &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; object to handle the source. This passes the array reference strings as command arguments to &lt;a href=&quot;../ipc/open3&quot;&gt;IPC::Open3::open3&lt;/a&gt;:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP :: Parser :: SourceHandler :: Executable&lt;/a&gt; 클래스는 소스를 처리 할 &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt; 객체를 만듭니다. 이것은 배열 참조 문자열을 &lt;a href=&quot;../ipc/open3&quot;&gt;IPC :: Open3 :: open3에&lt;/a&gt; 명령 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="a48220280114a78503f2a2001b0a32eddecb9d87" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; and &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">기본적으로 사용되는 &lt;code&gt;flush_type&lt;/code&gt; 은 &lt;code&gt;Z_FINISH&lt;/code&gt; 입니다. &lt;code&gt;flush_type&lt;/code&gt; 의 다른 유효한 값 은 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; 및 &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 입니다. &lt;code&gt;flush_type&lt;/code&gt; 매개 변수의 영향을 완전히 이해 한 경우 에만 flush_type 매개 변수를 설정하는 것이 좋습니다 . 자세한 내용은 &lt;code&gt;zlib&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="13a328506dc208738ad9d028668747611624fc18" translate="yes" xml:space="preserve">
          <source>By default the Makefile produced includes all the static extensions in the perl library. (Purified versions of library files, e.g., DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)</source>
          <target state="translated">기본적으로 생성 된 Makefile에는 perl 라이브러리의 모든 정적 확장자가 포함됩니다. (링크 된 오류를 피하기 위해 DynaLoader_pure_p1_c0_032.a와 같은 라이브러리 파일의 정제 된 버전은 자동으로 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="72406ce9b9b1b9e64fd6ddb212ef0d9f15de7828" translate="yes" xml:space="preserve">
          <source>By default the debugger is called using &lt;code&gt;-d&lt;/code&gt; option to perl. If you want to specify some other option, set the &lt;code&gt;TESTDB_SW&lt;/code&gt; variable:</source>
          <target state="translated">기본적으로 디버거는 &lt;code&gt;-d&lt;/code&gt; 옵션을 사용 하여 perl에 호출됩니다 . 다른 옵션을 지정하려면 &lt;code&gt;TESTDB_SW&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2356cae1189c23be90e67a7d45b9477ad72051f" translate="yes" xml:space="preserve">
          <source>By default the directory is deleted when the object goes out of scope.</source>
          <target state="translated">기본적으로 개체가 범위를 벗어나면 디렉터리가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf770fbcc502baf26e331b84104d6aaf9126f59" translate="yes" xml:space="preserve">
          <source>By default the layers from the input side of the filehandle are returned; to get the output side, use the optional &lt;code&gt;output&lt;/code&gt; argument:</source>
          <target state="translated">기본적으로 파일 핸들의 입력 측에서 레이어가 반환됩니다. 출력 측을 얻으려면 선택적 &lt;code&gt;output&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29f25f3b77d3062c86a659cbc91ff07ea769bf59" translate="yes" xml:space="preserve">
          <source>By default this will include *.pm and *.pl and the files found in the PMLIBDIRS directories. Defining PM in the Makefile.PL will override PMLIBDIRS.</source>
          <target state="translated">기본적으로 여기에는 * .pm 및 * .pl과 PMLIBDIRS 디렉토리에있는 파일이 포함됩니다. Makefile.PL에서 PM을 정의하면 PMLIBDIRS가 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1c14ce64b17e700de893a0b00ad2e97e494dcfd4" translate="yes" xml:space="preserve">
          <source>By default verbose output is generated, setting the PERL_INSTALL_QUIET environment variable will silence this output.</source>
          <target state="translated">기본적으로 상세 출력이 생성되며 PERL_INSTALL_QUIET 환경 변수를 설정하면이 출력이 침묵합니다.</target>
        </trans-unit>
        <trans-unit id="4e63e74d2a508a1a33c3e1bb5754226ab9609082" translate="yes" xml:space="preserve">
          <source>By default your system's F_* and O_* constants (eg, F_DUPFD and O_CREAT) and the FD_CLOEXEC constant are exported into your namespace.</source>
          <target state="translated">기본적으로 시스템의 F_ * 및 O_ * 상수 (예 : F_DUPFD 및 O_CREAT)와 FD_CLOEXEC 상수는 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="b44b2a95f6381a248195f00274a8435d100aaa35" translate="yes" xml:space="preserve">
          <source>By default,</source>
          <target state="translated">기본적으로,</target>
        </trans-unit>
        <trans-unit id="6d88a1aadef2616cc309d3135c3c0ad225e5d689" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; will be used for deserializing YAML data. If the &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; environment variable is defined, then it is interpreted as a module to use for deserialization. The given module must be installed, must load correctly and must implement the &lt;code&gt;Load()&lt;/code&gt; function or an exception will be thrown.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; 은 YAML 데이터를 직렬화 해제하는 데 사용됩니다. 는 IF &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; 의 환경 변수가 정의되고, 다음은 직렬화 복원에 사용하는 모듈로 해석됩니다. 주어진 모듈이 설치되어 있고 올바르게로드되어야하며 &lt;code&gt;Load()&lt;/code&gt; 함수를 구현해야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a9ce14085141d2bedbc81e908e7a8dd19fcc292a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../json/pp&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; . If &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../../json/pp&quot;&gt;JSON :: PP&lt;/a&gt; 는 JSON 데이터를 직렬화 해제하는 데 사용됩니다. 는 IF &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 의 환경 변수가 존재, 사실 다음 &quot;JSON :: PP&quot;아니다 &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON의&lt;/a&gt; 모듈 (버전 2.5 이상)로드하고 해석하는 데 사용됩니다 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 을 . 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON을&lt;/a&gt; 설치하거나 너무 오래되지 않은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a294e48ade56dbe097d94ecb2d017b667469c8" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; will try `sendmail` first, if it exists in your $PATH. This generally isn't the case. If there's a remote mail server you use to send mail, consider investigating one of the Transport classes. At time of writing, the available transports include:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple&lt;/a&gt; 은 $ path에`sendmail`을 먼저 시도합니다. 일반적으로 그렇지 않습니다. 메일을 보내는 데 사용하는 원격 메일 서버가 있으면 Transport 클래스 중 하나를 조사하십시오. 작성 당시 사용 가능한 운송 수단은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d72ee058cb3ba5edce2a08b405dc90217d0eada0" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;Locale::Maketext::Simple&lt;/b&gt; draws its source from the calling package's</source>
          <target state="translated">기본적으로 &lt;b&gt;Locale :: Maketext :: Simple&lt;/b&gt; 은 호출 패키지의 소스에서 소스를 그립니다.</target>
        </trans-unit>
        <trans-unit id="35fc08f26016b44845e97a461120088a4d635511" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2man&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2man&lt;/b&gt; 은 POD 입력에서 오류가 감지되면 죽습니다. 경우 &lt;b&gt;--stderr이&lt;/b&gt; 주어지고 더있다 &lt;b&gt;--errors의&lt;/b&gt; 플래그가없는 오류가 표준 오류로 전송되지만 &lt;b&gt;pod2man은&lt;/b&gt; 중단하지 않습니다. 이것은 &lt;code&gt;--errors=stderr&lt;/code&gt; 와 동일 하며 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30d3609c8a43f768f52510e95fef029cac6273de" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">기본적으로, &lt;b&gt; pod2man&lt;/b&gt; 은 가능한 많은 다른 * roff 구현과 작동하도록하기 위해 가장 보수적 인 * roff 출력을 생성합니다. 많은 * roff 구현은 비 ASCII 문자를 처리 할 수 ​​없으므로 모든 비 ASCII 문자가 올바르게 강조된 문자를 작성하는 (* 최소 troff 출력의 경우) * roff 이스케이프 시퀀스로 변환되거나 &lt;code&gt;X&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="b7337f82d45ceca3575dcc4fcaada9bab5f7a5ae" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2text&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">POD 입력에서 오류가 감지되면 기본적으로 &lt;b&gt;pod2text는&lt;/b&gt; 죽습니다. 경우 &lt;b&gt;--stderr이&lt;/b&gt; 주어지고 더있다 &lt;b&gt;--errors의&lt;/b&gt; 플래그가없는 오류가 표준 오류로 전송되지만,&lt;b&gt; pod2text은&lt;/b&gt; 중단하지 않습니다. 이것은 &lt;code&gt;--errors=stderr&lt;/code&gt; 와 동일 하며 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d98831aaac5ae8bfa863600541ce748cdfa2ce" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; tries to use the same output encoding as its input encoding (to be backward-compatible with older versions). This option says to instead force the output encoding to UTF-8.</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2text&lt;/b&gt; 는 입력 인코딩과 동일한 출력 인코딩을 사용하려고합니다 (이전 버전과 역 호환 가능). 이 옵션은 출력 인코딩을 UTF-8로 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f53f148127af7bd5af025188de73dc79a271f7fe" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2usage()&lt;/b&gt; will use &lt;code&gt;$0&lt;/code&gt; as the path to the pod input file. Unfortunately, not all systems on which Perl runs will set &lt;code&gt;$0&lt;/code&gt; properly (although if &lt;code&gt;$0&lt;/code&gt; isn't found, &lt;b&gt;pod2usage()&lt;/b&gt; will search &lt;code&gt;$ENV{PATH}&lt;/code&gt; or else the list specified by the &lt;code&gt;-pathlist&lt;/code&gt; option). If this is the case for your system, you may need to explicitly specify the path to the pod docs for the invoking script using something similar to the following:</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2usage ()&lt;/b&gt; 는 &lt;code&gt;$0&lt;/code&gt; 를 포드 입력 파일의 경로로 사용 합니다. 불행히도 Perl이 실행되는 모든 시스템이 &lt;code&gt;$0&lt;/code&gt; 올바르게 설정 하지는 않습니다 ( &lt;code&gt;$0&lt;/code&gt; 찾을 수 없더라도 &lt;b&gt;pod2usage ()&lt;/b&gt; 는 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 또는 &lt;code&gt;-pathlist&lt;/code&gt; 옵션으로 지정된 목록을 검색합니다 ). 시스템에 해당하는 경우 다음과 유사한 것을 사용하여 호출 스크립트에 대한 포드 문서의 경로를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="139ad65b1f5c08871019f97feca04f36c4d7791f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &lt;code&gt;tar&lt;/code&gt; to store files. For paths greater than 100 characters, this is done using the &lt;code&gt;POSIX header prefix&lt;/code&gt; . Non-POSIX-compatible clients may not support this part of the specification, and may only support the &lt;code&gt;GNU Extended
Header&lt;/code&gt; functionality. To facilitate those clients, you can set the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; . See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section for details on this variable.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 완전히 POSIX 호환 모드에 있으며 파일의 저장 에 &lt;code&gt;tar&lt;/code&gt; 의 POSIX 사양 을 사용합니다. 100자를 초과하는 경로의 경우 &lt;code&gt;POSIX header prefix&lt;/code&gt; 사용하여 수행됩니다 . POSIX 호환이 아닌 클라이언트는이 사양 부분을 지원하지 않을 수 있으며 &lt;code&gt;GNU Extended Header&lt;/code&gt; 기능 만 지원할 수 있습니다. 이러한 클라이언트를 용이하게하기 위해 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 이 변수에 대한 자세한 내용은 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0ce25419277d6adf6e0c4949f8ca8dca00cd62d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;-ing.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 파일을 아카이브의 특정 파일에 지정된 모드로 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 하려고 시도합니다 . 경우에 따라 원하지 않을 수도 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; -ing 을 비활성화 하려면이 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb67a5af923530004ebe769a16f96c44f7d23600" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;-ing, even if it were possible.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 가능한 경우 파일 을 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 시도 합니다. 경우에 따라 원하지 않을 수도 있습니다. 이 경우 가능하면 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; -ing 을 비활성화 하려면이 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="a46faa893a6a331982326586cd0db0d3a2c1dfbd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to put paths that are over 100 characters in the &lt;code&gt;prefix&lt;/code&gt; field of your tar header, as defined per POSIX-standard. However, some (older) tar programs do not implement this spec. To retain compatibility with these older or non-POSIX compliant versions, you can set the &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; variable to a true value, and &lt;code&gt;Archive::Tar&lt;/code&gt; will use an alternate way of dealing with paths over 100 characters by using the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 POSIX 표준에 정의 된대로 tar 헤더 의 &lt;code&gt;prefix&lt;/code&gt; 필드에 100 자 이상의 경로를 넣으려고합니다 . 그러나 일부 (이전) tar 프로그램은이 사양을 구현하지 않습니다. 이러한 이전 또는 비 POSIX 호환 버전과의 호환성을 유지하기 위해 &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 true로 설정 하고 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 &lt;code&gt;GNU Extended Header&lt;/code&gt; 기능 을 사용하여 100 자 이상의 경로를 처리하는 다른 방법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ca08f9f1e5aebac60920c9f0bab0c8d5475cdd53" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Sys::Syslog&lt;/code&gt; exports the symbols from the &lt;code&gt;:standard&lt;/code&gt; tag.</source>
          <target state="translated">기본적으로 &lt;code&gt;Sys::Syslog&lt;/code&gt; 는 &lt;code&gt;:standard&lt;/code&gt; 태그 에서 기호를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="ea04cfd93bdf64370c1cc20e848935f755855d27" translate="yes" xml:space="preserve">
          <source>By default, CJK unified ideographs are ordered in Unicode codepoint order, but those in the CJK Unified Ideographs block are less than those in the CJK Unified Ideographs Extension A etc.</source>
          <target state="translated">기본적으로 CJK 통합 표의 문자는 유니 코드 코드 포인트 순서로 정렬되지만 CJK Unified Ideographs 블록의 번호는 CJK Unified Ideographs Extension A 등의 번호보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="c9fd4df55423b1ff0429c30297d024455fc09d6b" translate="yes" xml:space="preserve">
          <source>By default, CPAN will install the latest non-developer release of a module. If you want to install a dev release, you have to specify the partial path starting with the author id to the tarball you wish to install, like so:</source>
          <target state="translated">기본적으로 CPAN은 개발자가 아닌 최신 버전의 모듈을 설치합니다. 개발자 릴리스를 설치하려면 작성자 ID로 시작하여 설치하려는 tarball의 부분 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d31a5f0a0e7ac5c54379eb4d64385f193a7c7e78" translate="yes" xml:space="preserve">
          <source>By default, Data::Dumper builds up the &quot;seen&quot; hash of scalars that it has encountered during serialization. This is very expensive. This seen hash is necessary to support and even just detect circular references. It is exposed to the user via the &lt;code&gt;Seen()&lt;/code&gt; call both for writing and reading.</source>
          <target state="translated">기본적으로 Data :: Dumper는 직렬화 중에 발생한 스칼라의 &quot;본&quot;해시를 작성합니다. 이것은 매우 비싸다. 이 해시는 원형 참조를 지원하고 감지하는 데 필요합니다. 쓰기와 읽기를 위해 &lt;code&gt;Seen()&lt;/code&gt; 호출을 통해 사용자에게 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd1b6853947249bceb85a960748d4561e30fc8ae" translate="yes" xml:space="preserve">
          <source>By default, GetOptions parses the options that are present in the global array &lt;code&gt;@ARGV&lt;/code&gt; . A special entry &lt;code&gt;GetOptionsFromArray&lt;/code&gt; can be used to parse options from an arbitrary array.</source>
          <target state="translated">기본적으로 GetOptions는 전역 배열 &lt;code&gt;@ARGV&lt;/code&gt; 에있는 옵션을 구문 분석합니다 . 특별한 입장 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; 를 사용하여 임의 배열의 옵션을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d8266281e8d2795ccf65d39f9f3a28ecacdd25" translate="yes" xml:space="preserve">
          <source>By default, HP-UX comes configured with a maximum data segment size of 64MB. This is too small to correctly compile Perl with the maximum optimization levels. You can increase the size of the maxdsiz kernel parameter through the use of SAM.</source>
          <target state="translated">기본적으로 HP-UX는 최대 데이터 세그먼트 크기가 64MB로 구성되어 제공됩니다. 최대 최적화 수준으로 Perl을 올바르게 컴파일하기에는 너무 작습니다. SAM을 사용하여 maxdsiz 커널 매개 변수의 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="137732db42e50a8e0a9c182ecd242a32825b115f" translate="yes" xml:space="preserve">
          <source>By default, Hangul syllables are decomposed into Hangul Jamo, even if &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; . But the mapping of Hangul syllables may be overridden.</source>
          <target state="translated">기본적으로 한글 음절은 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 경우에도 한글 자모로 분해됩니다 . 그러나 한글 음절의 매핑은 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b45806d57c8440d5ef81fe98a720868522060d" translate="yes" xml:space="preserve">
          <source>By default, Perl assumes that it must do most of its arithmetic in floating point. But by saying</source>
          <target state="translated">기본적으로 Perl은 대부분의 산술을 부동 소수점으로 수행해야한다고 가정합니다. 그러나 말함으로써</target>
        </trans-unit>
        <trans-unit id="4de9fffb0ae0d357c4fcb6328d235687ad4441ca" translate="yes" xml:space="preserve">
          <source>By default, Perl does a depth-first left-to-right search for a method. That means it starts with the first parent in the &lt;code&gt;@ISA&lt;/code&gt; array, and then searches all of its parents, grandparents, etc. If it fails to find the method, it then goes to the next parent in the original class's &lt;code&gt;@ISA&lt;/code&gt; array and searches from there.</source>
          <target state="translated">기본적으로 Perl은 깊이 우선 왼쪽에서 오른쪽으로 메소드를 검색합니다. 그것은 첫 번째 부모에서 시작한다는 것을 의미합니다. &lt;code&gt;@ISA&lt;/code&gt; 배열 시작한 다음 모든 부모, 조부모 등을 검색합니다. 메서드를 찾지 못하면 원래 클래스의 &lt;code&gt;@ISA&lt;/code&gt; 배열 에서 다음 부모로 이동하여 검색합니다. 거기에서.</target>
        </trans-unit>
        <trans-unit id="b268ca20b85e7cb3d549ac0ab2d0251384881b6c" translate="yes" xml:space="preserve">
          <source>By default, Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) ignores the current locale. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma tells Perl to use the current locale for some operations. Starting in v5.16, there are optional parameters to this pragma, described below, which restrict which operations are affected by it.</source>
          <target state="translated">기본적으로 Perl 자체 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 외부) 모듈 )는 현재 로케일을 무시합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma는 일부 작업에 대한 현재 로케일을 사용하는 펄을 알려줍니다. v5.16부터는이 pragma에 대한 선택적 매개 변수가 있으며이 매개 변수는 영향을받는 조작을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="d3796ef67591d4f35614b1eaeb5b1f668ac93c4c" translate="yes" xml:space="preserve">
          <source>By default, Perl's built-in OO system is very minimal, leaving you to do most of the work. This minimalism made a lot of sense in 1994, but in the years since Perl 5.0 we've seen a number of common patterns emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich ecosystem of Perl OO systems to flourish.</source>
          <target state="translated">기본적으로 Perl의 내장 OO 시스템은 매우 작으므로 대부분의 작업을 수행 할 수 있습니다. 이 미니멀리즘은 1994 년에 의미가 있었지만 Perl 5.0 이후 몇 년 동안 우리는 Perl OO에서 많은 공통 패턴이 등장하는 것을 보았습니다. 다행히도 Perl의 유연성으로 인해 Perl OO 시스템의 풍부한 생태계가 번창 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="fcb268259208b983d01ebd2fb8ea62f828af5570" translate="yes" xml:space="preserve">
          <source>By default, Pod::Escapes exports none of its symbols. But you can request any of them to be exported. Either request them individually, as with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; , or you can do &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; to get all exportable symbols.</source>
          <target state="translated">기본적으로 Pod :: Escapes는 해당 심볼을 내 보내지 않습니다. 그러나 내보내기를 요청할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; 을 &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 하여 개별적으로 요청하십시오 . 또는 당신이 할 수있는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; 내보낼 수있는 모든 심볼을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a42f3e93e67354db749eedfb3803802a7a1b163f" translate="yes" xml:space="preserve">
          <source>By default, Pod::Man produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">기본적으로 Pod :: Man은 최대한 많은 다른 * roff 구현과 작동하도록하기 위해 가장 보수적 인 * roff 출력을 생성합니다. 많은 * roff 구현은 비 ASCII 문자를 처리 할 수 ​​없으므로 모든 비 ASCII 문자가 올바르게 강조된 문자를 작성하는 (* 최소 troff 출력의 경우) * roff 이스케이프 시퀀스로 변환되거나 &lt;code&gt;X&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="98107783dba2f8c87d2092a6ced42a0827ce5268" translate="yes" xml:space="preserve">
          <source>By default, Pod::Text uses the same output encoding as the input encoding of the POD source (provided that Perl was built with PerlIO; otherwise, it doesn't encode its output). If this option is given, the output encoding is forced to UTF-8.</source>
          <target state="translated">기본적으로 Pod :: Text는 POD 소스의 입력 인코딩과 동일한 출력 인코딩을 사용합니다 (Perl이 PerlIO로 빌드 된 경우에는 그렇지 않으면 출력이 인코딩되지 않음). 이 옵션이 제공되면 출력 인코딩은 UTF-8로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="607468b061542c5fb308ea35e966138c590f5abc" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. This does not work well e.g. if the script was packed with &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;. The -noperldoc option suppresses the external call to &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; and uses the simple text formatter (&lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;) to output the POD.</source>
          <target state="translated">기본적으로 Pod :: Usage는 -verbose&amp;gt; = 2가 지정되면 &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; 을 호출 합니다. 예를 들어 스크립트가 &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt; 로 압축 된 경우에는 제대로 작동하지 않습니다 . -noperldoc 옵션은 &lt;a href=&quot;../perldoc&quot;&gt;perldoc에&lt;/a&gt; 대한 외부 호출을 억제하고 간단한 텍스트 포맷터 ( &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; )를 사용하여 POD를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7aaf9130ce3cc364b8ff0d6d870dfc5f5e3ff5d9" translate="yes" xml:space="preserve">
          <source>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a &quot;?&quot;. Note that the meanings don't change, just the &quot;greediness&quot;:</source>
          <target state="translated">기본적으로, 정량화 된 하위 패턴은 &quot;욕심&quot;입니다. 즉, 패턴의 나머지 부분은 계속 일치시키면서 가능한 한 여러 번 (특정 시작 위치가 제공됨) 일치합니다. 가능한 최소 횟수와 일치 시키려면 &quot;?&quot;로 수량자를 따르십시오. 그 의미는 변하지 않고 단지 &quot;만족&quot;이라는 것에 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="b48a9b04f7e394f8ae5c84a6badf024eee518a01" translate="yes" xml:space="preserve">
          <source>By default, all ftp connections are done in passive mode. To change that, see the &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; variable further down.</source>
          <target state="translated">기본적으로 모든 ftp 연결은 수동 모드로 수행됩니다. 이를 변경하려면 &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; 변수를 자세히 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="7f80a56139fac5d67611619acae3e63a365a4381" translate="yes" xml:space="preserve">
          <source>By default, attribute handlers are called at the end of the compilation phase (in a &lt;code&gt;CHECK&lt;/code&gt; block). This seems to be optimal in most cases because most things that can be defined are defined by that point but nothing has been executed.</source>
          <target state="translated">기본적으로 속성 처리기는 컴파일 단계 종료시 ( &lt;code&gt;CHECK&lt;/code&gt; 블록에서) 호출됩니다 . 정의 할 수있는 대부분의 항목이 해당 지점에서 정의되었지만 실행 된 것이 없기 때문에 대부분의 경우에 최적 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="d92e033ccee030ae17ccf241ebba25503e925cbf" translate="yes" xml:space="preserve">
          <source>By default, but can be redefined.</source>
          <target state="translated">기본적으로 다시 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f90d660b6b88d20d5a032c88e00b0f974301c2b" translate="yes" xml:space="preserve">
          <source>By default, case-sensitive comparison (that is level 3 difference) won't ignore accents (that is level 2 difference).</source>
          <target state="translated">기본적으로 대소 문자 구분 비교 (레벨 3 차이)는 악센트 (레벨 2 차이)를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b957d395a8a7eedebb03724489ebfa7e55174b9c" translate="yes" xml:space="preserve">
          <source>By default, classes in Perl only perform the &lt;code&gt;UNIVERSAL&lt;/code&gt; role, as well as the role of all classes in their inheritance. In other words, by default &lt;code&gt;DOES&lt;/code&gt; responds identically to &lt;code&gt;isa&lt;/code&gt; .</source>
          <target state="translated">기본적으로 Perl의 클래스는 &lt;code&gt;UNIVERSAL&lt;/code&gt; 역할과 상속시 모든 클래스의 역할 만 수행합니다 . 즉, 기본적으로 &lt;code&gt;DOES&lt;/code&gt; 는 &lt;code&gt;isa&lt;/code&gt; 에 동일하게 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="a09751b6a3dd219cd03f615c311b1588c0433a01" translate="yes" xml:space="preserve">
          <source>By default, each time the CPAN module is started, cache scanning is performed to keep the cache size in sync ('atstart'). Alternatively, scanning and cleanup can happen when CPAN exits ('atexit'). To prevent any cache cleanup, answer 'never'.</source>
          <target state="translated">기본적으로 CPAN 모듈이 시작될 때마다 캐시 크기를 동기화 ( 'atstart')로 유지하기 위해 캐시 스캔이 수행됩니다. 또는 CPAN이 종료되면 ( 'atexit') 스캔 및 정리가 발생할 수 있습니다. 캐시 정리를 방지하려면 'never'로 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="a04a99ac495330cd07b871fc7a9618f7082ee169" translate="yes" xml:space="preserve">
          <source>By default, every base class needs to live in a file of its own. If you want to have a subclass and its parent class in the same file, you can tell &lt;code&gt;parent&lt;/code&gt; not to load any modules by using the &lt;code&gt;-norequire&lt;/code&gt; switch:</source>
          <target state="translated">기본적으로 모든 기본 클래스는 자체 파일에 있어야합니다. 서브 클래스와 그 상위 클래스를 같은 파일에 두려면 , &lt;code&gt;-norequire&lt;/code&gt; 스위치 를 사용하여 &lt;code&gt;parent&lt;/code&gt; 에게 모듈을로드하지 않도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="009314417d0e225d96e9c70c4f8a61f37cbd61fb" translate="yes" xml:space="preserve">
          <source>By default, file names are assumed to be case sensitive; this flag makes bsd_glob() treat case differences as not significant.</source>
          <target state="translated">기본적으로 파일 이름은 대소 문자를 구분하는 것으로 간주됩니다. 이 플래그는 bsd_glob ()가 대소 문자 차이를 중요하지 않은 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="6e050dc7d694db5e9597e9b5666a97cb998c6670" translate="yes" xml:space="preserve">
          <source>By default, hiragana is before katakana. If the parameter is made true, this is reversed.</source>
          <target state="translated">기본적으로 히라가나는 가타카나 앞에 있습니다. 매개 변수가 true이면 반대입니다.</target>
        </trans-unit>
        <trans-unit id="a68b6a00ff07db87e5b4fca637ec784a918f2f88" translate="yes" xml:space="preserve">
          <source>By default, if a redispatch attempt fails to find another method elsewhere in the objects class hierarchy, it quietly gives up and does nothing (but see &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;Enforcing redispatch&lt;/a&gt;). This gracious acquiescence is also unlike the (generally annoying) behaviour of &lt;code&gt;SUPER&lt;/code&gt; , which throws an exception if it cannot redispatch.</source>
          <target state="translated">기본적으로 재발견 시도가 객체 클래스 계층의 다른 곳에서 다른 방법을 찾지 못하면 조용히 포기하지 않습니다 (그러나 &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;재발 명 시행&lt;/a&gt; 참조 ). 이 은혜로운 욕설은 또한 &lt;code&gt;SUPER&lt;/code&gt; 의 (일반적으로 성가신) 행동과는 달리 재발견 할 수없는 경우 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="622748004543277cac1eed24641a5d626b92e074" translate="yes" xml:space="preserve">
          <source>By default, it checks only ascii, utf8 and UTF-16/32 with BOM.</source>
          <target state="translated">기본적으로 BOM을 사용하여 ascii, utf8 및 UTF-16 / 32 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7d795357eb0370d795216bc893725d71f457449f" translate="yes" xml:space="preserve">
          <source>By default, it exports the functions cwd(), getcwd(), fastcwd(), and fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.</source>
          <target state="translated">기본적으로 cwd (), getcwd (), fastcwd () 및 fastgetcwd () (및 Win32의 경우 getdcwd ()) 함수를 호출자의 네임 스페이스로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bd57ef383f01461a26729aaf5bda1caeec29a44b" translate="yes" xml:space="preserve">
          <source>By default, lowercase is before uppercase. If the parameter is made true, this is reversed.</source>
          <target state="translated">기본적으로 소문자는 대문자 앞에 있습니다. 매개 변수가 true이면 반대입니다.</target>
        </trans-unit>
        <trans-unit id="bd52b1e53c314fe3c4b656aedbdea4b06daed47d" translate="yes" xml:space="preserve">
          <source>By default, no comment field is written to the zip file.</source>
          <target state="translated">기본적으로 주석 필드는 zip 파일에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d5b6fb015586b3864b9f25cf4e1c4322f8f41ee" translate="yes" xml:space="preserve">
          <source>By default, optional warnings are disabled, so any legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">기본적으로 선택적 경고는 비활성화되어 있으므로 경고를 제어하지 않는 레거시 코드는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56744be38bf9987fcb8b98dab67cef731ba84ab1" translate="yes" xml:space="preserve">
          <source>By default, perl handles file globbing using the File::Glob extension, which provides portable globbing.</source>
          <target state="translated">기본적으로 perl은 휴대용 globbing을 제공하는 File :: Glob 확장명을 사용하여 파일 globbing을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b252359c438a3c8369c5cbca58632d9664dd0131" translate="yes" xml:space="preserve">
          <source>By default, perl uses the large file compilation environment and relies on Solaris to do the underlying mapping of interfaces.</source>
          <target state="translated">기본적으로 perl은 큰 파일 컴파일 환경을 사용하며 기본 인터페이스 매핑을 수행하기 위해 Solaris를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95ea6d685281e6fc9b1246edd3de6ccbfbf85ecd" translate="yes" xml:space="preserve">
          <source>By default, perl will be compiled as a 32-bit application. Unless you want to allocate more than ~ 4GB of memory inside perl, or unless you need more than 255 open file descriptors, you probably don't need perl to be a 64-bit app.</source>
          <target state="translated">기본적으로 perl은 32 비트 응용 프로그램으로 컴파일됩니다. 펄 내에 ~ 4GB 이상의 메모리를 할당하지 않거나 255 개 이상의 열린 파일 디스크립터가 필요하지 않으면 펄이 64 비트 앱일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8beb3118174cbb4befcc9218c3e11ee8559a67ed" translate="yes" xml:space="preserve">
          <source>By default, perl-5.6.0 (or later) is compiled as a 32-bit application with largefile and long-long support.</source>
          <target state="translated">기본적으로 perl-5.6.0 이상은 큰 파일과 긴 지원을 가진 32 비트 응용 프로그램으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="c1d7d31b73907dcda6cd3ad0857aee8de05a33a3" translate="yes" xml:space="preserve">
          <source>By default, running out of memory is an untrappable, fatal error. However, if suitably built, Perl can use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency memory pool after &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;ing. Suppose that your Perl were compiled with &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; and used Perl's malloc. Then</source>
          <target state="translated">기본적으로 메모리 부족은 트래핑 할 수없고 치명적인 오류입니다. 그러나 적절하게 구축 된 경우 Perl은 &lt;code&gt;$^M&lt;/code&gt; 의 내용을 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 후 비상 메모리 풀로 사용할 수 있습니다 . Perl이 &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; 로 컴파일되고 Perl의 malloc을 사용 했다고 가정하십시오 . 그때</target>
        </trans-unit>
        <trans-unit id="4190ef76a4299cfe3e352f5cfeb999b38851b5f5" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt; in which case section 3 will be selected.</source>
          <target state="translated">파일이 &lt;code&gt;.pm&lt;/code&gt; 으로 끝나지 않는 한 기본적으로 섹션 1이 사용 되며이 경우 섹션 3이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8d9133733d7f7dcd376ecd3cd224e4dddd523774" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt;, in which case section 3 will be selected.</source>
          <target state="translated">파일이 &lt;code&gt;.pm&lt;/code&gt; 으로 끝나지 않으면 기본적으로 섹션 1이 사용되며 ,이 경우 섹션 3이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="961a8c7a3d78a4ba111b92d292c8ae5c80f7c1a1" translate="yes" xml:space="preserve">
          <source>By default, semaphores behave like locks, letting only one thread &lt;code&gt;down()&lt;/code&gt; them at a time. However, there are other uses for semaphores.</source>
          <target state="translated">기본적으로 세마포어는 잠금처럼 작동하여 한 번에 하나의 스레드 만 &lt;code&gt;down()&lt;/code&gt; 할 수 있습니다. 그러나 세마포어에는 다른 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed769cd67eb1346af1f13055d0984c3c18e8ed3" translate="yes" xml:space="preserve">
          <source>By default, strings whose weights are equal should be equal, even though their code points are not equal. Completely ignorable characters are ignored.</source>
          <target state="translated">코드 포인트가 동일하지 않더라도 기본적으로 가중치가 동일한 문자열은 동일해야합니다. 완전히 무시할 수있는 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="56921ea3749d0afb26fde19f34e5cd700c2dac28" translate="yes" xml:space="preserve">
          <source>By default, the &quot;^&quot; character is guaranteed to match only the beginning of the string, the &quot;$&quot; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line. Embedded newlines will not be matched by &quot;^&quot; or &quot;$&quot;. You may, however, wish to treat a string as a multi-line buffer, such that the &quot;^&quot; will match after any newline within the string (except if the newline is the last character in the string), and &quot;$&quot; will match before any newline. At the cost of a little more overhead, you can do this by using the /m modifier on the pattern match operator. (Older programs did this by setting &lt;code&gt;$*&lt;/code&gt; , but this option was removed in perl 5.10.)</source>
          <target state="translated">기본적으로 &quot;^&quot;문자는 문자열의 시작 부분 만 일치하고 &quot;$&quot;문자는 끝 부분 (또는 끝 부분의 줄 바꿈 이전)에만 일치하며 Perl은 문자열에 포함 된 것으로 가정하여 특정 최적화를 수행합니다. 한 줄. 포함 된 줄 바꿈은 &quot;^&quot;또는 &quot;$&quot;와 일치하지 않습니다. 그러나 문자열을 여러 줄 버퍼로 취급하여 문자열 내의 줄 바꿈 뒤에 &quot;^&quot;가 일치하도록하고 (줄 바꿈이 문자열의 마지막 문자 인 경우 제외) &quot;$&quot;는 개행 전에 일치합니다. 약간의 오버 헤드가 발생하지만 패턴 일치 연산자에서 / m 수정자를 사용하면됩니다. (이전 프로그램은 &lt;code&gt;$*&lt;/code&gt; 를 설정하여이 작업을 수행 했지만이 옵션은 perl 5.10에서 제거되었습니다.)</target>
        </trans-unit>
        <trans-unit id="a1a870bf9d52ad0a2c1a90186336492c4ae0aed3" translate="yes" xml:space="preserve">
          <source>By default, the function is &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;, and the SV parameter is</source>
          <target state="translated">기본적으로 함수는 &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt; 이고 SV 매개 변수는</target>
        </trans-unit>
        <trans-unit id="beeed48a59ea18c1b18a6cfda68d25973cd743b6" translate="yes" xml:space="preserve">
          <source>By default, the installed filter only filters up to a line consisting of one of the three standard source &quot;terminators&quot;:</source>
          <target state="translated">기본적으로 설치된 필터는 다음 세 가지 표준 소스 &quot;터미네이터&quot;중 하나로 구성된 라인까지만 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="e79e890007f8b504a54617ddbf05ff93a90734ba" translate="yes" xml:space="preserve">
          <source>By default, the only variables shared with compartments are the &quot;underscore&quot; variables $_ and @_ (and, technically, the less frequently used %_, the _ filehandle and so on). This is because otherwise perl operators which default to $_ will not work and neither will the assignment of arguments to @_ on subroutine entry.</source>
          <target state="translated">기본적으로 구획과 공유되는 유일한 변수는 &quot;밑줄&quot;변수 $ _ 및 _ (기술적으로 덜 자주 사용되는 % _, _ 파일 핸들 등)입니다. 그렇지 않으면 기본적으로 $ _로 설정된 perl 연산자가 작동하지 않으며 서브 루틴 항목에서 인수를 @_에 지정하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4eebbb2dfa043331a8ced51ef018a956d406180e" translate="yes" xml:space="preserve">
          <source>By default, the pathnames are sorted in ascending ASCII order; this flag prevents that sorting (speeding up bsd_glob()).</source>
          <target state="translated">기본적으로 경로 이름은 ASCII 오름차순으로 정렬됩니다. 이 플래그는 정렬을 방지합니다 (bsd_glob () 속도를 높입니다).</target>
        </trans-unit>
        <trans-unit id="cd52d7b7234ea4b8c1ee0272333575fae9c9ac61" translate="yes" xml:space="preserve">
          <source>By default, the string appended is assumed to be valid UTF-8 if the SV has the UTF-8 status set, and a string of bytes otherwise. One can force the appended string to be interpreted as UTF-8 by supplying the &lt;code&gt;SV_CATUTF8&lt;/code&gt; flag, and as bytes by supplying the &lt;code&gt;SV_CATBYTES&lt;/code&gt; flag; the SV or the string appended will be upgraded to UTF-8 if necessary.</source>
          <target state="translated">기본적으로 SV에 UTF-8 상태 세트가있는 경우 추가 된 문자열은 유효한 UTF-8이고 그렇지 않은 경우 바이트 문자열입니다. 하나는 첨부 된 문자열을 강제 공급으로 UTF-8로 해석 될 &lt;code&gt;SV_CATUTF8&lt;/code&gt; 의 플래그 및 공급함으로써 바이트로서 &lt;code&gt;SV_CATBYTES&lt;/code&gt; 의 플래그; 필요한 경우 SV 또는 추가 된 문자열이 UTF-8로 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="8d41f8d85e7a977c1704e0b6aa0d1e3446f200e7" translate="yes" xml:space="preserve">
          <source>By default, this module creates an &lt;code&gt;::I18N&lt;/code&gt; subclass under the caller's package (or the package specified by &lt;code&gt;Class&lt;/code&gt; ), and stores lexicon data in its subclasses. You can assign a name other than &lt;code&gt;I18N&lt;/code&gt; via this option.</source>
          <target state="translated">기본적으로이 모듈은 호출자의 패키지 (또는 &lt;code&gt;Class&lt;/code&gt; 에 의해 지정된 패키지) 아래에 &lt;code&gt;::I18N&lt;/code&gt; 서브 클래스를 작성하고 해당 서브 클래스에 어휘 데이터를 저장합니다. 이 옵션을 통해 &lt;code&gt;I18N&lt;/code&gt; 이외의 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5949c007c079cc7a10f34781de30c09a225b6eca" translate="yes" xml:space="preserve">
          <source>By default, this module exports a single function, &lt;code&gt;loc&lt;/code&gt; , into its caller's namespace. You can set it to another name, or set it to an empty string to disable exporting.</source>
          <target state="translated">기본적으로이 모듈은 단일 함수 &lt;code&gt;loc&lt;/code&gt; 을 호출자의 네임 스페이스로 내 보냅니다 . 다른 이름으로 설정하거나 빈 문자열로 설정하여 내보내기를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad4115958f94effa9746305a9b0cb4cffc6bd7c" translate="yes" xml:space="preserve">
          <source>By default, this module uses the &lt;code&gt;maketext&lt;/code&gt; style of &lt;code&gt;[_1]&lt;/code&gt; and &lt;code&gt;[quant,_1]&lt;/code&gt; for interpolation. Alternatively, you can specify the &lt;code&gt;gettext&lt;/code&gt; style, which uses &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%quant(%1)&lt;/code&gt; for interpolation.</source>
          <target state="translated">기본적으로이 모듈은 &lt;code&gt;maketext&lt;/code&gt; 스타일 &lt;code&gt;[_1]&lt;/code&gt; 및 &lt;code&gt;[quant,_1]&lt;/code&gt; 을 사용합니다. 또는 보간에 &lt;code&gt;%1&lt;/code&gt; 및 &lt;code&gt;%quant(%1)&lt;/code&gt; 을 사용 하는 &lt;code&gt;gettext&lt;/code&gt; 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="252a3c80bb1e3517a1330d8a71715773619ce9ac" translate="yes" xml:space="preserve">
          <source>By default, variables are private to each thread, and each newly created thread gets a private copy of each existing variable. This module allows you to share variables across different threads (and pseudo-forks on Win32). It is used together with the &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">기본적으로 변수는 각 스레드에 대해 비공개이며 새로 작성된 각 스레드는 기존 변수 각각의 개인용 사본을 가져옵니다. 이 모듈을 사용하면 다른 스레드 (및 Win32의 유사 포크)간에 변수를 공유 할 수 있습니다. &lt;a href=&quot;../threads&quot;&gt;스레드&lt;/a&gt; 모듈 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="08d154b38941f09ce6557f839a81a8eafedac239" translate="yes" xml:space="preserve">
          <source>By default, when a new interpreter is created as a copy of an existing one (eg via &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ), both interpreters share the same physical my_cxt_t structure. Calling &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (typically via the package's &lt;code&gt;CLONE()&lt;/code&gt; function), causes a byte-for-byte copy of the structure to be taken, and any future dMY_CXT will cause the copy to be accessed instead.</source>
          <target state="translated">기본적으로 새 인터프리터가 기존 인터프리터의 복사본으로 생성 된 경우 (예 : &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ) 두 인터프리터는 동일한 물리적 my_cxt_t 구조를 공유합니다. &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; 을 호출 하면 (일반적으로 패키지의 &lt;code&gt;CLONE()&lt;/code&gt; 함수를 통해) 구조의 바이트 별 바이트 사본이 작성되고 이후의 dMY_CXT는 대신 사본에 액세스하게됩니다.</target>
        </trans-unit>
        <trans-unit id="1f023b47e4b490e5f3861a02400fb5ce0693a9fc" translate="yes" xml:space="preserve">
          <source>By default, your program starts in package &lt;code&gt;main&lt;/code&gt; , so you will always be in some package.</source>
          <target state="translated">기본적으로 프로그램은 &lt;code&gt;main&lt;/code&gt; 패키지에서 시작 하므로 항상 일부 패키지에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="cc16f7e5e668d806fbde2fd531d2629a195bfd9c" translate="yes" xml:space="preserve">
          <source>By explicitly requiring a minimum Perl version number for your program, with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; construct. That is,</source>
          <target state="translated">프로그램에 대한 최소 Perl 버전 번호를 명시 적으로 요구함으로써 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 구문을 사용. 그건,</target>
        </trans-unit>
        <trans-unit id="b496b26c66a41bb8b28e0a2591cb8dda23a4871c" translate="yes" xml:space="preserve">
          <source>By far the easiest way to build Perl for OS/400 is to use the PASE (Portable Application Solutions Environment), for more information see &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; This environment allows one to use AIX APIs while programming, and it provides a runtime that allows AIX binaries to execute directly on the PowerPC iSeries.</source>
          <target state="translated">OS / 400 용 Perl을 빌드하는 가장 쉬운 방법은 PASE (Portable Application Solutions Environment)를 사용하는 것입니다. 자세한 정보는 다음을 참조하십시오. &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt; http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; 이를 환경은 프로그래밍하는 동안 AIX API를 사용할 수 있도록하며 AIX 바이너리가 PowerPC iSeries에서 직접 실행될 수있는 런타임을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90b268ad6928ce9b139ce0bfe20e0ab522c5a230" translate="yes" xml:space="preserve">
          <source>By far the most common reason is that the locale has characters in it that are represented by more than one byte. The only such locales that Perl can handle are the UTF-8 locales. Most likely the specified locale is a non-UTF-8 one for an East Asian language such as Chinese or Japanese. If the locale is a superset of ASCII, the ASCII portion of it may work in Perl.</source>
          <target state="translated">가장 일반적인 이유는 로케일에 하나 이상의 바이트로 표시되는 문자가 포함되어 있기 때문입니다. Perl이 처리 할 수있는 유일한 로케일은 UTF-8 로케일입니다. 지정된 로케일은 중국어 나 일본어와 같은 동아시아 언어의 비 UTF-8이 아닌 것 같습니다. 로케일이 ASCII의 상위 세트 인 경우, ASCII 부분은 Perl에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be86ce403211ab50be3b7ce1f4f87ec5b6bd179" translate="yes" xml:space="preserve">
          <source>By first converting the FOO-encoded byte string to a text string, and then the text string to a BAR-encoded byte string:</source>
          <target state="translated">먼저 FOO 인코딩 된 바이트 문자열을 텍스트 문자열로 변환 한 다음 텍스트 문자열을 BAR 인코딩 된 바이트 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3456e5ab0f472be26a41623d10e3cc8ff953c769" translate="yes" xml:space="preserve">
          <source>By including Exporter in your &lt;code&gt;@ISA&lt;/code&gt; you inherit an Exporter's import() method but you also inherit several other helper methods which you probably don't want. To avoid this you can do:</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 에 Exporter를 포함 시키면 Exporter의 import () 메소드를 상속 받지만 원하지 않는 다른 도우미 메소드도 상속합니다. 이를 피하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="583ac2704011a6bdba33e0ae7763c40858b78828" translate="yes" xml:space="preserve">
          <source>By passing a reference to a hash you may set the configuration values. This works only for values that a marked with a &lt;code&gt;RW&lt;/code&gt; above, anything else is read-only.</source>
          <target state="translated">해시에 대한 참조를 전달하여 구성 값을 설정할 수 있습니다. 이것은 &lt;code&gt;RW&lt;/code&gt; 로 표시된 값에 대해서만 작동합니다위 합니다. 다른 것은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e30293ddc7efc1598420ad5a32ac1415cea4ba8a" translate="yes" xml:space="preserve">
          <source>By running &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you ensure that your Mytest.t script runs and uses the correct version of your extension. If you have many test cases, save your test files in the &quot;t&quot; directory and use the suffix &quot;.t&quot;. When you run &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, all of these test files will be executed.</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 를 실행 하면 Mytest.t 스크립트가 실행되고 올바른 확장 버전을 사용하게됩니다. 많은 테스트 사례가있는 경우 테스트 파일을 &quot;t&quot;디렉토리에 저장하고 접미 부 &quot;.t&quot;를 사용하십시오. &quot; &lt;code&gt;make test&lt;/code&gt; 를 실행하면 &quot; 이러한 모든 테스트 파일이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49d2ff2073c166abecd08a90ef566dc2e86a7f38" translate="yes" xml:space="preserve">
          <source>By setting and then using &lt;code&gt;$var&lt;/code&gt; in this way relieves you from having to worry about exactly which numbered set of parentheses they are.</source>
          <target state="translated">이런 식으로 &lt;code&gt;$var&lt;/code&gt; 를 설정하고 사용 하면 정확히 어떤 숫자의 괄호가 있는지 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="265fb107c25a0f703500d08dbe4e8f2787903896" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string you can generate a Makefile that prints all commands. Mainly used in debugging MakeMaker itself.</source>
          <target state="translated">빈 문자열로 설정하면 모든 명령을 인쇄하는 Makefile을 생성 할 수 있습니다. 주로 MakeMaker 자체를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="619bd2bab7e99a9933fcadbbac647cbc3917a48b" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;:loose&lt;/code&gt; , Unicode's &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;loose character name matching&lt;/a&gt; rules are selected instead of the strict exact match used otherwise. That means that</source>
          <target state="translated">&lt;code&gt;:loose&lt;/code&gt; 를 지정하면 , 달리 사용 된 정확한 완전 일치 대신 유니 코드의 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;느슨한 문자 이름 일치&lt;/a&gt; 규칙이 선택됩니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="4173811273acdfc3b518c06a8c9add11d80be073" translate="yes" xml:space="preserve">
          <source>By subclassing, you may end up overriding undocumented methods. That's not a bad thing per se, but be forewarned that undocumented methods may change without warning from one release to the next - we cannot guarantee backwards compatibility. If any</source>
          <target state="translated">서브 클래 싱을 통해 문서화되지 않은 메소드를 대체 할 수 있습니다. 그 자체로는 나쁜 것이 아니지만 문서화되지 않은 방법은 한 릴리스에서 다음 릴리스로 경고없이 변경 될 수 있습니다. 우리는 이전 버전과의 호환성을 보장 할 수 없습니다. 만약에 어떠한</target>
        </trans-unit>
        <trans-unit id="7963af28b4afe4fecf3771e6be636d3a37450528" translate="yes" xml:space="preserve">
          <source>By the time Perl 5 rolled around, we were already stuck with this design: Hash values must be scalars. The solution to this is references.</source>
          <target state="translated">Perl 5가 롤오버 될 때, 우리는 이미이 설계를 고수했습니다. 해시 값은 스칼라 여야합니다. 이에 대한 해결책은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="92f8d8ab799211d118cdd3b80bc6282c36c18e07" translate="yes" xml:space="preserve">
          <source>By the time each of the &lt;code&gt;SaveSub1&lt;/code&gt; statements above has been executed, the SV*s which corresponded to the parameters will no longer exist. Expect an error message from Perl of the form</source>
          <target state="translated">위의 각 &lt;code&gt;SaveSub1&lt;/code&gt; 문이 실행될 때까지 매개 변수에 해당하는 SV *는 더 이상 존재하지 않습니다. 양식의 Perl에서 오류 메시지를 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="334c1508a5d779cb0c1040092154fbe0583ab19f" translate="yes" xml:space="preserve">
          <source>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run, in routines that read the &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; field which it populates.</source>
          <target state="translated">comp 콜백이 호출 될 때이 플래그 중 일부가 이미 적용되었습니다 (해당되는 경우 아래에 표시). 그러나 대부분의 효과는 comp 콜백이 실행 된 후 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 를 읽는 루틴에서 발생합니다. 필드를 .</target>
        </trans-unit>
        <trans-unit id="72795a79e31e2518cbd921d2bc0697a1bdbd6144" translate="yes" xml:space="preserve">
          <source>By tuning the stack size to more accurately reflect your application's needs, you may significantly reduce your application's memory usage, and increase the number of simultaneously running threads.</source>
          <target state="translated">애플리케이션의 요구를보다 정확하게 반영하도록 스택 크기를 조정하면 애플리케이션의 메모리 사용량을 크게 줄이고 동시에 실행중인 스레드 수를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd379fb72b0b513ca230e24dca7f155e46117288" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; , if there is no other &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the method call, an exception will be thrown (as usually happens in the absence of a suitable &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</source>
          <target state="translated">사용하여 &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; 다른이없는 경우, &lt;code&gt;AUTOLOAD&lt;/code&gt; (일반적으로 적당한의 부재에서 일어나는로 메서드 호출을 처리 할 수있는 예외가 발생합니다 &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f260eb29b6f0673bfdb6b907d310d5d3920f6717" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;-E&lt;/code&gt; switch on the Perl command-line instead of &lt;code&gt;-e&lt;/code&gt; . That will enable the feature bundle for that version of Perl in the main compilation unit (that is, the one-liner that follows &lt;code&gt;-E&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 대신 Perl 명령 행 에서 &lt;code&gt;-E&lt;/code&gt; 스위치 를 사용합니다 . 그러면 주 컴파일 단위 (즉, &lt;code&gt;-E&lt;/code&gt; 뒤에 오는 하나의 라이너)에서 해당 버전의 Perl에 대한 기능 번들이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dfef463e4e713cbb716245b6be6a4856999a34d" translate="yes" xml:space="preserve">
          <source>By using the WWW interface you can ask the Upload Server to mirror your modules from your ftp or WWW site into your own directory on CPAN!</source>
          <target state="translated">WWW 인터페이스를 사용하면 ftp 또는 WWW 사이트에서 CPAN의 고유 디렉토리로 모듈을 미러링하도록 업로드 서버에 요청할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="4f37c6bc860992a71dc03ba0a6eb8583644d0eac" translate="yes" xml:space="preserve">
          <source>By using the backslash operator on a variable, subroutine, or value. (This works much like the &amp;amp; (address-of) operator in C.) This typically creates</source>
          <target state="translated">변수, 서브 루틴 또는 값에서 백 슬래시 연산자를 사용합니다. (이것은 C의 &amp;amp; (주소) 연산자와 매우 유사합니다.) 이것은 일반적으로</target>
        </trans-unit>
        <trans-unit id="4fea865bf2bc7c769f8247d0ffedba42a3ee67f2" translate="yes" xml:space="preserve">
          <source>By way of demonstration, we present below a laborious listing resulting from setting your &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable to the value &lt;code&gt;f=n N&lt;/code&gt; , and running</source>
          <target state="translated">설명을 위해 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 환경 변수를 값 &lt;code&gt;f=n N&lt;/code&gt; 으로 설정하고 실행 한 결과로 힘든 목록이 아래에 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="05ff92e836fe1c104b327e3d41d6f42c1c2f68cf" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">Perl의 내장 getgr * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8701f0c6760ad255897a2adbc246d9e8608c8d7a" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">Perl의 내장 gethost * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8edbac978dbd72904307e2cc9662b26a10b3bd66" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">Perl의 내장 getnet * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="905cb97e8ed297dc43dcd08d2a9db1d9958b4ddc" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">Perl의 내장 getproto * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="7980958e534d59fc2ef012727304a32f6778bc74" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">Perl의 내장 getpw * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8c13e6c841eee178cc9c90b3ec31731fb7b6e9d6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">Perl의 내장 getserv * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="10bacc859a37b5cb2457a9867f2de200be21a6bd" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Perl의 내장 gmtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="827cbeee072a43490f322081b175fcaabf1286c6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Perl의 내장 localtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="34a637e08658f8356d26a5052ced9a5575ccaa48" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in stat() functions</source>
          <target state="translated">Perl의 내장 stat () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="00a7465e9ae8fc45cdd85380909fc57080f23c9d" translate="yes" xml:space="preserve">
          <source>Bypass shell script and produce qualifiers for CC directly (but warn user if a shell script for this extension exists). Fold multiple /Defines into one, since some C compilers pay attention to only one instance of this qualifier on the command line.</source>
          <target state="translated">쉘 스크립트를 무시하고 CC에 대한 규정자를 직접 생성하십시오 (그러나이 확장의 쉘 스크립트가 존재하면 사용자에게 경고하십시오). 일부 C 컴파일러는 명령 행에서이 규정 자의 한 인스턴스에만주의를 기울이므로 여러 개의 / Defines을 하나로 접으십시오.</target>
        </trans-unit>
        <trans-unit id="9f9d63573452a4bd55326feb5fe5283989ad472d" translate="yes" xml:space="preserve">
          <source>Byte and Character Semantics</source>
          <target state="translated">바이트 및 문자 의미</target>
        </trans-unit>
        <trans-unit id="1e6a3eac8ab6b01ca95c7c44eb60befc42854a50" translate="yes" xml:space="preserve">
          <source>Byte order is not compatible</source>
          <target state="translated">바이트 순서가 호환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="635424c9374984012107c0dd02fd2041e999753a" translate="yes" xml:space="preserve">
          <source>Byte-order modifiers</source>
          <target state="translated">바이트 순서 수정 자</target>
        </trans-unit>
        <trans-unit id="b0cb8dbe3d4ffe27cb86b68da21fae1475b9d341" translate="yes" xml:space="preserve">
          <source>Byteorders &lt;code&gt;&quot;1234&quot;&lt;/code&gt; and &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; are little-endian; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; and &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; are big-endian. Systems with multiarchitecture binaries will have &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; , signifying that static information doesn't work, one must use runtime probing.</source>
          <target state="translated">바이트 순서 &lt;code&gt;&quot;1234&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; 은 리틀 엔디안입니다. &lt;code&gt;&quot;4321&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; 은 빅 엔디안입니다. 멀티 아키텍처 바이너리가있는 시스템은 &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; 로 정적 정보가 작동하지 않음을 나타내며 런타임 프로빙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf6c5677e50bfc87de6c08c11b4d2bd476a1535" translate="yes" xml:space="preserve">
          <source>Bytes in the source text that have their high-bit set will be treated as being part of a literal UTF-X sequence. This includes most literals such as identifier names, string constants, and constant regular expression patterns.</source>
          <target state="translated">상위 비트 세트가있는 소스 텍스트의 바이트는 리터럴 UTF-X 시퀀스의 일부로 처리됩니다. 여기에는 식별자 이름, 문자열 상수 및 상수 정규 표현식 패턴과 같은 대부분의 리터럴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="129226dbff7ac0a26641ae86a93a3ce3ab2b8aca" translate="yes" xml:space="preserve">
          <source>C Operators Missing From Perl</source>
          <target state="translated">Perl에서 누락 된 C 연산자</target>
        </trans-unit>
        <trans-unit id="b810a5ecd150e1d0012428a848e5d769f60fea9b" translate="yes" xml:space="preserve">
          <source>C RTL</source>
          <target state="translated">C RTL</target>
        </trans-unit>
        <trans-unit id="17a5304c5884fe220f513c1c918ef7adab324995" translate="yes" xml:space="preserve">
          <source>C backtrace</source>
          <target state="translated">C 역 추적</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C 코드</target>
        </trans-unit>
        <trans-unit id="ebcfbca1a38de887c4893368cd463906e0bbe7b3" translate="yes" xml:space="preserve">
          <source>C code to place between the assignment of value (to a temporary) and the return from the function. This allows you to clear up anything in</source>
          <target state="translated">값 할당 (임시)과 함수 반환 사이에 배치 할 C 코드. 이것은 당신이 무엇이든을 정리할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="538185c3d7f303f06af9140ec0da107705c84d52" translate="yes" xml:space="preserve">
          <source>C code to use before the assignment of the value of the constant. This allows you to use temporary variables to extract a value from part of a &lt;code&gt;struct&lt;/code&gt; and return this as</source>
          <target state="translated">상수 값을 할당하기 전에 사용할 C 코드. 이를 통해 임시 변수를 사용하여 &lt;code&gt;struct&lt;/code&gt; 일부에서 값을 추출하여 다음과 같이 반환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0d6da997067e1b793fb43677b57abb70e6d14673" translate="yes" xml:space="preserve">
          <source>C doesn't have a concept of local scope, so perl provides one. We've seen that &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; are used as scoping braces; the save stack implements the C equivalent of, for example:</source>
          <target state="translated">C에는 로컬 범위 개념이 없으므로 perl이 제공합니다. 우리는 &lt;code&gt;ENTER&lt;/code&gt; 와 &lt;code&gt;LEAVE&lt;/code&gt; 가 범위 괄호로 사용되는 것을 보았습니다 . 저장 스택은 다음과 같은 C를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="062ffdd22a0d9502c039f8528f8150dbe0714cfe" translate="yes" xml:space="preserve">
          <source>C function parameters are normally initialized with their values from the argument stack (which in turn contains the parameters that were passed to the XSUB from Perl). The typemaps contain the code segments which are used to translate the Perl values to the C parameters. The programmer, however, is allowed to override the typemaps and supply alternate (or additional) initialization code. Initialization code starts with the first &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; on a line in the INPUT: section. The only exception happens if this &lt;code&gt;;&lt;/code&gt; terminates the line, then this &lt;code&gt;;&lt;/code&gt; is quietly ignored.</source>
          <target state="translated">C 함수 매개 변수는 일반적으로 인수 스택의 값으로 초기화됩니다 (Perl에서 XSUB로 전달 된 매개 변수가 포함됨). 유형 맵에는 Perl 값을 C 매개 변수로 변환하는 데 사용되는 코드 세그먼트가 포함됩니다. 그러나 프로그래머는 유형 맵을 대체하고 대체 (또는 추가) 초기화 코드를 제공 할 수 있습니다. 처음으로 초기화 코드 시작 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; 또는 INPUT : 섹션의 라인에서 &lt;code&gt;+&lt;/code&gt; 이 경우 유일한 예외가 발생합니다 &lt;code&gt;;&lt;/code&gt; 라인을 종료 한 다음 &lt;code&gt;;&lt;/code&gt; 조용히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="33ca94bf1de4049e4f9bdaa005b019e6d57ed90a" translate="yes" xml:space="preserve">
          <source>C header file. This file contains a series of macros and, if explicitly requested, functions that allow XS modules to be built using older versions of Perl. Currently, Perl versions from 5.003 to 5.20 are supported.</source>
          <target state="translated">C 헤더 파일 이 파일에는 일련의 매크로와 명시 적으로 요청 된 경우 이전 버전의 Perl을 사용하여 XS 모듈을 빌드 할 수있는 기능이 포함되어 있습니다. 현재 5.003에서 5.20까지의 Perl 버전이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a90cbbad6ac1bd0dbc637e8984710d08b0d07f9c" translate="yes" xml:space="preserve">
          <source>C header file.)</source>
          <target state="translated">C 헤더 파일)</target>
        </trans-unit>
        <trans-unit id="6475b4e6bb646eb3e0b6202577ce4b2fb0cd180d" translate="yes" xml:space="preserve">
          <source>C keyword introducing a structure definition or name.</source>
          <target state="translated">구조 정의 또는 이름을 소개하는 C 키워드.</target>
        </trans-unit>
        <trans-unit id="0a4b78bc2d00244d4f2291c70d25ad9ed10ec746" translate="yes" xml:space="preserve">
          <source>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions. Comments are allowed anywhere after the MODULE keyword. The compiler will pass the preprocessor directives through untouched and will remove the commented lines. POD documentation is allowed at any point, both in the C and XS language sections. POD must be terminated with a &lt;code&gt;=cut&lt;/code&gt; command; &lt;code&gt;xsubpp&lt;/code&gt; will exit with an error if it does not. It is very unlikely that human generated C code will be mistaken for POD, as most indenting styles result in whitespace in front of any line starting with &lt;code&gt;=&lt;/code&gt; . Machine generated XS files may fall into this trap unless care is taken to ensure that a space breaks the sequence &quot;\n=&quot;.</source>
          <target state="translated">C 프리 프로세서 지시문은 BOOT :, PREINIT : INIT :, CODE :, PPCODE :, POSTCALL : 및 CLEANUP : 블록 내 및 함수 외부에서 허용됩니다. MODULE 키워드 다음에 주석이 허용됩니다. 컴파일러는 수정되지 않은 채로 전 처리기 지시문을 전달하고 주석 처리 된 행을 제거합니다. POD 문서는 C 및 XS 언어 섹션에서 언제든지 허용됩니다. POD는 &lt;code&gt;=cut&lt;/code&gt; 명령 으로 종료해야합니다 . &lt;code&gt;xsubpp&lt;/code&gt; 가 없으면 오류와 함께 종료됩니다. 대부분의 들여 쓰기 스타일로 인해 &lt;code&gt;=&lt;/code&gt; 로 시작하는 행 앞에 공백이 생기기 때문에 사람이 생성 한 C 코드가 POD로 오인 될 가능성은 거의 없습니다 . 공간이 시퀀스 &quot;\ n =&quot;을 손상시키지 않도록주의를 기울이지 않으면 시스템 생성 XS 파일이이 트랩에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b72786c4e2763e287b454e5689b07155e0cdb40" translate="yes" xml:space="preserve">
          <source>C&amp;lt;_pc_chown_restricted&amp;gt; symbol (for example, Windows NT) it is assumed that ``chown() giveaway'' is possible and the recursive test is performed.</source>
          <target state="translated">C &amp;lt;_pc_chown_restricted&amp;gt; 기호 (예 : Windows NT)``chown () giveaway ''가 가능하고 재귀 테스트가 수행되는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d682623210c6b24f8d8f68ce43a83783f1b6c8af" translate="yes" xml:space="preserve">
          <source>C-style Logical And</source>
          <target state="translated">C 스타일 논리 및</target>
        </trans-unit>
        <trans-unit id="468d5b286c1316bc4a6baa7daaefae5e90272197" translate="yes" xml:space="preserve">
          <source>C-style Logical Or</source>
          <target state="translated">C 스타일 논리 또는</target>
        </trans-unit>
        <trans-unit id="0403ad1f3298e7e9e68a2636bf42146ffa41b4ae" translate="yes" xml:space="preserve">
          <source>C. BUILD</source>
          <target state="translated">C. 빌딩</target>
        </trans-unit>
        <trans-unit id="624f656f2b44769e8027ab2f2c47b638fe6eea88" translate="yes" xml:space="preserve">
          <source>C/C++ Traps</source>
          <target state="translated">C / C ++ 트랩</target>
        </trans-unit>
        <trans-unit id="633490a93f1c6b59da0e4592f3c36f5d9d5fc276" translate="yes" xml:space="preserve">
          <source>C3 is the name of an algorithm which aims to provide a sane method resolution order under multiple inheritance. It was first introduced in the language Dylan (see links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section), and then later adopted as the preferred MRO (Method Resolution Order) for the new-style classes in Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO for Perl 6 classes, and the default MRO for Parrot objects as well.</source>
          <target state="translated">C3은 다중 상속에서 정상적인 메소드 해결 순서를 제공하는 것을 목표로하는 알고리즘의 이름입니다. 이 언어는 Dylan 언어로 처음 소개되었고 ( &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; 섹션의 링크 참조 ) 나중에 Python 2.3의 새 스타일 클래스에 대해 선호되는 MRO (Method Resolution Order)로 채택되었습니다. 가장 최근에는 Perl 6 클래스의 &quot;표준&quot;MRO로, Parrot 객체의 기본 MRO로 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="4aa8a8fa5eacc54ba9f8a4e755d8440833ba62a6" translate="yes" xml:space="preserve">
          <source>C3 works by always preserving local precedence ordering. This essentially means that no class will appear before any of its subclasses. Take, for instance, the classic diamond inheritance pattern:</source>
          <target state="translated">C3은 항상 로컬 우선 순위 순서를 유지하여 작동합니다. 이것은 본질적으로 어떤 클래스도 서브 클래스 앞에 나타나지 않음을 의미합니다. 예를 들어, 고전적인 다이아몬드 상속 패턴을 보자.</target>
        </trans-unit>
        <trans-unit id="7a382120912440ea350318c064061d0e6ea8184a" translate="yes" xml:space="preserve">
          <source>C:/emx.add/bin/bash.exe</source>
          <target state="translated">C:/emx.add/bin/bash.exe</target>
        </trans-unit>
        <trans-unit id="519c5bd785564af1dec76cf3a5edc1bf3e894ac6" translate="yes" xml:space="preserve">
          <source>C:/emx/bin/foo.cmd</source>
          <target state="translated">C:/emx/bin/foo.cmd</target>
        </trans-unit>
        <trans-unit id="f6665c2627be2b969dcd410132185e0dd599f37b" translate="yes" xml:space="preserve">
          <source>CALLBACKS</source>
          <target state="translated">CALLBACKS</target>
        </trans-unit>
        <trans-unit id="3991ab584fec70130dcdb49fb4dbe4638d6f1b90" translate="yes" xml:space="preserve">
          <source>CALLING FROM PERL</source>
          <target state="translated">펄에서 전화</target>
        </trans-unit>
        <trans-unit id="5f0a327136ac9e42e9905406e9cf6ed2f2b8cdbf" translate="yes" xml:space="preserve">
          <source>CALLING FROM THE COMMAND LINE</source>
          <target state="translated">명령 줄에서 전화</target>
        </trans-unit>
        <trans-unit id="aa884ac53759d984488c656f65f21f650359027e" translate="yes" xml:space="preserve">
          <source>CAN</source>
          <target state="translated">CAN</target>
        </trans-unit>
        <trans-unit id="5f05bf320ccd994a5b4376cbf772126d72a752e5" translate="yes" xml:space="preserve">
          <source>CANONICAL REPRESENTATION</source>
          <target state="translated">정식 표현</target>
        </trans-unit>
        <trans-unit id="ed877e5c7f10c31f466df09c23df16788f087cc2" translate="yes" xml:space="preserve">
          <source>CANONICAL_NAME</source>
          <target state="translated">CANONICAL_NAME</target>
        </trans-unit>
        <trans-unit id="e520869852c82bbce05b6c5dc47274d3b3a11987" translate="yes" xml:space="preserve">
          <source>CATEGORIES</source>
          <target state="translated">CATEGORIES</target>
        </trans-unit>
        <trans-unit id="980aeb7f8f581c6b66ed59bbbed49733515b10e6" translate="yes" xml:space="preserve">
          <source>CAVEAT</source>
          <target state="translated">CAVEAT</target>
        </trans-unit>
        <trans-unit id="6567e0b0a7daf3c098913aa924483cfe44852131" translate="yes" xml:space="preserve">
          <source>CAVEAT FOR GREAT CIRCLE FORMULAS</source>
          <target state="translated">대순환 공식에 대한 경고</target>
        </trans-unit>
        <trans-unit id="8ae97560e6c967ffcb76f6cd835c75b45c6b2d57" translate="yes" xml:space="preserve">
          <source>CAVEAT ON PRECEDENCE</source>
          <target state="translated">우선주의</target>
        </trans-unit>
        <trans-unit id="1c968ba436040f2ef7532a90991da165ff0512dd" translate="yes" xml:space="preserve">
          <source>CAVEAT: The thread signalling capability provided by this module does not actually send signals via the OS. It</source>
          <target state="translated">주의 :이 모듈에서 제공하는 스레드 신호 기능은 실제로 OS를 통해 신호를 보내지 않습니다. 그것</target>
        </trans-unit>
        <trans-unit id="ce611c3a23df37ff734feee69c06233d5c9abfb4" translate="yes" xml:space="preserve">
          <source>CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless and as of this writing Encode suite just leave it as is (\x{FeFF}).</source>
          <target state="translated">주의 사항 : utf8 (\ xEF \ xBB \ xBF)의 BOM은 유효하지만 의미가 없으며이 코드 작성 당시에는 그대로 (\ x {FeFF}) 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="5ea0a6fefc9f66fb07ad0567375a2c4308c1f112" translate="yes" xml:space="preserve">
          <source>CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.</source>
          <target state="translated">경고 : UTF- (16 | 32)와 달리 utf8의 BOM은 자동으로 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0852d6090cb36f8c92fc678e7c0ed0101951986e" translate="yes" xml:space="preserve">
          <source>CAVEATS</source>
          <target state="translated">CAVEATS</target>
        </trans-unit>
        <trans-unit id="afa50a96d52c4af6173a5b3dcf9e10a0a47c02ab" translate="yes" xml:space="preserve">
          <source>CAVEATS AND LIMITATIONS</source>
          <target state="translated">주의 사항 및 제한 사항</target>
        </trans-unit>
        <trans-unit id="8db2d4672c0bb6f4ea12967ef5822987358da334" translate="yes" xml:space="preserve">
          <source>CAVEATS and NOTES</source>
          <target state="translated">주의 사항 및 참고</target>
        </trans-unit>
        <trans-unit id="422f720e7d72716b7017e69268406be073cfc7c1" translate="yes" xml:space="preserve">
          <source>CGI</source>
          <target state="translated">CGI</target>
        </trans-unit>
        <trans-unit id="41a4605be9cd5708c0812fcf96a67b02ae213ace" translate="yes" xml:space="preserve">
          <source>CGI.pm</source>
          <target state="translated">CGI.pm</target>
        </trans-unit>
        <trans-unit id="313c83d1d2e8c998d1416c76ceb327085bafcc5a" translate="yes" xml:space="preserve">
          <source>CHANGED IN PERL 5.6</source>
          <target state="translated">PERL 5.6에서 변경</target>
        </trans-unit>
        <trans-unit id="15a7fa79c2e880d7c668e6f0bb63190d52852647" translate="yes" xml:space="preserve">
          <source>CHANGED in 3.18</source>
          <target state="translated">3.18에서 변경</target>
        </trans-unit>
        <trans-unit id="a2feb6ed0257c21c6672793ee2f94eaadc10c72c" translate="yes" xml:space="preserve">
          <source>CHANGES</source>
          <target state="translated">CHANGES</target>
        </trans-unit>
        <trans-unit id="77e515bcbeea42a381522b3f02fc083d411a62f5" translate="yes" xml:space="preserve">
          <source>CHARACTER CLASSES</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="a375cca9c609e8591d1c22cf8e8a8c4bbd0e6f6f" translate="yes" xml:space="preserve">
          <source>CHARMAP starts the character map section. Each line has a form as follows:</source>
          <target state="translated">CHARMAP은 문자표 섹션을 시작합니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd3cbf6697996c51d6a64a08ee8b874fefe67b" translate="yes" xml:space="preserve">
          <source>CHARNAME</source>
          <target state="translated">CHARNAME</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="0a228e95208b8ea7acb00589cdd0f311e92f3483" translate="yes" xml:space="preserve">
          <source>CHECKSUM FUNCTIONS</source>
          <target state="translated">체크섬 기능</target>
        </trans-unit>
        <trans-unit id="0d2dc3d6989d0491c087fdf8b26389f6609dba54" translate="yes" xml:space="preserve">
          <source>CLASS METHODS</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="3a8f000aa3840296550580880a88660b74717610" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;safe_quote ITEM</source>
          <target state="translated">CLASS-&amp;gt; safe_quote 항목</target>
        </trans-unit>
        <trans-unit id="2a5520b8514a16a64037e86c211cbd6b6bfdc1cb" translate="yes" xml:space="preserve">
          <source>CLASSES</source>
          <target state="translated">CLASSES</target>
        </trans-unit>
        <trans-unit id="eb2ed6b6d36f266377a9e30f6e145c7fdae07a3f" translate="yes" xml:space="preserve">
          <source>CLONEf_CLONE_HOST - This is a win32 thing, it is ignored on unix, it tells perls win32host code (which is c++) to clone itself, this is needed on win32 if you want to run two threads at the same time, if you just want to do some stuff in a separate perl interpreter and then throw it away and return to the original one, you don't need to do anything.</source>
          <target state="translated">CLONEf_CLONE_HOST-이것은 win32 일이며, 유닉스에서는 무시되고 perls win32host 코드 (c ++)에게 스스로 복제하도록 지시합니다. 이것은 두 스레드를 동시에 실행하려는 경우 win32에서 필요합니다. 별도의 펄 통역사에서 몇 가지 일을 한 다음 버리고 원래의 것으로 돌아 가면 아무것도 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dd06954f8504852be625e8b13f9f38ba4df5c2d" translate="yes" xml:space="preserve">
          <source>CLONEf_COPY_STACKS - is used to, well, copy the stacks also, without it we only clone the data and zero the stacks, with it we copy the stacks and the new perl interpreter is ready to run at the exact same point as the previous one. The pseudo-fork code uses COPY_STACKS while the threads-&amp;gt;create doesn't.</source>
          <target state="translated">CLONEf_COPY_STACKS-스택을 복사하지 않고 데이터를 복제하고 스택을 0으로 만드는 데 사용됩니다. 스택을 복사하면 새로운 perl 인터프리터가 이전과 정확히 같은 시점에서 실행될 수 있습니다. 의사 포크 코드는 COPY_STACKS를 사용하지만 쓰레드-&amp;gt; 만들기는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="496d69294e21b9e9459d9ae5f134da2961a69331" translate="yes" xml:space="preserve">
          <source>CLONEf_KEEP_PTR_TABLE - perl_clone keeps a ptr_table with the pointer of the old variable as a key and the new variable as a value, this allows it to check if something has been cloned and not clone it again but rather just use the value and increase the refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill the ptr_table using the function &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; , reason to keep it around is if you want to dup some of your own variable who are outside the graph perl scans, example of this code is in threads.xs create.</source>
          <target state="translated">CLONEf_KEEP_PTR_TABLE-perl_clone은 이전 변수의 포인터를 키로 사용하고 새 변수를 값으로 사용하여 ptr_table을 유지합니다. 이는 무언가가 복제되었는지 다시 확인하지 않고 값을 사용하고 오히려 값을 사용하고 참조 횟수를 증가시킵니다. KEEP_PTR_TABLE을 설정하지 않으면 perl_clone은 &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; 함수를 사용하여 ptr_table을 종료합니다. PL_ptr_table = NULL; , 그것을 유지하는 이유는 그래프 perl 스캔 외부에있는 자신의 변수 중 일부를 두 드리려는 경우이 코드의 예는 threads.xs create에 있습니다.</target>
        </trans-unit>
        <trans-unit id="439fbcbebff5d3e18e9cd1652b960a8b5958c8fb" translate="yes" xml:space="preserve">
          <source>CMD.EXE</source>
          <target state="translated">CMD.EXE</target>
        </trans-unit>
        <trans-unit id="b7f8b1aaa4e3518d65a63cc4b574d3a502b21354" translate="yes" xml:space="preserve">
          <source>CMD_ERROR</source>
          <target state="translated">CMD_ERROR</target>
        </trans-unit>
        <trans-unit id="b9c1aaaf65573c7e15b93b6d826729e7711cf242" translate="yes" xml:space="preserve">
          <source>CNAME</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="8a81c4f5d7ebf0af1540db862699627a91092359" translate="yes" xml:space="preserve">
          <source>CODE EXAMPLES</source>
          <target state="translated">코드 예</target>
        </trans-unit>
        <trans-unit id="e00c531b83778b8e9867578bc4976f46546c5a61" translate="yes" xml:space="preserve">
          <source>CODE REFERENCES</source>
          <target state="translated">코드 참조</target>
        </trans-unit>
        <trans-unit id="440677eb0b9f2ced4b57b4cf4a1f2a4041acaf2f" translate="yes" xml:space="preserve">
          <source>CODE reference. The subroutine should return a hash reference. The hash may contain further attributes, e.g. {LIBS =&amp;gt; ...}, that have to be determined by some evaluation method.</source>
          <target state="translated">코드 참조. 서브 루틴은 해시 참조를 리턴해야합니다. 해시는 일부 평가 방법으로 결정해야하는 추가 속성 (예 : {LIBS =&amp;gt; ...})을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f975202aa1b4783c29e4937429d2b66fab5169e" translate="yes" xml:space="preserve">
          <source>CODE: directive is used which sets ST(0) explicitly.</source>
          <target state="translated">CODE : ST (0)을 명시 적으로 설정하는 지시문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a38ee1d9bd08c8be0112c20a3c4f3c5309ce957" translate="yes" xml:space="preserve">
          <source>COMMAND.COM</source>
          <target state="translated">COMMAND.COM</target>
        </trans-unit>
        <trans-unit id="c13bbfcc6932afed8045a8c6d2be122bbea2f4a3" translate="yes" xml:space="preserve">
          <source>COMMON CHARACTER CODE SETS</source>
          <target state="translated">공통 문자 코드 세트</target>
        </trans-unit>
        <trans-unit id="3565dc34b7a16c1ebb52c1be4a3b9554d589b634" translate="yes" xml:space="preserve">
          <source>COMMON MISTAKES</source>
          <target state="translated">흔한 실수</target>
        </trans-unit>
        <trans-unit id="d3bd9328431af889713253c0fe82cf459fd62fdd" translate="yes" xml:space="preserve">
          <source>COMMON PITFALLS</source>
          <target state="translated">공통의 사소</target>
        </trans-unit>
        <trans-unit id="3b75e36fb6f8799ec17d763957648965ceb0bf19" translate="yes" xml:space="preserve">
          <source>COMMON PROBLEMS</source>
          <target state="translated">일반적인 문제</target>
        </trans-unit>
        <trans-unit id="3631d60b3c3dad75e7023cf75ede2d8db90dced0" translate="yes" xml:space="preserve">
          <source>COMMON QUESTIONS</source>
          <target state="translated">일반적인 질문</target>
        </trans-unit>
        <trans-unit id="5931c475df95ba4c0e69e8680b4b2746d7dcadbd" translate="yes" xml:space="preserve">
          <source>COMPATIBILITY</source>
          <target state="translated">COMPATIBILITY</target>
        </trans-unit>
        <trans-unit id="1b93c2f6af1a728937d801492e8514e231fe859d" translate="yes" xml:space="preserve">
          <source>COMPILING AND INSTALLING PERL ON PLAN 9</source>
          <target state="translated">계획 9에서 Perl 컴파일 및 설치</target>
        </trans-unit>
        <trans-unit id="a3dbb0f2d743369125c33547e4a98f6e69c718ea" translate="yes" xml:space="preserve">
          <source>COMPRESS/UNCOMPRESS</source>
          <target state="translated">COMPRESS/UNCOMPRESS</target>
        </trans-unit>
        <trans-unit id="dbbd6e677093ab33626116ddbe95a8116b822da0" translate="yes" xml:space="preserve">
          <source>CONCEPTS</source>
          <target state="translated">CONCEPTS</target>
        </trans-unit>
        <trans-unit id="ce2288334f1137f427c025bf4db30086aa2e6ccd" translate="yes" xml:space="preserve">
          <source>CONCLUSION</source>
          <target state="translated">CONCLUSION</target>
        </trans-unit>
        <trans-unit id="54b45ea0b830c111f200238254cbe142d992ceb9" translate="yes" xml:space="preserve">
          <source>CONCURRENT ACCESS TO FILES</source>
          <target state="translated">파일에 대한 동시 액세스</target>
        </trans-unit>
        <trans-unit id="b6e52e4d80314fc8a5ba1a7faeb4aa6cd672bec0" translate="yes" xml:space="preserve">
          <source>CONFIGURATION</source>
          <target state="translated">CONFIGURATION</target>
        </trans-unit>
        <trans-unit id="0bcdf5cc47cad9c41938edcc7524d271413daa98" translate="yes" xml:space="preserve">
          <source>CONFIGURE PERL ON CYGWIN</source>
          <target state="translated">CYGWIN에서 PERL 구성</target>
        </trans-unit>
        <trans-unit id="86446751ae319594b5e453b782ebdfc8c4bf543b" translate="yes" xml:space="preserve">
          <source>CONFIGURING</source>
          <target state="translated">CONFIGURING</target>
        </trans-unit>
        <trans-unit id="65df4be803801cf76d0b33102b49347c0f49a265" translate="yes" xml:space="preserve">
          <source>CONSTANTS</source>
          <target state="translated">CONSTANTS</target>
        </trans-unit>
        <trans-unit id="9d4cd9e346a27cff016ae855f03e070521487596" translate="yes" xml:space="preserve">
          <source>CONSTRUCT</source>
          <target state="translated">CONSTRUCT</target>
        </trans-unit>
        <trans-unit id="6ed66fd18a1b175704db533d3865fa2679863e6d" translate="yes" xml:space="preserve">
          <source>CONSTRUCTOR</source>
          <target state="translated">CONSTRUCTOR</target>
        </trans-unit>
        <trans-unit id="740fabb870d6ed652cd56a6f6b4cabc2048431f9" translate="yes" xml:space="preserve">
          <source>CONTACT</source>
          <target state="translated">CONTACT</target>
        </trans-unit>
        <trans-unit id="6eb1660530253dbbb9bc0adce6c7c2db98f6c11e" translate="yes" xml:space="preserve">
          <source>CONTRIBUTED MODULES</source>
          <target state="translated">기여한 모듈</target>
        </trans-unit>
        <trans-unit id="c00c0afca84109e3fb2b98c8209ef559a912b256" translate="yes" xml:space="preserve">
          <source>CONTRIBUTORS</source>
          <target state="translated">CONTRIBUTORS</target>
        </trans-unit>
        <trans-unit id="3c270e7e648d60e989f665180ac5841d2f501b46" translate="yes" xml:space="preserve">
          <source>CONTROLLING LOOKUP FAILURE</source>
          <target state="translated">루킹 실패 제어</target>
        </trans-unit>
        <trans-unit id="56e1ec5824af8dff3fb44acbb1f5889b6031d924" translate="yes" xml:space="preserve">
          <source>CONVENTIONS</source>
          <target state="translated">CONVENTIONS</target>
        </trans-unit>
        <trans-unit id="bb5de08378fdc79cf1e8f681e4066f1cb85bb028" translate="yes" xml:space="preserve">
          <source>CONVERSIONS</source>
          <target state="translated">CONVERSIONS</target>
        </trans-unit>
        <trans-unit id="e1146aff355e08a86787f760b889571c858e8593" translate="yes" xml:space="preserve">
          <source>COOKBOOK</source>
          <target state="translated">COOKBOOK</target>
        </trans-unit>
        <trans-unit id="9510141c24a403496c1dfba8b0ab986988f95879" translate="yes" xml:space="preserve">
          <source>COORDINATE SYSTEMS</source>
          <target state="translated">코디네이트 시스템</target>
        </trans-unit>
        <trans-unit id="c51ce576d0d85de4e554620a3b7e0dd309045090" translate="yes" xml:space="preserve">
          <source>COP Hint Hashes</source>
          <target state="translated">순경 힌트 해시</target>
        </trans-unit>
        <trans-unit id="22ad88b10bee537423c13139a4d2b08d579efc3e" translate="yes" xml:space="preserve">
          <source>COP Hint Reading</source>
          <target state="translated">경찰 힌트 읽기</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="9c7e4e94b44caac6a4f40ca3467d6883ed67cf24" translate="yes" xml:space="preserve">
          <source>COPYRIGHT &amp;amp; LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="fd93171470739cb1a4e64e6ea953d8c1dd9e7c3a" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMER</source>
          <target state="translated">저작권 및 부인</target>
        </trans-unit>
        <trans-unit id="aed47af09308ae3a4fa8a24efc25bc20b8d6091d" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMERS</source>
          <target state="translated">저작권 및 면책 조항</target>
        </trans-unit>
        <trans-unit id="0524ce058903ad04ed18326112dd9695f4ac4f56" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENCE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="d7f1de266854e2b8d4c927372f1242e7739925ed" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="8c9b991a9d45dee993d0ee634ba8eafd7815c6a3" translate="yes" xml:space="preserve">
          <source>COPYRIGHT and LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="6d917c2df32bb3f8fb6b5f8e529bb779c3dca6f7" translate="yes" xml:space="preserve">
          <source>CORE</source>
          <target state="translated">CORE</target>
        </trans-unit>
        <trans-unit id="9f2a7e4446d753ffa86ebd32d2855d851f9cf12a" translate="yes" xml:space="preserve">
          <source>CORE - Namespace for Perl's core routines</source>
          <target state="translated">핵심-Perl의 핵심 루틴을위한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="a6110e98d6d5509cfa9c7e73794ab71e46a695de" translate="yes" xml:space="preserve">
          <source>CPAN - query, download and build perl modules from CPAN sites</source>
          <target state="translated">CPAN-CPAN 사이트에서 펄 모듈 조회, 다운로드 및 빌드</target>
        </trans-unit>
        <trans-unit id="f5cb991183e9576ae99c7af8774c4d59270235f0" translate="yes" xml:space="preserve">
          <source>CPAN TESTERS AND PERL SMOKERS</source>
          <target state="translated">CPAN 테스터 및 펄 스모커</target>
        </trans-unit>
        <trans-unit id="b04380d2ad945f75e3aa967dafb36ed58ba766cd" translate="yes" xml:space="preserve">
          <source>CPAN Testers</source>
          <target state="translated">CPAN 테스터</target>
        </trans-unit>
        <trans-unit id="01505e76b90321ebd4493c61034cb8a884911e63" translate="yes" xml:space="preserve">
          <source>CPAN also keeps track of what it has done within the current session and doesn't try to build a package a second time regardless of whether it succeeded or not. It does not repeat a test run if the test has been run successfully before. Same for install runs.</source>
          <target state="translated">CPAN은 또한 현재 세션 내에서 수행 한 작업을 추적하며 성공 여부에 관계없이 패키지를 다시 빌드하려고 시도하지 않습니다. 테스트가 이전에 성공적으로 실행 된 경우 테스트 실행을 반복하지 않습니다. 설치 실행과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d978419581e9be6ec9c55f53ba43e4e7f68766bd" translate="yes" xml:space="preserve">
          <source>CPAN can now help you select a &quot;good&quot; mirror, based on which ones have the lowest 'ping' round-trip times. From the shell, use the command 'o conf init urllist' and allow CPAN to automatically select mirrors for you.</source>
          <target state="translated">CPAN은 왕복 시간이 가장 적은 '핑'미러를 기준으로 &quot;좋은&quot;미러를 선택하는 데 도움을 줄 수 있습니다. 쉘에서 'o conf init urllist'명령을 사용하고 CPAN이 자동으로 미러를 선택하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f419c26e2ea47eba870171b0304a0f12d770bcb" translate="yes" xml:space="preserve">
          <source>CPAN can provide the best examples. &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;, &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test::Exception&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test::Differences&lt;/a&gt; all use Test::Builder.</source>
          <target state="translated">CPAN이 가장 좋은 예를 제공 할 수 있습니다. &lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt; , &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test :: Exception&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test :: Differences는&lt;/a&gt; 모두 Test :: Builder를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9b25cd0f5375c5eab72f3ffe3e62897e52e03cea" translate="yes" xml:space="preserve">
          <source>CPAN checks whether an install is needed and prints</source>
          <target state="translated">CPAN은 설치가 필요한지 확인하고 인쇄</target>
        </trans-unit>
        <trans-unit id="d5ac7dd05001d7d37e2f43d1797c997c4df20e68" translate="yes" xml:space="preserve">
          <source>CPAN has several JAPH programs at &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh&lt;/a&gt;.</source>
          <target state="translated">CPAN에는 &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh에&lt;/a&gt; 여러 JAPH 프로그램이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73829bcf0ad0c4b896f34810c840c5f0243a137e" translate="yes" xml:space="preserve">
          <source>CPAN module &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">CPAN 모듈 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec0e8e76dd47186c4a257a69793cc4b0fbd9812e" translate="yes" xml:space="preserve">
          <source>CPAN packages can be digitally signed by authors and thus verified with the security provided by strong cryptography. The exact mechanism is defined in the Module::Signature module. While this is generally considered a good thing, it is not always convenient to the end user to install modules that are signed incorrectly or where the key of the author is not available or where some prerequisite for Module::Signature has a bug and so on.</source>
          <target state="translated">CPAN 패키지는 작성자가 디지털 서명하여 강력한 암호화가 제공하는 보안으로 확인할 수 있습니다. 정확한 메커니즘은 Module :: Signature 모듈에 정의되어 있습니다. 이것은 일반적으로 좋은 것으로 간주되지만 최종 사용자가 서명이 잘못되었거나 작성자의 키를 사용할 수 없거나 Module :: Signature의 전제 조건에 버그가있는 모듈을 설치하는 것이 항상 편리한 것은 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="b51337fb370844b9eff5cf2f0d2334791161629e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network, a multi-gigabyte archive replicated on hundreds of machines all over the world. CPAN contains tens of thousands of modules and extensions, source code and documentation, designed for</source>
          <target state="translated">CPAN은 전 세계 수백 대의 머신에 복제 된 멀티 기가 바이트 아카이브 인 포괄적 인 Perl Archive Network의 약자입니다. CPAN에는 수만 개의 모듈과 확장, 소스 코드 및 설명서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a083d1c70360c499c212a22f42c02ebc10a2b7e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network; it's a globally replicated trove of Perl materials, including documentation, style guides, tricks and traps, alternate ports to non-Unix systems and occasional binary distributions for these. Search engines for CPAN can be found at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</source>
          <target state="translated">CPAN은 포괄적 인 Perl Archive Network의 약자입니다. 문서, 스타일 가이드, 트릭 및 트랩, 비 Unix 시스템의 대체 포트 및 때때로 바이너리 배포를 포함하여 전 세계적으로 복제 된 Perl 자료입니다. CPAN의 검색 엔진은 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11b7513cf5ed0783e222931555703c39249404ca" translate="yes" xml:space="preserve">
          <source>CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be asked any questions at all (assuming the modules you are installing are nice about obeying that variable as well):</source>
          <target state="translated">CPAN은 ExtUtils :: MakeMaker의 prompt () 함수를 사용하여 질문을합니다. 따라서 PERL_MM_USE_DEFAULT 환경 변수를 설정하면 전혀 질문하지 않아도됩니다 (설치중인 모듈이 해당 변수를 준수하는 것이 좋다고 가정). :</target>
        </trans-unit>
        <trans-unit id="763ab2cd14f13622b64f1d364ae89ff5e930c5e0" translate="yes" xml:space="preserve">
          <source>CPAN version is currently maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;.</source>
          <target state="translated">CPAN 버전은 현재 S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;에서 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d022fca84f913595d0e465957aa3ec07aa26e29a" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden이 제작 한 CPAN 버전 &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="df1b7ad617e594d1fcea7ef95394577f7d4285ee" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</source>
          <target state="translated">Jerry D. Hedden이 제작 한 CPAN 버전 &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="a3c7ec93761c4b99669cfe3abe56f987f4d86e7b" translate="yes" xml:space="preserve">
          <source>CPAN, or the Comprehensive Perl Archive Network &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, is a replicated, worldwide repository of Perl software. See &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;What is CPAN?&lt;/a&gt;.</source>
          <target state="translated">CPAN (Comprehensive Perl Archive Network) &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 는 전 세계적으로 복제 된 Perl 소프트웨어 저장소입니다. &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;CPAN이란 무엇입니까?를&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="d24df83c42548921d5e891bad0ec265b58c5632b" translate="yes" xml:space="preserve">
          <source>CPAN.pm</source>
          <target state="translated">CPAN.pm</target>
        </trans-unit>
        <trans-unit id="df07d81df98f66bb5cc686dd3a7b7369a164da96" translate="yes" xml:space="preserve">
          <source>CPAN.pm can introduce some randomness when using hosts for download that are configured in the urllist parameter. Enter a numeric value between 0 and 1 to indicate how often you want to let CPAN.pm try a random host from the urllist. A value of one specifies to always use a random host as the first try. A value of zero means no randomness at all. Anything in between specifies how often, on average, a random host should be tried first.</source>
          <target state="translated">CPAN.pm은 urllist 매개 변수에 구성된 다운로드 용 호스트를 사용할 때 임의성을 유발할 수 있습니다. CPAN.pm이 urllist에서 임의의 호스트를 시도하는 빈도를 표시하려면 0과 1 사이의 숫자 값을 입력하십시오. 값 1은 항상 첫 번째 시도로 임의 호스트를 사용하도록 지정합니다. 값이 0이면 임의성이 없음을 의미합니다. 중간에있는 것은 평균적으로 임의 호스트를 먼저 시도해야하는 빈도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8be548e1857808a4c33f06e8483679790bde10ef" translate="yes" xml:space="preserve">
          <source>CPAN.pm can limit the size of the disk area for keeping the build directories with all the intermediate files.</source>
          <target state="translated">CPAN.pm은 빌드 디렉토리를 모든 중간 파일과 함께 유지하기 위해 디스크 영역의 크기를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21743f9fae507577e1ebe77ee42077c588936ab" translate="yes" xml:space="preserve">
          <source>CPAN.pm can store customized build environments based on regular expressions for distribution names. These are YAML files where the default options for CPAN.pm and the environment can be overridden and dialog sequences can be stored that can later be executed by an Expect.pm object. The CPAN.pm distribution comes with some prefab YAML files that cover sample distributions that can be used as blueprints to store your own prefs. Please check out the distroprefs/ directory of the CPAN.pm distribution to get a quick start into the prefs system.</source>
          <target state="translated">CPAN.pm은 배포 이름에 대한 정규식을 기반으로 사용자 정의 된 빌드 환경을 저장할 수 있습니다. 이들은 CPAN.pm 및 환경에 대한 기본 옵션을 대체하고 나중에 Expect.pm 오브젝트가 실행할 수있는 대화 상자 순서를 저장할 수있는 YAML 파일입니다. CPAN.pm 배포판에는 자체 사전 설정을 저장하기위한 청사진으로 사용할 수있는 샘플 배포판을 포괄하는 일부 조립식 YAML 파일이 제공됩니다. prefs 시스템을 빠르게 시작하려면 CPAN.pm 배포판의 distroprefs / 디렉토리를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fe8999832e8cb3e24c5ee5786438c2eb7045f528" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. By default it uses Cwd::cwd, but if for some reason this doesn't work on your system, configure alternatives according to the following table:</source>
          <target state="translated">CPAN.pm은 현재 작업 디렉토리를 자주 변경하며 자체 현재 작업 디렉토리를 결정해야합니다. 기본적으로 Cwd :: cwd를 사용하지만 어떤 이유로 시스템에서 작동하지 않으면 다음 표에 따라 대안을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="110953d17daedc5ab884b800e79aa6017f230c3c" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. Per default it uses Cwd::cwd but if this doesn't work on your system for some reason, alternatives can be configured according to the following table:</source>
          <target state="translated">CPAN.pm은 현재 작업 디렉토리를 자주 변경하며 자체 현재 작업 디렉토리를 결정해야합니다. 기본적으로 Cwd :: cwd를 사용하지만 어떤 이유로 시스템에서 작동하지 않으면 다음 표에 따라 대안을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316ae9b3e749a01c06c792f2cfcc80c4846f19f6" translate="yes" xml:space="preserve">
          <source>CPAN.pm ignores SIGPIPE. If the user sets &lt;code&gt;inactivity_timeout&lt;/code&gt; , a SIGALRM is used during the run of the &lt;code&gt;perl Makefile.PL&lt;/code&gt; or &lt;code&gt;perl
Build.PL&lt;/code&gt; subprocess. A SIGALRM is also used during module version parsing, and is controlled by &lt;code&gt;version_timeout&lt;/code&gt; .</source>
          <target state="translated">CPAN.pm은 SIGPIPE를 무시합니다. 사용자가 &lt;code&gt;inactivity_timeout&lt;/code&gt; 을 설정 하면 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 또는 &lt;code&gt;perl Build.PL&lt;/code&gt; 서브 프로세스 실행 중에 SIGALRM이 사용됩니다 . SIGALRM은 모듈 버전 구문 분석 중에도 사용되며 &lt;code&gt;version_timeout&lt;/code&gt; 에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="190c010b5387bba4ea2b42cb563bd4dbf19face7" translate="yes" xml:space="preserve">
          <source>CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are in the cpan-shell, it is intended that you can press &lt;code&gt;^C&lt;/code&gt; anytime and return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell to clean up and leave the shell loop. You can emulate the effect of a SIGTERM by sending two consecutive SIGINTs, which usually means by pressing &lt;code&gt;^C&lt;/code&gt; twice.</source>
          <target state="translated">CPAN.pm은 SIGINT 및 SIGTERM에 대한 신호 핸들러를 설치합니다. cpan-shell에있는 동안 언제든지 &lt;code&gt;^C&lt;/code&gt; 누르고 cpan-shell 프롬프트로 돌아갈 수 있습니다. SIGTERM은 cpan-shell을 정리하고 쉘 루프를 떠나게합니다. 두 개의 연속 SIGINT를 보내서 SIGTERM의 효과를 에뮬레이션 할 수 있습니다. 일반적으로 &lt;code&gt;^C&lt;/code&gt; 두 번 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="74c9de97c18d0f26d42b5dbeeae85623299ae97e" translate="yes" xml:space="preserve">
          <source>CPAN.pm is regularly tested to run under 5.005 and assorted newer versions. It is getting more and more difficult to get the minimal prerequisites working on older perls. It is close to impossible to get the whole Bundle::CPAN working there. If you're in the position to have only these old versions, be advised that CPAN is designed to work fine without the Bundle::CPAN installed.</source>
          <target state="translated">CPAN.pm은 정기적으로 5.005 및 최신 버전으로 실행되도록 테스트되었습니다. 오래된 perls에서 최소한의 전제 조건을 작동시키는 것이 점점 어려워지고 있습니다. 전체 Bundle :: CPAN을 작동시키는 것은 거의 불가능합니다. 이러한 이전 버전 만 사용할 수있는 위치에있는 경우 CPAN은 번들 :: CPAN을 설치하지 않아도 제대로 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="9dede3b8abe89d4a573f74c512265cae8a956106" translate="yes" xml:space="preserve">
          <source>CPAN.pm will then fetch the index files from one of the CPAN sites that come at the beginning of urllist. It will later check for each module to see whether there is a local copy of the most recent version.</source>
          <target state="translated">그러면 CPAN.pm은 urllist의 시작 부분에있는 CPAN 사이트 중 하나에서 색인 파일을 가져옵니다. 나중에 각 모듈에서 최신 버전의 로컬 사본이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2867ea997c1ecbeaa882b9d340cc76b94bdae145" translate="yes" xml:space="preserve">
          <source>CPAN.pm works nicely without network access, too. If you maintain machines that are not networked at all, you should consider working with &lt;code&gt;file:&lt;/code&gt; URLs. You'll have to collect your modules somewhere first. So you might use CPAN.pm to put together all you need on a networked machine. Then copy the $CPAN::Config-&amp;gt;{keep_source_where} (but not $CPAN::Config-&amp;gt;{build_dir}) directory on a floppy. This floppy is kind of a personal CPAN. CPAN.pm on the non-networked machines works nicely with this floppy. See also below the paragraph about CD-ROM support.</source>
          <target state="translated">CPAN.pm은 네트워크 액세스 없이도 잘 작동합니다. 네트워크로 연결되지 않은 시스템을 유지 관리하는 경우 &lt;code&gt;file:&lt;/code&gt; URL 작업을 고려해야 합니다. 먼저 어딘가에 모듈을 수집해야합니다. 따라서 CPAN.pm을 사용하여 네트워크 컴퓨터에 필요한 모든 것을 구성 할 수 있습니다. 그런 다음 $ CPAN :: Config-&amp;gt; {keep_source_where} ($ CPAN :: Config-&amp;gt; {build_dir} 아님) 디렉토리를 플로피에 복사하십시오. 이 플로피는 일종의 개인 CPAN입니다. 네트워크에 연결되지 않은 컴퓨터의 CPAN.pm은이 플로피와 잘 작동합니다. CD-ROM 지원에 관한 아래 단락도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64b36001560d3fac13b876398b3f1a59def99f26" translate="yes" xml:space="preserve">
          <source>CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution inherit this method. It prints the data structure associated with an object. Useful for debugging. Note: the data structure is considered internal and thus subject to change without notice.</source>
          <target state="translated">CPAN :: Author, CPAN :: Bundle, CPAN :: Module 및 CPAN :: Distribution은이 메소드를 상속합니다. 객체와 관련된 데이터 구조를 인쇄합니다. 디버깅에 유용합니다. 참고 : 데이터 구조는 내부로 간주되므로 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2446a32cd0ff78f16b4c1f3133beeac56c5f5898" translate="yes" xml:space="preserve">
          <source>CPAN::Debug</source>
          <target state="translated">CPAN::Debug</target>
        </trans-unit>
        <trans-unit id="3cc1933835ca0280363968e304f73c0a15112e4c" translate="yes" xml:space="preserve">
          <source>CPAN::Debug - internal debugging for CPAN.pm</source>
          <target state="translated">CPAN :: Debug-CPAN.pm의 내부 디버깅</target>
        </trans-unit>
        <trans-unit id="8d7cc75d89d8c3bb9bd4511533d5eed2ec9484af" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs</source>
          <target state="translated">CPAN::Distroprefs</target>
        </trans-unit>
        <trans-unit id="80ea37d944a5515b88dd77f972d31b6df3134129" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs -- read and match distroprefs</source>
          <target state="translated">CPAN :: Distroprefs-분산 참조를 읽고 일치</target>
        </trans-unit>
        <trans-unit id="5bcd04a88f701c432b5a1ff104f6c8a0d02960ee" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs::Pref objects represent individual distroprefs documents. They are constructed automatically as part of &lt;code&gt;success&lt;/code&gt; results from &lt;code&gt;find()&lt;/code&gt; .</source>
          <target state="translated">CPAN :: Distroprefs :: Pref 객체는 개별 distroprefs 문서를 나타냅니다. &lt;code&gt;find()&lt;/code&gt; 의 &lt;code&gt;success&lt;/code&gt; 결과의 일부로 자동 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2f3edd9da9fa97ece6eafd83608b4b243b452a0" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime</source>
          <target state="translated">CPAN::FirstTime</target>
        </trans-unit>
        <trans-unit id="78dc35292a9ffa84e8778b2bc228974b2a98a06d" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime - Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN :: FirstTime-CPAN :: Config 파일 초기화 유틸리티</target>
        </trans-unit>
        <trans-unit id="e737cd6e08d40b3a667635e5cb83727e8679bd6f" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime::init()</source>
          <target state="translated">CPAN::FirstTime::init()</target>
        </trans-unit>
        <trans-unit id="85ea935cb2e14666fd64cb017917705b1d6fede5" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig</source>
          <target state="translated">CPAN::HandleConfig</target>
        </trans-unit>
        <trans-unit id="24310cde90de0fb64790326e96a727677d4e7601" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig - internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN :: HandleConfig-CPAN.pm의 내부 구성 처리</target>
        </trans-unit>
        <trans-unit id="64057ceb28c792089f8152cbd3da3bcade5223e9" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify</source>
          <target state="translated">CPAN::Kwalify</target>
        </trans-unit>
        <trans-unit id="a2e5f91adff087cfa00a37e97d84ee7727243629" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify - Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN :: Kwalify-CPAN.pm과 Kwalify.pm 사이의 인터페이스</target>
        </trans-unit>
        <trans-unit id="8dcc2e6edc3eadab9e78355482bf7252fe18e3ff" translate="yes" xml:space="preserve">
          <source>CPAN::Nox</source>
          <target state="translated">CPAN::Nox</target>
        </trans-unit>
        <trans-unit id="0b944fc036709f45e2abf674dd21a2de916a71a8" translate="yes" xml:space="preserve">
          <source>CPAN::Nox - Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">CPAN :: Nox-XS 모듈을 사용하지 않고 CPAN.pm을 감싸는 래퍼</target>
        </trans-unit>
        <trans-unit id="cff38ba28ab3cfea4d0464d49309db8969faf6ef" translate="yes" xml:space="preserve">
          <source>CPAN::Queue</source>
          <target state="translated">CPAN::Queue</target>
        </trans-unit>
        <trans-unit id="e3a09726a6ba57409ab3f10ea87af46541484c9f" translate="yes" xml:space="preserve">
          <source>CPAN::Queue - internal queue support for CPAN.pm</source>
          <target state="translated">CPAN :: Queue-CPAN.pm에 대한 내부 큐 지원</target>
        </trans-unit>
        <trans-unit id="349e923ec9cc993c3c5c400728886a4cd805bc87" translate="yes" xml:space="preserve">
          <source>CPAN::SQLite is a layer between the index files that are downloaded from the CPAN and CPAN.pm that speeds up metadata queries and reduces memory consumption of CPAN.pm considerably.</source>
          <target state="translated">CPAN :: SQLite는 CPAN과 CPAN.pm에서 다운로드 한 인덱스 파일 사이의 계층으로 메타 데이터 쿼리 속도를 높이고 CPAN.pm의 메모리 소비를 상당히 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b47dcd8919f1f65cec06b9c2d7f965e75c2b1219" translate="yes" xml:space="preserve">
          <source>CPAN::Shell</source>
          <target state="translated">CPAN::Shell</target>
        </trans-unit>
        <trans-unit id="23798a7b15a5d75dd8c6bdfc98d7078c277c16e8" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip</source>
          <target state="translated">CPAN::Tarzip</target>
        </trans-unit>
        <trans-unit id="814fdd5396978409421856089181c07c58c4c4cf" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip - internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN :: Tarzip-CPAN.pm에 대한 tar 아카이브의 내부 처리</target>
        </trans-unit>
        <trans-unit id="4901e7156541948e262f8f5d98071d2c7b3b87e3" translate="yes" xml:space="preserve">
          <source>CPAN::Version</source>
          <target state="translated">CPAN::Version</target>
        </trans-unit>
        <trans-unit id="30cd4b0821f4765c0d8295e7726cfae9b7fab40e" translate="yes" xml:space="preserve">
          <source>CPAN::Version - utility functions to compare CPAN versions</source>
          <target state="translated">CPAN :: Version-CPAN 버전을 비교하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="ec4a1634792e6ece098aa09e476bc1d9ef4268d0" translate="yes" xml:space="preserve">
          <source>CPAN::anycwd($path): Note on config variable getcwd</source>
          <target state="translated">CPAN :: anycwd ($ path) : 구성 변수 getcwd에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="6bf4457df819c8d2b082c5c17c609ae27bb6a63b" translate="yes" xml:space="preserve">
          <source>CPAN::shell([$prompt, $command]) Starting Interactive Mode</source>
          <target state="translated">CPAN :: shell ([$ prompt, $ command]) 대화식 모드 시작</target>
        </trans-unit>
        <trans-unit id="4ffdbed7690fc2f38db76dd54cf504d79c06ee88" translate="yes" xml:space="preserve">
          <source>CPANMINUS</source>
          <target state="translated">CPANMINUS</target>
        </trans-unit>
        <trans-unit id="0300a08f28f15d52b8c0f31d868e80fadb408109" translate="yes" xml:space="preserve">
          <source>CPANPLUS</source>
          <target state="translated">CPANPLUS</target>
        </trans-unit>
        <trans-unit id="4a2648ee2c7cdfe4f04963290c94c0f73b1a0296" translate="yes" xml:space="preserve">
          <source>CPU seconds is, in UNIX terms, the user time plus the system time of the process itself, as opposed to the real (wallclock) time and the time spent by the child processes. Less than 0.1 seconds is not accepted (-0.01 as the count, for example, will cause a fatal runtime exception).</source>
          <target state="translated">CPU 초는 UNIX 용어로, 사용자 시간과 프로세스 자체의 시스템 시간을 더한 것입니다 (실시간 (벽시계) 시간 및 하위 프로세스가 소비 한 시간). 0.1 초 미만은 허용되지 않습니다 (예 : -0.01을 카운트로하면 치명적인 런타임 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="8eabeaf9c51703b78032cab60996509e2a9fbc29" translate="yes" xml:space="preserve">
          <source>CPU time</source>
          <target state="translated">CPU 시간</target>
        </trans-unit>
        <trans-unit id="ceae75038d81d55818f9c7099cc499bef29e500c" translate="yes" xml:space="preserve">
          <source>CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE</source>
          <target state="translated">별도의 실행 파일로 소스 필터 생성</target>
        </trans-unit>
        <trans-unit id="8f5fc61f95a802dc2f2c87590b81afa3dc2d9f36" translate="yes" xml:space="preserve">
          <source>CREATION</source>
          <target state="translated">CREATION</target>
        </trans-unit>
        <trans-unit id="338f52baadf832c435e6693a6b1e770c010b5681" translate="yes" xml:space="preserve">
          <source>CREDITS</source>
          <target state="translated">CREDITS</target>
        </trans-unit>
        <trans-unit id="4b79357f1f7c4a8b8c01c419e8cd32de82816fa7" translate="yes" xml:space="preserve">
          <source>CROSS-COMPILATION</source>
          <target state="translated">CROSS-COMPILATION</target>
        </trans-unit>
        <trans-unit id="5ff3994b10db2ad29d009f4ea60878f1dbf5c21e" translate="yes" xml:space="preserve">
          <source>CURRENT BUILD INSTRUCTIONS</source>
          <target state="translated">현재 건물 지침</target>
        </trans-unit>
        <trans-unit id="f132b454c07ac52e508f217f0add8bd7ce5fa710" translate="yes" xml:space="preserve">
          <source>CUSTOM ALIASES</source>
          <target state="translated">고객 별명</target>
        </trans-unit>
        <trans-unit id="566216bf858af2148e9f96bcf3257d2d54bc9983" translate="yes" xml:space="preserve">
          <source>CUSTOM TRANSLATORS</source>
          <target state="translated">커스텀 번역기</target>
        </trans-unit>
        <trans-unit id="095d16308375c60700e556f5b8f5796ca1925951" translate="yes" xml:space="preserve">
          <source>CV Manipulation Functions</source>
          <target state="translated">CV 조작 기능</target>
        </trans-unit>
        <trans-unit id="2b943e6acf60a6fb581a6a5d00e315120f0f582e" translate="yes" xml:space="preserve">
          <source>CV reference counts and CvOUTSIDE</source>
          <target state="translated">CV 기준 카운트 및 CvOUTSIDE</target>
        </trans-unit>
        <trans-unit id="0c42c13d714fd16e36f14c85f7c7898781594d12" translate="yes" xml:space="preserve">
          <source>CV's can have CvPADLIST(cv) set to point to a PADLIST. This is the CV's scratchpad, which stores lexical variables and opcode temporary and per-thread values.</source>
          <target state="translated">CV는 CvPADLIST (cv)를 PADLIST를 가리 키도록 설정할 수 있습니다. 이것은 CV의 스크래치 패드로 어휘 변수와 opcode 임시 및 스레드 당 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ddb00c36c6d4c35daa72fdd0b44d9c728b39bcfa" translate="yes" xml:space="preserve">
          <source>C_FILE</source>
          <target state="translated">C_FILE</target>
        </trans-unit>
        <trans-unit id="575569dbcc2f1973e29e715e813fbf5f343f083a" translate="yes" xml:space="preserve">
          <source>C_SUBNAME</source>
          <target state="translated">C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="49dd0ee71a9f8c8e59007d14c22f8f02a232442a" translate="yes" xml:space="preserve">
          <source>Cache Manager</source>
          <target state="translated">캐시 관리자</target>
        </trans-unit>
        <trans-unit id="a9fca3e43fd40d529fa1de2b124c4181a70bcb17" translate="yes" xml:space="preserve">
          <source>Cache metadata (yes/no)?</source>
          <target state="translated">캐시 메타 데이터 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="36e2cd82188ed6fa0e4b613f6e68c50033b4f7eb" translate="yes" xml:space="preserve">
          <source>Cache size for build directory (in MB)?</source>
          <target state="translated">빌드 디렉토리의 캐시 크기 (MB)?</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="4216adaca29295eaea61f0fa24c35227b02c6845" translate="yes" xml:space="preserve">
          <source>Caching and deferred writing are inappropriate if you want the same file to be accessed simultaneously from more than one process. Other optimizations performed internally by this module are also incompatible with concurrent access. A future version of this module will support a &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; option that enables safe concurrent access.</source>
          <target state="translated">동일한 파일에 둘 이상의 프로세스에서 동시에 액세스하려면 캐싱 및 지연된 쓰기가 부적절합니다. 이 모듈에서 내부적으로 수행 된 다른 최적화도 동시 액세스와 호환되지 않습니다. 이 모듈의 향후 버전 은 안전한 동시 액세스를 가능하게 하는 &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="66d425679370669a060d7b12eda4e17f2fb01bea" translate="yes" xml:space="preserve">
          <source>Caching is off by default, as it can (usually slightly) decrease accuracy and does not usually noticeably affect runtimes.</source>
          <target state="translated">캐싱은 기본적으로 꺼져 있습니다. 정확도는 (일반적으로 약간) 저하 될 수 있으며 일반적으로 런타임에 눈에 띄게 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81c8c72b5e27066945946d422a802165663f5930" translate="yes" xml:space="preserve">
          <source>Caesarean ciphers</source>
          <target state="translated">제왕 절개 암호</target>
        </trans-unit>
        <trans-unit id="f76942716d4c2528f7cd94b85c359f606e3e15f5" translate="yes" xml:space="preserve">
          <source>Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to &quot;even&quot;.</source>
          <target state="translated">PI를 N 자리로 계산합니다 (점 앞의 3을 포함). 결과는 현재 반올림 모드에 따라 반올림되며 기본값은 &quot;짝수&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ba16d2dfddf095e54ae25bc218255c71ce5afa48" translate="yes" xml:space="preserve">
          <source>Calculate digests of files</source>
          <target state="translated">파일 요약 계산</target>
        </trans-unit>
        <trans-unit id="6edac12b6f864eee888f0c08f462e84fff153f20" translate="yes" xml:space="preserve">
          <source>Calculate the N'th root of $x.</source>
          <target state="translated">$ x의 N 번째 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f7dc98fbb7b43c855859dedd630f45c56ad2bc12" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하여 $ x의 아크 루스 탄젠을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="49fd3457ed632359ca2520e72d6632cb278658b7" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place.</source>
          <target state="translated">의 ARCUS의 tangens 계산 &lt;code&gt;$y&lt;/code&gt; 나눈 &lt;code&gt;$x&lt;/code&gt; 대신 $ Y 수정.</target>
        </trans-unit>
        <trans-unit id="4f94eb38f838a42af1307713af2f7a6e7542c447" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of $x, modifying $x in place. See also &lt;a href=&quot;#batan2()&quot;&gt;batan2()&lt;/a&gt;.</source>
          <target state="translated">$ x를 수정하여 $ x의 arcus tanges를 계산하십시오. &lt;a href=&quot;#batan2()&quot;&gt;batan2 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="982777a50f0c3516dc7b84208808f54a3e72dbea" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place. See also &lt;a href=&quot;#batan()&quot;&gt;batan()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$y&lt;/code&gt; 를 &lt;code&gt;$x&lt;/code&gt; 로 나눈 값을 계산 하여 $ y를 수정합니다. &lt;a href=&quot;#batan()&quot;&gt;batan ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8312c24fc6c367f7ba0626e0df9859355b1ba267" translate="yes" xml:space="preserve">
          <source>Calculate the cosinus of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하여 $ x의 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="01c8c185c9d12673e45f702a2f9d36653ab1f38e" translate="yes" xml:space="preserve">
          <source>Calculate the sinus of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하고 $ x를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="049cf6157b6ee1c242c2800800be8ef0165625bc" translate="yes" xml:space="preserve">
          <source>Calculate the square root of $x.</source>
          <target state="translated">$ x의 제곱근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="d5c08bd3d571674414934d46e315d05c1e757d23" translate="yes" xml:space="preserve">
          <source>Calculates the N'th root of &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x&lt;/code&gt; 의 N 번째 근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2470f12a5e304e7422bd1a2f8c0e1abfd2982a1d" translate="yes" xml:space="preserve">
          <source>Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:</source>
          <target state="translated">&quot;선택&quot;함수라고도하는 k에 대한 이항 계수 n을 계산합니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34e97fbd408b8eed5635c834b2854c0be8cb6dbf" translate="yes" xml:space="preserve">
          <source>Calculates the expression &lt;code&gt;e ** $x&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">식 &lt;code&gt;e ** $x&lt;/code&gt; 계산합니다. 여기서 &lt;code&gt;e&lt;/code&gt; 는 오일러의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="416b7a310945db184afb57b971e8e098dac1fa18" translate="yes" xml:space="preserve">
          <source>Calculates the factorial of $x. For instance:</source>
          <target state="translated">$ x의 계승을 계산합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="62fb105cdba4cb5918fb1ee8f5656956e6874fed" translate="yes" xml:space="preserve">
          <source>Calculates the maximum command size the OS can exec. Effectively, this is the max size of a shell command line.</source>
          <target state="translated">OS가 실행할 수있는 최대 명령 크기를 계산합니다. 사실상 이것은 쉘 명령 행의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="fd42bdc4343d55afb259e24e240b92c18465e03e" translate="yes" xml:space="preserve">
          <source>Calculates two integers A and B so that A/B is equal to &lt;code&gt;e ** $x&lt;/code&gt; , where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">A / B가 &lt;code&gt;e ** $x&lt;/code&gt; (여기서 &lt;code&gt;e&lt;/code&gt; 는 오일러 수)가 되도록 두 개의 정수 A와 B를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="0037c314d771bc8eaa4953dbcb986cc7bf547ac0" translate="yes" xml:space="preserve">
          <source>Calendar of Perl Events</source>
          <target state="translated">펄 행사 일정</target>
        </trans-unit>
        <trans-unit id="afd632ce2019ef9ec38232fb5195ec297239dcfa" translate="yes" xml:space="preserve">
          <source>Calendar time for December 12, 1995, at 10:30 am.</source>
          <target state="translated">1995 년 12 월 12 일 오전 10시 30 분의 달력 시간.</target>
        </trans-unit>
        <trans-unit id="a7a5d5cba867fa341140666997ab9bfd6cadc129" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; and return a list of two sockets created, or an empty list on failure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 를 호출 하고 작성된 두 개의 소켓 목록 또는 실패시 빈 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6b6b5d06a5f85554364bcd897b8c29e92093294d" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start&lt;/code&gt; immediately before adding any results to the aggregator. Among other times it records the start time for the test run.</source>
          <target state="translated">통화 &lt;code&gt;start&lt;/code&gt; 게이터에 어떤 결과를 추가하기 전에 즉시. 다른 경우에는 테스트 실행의 시작 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bab90a1ca7bed318a773f1cd868353d680619794" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;stop&lt;/code&gt; immediately after adding all test results to the aggregator.</source>
          <target state="translated">모든 테스트 결과를 수집기에 추가 한 후 즉시 호출을 &lt;code&gt;stop&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e0f1fdfb2231f4e8ba5ad2172306eb394d414cf5" translate="yes" xml:space="preserve">
          <source>Call all the registered block hooks for type</source>
          <target state="translated">유형에 대해 등록 된 모든 블록 후크를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d63876fa9d1b98c3c63563764cf54bc05c244034" translate="yes" xml:space="preserve">
          <source>Call the system level poll routine. If TIMEOUT is not specified then the call will block. Returns the number of handles which had events happen, or -1 on error.</source>
          <target state="translated">시스템 레벨 폴 루틴을 호출하십시오. TIMEOUT을 지정하지 않으면 호출이 차단됩니다. 이벤트가 발생한 핸들 수 또는 오류시 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="707d41981449a7ac1f49727761a071399e9047fa" translate="yes" xml:space="preserve">
          <source>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. &lt;code&gt;stash&lt;/code&gt; is the stash that has been assigned. &lt;code&gt;oldstash&lt;/code&gt; is the stash it replaces, if any. &lt;code&gt;gv&lt;/code&gt; is the glob that is actually being assigned to.</source>
          <target state="translated">이 기능을 호출하여 숨김 계층 구조의 다른 스팟에 지정되었음을 숨김에 신호합니다. &lt;code&gt;stash&lt;/code&gt; 는 할당 된 숨김입니다. &lt;code&gt;oldstash&lt;/code&gt; 는 대체되는 숨김입니다. &lt;code&gt;gv&lt;/code&gt; 는 실제로 할당되는 glob입니다.</target>
        </trans-unit>
        <trans-unit id="897a2466922f6de52dc65c0d77a98544c7fb349a" translate="yes" xml:space="preserve">
          <source>CallSubPV</source>
          <target state="translated">CallSubPV</target>
        </trans-unit>
        <trans-unit id="ade75b74553b436dc4fbae17ff916436ba41a1b5" translate="yes" xml:space="preserve">
          <source>CallSubSV</source>
          <target state="translated">CallSubSV</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="e2492d7f90f5ff291923cb9e3820556cd26e7081" translate="yes" xml:space="preserve">
          <source>Callbacks may also be added like this:</source>
          <target state="translated">콜백은 다음과 같이 추가 될 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0b30b959e54d6077a0087fde2fbe95f232d8abe1" translate="yes" xml:space="preserve">
          <source>Called after debug API inits itself.</source>
          <target state="translated">디버그 API 자체가 초기화 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce9b93a40160290fff58c32f9bc646588fa275b" translate="yes" xml:space="preserve">
          <source>Called before &lt;code&gt;process_args&lt;/code&gt; to prepend the contents of an rc file to the options.</source>
          <target state="translated">rc 파일의 내용을 옵션 앞에 추가 하기 위해 &lt;code&gt;process_args&lt;/code&gt; 전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="712b31fe99457d34e411f45757dac056dcd534cd" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt; so that the class has a chance to initialize the converter. Internally it sets the &lt;code&gt;batch_mode&lt;/code&gt; property to true and sets &lt;code&gt;batch_mode_current_level()&lt;/code&gt; , but Pod::Simple::XHTML does not currently use those features. Subclasses might, though.</source>
          <target state="translated">클래스가 변환기를 초기화 할 수 있도록 &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch에&lt;/a&gt; 의해 호출됩니다 . 내부적으로 &lt;code&gt;batch_mode&lt;/code&gt; 속성을 true로 설정하고 &lt;code&gt;batch_mode_current_level()&lt;/code&gt; 설정 하지만 Pod :: Simple :: XHTML은 현재 이러한 기능을 사용하지 않습니다. 그래도 서브 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44d9ba6e8c865877532df9753c9657e69186427" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;close_test&lt;/code&gt; to clear the line showing test progress, or the parallel test ruler, prior to printing the final test result.</source>
          <target state="translated">최종 테스트 결과를 인쇄하기 전에 &lt;code&gt;close_test&lt;/code&gt; 에 의해 호출되어 테스트 진행 상황을 표시하는 행 또는 병렬 테스트 눈금자를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="83de9bce1b7b2bd7be455db4ac0ff451b79c596a" translate="yes" xml:space="preserve">
          <source>Called by Perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. This is only responsible for freeing private data; Perl will handle releasing anything else contained in the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">정규식 패턴을 해제 할 때 Perl에 의해 호출되어 엔진 이 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;pprivate&lt;/code&gt; 구성원이 가리키는 자원을 해제 할 수 있습니다 . 개인 정보를 확보하는 것만 책임집니다. 펄은 &lt;code&gt;regexp&lt;/code&gt; 구조에 포함 된 다른 것들의 공개를 처리 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="192f5069ea69d61876f992ae04cbfebd42365fdf" translate="yes" xml:space="preserve">
          <source>Called by Test::Harness before any test output is generated.</source>
          <target state="translated">테스트 출력이 생성되기 전에 Test :: Harness에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="252637df9babf3148f5feaeda72912f2045c6976" translate="yes" xml:space="preserve">
          <source>Called by init_main.</source>
          <target state="translated">init_main에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdb9b50857f3ef3652ef325b6cf3d72fa3622a7" translate="yes" xml:space="preserve">
          <source>Called by init_main. Initializes PERL_*</source>
          <target state="translated">init_main에 의해 호출됩니다. PERL_ *를 초기화합니다</target>
        </trans-unit>
        <trans-unit id="803f7311292b6dbe520d9001028a74a3740ad58e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up ABSPERL, PERL, FULLPERL and all the *PERLRUN* permutations.</source>
          <target state="translated">init_main에 의해 호출됩니다. ABSPERL, PERL, FULLPERL 및 모든 * PERLRUN * 순열을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3f68bdd2c8090ffda024fb7a301dcec75150221e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INSTALL_* variables (except INSTALLDIRS) and *PREFIX.</source>
          <target state="translated">init_main에 의해 호출됩니다. 모든 INSTALL_ * 변수 (INSTALLDIRS 제외) 및 * PREFIX를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e5e9ec66a22e81bfffe8ba34ae133177fa3495b6" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INST_* variables except those related to XS code. Those are handled in init_xs.</source>
          <target state="translated">init_main에 의해 호출됩니다. XS 코드와 관련된 변수를 제외한 모든 INST_ * 변수를 설정합니다. 그것들은 init_xs에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0c75a0f13f487e51a8d6aa8f296a671eded4fd" translate="yes" xml:space="preserve">
          <source>Called by init_others, and calls ext ExtUtils::Liblist. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">init_others에 의해 호출되고 ext ExtUtils :: Liblist를 호출합니다. 자세한 내용은 &lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa989d1b35e9dfa1af106d6dbfbb5e0924c7a182" translate="yes" xml:space="preserve">
          <source>Called by staticmake. Defines how to write the Makefile to produce a static new perl.</source>
          <target state="translated">staticmake에 의해 호출됩니다. 정적 새 펄을 생성하기 위해 Makefile을 작성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a7da98d82f41c03c342a989f11faab94693c6c57" translate="yes" xml:space="preserve">
          <source>Called by the harness for each line of TAP it receives.</source>
          <target state="translated">받는 TAP의 각 라인에 대한 하네스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="567cd3e87bf8931281fcaa23e35e2da3fe139b11" translate="yes" xml:space="preserve">
          <source>Called by the harness when it needs to create a &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. Override in a subclass to provide an alternative scheduler. &lt;code&gt;make_scheduler&lt;/code&gt; is passed the list of tests that was passed to &lt;code&gt;aggregate_tests&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; 를 생성해야 할 때 하네스에 의해 호출됩니다 . 대체 스케줄러를 제공하기 위해 서브 클래스에서 대체하십시오. &lt;code&gt;make_scheduler&lt;/code&gt; 에는 &lt;code&gt;aggregate_tests&lt;/code&gt; 에 전달 된 테스트 목록이 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="496f62a4d27b344cea2367c44afc046f7d3e616c" translate="yes" xml:space="preserve">
          <source>Called in list context, returns a list consisting of all the keys of the named hash, or in Perl 5.12 or later only, the indices of an array. Perl releases prior to 5.12 will produce a syntax error if you try to use an array argument. In scalar context, returns the number of keys or indices.</source>
          <target state="translated">목록 컨텍스트에서 호출되며 명명 된 해시의 모든 키로 구성되거나 Perl 5.12 이상에서만 배열의 인덱스로 구성된 목록을 반환합니다. 5.12 이전의 Perl 릴리스에서는 배열 인수를 사용하려고하면 구문 오류가 발생합니다. 스칼라 컨텍스트에서 키 또는 인덱스 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="467bfe2c2b5fcadd2c658d71f62e583886879a81" translate="yes" xml:space="preserve">
          <source>Called just before exit.</source>
          <target state="translated">종료 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="56f111d681d8f9bb2b8ea3bbe2cb68fe1cbd1b6b" translate="yes" xml:space="preserve">
          <source>Called to close a test session.</source>
          <target state="translated">테스트 세션을 종료하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0fea40ea6e66a6d129222181dca9ffffa1dc50aa" translate="yes" xml:space="preserve">
          <source>Called to create a new test session. A test session looks like this:</source>
          <target state="translated">새로운 테스트 세션을 만들기 위해 호출됩니다. 테스트 세션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bec535037f1a075b8ca545622477cf0f336b95f2" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...).</source>
          <target state="translated">번호가 매겨진 캡처 그룹 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 뿐만 아니라 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 그와 동등한 이름 ​​인 $ {^ PREMATCH}, $ {^ POSTMATCH} 및 $ {^ MATCH} 의 값을 가져 오거나 설정하기 위해 호출됩니다. ...).</target>
        </trans-unit>
        <trans-unit id="f05cab34d068a722bc12f2e226cde25cd9659c30" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , as well as by some utility functions in &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;re&quot;&gt;re의&lt;/a&gt; 일부 유틸리티 함수뿐만 아니라 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 값을 가져 오거나 설정하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ca1fbe0a0f38d437dca54b642d9f31c3ccb8f90" translate="yes" xml:space="preserve">
          <source>Called when API must show a message (warnings, errors etc.).</source>
          <target state="translated">API가 메시지 (경고, 오류 등)를 표시해야 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f94cf1c0617789052abd6d872abe927053b4b0cd" translate="yes" xml:space="preserve">
          <source>Called when a job is complete to unlock it. If a callback has been registered with &lt;code&gt;on_finish&lt;/code&gt; , it calls it. Otherwise, it does nothing.</source>
          <target state="translated">잠금 해제를 위해 작업이 완료되면 호출됩니다. 콜백이 &lt;code&gt;on_finish&lt;/code&gt; 로 등록 된 경우 호출됩니다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5516c9265ba63c86e3ef82397e79274838607cf" translate="yes" xml:space="preserve">
          <source>Called when execution stops (w/ args file, line).</source>
          <target state="translated">실행이 중지 될 때 호출됩니다 (args 파일, 행 포함).</target>
        </trans-unit>
        <trans-unit id="145748d07108bcdb9c427172d1270877727239ed" translate="yes" xml:space="preserve">
          <source>Called when the layer is popped from the stack. A layer will normally be popped after &lt;code&gt;Close()&lt;/code&gt; is called. But a layer can be popped without being closed if the program is dynamically managing layers on the stream. In such cases &lt;code&gt;Popped()&lt;/code&gt; should free any resources (buffers, translation tables, ...) not held directly in the layer's struct. It should also &lt;code&gt;Unread()&lt;/code&gt; any unconsumed data that has been read and buffered from the layer below back to that layer, so that it can be re-provided to what ever is now above.</source>
          <target state="translated">스택에서 레이어가 튀어 나올 때 호출됩니다. 일반적으로 &lt;code&gt;Close()&lt;/code&gt; 가 호출 된 후 레이어가 나타납니다 . 그러나 프로그램이 스트림에서 레이어를 동적으로 관리하는 경우 레이어를 닫지 않고 팝업 할 수 있습니다. 이러한 경우 &lt;code&gt;Popped()&lt;/code&gt; 는 레이어의 구조체에 직접 보유되지 않은 모든 리소스 (버퍼, 변환 테이블 등 ) 를 해제해야합니다. 또한 아래 계층에서 해당 계층으로 다시 읽혀지고 버퍼링 된 소비되지 않은 데이터를 &lt;code&gt;Unread()&lt;/code&gt; 해야합니다 . 따라서 현재 위의 항목으로 다시 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939127156e81551fd5a7e818b4482a513aebb0f8" translate="yes" xml:space="preserve">
          <source>Called while stopped (can be a client event loop).</source>
          <target state="translated">중지 된 동안 호출됩니다 (클라이언트 이벤트 루프 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="aac1bcb8d7dddba4603f778cf3da3d2bb22b9d64" translate="yes" xml:space="preserve">
          <source>Called without parameters, or with the first argument false, hash marks are suppressed. If the first argument is true but not a reference to a file handle glob, then \*STDERR is used. The second argument is the number of bytes per hash mark printed, and defaults to 1024. In all cases the return value is a reference to an array of two: the filehandle glob reference and the bytes per hash mark.</source>
          <target state="translated">매개 변수없이 또는 첫 번째 인수가 false 인 경우 해시 표시가 억제됩니다. 첫 번째 인수가 true이지만 파일 핸들 glob에 대한 참조가 아닌 경우 \ * STDERR이 사용됩니다. 두 번째 인수는 인쇄 된 해시 마크 당 바이트 수이며 기본값은 1024입니다. 모든 경우에 반환 값은 파일 핸들 글로브 참조와 해시 마크 당 바이트의 두 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e216eb70c5a18b158cc8c755c284c444b41dcf38" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt; inside a thread causes the whole application to terminate. Because of this, the use of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside threaded code, or in modules that might be used in threaded applications, is strongly discouraged.</source>
          <target state="translated">스레드 내에서 &lt;a href=&quot;functions/exit&quot;&gt;종료 EXPR을&lt;/a&gt; 호출 하면 전체 애플리케이션이 종료됩니다. 이 때문에 스레드 코드 내에서 또는 스레드 응용 프로그램에서 사용될 수있는 모듈에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9e1f81bd75479e40b9c0318383b0b5ea0cddb02d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;flush&lt;/code&gt; returns the array to immediate-write mode. If you wish to discard the deferred writes, you may call &lt;code&gt;-&amp;gt;discard&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;flush&lt;/code&gt; . Note that in some cases, some of the data will have been written already, and it will be too late for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; to discard all the changes. Support for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; may be withdrawn in a future version of &lt;code&gt;Tie::File&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-&amp;gt;flush&lt;/code&gt; 를 호출 하면 배열이 즉시 쓰기 모드로 돌아갑니다. 지연된 쓰기를 삭제하려면 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 대신 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 를 호출 하십시오 . 경우에 따라 일부 데이터가 이미 작성되었으며 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 가 모든 변경 사항을 삭제 하기에는 너무 늦습니다 . 향후 버전의 &lt;code&gt;Tie::File&lt;/code&gt; 에서 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 지원 이 철회 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b218ac14d28e4eba90c2438d62379a52be6547e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already detached thread will cause an error to be thrown.</source>
          <target state="translated">이미 분리 된 스레드에서 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b0f01a2dc8c4ec0ab9ed2203d7fa7fc14d740a" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already joined thread will cause an error to be thrown.</source>
          <target state="translated">이미 결합 된 스레드에서 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5013e17c5c2bf4d76b64a60f93a3e6d87ce580e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; in a thread indicates an abnormal exit for the thread. Any &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler in the thread will be called first, and then the thread will exit with a warning message that will contain any arguments passed in the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">스레드에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 스레드가 비정상적으로 종료되었음을 나타냅니다. 모든 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 스레드의 핸들러가 먼저 호출되고, 다음 스레드는 전달 된 인수가 포함됩니다 경고 메시지와 함께 종료됩니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="432a891f5fe2a318db5e9ee1a582e0b88a0dccd1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;attributes::get()&lt;/code&gt; from within the scope of a null package declaration &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; for an unblessed variable reference will not provide any starting package name for the 'fetch' method lookup. Thus, this circumstance will not result in a method call for package-defined attributes. A named subroutine knows to which symbol table entry it belongs (or originally belonged), and it will use the corresponding package. An anonymous subroutine knows the package name into which it was compiled (unless it was also compiled with a null package declaration), and so it will use that package name.</source>
          <target state="translated">호출 &lt;code&gt;attributes::get()&lt;/code&gt; 널 패키지 선언의 범위 내에서 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; 축복되지 않은 변수 참조의 경우 'fetch'메소드 검색을위한 시작 패키지 이름을 제공하지 않습니다. 따라서이 상황에서는 패키지 정의 속성에 대한 메소드 호출이 발생하지 않습니다. 명명 된 서브 루틴은 자신이 속한 (또는 원래 속한) 심볼 테이블 항목을 알고 있으며 해당 패키지를 사용합니다. 익명 서브 루틴은 패키지가 널 패키지 선언으로 컴파일되지 않은 경우 컴파일 된 패키지 이름을 알고 있으므로 해당 패키지 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="33bb3644bf1e13b2cbec6a1bd85b13b8d5473401" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;finalize&lt;/code&gt; on a child with open children will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">호출 &lt;code&gt;finalize&lt;/code&gt; 열고 아이들과 아이에하는 것입니다 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a05e36379b2d12e2a61d8dca60e3236620cfbdd1" translate="yes" xml:space="preserve">
          <source>Calling Configure</source>
          <target state="translated">호출 구성</target>
        </trans-unit>
        <trans-unit id="858cb737d2c8f0a72b951ab4ea78b7b78f817737" translate="yes" xml:space="preserve">
          <source>Calling Conventions and Magic Autogeneration</source>
          <target state="translated">전화 컨벤션 및 매직 자동 생성</target>
        </trans-unit>
        <trans-unit id="5a077d29f5340a5b715ff2d0b7446d09abed736c" translate="yes" xml:space="preserve">
          <source>Calling Perl Routines from within C Programs</source>
          <target state="translated">C 프로그램 내에서 Perl 루틴 호출</target>
        </trans-unit>
        <trans-unit id="da4bd907e548514c9e5225dea46a70baeae7e05d" translate="yes" xml:space="preserve">
          <source>Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is complete. It is removed from the list of 'exported' FILE *s, and the associated PerlIO * should revert to its original behaviour.</source>
          <target state="translated">PerlIO_releaseFILE을 호출하면 모든 FILE * 사용이 완료되었음을 PerlIO에 알립니다. '내 보낸'FILE * 목록에서 제거되며 관련 PerlIO *는 원래 동작으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="4f10f9c81f6874964032fb54a94909bb2041ccaa" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;find(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;find(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Pod :: Simple :: Search-&amp;gt; find (...) 호출은 Pod :: Simple :: Search-&amp;gt; new-&amp;gt; find (...)의 줄임말입니다. 즉, 기본 속성 값을 가진 폐기 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63b53fa8f0a187ed1ffd0c16a376efb544cfcb62" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;search(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;search(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Pod :: Simple :: Search-&amp;gt; search (...) 호출은 Pod :: Simple :: Search-&amp;gt; new-&amp;gt; search (...)의 줄임말입니다. 즉, 기본 속성 값을 가진 폐기 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae570393756fa33aae649a93468e74ad3aa690b1" translate="yes" xml:space="preserve">
          <source>Calling a Perl method from C is fairly straightforward. The following things are required:</source>
          <target state="translated">C에서 Perl 메소드를 호출하는 것은 매우 간단합니다. 다음 사항이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4f751357fb4ae38f84e904fc36d9db5113b5aaaf" translate="yes" xml:space="preserve">
          <source>Calling a Perl subroutine from your C program</source>
          <target state="translated">C 프로그램에서 Perl 서브 루틴 호출</target>
        </trans-unit>
        <trans-unit id="c40cbac274b56e1beac728d697b23cc2ad8b3e30" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is written as &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; .</source>
          <target state="translated">객체에서 메소드를 호출하는 것은 &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="effd5ea5d1271fcf8d367de7457fffef004c2411" translate="yes" xml:space="preserve">
          <source>Calling a subroutine as &lt;code&gt;&amp;amp;foo&lt;/code&gt; with no trailing parentheses ignores the prototype of &lt;code&gt;foo&lt;/code&gt; and passes it the current value of the argument list, &lt;code&gt;@_&lt;/code&gt; . Here's an example; the &lt;code&gt;bar&lt;/code&gt; subroutine calls &lt;code&gt;&amp;amp;foo&lt;/code&gt; , which prints its arguments list:</source>
          <target state="translated">같은 서브 루틴을 호출 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 전혀 뒤 괄호가의 프로토 타입 무시 &lt;code&gt;foo&lt;/code&gt; 는 그것에게 인수 목록의 현재 값을 전달 &lt;code&gt;@_&lt;/code&gt; . 다음은 예입니다. &lt;code&gt;bar&lt;/code&gt; 서브 루틴 호출 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 인수 목록을 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="83a5a40c5745b90b08565729f9c8b41d859bfba5" translate="yes" xml:space="preserve">
          <source>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle &lt;code&gt;_&lt;/code&gt; . It still refers to the result of the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; or unoverloaded filetest.</source>
          <target state="translated">오버로드 된 파일 테스트 연산자를 호출해도 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 관련된 통계 값에는 영향을 미치지 않습니다 . 여전히 마지막 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 또는 오버로드되지 않은 파일 테스트 의 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="013392383aeb8f3aaeaada77da8e78bbc103974c" translate="yes" xml:space="preserve">
          <source>Calling either function on a string that already is in the desired state is a no-op.</source>
          <target state="translated">이미 원하는 상태에있는 문자열에서 함수를 호출하는 것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac9d89d6b846180f08777572deb7332f87bf19f8" translate="yes" xml:space="preserve">
          <source>Calling exec() within a pseudo-process actually spawns the requested executable in a separate process and waits for it to complete before exiting with the same exit status as that process. This means that the process ID reported within the running executable will be different from what the earlier Perl fork() might have returned. Similarly, any process manipulation functions applied to the ID returned by fork() will affect the waiting pseudo-process that called exec(), not the real process it is waiting for after the exec().</source>
          <target state="translated">의사 프로세스 내에서 exec ()를 호출하면 실제로 요청 된 실행 파일이 별도의 프로세스로 생성되고 해당 프로세스와 동일한 종료 상태로 종료하기 전에 해당 프로세스가 완료되기를 기다립니다. 이는 실행중인 실행 파일 내에보고 된 프로세스 ID가 이전 Perl fork ()가 리턴 한 것과 다릅니다. 마찬가지로 fork ()에 의해 반환 된 ID에 적용된 프로세스 조작 함수는 exec () 이후에 대기중인 실제 프로세스가 아니라 exec ()를 호출 한 대기 의사 프로세스에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="40ade94f7a99e61011be8ace5918982f9630cfc9" translate="yes" xml:space="preserve">
          <source>Calling the Debugger</source>
          <target state="translated">디버거 호출</target>
        </trans-unit>
        <trans-unit id="2ca81641ec6217e87de3fa52de37358174c935e6" translate="yes" xml:space="preserve">
          <source>Calling the subroutine with trailing parentheses, with or without arguments, does not use the current &lt;code&gt;@_&lt;/code&gt; . Changing the example to put parentheses after the call to &lt;code&gt;foo&lt;/code&gt; changes the program:</source>
          <target state="translated">인수가 있거나없는 후행 괄호로 서브 루틴을 호출하면 현재 &lt;code&gt;@_&lt;/code&gt; 가 사용되지 않습니다 . &lt;code&gt;foo&lt;/code&gt; 를 호출 한 후 괄호를 넣도록 예제를 변경하면 프로그램이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="492d320490c0c1bea0a0670c56d499e8b857ba1c" translate="yes" xml:space="preserve">
          <source>Calling this function repeatedly will create a FILE * on each call (and will push an :stdio layer each time as well).</source>
          <target state="translated">이 함수를 반복해서 호출하면 각 호출마다 FILE *가 생성됩니다 (또한 매번 : stdio 계층을 푸시합니다).</target>
        </trans-unit>
        <trans-unit id="bc6008c1e7f7d9345b7132b8abf50b8ba6fadc50" translate="yes" xml:space="preserve">
          <source>Calling this function will cause any temp files or temp directories that are registered for removal to be removed. This happens automatically when the process exits but can be triggered manually if the caller is sure that none of the temp files are required. This method can be registered as an Apache callback.</source>
          <target state="translated">이 함수를 호출하면 제거를 위해 등록 된 임시 파일 또는 임시 디렉토리가 제거됩니다. 프로세스가 종료되면 자동으로 발생하지만 호출자가 임시 파일이 필요하지 않은 것으로 확인되면 수동으로 트리거 할 수 있습니다. 이 메소드는 Apache 콜백으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c554dbf8d391703907c916da0c8b2d2b667cbb" translate="yes" xml:space="preserve">
          <source>Calling this on the root builder is a no-op.</source>
          <target state="translated">루트 빌더에서 이것을 호출하는 것은 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="2e765d5d5aa54eb2d852bc799f3a264f32d02c18" translate="yes" xml:space="preserve">
          <source>Calling with ampersand syntax and through references does not work for the following functions, as they have special syntax that cannot always be translated into a simple list (e.g., &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">앰퍼샌드 구문 및 참조를 통한 호출은 항상 간단한 목록으로 변환 될 수없는 특수 구문 (예 : &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; ) 을 가지므로 다음 함수에는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fd4f026ec1a5607feec9a1e107752900730638f9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; turning off the ending tests. This is needed as otherwise it will trip out because we've run more tests than we strictly should have and it'll register any failures we had that we were testing for as real failures.</source>
          <target state="translated">&lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; 호출 하여 종료 테스트를 끕니다. 이는 엄격히해야하는 것보다 더 많은 테스트를 실행하고 실제 실패로 테스트하고 있던 모든 실패를 등록하므로 트립되기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="590c7d6e88adb5bddf3d8f642e0126b6c862bc26" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once. Does not handle 'set' magic on the destination SV.</source>
          <target state="translated">dsv가 ssv와 &lt;code&gt;sv_setsv&lt;/code&gt; 않으면 sv_setsv를 호출 합니다. 인수를 두 번 이상 평가할 수 있습니다. 대상 SV에서 '세트'마법을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecc1c1a42047512bf4698d979850ea62424810ba" translate="yes" xml:space="preserve">
          <source>Calls Cwd::cwd</source>
          <target state="translated">Cwd :: cwd 호출</target>
        </trans-unit>
        <trans-unit id="c904982ef90b628587f5e1c223b066f40097484e" translate="yes" xml:space="preserve">
          <source>Calls Cwd::fastcwd</source>
          <target state="translated">Cwd :: fastcwd 호출</target>
        </trans-unit>
        <trans-unit id="8c1ba5cb44af7e4a4c20a5047a781fc7e8a8fc22" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getcwd</source>
          <target state="translated">Cwd :: getcwd 호출</target>
        </trans-unit>
        <trans-unit id="206e7aa2eb36edf2b309bbc5748aac00256c2321" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getdcwd</source>
          <target state="translated">Cwd :: getdcwd 호출</target>
        </trans-unit>
        <trans-unit id="780a41207facdbbb71db04db90d90ec1fa2163f5" translate="yes" xml:space="preserve">
          <source>Calls a non-destructive version of &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once.</source>
          <target state="translated">dsv가 ssv와 동일하지 않은 경우 비파괴 버전의 &lt;code&gt;sv_setsv&lt;/code&gt; 를 호출합니다 . 인수를 두 번 이상 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff2ef8b2188043c87a9c12a3c9cbf04635b332b" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">FILEHANDLE에서 flock (2) 또는 에뮬레이션을 호출합니다. 성공하면 true를, 실패하면 false를 반환합니다. flock (2), fcntl (2) 잠금 또는 lockf (3)를 구현하지 않는 시스템에서 사용하면 치명적인 오류가 발생합니다. &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 은 Perl의 휴대용 파일 잠금 인터페이스이지만 레코드가 아닌 전체 파일 만 잠급니다.</target>
        </trans-unit>
        <trans-unit id="bb35c1fa57137cad992f4edf7e56c85897367e17" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">FILEHANDLE에서 flock (2) 또는 에뮬레이션을 호출합니다. 성공하면 true를, 실패하면 false를 반환합니다. flock (2), fcntl (2) 잠금 또는 lockf (3)를 구현하지 않는 시스템에서 사용하면 치명적인 오류가 발생합니다. &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 은 Perl의 휴대용 파일 잠금 인터페이스이지만 레코드가 아닌 전체 파일 만 잠급니다.</target>
        </trans-unit>
        <trans-unit id="773f4cafc0f3777dd34c2b664ecf08fdcad62645" translate="yes" xml:space="preserve">
          <source>Calls install() with arguments to copy a module from blib/ to the default site installation location.</source>
          <target state="translated">인수와 함께 install ()을 호출하여 blib /에서 기본 사이트 설치 위치로 모듈을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="f72e847b0819bcbc3ab49dbf4b9ab2bb349a665c" translate="yes" xml:space="preserve">
          <source>Calls makeaperl.</source>
          <target state="translated">makeaperl을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="37943b6a726d9d0c50758cce3c190484f78dfe2c" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a list context.</source>
          <target state="translated">리스트 컨텍스트에서 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bb7f57720f3817b40ff0bbe8ea59e47c2d2ab29e" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a scalar context. This is the default context flag setting for all the</source>
          <target state="translated">스칼라 컨텍스트에서 Perl 서브 루틴을 호출합니다. 이것은 모든 기본 컨텍스트 플래그 설정입니다</target>
        </trans-unit>
        <trans-unit id="73962f3f75b41688efacfc0da40dee4461b9fec3" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a void context.</source>
          <target state="translated">빈 컨텍스트에서 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f29d60ee63be0b6e387efbeaa174ef5a3adf4ba4" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgctl(2). You'll probably have to say</source>
          <target state="translated">System V IPC 함수 msgctl (2)를 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="be9988a6d42da7c4020e6a5f954992f1c4491de0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">System V IPC 함수 msgget (2)를 호출합니다. 메시지 큐 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98b9f73da86e0e6b472bbcb69f309820842a2666" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">System V IPC 함수 msgget (2)를 호출합니다. 메시지 큐 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc2abfdb7a6e8deeeb37c01f08b5371f84b9260b" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">최대 메시지 크기가 SIZE 인 메시지 큐 ID에서 변수 VAR로 메시지를 수신하기 위해 System V IPC 함수 msgrcv를 호출합니다. 메시지가 수신되면 VAR에서 가장 긴 정수인 메시지 유형이 실제 메시지 다음에 오게됩니다. 이 포장은 포장 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 로 열 수 있습니다 . 변수를 오염시킵니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="948f348f6fa98a8010bd8fc9ae4ccc04726f6c57" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">최대 메시지 크기가 SIZE 인 메시지 큐 ID에서 변수 VAR로 메시지를 수신하기 위해 System V IPC 함수 msgrcv를 호출합니다. 메시지가 수신되면 VAR에서 가장 긴 정수인 메시지 유형이 실제 메시지 다음에 오게됩니다. 이 포장은 포장 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 로 열 수 있습니다 . 변수를 오염시킵니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5afcee05064a60e928b37ea8427c6294d37aba0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">메시지 MSG를 메시지 큐 ID로 보내기 위해 System V IPC 기능 msgsnd를 호출합니다. MSG는 기본 정수 정수 메시지 유형으로 시작하고 그 뒤에 실제 메시지 길이가오고 마지막으로 메시지 자체가 있어야합니다. 이런 종류의 패킹은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 으로 달성 할 수 있습니다 . 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 설명서 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11394b0f70e6027e810e867a48b7248721c79467" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">메시지 MSG를 메시지 큐 ID로 보내기 위해 System V IPC 기능 msgsnd를 호출합니다. MSG는 기본 정수 정수 메시지 유형으로 시작하고 그 뒤에 실제 메시지 길이가오고 마지막으로 메시지 자체가 있어야합니다. 이런 종류의 패킹은 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 으로 달성 할 수 있습니다 . 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 설명서 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6019e00f804cda82d4ccc726e831f656c990eb13" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semctl(2). You'll probably have to say</source>
          <target state="translated">System V IPC 함수 semctl (2)를 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="5f610b5b4eaf02b0f729a98fdbc4342fbee172a9" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 semget (2)을 호출합니다. 세마포어 ID 또는 오류시 정의되지 않은 값을 반환합니다. 참조 &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;시스템 V IPC가 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="315be1c7490d0b06d562bb984c8930c31052ce5c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 semget (2)을 호출합니다. 세마포어 ID 또는 오류시 정의되지 않은 값을 반환합니다. 참조 &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;시스템 V IPC가 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef274fb91ef606897494225538343bd9782c7288" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">시그널링 및 대기와 같은 세마포어 작업을 위해 System V IPC 함수 semop (2)를 호출합니다. OPSTRING은 semop 구조의 팩형 배열이어야합니다. 각 semop 구조는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 으로 생성 할 수 있습니다 . OPSTRING의 길이는 세마포어 조작의 수를 의미합니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. 예를 들어 다음 코드는 세마포어 ID $ semid의 세마포어 $ semnum에서 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e0c44ed833fa28db0acecadac8e6a6c1fb4ee6ed" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">시그널링 및 대기와 같은 세마포어 작업을 위해 System V IPC 함수 semop (2)를 호출합니다. OPSTRING은 semop 구조의 팩형 배열이어야합니다. 각 semop 구조는 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 으로 생성 할 수 있습니다 . OPSTRING의 길이는 세마포어 조작의 수를 의미합니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. 예를 들어 다음 코드는 세마포어 ID $ semid의 세마포어 $ semnum에서 대기합니다.</target>
        </trans-unit>
        <trans-unit id="c7ffce30c16d2adb19634cb73edd07b139d51d58" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmctl. You'll probably have to say</source>
          <target state="translated">System V IPC 함수 shmctl을 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="b0bc62f7fa862b27b2de307fc455c072f03da35c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 shmget을 호출합니다. 공유 메모리 세그먼트 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c305f2b321c34aa679da0caad314dcb3d11fcda" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 shmget을 호출합니다. 공유 메모리 세그먼트 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="171e1908f8052943b22ba1224601d2782bb8861e" translate="yes" xml:space="preserve">
          <source>Calls the external command cwd.</source>
          <target state="translated">외부 명령 cwd를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3c0dfe2a93186d77d26e8574e4df98dbb4f6b11b" translate="yes" xml:space="preserve">
          <source>Calls the reports() method on the associated distribution object.</source>
          <target state="translated">연관된 분배 오브젝트에서 reports () 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e80219f44739d96f5e20c3cf29ed7bd7ff8e792b" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">목록의 첫 번째 요소로 지정된 시스템 호출을 호출하고 나머지 요소는 시스템 호출에 인수로 전달합니다. 구현되지 않은 경우 예외가 발생합니다. 인수는 다음과 같이 해석됩니다. 주어진 인수가 숫자 인 경우 인수는 int로 전달됩니다. 그렇지 않으면 문자열 값에 대한 포인터가 전달됩니다. 문자열에 기록 될 수있는 결과를 수신 할 수있을 정도로 문자열이 미리 확장되어 있는지 확인해야합니다. Perl은 문자열 포인터가 작성 될 수 있다고 가정해야하므로 문자열 리터럴 (또는 다른 읽기 전용 문자열)을 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 의 인수로 사용할 수 없습니다 . 정수 인수가 리터럴이 아니며 숫자 컨텍스트에서 해석되지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 추가해야 할 수도 있습니다.그들에게 숫자처럼 보이도록 강요합니다. 이것은 에뮬레이트합니다 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 기능 (또는 그 반대) :</target>
        </trans-unit>
        <trans-unit id="14adf48ff5b79cf02eb35e0df8ee02d1dedea8a0" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">목록의 첫 번째 요소로 지정된 시스템 호출을 호출하고 나머지 요소는 시스템 호출에 인수로 전달합니다. 구현되지 않은 경우 예외가 발생합니다. 인수는 다음과 같이 해석됩니다. 주어진 인수가 숫자 인 경우 인수는 int로 전달됩니다. 그렇지 않으면 문자열 값에 대한 포인터가 전달됩니다. 문자열에 기록 될 수있는 결과를 수신 할 수있을 정도로 문자열이 미리 확장되어 있는지 확인해야합니다. Perl은 문자열 포인터가 작성 될 수 있다고 가정해야하므로 문자열 리터럴 (또는 다른 읽기 전용 문자열)을 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 의 인수로 사용할 수 없습니다 . 정수 인수가 리터럴이 아니며 숫자 컨텍스트에서 해석되지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 추가해야 할 수도 있습니다. 처럼 보이 합니다. 이것은 에뮬레이션 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 함수를(또는 그 반대).</target>
        </trans-unit>
        <trans-unit id="4689606e99f2e0dc6a1ba0af906a041a8988cfda" translate="yes" xml:space="preserve">
          <source>Calls to external programs</source>
          <target state="translated">외부 프로그램으로 전화</target>
        </trans-unit>
        <trans-unit id="b9f578265a3254a0619351c53e86631e90149c66" translate="yes" xml:space="preserve">
          <source>Calls user-supplied functions for conversion. For &lt;code&gt;OUTPUT&lt;/code&gt; (XSUB to Perl), a function named &lt;code&gt;XS_pack_$ntype&lt;/code&gt; is called with the output Perl scalar and the C variable to convert from. &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type that is to be mapped to Perl. Normalized means that all &lt;code&gt;*&lt;/code&gt; are replaced by the string &lt;code&gt;Ptr&lt;/code&gt; . The return value of the function is ignored.</source>
          <target state="translated">변환을 위해 사용자 제공 함수를 호출합니다. 들면 &lt;code&gt;OUTPUT&lt;/code&gt; (펄 XSUB)라는 함수 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 출력 펄 스칼라로부터 변환하는 C 변수로 불린다. &lt;code&gt;$ntype&lt;/code&gt; 은 Perl에 매핑 될 정규화 된 C 유형입니다. 정규화는 모든 &lt;code&gt;*&lt;/code&gt; 가 문자열 &lt;code&gt;Ptr&lt;/code&gt; 로 대체 됨을 의미합니다 . 함수의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="adb92c1608308898a1811cd12d916df49f9c32f4" translate="yes" xml:space="preserve">
          <source>CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; ) is a Perl interface to Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that CPAN.pm doesn't know how to install, but installation is via the standard OSX package installer. The Perl API is, again, very close to the ObjC API it's wrapping, and the documentation just tells you how to translate from one to the other.</source>
          <target state="translated">CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; )는 Mac OS X의 Cocoa GUI 툴킷에 대한 Perl 인터페이스이며, Mac OS X에서 고유 GUI를 생성하는 데 사용될 수 있습니다. CPAN에는 CPAN의 프레임 워크가 필요하므로 CPAN에는 없습니다. .pm은 설치 방법을 모르지만 표준 OSX 패키지 설치 프로그램을 통해 설치됩니다. Perl API는 다시 랩핑하는 ObjC API와 매우 유사하며 문서는 서로간에 변환하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="80701e22e30b3906cffd903f13b0b88b4269184d" translate="yes" xml:space="preserve">
          <source>CamelGrayBig.BMP</source>
          <target state="translated">CamelGrayBig.BMP</target>
        </trans-unit>
        <trans-unit id="e06a2487ce9da8707485d167c86e4cec108412be" translate="yes" xml:space="preserve">
          <source>Can I do [task] in Perl?</source>
          <target state="translated">Perl에서 [작업]을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="17260f8bf54a1e0a6921ffbe29352d30c7eb0d7e" translate="yes" xml:space="preserve">
          <source>Can I get a BNF/yacc/RE for the Perl language?</source>
          <target state="translated">Perl 언어에 대한 BNF / yacc / RE를받을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3a800859ea9403fd88df5aa63fab2b1ed9bba4be" translate="yes" xml:space="preserve">
          <source>Can I use Perl regular expressions to match balanced text?</source>
          <target state="translated">균형 잡힌 텍스트와 일치시키기 위해 Perl 정규식을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2289a974ae52b9e29f0b401490ee2c25637b7437" translate="yes" xml:space="preserve">
          <source>Can I use Unicode in my Perl sources?</source>
          <target state="translated">Perl 소스에서 유니 코드를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="32e50e864db1746776899a01caf14e13d2d4a291" translate="yes" xml:space="preserve">
          <source>Can I use perl to run a telnet or ftp session?</source>
          <target state="translated">펄을 사용하여 텔넷 또는 ftp 세션을 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="14d0ae1165be9b8566f8406ca14230c7961f4848" translate="yes" xml:space="preserve">
          <source>Can I write useful Perl programs on the command line?</source>
          <target state="translated">명령 행에 유용한 Perl 프로그램을 작성할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="35df49ce9c972c29af7bf8e861531cb5efb30472" translate="yes" xml:space="preserve">
          <source>Can also be called as an instance method.</source>
          <target state="translated">인스턴스 메소드로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ba8c255d770ca0f7b72beded6916ada06108fbe" translate="yes" xml:space="preserve">
          <source>Can also be used to set &lt;code&gt;$TODO&lt;/code&gt; to a new value while returning the old value:</source>
          <target state="translated">이전 값을 반환하면서 &lt;code&gt;$TODO&lt;/code&gt; 를 새 값 으로 설정하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91cc357ede21e8f86848e6eae7e811a215ba08ce" translate="yes" xml:space="preserve">
          <source>Can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pod2latex&lt;/code&gt; 를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa58e7bcf2882cbd00cc88fa0dc03c0cd52468bb" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether code references are turned into perl source code. If set to a true value, &lt;code&gt;B::Deparse&lt;/code&gt; will be used to get the source of the code reference. Using this option will force using the Perl implementation of the dumper, since the fast XSUB implementation doesn't support it.</source>
          <target state="translated">코드 참조가 펄 소스 코드로 변환되는지 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. true 값으로 설정하면 &lt;code&gt;B::Deparse&lt;/code&gt; 가 코드 참조의 소스를 가져 오는 데 사용됩니다. 빠른 XSUB 구현이이를 지원하지 않기 때문에이 옵션을 사용하면 덤퍼의 Perl 구현을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c627856437742bf2a91768641f29dacbba9c49e" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are dumped in sorted order. A true value will cause the keys of all hashes to be dumped in Perl's default sort order. Can also be set to a subroutine reference which will be called for each hash that is dumped. In this case &lt;code&gt;Data::Dumper&lt;/code&gt; will call the subroutine once for each hash, passing it the reference of the hash. The purpose of the subroutine is to return a reference to an array of the keys that will be dumped, in the order that they should be dumped. Using this feature, you can control both the order of the keys, and which keys are actually used. In other words, this subroutine acts as a filter by which you can exclude certain keys from being dumped. Default is 0, which means that hash keys are not sorted.</source>
          <target state="translated">해시 키가 정렬 된 순서로 덤프되는지 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. 값이 true이면 모든 해시의 키가 Perl의 기본 정렬 순서로 덤프됩니다. 덤프되는 각 해시마다 호출되는 서브 루틴 참조로 설정할 수도 있습니다. 이 경우 &lt;code&gt;Data::Dumper&lt;/code&gt; 는 각 해시마다 서브 루틴을 한 번 호출하여 해시 참조를 전달합니다. 서브 루틴의 목적은 덤프 될 순서대로 덤프 될 키 배열에 대한 참조를 리턴하는 것입니다. 이 기능을 사용하면 키 순서와 실제로 사용되는 키를 모두 제어 할 수 있습니다. 즉,이 서브 루틴은 특정 키가 덤프되지 않도록 제외시키는 필터 역할을합니다. 기본값은 0이며, 이는 해시 키가 정렬되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7fb27ddb4917ba511f5c8620ff526bf1f7bf1e63" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are quoted. A defined false value will avoid quoting hash keys when it looks like a simple string. Default is 1, which will always enclose hash keys in quotes.</source>
          <target state="translated">해시 키의 인용 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. 정의 된 false 값은 간단한 문자열처럼 보일 때 해시 키를 인용하지 않습니다. 기본값은 1이며 항상 해시 키를 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="88c46add64294e8210c672da2183abe0ed447bfc" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to enable deep copies of structures. Cross-referencing will then only be done when absolutely essential (i.e., to break reference cycles). Default is 0.</source>
          <target state="translated">구조의 깊은 사본을 사용하기 위해 부울 값으로 설정할 수 있습니다. 상호 참조는 절대적으로 필요한 경우에만 수행됩니다 (예 : 기준 사이클을 중단). 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="67a33f1bf6a1de539cc6aeb590a56729f0fa737c" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value which controls whether the pure Perl implementation of &lt;code&gt;Data::Dumper&lt;/code&gt; is used. The &lt;code&gt;Data::Dumper&lt;/code&gt; module is a dual implementation, with almost all functionality written in both pure Perl and also in XS ('C'). Since the XS version is much faster, it will always be used if possible. This option lets you override the default behavior, usually for testing purposes only. Default is 0, which means the XS implementation will be used if possible.</source>
          <target state="translated">&lt;code&gt;Data::Dumper&lt;/code&gt; 의 순수 Perl 구현 사용 여부를 제어하는 ​​부울 값으로 설정할 수 있습니다 . &lt;code&gt;Data::Dumper&lt;/code&gt; 모듈은 모두 순수 Perl로도 XS ( 'C')에 기록 된 거의 모든 기능을, 듀얼 구현입니다. XS 버전이 훨씬 빠르므로 가능하면 항상 사용됩니다. 이 옵션을 사용하면 일반적으로 테스트 목적으로 만 기본 동작을 무시할 수 있습니다. 기본값은 0이며, 가능하면 XS 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb22428de8a3ede5e563a5e4f65611da085b8c2a" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will emit a method call for any objects that are to be dumped using the syntax &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; . Note that this means that the method specified will have to perform any modifications required on the object (like creating new state within it, and/or reblessing it in a different package) and then return it. The client is responsible for making sure the method can be called via the object, and that it returns a valid object. Defaults to an empty string.</source>
          <target state="translated">기능을 비활성화하기 위해 메소드 이름 또는 빈 문자열로 설정할 수 있습니다. Data :: Dumper는 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; 구문을 사용하여 덤프 할 객체에 대한 메소드 호출을 생성합니다 . 이는 지정된 메소드가 오브젝트에 필요한 수정을 수행하고 (예 : 오브젝트 내에 새 상태 작성 및 / 또는 다른 패키지에서이를 재 축제하는 것과 같이) 리턴해야 함을 의미합니다. 클라이언트는 메소드를 오브젝트를 통해 호출 할 수 있는지 확인하고 유효한 오브젝트를 리턴해야합니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="585673e874a0b17703c1a10f7dfc47aff5c9f0ec" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will invoke that method via the object before attempting to stringify it. This method can alter the contents of the object (if, for instance, it contains data allocated from C), and even rebless it in a different package. The client is responsible for making sure the specified method can be called via the object, and that the object ends up containing only perl data types after the method has been called. Defaults to an empty string.</source>
          <target state="translated">기능을 비활성화하기 위해 메소드 이름 또는 빈 문자열로 설정할 수 있습니다. Data :: Dumper는 문자열 화를 시도하기 전에 객체를 통해 해당 메소드를 호출합니다. 이 메소드는 오브젝트의 컨텐츠를 변경하고 (예를 들어, C에서 할당 된 데이터를 포함하는 경우), 다른 패키지로 다시 만들 수도 있습니다. 클라이언트는 지정된 메소드가 오브젝트를 통해 호출 될 수 있는지 확인하고 메소드가 호출 된 후 오브젝트에 펄 데이터 유형 만 포함되도록합니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6ee2759a6426aff4b67b4db8b27a81f5748f17a4" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which recursion into a structure will throw an exception. This is intended as a security measure to prevent perl running out of stack space when dumping an excessively deep structure. Can be set to 0 to remove the limit. Default is 1000.</source>
          <target state="translated">구조로의 재귀가 예외를 발생시키는 깊이를 지정하는 양의 정수로 설정할 수 있습니다. 이는 지나치게 깊은 구조를 덤프 할 때 스택 공간에서 펄이 부족 해지는 것을 방지하기위한 보안 조치입니다. 한계를 제거하기 위해 0으로 설정할 수 있습니다. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="4bf42f1af137c40c87a30e672fa92d800507f75f" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which we don't venture into a structure. Has no effect when &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; is set. (Useful in debugger when we often don't want to see more than enough). Default is 0, which means there is no maximum depth.</source>
          <target state="translated">구조로 들어 가지 않는 깊이를 지정하는 양의 정수로 설정할 수 있습니다. &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; 가 설정되어 있으면 효과가 없습니다 . (우리가 종종 더 이상보고 싶지 않은 디버거에 유용합니다). 기본값은 0이며 최대 깊이가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1b8ab4925558b8a13bc55bec7e3f47e1da66a3e2" translate="yes" xml:space="preserve">
          <source>Can be set to a regular expression. Only files with names that match the expression will be read.</source>
          <target state="translated">정규식으로 설정할 수 있습니다. 식과 일치하는 이름을 가진 파일 만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b4c1fc7bc4091447e126bb9cbc6311ac8f682f2f" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies an alternative to the &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; builtin operator used to create objects. A function with the specified name should exist, and should accept the same arguments as the builtin. Default is &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">객체를 만드는 데 사용되는 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 내장 연산자 의 대안을 지정하는 문자열로 설정할 수 있습니다 . 지정된 이름의 함수가 존재해야하며 내장 함수와 동일한 인수를 허용해야합니다. 기본값은 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a994c4b88b43caa5b752fd46ef7324627d9d83c6" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies the separator between hash keys and values. To dump nested hash, array and scalar values to JavaScript, use: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . Implementing &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; in JavaScript is left as an exercise for the reader. A function with the specified name exists, and accepts the same arguments as the builtin.</source>
          <target state="translated">해시 키와 값 사이의 구분 기호를 지정하는 문자열로 설정할 수 있습니다. 중첩 해시, 배열 및 스칼라 값을 JavaScript로 덤프하려면 다음을 사용하십시오. &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . JavaScript로 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 을 구현 하는 것은 독자의 연습으로 남아 있습니다. 지정된 이름의 함수가 존재하며 내장과 동일한 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9e933a47e6aaf6dd73210fa86f1269378f8318bc" translate="yes" xml:space="preserve">
          <source>Can be trimmed if you compile for one access method.</source>
          <target state="translated">하나의 액세스 방법으로 컴파일하면 다듬을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="717d201646a10747b3a920b5eaa1592483e5445b" translate="yes" xml:space="preserve">
          <source>Can call croak() if an error occurs.</source>
          <target state="translated">에러가 발생하면 croak ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="610ece97ddb84d598c6d8556f131f1844efd48bc" translate="yes" xml:space="preserve">
          <source>Can call croak() if there is a security anomaly during the stat() comparison.</source>
          <target state="translated">stat () 비교 중에 보안 이상이있는 경우 croak ()을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512d893f80ec4605f408cd9d8d3b090f641b1bc5" translate="yes" xml:space="preserve">
          <source>Can only be applied to process handles returned for processes spawned using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; or pseudo processes created with &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 작성된 의사 프로세스를 사용하여 생성 된 프로세스에 대해 리턴 된 프로세스 핸들에만 적용 할 수 있습니다 . (Win32)</target>
        </trans-unit>
        <trans-unit id="acc17adc87dae58e0d71e7b8a46715c51db69dd0" translate="yes" xml:space="preserve">
          <source>Can use any of the methods described above but for further customization one needs to override some of the methods:</source>
          <target state="translated">위에서 설명한 방법 중 하나를 사용할 수 있지만 추가 사용자 정의를 위해서는 일부 방법을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e5e0a8f8265c585a4f386242ed86595f0f740c3" translate="yes" xml:space="preserve">
          <source>Can we do the same with an XSUB</source>
          <target state="translated">XSUB로도 같은 작업을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d71b162349ad8d3cc1b62ad26a21aad2924ff2d2" translate="yes" xml:space="preserve">
          <source>Can't move directories between directories on different logical volumes. (Win32)</source>
          <target state="translated">다른 논리 볼륨의 디렉토리간에 디렉토리를 이동할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="d5c61e930ba2ace5562dbc01d87ff2dccd871bad" translate="yes" xml:space="preserve">
          <source>Cancel output to the file handle. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">파일 핸들로의 출력을 취소하십시오. &lt;code&gt;$parser&lt;/code&gt; 가 읽은 POD 는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c9d54018682f033ce26d5d28cbd53bef40aa76" translate="yes" xml:space="preserve">
          <source>Cancel output to the output string. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">출력 문자열로 출력을 취소하십시오. &lt;code&gt;$parser&lt;/code&gt; 가 읽은 POD 는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf5ab48928c6227aa52c3d012c2701389449d7d8" translate="yes" xml:space="preserve">
          <source>Canned Filters</source>
          <target state="translated">통조림 필터</target>
        </trans-unit>
        <trans-unit id="1bbd1f5144cc25ff3e79e713323aaa5805fc1bb3" translate="yes" xml:space="preserve">
          <source>Cannot start &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt; 시작할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="4f9378da13e876924853515ac330a0589ab874eb" translate="yes" xml:space="preserve">
          <source>Cannot start find.exe &quot;pattern&quot; file</source>
          <target state="translated">find.exe &quot;pattern&quot;파일을 시작할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="07f4ae991f88e569288a303eea482424b54e133d" translate="yes" xml:space="preserve">
          <source>Canonical Equivalence in Applications - UTN #5</source>
          <target state="translated">응용에서의 정식 동등성-UTN # 5</target>
        </trans-unit>
        <trans-unit id="b8dabeba508ec88a0783430634fb6a91f3d06c7d" translate="yes" xml:space="preserve">
          <source>Canonical order does not imply network order; those are two orthogonal settings.</source>
          <target state="translated">정식 순서는 네트워크 순서를 의미하지 않습니다. 그것들은 두 개의 직교 설정입니다.</target>
        </trans-unit>
        <trans-unit id="747ae3c9036b2b9d0c1bdc3f6a1c392c7794eed3" translate="yes" xml:space="preserve">
          <source>Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.) You can refer to them by absolute number (using &lt;code&gt;&quot;$1&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , etc); or by name via the &lt;code&gt;%+&lt;/code&gt; hash, using &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt;.</source>
          <target state="translated">캡처 그룹 내용은 동적으로 범위가 지정되며 둘러싸는 블록이 끝날 때까지 또는 다음 성공적인 일치 중 하나가 될 때까지 패턴 외부에서 사용할 수 있습니다. ( &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문을&lt;/a&gt; 참조하십시오 .) 절대 번호 ( &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;$1&quot;&lt;/code&gt; 사용 등)로 참조 할 수 있습니다 . 또는 &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt; &lt;i&gt;name&lt;/i&gt; }&quot;을 사용하여 &lt;code&gt;%+&lt;/code&gt; 해시 를 통해 이름별로 지정할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">캡처 그룹</target>
        </trans-unit>
        <trans-unit id="17d5baafa6da919c16c090df56e9fd9d7a565715" translate="yes" xml:space="preserve">
          <source>Capture groups are numbered from left to right, but inside this construct the numbering is restarted for each branch.</source>
          <target state="translated">캡처 그룹은 왼쪽에서 오른쪽으로 번호가 매겨 지지만이 구성에서는 번호가 각 분기에 대해 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0771c31053343949dda6efc584e44e5297b9a9" translate="yes" xml:space="preserve">
          <source>Captured groups are numbered according to their</source>
          <target state="translated">캡처 된 그룹은</target>
        </trans-unit>
        <trans-unit id="f7b4920b8aa7c1586544c28d9c8886e52d98ca56" translate="yes" xml:space="preserve">
          <source>Capturing parenthesis that work just like perl</source>
          <target state="translated">펄처럼 작동하는 괄호 캡처</target>
        </trans-unit>
        <trans-unit id="4ea8cbac41ff9a96e8d9db8e075354ecd6a9f99e" translate="yes" xml:space="preserve">
          <source>Care must be taken when making changes to make sure that you handle UTF-8 properly, both at compile time and at execution time, including when the string and pattern are mismatched.</source>
          <target state="translated">문자열과 패턴이 일치하지 않는 경우를 포함하여 컴파일 타임과 실행 시간에 UTF-8을 올바르게 처리 할 수 ​​있도록 변경시주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="04617e457add86a7b016a256cae6724b67e05962" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용할 때주의해야합니다 버전 의 형태로 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . 그것은</target>
        </trans-unit>
        <trans-unit id="f12898eb208465f617f9b5c3dd913e72b7c63a92" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용할 때주의해야합니다 버전 의 형태로 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . 그것은</target>
        </trans-unit>
        <trans-unit id="d00ed6d0c5ac45de00f179782815edeefadfc67b" translate="yes" xml:space="preserve">
          <source>Carp</source>
          <target state="translated">Carp</target>
        </trans-unit>
        <trans-unit id="d88a6c87d4e1376b298c703f4fc38df13d24c117" translate="yes" xml:space="preserve">
          <source>Carp - alternative warn and die for modules</source>
          <target state="translated">잉어-모듈에 대한 대체 경고 및 다이</target>
        </trans-unit>
        <trans-unit id="4cac758eff9ae8b1951cfa88daf6efd8e4c9f9dd" translate="yes" xml:space="preserve">
          <source>Carp gives two ways to control this.</source>
          <target state="translated">잉어는 이것을 제어하는 ​​두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bca0e3c0ab768e90d91b7158f9afa5173ab39d46" translate="yes" xml:space="preserve">
          <source>Case 2 is also deceptive in that you're accessing a variable called %hashref, not dereferencing through $hashref to the hash it's presumably referencing. That would be case 3.</source>
          <target state="translated">사례 2는 또한 $ hashref를 통해 아마도 참조하는 해시로 역 참조하지 않고 % hashref라는 변수에 액세스한다는 점에서 기만적입니다. 그것은 사례 3입니다.</target>
        </trans-unit>
        <trans-unit id="298d6337ccd66315823554fe2294fb2258cef971" translate="yes" xml:space="preserve">
          <source>Case Mappings/SpecialCasing</source>
          <target state="translated">사례 매핑 / 특별한 사건</target>
        </trans-unit>
        <trans-unit id="12c50192a130e9814d8ea8606bd466ad9981e92e" translate="yes" xml:space="preserve">
          <source>Case and abbreviations</source>
          <target state="translated">대소 문자 및 약어</target>
        </trans-unit>
        <trans-unit id="71820be5979516bbf68abefb91861f6a5f447350" translate="yes" xml:space="preserve">
          <source>Case translation operators use the Unicode case translation tables.</source>
          <target state="translated">대 / 소문자 변환 연산자는 유니 코드 대 / 소문자 변환 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9fc0b2fddd3396951a95310fbd8003b367dba5dd" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input parameters (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">대소 문자, 공백, 하이픈 및 밑줄은 입력 매개 변수에서 무시됩니다 (구형 일반 범주 속성 값 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 표시됨) ).</target>
        </trans-unit>
        <trans-unit id="9c97ea35c0c010d6bc3fa3e2766ca1eeed20cb95" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input property name (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">대소 문자, 공백, 하이픈 및 밑줄은 입력 속성 이름에서 무시됩니다 (구형 일반 범주 속성 값 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 더 잘 작성 됨 ).</target>
        </trans-unit>
        <trans-unit id="5913a3e508c3f58147c3a7ea4922d97aeb2d10bc" translate="yes" xml:space="preserve">
          <source>Casefolding is the process of mapping strings to a form where case differences are erased; comparing two strings in their casefolded form is effectively a way of asking if two strings are equal, regardless of case.</source>
          <target state="translated">Casefolding은 대소 문자 차이가 지워지는 형태로 문자열을 매핑하는 프로세스입니다. 대소 문자를 구분 한 형태로 두 문자열을 비교하는 것은 대소 문자에 관계없이 두 문자열이 동일한 지 묻는 효과적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3efae3773aea3e6418118bae37722e49dd2d43fd" translate="yes" xml:space="preserve">
          <source>Cases 1 and 2 above behave identically: they run the code contained in the variable $x. (Although case 2 has misleading double quotes making the reader wonder what else might be happening (nothing is).) Cases 3 and 4 likewise behave in the same way: they run the code &lt;code&gt;'$x'&lt;/code&gt; , which does nothing but return the value of $x. (Case 4 is preferred for purely visual reasons, but it also has the advantage of compiling at compile-time instead of at run-time.) Case 5 is a place where normally you</source>
          <target state="translated">위의 사례 1과 2는 동일하게 작동합니다. 변수 $ x에 포함 된 코드를 실행합니다. (경우 2는 큰 따옴표를 잘못 사용하지만 독자는 다른 일이 일어나지 않을지 궁금해합니다.) 사례 3과 4도 같은 방식으로 작동합니다. 코드 &lt;code&gt;'$x'&lt;/code&gt; 아무것도하지 않는다, 그러나 값을 반환을 $ x (사례 4는 순수한 시각적 이유로 선호되지만 런타임 대신 컴파일 타임에 컴파일 할 수 있다는 장점도 있습니다.) 사례 5는 일반적으로</target>
        </trans-unit>
        <trans-unit id="fce28c3834b46c5817fa1ba652ddba28baf2570f" translate="yes" xml:space="preserve">
          <source>Casting between function pointers and data pointers</source>
          <target state="translated">함수 포인터와 데이터 포인터 사이의 캐스트</target>
        </trans-unit>
        <trans-unit id="6f9e423b5bc8680aa5b16ed1908f25312d66ad7e" translate="yes" xml:space="preserve">
          <source>Casting pointers to integers or casting integers to pointers</source>
          <target state="translated">포인터를 정수로 캐스트하거나 정수를 포인터로 캐스트</target>
        </trans-unit>
        <trans-unit id="499253af5f67ae889bc3aabf24d35d8ba82de0e2" translate="yes" xml:space="preserve">
          <source>Casts I to the internal I32 type used by that perl.</source>
          <target state="translated">해당 perl에서 사용하는 내부 I32 유형으로 I을 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="c174d6be41280356a91ddfdde65f079878120639" translate="yes" xml:space="preserve">
          <source>Catch stopped child processes.</source>
          <target state="translated">자식 프로세스가 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2d335ad7e81fdf6a55a7304c8fd31f60f0fc162" translate="yes" xml:space="preserve">
          <source>Catchall routine to clean up problem MM[SK]/Make macros. Expands macros in any directory specification, in order to avoid juxtaposing two VMS-syntax directories when MM[SK] is run. Also expands expressions which are all macro, so that we can tell how long the expansion is, and avoid overrunning DCL's command buffer when MM[KS] is running.</source>
          <target state="translated">문제 MM [SK] / 매크로를 정리하는 Catchall 루틴. MM [SK]가 실행될 때 두 개의 VMS 구문 디렉토리를 병렬 처리하지 않도록 모든 디렉토리 스펙에서 매크로를 확장합니다. 또한 모든 매크로 인 표현식을 확장하여 확장 시간을 알 수 있으며 MM [KS]가 실행될 때 DCL의 명령 버퍼가 오버런되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="6b5024a9f7f3c46574351ad45dcdeceef2016767" translate="yes" xml:space="preserve">
          <source>Categories of modules range from text manipulation to network protocols to database integration to graphics. A categorized list of modules is also available from CPAN.</source>
          <target state="translated">모듈 범주는 텍스트 조작에서 네트워크 프로토콜, 데이터베이스 통합 및 그래픽에 이르기까지 다양합니다. CPAN에서 분류 된 모듈 목록도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="337a8f7bd3bdbf4fe42f0b9d4b42a95657d8e9f9" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt; : Collation</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; 카테고리 : 콜 레이션</target>
        </trans-unit>
        <trans-unit id="beec9c5a8a3b1200e13a31c08cab20f387038371" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_CTYPE&lt;/code&gt; : Character Types</source>
          <target state="translated">카테고리 &lt;code&gt;LC_CTYPE&lt;/code&gt; : 문자 유형</target>
        </trans-unit>
        <trans-unit id="38233af031be21177bea3a81f92c8363621b4861" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MONETARY&lt;/code&gt; : Formatting of monetary amounts</source>
          <target state="translated">&lt;code&gt;LC_MONETARY&lt;/code&gt; 카테고리 : 금액 서식</target>
        </trans-unit>
        <trans-unit id="19550402e5a1f045b848054b7a9e298b524aa833" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt; : Numeric Formatting</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 카테고리 : 숫자 형식</target>
        </trans-unit>
        <trans-unit id="d6caa2ce2c0ba347d49ead269d4ac916346dc572" translate="yes" xml:space="preserve">
          <source>Category Hierarchy</source>
          <target state="translated">카테고리 계층</target>
        </trans-unit>
        <trans-unit id="ad6f8c0088808eee492b45306c0d1b94608c6f08" translate="yes" xml:space="preserve">
          <source>Category LC_COLLATE: Collation</source>
          <target state="translated">LC_COLLATE 카테고리 : 콜 레이션</target>
        </trans-unit>
        <trans-unit id="a51fd3f6ab56831c7fdec8dd63db4d84c5e5ddfb" translate="yes" xml:space="preserve">
          <source>Category LC_CTYPE: Character Types</source>
          <target state="translated">카테고리 LC_CTYPE : 문자 유형</target>
        </trans-unit>
        <trans-unit id="7682ad4955d10f9cf4cc9354213c179454f72007" translate="yes" xml:space="preserve">
          <source>Category LC_MONETARY: Formatting of monetary amounts</source>
          <target state="translated">LC_MONETARY 카테고리 : 화폐 금액 형식</target>
        </trans-unit>
        <trans-unit id="07571e7937ae3f96671e4cd556a4abc903111a57" translate="yes" xml:space="preserve">
          <source>Category LC_NUMERIC: Numeric Formatting</source>
          <target state="translated">LC_NUMERIC 카테고리 : 숫자 형식</target>
        </trans-unit>
        <trans-unit id="85dc017dda24f39d24e2b45c927b49e37ad2e173" translate="yes" xml:space="preserve">
          <source>Causes symbolic links to be followed. Since directory trees with symbolic links (followed) may contain files more than once and may even have cycles, a hash has to be built up with an entry for each file. This might be expensive both in space and time for a large directory tree. See &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; and &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt; below. If either</source>
          <target state="translated">심볼릭 링크를 따르도록합니다. 심볼릭 링크가있는 디렉토리 트리 (다음에 오는)는 파일을 두 번 이상 포함 할 수 있으며주기가있을 수 있으므로 각 파일에 대한 항목으로 해시를 작성해야합니다. 큰 디렉토리 트리의 경우 공간과 시간이 모두 비쌀 수 있습니다. 아래의 &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; 및 &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip를&lt;/a&gt; 참조하십시오 . 어느 쪽이든</target>
        </trans-unit>
        <trans-unit id="d8a6af2ce96fea0e83364432bebd24ee2a299a63" translate="yes" xml:space="preserve">
          <source>Causes the script to sleep for (integer) EXPR seconds, or forever if no argument is given. Returns the integer number of seconds actually slept.</source>
          <target state="translated">스크립트가 (정수) EXPR 초 동안 또는 인수가 제공되지 않으면 영원히 휴면 상태가됩니다. 실제로 잤던 정수 (초)를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="adc5b4e7301cfc17b319d4424a90aed30a644658" translate="yes" xml:space="preserve">
          <source>Causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">이 모듈이 Time :: HiRes 모듈을 사용하게하여 ping ()에 대한 후속 호출에서 밀리 초를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37cbf6da85f81293291a3c0f70bd83d035bcf72f" translate="yes" xml:space="preserve">
          <source>Causing infinite loops etc.</source>
          <target state="translated">무한 루프 등 발생</target>
        </trans-unit>
        <trans-unit id="b643ecf0f138f7f21c8987e5e43245e6d526028e" translate="yes" xml:space="preserve">
          <source>Causing signals (especially SIGFPE and SIGALARM) to affect your process.</source>
          <target state="translated">신호에 영향을 미치므로 (특히 SIGFPE 및 SIGALARM) 공정에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f78acd3020c7919c3876959d6358cd31ff6af003" translate="yes" xml:space="preserve">
          <source>Caution : use this option only if you know that your coderefs will be properly reconstructed by &lt;code&gt;B::Deparse&lt;/code&gt; .</source>
          <target state="translated">주의 :이 옵션은 &lt;code&gt;B::Deparse&lt;/code&gt; 의해 코드 참조가 올바르게 재구성 될 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="6c45fe1a67bfe92ba6c4b2119ad5a8061d201ed7" translate="yes" xml:space="preserve">
          <source>Caveat: this is a bit of a kludge. In particular note that if anything that appears on STDERR looks like a test result the test harness will get confused. Use this option only if you understand the consequences and can live with the risk.</source>
          <target state="translated">경고 : 이것은 약간의 혼란입니다. 특히 STDERR에 나타나는 것이 테스트 결과처럼 보이는 경우 테스트 하네스가 혼동 될 수 있습니다. 결과를 이해하고 위험을 감수 할 수있는 경우에만이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="ff751acd8ebba60eb35fa0124046207c1b17cdf6" translate="yes" xml:space="preserve">
          <source>Caveats mentioned in the description of &lt;code&gt;$!&lt;/code&gt; generally apply to &lt;code&gt;$^E&lt;/code&gt; , also.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; 의 설명에 언급 된주의 사항 ! 일반적으로 &lt;code&gt;$^E&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2480f4a426ee72a3f6daf975f41b3976cd3d2933" translate="yes" xml:space="preserve">
          <source>Caveats:</source>
          <target state="translated">Caveats:</target>
        </trans-unit>
        <trans-unit id="f904f3f198a1560f6503e45c25c6ea2281d83a7a" translate="yes" xml:space="preserve">
          <source>Central America</source>
          <target state="translated">중앙 아메리카</target>
        </trans-unit>
        <trans-unit id="09fe478d9ba3d71f7c5e36ee02ee955b6c719e87" translate="yes" xml:space="preserve">
          <source>Centralized management of resources</source>
          <target state="translated">중앙 집중식 자원 관리</target>
        </trans-unit>
        <trans-unit id="e7fb0f6eb972f6f903d5d8421fe8c063e2da1bee" translate="yes" xml:space="preserve">
          <source>Cerebral C and C++ programmers should take note of the following:</source>
          <target state="translated">대뇌 C 및 C ++ 프로그래머는 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="098ac784d3c3bb2be5336c055d431de5a978080e" translate="yes" xml:space="preserve">
          <source>Certain Perl operations that are set-up within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; retain that effect even outside the scope. These include:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 로케일 범위 내에서 설정된 특정 Perl 조작 밖에서도 그 영향을 유지합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e445bdfbac84e85f57db984a7caae903e4414a5a" translate="yes" xml:space="preserve">
          <source>Certain SV types are considered 'special'. They're represented by B::SPECIAL and are referred to by a number from the specialsv_list. This array maps that number back to the name of the SV (like 'Nullsv' or '&amp;amp;PL_sv_undef').</source>
          <target state="translated">특정 SV 유형은 '특별한'것으로 간주됩니다. B :: SPECIAL로 표시되며 specialsv_list의 숫자로 나타납니다. 이 배열은 해당 숫자를 SV 이름 (예 : 'Nullsv'또는 '&amp;amp; PL_sv_undef')에 다시 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="8edd6c5378e389e68c51d5a29d8332712fb8e453" translate="yes" xml:space="preserve">
          <source>Certain Win32 programs called from cygwin programs might need some environment variable, such as e.g. ADODB needs %COMMONPROGRAMFILES%. Call Cygwin::sync_winenv() to copy all Win32 environment variables to your process and note that cygwin will warn on every encounter of non-POSIX paths.</source>
          <target state="translated">cygwin 프로그램에서 호출 된 특정 Win32 프로그램은 ADODB에 % COMMONPROGRAMFILES %와 같은 일부 환경 변수가 필요할 수 있습니다. Cygwin :: sync_winenv ()를 호출하여 모든 Win32 환경 변수를 프로세스에 복사하고 cygwin은 POSIX가 아닌 경로가 발생할 때마다 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0c5660d59e9ee01e56352c20048bf93f027e41cc" translate="yes" xml:space="preserve">
          <source>Certain built-in Unix features help prevent this most of the time. For instance, filehandles have a &quot;close on exec&quot; flag, which is set</source>
          <target state="translated">특정 내장 Unix 기능은 대부분의 시간을 막습니다. 예를 들어, 파일 핸들에는 &quot;close on exec&quot;플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd014b85703f4f23ce05ad07fc9ca7afcd931605" translate="yes" xml:space="preserve">
          <source>Certain code points are considered problematic. These are Unicode surrogates, Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF. By default these are considered regular code points, but certain situations warrant special handling for them. If &lt;code&gt;flags&lt;/code&gt; contains UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as malformations and handled as such. The flags UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal Unicode maximum) can be set to disallow these categories individually.</source>
          <target state="translated">특정 코드 포인트는 문제가있는 것으로 간주됩니다. 유니 코드 대리자, 유니 코드 비 문자 및 유니 코드 최대 0x10FFFF를 초과하는 코드 포인트입니다. 기본적으로 이들은 일반적인 코드 포인트로 간주되지만 특정 상황에서는 특별한 처리가 필요합니다. &lt;code&gt;flags&lt;/code&gt; 에 UTF8_DISALLOW_ILLEGAL_INTERCHANGE가 포함 된 경우 세 클래스 모두 기형으로 처리되어 처리됩니다. UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR 및 UTF8_DISALLOW_SUPER 플래그 (법적 유니 코드 최대 값 이상)는 이러한 범주를 개별적으로 허용하지 않도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02926fb30feba66eb4b4ce45a0942f1b38d9143" translate="yes" xml:space="preserve">
          <source>Certain file systems have a limited ability to store the times on a file at the expected level of precision. For example, the FAT and HPFS filesystem are unable to create dates on files with a finer granularity than two seconds. This is a limitation of the filesystems, not of utime().</source>
          <target state="translated">특정 파일 시스템은 파일에 예상 정확도 수준으로 시간을 저장하는 기능이 제한되어 있습니다. 예를 들어 FAT 및 HPFS 파일 시스템은 2 초보다 세분화 된 파일에서 날짜를 만들 수 없습니다. 이것은 utime ()이 아닌 파일 시스템의 한계입니다.</target>
        </trans-unit>
        <trans-unit id="37d5dc51bb3f3e8f5f3c6c97dff5e509bb4e1f21" translate="yes" xml:space="preserve">
          <source>Certain glyph variations for character display are standardized. This lists the non-Unihan ones; the Unihan ones are also not used by Perl, and are in a separate Unicode data base &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</source>
          <target state="translated">문자 표시를위한 특정 글리프 변형이 표준화됩니다. 여기에는 비 유니 한 것들이 나열됩니다. Unihan은 Perl에서도 사용되지 않으며 별도의 유니 코드 데이터베이스 ( &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd)에 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0b6cb7913f706e7a5eacb52a20195ab75fdb53c" translate="yes" xml:space="preserve">
          <source>Certain internal algorithms used in the implementation of Perl can be attacked by choosing the input carefully to consume large amounts of either time or space or both. This can lead into the so-called</source>
          <target state="translated">Perl 구현에 사용 된 특정 내부 알고리즘은 많은 시간 또는 공간 또는 둘 다를 소비하도록 입력을 신중하게 선택하여 공격 할 수 있습니다. 이것은 소위</target>
        </trans-unit>
        <trans-unit id="96a386c331a35cc383e0fb0a983cc8532170d5c8" translate="yes" xml:space="preserve">
          <source>Certain internal hooks can be also set using the &lt;code&gt;%SIG&lt;/code&gt; hash. The routine indicated by &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; is called when a warning message is about to be printed. The warning message is passed as the first argument. The presence of a &lt;code&gt;__WARN__&lt;/code&gt; hook causes the ordinary printing of warnings to &lt;code&gt;STDERR&lt;/code&gt; to be suppressed. You can use this to save warnings in a variable, or turn warnings into fatal errors, like this:</source>
          <target state="translated">&lt;code&gt;%SIG&lt;/code&gt; 해시를 사용하여 특정 내부 후크를 설정할 수도 있습니다 . &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 표시된 루틴은 경고 메시지가 인쇄 될 때 호출됩니다. 경고 메시지가 첫 번째 인수로 전달됩니다. (A)의 존재 &lt;code&gt;__WARN__&lt;/code&gt; 의 후크에 경고 통상 인쇄 발생 &lt;code&gt;STDERR&lt;/code&gt; 이 억제된다. 이를 사용하여 경고를 변수에 저장하거나 다음과 같이 경고를 치명적인 오류로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64cf21b984a47fe95b3c69dcb71d4d0db67b02a" translate="yes" xml:space="preserve">
          <source>Certain properties are accessible also via core function calls. These are:</source>
          <target state="translated">핵심 속성 호출을 통해서도 특정 속성에 액세스 할 수 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="d27dc694c4a5fbe7b1d7b9b68b009abd079b8811" translate="yes" xml:space="preserve">
          <source>Certain signals like SEGV, ILL, and BUS are generated by virtual memory addressing errors and similar &quot;faults&quot;. These are normally fatal: there is little a Perl-level handler can do with them. So Perl delivers them immediately rather than attempting to defer them.</source>
          <target state="translated">SEGV, ILL 및 BUS와 같은 특정 신호는 가상 메모리 주소 지정 오류 및 유사한 &quot;오류&quot;에 의해 생성됩니다. 이것들은 일반적으로 치명적입니다. Perl 레벨 핸들러가 그들과 함께 할 수있는 일은 거의 없습니다. 따라서 Perl은이를 연기하려고하지 않고 즉시 전달합니다.</target>
        </trans-unit>
        <trans-unit id="536f525355145c06eb27b43dd05eceed140e4f71" translate="yes" xml:space="preserve">
          <source>Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;전제 조건&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b90248a63c8f592d9dd961a96f1170c6b169a4" translate="yes" xml:space="preserve">
          <source>Ch. 15 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Ch. Larry Wall, Tom Christiansen, Jon Orwant 의 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 15 ; 오라일리 및 어소시에이트; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="9fe7a1219b8f1fb95786f557bb47edce5064d4db" translate="yes" xml:space="preserve">
          <source>Ch. 15, pp. 403 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">Ch. Larry Wall, Tom Christiansen, Jon Orwant 의 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 의 15, pp. 403 ; 오라일리 및 어소시에이트; ISBN 0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="d493056c1da57a03b23c818e0ed106583a75e9df" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for meta data about the source. This defaults to an empty hashref. See &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; for more info.</source>
          <target state="translated">소스에 대한 메타 데이터에 대한 체인 getter / setter. 기본적으로 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d37cf9e27bcdb9224f76d171f3ec04e137833197" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the configuration of the available source handlers. This is a hashref keyed on handler class whose values contain config to be passed onto the handlers during detection &amp;amp; creation. Class names may be fully qualified or abbreviated, eg:</source>
          <target state="translated">사용 가능한 소스 핸들러 구성을위한 체인화 getter / setter. 이것은 발견 및 생성 중에 핸들러로 전달 될 구성이 값에 포함 된 핸들러 클래스에 키가 지정된 해시 참조입니다. 클래스 이름은 다음과 같이 정규화되거나 약어로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e3ffd2df81751de57a2fcbade1ad6be4b71309" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the flag that dictates whether STDOUT and STDERR should be merged (where appropriate). Defaults to undef.</source>
          <target state="translated">STDOUT과 STDERR의 병합 여부를 지시하는 플래그에 대한 체인 Getter / setter (적절한 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="fa3fa390f5b11b8da2cbd991e38fe6758bc14f24" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line arguments that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">소스에 전달해야하는 명령 행 인수 목록에 대한 getter / setter를 체인으로 연결하십시오 (적절한 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="6875662647c6f1815155ad787b4b2ddda071cbb4" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line switches that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">소스로 전달되어야하는 명령 행 스위치 목록에 대한 체인 getter / setter (해당하는 경우). 기본값은 undef입니다.</target>
        </trans-unit>
        <trans-unit id="484c910049e12d13347861a5be23f00c8321a0d6" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the raw TAP source. This is a reference, as it may contain large amounts of data (eg: raw TAP).</source>
          <target state="translated">원시 TAP 소스에 대한 체인 게터 / 세터. 이는 많은 양의 데이터 (예 : 원시 TAP)를 포함 할 수 있으므로 참조입니다.</target>
        </trans-unit>
        <trans-unit id="74174c42fd62072d6ee5d0a7398fa78f44559dff" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the source's configuration, if any has been provided by the user. How it's used is up to you. This defaults to an empty hashref. See &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; for more info.</source>
          <target state="translated">사용자가 소스 구성을 제공 한 경우 소스 구성을위한 체인화 getter / setter. 그것이 사용되는 방법은 당신에게 달려 있습니다. 기본적으로 빈 해시 참조입니다. 자세한 내용은 &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="930947c88d29b6f085064df238c19e6c783d2627" translate="yes" xml:space="preserve">
          <source>Change and/or examine calling process's signal mask. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; and &lt;code&gt;oldsigset&lt;/code&gt; arguments. Consult your system's &lt;code&gt;sigprocmask&lt;/code&gt; manpage for details.</source>
          <target state="translated">호출 프로세스의 신호 마스크를 변경 및 / 또는 검사합니다. 이 사용 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 에 대한 객체 &lt;code&gt;sigset&lt;/code&gt; 및 &lt;code&gt;oldsigset&lt;/code&gt; 인수. 자세한 내용은 시스템의 &lt;code&gt;sigprocmask&lt;/code&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="47d396cd087a5a418e7353a4c45e6745ef5c9209" translate="yes" xml:space="preserve">
          <source>Change directory to /</source>
          <target state="translated">디렉토리를 /로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="6b35e50e6231ecd47c51f9d0f60727b3553c64b4" translate="yes" xml:space="preserve">
          <source>Change directory to the parent of the current directory.</source>
          <target state="translated">디렉토리를 현재 디렉토리의 상위 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="6eba8b030681c63dbaca5c083fcb141f12c78bec" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode.</source>
          <target state="translated">$ file의 모드를 $ mode로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="61d995589ae611e0f4742d3a0cee92270e9ce91b" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode. The mode can be a string or a number which is interpreted as octal whether or not a leading 0 is given.</source>
          <target state="translated">$ file의 모드를 $ mode로 변경하십시오. 모드는 문자열 또는 숫자 일 수 있으며 앞에 0이 제공되는지 여부에 따라 8 진수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3a726567b511b7efb1456c7410856f0769212a35" translate="yes" xml:space="preserve">
          <source>Change owner $file to $uname and $gname.</source>
          <target state="translated">소유자 $ file을 $ uname 및 $ gname으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c8ee54b2a4c58db1f595c468254073b721477b33" translate="yes" xml:space="preserve">
          <source>Change owner of $file to $user. If a $group is given that is changed as well. You can also pass a single parameter with a colon separating the use and group as in 'root:wheel'.</source>
          <target state="translated">$ file의 소유자를 $ user로 변경하십시오. $ group이 주어지면 그것도 변경됩니다. 'root : wheel'에서와 같이 사용 및 그룹을 구분하는 콜론으로 단일 매개 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad1746f9b9be805d4a6fb33e7166d4914a6f334" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate object &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">수축 오브젝트 &lt;code&gt;$d&lt;/code&gt; 의 설정을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6d7824dc2aeadd89378b9289a40f5baa46baf4c" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">수축 스트림 &lt;code&gt;$d&lt;/code&gt; 의 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="f11138eabf6401374fb6ae86928421d28ef54011" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$gz&lt;/code&gt; .</source>
          <target state="translated">수축 스트림 &lt;code&gt;$gz&lt;/code&gt; 의 설정을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="cc239982b98cfe5d4bf5a6e97925df8bb9b66869" translate="yes" xml:space="preserve">
          <source>Change style of array and hash dump. If true, short array may be printed on one line.</source>
          <target state="translated">배열 및 해시 덤프 스타일 변경 참이면 짧은 배열이 한 줄에 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc31075534bc4e1f585b7495788835ad53a5ed8b" translate="yes" xml:space="preserve">
          <source>Change style of string dump. Default value of &lt;code&gt;tick&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; , one can enable either double-quotish dump, or single-quotish by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. By default, characters with high bit set are printed</source>
          <target state="translated">문자열 덤프의 스타일을 변경하십시오. 의 기본값 &lt;code&gt;tick&lt;/code&gt; 입니다 &lt;code&gt;auto&lt;/code&gt; , 하나에 설정하여 두 번 quotish 덤프, 또는 단일 quotish을 활성화 할 수 있습니다 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; . 기본적으로 높은 비트 세트와 문자가 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="f62e18a300604c2d0b5ad8fe35bb69d2aa22ab89" translate="yes" xml:space="preserve">
          <source>Change the line reading:</source>
          <target state="translated">행 판독 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0d5ba9e028e71b7c3b6cfe8c3482bc252c2e3c53" translate="yes" xml:space="preserve">
          <source>Change the size of code list window (default is 10 lines).</source>
          <target state="translated">코드 목록 창의 크기를 변경하십시오 (기본값은 10 행).</target>
        </trans-unit>
        <trans-unit id="569c8a1e53a15c2ffb329e7aa5e5500846bb9b87" translate="yes" xml:space="preserve">
          <source>Change the style of array and hash output. If &lt;code&gt;compactDump&lt;/code&gt; , short array may be printed on one line.</source>
          <target state="translated">배열 및 해시 출력 스타일을 변경하십시오. &lt;code&gt;compactDump&lt;/code&gt; 인 경우 짧은 배열이 한 줄에 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ddcd6267b5132268c1d3a6f92ad7c15283dd197" translate="yes" xml:space="preserve">
          <source>Change the style of string dump. The default value for &lt;code&gt;quote&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; ; one can enable double-quotish or single-quotish format by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, respectively. By default, characters with their high bit set are printed verbatim.</source>
          <target state="translated">문자열 덤프 스타일을 변경하십시오. &lt;code&gt;quote&lt;/code&gt; 의 기본값 은 &lt;code&gt;auto&lt;/code&gt; 입니다 . 큰 따옴표 또는 작은 따옴표 형식을 각각 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 . 기본적으로 비트 수가 높은 문자는 그대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="38de6175abf6da26b6853e84b1888d7d917d0994" translate="yes" xml:space="preserve">
          <source>Change this to</source>
          <target state="translated">이것을 다음으로 변경하십시오</target>
        </trans-unit>
        <trans-unit id="0558571d851a8433aad3815610abfaf16dab150e" translate="yes" xml:space="preserve">
          <source>Change to an empty directory, and create a placeholder &amp;lt;Makefile.PL&amp;gt;:</source>
          <target state="translated">빈 디렉토리로 변경하고 플레이스 홀더 &amp;lt;Makefile.PL&amp;gt;을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bbbe466cbb3d9bd600f9492fe6485ab273c48d8c" translate="yes" xml:space="preserve">
          <source>Change to the &lt;code&gt;./pod&lt;/code&gt; directory of the build tree, download the Perl logo</source>
          <target state="translated">빌드 트리 의 &lt;code&gt;./pod&lt;/code&gt; 디렉토리로 변경 하고 Perl 로고를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="862ce088bc8e3f533e4bd14af7a6130330f00504" translate="yes" xml:space="preserve">
          <source>Change to the directory of extraction.</source>
          <target state="translated">추출 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1a08104f60eb079d49d12cd925f4ebbd076f6abd" translate="yes" xml:space="preserve">
          <source>Change to the extension directory where its source files are present.</source>
          <target state="translated">소스 파일이있는 확장 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="622a8441b6e400617adf70d8d715f1f671124897" translate="yes" xml:space="preserve">
          <source>Change to the installation directory (most probably ADE:), and extract the binary distribution:</source>
          <target state="translated">설치 디렉토리 (대부분 ADE :)로 변경하고 바이너리 배포판을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d82ce619d11521a894a962f613af5bfbbfd623ad" translate="yes" xml:space="preserve">
          <source>Changes / enhancements you plan to make in the future.</source>
          <target state="translated">향후 변경 / 향상 될 계획입니다.</target>
        </trans-unit>
        <trans-unit id="4371a5117e6fef40651394dbe58dc03dbb87745b" translate="yes" xml:space="preserve">
          <source>Changes EQUALIZE_TIMESTAMP to set revision date of target file to one second later than source file, since MMK interprets precisely equal revision dates for a source and target file as a sign that the target needs to be updated.</source>
          <target state="translated">MMK는 소스 및 대상 파일에 대해 정확히 동일한 개정 날짜를 대상을 업데이트해야한다는 표시로 해석하므로 EQUALIZE_TIMESTAMP를 변경하여 대상 파일의 개정 날짜를 소스 파일보다 1 초 늦게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4d2ce6a709b5b2cac8d8c837247b977c30d65233" translate="yes" xml:space="preserve">
          <source>Changes are always applied directly to the main development branch, called &quot;blead&quot;. Some patches may be backported to a maintenance branch. If you think your patch is appropriate for the maintenance branch (see &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;MAINTENANCE BRANCHES in perlpolicy&lt;/a&gt;), please explain why when you submit it.</source>
          <target state="translated">변경 사항은 항상 &quot;블레이드&quot;라고하는 기본 개발 지점에 직접 적용됩니다. 일부 패치는 유지 관리 지점으로 백 포트 될 수 있습니다. 패치가 유지 보수 브랜치에 적합하다고 생각되면 ( &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;perlpolicy&lt;/a&gt; 의 유지 보수 지점 참조 ) 제출할 때 이유를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="1aa5832c7b70a5878149d5b5588b7d55b7c3bff5" translate="yes" xml:space="preserve">
          <source>Changes for h2xs as of Perl 5.8.x by Renee Baecker</source>
          <target state="translated">Renee Baecker의 Perl 5.8.x 기준 h2x 변경 사항</target>
        </trans-unit>
        <trans-unit id="62a553e5ccf5c46fdfc0ab8ea84db2a7f76cbebc" translate="yes" xml:space="preserve">
          <source>Changes how to run the linker.</source>
          <target state="translated">링커 실행 방법을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f786f1f1a07415a1d8f2db0065ca900fcd53b8f6" translate="yes" xml:space="preserve">
          <source>Changes in code reference aliasing</source>
          <target state="translated">코드 참조 앨리어싱 변경</target>
        </trans-unit>
        <trans-unit id="be9cab3f4b47428605082907ec95e1b8c3df99df" translate="yes" xml:space="preserve">
          <source>Changes that might break existing code, either on the perl or C level</source>
          <target state="translated">Perl 또는 C 레벨에서 기존 코드를 손상시킬 수있는 변경 사항</target>
        </trans-unit>
        <trans-unit id="db0ec37c30cf600ec53fc96678818cec2782658c" translate="yes" xml:space="preserve">
          <source>Changes the access and modification times on each file of a list of files. The first two elements of the list must be the NUMERIC access and modification times, in that order. Returns the number of files successfully changed. The inode change time of each file is set to the current time. For example, this code has the same effect as the Unix touch(1) command when the files</source>
          <target state="translated">파일 목록의 각 파일에 대한 액세스 및 수정 시간을 변경합니다. 목록의 처음 두 요소는 순서대로 NUMERIC 액세스 및 수정 시간이어야합니다. 성공적으로 변경된 파일 수를 반환합니다. 각 파일의 inode 변경 시간은 현재 시간으로 설정됩니다. 예를 들어,이 코드는 파일의 Unix touch (1) 명령과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4b4b4c86467333f8b7a7b80f4a01e7d1918a1a32" translate="yes" xml:space="preserve">
          <source>Changes the name of a file; an existing file NEWNAME will be clobbered. Returns true for success, false otherwise.</source>
          <target state="translated">파일 이름을 변경합니다. 기존 파일 NEWNAME이 삭제됩니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8b1fed7eb953f32d4b671261c0f298f432b77d6" translate="yes" xml:space="preserve">
          <source>Changes the owner (and group) of a list of files. The first two elements of the list must be the</source>
          <target state="translated">파일 목록의 소유자 (및 그룹)를 변경합니다. 목록의 처음 두 요소는</target>
        </trans-unit>
        <trans-unit id="1c7b4f13f0f9f250ad54a523828fe1dadc6bd8b6" translate="yes" xml:space="preserve">
          <source>Changes the path separator with .</source>
          <target state="translated">로 경로 구분 기호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2250a43272b4d912fcb35a54a90fbad3a0416b17" translate="yes" xml:space="preserve">
          <source>Changes the permissions of a list of files. The first element of the list must be the numeric mode, which should probably be an octal number, and which definitely should</source>
          <target state="translated">파일 목록의 권한을 변경합니다. 목록의 첫 번째 요소는 숫자 모드 여야하며, 이는 아마도 8 진수 여야하며 반드시</target>
        </trans-unit>
        <trans-unit id="9bd248973528630e1bf213ec672fc9ef7ebeb306" translate="yes" xml:space="preserve">
          <source>Changes the style of printout of strings. Possible values are &lt;code&gt;unctrl&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; .</source>
          <target state="translated">문자열의 인쇄 스타일을 변경합니다. 가능한 값은 &lt;code&gt;unctrl&lt;/code&gt; 및 &lt;code&gt;quote&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e08e00af7afee19133f68fcfa5c4f8c0f8fe0ac1" translate="yes" xml:space="preserve">
          <source>Changes the value of specified keys and returns the changed part.</source>
          <target state="translated">지정된 키의 값을 변경하고 변경된 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3647bf8ac5df1429e21c0b23760ce2722ca59762" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 작업 디렉토리를 EXPR로 변경합니다. EXPR을 생략하면 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 지정된 디렉토리로 변경 됩니다 (설정된 경우). 그렇지 않은 경우 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 지정된 디렉토리로 변경하십시오 . (VMS에서 변수 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; 도 검사되며 설정되어 있으면 사용됩니다.) 둘 다 설정 되지 않으면 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 아무 작업도 수행하지 않습니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 아래 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1086b5985822b0db7454ba706dee00d51c0ece8" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">가능한 경우 작업 디렉토리를 EXPR로 변경합니다. EXPR을 생략하면 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 지정된 디렉토리로 변경 됩니다 (설정된 경우). 그렇지 않은 경우 &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 지정된 디렉토리로 변경하십시오 . (VMS에서 변수 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; 도 검사되며 설정되어 있으면 사용됩니다.) 둘 다 설정 되지 않으면 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 은 아무 작업도 수행하지 않습니다. 성공하면 true를, 그렇지 않으면 false를 반환합니다. &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 아래 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fabf30bdd6213704e83eeade8922d6faf64b5fd" translate="yes" xml:space="preserve">
          <source>Changes to the array are reflected in the file immediately.</source>
          <target state="translated">배열에 대한 변경 사항은 파일에 즉시 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="6803890e536e93e672442636eafadf71854a5e67" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution associated with this module has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">이 모듈과 연관된 분배가 압축 해제 된 디렉토리로 변경하고 거기에서 서브 쉘을 엽니 다. 서브 쉘을 종료하면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e4202a82c344d58c60462a8105e61b62b6fab966" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">배포가 압축 해제 된 디렉토리로 변경하고 거기에서 서브 쉘을 엽니 다. 서브 쉘을 종료하면 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b8731050a8a7a9f8df1483a6a44fb58459c692c8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make clean&lt;/code&gt; there.</source>
          <target state="translated">배포판의 압축을 풀고 실행 한 디렉토리를 변경 &lt;code&gt;make clean&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2cf85dcec97c298d42a66cbcf92705947c20dbb8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make test&lt;/code&gt; there.</source>
          <target state="translated">배포가 풀린 디렉토리를 변경하고 실행 &lt;code&gt;make test&lt;/code&gt; 가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce66a23f208dbab005ac63aadf6ed1d3fdec95de" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs something like</source>
          <target state="translated">배포가 풀린 디렉토리로 변경하고 다음과 같은 것을 실행합니다</target>
        </trans-unit>
        <trans-unit id="936a954c5967e4fb0f809c16524179a6172e7265" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs the external command &lt;code&gt;make install&lt;/code&gt; there. If &lt;code&gt;make&lt;/code&gt; has not yet been run, it will be run first. A &lt;code&gt;make test&lt;/code&gt; is issued in any case and if this fails, the install is cancelled. The cancellation can be avoided by letting &lt;code&gt;force&lt;/code&gt; run the &lt;code&gt;install&lt;/code&gt; for you.</source>
          <target state="translated">배포가 압축 해제 된 디렉토리를 변경하고 외부 명령 &lt;code&gt;make install&lt;/code&gt; 을 실행하십시오 . &lt;code&gt;make&lt;/code&gt; 가 아직 실행되지 않은 경우 먼저 실행됩니다. &lt;code&gt;make test&lt;/code&gt; 어떤 경우에 발행이 실패 할 경우, 취소되어 설치된다. &lt;code&gt;force&lt;/code&gt; &lt;code&gt;install&lt;/code&gt; 를 실행하면 취소를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d3b3f1bc0445ad3c7b600875f43d2f0c065a2c3" translate="yes" xml:space="preserve">
          <source>Changing parts of a string via the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator. (We avoid use of this term to mean &lt;b&gt;variable interpolation&lt;/b&gt;.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 연산자 를 통해 문자열 부분 변경 &lt;b&gt;변수 보간&lt;/b&gt; 을 의미하기 위해이 용어를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="d7a71579d5e34f224f4b7a44cf8dcd2dbcaa9c26" translate="yes" xml:space="preserve">
          <source>Changing the BTREE sort order</source>
          <target state="translated">BTREE 정렬 순서 변경</target>
        </trans-unit>
        <trans-unit id="e17474358ec9689585fdd62efb80f2dbb797c7f5" translate="yes" xml:space="preserve">
          <source>Changing the case of a scalar, that is, using &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\l&lt;/code&gt; in double-quotish contexts, such as regular expression substitutions.</source>
          <target state="translated">스칼라의 대소 문자 변경, 즉 정규 표현식과 같이 큰 따옴표로 묶은 문맥에서 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 및 &lt;code&gt;\l&lt;/code&gt; 대체.</target>
        </trans-unit>
        <trans-unit id="df6f7a30e2f621822d21b001b70407e472b19e52" translate="yes" xml:space="preserve">
          <source>Changing the program's locale should be avoided by XS code. Nevertheless, certain non-Perl libraries called from XS, such as &lt;code&gt;Gtk&lt;/code&gt; do so. When this happens, Perl needs to be told that the locale has changed. Use this function to do so, before returning to Perl.</source>
          <target state="translated">XS 코드로 프로그램 로케일을 변경하지 않아야합니다. 그럼에도 불구하고 &lt;code&gt;Gtk&lt;/code&gt; 와 같은 XS에서 호출 된 비 Perl 라이브러리 는 그렇게합니다. 이 경우, Perl은 로케일이 변경되었음을 알려줘야합니다. Perl로 돌아 가기 전에이 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e1948c28b77c30e8fb57b5aff7a3dda34db561" translate="yes" xml:space="preserve">
          <source>Character Class Tests</source>
          <target state="translated">캐릭터 클래스 테스트</target>
        </trans-unit>
        <trans-unit id="09d5ec3fa8dfa6626f64711e08afb866161e2c4e" translate="yes" xml:space="preserve">
          <source>Character Classes and other Special Escapes</source>
          <target state="translated">캐릭터 클래스 및 기타 특수 탈출</target>
        </trans-unit>
        <trans-unit id="34a9fd5b966d1c074e2cee0432c22ae8d6ad1a1d" translate="yes" xml:space="preserve">
          <source>Character Data</source>
          <target state="translated">캐릭터 데이터</target>
        </trans-unit>
        <trans-unit id="f710e107c2984efab355453a12a4c6ea080f5d29" translate="yes" xml:space="preserve">
          <source>Character Encoding Scheme</source>
          <target state="translated">문자 인코딩 체계</target>
        </trans-unit>
        <trans-unit id="4cf0ae92275a457503e6f1502570311bf8750725" translate="yes" xml:space="preserve">
          <source>Character Encodings for Input and Output</source>
          <target state="translated">입력 및 출력을위한 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="20ec21ca7596ab8473642f9e0c8182b338e1d924" translate="yes" xml:space="preserve">
          <source>Character Escapes</source>
          <target state="translated">캐릭터 탈출</target>
        </trans-unit>
        <trans-unit id="70a24f05bd3a1beeddb3d790c2d17711c420ebac" translate="yes" xml:space="preserve">
          <source>Character Ranges</source>
          <target state="translated">문자 범위</target>
        </trans-unit>
        <trans-unit id="d2f44b6bf2d1636aa1643ea45ee60f381bdc2aa5" translate="yes" xml:space="preserve">
          <source>Character Ranges and Classes</source>
          <target state="translated">문자 범위 및 클래스</target>
        </trans-unit>
        <trans-unit id="def6212f0e6caec39a85ca7bef2c8e9c647d0bd2" translate="yes" xml:space="preserve">
          <source>Character and block devices. devmajor and devminor should specify the major and minor device numbers.</source>
          <target state="translated">캐릭터 및 블록 장치. devmajor와 devminor는 주 장치 번호와 부 장치 번호를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fae5ab4ae64b19dd3884a0674108f420e439509e" translate="yes" xml:space="preserve">
          <source>Character case changing</source>
          <target state="translated">대소 문자 변경</target>
        </trans-unit>
        <trans-unit id="5c948c7ed34065b8008d26ee3576913d72d9cc02" translate="yes" xml:space="preserve">
          <source>Character class.</source>
          <target state="translated">캐릭터 클래스.</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="b8d7eaa1fb86bcd30ed62dcabd2cca16ff64d891" translate="yes" xml:space="preserve">
          <source>Character classes also have ordinary and special characters, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; and are matched using an escape:</source>
          <target state="translated">문자 클래스에는 일반 문자와 특수 문자가 있지만 문자 클래스 내부의 일반 문자와 특수 문자 세트는 문자 클래스 외부의 문자와 다릅니다. 문자 클래스의 특수 문자는 &lt;code&gt;-]\^$&lt;/code&gt; 이며 이스케이프를 사용하여 일치합니다.</target>
        </trans-unit>
        <trans-unit id="334bc0b92c2c74eb72d0f1cbef4062f7de8fe371" translate="yes" xml:space="preserve">
          <source>Character classes in regular expressions match based on the character properties specified in the Unicode properties database.</source>
          <target state="translated">정규식의 문자 클래스는 유니 코드 특성 데이터베이스에 지정된 문자 특성을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">문자 분류</target>
        </trans-unit>
        <trans-unit id="0c5cbf9ae05984cb96206744590414bbd855ee84" translate="yes" xml:space="preserve">
          <source>Character code set ID 0037 is a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 0037 is used in North American English locales on the OS/400 operating system that runs on AS/400 computers. CCSID 0037 differs from ISO 8859-1 in 236 places; in other words they agree on only 20 code point values.</source>
          <target state="translated">문자 코드 세트 ID 0037은 ASCII와 Latin-1 문자 (예 : ISO 8859-1)를 EBCDIC 세트에 매핑 한 것입니다. 0037은 AS / 400 컴퓨터에서 실행되는 OS / 400 운영 체제의 북미 영어 로케일에서 사용됩니다. CCSID 0037은 236 개 장소에서 ISO 8859-1과 다릅니다. 즉, 20 개의 코드 포인트 값에만 동의합니다.</target>
        </trans-unit>
        <trans-unit id="40746c1bc8caca4e8597fe4115baf09938eb4d04" translate="yes" xml:space="preserve">
          <source>Character code set ID 1047 is also a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 1047 is used under Unix System Services for OS/390 or z/OS, and OpenEdition for VM/ESA. CCSID 1047 differs from CCSID 0037 in eight places, and from ISO 8859-1 in 236.</source>
          <target state="translated">문자 코드 세트 ID 1047은 ASCII와 Latin-1 문자 (예 : ISO 8859-1)를 EBCDIC 세트에 매핑 한 것입니다. 1047은 OS / 390 또는 z / OS 용 Unix 시스템 서비스 및 VM / ESA 용 OpenEdition에서 사용됩니다. CCSID 1047은 8 곳의 CCSID 0037과 236의 ISO 8859-1과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d32256dddf94c58de00208fb12aedf2f63688834" translate="yes" xml:space="preserve">
          <source>Character encodings in Perl</source>
          <target state="translated">Perl의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="704c519e45bb20896b1cac037d9dc1f99d2661e9" translate="yes" xml:space="preserve">
          <source>Character ranges in regular expression bracketed character classes ( e.g., &lt;code&gt;/[a-z]/&lt;/code&gt; ) and in the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (also known as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) operator are not magically Unicode-aware. What this means is that &lt;code&gt;[A-Za-z]&lt;/code&gt; will not magically start to mean &quot;all alphabetic letters&quot; (not that it does mean that even for 8-bit characters; for those, if you are using locales (&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), use &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; and if not, use the 8-bit-aware property &lt;code&gt;\p{alpha}&lt;/code&gt; ).</source>
          <target state="translated">정규식 대괄호로 묶은 문자 클래스 (예 : &lt;code&gt;/[a-z]/&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 라고도 함 ) 연산자의 문자 범위는 마술처럼 유니 코드를 인식하지 않습니다. 이것이 의미하는 바는 &lt;code&gt;[A-Za-z]&lt;/code&gt; 가 마술처럼 &quot;모든 알파벳 문자&quot;를 의미하지는 않는다는 것입니다 (8 비트 문자의 경우도 마찬가지입니다. 로케일 ( &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; )을 사용하는 경우에는 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; 그렇지 않은 경우 8 비트 인식 속성 &lt;code&gt;\p{alpha}&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="562694c8fa3ccd4702e9b5a3b83e76744b7e6c8c" translate="yes" xml:space="preserve">
          <source>Character set modifier behavior prior to Perl 5.14</source>
          <target state="translated">Perl 5.14 이전의 문자 세트 수정 자 동작</target>
        </trans-unit>
        <trans-unit id="e156811acff779a0efdf0149cf0ae9a427195a9d" translate="yes" xml:space="preserve">
          <source>Character set modifiers</source>
          <target state="translated">문자 세트 수정 자</target>
        </trans-unit>
        <trans-unit id="5b676207ec8a3106cd8805847b93ca527620baf4" translate="yes" xml:space="preserve">
          <source>Character sets and character encoding</source>
          <target state="translated">문자 세트 및 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="0dd9c6f6d08e52935fa08236378969d99f092384" translate="yes" xml:space="preserve">
          <source>Characters in Pod documents may be conveyed either as literals, or by number in E&amp;lt;n&amp;gt; codes, or by an equivalent mnemonic, as in E&amp;lt;eacute&amp;gt; which is exactly equivalent to E&amp;lt;233&amp;gt;. The numbers are the Latin1/Unicode values, even on EBCDIC platforms.</source>
          <target state="translated">포드 문서의 문자는 리터럴 또는 E &amp;lt;n&amp;gt; 코드의 숫자 또는 E &amp;lt;233&amp;gt;과 정확히 동일한 E &amp;lt;eacute&amp;gt;와 같은 등가의 니모닉으로 전달 될 수 있습니다. 숫자는 EBCDIC 플랫폼에서도 Latin1 / Unicode 값입니다.</target>
        </trans-unit>
        <trans-unit id="dcec8944860f789b80b281bc04ffb139e54ea11c" translate="yes" xml:space="preserve">
          <source>Characters may be literals or any of the escape sequences accepted in double-quoted strings. But there is no interpolation, so &lt;code&gt;&quot;$&quot;&lt;/code&gt; and &lt;code&gt;&quot;@&quot;&lt;/code&gt; are treated as literals. A hyphen at the beginning or end, or preceded by a backslash is considered a literal. Escape sequence details are in &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;the table near the beginning of this section&lt;/a&gt;. It is a bug in Perl v5.22 that something like</source>
          <target state="translated">문자는 리터럴이거나 큰 따옴표로 묶인 문자열에서 허용되는 이스케이프 시퀀스 일 수 있습니다. 그러나 보간법이 없으므로 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 는 리터럴로 취급됩니다. 시작 또는 끝의 하이픈 또는 백 슬래시가 앞에 오는 문자는 리터럴로 간주됩니다. 이스케이프 시퀀스 세부 정보는 &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;이 섹션의 시작 부분 근처&lt;/a&gt; 에 있는 표에 있습니다 . Perl v5.22의 버그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9963f5cdbae1775d9f83906b3a5cbef411c1ebf6" translate="yes" xml:space="preserve">
          <source>Characters may be specified using a metacharacter syntax much like that used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a form feed, etc. More generally, \</source>
          <target state="translated">C에서 사용되는 것과 비슷한 메타 문자 구문을 사용하여 문자를 지정할 수 있습니다. &quot;\ n&quot;은 개행, &quot;\ t&quot;탭, &quot;\ r&quot;캐리지 리턴, &quot;\ f&quot;폼 피드 등과 일치합니다. , \</target>
        </trans-unit>
        <trans-unit id="6677fa2bd945e79a1181804df0a34874fe2d47f6" translate="yes" xml:space="preserve">
          <source>Characters that are not coded in logical order and to be rearranged. If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or less than 11, default is:</source>
          <target state="translated">논리적 순서로 코딩되지 않고 재 배열 될 문자 경우 &lt;code&gt;UCA_Version&lt;/code&gt; 이 같거나 11보다 작은, 기본값은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="87ac5130c826b6e80d3a59535b9d6400acad5f5d" translate="yes" xml:space="preserve">
          <source>Characters that may carry a special meaning inside a character class are: &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</source>
          <target state="translated">문자 클래스 내에서 특별한 의미를 가질 수있는 문자는 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 이며 아래에서 설명합니다. 백 슬래시를 사용하여 이스케이프 처리 할 수 ​​있지만, 때로는 필요하지 않지만이 경우 백 슬래시를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4dafb52fa02eb41cdb895328b5e1fe67da8f211" translate="yes" xml:space="preserve">
          <source>Charles Bailey</source>
          <target state="translated">찰스 베일리</target>
        </trans-unit>
        <trans-unit id="5e62c89e7209c56822c7a94ca2800f8e7a4f3ee5" translate="yes" xml:space="preserve">
          <source>Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</source>
          <target state="translated">Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</target>
        </trans-unit>
        <trans-unit id="22cb7bacebab63abf9230cfeb35ec01ffa449880" translate="yes" xml:space="preserve">
          <source>Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc.fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</source>
          <target state="translated">Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc .fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7f45f4145d31345768a09969013e2d6f185c06a1" translate="yes" xml:space="preserve">
          <source>Chdir to the djgpp subdirectory of perl toplevel and type the following commands:</source>
          <target state="translated">perl toplevel의 djgpp 서브 디렉토리에 Chdir을 입력하고 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8940df58b96cd7c07fc9ea07120c785f6f8a4a5c" translate="yes" xml:space="preserve">
          <source>Check a remote host for reachability</source>
          <target state="translated">연결 가능성에 대한 원격 호스트 확인</target>
        </trans-unit>
        <trans-unit id="d7a845256cebed69e9f121b044f6c493f63a9f2a" translate="yes" xml:space="preserve">
          <source>Check for correct syntax of hyperlinks &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . See &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; for details.</source>
          <target state="translated">하이퍼 링크 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 의 올바른 구문을 확인하십시오 . 자세한 내용은 &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abb3f832fd190f3b3ed53530b24afb5eea0c92cc" translate="yes" xml:space="preserve">
          <source>Check for duplicate declarations: report any of:</source>
          <target state="translated">중복 선언 확인 : 다음 중 하나를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="958d7ef30eb1cb4c2c9bdb613326b0eabb0fd9a1" translate="yes" xml:space="preserve">
          <source>Check for malformed or non-existing entities &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">잘못되었거나 존재하지 않는 엔터티 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9bacd3ffc2516115599a71ea7b04dc011ace75" translate="yes" xml:space="preserve">
          <source>Check for proper balancing of &lt;code&gt;=begin&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt; . The contents of such a block are generally ignored, i.e. no syntax checks are performed.</source>
          <target state="translated">&lt;code&gt;=begin&lt;/code&gt; 및 &lt;code&gt;=end&lt;/code&gt; 의 적절한 균형을 확인하십시오 . 이러한 블록의 내용은 일반적으로 무시됩니다. 즉, 구문 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cf90762a2de5be38eed8acc089a711c78e01421" translate="yes" xml:space="preserve">
          <source>Check for proper nesting and balancing of &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; and &lt;code&gt;=back&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; 및 &lt;code&gt;=back&lt;/code&gt; 의 적절한 중첩 및 균형을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bb965418973274267147c8cc4fc0522a33ac593" translate="yes" xml:space="preserve">
          <source>Check for same nested interior-sequences (e.g. &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">동일한 중첩 된 내부 시퀀스를 확인하십시오 (예 : &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eacd44b00e12dfbcc0672a7ce6d8176f78df3437" translate="yes" xml:space="preserve">
          <source>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</source>
          <target state="translated">cur_env.je_ret의 사례 0 또는 3이 eval 컨텍스트 내에서만 사용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0d6f75515a999669b8c1d54704fc6c80c44584" translate="yes" xml:space="preserve">
          <source>Check for unresolved document-internal links. This check may also reveal misspelled links that seem to be internal links but should be links to something else.</source>
          <target state="translated">해결되지 않은 문서 내부 링크를 확인하십시오. 이 검사는 또한 내부 링크 인 것처럼 보이지만 다른 것으로 링크 된 철자가 틀린 링크를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6fabbaa68065f92237c60138ecddb521d11db66" translate="yes" xml:space="preserve">
          <source>Check if all required arguments have been provided</source>
          <target state="translated">필요한 모든 인수가 제공되었는지 확인</target>
        </trans-unit>
        <trans-unit id="f79df82175c5eb3e95e2c6cd96c98c735fe9a6fb" translate="yes" xml:space="preserve">
          <source>Check if the archive contains a certain file. It will return true if the file is in the archive, false otherwise.</source>
          <target state="translated">아카이브에 특정 파일이 포함되어 있는지 확인하십시오. 파일이 아카이브에 있으면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a3059c728f920e1399329e5c1ad9c928030d581" translate="yes" xml:space="preserve">
          <source>Check out the MLDBM module, available on CPAN in the directory</source>
          <target state="translated">CPAN의 디렉토리에있는 MLDBM 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ca159b8d6ca8bc89a6d10a26dae1e203c859a67d" translate="yes" xml:space="preserve">
          <source>Check that a hash is in an internally consistent state.</source>
          <target state="translated">해시가 내부적으로 일관성있는 상태인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6c679ad8ca10d169e6a7df72723849d47a11c40b" translate="yes" xml:space="preserve">
          <source>Check that some temporary files did not make into the perl install tree. Run something like this</source>
          <target state="translated">일부 임시 파일이 perl 설치 트리로 작성되지 않았는지 점검하십시오. 이런 식으로 실행</target>
        </trans-unit>
        <trans-unit id="9defd6564bb9099fa189d5588407b66bb7555daa" translate="yes" xml:space="preserve">
          <source>Check that you have &lt;b&gt;BSD&lt;/b&gt; libraries and headers installed, and - optionally - Berkeley DB headers and libraries, and crypt.</source>
          <target state="translated">&lt;b&gt;BSD&lt;/b&gt; 라이브러리 및 헤더가 설치되어 있고 선택적으로 Berkeley DB 헤더 및 라이브러리 및 암호가 설치되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cfcc4548a2343eadc2629dda5508ccfded48bd5" translate="yes" xml:space="preserve">
          <source>Check that you have link386 installed. It comes standard with OS/2, but may be not installed due to customization. If typing</source>
          <target state="translated">link386이 설치되어 있는지 확인하십시오. OS / 2에는 표준으로 제공되지만 사용자 정의로 인해 설치되지 않을 수 있습니다. 입력하는 경우</target>
        </trans-unit>
        <trans-unit id="79d08dd23471c409ed3ca7645ef7d274508c7b47" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;Benchmark&lt;/code&gt; docs for further useful techniques.</source>
          <target state="translated">유용한 기술에 대해서는 &lt;code&gt;Benchmark&lt;/code&gt; 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="14e9adf4a018a86aa09ce8983af2c630914d716c" translate="yes" xml:space="preserve">
          <source>Check the CPAN Testers if a module should work with your platform but it doesn't behave as you'd expect, or you aren't sure whether or not a module will work under your platform. If the module you want isn't listed there, you can test it yourself and let CPAN Testers know, you can join CPAN Testers, or you can request it be tested.</source>
          <target state="translated">모듈이 플랫폼에서 작동해야하지만 예상대로 작동하지 않거나 모듈이 플랫폼에서 작동하는지 확실하지 않은 경우 CPAN 테스터를 확인하십시오. 원하는 모듈이 목록에 없으면 직접 테스트하여 CPAN 테스터에게 알리거나 CPAN 테스터에 가입하거나 테스트를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5173a90532c2701f8f8cdb88adc2b6f4e6723f22" translate="yes" xml:space="preserve">
          <source>Check the PerlIO::via:: namespace on CPAN for examples of PerlIO layers implemented in Perl. To give you an idea how simple the implementation of a PerlIO layer can look, a simple example is included here.</source>
          <target state="translated">Perl에서 구현 된 PerlIO 계층의 예는 CPAN의 PerlIO :: via :: 네임 스페이스를 확인하십시오. PerlIO 레이어의 구현이 얼마나 간단한 지 알기 위해 간단한 예제가 여기에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7b70cf85fde5d10a4d6750e595901816be3c74" translate="yes" xml:space="preserve">
          <source>Check the Pod syntax of a document</source>
          <target state="translated">문서의 포드 구문 확인</target>
        </trans-unit>
        <trans-unit id="f91480d26f728c8f70780347d46c3882a8821adf" translate="yes" xml:space="preserve">
          <source>Check the contents of the distribution. Read the module's documentation, looking for reasons why you might have trouble using it with MacPerl. Look for</source>
          <target state="translated">배포 내용을 확인하십시오. MacPerl에서 모듈을 사용하는 데 문제가있을 수있는 이유를 찾아 모듈 설명서를 읽으십시오. 찾다</target>
        </trans-unit>
        <trans-unit id="9e48cf52c63c2d0f64a711912719de261c9edcba" translate="yes" xml:space="preserve">
          <source>Check the validity of the stream if</source>
          <target state="translated">스트림의 유효성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9e8967b00a81a9d723ab21648f7d0d7f4c57338" translate="yes" xml:space="preserve">
          <source>Checkcc.U</source>
          <target state="translated">Checkcc.U</target>
        </trans-unit>
        <trans-unit id="82a2acac5750a7cb12b97634f29af8ec944c5757" translate="yes" xml:space="preserve">
          <source>Checking the environment entails either looking ahead on the trail, looking behind, or both. &lt;code&gt;^&lt;/code&gt; looks behind, to see that there are no characters before. &lt;code&gt;$&lt;/code&gt; looks ahead, to see that there are no characters after. &lt;code&gt;\b&lt;/code&gt; looks both ahead and behind, to see if the characters on either side differ in their &quot;word-ness&quot;.</source>
          <target state="translated">환경을 점검하려면 트레일을 미리 보거나 뒤에 보거나 둘 다를 수반해야합니다. &lt;code&gt;^&lt;/code&gt; 뒤에 문자가 없는지 확인하기 위해 뒤를 돌아 봅니다. 뒤에 문자가 없다는 것을 알기 위해 &lt;code&gt;$&lt;/code&gt; 가 계속 보입니다. &lt;code&gt;\b&lt;/code&gt; 는 앞뒤를 보면서 양쪽의 문자가 &quot;단어&quot;가 다른지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="223804327875b075a53dd25f4221175abf389942" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;. Tests:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 확인합니다 . 테스트 :</target>
        </trans-unit>
        <trans-unit id="3a60535c47ae3686d1195136cbe426251f2f931d" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; on a filehandle just opened for write - I do not know why this should or should not work.</source>
          <target state="translated">쓰기 위해 열린 파일 핸들에서 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; 를 확인합니다 -왜 이것이 작동 해야하는지 모르겠습니다.</target>
        </trans-unit>
        <trans-unit id="564e49285a0398ab07e0e7063594b4b39a5abcbe" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;atime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; - unfortunately, HPFS provides only 2sec time granularity (for compatibility with FAT?).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;atime&lt;/code&gt; 및 &lt;code&gt;mtime&lt;/code&gt; 을 확인합니다. 불행히도 HPFS는 2 초의 시간 단위 (FAT와의 호환성을 위해) 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7aa1e4bbcb9ef8e50cbb1ca2e0aa94d40c33e10" translate="yes" xml:space="preserve">
          <source>Checks for VMS directory spec as well as Unix separators.</source>
          <target state="translated">VMS 디렉토리 스펙과 유닉스 구분 기호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3af941bd688efd7585a7f0e144f9af47e846d7a5" translate="yes" xml:space="preserve">
          <source>Checks for the perl program under several common perl extensions.</source>
          <target state="translated">몇 가지 일반적인 perl 확장에서 perl 프로그램을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f3d96161e784b66068319a1db708dc0748d310a2" translate="yes" xml:space="preserve">
          <source>Checks if a group with the given name has matched something.</source>
          <target state="translated">주어진 이름을 가진 그룹이 무언가와 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b64ff69951ab67fee8d9d86a7a4cf97007ecbf7" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated inside of recursion.</source>
          <target state="translated">식이 재귀 안에서 평가되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c6dad515448c742f2dc10676e5ccdb019e7a0c22" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated while executing directly inside of the n-th capture group. This check is the regex equivalent of</source>
          <target state="translated">n 번째 캡처 그룹 내에서 직접 실행하는 동안 표현식이 평가되었는지 확인합니다. 이 검사는 정규식에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="29b9caf4fecb2c45031e3e282976736db6a59c9c" translate="yes" xml:space="preserve">
          <source>Checks if the numbered capturing group has matched something.</source>
          <target state="translated">번호가 매겨진 캡처 그룹이 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7915221a7e3c9b01fb693fd7e47a678921143862" translate="yes" xml:space="preserve">
          <source>Checks if two arrays are equivalent. This is a deep check, so multi-level structures are handled correctly.</source>
          <target state="translated">두 배열이 같은지 확인합니다. 이것은 철저한 검사이므로 다중 레벨 구조가 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e40bfce6a6d81449f234a025589a2a5b020bf9fa" translate="yes" xml:space="preserve">
          <source>Checks to make sure the $module or $object can do these @methods (works with functions, too).</source>
          <target state="translated">$ module 또는 $ object가 이러한 @method를 수행 할 수 있는지 확인합니다 (함수와 함께 작동).</target>
        </trans-unit>
        <trans-unit id="55b2f57a95767c489c56b01d1268c9dfc91fb618" translate="yes" xml:space="preserve">
          <source>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.</source>
          <target state="translated">SV가 오염되었는지 확인합니다. 참이면 참을, 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3c0b5dd82119b45805bc8cb1d101b8d9a91fd41" translate="yes" xml:space="preserve">
          <source>Checks to see if the current operating system is one of the given flavors.</source>
          <target state="translated">현재 운영 체제가 지정된 특징 중 하나인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="963de9ea3a8bb874b459828c02df2b61c6ee5c78" translate="yes" xml:space="preserve">
          <source>Checks to see if the given &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; . Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</source>
          <target state="translated">주어진 &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; 합니다. 또한 객체가 처음에 정의되었는지 확인합니다. 이런 종류의 일에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ac6373448a4e97de67ddcff713361ab246705ca8" translate="yes" xml:space="preserve">
          <source>Checks whether the pattern matches (or does not match, for the '!' variants).</source>
          <target state="translated">패턴이 일치하는지 또는 '!'변형에 대해 일치하지 않는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="acfac0fe5ba60bfef12b9f1265f8a0428c3029f8" translate="yes" xml:space="preserve">
          <source>Checksum field for the tar header</source>
          <target state="translated">tar 헤더의 체크섬 필드</target>
        </trans-unit>
        <trans-unit id="607b7fc55b056c24f1c8cacc3987ff9e25b1dcc5" translate="yes" xml:space="preserve">
          <source>Children's times are only included for terminated children.</source>
          <target state="translated">아동 시간은 해고 된 아동에게만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="189da622f3fbd822d1e732459ee0eddbbb7cd8ef" translate="yes" xml:space="preserve">
          <source>China-based Chinese Encodings</source>
          <target state="translated">중국 기반 중국어 인코딩</target>
        </trans-unit>
        <trans-unit id="d48a6b368170de01eb1a86e009fcbab8bf75cbe6" translate="yes" xml:space="preserve">
          <source>Chip Salzenberg &amp;lt;</source>
          <target state="translated">칩 잘젠 버그 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92e3f195464d519a284541bb4d50a0a8112bfbe" translate="yes" xml:space="preserve">
          <source>Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)</source>
          <target state="translated">적절하고 일관된 버전 번호 체계를 선택하십시오 (X.YY는 일반적인 Perl 모듈 번호 체계입니다)</target>
        </trans-unit>
        <trans-unit id="26d5375b27ee62ca78bfa742d3f1dc585cc2baa3" translate="yes" xml:space="preserve">
          <source>Choose an appropriate license (GPL/Artistic is a good default)</source>
          <target state="translated">적절한 라이센스를 선택하십시오 (GPL / Artistic이 좋은 기본값입니다)</target>
        </trans-unit>
        <trans-unit id="80fb4b6e80ff447b460548828bfa4306c5610812" translate="yes" xml:space="preserve">
          <source>Choose an appropriate name</source>
          <target state="translated">적절한 이름을 선택하십시오</target>
        </trans-unit>
        <trans-unit id="d82893eb0e9cc35f7e43c5d3e352d8ca738e05ba" translate="yes" xml:space="preserve">
          <source>Choose mnemonic identifiers. If you can't remember what mnemonic means, you've got a problem.</source>
          <target state="translated">니모닉 식별자를 선택하십시오. 니모닉의 의미를 기억할 수 없다면 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ed88e1b0d9bb812c4891cf57f9140a2970de186a" translate="yes" xml:space="preserve">
          <source>Choose wisely.</source>
          <target state="translated">현명하게 선택해.</target>
        </trans-unit>
        <trans-unit id="f68f3e0f920c046e7af5038b0261d7ac2b4646da" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">문자열의 마지막 문자를 잘라 내고 잘린 문자를 반환합니다. 문자열을 스캔하거나 복사하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 보다 훨씬 효율적 입니다. VARIABLE을 생략하면 &lt;code&gt;$_&lt;/code&gt; 잘라 냅니다. VARIABLE이 해시 인 경우 프로세스 의 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 해시 값을 자르고 키는 자르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06caa54c979ede41f81e5b2bef50565e9d2ae230" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">문자열의 마지막 문자를 잘라 내고 잘린 문자를 반환합니다. 문자열을 스캔하거나 복사하지 않기 때문에 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 보다 훨씬 효율적 입니다. VARIABLE을 생략하면 &lt;code&gt;$_&lt;/code&gt; 잘라 냅니다. VARIABLE이 해시 인 경우 프로세스 의 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 반복자를 재설정하여 해시 값을 자르고 키는 자르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="26d10419c85d39f36202cd562489c0cca977e3fc" translate="yes" xml:space="preserve">
          <source>Circular References</source>
          <target state="translated">원형 참조</target>
        </trans-unit>
        <trans-unit id="29285dd5c7a27e978de25c300eb6e17434a810c3" translate="yes" xml:space="preserve">
          <source>Civility is simple: stick to the facts while avoiding demeaning remarks and sarcasm. It is not enough to be factual. You must also be civil. Responding in kind to incivility is not acceptable.</source>
          <target state="translated">문명은 단순합니다. 사실을 고수하면서 말과 비난을 피하십시오. 사실이 충분하지 않습니다. 또한 시민이어야합니다. 무례에 대한 종류의 대응은 용납되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="1e7fb31960aaba1258b4feeaa688fcb9336dfe6f" translate="yes" xml:space="preserve">
          <source>Class Creation at Compile Time</source>
          <target state="translated">컴파일 타임에 클래스 생성</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="3fda1907fb10f41774bfaecce153bd2dcb1991b7" translate="yes" xml:space="preserve">
          <source>Class Names as Strings</source>
          <target state="translated">문자열로서의 클래스 이름</target>
        </trans-unit>
        <trans-unit id="f3e7ba90394996375a075b54692b14d58b442ff0" translate="yes" xml:space="preserve">
          <source>Class method for use inside a thread to change its own behavior for &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 의 자체 동작을 변경하기 위해 스레드 내부에서 사용하기위한 클래스 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="a38175b54007e6872fad46c411f63af989070306" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to detach itself.</source>
          <target state="translated">스레드가 스스로 분리 할 수 ​​있도록하는 클래스 메소드</target>
        </trans-unit>
        <trans-unit id="0e0095b85b575f8ed03afeaf1d333c819ad78615" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to determine whether or not it is detached.</source>
          <target state="translated">스레드가 분리되었는지 여부를 판별 할 수있는 클래스 메소드.</target>
        </trans-unit>
        <trans-unit id="e73d227a516617a6441904d7cb0de003fa8faaff" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own</source>
          <target state="translated">스레드가 자체적으로 얻을 수있는 클래스 메소드</target>
        </trans-unit>
        <trans-unit id="4898ddb7865314fdb26c20ddf401c39b5082833c" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own ID.</source>
          <target state="translated">스레드가 자체 ID를 얻을 수있게하는 클래스 메소드.</target>
        </trans-unit>
        <trans-unit id="fddf8c93c0000670b5cdf682b97e468968024e66" translate="yes" xml:space="preserve">
          <source>Class method to return the current thread's context. This returns the same value as running &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; inside the current thread's entry point function.</source>
          <target state="translated">현재 스레드의 컨텍스트를 반환하는 클래스 메서드 현재 스레드의 진입 점 함수 내에서 &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; 를 실행하는 것과 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="61e8fdd13a105e0002eef0663431494746684737" translate="yes" xml:space="preserve">
          <source>Class::Accessor</source>
          <target state="translated">Class::Accessor</target>
        </trans-unit>
        <trans-unit id="394e591256dfedee8ffcd71362b2ad76a446733c" translate="yes" xml:space="preserve">
          <source>Class::C3</source>
          <target state="translated">Class::C3</target>
        </trans-unit>
        <trans-unit id="6d45f04ee3b770e5707c62b830d994b42f571d44" translate="yes" xml:space="preserve">
          <source>Class::Struct</source>
          <target state="translated">Class::Struct</target>
        </trans-unit>
        <trans-unit id="2ea8699f7b748850b0a3f5be8865468e94f1fe28" translate="yes" xml:space="preserve">
          <source>Class::Struct - declare struct-like datatypes as Perl classes</source>
          <target state="translated">Class :: Struct-구조체와 유사한 데이터 유형을 Perl 클래스로 선언</target>
        </trans-unit>
        <trans-unit id="eabd5b700d02e72052a5dba7a49163d27d89c51a" translate="yes" xml:space="preserve">
          <source>Class::Tiny</source>
          <target state="translated">Class::Tiny</target>
        </trans-unit>
        <trans-unit id="77e7593f3ad030d22758c56fb1b2215a3db2ee44" translate="yes" xml:space="preserve">
          <source>Classes and inherited methods.</source>
          <target state="translated">클래스와 상속 된 메소드.</target>
        </trans-unit>
        <trans-unit id="1161f577bbba62479b9f81c878cce8a1b390e9a9" translate="yes" xml:space="preserve">
          <source>Classes based on the &lt;code&gt;id()&lt;/code&gt; function (and hence classes based on &lt;code&gt;idhash()&lt;/code&gt; and &lt;code&gt;fieldhash()&lt;/code&gt; ) show a peculiar behavior in that the class name can be used like an object. Specifically, methods that set or read data associated with an object continue to work as class methods, just as if the class name were an object, distinct from all other objects, with its own data. This object may be called the</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 함수를 기반으로하는 클래스 (따라서 &lt;code&gt;idhash()&lt;/code&gt; 및 &lt;code&gt;fieldhash()&lt;/code&gt; 기반 클래스 )는 클래스 이름을 객체처럼 사용할 수 있다는 특이한 동작을 보여줍니다. 특히, 객체와 관련된 데이터를 설정하거나 읽는 메서드는 클래스 이름이 다른 모든 객체와 다른 객체 인 것처럼 자체 데이터가있는 것처럼 클래스 메서드로 계속 작동합니다. 이 개체는</target>
        </trans-unit>
        <trans-unit id="6fe3306e3ca4485e41a1374bad73dbf1cbd32c97" translate="yes" xml:space="preserve">
          <source>Clean out some extra dll.{base,exp} files which might be generated by gcc. Otherwise, take out all *.pdb files.</source>
          <target state="translated">gcc에 의해 생성 될 수있는 추가 dll. {base, exp} 파일을 정리하십시오. 그렇지 않으면 모든 * .pdb 파일을 꺼내십시오.</target>
        </trans-unit>
        <trans-unit id="44fff3c8b56cfdff2a4b1fd6a798cd0eef5df63b" translate="yes" xml:space="preserve">
          <source>Clean package to evaluate code in</source>
          <target state="translated">코드를 평가하기위한 패키지 정리</target>
        </trans-unit>
        <trans-unit id="10cfbcf1f47828bf537936a130691a497387fb6d" translate="yes" xml:space="preserve">
          <source>Clean up some OS specific files. Plus the temp file used to shorten a lot of commands. And the name mangler database.</source>
          <target state="translated">일부 OS 특정 파일을 정리하십시오. 또한 많은 명령을 단축하는 데 사용되는 임시 파일. 그리고 이름 mangler 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="81ba7eebd7e241b8a0d3ee0f0dc83f6dcb213ac0" translate="yes" xml:space="preserve">
          <source>Cleaning Up Your Path</source>
          <target state="translated">경로 정리</target>
        </trans-unit>
        <trans-unit id="c39c68e4f213f84f2b2c6b1480b516f413b3ce6f" translate="yes" xml:space="preserve">
          <source>Cleanup VOS core files</source>
          <target state="translated">VOS 코어 파일 정리</target>
        </trans-unit>
        <trans-unit id="89d75847cf7d1968a70859baea6df0822891a7f0" translate="yes" xml:space="preserve">
          <source>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</source>
          <target state="translated">컴파일 중 범위 끝에서 정리 :이 범위에서 어휘에 대한 최대 seq 번호를 설정하고 소개되지 않은 어휘에 대해 경고하십시오.</target>
        </trans-unit>
        <trans-unit id="090755b1798e39d1824b0b1af3f46d5a518ba79a" translate="yes" xml:space="preserve">
          <source>Clear (remove, delete, ...) all values from the tied array associated with object</source>
          <target state="translated">객체와 연결된 묶인 배열에서 모든 값을 지우거나</target>
        </trans-unit>
        <trans-unit id="f3388c6c3c8ea1834f8402fd24982f91fd19df77" translate="yes" xml:space="preserve">
          <source>Clear all cached times.</source>
          <target state="translated">캐시 된 시간을 모두 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="d49faf737a36f02abafb6ec88b142fb354d6f3ff" translate="yes" xml:space="preserve">
          <source>Clear all values from the tied hash</source>
          <target state="translated">묶인 해시에서 모든 값을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="716a5cc3044dab9309ffffc76efde99c4966f639" translate="yes" xml:space="preserve">
          <source>Clear an SV: call any destructors, free up any memory used by the body, and free the body itself. The SV's head is</source>
          <target state="translated">SV 지우기 : 소멸자를 호출하고 본문에서 사용하는 메모리를 비우고 본문 자체를 비 웁니다. SV의 머리는</target>
        </trans-unit>
        <trans-unit id="1f45c3303d209b593f661cc5395c426e8611e2fe" translate="yes" xml:space="preserve">
          <source>Clear end-of-file and error indicators. Should call &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; to set the &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags, which may suffice.</source>
          <target state="translated">파일 끝 및 오류 표시기를 지우십시오. &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 플래그 를 설정하려면 &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c704c7949a89c5080ffdb34efe24fd104216362a" translate="yes" xml:space="preserve">
          <source>Clear out all the active components of a CV. This can happen either by an explicit &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; , or by the reference count going to zero. In the former case, we keep the CvOUTSIDE pointer, so that any anonymous children can still follow the full lexical scope chain.</source>
          <target state="translated">CV의 모든 활성 구성 요소를 지우십시오. 이것은 명시적인 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 또는 참조 카운트가 0 이 될 때 발생할 수 있습니다 . 전자의 경우 익명의 자식이 여전히 전체 어휘 범위 체인을 따를 수 있도록 CvOUTSIDE 포인터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8b91d04ce711fbc4bae58028f0e5981dcdbd67ba" translate="yes" xml:space="preserve">
          <source>Clear something magical that the SV represents. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">SV가 나타내는 마술 같은 것을 지우십시오. &lt;code&gt;sv_magic&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b01d4c4067d3dfce27d55a2e8d3ed5071a36b77" translate="yes" xml:space="preserve">
          <source>Clear the cached time for COUNT rounds of the null loop.</source>
          <target state="translated">null 루프의 COUNT 라운드에 대해 캐시 된 시간을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="46dd73c2f90db1a664404bb49713a30b15f4ee3a" translate="yes" xml:space="preserve">
          <source>Clear the default .SUFFIXES and put in our own list.</source>
          <target state="translated">기본 .SUFFIXES를 지우고 자체 목록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="1b8e52e2f767f085e79c243fc87322fea735897b" translate="yes" xml:space="preserve">
          <source>Clear the given handle's error indicator. Returns -1 if the handle is invalid, 0 otherwise.</source>
          <target state="translated">주어진 핸들의 오류 표시기를 지우십시오. 핸들이 유효하지 않으면 -1을, 그렇지 않으면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4550ae4c0426155ad5abb566d892619b67766b1" translate="yes" xml:space="preserve">
          <source>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</source>
          <target state="translated">범위 종료에서 지정된 패드 값을 지우십시오. (즉, 'my'의 런타임 동작)</target>
        </trans-unit>
        <trans-unit id="57a12ccd13dcf014dfc25137bea182ded0f98ac8" translate="yes" xml:space="preserve">
          <source>Clears a slot in the current scratchpad which corresponds to &lt;code&gt;sv&lt;/code&gt; at the end of</source>
          <target state="translated">현재 스크래치 패드에서 슬롯 의 끝에있는 &lt;code&gt;sv&lt;/code&gt; 에 해당하는 슬롯을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="3ef31da8d602e77684482123705889bd007979e0" translate="yes" xml:space="preserve">
          <source>Clears an array, making it empty. Does not free the memory the av uses to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed when this function returns.</source>
          <target state="translated">배열을 비워서 비 웁니다. av가 스칼라 목록을 저장하는 데 사용하는 메모리를 비우지 않습니다. 결과적으로 소멸자가 트리거되면이 함수가 리턴 될 때 av 자체가 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd338daf3e28d8a698a54a756c5a2c73cce2208" translate="yes" xml:space="preserve">
          <source>Clears any placeholders from a hash. If a restricted hash has any of its keys marked as readonly and the key is subsequently deleted, the key is not actually deleted but is marked by assigning it a value of &amp;amp;PL_sv_placeholder. This tags it so it will be ignored by future operations such as iterating over the hash, but will still allow the hash to have a value reassigned to the key at some future point. This function clears any such placeholder keys from the hash. See Hash::Util::lock_keys() for an example of its use.</source>
          <target state="translated">자리 표시자를 해시에서 지 웁니다. 제한된 해시에 키 중 하나가 읽기 전용으로 표시되고 이후에 키가 삭제되면 키는 실제로 삭제되지 않지만 키에 &amp;amp; PL_sv_placeholder 값을 지정하여 표시됩니다. 이것은 태그를 지정하여 해시 반복과 같은 향후 작업에서 무시되지만 나중에 해시가 키에 값을 다시 할당하도록 허용합니다. 이 함수는 이러한 자리 표시 자 키를 해시에서 지 웁니다. 사용 예는 Hash :: Util :: lock_keys ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8694e0be1c305fe59f17048c06b457a918bbcd82" translate="yes" xml:space="preserve">
          <source>Clears the internal table of &quot;seen&quot; references and returns the object itself.</source>
          <target state="translated">&quot;본&quot;참조의 내부 테이블을 지우고 개체 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47b31851c74e0f5ebbb3dfaea28b4822609aa2b8" translate="yes" xml:space="preserve">
          <source>Client Callback Methods</source>
          <target state="translated">클라이언트 콜백 메소드</target>
        </trans-unit>
        <trans-unit id="37da5860354a7f86a5ca376c0d24243e5da20032" translate="yes" xml:space="preserve">
          <source>Clients of &lt;b&gt;Pod::Parser&lt;/b&gt; should use the following methods to access instance data fields:</source>
          <target state="translated">&lt;b&gt;Pod :: Parser의&lt;/b&gt; 클라이언트는 다음 방법을 사용하여 인스턴스 데이터 필드에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6d24920f2b48bf829e8a23e9a90dfdd3440760d" translate="yes" xml:space="preserve">
          <source>Clone a CV, making a lexical closure.</source>
          <target state="translated">어휘 폐쇄를 만들어 CV를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="5f979b64a2e1385f3005f3cb2103d9f2baf2955c" translate="yes" xml:space="preserve">
          <source>Clone the state variables associated with running and compiling pads.</source>
          <target state="translated">실행 및 컴파일 패드와 관련된 상태 변수를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="8a76336a32c405fad8ce65baf95c160bc7bd1714" translate="yes" xml:space="preserve">
          <source>Cloning an interpreter</source>
          <target state="translated">통역사 복제</target>
        </trans-unit>
        <trans-unit id="4b55eaddcc64cc03fb97cb5cfdc6e4a0b7e1eab8" translate="yes" xml:space="preserve">
          <source>Close the data connection and get a response from the FTP server. Returns</source>
          <target state="translated">데이터 연결을 닫고 FTP 서버에서 응답을 받으십시오. 보고</target>
        </trans-unit>
        <trans-unit id="1c0a792433b635cbfbf3a9fa1132f2f138428c0e" translate="yes" xml:space="preserve">
          <source>Close the file associated with the object and disassociate the file from the handle. Done automatically on destroy.</source>
          <target state="translated">객체와 관련된 파일을 닫고 파일을 핸들에서 분리합니다. 파괴하면 자동으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="19ff0b1a9c29ac2abd677ef11d03ad865001d751" translate="yes" xml:space="preserve">
          <source>Close the file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일을 닫습니다. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6557bfb4a242f6c8d48bf95461a4833d7849fd1a" translate="yes" xml:space="preserve">
          <source>Close the handle</source>
          <target state="translated">핸들을 닫습니다</target>
        </trans-unit>
        <trans-unit id="bb4472090f184d3ee362c8c35a0ec02ede037401" translate="yes" xml:space="preserve">
          <source>Close the network connection for this ping object. The network connection is also closed by &quot;undef $p&quot;. The network connection is automatically closed if the ping object goes out of scope (e.g. $p is local to a subroutine and you leave the subroutine).</source>
          <target state="translated">이 핑 개체의 네트워크 연결을 닫습니다. &quot;undef $ p&quot;에 의해 네트워크 연결도 닫힙니다. Ping 오브젝트가 범위를 벗어나면 네트워크 연결이 자동으로 닫힙니다 (예 : $ p가 서브 루틴에 로컬이고 서브 루틴을 떠나는 경우).</target>
        </trans-unit>
        <trans-unit id="190ae3f86d0557b4127e04bcfb326cc6d030a90a" translate="yes" xml:space="preserve">
          <source>Close the stream. Should normally call &lt;code&gt;PerlIOBase_close()&lt;/code&gt; to flush itself and close layers below, and then deallocate any data structures (buffers, translation tables, ...) not held directly in the data structure.</source>
          <target state="translated">스트림을 닫습니다. 일반적으로 &lt;code&gt;PerlIOBase_close()&lt;/code&gt; 를 호출 하여 자체를 플러시하고 아래 레이어를 닫은 다음 데이터 구조에 직접 보유하지 않은 데이터 구조 (버퍼, 변환 테이블 등)를 할당 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="31da48802b39a62004814937a9e31811a752be6b" translate="yes" xml:space="preserve">
          <source>Closely associated with the &lt;code&gt;//g&lt;/code&gt; modifier is the &lt;code&gt;\G&lt;/code&gt; anchor. The &lt;code&gt;\G&lt;/code&gt; anchor matches at the point where the previous &lt;code&gt;//g&lt;/code&gt; match left off. &lt;code&gt;\G&lt;/code&gt; allows us to easily do context-sensitive matching:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 수정 자 와 밀접하게 관련된 것은 &lt;code&gt;\G&lt;/code&gt; 앵커입니다. &lt;code&gt;\G&lt;/code&gt; 이전 지점에서 앵커 일치 &lt;code&gt;//g&lt;/code&gt; 경기 중단. &lt;code&gt;\G&lt;/code&gt; 사용하면 상황에 맞는 일치를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed2c86b22aa0e19fdc594e6bdac3be5d440f77af" translate="yes" xml:space="preserve">
          <source>Closely associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the</source>
          <target state="translated">일치하는 변수 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... 와 밀접하게 연관된</target>
        </trans-unit>
        <trans-unit id="4c6e55c513c3700cb482b5228ee114dea0eb2014" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 에 의해 열린 디렉토리를 닫고 해당 시스템 호출의 성공을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1718bbd298f85e4f92aa5e14dbae95e752272e78" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 에 의해 열린 디렉토리를 닫고 해당 시스템 호출의 성공을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c738bf1c5aeadafd66d4f3177f0ec53c7a05eef3" translate="yes" xml:space="preserve">
          <source>Closes the compressed file. Any pending data is flushed to the file before it is closed.</source>
          <target state="translated">압축 파일을 닫습니다. 보류중인 데이터는 파일을 닫기 전에 파일로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d528fd6e4e57f9b4f4824f906e152d2b52aa44" translate="yes" xml:space="preserve">
          <source>Closes the current compressed data stream and starts a new one.</source>
          <target state="translated">현재 압축 된 데이터 스트림을 닫고 새 스트림을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="51e188a428b2b9dba319c461ba18765571b8c558" translate="yes" xml:space="preserve">
          <source>Closes the file or pipe associated with the filehandle, flushes the IO buffers, and closes the system file descriptor. Returns true if those operations succeed and if no error was reported by any PerlIO layer. Closes the currently selected filehandle if the argument is omitted.</source>
          <target state="translated">파일 핸들과 연관된 파일 또는 파이프를 닫고 IO 버퍼를 플러시하고 시스템 파일 설명자를 닫습니다. 해당 작업이 성공하고 PerlIO 계층에서 오류가보고되지 않은 경우 true를 반환합니다. 인수가 생략되면 현재 선택된 파일 핸들을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="fea628f203f0d9f7135eed7983ec3d8792beb442" translate="yes" xml:space="preserve">
          <source>Closes the log file and returns true on success.</source>
          <target state="translated">로그 파일을 닫고 성공하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2bbc309bbe5a51ba61bf619d197d1239e2eb8ce" translate="yes" xml:space="preserve">
          <source>Closes the output file/buffer.</source>
          <target state="translated">출력 파일 / 버퍼를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="ba43eac7b65017fd2089f1e6bc015f1ec8c511e2" translate="yes" xml:space="preserve">
          <source>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">파이프 된 파일 핸들을 닫으면 상위 프로세스가 하위 프로세스가 완료 될 때까지 대기 한 다음 상태 값을 &lt;code&gt;$?&lt;/code&gt; 및 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dcf08fb56e6d72fb32ed7e1eabe87691436e56" translate="yes" xml:space="preserve">
          <source>Closing bracket for XSUB arguments. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for other uses.</source>
          <target state="translated">XSUB 인수에 대한 닫는 대괄호. 이것은 일반적으로 &lt;code&gt;xsubpp&lt;/code&gt; 에 의해 처리됩니다 . 다른 용도에 대해서는 &lt;code&gt;PUSHMARK&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="737b7e3ad0d2423ad5a8db0c5d04ee20b1d52475" translate="yes" xml:space="preserve">
          <source>Closing bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">가벼운 콜백을위한 닫기 브래킷. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall의 LIGHTWEIGHT CALLBACKS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2745a4c8776a0e5fafe11f0f22ec70fe0d72258" translate="yes" xml:space="preserve">
          <source>Closing bracket for temporaries on a callback. See &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 임시에 대한 닫는 대괄호입니다. &lt;code&gt;SAVETMPS&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ba349d3ba72088b84c46b90a7f642094300bd0d" translate="yes" xml:space="preserve">
          <source>Closing bracket on a callback. See &lt;code&gt;ENTER&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">콜백에서 닫는 괄호. &lt;code&gt;ENTER&lt;/code&gt; 및 &lt;a href=&quot;perlcall&quot;&gt;perlcall을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23a4c843ad3bbdd040a62a1e5a6170f0fcb264c5" translate="yes" xml:space="preserve">
          <source>Closing the read end of a pipe before the process writing to it at the other end is done writing results in the writer receiving a SIGPIPE. If the other end can't handle that, be sure to read all the data before closing the pipe.</source>
          <target state="translated">프로세스가 다른 쪽 끝에 파이프에 쓰기 전에 파이프의 읽기 쪽을 닫으면 작성기가 SIGPIPE를받습니다. 다른 쪽 끝이이를 처리 할 수없는 경우 파이프를 닫기 전에 모든 데이터를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="b6d86b58c6ea474356b305c2ad2f3387941bd459" translate="yes" xml:space="preserve">
          <source>Closures are documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">클로저는 &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; 에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e50ba612fbe1c93f394383c8388d370e33f827" translate="yes" xml:space="preserve">
          <source>Closures are most often used in programming languages where you can have the return value of a function be itself a function, as you can in Perl. Note that some languages provide anonymous functions but are not capable of providing proper closures: the Python language, for example. For more information on closures, check out any textbook on functional programming. Scheme is a language that not only supports but encourages closures.</source>
          <target state="translated">클로저는 Perl 에서처럼 함수의 반환 값을 함수로 가질 수있는 프로그래밍 언어에서 가장 자주 사용됩니다. 일부 언어는 익명 함수를 제공하지만 Python 언어와 같은 적절한 클로저를 제공 할 수는 없습니다. 클로저에 대한 자세한 내용은 함수형 프로그래밍에 대한 모든 교과서를 확인하십시오. 체계는 폐쇄를 지원할뿐만 아니라 격려하는 언어입니다.</target>
        </trans-unit>
        <trans-unit id="625dad30655b90e54e26f3f025084dbfc6f7497b" translate="yes" xml:space="preserve">
          <source>Closures are often used for less esoteric purposes. For example, when you want to pass in a bit of code into a function:</source>
          <target state="translated">폐쇄는 종종 난해한 목적으로 사용됩니다. 예를 들어, 약간의 코드를 함수에 전달하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5161af4a1cac3a1b9b45f56c8dea0b53f7bfbecc" translate="yes" xml:space="preserve">
          <source>Co-existence with stdio</source>
          <target state="translated">stdio와 공존</target>
        </trans-unit>
        <trans-unit id="6517f8be2c6a95c643a9a9b5bb9a2d69ac206184" translate="yes" xml:space="preserve">
          <source>Cocoa</source>
          <target state="translated">Cocoa</target>
        </trans-unit>
        <trans-unit id="95c99c8aeaa2e8fc96be370bcb2d2ba452daba68" translate="yes" xml:space="preserve">
          <source>Code &lt;code&gt;x&lt;/code&gt; skips a byte, since we don't need the count yet. Code &lt;code&gt;n&lt;/code&gt; takes care of the 16-bit big-endian integer address, and &lt;code&gt;C&lt;/code&gt; unpacks the record type. Being at offset 4, where the data begins, we need the count. &lt;code&gt;X4&lt;/code&gt; brings us back to square one, which is the byte at offset 0. Now we pick up the count, and zoom forth to offset 4, where we are now fully furnished to extract the exact number of data bytes, leaving the trailing checksum byte alone.</source>
          <target state="translated">코드 &lt;code&gt;x&lt;/code&gt; 는 아직 카운트가 필요하지 않기 때문에 바이트를 건너 뜁니다. 코드 &lt;code&gt;n&lt;/code&gt; 은 16 비트 빅 엔디안 정수 주소를 처리하고 &lt;code&gt;C&lt;/code&gt; 는 레코드 유형을 압축 해제합니다. 데이터가 시작되는 오프셋 4에 있기 때문에 카운트가 필요합니다. &lt;code&gt;X4&lt;/code&gt; 는 오프셋 0의 바이트 인 정사각형 1로 다시 돌아옵니다. 이제 카운트를 가져 와서 오프셋 4로 축소하여 정확한 데이터 바이트 수를 추출하여 후행 체크섬 바이트를 남겨 둡니다. 혼자.</target>
        </trans-unit>
        <trans-unit id="88ed008dc7a2ff797ab17a3de73dfdb055a98c4d" translate="yes" xml:space="preserve">
          <source>Code blocks such as &lt;code&gt;(?{BLOCK})&lt;/code&gt; are handled by temporarily passing control back to the perl parser, in a similar way that an interpolated array subscript expression such as &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; would be.</source>
          <target state="translated">&lt;code&gt;(?{BLOCK})&lt;/code&gt; 과 같은 코드 블록 은 &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; 와 같은 보간 배열 첨자 표현식과 유사한 방식으로 제어를 perl 파서에 일시적으로 다시 전달하여 처리됩니다 . &quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="762d66380b843da111702ccfbb2c67a26389d7e3" translate="yes" xml:space="preserve">
          <source>Code evaluation</source>
          <target state="translated">코드 평가</target>
        </trans-unit>
        <trans-unit id="37d37b9a8d116d9e1ae5c945c68e058e2feb14aa" translate="yes" xml:space="preserve">
          <source>Code expressions are zero-width assertions, and the value they return depends on their environment. There are two possibilities: either the code expression is used as a conditional in a conditional expression &lt;code&gt;(?(condition)...)&lt;/code&gt;, or it is not. If the code expression is a conditional, the code is evaluated and the result (i.e., the result of the last statement) is used to determine truth or falsehood. If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . The variable &lt;code&gt;$^R&lt;/code&gt; can then be used in code expressions later in the regexp. Here are some silly examples:</source>
          <target state="translated">코드 표현식은 너비가 0 인 어설 션이며 반환되는 값은 환경에 따라 다릅니다. 코드 표현식이 조건식 &lt;code&gt;(?(condition)...)&lt;/code&gt; 에서 조건부로 사용 되거나 그렇지 않은 두 가지 가능성이 있습니다 . 코드 표현식이 조건부 인 경우 코드가 평가되고 결과 (즉, 마지막 문의 결과)가 진실 또는 허위를 결정하는 데 사용됩니다. 코드 표현식이 조건부로 사용되지 않으면 어설 션은 항상 true로 평가되고 결과는 특수 변수 &lt;code&gt;$^R&lt;/code&gt; 됩니다. 변수 &lt;code&gt;$^R&lt;/code&gt; 은 나중에 정규 표현식의 코드 표현식에서 사용될 수 있습니다. 다음은 어리석은 예입니다.</target>
        </trans-unit>
        <trans-unit id="16588d7ea09d6c8a62bccdc2d6ce591ced66cdbf" translate="yes" xml:space="preserve">
          <source>Code expressions, conditional expressions, and independent expressions are</source>
          <target state="translated">코드 표현식, 조건식 및 독립 표현식은</target>
        </trans-unit>
        <trans-unit id="0d4a4669a2b66538a054bb02710d7250ecbe4161" translate="yes" xml:space="preserve">
          <source>Code for &lt;code&gt;constant()&lt;/code&gt; s regenerated by Nicholas Clark &amp;lt;</source>
          <target state="translated">Nicholas Clark이 다시 생성 한 &lt;code&gt;constant()&lt;/code&gt; 코드 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3cbaac4d40358f731935693702135f199e63c95" translate="yes" xml:space="preserve">
          <source>Code is executed in the caller's package.</source>
          <target state="translated">코드는 호출자의 패키지에서 실행됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
