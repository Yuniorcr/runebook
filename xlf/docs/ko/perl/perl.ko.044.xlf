<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="4759d0bf1837078279cedaffe79b3b9844ef0d71" translate="yes" xml:space="preserve">
          <source>Most often, the real question is how you can delete the last N lines without making more than one pass over the file, or how to do it without a lot of copying. The easy concept is the hard reality when you might have millions of lines in your file.</source>
          <target state="translated">가장 중요한 것은 실제 질문은 파일을 두 번 이상 통과하지 않고 마지막 N 줄을 삭제하는 방법 또는 많은 복사없이 수행하는 방법입니다. 쉬운 개념은 파일에 수백만 줄이있을 때 어려운 현실입니다.</target>
        </trans-unit>
        <trans-unit id="c39bff964e11a5bf3472bbb0b25d07ba29893372" translate="yes" xml:space="preserve">
          <source>Most paragraphs in your documentation will be ordinary blocks of text, like this one. You can simply type in your text without any markup whatsoever, and with just a blank line before and after. When it gets formatted, it will undergo minimal formatting, like being rewrapped, probably put into a proportionally spaced font, and maybe even justified.</source>
          <target state="translated">문서의 대부분의 단락은 이와 같은 일반적인 텍스트 블록입니다. 마크 업없이 텍스트를 입력하거나 앞뒤 빈 줄만 입력하면됩니다. 형식이 변경되면 다시 줄 바꿈하거나 비례 간격 글꼴에 넣거나 정당화 할 수있는 것처럼 최소한의 서식이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="758d5aaffea254b4a108f5a7e332dc97c651824c" translate="yes" xml:space="preserve">
          <source>Most people mean that greedy regexes match as much as they can. Technically speaking, it's actually the quantifiers (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; ) that are greedy rather than the whole pattern; Perl prefers local greed and immediate gratification to overall greed. To get non-greedy versions of the same quantifiers, use (&lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{}?&lt;/code&gt;).</source>
          <target state="translated">대부분의 사람들은 탐욕스러운 정규 표현식이 최대한 일치한다는 것을 의미합니다. 기술적으로 말하면 실제로 전체 패턴이 아닌 욕심 많은 수량 자 ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; )입니다. Perl은 현지 탐욕과 전체 탐욕에 대한 즉각적인 만족을 선호합니다. 같은 한정사, 사용의 비 욕심 버전을 얻으려면 ( &lt;code&gt;??&lt;/code&gt; , &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , &lt;code&gt;{}?&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="61da54e1705a16eee7e2b6ceef3fefda6354d4c3" translate="yes" xml:space="preserve">
          <source>Most people mean that greedy regexes match as much as they can. Technically speaking, it's actually the quantifiers (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;) that are greedy rather than the whole pattern; Perl prefers local greed and immediate gratification to overall greed. To get non-greedy versions of the same quantifiers, use (&lt;code&gt;??&lt;/code&gt;, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;{}?&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d247005e28d9890e433308bb61b16e11eb364199" translate="yes" xml:space="preserve">
          <source>Most people try to use the time rather than the calendar to figure out dates, but that assumes that days are twenty-four hours each. For most people, there are two days a year when they aren't: the switch to and from summer time throws this off. For example, the rest of the suggestions will be wrong sometimes:</source>
          <target state="translated">대부분의 사람들은 날짜를 알아 내기 위해 달력이 아닌 시간을 사용하려고하지만 날짜는 각각 24 시간이라고 가정합니다. 대부분의 사람들에게는 1 년에 2 일이 그렇지 않은 경우가 있습니다. 예를 들어, 나머지 제안은 때때로 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="07b59a28d545dc68a00653586a9af9908a625c7c" translate="yes" xml:space="preserve">
          <source>Most platforms these days structure files in a hierarchical fashion. So, it is reasonably safe to assume that all platforms support the notion of a &quot;path&quot; to uniquely identify a file on the system. How that path is really written, though, differs considerably.</source>
          <target state="translated">요즘 대부분의 플랫폼은 파일을 계층 적으로 구성합니다. 따라서 모든 플랫폼이 시스템에서 파일을 고유하게 식별하기 위해 &quot;경로&quot;개념을 지원한다고 가정하는 것이 합리적입니다. 그러나 그 경로가 실제로 어떻게 쓰여지는지는 상당히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f5162bd3aaf5f209ead52eacd74062b771e3c04c" translate="yes" xml:space="preserve">
          <source>Most probably the most convenient form. Under OS/2 view it as</source>
          <target state="translated">아마도 가장 편리한 형태 일 것입니다. OS / 2에서</target>
        </trans-unit>
        <trans-unit id="b3219374aa50766aeb504023a6090322d39aaeb1" translate="yes" xml:space="preserve">
          <source>Most problems with &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; arise because the programmer thinks they have a number but really it's a string or vice versa. To avoid this, stringify the arguments explicitly (using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt;) or convert them to numbers explicitly (using &lt;code&gt;0+$arg&lt;/code&gt; ). The rest arise because the programmer says:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 와 대부분의 문제 &lt;code&gt;|&lt;/code&gt; 프로그래머가 숫자가 있다고 생각하기 때문에 발생하지만 실제로는 문자열이거나 그 반대입니다. 이를 피하려면 인수를 명시 적 으로 문자열 화하거나 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 qq () 사용) 인수를 명시 적 으로 숫자로 변환하십시오 ( &lt;code&gt;0+$arg&lt;/code&gt; ). 나머지는 프로그래머가 말하기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2718676853f0e2fd758f4f8f6b37c17469ccfcd0" translate="yes" xml:space="preserve">
          <source>Most problems with &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; arise because the programmer thinks they have a number but really it's a string or vice versa. To avoid this, stringify the arguments explicitly (using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;qq()&lt;/code&gt;) or convert them to numbers explicitly (using &lt;code&gt;0+$arg&lt;/code&gt;). The rest arise because the programmer says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97498d9b162518efa835ea3e4a21ab0beffd2067" translate="yes" xml:space="preserve">
          <source>Most programming languages don't shelter the memory where variables are stored. In C, for instance, you can take the address of some variable, and the &lt;code&gt;sizeof&lt;/code&gt; operator tells you how many bytes are allocated to the variable. Using the address and the size, you may access the storage to your heart's content.</source>
          <target state="translated">대부분의 프로그래밍 언어는 변수가 저장된 메모리를 보호하지 않습니다. 예를 들어 C에서는 일부 변수의 주소를 사용할 수 있으며 &lt;code&gt;sizeof&lt;/code&gt; 연산자는 변수에 할당 된 바이트 수를 알려줍니다. 주소와 크기를 사용하여 마음의 내용물을 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098186d7a29b8f65f8c838a2e5b2830d1de6af62" translate="yes" xml:space="preserve">
          <source>Most properties match the same code points regardless of whether &lt;code&gt;&quot;/i&quot;&lt;/code&gt; case-insensitive matching is specified or not. But a few properties are affected. These are shown with the notation &lt;code&gt;(/i= &lt;i&gt;other_property&lt;/i&gt;)&lt;/code&gt; in the second column. Under case-insensitive matching they match the same code pode points as the property</source>
          <target state="translated">대 &lt;code&gt;&quot;/i&quot;&lt;/code&gt; 소문자를 구분하지 않는 &quot;/ i&quot; 일치 여부에 관계없이 대부분의 속성은 동일한 코드 포인트와 일치합니다. 그러나 몇 가지 속성이 영향을받습니다. 이들은 두 번째 열에 표기법 &lt;code&gt;(/i= &lt;i&gt;other_property&lt;/i&gt;)&lt;/code&gt; 과 함께 표시 됩니다. 대소 문자를 구분하지 않는 일치 하에서 속성과 동일한 코드 포드 포인트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="93f39d1fecbeea5d31df34771fb4dfaa8600c5c6" translate="yes" xml:space="preserve">
          <source>Most ranges are unportable between character sets, but certain ones signal Perl to do special handling to make them portable. There are two classes of portable ranges. The first are any subsets of the ranges &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, and &lt;code&gt;0-9&lt;/code&gt;, when expressed as literal characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea7b30461e5f88919bb6524b261e1fbc23c8866" translate="yes" xml:space="preserve">
          <source>Most scripts should print some type of usage message to &lt;code&gt;STDERR&lt;/code&gt; when a command line syntax error is detected. They should also provide an option (usually &lt;code&gt;-H&lt;/code&gt; or &lt;code&gt;-help&lt;/code&gt; ) to print a (possibly more verbose) usage message to &lt;code&gt;STDOUT&lt;/code&gt; . Some scripts may even wish to go so far as to provide a means of printing their complete documentation to &lt;code&gt;STDOUT&lt;/code&gt; (perhaps by allowing a &lt;code&gt;-man&lt;/code&gt; option). The following complete example uses &lt;b&gt;Pod::Usage&lt;/b&gt; in combination with &lt;b&gt;Getopt::Long&lt;/b&gt; to do all of these things:</source>
          <target state="translated">대부분의 스크립트는 명령 행 구문 오류가 감지되면 일부 유형의 사용 메시지를 &lt;code&gt;STDERR&lt;/code&gt; 에 인쇄해야합니다 . 또한 사용 메시지를 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 하는 옵션 (보통 &lt;code&gt;-H&lt;/code&gt; 또는 &lt;code&gt;-help&lt;/code&gt; )을 제공해야합니다 . 일부 스크립트는 완전한 문서를 &lt;code&gt;STDOUT&lt;/code&gt; 에 인쇄 할 수있는 수단 (아마도 &lt;code&gt;-man&lt;/code&gt; 옵션 허용) 을 제공하기를 원할 수도 있습니다 . 다음 예제에서는 &lt;b&gt;Pod :: Usage&lt;/b&gt; 를 &lt;b&gt;Getopt :: Long&lt;/b&gt; 과 함께 &lt;b&gt;사용&lt;/b&gt; 하여 이러한 모든 작업을 수행합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65b0d0948142b7ec60acd9bde4f4e302c30d9528" translate="yes" xml:space="preserve">
          <source>Most scripts should print some type of usage message to &lt;code&gt;STDERR&lt;/code&gt; when a command line syntax error is detected. They should also provide an option (usually &lt;code&gt;-H&lt;/code&gt; or &lt;code&gt;-help&lt;/code&gt;) to print a (possibly more verbose) usage message to &lt;code&gt;STDOUT&lt;/code&gt;. Some scripts may even wish to go so far as to provide a means of printing their complete documentation to &lt;code&gt;STDOUT&lt;/code&gt; (perhaps by allowing a &lt;code&gt;-man&lt;/code&gt; option). The following complete example uses &lt;b&gt;Pod::Usage&lt;/b&gt; in combination with &lt;b&gt;Getopt::Long&lt;/b&gt; to do all of these things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2986b3da9e25c6ac2c76862bdb207bac32623aca" translate="yes" xml:space="preserve">
          <source>Most sequences are described in detail in different documents; the primary purpose of this document is to have a quick reference guide describing all backslash and escape sequences.</source>
          <target state="translated">대부분의 시퀀스는 다른 문서에 자세히 설명되어 있습니다. 이 문서의 주요 목적은 모든 백 슬래시 및 이스케이프 시퀀스를 설명하는 빠른 참조 안내서를 보유하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cf7387c1ea7a96beacd0b59cccd9572dbbcde67" translate="yes" xml:space="preserve">
          <source>Most sites usually disable this feature in their SMTP service configuration. Use &quot;Debug =&amp;gt; 1&quot; option under new() to see if disabled.</source>
          <target state="translated">대부분의 사이트는 일반적으로 SMTP 서비스 구성에서이 기능을 비활성화합니다. new ()에서 &quot;Debug =&amp;gt; 1&quot;옵션을 사용하여 비활성화되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="805a1b088f4235fc8495203b21cfd64c3f92735f" translate="yes" xml:space="preserve">
          <source>Most socket programming assumes ASCII character encodings in network byte order. Exceptions can include CGI script writing under a host web server where the server may take care of translation for you. Most host web servers convert EBCDIC data to ISO-8859-1 or Unicode on output.</source>
          <target state="translated">대부분의 소켓 프로그래밍은 ASCII 문자 인코딩을 네트워크 바이트 순서로 가정합니다. 서버에서 번역을 처리 할 수있는 호스트 웹 서버에서 CGI 스크립트 작성이 예외 일 수 있습니다. 대부분의 호스트 웹 서버는 EBCDIC 데이터를 ISO-8859-1 또는 출력시 유니 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="29ff99325371b7f580464c1d1eca725c963c97f2" translate="yes" xml:space="preserve">
          <source>Most software projects begin each file with a literal description of each file's purpose. Perl instead begins each with a literary allusion to that file's purpose.</source>
          <target state="translated">대부분의 소프트웨어 프로젝트는 각 파일의 목적에 대한 문자 설명으로 각 파일을 시작합니다. 펄은 대신 그 파일의 목적에 대한 문학적 암시로 시작한다.</target>
        </trans-unit>
        <trans-unit id="db6c865df11697d9eda20f45a2680b42a8a01010" translate="yes" xml:space="preserve">
          <source>Most source code ceases to be grammatically correct when it is broken up into the pieces between string literals and regexes. So the &lt;code&gt;'code'&lt;/code&gt; and &lt;code&gt;'code_no_comments'&lt;/code&gt; component filter behave slightly differently from the other partial filters described in the previous section.</source>
          <target state="translated">대부분의 소스 코드는 문자열 리터럴과 정규 표현식 사이의 조각으로 나눌 때 문법적으로 정확하지 않습니다. 따라서 &lt;code&gt;'code'&lt;/code&gt; 및 &lt;code&gt;'code_no_comments'&lt;/code&gt; 구성 요소 필터는 이전 섹션에서 설명한 다른 부분 필터와 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="335be1d7a3acfa7558b1ff815c489a483910fb62" translate="yes" xml:space="preserve">
          <source>Most subroutines documented in this module have equivalent versions that operate on references to hashes instead of native hashes. The following is a list of these subs. They are identical except in name and in that instead of taking a %hash they take a $hashref, and additionally are not prototyped.</source>
          <target state="translated">이 모듈에 문서화 된 대부분의 서브 루틴에는 기본 해시 대신 해시에 대한 참조에서 작동하는 동등한 버전이 있습니다. 다음은 이러한 하위 목록입니다. 그것들은 이름을 제외하고 동일하며 % hash 대신 $ hashref를 가져오고 추가적으로 프로토 타입이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="673b355050421a0f250c2913c779df1badafbdd4" translate="yes" xml:space="preserve">
          <source>Most systems do not bother to return anything useful in $timeleft, so calling select() in scalar context just returns $nfound.</source>
          <target state="translated">대부분의 시스템은 $ timeleft에 유용한 것을 반환하지 않으므로 스칼라 컨텍스트에서 select ()를 호출하면 $ nfound 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8cbac972b9177f5aed2cfd37309a35a3aa9a5f" translate="yes" xml:space="preserve">
          <source>Most systems do not bother to return anything useful in &lt;code&gt;$timeleft&lt;/code&gt;, so calling &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; in scalar context just returns &lt;code&gt;$nfound&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be0e0cacadb003a014aeecaa66260a81fb37a7" translate="yes" xml:space="preserve">
          <source>Most tasks only require a small subset of the Perl language. One of the guiding mottos for Perl development is &quot;there's more than one way to do it&quot; (TMTOWTDI, sometimes pronounced &quot;tim toady&quot;). Perl's learning curve is therefore shallow (easy to learn) and long (there's a whole lot you can do if you really want).</source>
          <target state="translated">대부분의 작업에는 작은 Perl 언어 하위 집합 만 필요합니다. Perl 개발을위한 모토 중 하나는 &quot;한 가지 이상의 방법이있다&quot;(TMTOWTDI, 때로는 &quot;tim toady&quot;라고 발음 함)이다. 따라서 Perl의 학습 곡선은 얕고 (배우기 쉬움) 길다 (실제로 원한다면 할 수있는 것이 많이있다).</target>
        </trans-unit>
        <trans-unit id="c9cf8e4a405ae90922b90be3b50350defeef4763" translate="yes" xml:space="preserve">
          <source>Most times, the pattern is evaluated in double-quotish context, but it is possible to choose delimiters to force single-quotish, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6ff5de9e8fc03a10f36de6d162848c70fb3768" translate="yes" xml:space="preserve">
          <source>Most useful when you can't depend on the test output order, such as when threads or forking is involved.</source>
          <target state="translated">스레드 또는 포킹과 같은 테스트 출력 순서에 의존 할 수 없을 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d352875a4c7ac21070cf3a1cd4743c30a9c2d0b1" translate="yes" xml:space="preserve">
          <source>Mount a different file system structure without changing login or accounting information.</source>
          <target state="translated">로그인 또는 계정 정보를 변경하지 않고 다른 파일 시스템 구조를 마운트하십시오.</target>
        </trans-unit>
        <trans-unit id="573dd2c2ed953b97e3c31f3090925fe92109b779" translate="yes" xml:space="preserve">
          <source>Mouse</source>
          <target state="translated">Mouse</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="b9c654f6de08d2f23a43dc1905efaf207281f877" translate="yes" xml:space="preserve">
          <source>Move on to the second group and pick the first alternative 'df'.</source>
          <target state="translated">두 번째 그룹으로 이동하여 첫 번째 대안 'df'를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="656251711514e69bd101328e64271cab684cd5f2" translate="yes" xml:space="preserve">
          <source>Move on to the third element '.*'. Since we are at the end of the string and '.*' can match 0 times, assign it the empty string.</source>
          <target state="translated">세 번째 요소 '. *'로 이동하십시오. 문자열의 끝에 있고 '. *'는 0 번 일치 할 수 있으므로 빈 문자열을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="a05a5599f4ff1f6f057b4c325aeb15095e59f574" translate="yes" xml:space="preserve">
          <source>Move the file's read/write position. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">파일의 읽기 / 쓰기 위치를 이동하십시오. &lt;code&gt;POSIX::open&lt;/code&gt; 을 호출하여 얻은 것과 같은 파일 디스크립터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5fc1e9ef37151e0b1e126ddb3041bc5885f75355" translate="yes" xml:space="preserve">
          <source>Move the file's read/write position. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222e9fd8bd8c25e24b2a3f8a53104c5ee2a7923b" translate="yes" xml:space="preserve">
          <source>MoveD</source>
          <target state="translated">MoveD</target>
        </trans-unit>
        <trans-unit id="80fa2eaea134b0cd5569d0e8ca67b027b0a7ab32" translate="yes" xml:space="preserve">
          <source>MoveFile</source>
          <target state="translated">MoveFile</target>
        </trans-unit>
        <trans-unit id="ff3e3393da77e789dbcbb3a42c7951722bbe29e4" translate="yes" xml:space="preserve">
          <source>MoveFileEx</source>
          <target state="translated">MoveFileEx</target>
        </trans-unit>
        <trans-unit id="92862065f1668adaa1d1045b66d5bf772503cc43" translate="yes" xml:space="preserve">
          <source>MoveFileExW</source>
          <target state="translated">MoveFileExW</target>
        </trans-unit>
        <trans-unit id="f8eb80496378f80b4e51f94af632152cabf7dadd" translate="yes" xml:space="preserve">
          <source>MoveFileW</source>
          <target state="translated">MoveFileW</target>
        </trans-unit>
        <trans-unit id="5c049050655e528eff7cc66a0c1978dd42e900ba" translate="yes" xml:space="preserve">
          <source>Moved from &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2278daf64913fd58204056d82689681803a8cd5" translate="yes" xml:space="preserve">
          <source>Moved from Perl 5.10.1 to CPAN</source>
          <target state="translated">Perl 5.10.1에서 CPAN으로 이동</target>
        </trans-unit>
        <trans-unit id="99a21ee175eac25359a901bcbda82fe551ce8663" translate="yes" xml:space="preserve">
          <source>Moved from Perl 5.9.0 to CPAN</source>
          <target state="translated">Perl 5.9.0에서 CPAN으로 이동</target>
        </trans-unit>
        <trans-unit id="5de42d916e82311c864672d75f077c9b2068801a" translate="yes" xml:space="preserve">
          <source>Moved out of &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; &amp;amp; converted to a factory class to support extensible TAP source detective work by Steve Purkis.</source>
          <target state="translated">Steve Purkis 의 &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser에서&lt;/a&gt; 벗어나 TAP 소스 탐사 작업을 지원하기 위해 팩토리 클래스로 변환했습니다.</target>
        </trans-unit>
        <trans-unit id="ea7e6117e52e814be500d918ab6f4d7fa770c757" translate="yes" xml:space="preserve">
          <source>Moved out of &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; &amp;amp; converted to a factory class to support extensible TAP source detective work by Steve Purkis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06473ac4424aa3537730dc5fa59fd056a6719bfb" translate="yes" xml:space="preserve">
          <source>Moved to Changes file.</source>
          <target state="translated">변경 파일로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="a36390af19221c7ada243c00a81cdf9c9fd9cb46" translate="yes" xml:space="preserve">
          <source>Moved to the Changes file.</source>
          <target state="translated">변경 파일로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="04735508f82cd9b0551e1cf6d2f2c73c1c36e575" translate="yes" xml:space="preserve">
          <source>Moves source to destination. Multiple sources are allowed if destination is an existing directory.</source>
          <target state="translated">소스를 대상으로 이동합니다. 대상이 기존 디렉토리 인 경우 여러 소스가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="65cd4dd8114610f7bacc1f81bb9dd01a137f162f" translate="yes" xml:space="preserve">
          <source>Moving</source>
          <target state="translated">Moving</target>
        </trans-unit>
        <trans-unit id="5dc46ce92133770b3cb0566e53187390443c015a" translate="yes" xml:space="preserve">
          <source>Moving to perl5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43ac9463df3e2d50948534cdbda94703301864a" translate="yes" xml:space="preserve">
          <source>Much better!</source>
          <target state="translated">훨씬 낫다!</target>
        </trans-unit>
        <trans-unit id="baae2905164a527d46c5511d6f6cde4ac79fa8cd" translate="yes" xml:space="preserve">
          <source>Multi-argument form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; allows an additional numeric argument. The meaning of this argument is described in &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::Process&quot;&gt;OS2::Process&lt;/a&gt;.</source>
          <target state="translated">다중 인수 형식의 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 은 추가 숫자 인수를 허용합니다. 이 인수의 의미는 &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::Process&quot;&gt;OS2 :: Process에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c2b4322d0dcbe5e345ade2ce04fea2a4d2add9" translate="yes" xml:space="preserve">
          <source>Multi-argument form of &lt;code&gt;system()&lt;/code&gt; allows an additional numeric argument. The meaning of this argument is described in &lt;a href=&quot;OS2::Process&quot;&gt;OS2::Process&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9857028e641dc5456ee948176f4473c16db09596" translate="yes" xml:space="preserve">
          <source>Multi-dimensional array emulation</source>
          <target state="translated">다차원 배열 에뮬레이션</target>
        </trans-unit>
        <trans-unit id="953b15a9991dd3cf45d05422ed2057e683840ca2" translate="yes" xml:space="preserve">
          <source>Multi-threaded</source>
          <target state="translated">Multi-threaded</target>
        </trans-unit>
        <trans-unit id="c69c3d945e47dae4c99c3ab199d1b9d455504d13" translate="yes" xml:space="preserve">
          <source>Multi-threaded operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57aac3c240d3e0ac36b471e64758ed7bdabec310" translate="yes" xml:space="preserve">
          <source>MultiEdit</source>
          <target state="translated">MultiEdit</target>
        </trans-unit>
        <trans-unit id="450c5aa974c7a5f408f5a12f136ca88727d8798b" translate="yes" xml:space="preserve">
          <source>MultiHomed</source>
          <target state="translated">MultiHomed</target>
        </trans-unit>
        <trans-unit id="4844caf78b10cf385ed68d57ca4c64d998065cbb" translate="yes" xml:space="preserve">
          <source>Multiblock count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f531e0d77ec76c8767bb9e4fb3934a040894292" translate="yes" xml:space="preserve">
          <source>Multicall Functions</source>
          <target state="translated">다중 호출 기능</target>
        </trans-unit>
        <trans-unit id="498682cb179ef81881fc0701c5fef4200dc2318b" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays may be emulated by subscripting a hash with a list. The elements of the list are joined with the subscript separator (see &lt;a href=&quot;perlvar#%24%3B&quot;&gt;&quot;$;&quot; in perlvar&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f46258b912e10d35fd5082f358a2c20442fe00" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays may be emulated by subscripting a hash with a list. The elements of the list are joined with the subscript separator (see &lt;a href=&quot;perlvar#%24%3b&quot;&gt;$; in perlvar&lt;/a&gt;).</source>
          <target state="translated">다차원 배열은 목록으로 해시를 첨자 화하여 에뮬레이션 할 수 있습니다. 목록의 요소는 첨자 구분 기호와 결합됩니다 ( &lt;a href=&quot;perlvar#%24%3b&quot;&gt;$; perlvar&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f938af18a3f6f3ad92f399fa7884135f73cf19e" translate="yes" xml:space="preserve">
          <source>Multidimensional syntax %s not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4270bb13db0a8c118eef1b6d5f8e97e9e384c0" translate="yes" xml:space="preserve">
          <source>Multiline commands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dfb27b6e58426cb7118d4abc1cd99a64af78a3" translate="yes" xml:space="preserve">
          <source>Multiple &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declarations with the same name in the same lexical scope are allowed if they are in different packages. If they happen to be in the same package, Perl will emit warnings if you have asked for them, just like multiple &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; declarations. Unlike a second &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; declaration, which will bind the name to a fresh variable, a second &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration in the same package, in the same scope, is merely redundant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b29c6623047ed312fa13a7468cb3a2585d42cc" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;-M&lt;/code&gt; options are processed from left to right. So this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f96f856d2f7161b69ace4cbe667d2f05f5d119" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations with the same name in the same lexical scope are allowed if they are in different packages. If they happen to be in the same package, Perl will emit warnings if you have asked for them, just like multiple &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations. Unlike a second &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declaration, which will bind the name to a fresh variable, a second &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration in the same package, in the same scope, is merely redundant.</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 서로 다른 패키지에있는 경우 같은 어휘 범위에서 같은 이름의 선언이 허용됩니다. 그들은 같은 패키지에 될 일 경우, 펄은 당신이 그들을 요구 한 경우, 경고를 방출 단지 복수와 같은 것입니다 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언. 두 번째는 달리 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , 새로운 변수에 두 번째 이름을 바인딩 선언, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 같은 패키지에 선언을, 같은 범위에서, 단순히 중복입니다.</target>
        </trans-unit>
        <trans-unit id="9985bd0ec5a4c016728a57fca407ec3ba9776cda" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations with the same name in the same lexical scope are allowed if they are in different packages. If they happen to be in the same package, Perl will emit warnings if you have asked for them, just like multiple &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations. Unlike a second &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declaration, which will bind the name to a fresh variable, a second &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration in the same package, in the same scope, is merely redundant.</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 서로 다른 패키지에있는 경우 같은 어휘 범위에서 같은 이름의 선언이 허용됩니다. 그들은 같은 패키지에 될 일 경우, 펄은 당신이 그들을 요구 한 경우, 경고를 방출 단지 복수와 같은 것입니다 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 선언. 두 번째는 달리 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , 새로운 변수에 두 번째 이름을 바인딩 선언, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 같은 패키지에 선언을, 같은 범위에서, 단순히 중복입니다.</target>
        </trans-unit>
        <trans-unit id="48353bd1f51bb6eec720b26a40670dcc8efa9d3b" translate="yes" xml:space="preserve">
          <source>Multiple Inheritance</source>
          <target state="translated">다중 상속</target>
        </trans-unit>
        <trans-unit id="cbb8ace32d78b2ae6f01fe57c603e73837a4bd68" translate="yes" xml:space="preserve">
          <source>Multiple alternate names are possible.</source>
          <target state="translated">여러 개의 대체 이름이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b26a054b05093a88178030f5a8b1997575b74ff" translate="yes" xml:space="preserve">
          <source>Multiple constant declarations at once added by Casey West, &amp;lt;</source>
          <target state="translated">Casey West에 의해 한 번에 여러 개의 상수 선언이 추가됨, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="285ddce39862d8fe5e23d4388af8d0a347056a9c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance often indicates a design problem, but Perl always gives you enough rope to hang yourself with if you ask for it.</source>
          <target state="translated">다중 상속은 종종 디자인 문제를 나타내지 만 Perl은 요청하면 항상 매달릴 수있는 충분한 로프를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d9f2a08980cf6a269a8484f3b1b84e9a908ab93" translate="yes" xml:space="preserve">
          <source>Multiple options may be separated by colons:</source>
          <target state="translated">콜론으로 여러 옵션을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711c51a111027364db7380ccd9acdaec1492d123" translate="yes" xml:space="preserve">
          <source>Multiple packages</source>
          <target state="translated">여러 패키지</target>
        </trans-unit>
        <trans-unit id="e5cb4101d607c5394d01741bac5f7456e4908d11" translate="yes" xml:space="preserve">
          <source>Multiple packages and fully qualified subroutine names</source>
          <target state="translated">여러 패키지 및 완전한 서브 루틴 이름</target>
        </trans-unit>
        <trans-unit id="24101d9d31bf0129420330c39c5cf010537d4874" translate="yes" xml:space="preserve">
          <source>Multiple slurpy parameters not allowed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436ca522c08df8bc62c5560d209e972cbfc6c8f8" translate="yes" xml:space="preserve">
          <source>Multiple tar archive filenames can be specified - they will each be processed in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6459b694c217e7d6e4f4403e095b344a4a592d8" translate="yes" xml:space="preserve">
          <source>Multiplex multiple TAP::Parsers</source>
          <target state="translated">다중 다중 TAP :: 파서</target>
        </trans-unit>
        <trans-unit id="150be49d038f614e193602a7005597f5ff875ec0" translate="yes" xml:space="preserve">
          <source>Multiplicative Operators</source>
          <target state="translated">곱하기 연산자</target>
        </trans-unit>
        <trans-unit id="f231b68e224950ab7816fb6e20b4d2a930d3893b" translate="yes" xml:space="preserve">
          <source>Multiplicity is required when embedding Perl in a C program and using more than one interpreter instance. This is only required when you build a not-threaded perl with &lt;code&gt;-Uuseithreads&lt;/code&gt; .</source>
          <target state="translated">C 프로그램에 Perl을 임베드하고 둘 이상의 인터프리터 인스턴스를 사용하는 경우 다중성이 필요합니다. 이것은 &lt;code&gt;-Uuseithreads&lt;/code&gt; 로 스레드되지 않은 펄을 빌드 할 때만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6c8c6ecf04843cba53a3a0dc6d02df3607984c15" translate="yes" xml:space="preserve">
          <source>Multiplicity is required when embedding Perl in a C program and using more than one interpreter instance. This is only required when you build a not-threaded perl with &lt;code&gt;-Uuseithreads&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a823acc8d727a505e347a4373b2b4a2fd658bbbd" translate="yes" xml:space="preserve">
          <source>Multiplies $y to $x and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c164249090c5dcf176539a56868115da2c726290" translate="yes" xml:space="preserve">
          <source>Multiply $x by $y, and then add $z to the result,</source>
          <target state="translated">$ x에 $ y를 곱한 다음 결과에 $ z를 더합니다.</target>
        </trans-unit>
        <trans-unit id="ccb1f5d6ba5d2943ea716c8d09ca6acbfac04509" translate="yes" xml:space="preserve">
          <source>Multiply $x by $y, and then add $z to the result.</source>
          <target state="translated">$ x에 $ y를 곱한 다음 결과에 $ z를 더하십시오.</target>
        </trans-unit>
        <trans-unit id="ee25591d06b217f4358e8b341dce8e1906aeef44" translate="yes" xml:space="preserve">
          <source>Multiprocessor kernel threads are the final step in thread support. With multiprocessor kernel threads on a machine with multiple CPUs, the OS may schedule two or more threads to run simultaneously on different CPUs.</source>
          <target state="translated">멀티 프로세서 커널 스레드는 스레드 지원의 마지막 단계입니다. 여러 개의 CPU가있는 머신에서 다중 프로세서 커널 스레드를 사용하면 OS가 두 개 이상의 스레드가 다른 CPU에서 동시에 실행되도록 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82309bfc506cd2ed77334625f12e0460757a107" translate="yes" xml:space="preserve">
          <source>Must be one of the following licenses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafd5d404242155cb8650eca5e234b7aeedd750b" translate="yes" xml:space="preserve">
          <source>Must be passed an array reference.</source>
          <target state="translated">배열 참조를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8387835af5df8bfeb3d9299ef8165454a3d981d" translate="yes" xml:space="preserve">
          <source>Mustn't forget to change the number of tests which appears at the top, or else the automated tester will get confused. This will either look like this:</source>
          <target state="translated">맨 위에 표시되는 테스트 수를 변경해야합니다. 그렇지 않으면 자동화 된 테스터가 혼동됩니다. 이것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="fb98af5989ebce8fc6cd27827500b2f2656fae01" translate="yes" xml:space="preserve">
          <source>My ftp proxy firewall does not listen on port 21</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdcdee602cc75b045989a2d406d8d4ffd6c037c" translate="yes" xml:space="preserve">
          <source>My personal recommendation, out of respect for Larry, Perl, and the Perl community at large is to state something simply like:</source>
          <target state="translated">Larry, Perl 및 Perl 커뮤니티에 대한 저의 개인적인 추천은 다음과 같이 간단하게 진술하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be4eba3c145424407628857ba57fbd52704452d3" translate="yes" xml:space="preserve">
          <source>My subclasses: &lt;a href=&quot;Pod::Simple::PullParserStartToken&quot;&gt;Pod::Simple::PullParserStartToken&lt;/a&gt;, &lt;a href=&quot;Pod::Simple::PullParserTextToken&quot;&gt;Pod::Simple::PullParserTextToken&lt;/a&gt;, and &lt;a href=&quot;Pod::Simple::PullParserEndToken&quot;&gt;Pod::Simple::PullParserEndToken&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748a895bf6724a550c8c67860c94e7094d972f64" translate="yes" xml:space="preserve">
          <source>My subclasses: &lt;a href=&quot;pullparserstarttoken&quot;&gt;Pod::Simple::PullParserStartToken&lt;/a&gt;, &lt;a href=&quot;pullparsertexttoken&quot;&gt;Pod::Simple::PullParserTextToken&lt;/a&gt;, and &lt;a href=&quot;pullparserendtoken&quot;&gt;Pod::Simple::PullParserEndToken&lt;/a&gt;.</source>
          <target state="translated">내 하위 클래스 : &lt;a href=&quot;pullparserstarttoken&quot;&gt;Pod :: Simple :: PullParserStartToken&lt;/a&gt; , &lt;a href=&quot;pullparsertexttoken&quot;&gt;Pod :: Simple :: PullParserTextToken&lt;/a&gt; 및 &lt;a href=&quot;pullparserendtoken&quot;&gt;Pod :: Simple :: PullParserEndToken&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc204f1e0858a7337033f5946b1dc262a92ffcd" translate="yes" xml:space="preserve">
          <source>MyModule</source>
          <target state="translated">MyModule</target>
        </trans-unit>
        <trans-unit id="97ad397eea0be3e1f89ac813a16d43595116bd1c" translate="yes" xml:space="preserve">
          <source>Myclass::Subclass</source>
          <target state="translated">Myclass::Subclass</target>
        </trans-unit>
        <trans-unit id="c6940a4c07e595b424fa7842373c9f33f87cd575" translate="yes" xml:space="preserve">
          <source>Myinit.U</source>
          <target state="translated">Myinit.U</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="9a47348ab82eb6d6bab23d474edae2c5c05217c3" translate="yes" xml:space="preserve">
          <source>N scalars leaked</source>
          <target state="translated">N 스칼라 유출</target>
        </trans-unit>
        <trans-unit id="5a5f7af20c8e39658565746ad27f9a6866756694" translate="yes" xml:space="preserve">
          <source>N. B.</source>
          <target state="translated">NB</target>
        </trans-unit>
        <trans-unit id="a1288af793f71d98bd1d7968a0996780aa30d8e3" translate="yes" xml:space="preserve">
          <source>N.B. Setting &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; implicitly enables &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; .</source>
          <target state="translated">NB &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 설정 하면 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 가 내재적으로 활성화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="82840d382ba6e35da8eff2b3c88e5874455dbfcd" translate="yes" xml:space="preserve">
          <source>N.B. Setting &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; implicitly enables &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="4c53abfad1785f59a4ee14505ad91b4508658ce7" translate="yes" xml:space="preserve">
          <source>NAME is the top-level namespace of your module. VERSION_FROM is the file which contains the $VERSION variable for the entire distribution. Typically this is the same as your top-level module.</source>
          <target state="translated">NAME은 모듈의 최상위 네임 스페이스입니다. VERSION_FROM은 전체 배포에 대한 $ VERSION 변수를 포함하는 파일입니다. 일반적으로 이것은 최상위 모듈과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d81d8c4e29195f73ad2566e9351c6a67f3f09071" translate="yes" xml:space="preserve">
          <source>NAME needn't be the name of a subroutine; it can be a scalar variable containing a code reference or a block that evaluates to a code reference.</source>
          <target state="translated">NAME은 서브 루틴의 이름 일 필요는 없습니다. 코드 참조를 포함하는 스칼라 변수 또는 코드 참조로 평가되는 블록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1261b44b9791565719eece908fc8aabec59c02c" translate="yes" xml:space="preserve">
          <source>NAMELEN</source>
          <target state="translated">NAMELEN</target>
        </trans-unit>
        <trans-unit id="5e3909d12f66ddb276f16c1c76bcb4924e613445" translate="yes" xml:space="preserve">
          <source>NAMES</source>
          <target state="translated">NAMES</target>
        </trans-unit>
        <trans-unit id="941d6029f49e5d7a70ad52579f12da850d9d8bc5" translate="yes" xml:space="preserve">
          <source>NAMESPACE LAYOUT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832ae6b6120b927078a7d3ce9fe270032ed0f14a" translate="yes" xml:space="preserve">
          <source>NAME_HEK</source>
          <target state="translated">NAME_HEK</target>
        </trans-unit>
        <trans-unit id="9c01dbcc56faa849a3e733fd9d72b3167f597af7" translate="yes" xml:space="preserve">
          <source>NATIVE_TO_LATIN1</source>
          <target state="translated">NATIVE_TO_LATIN1</target>
        </trans-unit>
        <trans-unit id="8f24a21d73be24d957aec6eb17d5b59ef96e9f9c" translate="yes" xml:space="preserve">
          <source>NATIVE_TO_NEED</source>
          <target state="translated">NATIVE_TO_NEED</target>
        </trans-unit>
        <trans-unit id="39d2e9c7a844a802cee07179a83665ab497e1d24" translate="yes" xml:space="preserve">
          <source>NATIVE_TO_UNI</source>
          <target state="translated">NATIVE_TO_UNI</target>
        </trans-unit>
        <trans-unit id="1cb5d20286de76cb8688a83e567257746c132849" translate="yes" xml:space="preserve">
          <source>NB. (more info on these and others would be appreciated).</source>
          <target state="translated">NB. (이들과 다른 사람들에 대한 자세한 정보는 높이 평가 될 것입니다).</target>
        </trans-unit>
        <trans-unit id="5f010024527e42fccba4ce2404e18f5c69eb9822" translate="yes" xml:space="preserve">
          <source>NB: Extensions that have nothing but *.pm files had to say</source>
          <target state="translated">NB : * .pm 파일 이외의 확장자는</target>
        </trans-unit>
        <trans-unit id="1f7de72c9876d092d89ca69c43c95f07a23bc665" translate="yes" xml:space="preserve">
          <source>NB: This variable must be in the package's symbol table, thus:</source>
          <target state="translated">주의 :이 변수는 패키지의 심볼 테이블에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7297e43fd27e251c1624e34ebd5bf6e99f4c09b7" translate="yes" xml:space="preserve">
          <source>NBSP</source>
          <target state="translated">NBSP</target>
        </trans-unit>
        <trans-unit id="12f6598371d9f16419b7754d6868d5184ea681b6" translate="yes" xml:space="preserve">
          <source>NDBM_File</source>
          <target state="translated">NDBM_File</target>
        </trans-unit>
        <trans-unit id="d90fc6a608918a70294d6b999fb9f1f64ecfd606" translate="yes" xml:space="preserve">
          <source>NDBM_File - Tied access to ndbm files</source>
          <target state="translated">NDBM_File-ndbm 파일에 대한 액세스 권한</target>
        </trans-unit>
        <trans-unit id="5aae06f9c3e77d522c379b6951fa1408e2490531" translate="yes" xml:space="preserve">
          <source>NDBM_File and ODBM_File do not work on FAT filesystems</source>
          <target state="translated">FAT 파일 시스템에서 NDBM_File 및 ODBM_File이 작동하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a798c3d94cb982cba534a63f36ccc06041d89ff0" translate="yes" xml:space="preserve">
          <source>NDBM_File, DB_File, GDBM_File, SDBM_File, ODBM_File - various DBM implementations</source>
          <target state="translated">NDBM_File, DB_File, GDBM_File, SDBM_File, ODBM_File-다양한 DBM 구현</target>
        </trans-unit>
        <trans-unit id="8ada427b353c510d65dd5713797216d9c991cb85" translate="yes" xml:space="preserve">
          <source>NEED TO UPGRADE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d5383e4d48ed9cc34a642b91253d4ab7ea693b" translate="yes" xml:space="preserve">
          <source>NEEDS_LINKING</source>
          <target state="translated">NEEDS_LINKING</target>
        </trans-unit>
        <trans-unit id="20e4cb428c1111a7f321068ef6494db03de900ba" translate="yes" xml:space="preserve">
          <source>NEW API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95b5a9cf67180becca6d7616cbe8c2dbd055da" translate="yes" xml:space="preserve">
          <source>NEW to 3.18</source>
          <target state="translated">3.18에 처음</target>
        </trans-unit>
        <trans-unit id="6d7b1945b703be410af2f234b62894cdfab399db" translate="yes" xml:space="preserve">
          <source>NEW to 3.22</source>
          <target state="translated">3.22에 처음</target>
        </trans-unit>
        <trans-unit id="1bd0055e213031c1eb32db565ffd38acb782ca87" translate="yes" xml:space="preserve">
          <source>NEWNAME</source>
          <target state="translated">NEWNAME</target>
        </trans-unit>
        <trans-unit id="1992d5e8d57e780981c364d844480c004ead1bc2" translate="yes" xml:space="preserve">
          <source>NEXT</source>
          <target state="translated">NEXT</target>
        </trans-unit>
        <trans-unit id="b671ceb8e301ee8b8afde8681000cc597a749b5b" translate="yes" xml:space="preserve">
          <source>NEXT - Provide a pseudo-class NEXT (et al) that allows method redispatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b264d41dd1016991ce0cb432539e94a460600e52" translate="yes" xml:space="preserve">
          <source>NEXT LINE and NO-BREAK SPACE may or may not match &lt;code&gt;\s&lt;/code&gt; depending on the rules in effect. See &lt;a href=&quot;#Whitespace&quot;&gt;the beginning of this section&lt;/a&gt;.</source>
          <target state="translated">NEXT LINE 및 NO-BREAK SPACE는 적용되는 규칙에 따라 &lt;code&gt;\s&lt;/code&gt; 와 일치하거나 일치하지 않을 수 있습니다 . &lt;a href=&quot;#Whitespace&quot;&gt;이 섹션의 시작 부분을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="113018ee92aaf6966a4feae636745a050ed016d4" translate="yes" xml:space="preserve">
          <source>NEXT.pm - Provide a pseudo-class NEXT (et al) that allows method redispatch</source>
          <target state="translated">NEXT.pm-메소드 재발 포를 허용하는 의사 클래스 NEXT (et al) 제공</target>
        </trans-unit>
        <trans-unit id="2f9fcb4031e8bf2abe384c4ced588f3eb413318c" translate="yes" xml:space="preserve">
          <source>NEXT.pm adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; , the call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="translated">NEXT.pm은 &lt;code&gt;NEXT&lt;/code&gt; 라는 의사 클래스 를 사용하는 모든 프로그램에 NEXT 라는 의사 클래스를 추가 합니다. 메소드 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 호출하면, 호출 메소드가 원래 발견되지 않은 것처럼 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 에 대한 호출 이 재발신됩니다.</target>
        </trans-unit>
        <trans-unit id="fabb600989a7bba10f84538b2741dea0ab962144" translate="yes" xml:space="preserve">
          <source>NEXTKEY is always called in scalar context and it should just return the next key. values(), and each() in list context, will call FETCH for the returned keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c24556247a8b24895bea71905672183f614ef3" translate="yes" xml:space="preserve">
          <source>NEXTKEY this, lastkey</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1218651fb5d285bf3469a4750e2db41f4b8b5f" translate="yes" xml:space="preserve">
          <source>NFS</source>
          <target state="translated">NFS</target>
        </trans-unit>
        <trans-unit id="608f5850e4d46263293fc905b013705ee17bff47" translate="yes" xml:space="preserve">
          <source>NFS Mount Points</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f3c73aafb4df691799fd406377dadc9780d033" translate="yes" xml:space="preserve">
          <source>NFS filesystems and utime(2) on HP-UX</source>
          <target state="translated">HP-UX의 NFS 파일 시스템 및 utime (2)</target>
        </trans-unit>
        <trans-unit id="33955091f178d2e0b6833a44b9c41c2530abaaef" translate="yes" xml:space="preserve">
          <source>NIST STATEMENT ON SHA-1</source>
          <target state="translated">SHA-1에 대한 NIST 진술</target>
        </trans-unit>
        <trans-unit id="8a32963006e5a121b9fe9a8458d70540a03114d8" translate="yes" xml:space="preserve">
          <source>NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a practical collision attack on SHA-1. Therefore, NIST encourages the rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications requiring strong collision resistance, such as digital signatures.</source>
          <target state="translated">NIST는 Xiaoyun Wang 교수의 연구가 SHA-1에 대한 실질적인 충돌 공격임을 인정합니다. 따라서 NIST는 디지털 서명과 같이 강력한 충돌 저항이 필요한 응용 프로그램에 SHA-2 해시 기능 (예 : SHA-256)을 빠르게 채택 할 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="3ed352aa54aa2907bf2965b3e66dc4da9f6230d6" translate="yes" xml:space="preserve">
          <source>NI_DGRAM</source>
          <target state="translated">NI_DGRAM</target>
        </trans-unit>
        <trans-unit id="40e6efbcba9fea1565ffb548c0ce6055f9f0abcd" translate="yes" xml:space="preserve">
          <source>NI_NAMEREQD</source>
          <target state="translated">NI_NAMEREQD</target>
        </trans-unit>
        <trans-unit id="c34d054e005e6ec8eab7acfe44ac788972e4e691" translate="yes" xml:space="preserve">
          <source>NI_NUMERICHOST</source>
          <target state="translated">NI_NUMERICHOST</target>
        </trans-unit>
        <trans-unit id="6afe1c04c2484c532e8d9fe653a24b3b764e7c90" translate="yes" xml:space="preserve">
          <source>NI_NUMERICSERV</source>
          <target state="translated">NI_NUMERICSERV</target>
        </trans-unit>
        <trans-unit id="b465e7557bda36b84a37e52f7c4e7301aae96613" translate="yes" xml:space="preserve">
          <source>NIx_NOHOST</source>
          <target state="translated">NIx_NOHOST</target>
        </trans-unit>
        <trans-unit id="a9b2d0ec65146c4b3c86a214eedc9bb8ca3669cd" translate="yes" xml:space="preserve">
          <source>NIx_NOSERV</source>
          <target state="translated">NIx_NOSERV</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="259e7beda3cad46f62a7095d7eeef91dfa1452ff" translate="yes" xml:space="preserve">
          <source>NNTP Client class</source>
          <target state="translated">NNTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="08ede25c29d0b14def59102b820c983fef641f93" translate="yes" xml:space="preserve">
          <source>NO READER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45b84bee02bd83b950a021e94155970ceaec318" translate="yes" xml:space="preserve">
          <source>NO SETTER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09540dd5a1bab1aead125e4e2e0e2b654166fb0" translate="yes" xml:space="preserve">
          <source>NOECHO</source>
          <target state="translated">NOECHO</target>
        </trans-unit>
        <trans-unit id="4217d58bbccddebf68dfe2d9142182d33dd44068" translate="yes" xml:space="preserve">
          <source>NON-BLOCKING</source>
          <target state="translated">NON-BLOCKING</target>
        </trans-unit>
        <trans-unit id="fccfdb937713b1cc25887e8572de25d1e7746077" translate="yes" xml:space="preserve">
          <source>NONINTERACTIVE_TESTING</source>
          <target state="translated">NONINTERACTIVE_TESTING</target>
        </trans-unit>
        <trans-unit id="0e091603e3f994d50c190a2d5fd3e5c41973500d" translate="yes" xml:space="preserve">
          <source>NONPERLIO FUNCTIONALITY</source>
          <target state="translated">비 페로 리오 기능</target>
        </trans-unit>
        <trans-unit id="76ad789b38e8dbe21ca0bc2010e7bf69341912fe" translate="yes" xml:space="preserve">
          <source>NORECURS</source>
          <target state="translated">NORECURS</target>
        </trans-unit>
        <trans-unit id="839079acafd0ee6f848c67721260af9d37e0e0a1" translate="yes" xml:space="preserve">
          <source>NORMAL TESTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89019f3be9c018c42adb350f614090da4dc3c7c" translate="yes" xml:space="preserve">
          <source>NORMALIZER</source>
          <target state="translated">NORMALIZER</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="c4670e378e0ef3deb0f4049eccb697b77c441ecf" translate="yes" xml:space="preserve">
          <source>NOT Algonquin!</source>
          <target state="translated">알곤 퀸이 아님!</target>
        </trans-unit>
        <trans-unit id="f8e9babf78c2e719cd84e72dad7681487647bef9" translate="yes" xml:space="preserve">
          <source>NOT Amharic! NOT Samaritan Aramaic!</source>
          <target state="translated">암하라 어가 아닙니다! 사마리아 아람이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="753ae89bc9aefd4bc4c59d18e8756509c836fa15" translate="yes" xml:space="preserve">
          <source>NOT Aramaic!</source>
          <target state="translated">아람어 아님!</target>
        </trans-unit>
        <trans-unit id="133f3813e3d37b50fe3b4bc3090b8a682ecfc808" translate="yes" xml:space="preserve">
          <source>NOT Cree!</source>
          <target state="translated">울지마!</target>
        </trans-unit>
        <trans-unit id="4ae987be84fecb4729307de204915c9a99c39e5b" translate="yes" xml:space="preserve">
          <source>NOT Creek! (Formerly &quot;cre&quot;.)</source>
          <target state="translated">크릭이 아닙니다! (이전의 &quot;cre&quot;)</target>
        </trans-unit>
        <trans-unit id="9aa8553630af3827a1d2df27f4500615b8d003a9" translate="yes" xml:space="preserve">
          <source>NOT Dogri!</source>
          <target state="translated">Dogri가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="1a5a67d55f9ca3936956ef4502ba89ff2b34b328" translate="yes" xml:space="preserve">
          <source>NOT Dogrib!</source>
          <target state="translated">도그 립이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="68c49025492a4631abe9ece2f0cd79b5a465f4d6" translate="yes" xml:space="preserve">
          <source>NOT Lahnda!</source>
          <target state="translated">Lahnda가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="3e4ff7d40fd5253a99d44731fd85dd7a075a8d8c" translate="yes" xml:space="preserve">
          <source>NOT Lamba!</source>
          <target state="translated">람바!</target>
        </trans-unit>
        <trans-unit id="bbf0ff26137d6eeee6a5487552177165fd9cd76f" translate="yes" xml:space="preserve">
          <source>NOT Malay!</source>
          <target state="translated">말레이어 아님!</target>
        </trans-unit>
        <trans-unit id="ba94ae989804baff400b9b606493ab5274d7a721" translate="yes" xml:space="preserve">
          <source>NOT Malayalam!</source>
          <target state="translated">말라 얄람 어가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="84b3ff998bfbcb82e2509048721a02e46fb1bbb0" translate="yes" xml:space="preserve">
          <source>NOT Mandarin!</source>
          <target state="translated">만다린이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="1befb6835c1562cd0baa23c9fea5413fe9068e2e" translate="yes" xml:space="preserve">
          <source>NOT Maori!</source>
          <target state="translated">마오리가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="3996b78a86c029adf66ba0fba4afc3b0b738285a" translate="yes" xml:space="preserve">
          <source>NOT Mari!</source>
          <target state="translated">마리가 아니야!</target>
        </trans-unit>
        <trans-unit id="fd25af715e82d2a1e52a76f6042a96a0b97ee0df" translate="yes" xml:space="preserve">
          <source>NOT Pompeiian!</source>
          <target state="translated">폼페이 아님!</target>
        </trans-unit>
        <trans-unit id="401d021df78de2f61ec2f834d14cc4a3deb3d7f8" translate="yes" xml:space="preserve">
          <source>NOT Romanian! NOT Romany! NOT Romansh!</source>
          <target state="translated">루마니아어 아님! 로마 니 아님! Romansh가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="e7bebe37efc0e0896e678888788c0119a46ec810" translate="yes" xml:space="preserve">
          <source>NOT Scots Gaelic!</source>
          <target state="translated">게 일어를 막지 마라!</target>
        </trans-unit>
        <trans-unit id="5cb51efbf1da343aa35bb0cd1503a285538b7130" translate="yes" xml:space="preserve">
          <source>NOT Scots!</source>
          <target state="translated">Scots하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="406bca1dda1a92a194b3f06540dac98edfe02f9c" translate="yes" xml:space="preserve">
          <source>NOT Tai!</source>
          <target state="translated">타이가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="f4263bbd2a696d31694b9b4dfaddde3fd2e9242a" translate="yes" xml:space="preserve">
          <source>NOT Thai!</source>
          <target state="translated">태국어가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="381ade097816523a950f9c68fe73f8bdd2483e08" translate="yes" xml:space="preserve">
          <source>NOT Tonga!</source>
          <target state="translated">통가 아님!</target>
        </trans-unit>
        <trans-unit id="43e2eb938fbfde6d76b6fc73f130bf7c34e96d8a" translate="yes" xml:space="preserve">
          <source>NOT Tsonga!</source>
          <target state="translated">Tsonga가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="7bb4f6673a55f3ef4e9a72ddaea2a35397daeb1b" translate="yes" xml:space="preserve">
          <source>NOT Ugric!</source>
          <target state="translated">우 그릭이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="ac75bf1bb4152325d5d23d198732d52ff6533a71" translate="yes" xml:space="preserve">
          <source>NOT Wendish! NOT Wend! NOT Avestan! (Formerly &quot;ven&quot;.)</source>
          <target state="translated">Wendish가 아닙니다! 구부리지 마십시오! Avestan이 아닙니다! (이전의 &quot;ven&quot;)</target>
        </trans-unit>
        <trans-unit id="8ccbd83d9bd35a8139be881200b96ebe4bf4f8ba" translate="yes" xml:space="preserve">
          <source>NOT White Russian! NOT Rusyn!</source>
          <target state="translated">백인 러시아어가 아닙니다! Rusyn이 아닙니다!</target>
        </trans-unit>
        <trans-unit id="9a3ad696e905452a166a11feac1b5ce24fc7f64e" translate="yes" xml:space="preserve">
          <source>NOT YET</source>
          <target state="translated">아직</target>
        </trans-unit>
        <trans-unit id="c775454cbbf850c1e44e01c2124ec3b439b5a154" translate="yes" xml:space="preserve">
          <source>NOT Zend.</source>
          <target state="translated">젠드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8ad860c15810cce0e7beac1c91da3ab2cb22c47" translate="yes" xml:space="preserve">
          <source>NOTE</source>
          <target state="translated">NOTE</target>
        </trans-unit>
        <trans-unit id="2e08c41aed7a4c92f4cb54085b5d4c152d02dd41" translate="yes" xml:space="preserve">
          <source>NOTE ON CYCLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6abbe86b9a3dd54d847c73d2fcb02c7646f939" translate="yes" xml:space="preserve">
          <source>NOTE:</source>
          <target state="translated">NOTE:</target>
        </trans-unit>
        <trans-unit id="17e95c44cb46af490bb8e16ee27a4a479ea2e057" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;a href=&quot;ExtUtils::Liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; should be removed from the inheritance hiearchy and simply be called as functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618dd0810d8f0328d5c844bf5776ec75fdee5055" translate="yes" xml:space="preserve">
          <source>NOTE: As of version 3.27, the FIPS code set is no longer supported. See the Locale::Codes::Changes document for details.</source>
          <target state="translated">참고 : 버전 3.27부터는 FIPS 코드 세트가 더 이상 지원되지 않습니다. 자세한 내용은 Locale :: Codes :: Changes 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f153ba173fef9b5aa6938b0a0ee92d9e101e6d02" translate="yes" xml:space="preserve">
          <source>NOTE: Before version 5.004_65, &lt;code&gt;hv_iterinit&lt;/code&gt; used to return the number of hash buckets that happen to be in use. If you still need that esoteric value, you can get it through the macro &lt;code&gt;HvFILL(hv)&lt;/code&gt; .</source>
          <target state="translated">참고 : 버전 5.004_65 이전에는 &lt;code&gt;hv_iterinit&lt;/code&gt; 를 사용하여 사용중인 해시 버킷 수를 반환했습니다. 여전히 난해한 가치가 필요한 경우 매크로 &lt;code&gt;HvFILL(hv)&lt;/code&gt; 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb6856d39d8b489cad3f52ad021a622af14f9bc7" translate="yes" xml:space="preserve">
          <source>NOTE: Before version 5.004_65, &lt;code&gt;hv_iterinit&lt;/code&gt; used to return the number of hash buckets that happen to be in use. If you still need that esoteric value, you can get it through the macro &lt;code&gt;HvFILL(hv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649360d37b390feb3a2b0b394e1546f8221a9d4a" translate="yes" xml:space="preserve">
          <source>NOTE: Due to the nature of make, it is important that you put the trailing slash on your DESTDIR.</source>
          <target state="translated">참고 : make의 특성상 DESTDIR에 슬래시를 추가하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3f7ead4aaae021a928fa1ee51af8a79894a0f263" translate="yes" xml:space="preserve">
          <source>NOTE: Each direct &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;MM_Unix&lt;/a&gt; subclass is also an &lt;a href=&quot;ExtUtils::MM_Any&quot;&gt;MM_Any&lt;/a&gt; subclass. This is a temporary hack because MM_Unix overrides some MM_Any methods with Unix specific code. It allows the non-Unix modules to see the original MM_Any implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067432480fa685a3f96480be8331efe9c45e8058" translate="yes" xml:space="preserve">
          <source>NOTE: ExtUtils::MM_{Current OS} represents one of the ExtUtils::MM_* modules except &lt;a href=&quot;ExtUtils::MM_Any&quot;&gt;ExtUtils::MM_Any&lt;/a&gt; chosen based on your operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be33fdad677decf9bf49440b259d731f4baa5cc9" translate="yes" xml:space="preserve">
          <source>NOTE: For use with variables in the current package for a single scope, the functionality provided by this pragma has been superseded by &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations, available in Perl v5.6.0 or later, and use of this pragma is discouraged. See &lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;.</source>
          <target state="translated">참고 : 하나의 범위에 대한 현재 패키지의 변수와 함께 사용할 경우,이 프라그에서 제공하는 기능에 의해 대체되었습니다 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 펄 v5.6.0 이상 및이 pragma의 사용은 권장하지 않습니다에서 사용할 선언. &lt;a href=&quot;functions/our&quot;&gt;우리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2444687bc2e7aa6f630fc198feec77962205c8c7" translate="yes" xml:space="preserve">
          <source>NOTE: For use with variables in the current package for a single scope, the functionality provided by this pragma has been superseded by &lt;code&gt;our&lt;/code&gt; declarations, available in Perl v5.6.0 or later, and use of this pragma is discouraged. See &lt;a href=&quot;perlfunc#our&quot;&gt;&quot;our&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b263360f03c5b7669d257ce01c55faecf28c63" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;STDERR&lt;/code&gt; is redirected &lt;code&gt;make install&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; prompt you to install</source>
          <target state="translated">참고 : &lt;code&gt;STDERR&lt;/code&gt; 이 리디렉션 되면 &lt;code&gt;make install&lt;/code&gt; 하라는 메시지 가 표시 &lt;b&gt;되지 않습니다&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a15713e4ca482b00669bde833a2ad067bed418a" translate="yes" xml:space="preserve">
          <source>NOTE: If the</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="3fbf142c302988d361f32c92573c404f0d821571" translate="yes" xml:space="preserve">
          <source>NOTE: If you're using a 32-bit compiler to build perl on a 64-bit Windows operating system, then you should set the WIN64 environment variable to &quot;undef&quot;. Also, the trimmed down compiler only passes tests when USE_ITHREADS *= define (as opposed to undef) and when the CFG *= Debug line is commented out.</source>
          <target state="translated">참고 : 64 비트 Windows 운영 체제에서 perl을 빌드하기 위해 32 비트 컴파일러를 사용하는 경우 WIN64 환경 변수를 &quot;undef&quot;로 설정해야합니다. 또한 트림 된 컴파일러는 USE_ITHREADS * = 정의 (undef와 반대) 및 CFG * = 디버그 행이 주석 처리 된 경우에만 테스트를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="3627e1c3e922f58002616f63fa3f427fea434731" translate="yes" xml:space="preserve">
          <source>NOTE: In perl 5.25 the behavior of scalar %hash on an untied hash changed to return the count of keys. Prior to this it returned a string containing information about the bucket setup of the hash. See &lt;a href=&quot;Hash::Util#bucket_ratio&quot;&gt;&quot;bucket_ratio&quot; in Hash::Util&lt;/a&gt; for a backwards compatibility path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f20f131ce04b8a1fb6640adea5e575bdb22bbd" translate="yes" xml:space="preserve">
          <source>NOTE: In the example above, the thread returns a list, thus necessitating that the thread creation call be made in list context (i.e., &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; ($thr)&lt;/code&gt; ). See &lt;a href=&quot;threads#%24thr-%3ejoin()&quot;&gt;$thr-&amp;gt;join() in threads&lt;/a&gt; and &lt;a href=&quot;threads#THREAD-CONTEXT&quot;&gt;THREAD CONTEXT in threads&lt;/a&gt; for more details on thread context and return values.</source>
          <target state="translated">참고 : 위 예제에서 스레드는 목록을 반환하므로 목록 컨텍스트 (예 : &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; ($thr)&lt;/code&gt; ) 에서 스레드 작성 호출이 필요합니다 . 참조 &lt;a href=&quot;threads#%24thr-%3ejoin()&quot;&gt;스레드 ()에서 가입&amp;gt; $ thr-를&lt;/a&gt; 하고 &lt;a href=&quot;threads#THREAD-CONTEXT&quot;&gt;스레드에서 스레드 컨텍스트&lt;/a&gt; 스레드 컨텍스트 및 반환 값에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="53ecad029faffe4377d8471df7c402459fee1a5f" translate="yes" xml:space="preserve">
          <source>NOTE: In the example above, the thread returns a list, thus necessitating that the thread creation call be made in list context (i.e., &lt;code&gt;my ($thr)&lt;/code&gt;). See &lt;a href=&quot;threads#%24thr-%3Ejoin%28%29&quot;&gt;&quot;$thr-&amp;gt;join()&quot; in threads&lt;/a&gt; and &lt;a href=&quot;threads#THREAD-CONTEXT&quot;&gt;&quot;THREAD CONTEXT&quot; in threads&lt;/a&gt; for more details on thread context and return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eded8f1ec362061e175e773a0320700ccc8a74a7" translate="yes" xml:space="preserve">
          <source>NOTE: Modules like &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt; and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; have been omitted for clarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b96a646789fe22b9736fd0f77217c9c6f301c" translate="yes" xml:space="preserve">
          <source>NOTE: Strictly speaking Perl's UTF-8 should not be called UTF-8 since UTF-8 is an encoding of Unicode, and Unicode's upper limit, 0x10FFFF, can be expressed with 4 bytes. However, Perl thinks of UTF-8 as a way to encode non-negative integers in a binary format, even those above Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd640e426e455b329ccdbe19f860f26de435861" translate="yes" xml:space="preserve">
          <source>NOTE: The BerkeleyDB library only completely works on NTFS partitions.</source>
          <target state="translated">참고 : BerkeleyDB 라이브러리는 NTFS 파티션에서만 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a883d5970a29c1610a3c0fa8d3c7281403c56317" translate="yes" xml:space="preserve">
          <source>NOTE: The GDBM library only works on NTFS partitions.</source>
          <target state="translated">참고 : GDBM 라이브러리는 NTFS 파티션에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9b01e20bea3deec5ba5197be5f2861b1f24a1902" translate="yes" xml:space="preserve">
          <source>NOTE: The USE_64_BIT_INT build option is not supported with the 32-bit Visual C++ 6.0 compiler.</source>
          <target state="translated">참고 : USE_64_BIT_INT 빌드 옵션은 32 비트 Visual C ++ 6.0 컴파일러에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92679b71ee8b46e8b7e0ced5d18384810d027930" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation keeps the declared fields in the %FIELDS hash of the calling package, but this may change in future versions. Do &lt;b&gt;not&lt;/b&gt; update the %FIELDS hash directly, because it must be created at compile-time for it to be fully useful, as is done by this pragma.</source>
          <target state="translated">참고 : 현재 구현에서는 선언 된 필드를 호출 패키지의 % FIELDS 해시에 유지하지만 이후 버전에서는 변경 될 수 있습니다. 하다&lt;b&gt; 하지&lt;/b&gt; 완전히 유용하는 것이이 컴파일시에 작성해야하기 때문에, 직접 % FIELDS 해시를 업데이트 등이 pragma에 의해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="bffb349a25186b416bb90a95e353abe4799c593a" translate="yes" xml:space="preserve">
          <source>NOTE: The main Perl thread (thread 0) is in a</source>
          <target state="translated">참고 : 주 Perl 스레드 (스레드 0)는</target>
        </trans-unit>
        <trans-unit id="57e161872abdc951ab6418dd3709a011bb12d2ef" translate="yes" xml:space="preserve">
          <source>NOTE: The main object used by MakeMaker is a PACK### object, *not* &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. It is, effectively, a subclass of &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt;, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;, &lt;a href=&quot;ExtUtils::Liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; and ExtUtils::MM_{Current OS}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd01972804c083061ace7521dcf3ba26f354b9f" translate="yes" xml:space="preserve">
          <source>NOTE: The methods in &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; are simply copied into PACK### rather than MY being a superclass of PACK###. I don't remember the rationale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2d780df8a865a0c1e4241c863cc63ef39b82f8" translate="yes" xml:space="preserve">
          <source>NOTE: This class is now a front-end to the IO::* classes.</source>
          <target state="translated">참고 :이 클래스는 이제 IO :: * 클래스의 프런트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="3c0adaeecd5969cd29892262a1fafa36ba011ebd" translate="yes" xml:space="preserve">
          <source>NOTE: This has &lt;b&gt;not&lt;/b&gt; been extensively tested. In particular, &lt;code&gt;d_semctl_semun&lt;/code&gt; is undefined because it fails a Configure test and on Win9x the</source>
          <target state="translated">참고 : 이것은 광범위하게 테스트 &lt;b&gt;되지&lt;/b&gt; 않았습니다. 특히 &lt;code&gt;d_semctl_semun&lt;/code&gt; 은 구성 테스트에 실패하고 Win9x에서</target>
        </trans-unit>
        <trans-unit id="2235e00b8313ce99cbd9b52cd441ef5625f482e5" translate="yes" xml:space="preserve">
          <source>NOTE: This is the canonical version of the method. The version in &lt;a href=&quot;File::Spec::VMS&quot;&gt;File::Spec::VMS&lt;/a&gt; is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93561b423a89d40f27ddedd870c2c3c213cd0ca9" translate="yes" xml:space="preserve">
          <source>NOTE: This is the canonical version of the method. The version in File::Spec::VMS is deprecated.</source>
          <target state="translated">참고 :이 방법은 정식 버전입니다. File :: Spec :: VMS의 버전은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f653cc8c3999a85d9ddcfbc0bf440c5b24acc130" translate="yes" xml:space="preserve">
          <source>NOTE: This section presents an abstract approximation of regular expression behavior. For a more rigorous (and complicated) view of the rules involved in selecting a match among possible alternatives, see &lt;a href=&quot;#Combining-RE-Pieces&quot;&gt;&quot;Combining RE Pieces&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfe8cfad2c7f08a016e53df968cd93d3ee1a3d3" translate="yes" xml:space="preserve">
          <source>NOTE: This section presents an abstract approximation of regular expression behavior. For a more rigorous (and complicated) view of the rules involved in selecting a match among possible alternatives, see &lt;a href=&quot;#Combining-RE-Pieces&quot;&gt;Combining RE Pieces&lt;/a&gt;.</source>
          <target state="translated">참고 :이 섹션에서는 정규 표현식 동작에 대한 추상적 인 근사값을 제공합니다. 가능한 대안 중에서 일치 항목을 선택하는 데 관련된 규칙을보다 엄격하고 복잡하게 보려면 &lt;a href=&quot;#Combining-RE-Pieces&quot;&gt;RE 조각 결합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f97ff6e3100b23f28f9a60da39c11eb47af9c9a6" translate="yes" xml:space="preserve">
          <source>NOTE: This warning detects package symbols that have been used only once. This means lexical variables will never trigger this warning. It also means that all of the package variables $c, @c, %c, as well as *c, &amp;amp;c, sub c{}, c(), and c (the filehandle or format) are considered the same; if a program uses $c only once but also uses any of the others it will not trigger this warning. Symbols beginning with an underscore and symbols using special identifiers (q.v. &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;) are exempt from this warning.</source>
          <target state="translated">참고 :이 경고는 한 번만 사용 된 패키지 기호를 감지합니다. 이는 어휘 변수가이 경고를 트리거하지 않음을 의미합니다. 또한 모든 패키지 변수 $ c, @c, % c 및 * c, &amp;amp; c, sub c {}, c () 및 c (파일 핸들 또는 형식)는 동일하게 간주됩니다. 프로그램이 $ c를 한 번만 사용하고 다른 프로그램도 사용하는 경우이 경고가 발생하지 않습니다. 밑줄로 시작하는 기호 및 특수 식별자 (qv &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt; )를 사용하는 기호 는이 경고에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="5871f00a4b47482fbc58aebc0cc4ba62002b52da" translate="yes" xml:space="preserve">
          <source>NOTE: This was fixed in perl 5.20. Mentioning these three variables no longer makes a speed difference. This section still applies if your code is to run on perl 5.18 or earlier.</source>
          <target state="translated">참고 : 이것은 perl 5.20에서 수정되었습니다. 이 세 가지 변수를 언급해도 더 이상 속도 차이가 없습니다. 이 섹션은 코드가 perl 5.18 이전 버전에서 실행되는 경우에도 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6324a263e1895ae371269bca4d897ca5cff9e0a3" translate="yes" xml:space="preserve">
          <source>NOTE: When &lt;a href=&quot;ExtUtils::MM&quot;&gt;ExtUtils::MM&lt;/a&gt; is loaded it chooses a superclass for MM from amongst the ExtUtils::MM_* modules based on the current operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e360e636f982b17adc20c8e88ac33bf0ddfb0d5f" translate="yes" xml:space="preserve">
          <source>NOTE: When using this option to alter the extension of a module's loadable object, it is also necessary that the module's pm file specifies the same change:</source>
          <target state="translated">참고 :이 옵션을 사용하여 모듈의로드 가능한 객체의 확장자를 변경하는 경우 모듈의 pm 파일도 동일한 변경 사항을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdfc117a261c4487af6b7a42f6e1291c57974793" translate="yes" xml:space="preserve">
          <source>NOTE: Yes, this is a mess. See &lt;a href=&quot;http://archive.develooper.com/makemaker@perl.org/msg00134.html&quot;&gt;http://archive.develooper.com/makemaker@perl.org/msg00134.html&lt;/a&gt; for some history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376fb7bcf600539ba82d51a66a1efcb849c8327e" translate="yes" xml:space="preserve">
          <source>NOTE: during a build there could be created a number (or one) of</source>
          <target state="translated">참고 : 빌드하는 동안 숫자 (또는 하나)를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ea17cbc15e73a4439305d4a5eaa00618c0f4354b" translate="yes" xml:space="preserve">
          <source>NOTE: the NaN payload APIs are based on the latest (as of June 2015) proposed ISO C interfaces, but they are not yet a standard. Things may change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adeb89f1a65c1db4fe7065e44b17a7dc45e0c343" translate="yes" xml:space="preserve">
          <source>NOTE: the perl_ form of this function is deprecated.</source>
          <target state="translated">참고 :이 함수의 perl_ 형식은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="259672a245b4c95b8c72c4ad7549e5e6b6f26678" translate="yes" xml:space="preserve">
          <source>NOTE: this function is experimental and may change or be removed without notice.</source>
          <target state="translated">참고 :이 기능은 실험용이므로 예고없이 변경되거나 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33eb4db5f4c5d89147eba4406fbdfdfe557672e" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_av_create_and_push with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e2262bd5b95a859bc1a2c93f9d408eb99eab78" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_av_create_and_unshift_one with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3d58bf1438c4c6241c66bb37ecbdb244a70618" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_blockhook_register with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_blockhook_register로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7b1f0204d1784d6985d1beacf1a3919bed1aa91" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_custom_op_register with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_custom_op_register로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6babb9cf8fb6ef67053f45016008ddba04aec872" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_custom_op_xop with an aTHX_ parameter.</source>
          <target state="translated">참고 :이 함수는 aTHX_ 매개 변수를 사용하여 Perl_custom_op_xop으로 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="b159c116788bb9d42ea050ce36c9737031992cdb" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_hv_assert with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c08dd051851cab61787d1e02454177c1d426b4f" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_hv_fill with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c35c13dd37990737f29f6eaec9450f57ed8d98" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_magic_methcall with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3dc30cd58d0d45defc4c1bd85171b5851ea611" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_mro_register with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623bce064ae2394282ca4352cc0845eed93e9159" translate="yes" xml:space="preserve">
          <source>NOTE: this function must be explicitly called as Perl_start_glob with an aTHX_ parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb98ccf0885ad4b3b865d59fcf8b08abb3ba7533" translate="yes" xml:space="preserve">
          <source>NOTE: unless your Perl has been compiled with debug info (often &lt;b&gt;-g&lt;/b&gt;), the stack trace is likely to be somewhat hard to use because it will most probably contain only the function names and not their arguments. If possible, recompile your Perl with debug info and reproduce the crash and the stack trace.</source>
          <target state="translated">참고 : Perl이 디버그 정보 (종종 &lt;b&gt;-g&lt;/b&gt; ) 로 컴파일되지 않은 경우 스택 트레이스는 인수가 아닌 함수 이름 만 포함하므로 사용하기가 다소 어려울 수 있습니다. 가능한 경우 디버그 정보로 Perl을 다시 컴파일하고 충돌 및 스택 추적을 재현하십시오.</target>
        </trans-unit>
        <trans-unit id="d1560e71dccb0898373285ee4f50b724b2b71c7d" translate="yes" xml:space="preserve">
          <source>NOTE: you can pass either the object directly or the SV contained within the RV.</source>
          <target state="translated">참고 : 객체를 직접 전달하거나 RV에 포함 된 SV를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69fc18a69727f31dc484cc6cc5d98f4552fffd6" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">NOTES</target>
        </trans-unit>
        <trans-unit id="ca9bb80b927e1f747948f6be662bf44318c1f39e" translate="yes" xml:space="preserve">
          <source>NOTES &amp;amp;&amp;amp; CAVEATS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f05e227bc69b9c43de84ec895a9faed1f7b4aa" translate="yes" xml:space="preserve">
          <source>NOTES FOR IMPLEMENTORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc8974be5d154b1084db932a691a405a4c97b92" translate="yes" xml:space="preserve">
          <source>NOTES ON CUSTOMIZATION</source>
          <target state="translated">맞춤화에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="fe71871083ca490e6bc0da33fb48ce231f820a94" translate="yes" xml:space="preserve">
          <source>NOTICE</source>
          <target state="translated">NOTICE</target>
        </trans-unit>
        <trans-unit id="9d379c9bca90d391f4c7c80b6ee18ca954e9daee" translate="yes" xml:space="preserve">
          <source>NO_COLOR</source>
          <target state="translated">NO_COLOR</target>
        </trans-unit>
        <trans-unit id="bb12929c24b3715cb12e906f7859970b509fae40" translate="yes" xml:space="preserve">
          <source>NO_META</source>
          <target state="translated">NO_META</target>
        </trans-unit>
        <trans-unit id="559eb72468b854747e75621aff713b8e7e7d9391" translate="yes" xml:space="preserve">
          <source>NO_MYMETA</source>
          <target state="translated">NO_MYMETA</target>
        </trans-unit>
        <trans-unit id="cb279b60b97f699d3e518821acdba981cd19ddff" translate="yes" xml:space="preserve">
          <source>NO_PACKLIST</source>
          <target state="translated">NO_PACKLIST</target>
        </trans-unit>
        <trans-unit id="6df50ca6f085eef53a1d294af151847fd55dc1fd" translate="yes" xml:space="preserve">
          <source>NO_PERLLOCAL</source>
          <target state="translated">NO_PERLLOCAL</target>
        </trans-unit>
        <trans-unit id="106cd42701eab33079b05c517f262d495992d284" translate="yes" xml:space="preserve">
          <source>NO_VC</source>
          <target state="translated">NO_VC</target>
        </trans-unit>
        <trans-unit id="20fba7fb07c15dd5e4b286e814069b42b6d4cf66" translate="yes" xml:space="preserve">
          <source>NUL</source>
          <target state="translated">NUL</target>
        </trans-unit>
        <trans-unit id="0caa59b644c0cefac70de91f3a56d8b895dc8638" translate="yes" xml:space="preserve">
          <source>NUL terminated string, length will be determined with &lt;code&gt;strlen&lt;/code&gt;</source>
          <target state="translated">NUL 종료 문자열, 길이는 &lt;code&gt;strlen&lt;/code&gt; 으로 결정됩니다</target>
        </trans-unit>
        <trans-unit id="9618acc0df0394ab4c059fe5284c47cb34741100" translate="yes" xml:space="preserve">
          <source>NULL OP IN RUN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47772c7a46c443ef637a948d4d60da7733075770" translate="yes" xml:space="preserve">
          <source>NULL regexp argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67527a1d9b957d6ff496b6a019534a5af79d800" translate="yes" xml:space="preserve">
          <source>NULL regexp parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2fb40b4decc623e7e7104506804374fa2e9c3b" translate="yes" xml:space="preserve">
          <source>NULL will be returned if a REGEXP* is not found.</source>
          <target state="translated">REGEXP *를 찾을 수 없으면 NULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="9a969c7ad3b1a0b9595b8188b657f82438b62232" translate="yes" xml:space="preserve">
          <source>NV</source>
          <target state="translated">NV</target>
        </trans-unit>
        <trans-unit id="de8dc4fa7c538b042ca7c0d8c2872f7018b2f2d9" translate="yes" xml:space="preserve">
          <source>NVX</source>
          <target state="translated">NVX</target>
        </trans-unit>
        <trans-unit id="def32bbdca04fbf76d7fa0113c3d0fd8eea98a15" translate="yes" xml:space="preserve">
          <source>NYI</source>
          <target state="translated">NYI</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="784fe306d7073aacaa442494af76294e3c4c800c" translate="yes" xml:space="preserve">
          <source>NaN()</source>
          <target state="translated">NaN()</target>
        </trans-unit>
        <trans-unit id="8ea6de70f2564dc30edd68bddca7689ae4a18ad9" translate="yes" xml:space="preserve">
          <source>NaN, as opposed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bdd06e23eea433753b56651dbbec75237cf1329" translate="yes" xml:space="preserve">
          <source>NaN.</source>
          <target state="translated">NaN.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="bd023d4abed699d0493893db0b8a9b139b7421f3" translate="yes" xml:space="preserve">
          <source>Name &quot;%s&quot; used only once: possible typo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03976a62cd47751685b4ca15bb96f0bcaf7e4a01" translate="yes" xml:space="preserve">
          <source>Name &quot;%s::%s&quot; used only once: possible typo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5a7c30af283c6875cea008a552e7d7c9264007" translate="yes" xml:space="preserve">
          <source>Name of current executing subroutine.</source>
          <target state="translated">현재 실행중인 서브 루틴의 이름</target>
        </trans-unit>
        <trans-unit id="5d6475ea1ed77582899f2ede3c078b5d7ca7f2d5" translate="yes" xml:space="preserve">
          <source>Name of the MRO, either in ISO-8859-1 or UTF-8.</source>
          <target state="translated">ISO-8859-1 또는 UTF-8의 MRO 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f311c3300c6ca77afd17b4650f40819e62321f9f" translate="yes" xml:space="preserve">
          <source>Name of the executable used to run &lt;code&gt;PPM_INSTALL_SCRIPT&lt;/code&gt; below. (e.g. perl)</source>
          <target state="translated">아래 &lt;code&gt;PPM_INSTALL_SCRIPT&lt;/code&gt; 를 실행하는 데 사용되는 실행 파일 이름입니다 . (예 : 펄)</target>
        </trans-unit>
        <trans-unit id="e843afb94a5b81c10884290c28f3a8b15754d088" translate="yes" xml:space="preserve">
          <source>Name of the executable used to run &lt;code&gt;PPM_UNINSTALL_SCRIPT&lt;/code&gt; below. (e.g. perl)</source>
          <target state="translated">아래 &lt;code&gt;PPM_UNINSTALL_SCRIPT&lt;/code&gt; 를 실행하는 데 사용되는 실행 파일 이름입니다 . (예 : 펄)</target>
        </trans-unit>
        <trans-unit id="8624fc8eceebc0b51b2143689f1f48b7ecc08665" translate="yes" xml:space="preserve">
          <source>Name of the file that contains the package description. MakeMaker looks for a line in the POD matching /^($package\s-\s)(.*)/. This is typically the first line in the &quot;=head1 NAME&quot; section. $2 becomes the abstract.</source>
          <target state="translated">패키지 설명이 포함 된 파일의 이름입니다. MakeMaker는 POD에서 /^($package\s-\s)(.*)/와 일치하는 행을 찾습니다. 이것은 일반적으로 &quot;= head1 NAME&quot;섹션의 첫 번째 줄입니다. $ 2는 초록이됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3cf8734b2c68bc08b2cd79d4d6ccc0136f6aa2" translate="yes" xml:space="preserve">
          <source>Name of the module. This must be specified</source>
          <target state="translated">모듈 이름. 반드시 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="7868a8b47d3d92cc64ccf808862aaae2ad267aa5" translate="yes" xml:space="preserve">
          <source>Name of the script that gets executed by the Perl Package Manager after the installation of a package.</source>
          <target state="translated">패키지 설치 후 Perl Package Manager가 실행하는 스크립트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0c5023ea38126581b7ad8749f0a6eeac640c079" translate="yes" xml:space="preserve">
          <source>Name of the script that gets executed by the Perl Package Manager before the removal of a package.</source>
          <target state="translated">패키지를 제거하기 전에 Perl 패키지 관리자가 실행하는 스크립트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2eb9b9a155f6c64706ab31edb5653aa07c449701" translate="yes" xml:space="preserve">
          <source>Name of the test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d34802dcd2d7fcce651f51b7ec73165b93670d1" translate="yes" xml:space="preserve">
          <source>Name_Alias</source>
          <target state="translated">Name_Alias</target>
        </trans-unit>
        <trans-unit id="68785b7e9b3c03448ca8a837701cc8c707a8e260" translate="yes" xml:space="preserve">
          <source>Named Pipes</source>
          <target state="translated">명명 된 파이프</target>
        </trans-unit>
        <trans-unit id="38f9681437d9ef50ce0be66a608e2a42a4859202" translate="yes" xml:space="preserve">
          <source>Named Unary Operators</source>
          <target state="translated">명명 된 단항 연산자</target>
        </trans-unit>
        <trans-unit id="363027e7f4ba04f6c37400d54c44141712c1efe2" translate="yes" xml:space="preserve">
          <source>Named Unicode properties, scripts, and block ranges may be used (like bracketed character classes) by using the &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot; construct and the &lt;code&gt;\P{}&lt;/code&gt; negation, &quot;doesn't match property&quot;.</source>
          <target state="translated">명명 된 유니 코드 속성, 스크립트 및 블록 범위는 &lt;code&gt;\p{}&lt;/code&gt; &quot;matches property&quot;구성과 &lt;code&gt;\P{}&lt;/code&gt; 부정, &quot;properties와 일치하지 않음&quot; 을 사용하여 괄호 문자 클래스와 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f3bf2783d20b66cecd2489a0534cdb07661abf" translate="yes" xml:space="preserve">
          <source>Named backreference. Similar to numeric backreferences, except that the group is designated by name and not number. If multiple groups have the same name then it refers to the leftmost defined group in the current match.</source>
          <target state="translated">역 참조라는 이름. 그룹이 숫자가 아닌 이름으로 지정된다는 점을 제외하고 숫자 역 참조와 유사합니다. 여러 그룹의 이름이 같은 경우 현재 일치에서 가장 왼쪽에 정의 된 그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8dc1cc0c73966f67aab3d39f6cd441d18321c8ff" translate="yes" xml:space="preserve">
          <source>Named backreferences</source>
          <target state="translated">명명 된 역 참조</target>
        </trans-unit>
        <trans-unit id="16f988a61667e6887152ee06c28af4c95a899d43" translate="yes" xml:space="preserve">
          <source>Named capture callbacks</source>
          <target state="translated">명명 된 캡처 콜백</target>
        </trans-unit>
        <trans-unit id="a3c4ad7c429d9290102e7a6d5ae4db5c22f03f6f" translate="yes" xml:space="preserve">
          <source>Named or numbered characters and character sequences</source>
          <target state="translated">명명 된 또는 번호가 매겨진 문자 및 문자 순서</target>
        </trans-unit>
        <trans-unit id="65c4b696d78a27092b9642bc7761e57eb905bc44" translate="yes" xml:space="preserve">
          <source>Named parameters control how the processing is done. The following parameters are accepted:</source>
          <target state="translated">명명 된 매개 변수는 처리 방법을 제어합니다. 다음과 같은 매개 변수가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1d236b5d1295b7af7be948d212edc9fb3b966e" translate="yes" xml:space="preserve">
          <source>Named referencing</source>
          <target state="translated">명명 된 참조</target>
        </trans-unit>
        <trans-unit id="50a6776c3f86da85ce1ec46afa315f3a40ef3305" translate="yes" xml:space="preserve">
          <source>Named regexp capture buffers</source>
          <target state="translated">명명 된 정규식 캡처 버퍼</target>
        </trans-unit>
        <trans-unit id="5bc55622970622d1a946affa392f121998a96cf2" translate="yes" xml:space="preserve">
          <source>Named sequences proposed for inclusion in a later version of the Unicode Standard; if you need them now, you can append this file to</source>
          <target state="translated">이후 버전의 유니 코드 표준에 포함되도록 제안 된 명명 된 시퀀스; 지금 필요한 경우이 파일을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5c3780cc2079e280219cd2c73d0c31b04ec16680" translate="yes" xml:space="preserve">
          <source>NamedSequences.txt</source>
          <target state="translated">NamedSequences.txt</target>
        </trans-unit>
        <trans-unit id="e037613d4443785152fa3d95c2810f8c3354dd9d" translate="yes" xml:space="preserve">
          <source>NamedSqProv.txt</source>
          <target state="translated">NamedSqProv.txt</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="baefd92d48050a7240199d96c1a36a56b359c89c" translate="yes" xml:space="preserve">
          <source>Names can be specified in a variety of platform independent forms. Any names in the form &lt;b&gt;-lname&lt;/b&gt; are converted into</source>
          <target state="translated">이름은 다양한 플랫폼 독립적 형태로 지정할 수 있습니다. 형태의 모든 이름 &lt;b&gt;-lName가&lt;/b&gt; 로 변환</target>
        </trans-unit>
        <trans-unit id="6b7a2802d0082d79ff8976f3240ee6e3da8a9ceb" translate="yes" xml:space="preserve">
          <source>Names can include package names, which are relative to the specified PACKAGE. So these two calls have the same effect:</source>
          <target state="translated">이름에는 지정된 패키지와 관련된 패키지 이름이 포함될 수 있습니다. 따라서이 두 호출은 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="821821513dd7967a6e00087d901b1371b2e3ad09" translate="yes" xml:space="preserve">
          <source>Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">EXPORT_TAGS의 이름은 @EXPORT 또는 @EXPORT_OK에도 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c41eeb7fb1662a7738050a541890eb91cb128a6c" translate="yes" xml:space="preserve">
          <source>Names that start with a digit may contain only more digits. Names that do not start with a letter, underscore, digit or a caret (i.e. a control character) are limited to one character, e.g., &lt;code&gt;$%&lt;/code&gt; or &lt;code&gt;$$&lt;/code&gt; . (Most of these one character names have a predefined significance to Perl. For instance, &lt;code&gt;$$&lt;/code&gt; is the current process id.)</source>
          <target state="translated">숫자로 시작하는 이름에는 더 많은 숫자 만 포함될 수 있습니다. 문자, 밑줄, 숫자 또는 캐럿 (예 : 제어 문자)으로 시작하지 않는 이름은 한 문자 (예 : &lt;code&gt;$%&lt;/code&gt; 또는 &lt;code&gt;$$&lt;/code&gt; )로 제한됩니다 . (이 중 하나의 문자 이름은 대부분 Perl에 사전 정의 된 의미를 갖습니다. 예를 들어 &lt;code&gt;$$&lt;/code&gt; 는 현재 프로세스 ID입니다.)</target>
        </trans-unit>
        <trans-unit id="d6e3c92c2253dbdd3c4ece3e19dfc6a918646d7c" translate="yes" xml:space="preserve">
          <source>Names that start with a digit may contain only more digits. Names that do not start with a letter, underscore, digit or a caret are limited to one character, e.g., &lt;code&gt;$%&lt;/code&gt; or &lt;code&gt;$$&lt;/code&gt;. (Most of these one character names have a predefined significance to Perl. For instance, &lt;code&gt;$$&lt;/code&gt; is the current process id. And all such names are reserved for Perl's possible use.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61c957a0ea0313872e704f1b4fb7ca6add44160" translate="yes" xml:space="preserve">
          <source>Names which are unknown are output as &lt;code&gt;name='UNKNOWN';&lt;/code&gt; . See also &lt;code&gt;-V:name&lt;/code&gt; in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">알 수없는 &lt;code&gt;name='UNKNOWN';&lt;/code&gt; 은 name = 'UNKNOWN' 으로 출력됩니다 . . 참조 &lt;code&gt;-V:name&lt;/code&gt; 의 &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;명령 perlrun에서 전환합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5410d6566e489278d83cf4a60c9e048f5044cfdb" translate="yes" xml:space="preserve">
          <source>Names which are unknown are output as &lt;code&gt;name='UNKNOWN';&lt;/code&gt;. See also &lt;code&gt;-V:name&lt;/code&gt; in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acbec48b382ee1ec2cbdc1893b6da5a5a130d2d" translate="yes" xml:space="preserve">
          <source>NamesList.html</source>
          <target state="translated">NamesList.html</target>
        </trans-unit>
        <trans-unit id="98ccbf4f5c0c9d25ab257fc9d0e7b0d41bb961f3" translate="yes" xml:space="preserve">
          <source>NamesList.txt</source>
          <target state="translated">NamesList.txt</target>
        </trans-unit>
        <trans-unit id="286ecdc947944985bf973a72fa95a40f4b1c4f17" translate="yes" xml:space="preserve">
          <source>Namespace for Perl's core routines</source>
          <target state="translated">Perl의 핵심 루틴을위한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="da7731dc19a7c651d54b18d692eb80fc4c7ecba5" translate="yes" xml:space="preserve">
          <source>Namespace for formatters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34803b64f16548b242233b7132d75f6e5f8fe8e6" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3056e2bd0eee723080eaab7641ee4953af255c2b" translate="yes" xml:space="preserve">
          <source>Nathan Torkington &amp;lt;gnat@frii.com&amp;gt; - for some input on the documentation.</source>
          <target state="translated">Nathan Torkington &amp;lt;gnat@frii.com&amp;gt;-문서에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="425a4714dabb702a64966a65e07281505da878fd" translate="yes" xml:space="preserve">
          <source>Native Builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab012d77f1bfa1be662b51a80ae510c6cc5e59a" translate="yes" xml:space="preserve">
          <source>Native filenames are of the form</source>
          <target state="translated">기본 파일 이름은 형식입니다</target>
        </trans-unit>
        <trans-unit id="f32184e7a20d2a9f1d6a13ce8f1e8d87d0cb4d78" translate="yes" xml:space="preserve">
          <source>Natively compiling perl 5.30 or later should be as straightforward as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9026c8c56fc624332cd74cb5876316288c820bc7" translate="yes" xml:space="preserve">
          <source>Naturally, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; will do the reverse: it turns a character into a code point.</source>
          <target state="translated">당연히 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; 는 역을 수행합니다. 문자를 코드 포인트로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7462c5dafb369c2da402d8819a84ebcb4f3bc37d" translate="yes" xml:space="preserve">
          <source>Naturally, &lt;code&gt;ord()&lt;/code&gt; will do the reverse: it turns a character into a code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e294c54a3821c9309d267be94bb7315c4078d9b4" translate="yes" xml:space="preserve">
          <source>Nearly all of Perl already</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a140f3939f57780fd27a1d0165e3f2dc71e5686" translate="yes" xml:space="preserve">
          <source>Nearly all regops that involve looking at the input string have two cases, one for UTF-8, and one not. In fact, it's often more complex than that, as the pattern may be UTF-8 as well.</source>
          <target state="translated">입력 문자열을 보는 거의 모든 regop에는 UTF-8의 경우와 그렇지 않은 경우의 두 가지 경우가 있습니다. 실제로 패턴이 UTF-8 일 수도 있기 때문에 종종 그보다 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="1fd3d62f70c4406780dc474d5a41b0bf90bd7065" translate="yes" xml:space="preserve">
          <source>Need exactly 3 octal digits in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3f8a85f04426583b54b3312fffad6ba80924a3" translate="yes" xml:space="preserve">
          <source>Needed source files can be downloaded at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt;</source>
          <target state="translated">필요한 소스 파일은 &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; 에서 다운로드 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4c6bdc96d2ca3d241efb74d4a188d630f77bcd7" translate="yes" xml:space="preserve">
          <source>Negate the number, e.g. change the sign between '+' and '-', or between '+inf' and '-inf', respectively. Does nothing for NaN or zero.</source>
          <target state="translated">숫자를 무효화하십시오 (예 : '+'와 '-'사이 또는 '+ inf'와 '-inf'사이의 부호 변경). NaN 또는 0에 대해서는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d32e5cf3d83bdea0163589b14f9ddb6e83801ec" translate="yes" xml:space="preserve">
          <source>Negates previous setting of &lt;code&gt;ctx=noctx&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="7eeb67f2368c6c772835291295311889c092fbbd" translate="yes" xml:space="preserve">
          <source>Negation of POSIX character classes</source>
          <target state="translated">POSIX 문자 클래스의 부정</target>
        </trans-unit>
        <trans-unit id="0bbb46ed18fc239283ab5d6721b9f20daf485efe" translate="yes" xml:space="preserve">
          <source>Negative '/' count in unpack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838604a201964cc68e7ef736a20025e0b5fec649" translate="yes" xml:space="preserve">
          <source>Negative Epoch Values</source>
          <target state="translated">네거티브 에포크 값</target>
        </trans-unit>
        <trans-unit id="19f49d5d6ade2549965db79a7030897c2f5f4f62" translate="yes" xml:space="preserve">
          <source>Negative index positions are supported. Specifying a negative index position greater than the number of items in the queue may return items from the head of the queue (similar to &lt;code&gt;dequeue_nb&lt;/code&gt; ) if the count overlaps the head of the queue from the specified position (i.e. if queue size + index + count is greater than zero):</source>
          <target state="translated">음의 인덱스 위치가 지원됩니다. 큐의 항목 수보다 큰 음수 인덱스 위치를 지정 하면 지정된 위치에서 큐 수가 큐의 머리와 겹치는 경우 (예 : 큐 크기 + 인덱스 + 개수) 큐의 헤드에서 항목을 리턴 할 수 있습니다 ( &lt;code&gt;dequeue_nb&lt;/code&gt; 와 유사 ). 0보다 큼) :</target>
        </trans-unit>
        <trans-unit id="77f35a19afaa31759454e6029201200e580e338f" translate="yes" xml:space="preserve">
          <source>Negative index positions are supported. Specifying a negative index position greater than the number of items in the queue may return items from the head of the queue (similar to &lt;code&gt;dequeue_nb&lt;/code&gt;) if the count overlaps the head of the queue from the specified position (i.e. if queue size + index + count is greater than zero):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a43ac9c627d0de9e56d6cc12c6dfda0e520af0" translate="yes" xml:space="preserve">
          <source>Negative index positions are supported:</source>
          <target state="translated">음의 색인 위치가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5e4636dc65fd0c83bdadbdf91aa1d35d1fb840" translate="yes" xml:space="preserve">
          <source>Negative indexes are treated the same as with FETCH.</source>
          <target state="translated">음수 인덱스는 FETCH와 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="fe95900811e52afa9dd58cd10e425f82213ff9ca" translate="yes" xml:space="preserve">
          <source>Negative length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e608ed3d872d4ab6a4bbdcfb93eb90da28b4eec1" translate="yes" xml:space="preserve">
          <source>Negative offset to vec in lvalue context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed04f2afce275a8c0ec8d20c42d1e68c8ed46a8b" translate="yes" xml:space="preserve">
          <source>Negative repeat count does nothing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ec1ebfabb890ebda597976839aada64bc04b63" translate="yes" xml:space="preserve">
          <source>Negative values give the Unicode replacement character (chr(0xfffd)), except under the &lt;a href=&quot;../bytes&quot;&gt;bytes&lt;/a&gt; pragma, where the low eight bits of the value (truncated to an integer) are used.</source>
          <target state="translated">음수 값은 &lt;a href=&quot;../bytes&quot;&gt;바이트&lt;/a&gt; pragma 아래를 제외하고 유니 코드 대체 문자 (chr (0xfffd)) 를 제공합니다 (값의 하위 8 비트 (정수로 잘림)).</target>
        </trans-unit>
        <trans-unit id="1c329b07c62265cbfacaf020c4fd1ffae1eec60d" translate="yes" xml:space="preserve">
          <source>Negative values give the Unicode replacement character (chr(0xfffd)), except under the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, where the low eight bits of the value (truncated to an integer) are used.</source>
          <target state="translated">음수 값은 &lt;a href=&quot;bytes&quot;&gt;바이트&lt;/a&gt; pragma 아래를 제외하고 유니 코드 대체 문자 (chr (0xfffd)) 를 제공합니다 (값의 하위 8 비트 (정수로 잘림)).</target>
        </trans-unit>
        <trans-unit id="1f8e2d0b246c79d6b8bec7311afcd29fb2d3ca36" translate="yes" xml:space="preserve">
          <source>Neil Bowers &amp;lt;neil@bowers.com&amp;gt;</source>
          <target state="translated">닐 바우어 &amp;lt;neil@bowers.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6d2dec944babf88ec6f3aa5e208e251180845055" translate="yes" xml:space="preserve">
          <source>Neither IPC::Run nor IPC::Open3 can interleave STDOUT and STDERR. For short bursts of output from a program, e.g. this sample,</source>
          <target state="translated">IPC :: Run 또는 IPC :: Open3은 STDOUT 및 STDERR을 인터리브 할 수 없습니다. 이 샘플과 같은 프로그램의 짧은 출력 버스트의 경우</target>
        </trans-unit>
        <trans-unit id="347950b60212511ddff56b7de9a7367e8d020bbb" translate="yes" xml:space="preserve">
          <source>Neither of these forms will autovivify any stashes at compile time and only have run time effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55223738b7234df257020b80e5bb6455348daec" translate="yes" xml:space="preserve">
          <source>Neither of these last two commands will update your working directory, however both will update the remote-tracking branches in your repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcfe7ff09d4107e0ffd3c63c3f6ea8716597ff26" translate="yes" xml:space="preserve">
          <source>Neither the name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ec836d28f250f8bd76b8042a3917b08e1cacac" translate="yes" xml:space="preserve">
          <source>Neither using offsets nor adding &lt;code&gt;x&lt;/code&gt; 's to bridge the gaps is satisfactory. (Just imagine what happens if the structure changes.) What we really need is a way of saying &quot;skip as many bytes as required to the next multiple of N&quot;. In fluent Templatese, you say this with &lt;code&gt;x!N&lt;/code&gt; where N is replaced by the appropriate value. Here's the next version of our struct packaging:</source>
          <target state="translated">간격을 메우기 위해 오프셋을 사용하거나 &lt;code&gt;x&lt;/code&gt; 를 추가하는 것은 만족스럽지 않습니다. (구조가 바뀌면 어떻게 될지 상상해보십시오.) 실제로 필요한 것은 &quot;다음 N의 배수에 필요한만큼의 바이트를 건너 뛰십시오&quot;라고 말하는 방법입니다. 유창한 템플릿에서는 &lt;code&gt;x!N&lt;/code&gt; 으로 N을 적절한 값으로 바꿉니다. 구조체 패키징의 다음 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60a99bcf07880ccd5a328d1c33878c630eeaa795" translate="yes" xml:space="preserve">
          <source>Neither using offsets nor adding &lt;code&gt;x&lt;/code&gt;'s to bridge the gaps is satisfactory. (Just imagine what happens if the structure changes.) What we really need is a way of saying &quot;skip as many bytes as required to the next multiple of N&quot;. In fluent Templatese, you say this with &lt;code&gt;x!N&lt;/code&gt; where N is replaced by the appropriate value. Here's the next version of our struct packaging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07a42044209eb0a8555ca6ade59268b7094a144" translate="yes" xml:space="preserve">
          <source>Nelson, Greg (editor). Systems Programming with Modula-3. Prentice Hall, 1991, ISBN 0-13-590464-1.</source>
          <target state="translated">넬슨, 그렉 (편집자). Modula-3을 사용한 시스템 프로그래밍. 1991 년 Prentice Hall, ISBN 0-13-590464-1.</target>
        </trans-unit>
        <trans-unit id="f70ac392d4ed3bbaf151d74c3300a0bf8e1f667a" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; constructs are not no-ops, even if at first glance they might seem to be. This is because the nested &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; can restrict internal backtracking that otherwise might occur. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c5029fd7192d4f3ec3c0c9acc5e8ee66ed64a0" translate="yes" xml:space="preserve">
          <source>Nested quantifiers in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76def473f02aedcda635cf9dd95594a147e23e1" translate="yes" xml:space="preserve">
          <source>Nesting level is defined by number of hash- or arrayrefs that the encoder needs to traverse to reach a given point or the number of &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;[&lt;/code&gt; characters without their matching closing parenthesis crossed to reach a given character in a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efebdaa6b0f715d9d72c6ff062fcce8380a1d17" translate="yes" xml:space="preserve">
          <source>Net::BitTorrent</source>
          <target state="translated">Net::BitTorrent</target>
        </trans-unit>
        <trans-unit id="4eb9236f898d35e46f6533b663fb0cc39ac3281b" translate="yes" xml:space="preserve">
          <source>Net::Cmd</source>
          <target state="translated">Net::Cmd</target>
        </trans-unit>
        <trans-unit id="9b649db7310bc211d9f1ac99e1a4786a84597204" translate="yes" xml:space="preserve">
          <source>Net::Cmd - Network Command class (as used by FTP, SMTP etc)</source>
          <target state="translated">Net :: Cmd-네트워크 명령 클래스 (FTP, SMTP 등에서 사용)</target>
        </trans-unit>
        <trans-unit id="1294c92fcf04499d6b81523ccdaa5539dece0dcd" translate="yes" xml:space="preserve">
          <source>Net::Config</source>
          <target state="translated">Net::Config</target>
        </trans-unit>
        <trans-unit id="90625b9f0d5c16a32efbdc040ebbf3d89a17fb98" translate="yes" xml:space="preserve">
          <source>Net::Config - Local configuration data for libnet</source>
          <target state="translated">Net :: Config-libnet의 로컬 구성 데이터</target>
        </trans-unit>
        <trans-unit id="d2609cd7d34a9ef70d66b656d20f6d7141373166" translate="yes" xml:space="preserve">
          <source>Net::Domain</source>
          <target state="translated">Net::Domain</target>
        </trans-unit>
        <trans-unit id="79d06eb32b3346cf8bd3d603f70534bd0b81c26c" translate="yes" xml:space="preserve">
          <source>Net::Domain - Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">Net :: Domain-현재 호스트의 인터넷 이름 및 도메인을 평가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e600d59f8d5cea62e2e7232d04583ce46bcf0e54" translate="yes" xml:space="preserve">
          <source>Net::FTP</source>
          <target state="translated">Net::FTP</target>
        </trans-unit>
        <trans-unit id="760713d42087f7dca8f19249d8ef722a9fcee544" translate="yes" xml:space="preserve">
          <source>Net::FTP - FTP Client class</source>
          <target state="translated">Net :: FTP-FTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="92a35c424cd4eca45aaf00b8629e639085d233d4" translate="yes" xml:space="preserve">
          <source>Net::FTP implements the most popular ftp proxy firewall approach. The scheme implemented is that where you log in to the firewall with &lt;code&gt;user@hostname&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe29b949236419be339c0b7efff07aa8604a33" translate="yes" xml:space="preserve">
          <source>Net::FTP uses IO::Socket to open the connection and IO::Socket allows the port number to be specified as part of the hostname. So this problem can be resolved by either passing a Firewall option like &lt;code&gt;&quot;hostname:1234&quot;&lt;/code&gt; or by setting the &lt;code&gt;ftp_firewall&lt;/code&gt; option in Net::Config to be a string in the same form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c4644c97591ee47a8aae6116ac76edd4f5d83b" translate="yes" xml:space="preserve">
          <source>Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so all the methods described in Net::Cmd are also available on Net::FTP objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59946fef31b50a99653b28a153ac63abae9315d1" translate="yes" xml:space="preserve">
          <source>Net::FTP::dataconn</source>
          <target state="translated">Net::FTP::dataconn</target>
        </trans-unit>
        <trans-unit id="68e99886fb9e7eeead8137e48281b0ac46381c53" translate="yes" xml:space="preserve">
          <source>Net::FTP::dataconn - FTP Client data connection class</source>
          <target state="translated">Net :: FTP :: dataconn-FTP 클라이언트 데이터 연결 클래스</target>
        </trans-unit>
        <trans-unit id="2ba79303d7df37b27bccb82e4aaeb8383769338b" translate="yes" xml:space="preserve">
          <source>Net::NNTP</source>
          <target state="translated">Net::NNTP</target>
        </trans-unit>
        <trans-unit id="1f88f3dc9b54f8f1f3117b189d2bcc352702751e" translate="yes" xml:space="preserve">
          <source>Net::NNTP - NNTP Client class</source>
          <target state="translated">Net :: NNTP-NNTP 클라이언트 클래스</target>
        </trans-unit>
        <trans-unit id="634fa163a1bb55220f43fe3d8f658acf7bf2e805" translate="yes" xml:space="preserve">
          <source>Net::Netrc</source>
          <target state="translated">Net::Netrc</target>
        </trans-unit>
        <trans-unit id="e565165304b4cd87ebc082d3d778254a21d1e828" translate="yes" xml:space="preserve">
          <source>Net::Netrc - OO interface to users netrc file</source>
          <target state="translated">Net :: Netrc-사용자 netrc 파일에 대한 OO 인터페이스</target>
        </trans-unit>
        <trans-unit id="07d7d837c6ee6980c7dd03a4fc9e0f56e0b48e2f" translate="yes" xml:space="preserve">
          <source>Net::POP3</source>
          <target state="translated">Net::POP3</target>
        </trans-unit>
        <trans-unit id="c035763415c5e31a5fb091c5e1210e8a45507f17" translate="yes" xml:space="preserve">
          <source>Net::POP3 - Post Office Protocol 3 Client class (RFC1939)</source>
          <target state="translated">Net :: POP3-우체국 프로토콜 3 클라이언트 클래스 (RFC1939)</target>
        </trans-unit>
        <trans-unit id="aa89e2215ec797bac7f32905762d8dcb7883a796" translate="yes" xml:space="preserve">
          <source>Net::Ping</source>
          <target state="translated">Net::Ping</target>
        </trans-unit>
        <trans-unit id="797696af258d1ca33ead432810454bbe7f86b9d9" translate="yes" xml:space="preserve">
          <source>Net::Ping - check a remote host for reachability</source>
          <target state="translated">Net :: Ping-연결 가능성에 대한 원격 호스트 확인</target>
        </trans-unit>
        <trans-unit id="7523e64a2a317d77f41e0ee4bcc5eaf0e15b59ef" translate="yes" xml:space="preserve">
          <source>Net::Ping-&amp;gt;new([proto, timeout, bytes, device, tos, ttl, family, host, port, bind, gateway, retrans, pingstring, source_verify econnrefused dontfrag IPV6_USE_MIN_MTU IPV6_RECVPATHMTU])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7892c063104435dff8c4fb6f81f8e0633b34593b" translate="yes" xml:space="preserve">
          <source>Net::SMTP</source>
          <target state="translated">Net::SMTP</target>
        </trans-unit>
        <trans-unit id="3f4b2bd689e539d2c249ffa70c859d6d28efdef2" translate="yes" xml:space="preserve">
          <source>Net::SMTP - Simple Mail Transfer Protocol Client</source>
          <target state="translated">Net :: SMTP-단순 메일 전송 프로토콜 클라이언트</target>
        </trans-unit>
        <trans-unit id="06e6ad3b368406a8be028b87e347415ebb4b0cdf" translate="yes" xml:space="preserve">
          <source>Net::SMTP attempts to DWIM with addresses that are passed. For example an application might extract The From: line from an email and pass that to mail(). While this may work, it is not recommended. The application should really use a module like &lt;a href=&quot;Mail::Address&quot;&gt;Mail::Address&lt;/a&gt; to extract the mail address and pass that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dd7ce8a5f6c30dbe592557d703bdc3c58ebeb5" translate="yes" xml:space="preserve">
          <source>Net::SMTP attempts to DWIM with addresses that are passed. For example an application might extract The From: line from an email and pass that to mail(). While this may work, it is not recommended. The application should really use a module like &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Address&quot;&gt;Mail::Address&lt;/a&gt; to extract the mail address and pass that.</source>
          <target state="translated">Net :: SMTP는 전달 된 주소로 DWIM을 시도합니다. 예를 들어 응용 프로그램은 전자 메일에서 From : 행을 추출하여 mail ()로 전달할 수 있습니다. 이것이 작동 할 수는 있지만 권장되지는 않습니다. 응용 프로그램은 실제로 &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Address&quot;&gt;Mail :: Address&lt;/a&gt; 와 같은 모듈을 사용하여 메일 주소 를 추출하고 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8daf5a6d470279d0dfd4ec9a06cb691d5194e8eb" translate="yes" xml:space="preserve">
          <source>Net::SMTP implements the SMTP protocol. The DNS MX lookup is not part of this protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64018d825c9dce97cd967ab565ae5bde0e71a33f" translate="yes" xml:space="preserve">
          <source>Net::SSLeay on Solaris</source>
          <target state="translated">Solaris의 Net :: SSLeay</target>
        </trans-unit>
        <trans-unit id="8e0508a806d7681b9f57b4f0dafc12dd8ed03cac" translate="yes" xml:space="preserve">
          <source>Net::SSLeay requires a /dev/urandom to be present. This device is available from Solaris 9 onwards. For earlier Solaris versions you can either get the package SUNWski (packaged with several Sun software products, for example the Sun WebServer, which is part of the Solaris Server Intranet Extension, or the Sun Directory Services, part of Solaris for ISPs) or download the ANDIrand package from &lt;a href=&quot;http://www.cosy.sbg.ac.at/~andi/&quot;&gt;http://www.cosy.sbg.ac.at/~andi/&lt;/a&gt;. If you use SUNWski, make a symbolic link /dev/urandom pointing to /dev/random. For more details, see Document ID27606 entitled &quot;Differing /dev/random support requirements within Solaris[TM] Operating Environments&quot;, available at &lt;a href=&quot;http://sunsolve.sun.com&quot;&gt;http://sunsolve.sun.com&lt;/a&gt; .</source>
          <target state="translated">Net :: SSLeay에는 / dev / urandom이 있어야합니다. 이 장치는 Solaris 9부터 사용할 수 있습니다. 이전 Solaris 버전의 경우 SUNWski 패키지 (Solaris 서버 인트라넷 확장의 일부인 Sun WebServer 또는 ISP for Solaris의 일부인 Sun Directory Services와 같은 여러 Sun 소프트웨어 제품과 함께 패키지로 제공됨)를 다운로드하거나 ANDIrand에서 패키지 &lt;a href=&quot;http://www.cosy.sbg.ac.at/~andi/&quot;&gt;http://www.cosy.sbg.ac.at/~andi/&lt;/a&gt; . SUNWski를 사용하는 경우 / dev / random을 가리키는 심볼릭 링크 / dev / urandom을 만드십시오. 자세한 내용은 &lt;a href=&quot;http://sunsolve.sun.com&quot;&gt;http://sunsolve.sun.com&lt;/a&gt; 에서 &quot;Solaris [TM] 운영 환경의 다른 / dev / random 지원 요구 사항&quot;이라는 제목의 문서 ID27606을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="102b884f179ead18ed0a96b3577140ffb3aa57c6" translate="yes" xml:space="preserve">
          <source>Net::Time</source>
          <target state="translated">Net::Time</target>
        </trans-unit>
        <trans-unit id="d4f2b1be39e8c9f5b26b24988447cbc89c5fc6f8" translate="yes" xml:space="preserve">
          <source>Net::Time - time and daytime network client interface</source>
          <target state="translated">Net :: 시간-시간 및 주간 네트워크 클라이언트 인터페이스</target>
        </trans-unit>
        <trans-unit id="a529af9268e6c0617479c607894ba89216a5cc4f" translate="yes" xml:space="preserve">
          <source>Net::hostent</source>
          <target state="translated">Net::hostent</target>
        </trans-unit>
        <trans-unit id="98b632aa79485958bf201436fd61cedb7d0ac34a" translate="yes" xml:space="preserve">
          <source>Net::hostent - by-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">Net :: hostent-Perl의 내장 gethost * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="bc76b178ba622c9caf521e77cbcbe2855aa1bc5e" translate="yes" xml:space="preserve">
          <source>Net::libnetFAQ</source>
          <target state="translated">Net::libnetFAQ</target>
        </trans-unit>
        <trans-unit id="04ad5a37dedb3b744b15bac4ca7302257a051aef" translate="yes" xml:space="preserve">
          <source>Net::netent</source>
          <target state="translated">Net::netent</target>
        </trans-unit>
        <trans-unit id="1fbeb7dc05a497d734af7f7775d02430de2ab805" translate="yes" xml:space="preserve">
          <source>Net::netent - by-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">Net :: netent-Perl의 내장 getnet * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f1cdba311d5959633cf045aa60bf446ccf54af8" translate="yes" xml:space="preserve">
          <source>Net::protoent</source>
          <target state="translated">Net::protoent</target>
        </trans-unit>
        <trans-unit id="078ad82faa206681ea192cb93b449ee403fbdf7a" translate="yes" xml:space="preserve">
          <source>Net::protoent - by-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">Net :: protoent-Perl의 내장 getproto * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="c5f4c3e0d467febed569e1767ca88a110ec104d8" translate="yes" xml:space="preserve">
          <source>Net::servent</source>
          <target state="translated">Net::servent</target>
        </trans-unit>
        <trans-unit id="7e6a54f9191b9c026dff4416eca28d52185f8a20" translate="yes" xml:space="preserve">
          <source>Net::servent - by-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">Net :: servent-Perl의 내장 getserv * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="c5264f1d295bd0d284bab240b5d586bcd3e69efe" translate="yes" xml:space="preserve">
          <source>NetConfig VALUES</source>
          <target state="translated">NetConfig 값</target>
        </trans-unit>
        <trans-unit id="fb61c8a8eba24117016597fc7618f38821b16e8f" translate="yes" xml:space="preserve">
          <source>Netherlands</source>
          <target state="translated">Netherlands</target>
        </trans-unit>
        <trans-unit id="e17b1a34870d3dc76ed5ed6dddba8f1f23174d27" translate="yes" xml:space="preserve">
          <source>Network Command class (as used by FTP, SMTP etc)</source>
          <target state="translated">네트워크 명령 클래스 (FTP, SMTP 등에서 사용)</target>
        </trans-unit>
        <trans-unit id="c1cb4106aaf9e962404483234251f265e659ef77" translate="yes" xml:space="preserve">
          <source>Network File System, which allows you to mount a remote filesystem as if it were local.</source>
          <target state="translated">원격 파일 시스템을 마치 로컬 인 것처럼 마운트 할 수있는 네트워크 파일 시스템.</target>
        </trans-unit>
        <trans-unit id="1e91748557010f07119a40ac844fcae91cc2e7a3" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="translated">Networking</target>
        </trans-unit>
        <trans-unit id="1732a8d9a671f491b3444f4dd135a29f1c8db726" translate="yes" xml:space="preserve">
          <source>Networking constants and support functions</source>
          <target state="translated">네트워킹 상수 및 지원 기능</target>
        </trans-unit>
        <trans-unit id="3efe51707d515bbc55ed5e7a197cc135de39695b" translate="yes" xml:space="preserve">
          <source>Networking, Device Control (modems) and InterProcess Communication</source>
          <target state="translated">네트워킹, 장치 제어 (모뎀) 및 프로세스 간 통신</target>
        </trans-unit>
        <trans-unit id="f7865ee5f52b156bb53526c08f3154f5493c0e67" translate="yes" xml:space="preserve">
          <source>Neutralizes an op when it is no longer needed, but is still linked to from other ops.</source>
          <target state="translated">더 이상 필요하지 않은 op를 중립화하지만 여전히 다른 ops와 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9cdfd72ef200657927c8b92328d8203f7e523d" translate="yes" xml:space="preserve">
          <source>Never add a comma after &lt;code&gt;pTHX&lt;/code&gt; yourself--always use the form of the macro with the underscore for functions that take explicit arguments, or the form without the argument for functions with no explicit arguments.</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; 뒤에 쉼표를 추가하지 마십시오. 항상 명시적인 인수를 취하는 함수의 경우 밑줄과 함께 매크로 형식을 사용하거나 명시적인 인수가없는 함수의 경우 인수가없는 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5435ce11aa44af4272570c0064637abeeb8634e2" translate="yes" xml:space="preserve">
          <source>Never forget that the &lt;code&gt;SVf_UTF8&lt;/code&gt; flag is separate from the PV value; you need to be sure you don't accidentally knock it off while you're manipulating SVs. More specifically, you cannot expect to do this:</source>
          <target state="translated">것을 잊지 마십시오 &lt;code&gt;SVf_UTF8&lt;/code&gt; 의 플래그는 PV 값 별개입니다; SV를 조작하는 동안 실수로 눌리지 않도록해야합니다. 더 구체적으로, 당신은 이것을 기대할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="8b5cf307b4ec3e0ecc76a7852a46b24101becfd1" translate="yes" xml:space="preserve">
          <source>Never release anything (even a one-word documentation patch) without incrementing the number. Even a one-word documentation patch should result in a change in version at the sub-minor level.</source>
          <target state="translated">숫자를 늘리지 않고는 아무 것도 (한 단어로 된 문서 패치도) 해제하지 마십시오. 한 단어로 된 문서 패치라도 하위 수준에서 버전이 변경되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9967e88983d851428fa745aa72bb8b4e0bec2da" translate="yes" xml:space="preserve">
          <source>New Caledonia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e15dbc72156ffc0843ba2348b704e297c877b65" translate="yes" xml:space="preserve">
          <source>New Default Hash Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faca668b323e8715f2386a28f65791202098c13" translate="yes" xml:space="preserve">
          <source>New Hampshire</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b173294f2264191e273c10c1191a9e69ee069cb" translate="yes" xml:space="preserve">
          <source>New Jersey</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df5b2ef307f6a160a509c29570eb50079d5b0f1" translate="yes" xml:space="preserve">
          <source>New Things in this Example</source>
          <target state="translated">이 예의 새로운 것</target>
        </trans-unit>
        <trans-unit id="3dddf7feb16bf399efe204acf0fee9106ad446eb" translate="yes" xml:space="preserve">
          <source>New York</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2238e91907fa2436a6a50e0fd8cf97ab60ec508" translate="yes" xml:space="preserve">
          <source>New Zealand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2584dea92b21670e4258fc9ba91d4693d707e48d" translate="yes" xml:space="preserve">
          <source>New code should favor the three-argument form of &lt;code&gt;open&lt;/code&gt; over this older form. Declaring the mode and the filename as two distinct arguments avoids any confusion between the two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f51bfcb9560ecde82ad892ebcafb708e6079f56" translate="yes" xml:space="preserve">
          <source>New digest implementations should consider subclassing from &lt;a href=&quot;Digest::base&quot;&gt;Digest::base&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dbbca1c816cd191c8bd8984ca3248c86453e2c" translate="yes" xml:space="preserve">
          <source>New digest implementations should consider subclassing from &lt;a href=&quot;digest/base&quot;&gt;Digest::base&lt;/a&gt;.</source>
          <target state="translated">새로운 다이제스트 구현에서는 &lt;a href=&quot;digest/base&quot;&gt;Digest :: base의&lt;/a&gt; 서브 클래 싱을 고려해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1da49e0f3f02f18a191c8fcb01275608dfe945" translate="yes" xml:space="preserve">
          <source>New features and extensions to the language can be contentious. There is no specific set of criteria which determine what features get added, but here are some questions to consider when developing a patch:</source>
          <target state="translated">언어에 대한 새로운 기능과 확장은 논쟁의 여지가 있습니다. 추가 할 기능을 결정하는 특정 기준은 없지만 패치를 개발할 때 고려해야 할 몇 가지 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da95c014dd8883747091781d4d6ca60e675421a" translate="yes" xml:space="preserve">
          <source>New form, no specials, outside O framework:</source>
          <target state="translated">O 프레임 워크 외부의 새로운 형태, 특별한 사항 없음 :</target>
        </trans-unit>
        <trans-unit id="5e8cec07473bfe4fcd70c1e35f5f7241e6718c1b" translate="yes" xml:space="preserve">
          <source>New in v5.22, &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt; applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be71b0b9cb949acf4db96e41224f4fef5adee91f" translate="yes" xml:space="preserve">
          <source>New in v5.22, &lt;a href=&quot;re#'strict'-mode&quot;&gt;use re 'strict' &lt;/a&gt; applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</source>
          <target state="translated">v5.22의 새로운 기능인 &lt;a href=&quot;re#'strict'-mode&quot;&gt;re 'strict'를 사용&lt;/a&gt; 하면 정규식 패턴을 컴파일 할 때보 다 엄격한 규칙이 적용됩니다. 합법적이지만 의도하지 않은 것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="395e14e59421d33f95e93938d8513a500819f2e7" translate="yes" xml:space="preserve">
          <source>New in v5.22, this applies stricter rules than otherwise when compiling regular expression patterns. It can find things that, while legal, may not be what you intended.</source>
          <target state="translated">v5.22의 새로운 기능으로, 정규 표현식 패턴을 컴파일 할 때보 다 더 엄격한 규칙을 적용합니다. 합법적이지만 의도하지 않은 것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ba249fed1974d4b07df4d7258092eb5b6e28d9" translate="yes" xml:space="preserve">
          <source>New releases of maintenance branches should only contain changes that fall into one of the &quot;acceptable&quot; categories set out below, but must not contain any changes that fall into one of the &quot;unacceptable&quot; categories. (For example, a fix for a crashing bug must not be included if it breaks binary compatibility.)</source>
          <target state="translated">유지 보수 지점의 새 릴리스에는 아래에 설명 된 &quot;허용 가능한&quot;범주 중 하나에 해당하는 변경 사항 만 포함되어야하지만 &quot;허용 할 수없는&quot;범주 중 하나에 해당하는 변경 사항은 포함해서는 안됩니다. 예를 들어, 이진 호환성을 위반하는 경우 충돌 버그에 대한 수정 프로그램이 포함되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="795ece357da263bd94bd3808d4fa48fca182a70d" translate="yes" xml:space="preserve">
          <source>New syntax and semantics which don't break existing language constructs and syntax have a much lower bar. They merely need to prove themselves to be useful, elegant, well designed, and well tested. In most cases, these additions will be marked as</source>
          <target state="translated">기존 언어 구성과 구문을 깨뜨리지 않는 새로운 구문과 의미는 훨씬 더 낮습니다. 그들은 유용하고, 우아하고, 잘 설계되고, 잘 테스트되었음을 ​​증명하기 만하면됩니다. 대부분의 경우 이러한 추가 사항은</target>
        </trans-unit>
        <trans-unit id="4fb820941ba4424da4c1818abae06d75b8cd8521" translate="yes" xml:space="preserve">
          <source>New versions of dual-life modules should NOT be imported into maint. Those belong in the next stable series.</source>
          <target state="translated">새 버전의 이중 수명 모듈을 메인으로 가져 와서는 안됩니다. 그것들은 다음 안정적인 시리즈에 속합니다.</target>
        </trans-unit>
        <trans-unit id="231604734d2d979c77600cba2319f1623c551b25" translate="yes" xml:space="preserve">
          <source>New() and Copy() are unfortunately used by both Symbian and Perl code so you'll have to play cpp games if you need them. PerlBase.h undefines the Perl definitions and redefines them as PerlNew() and PerlCopy().</source>
          <target state="translated">안타깝게도 New () 및 Copy ()는 Symbian 및 Perl 코드에서 사용되므로 필요한 경우 cpp 게임을해야합니다. PerlBase.h는 Perl 정의를 정의 해제하고이를 PerlNew () 및 PerlCopy ()로 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="81e452125a72a6fe6ff7abcdeebcf00242e0de29" translate="yes" xml:space="preserve">
          <source>New, in 1.96, a hash that clusters known perl releases by their major versions.</source>
          <target state="translated">1.96의 새로운 기능으로 알려진 펄 릴리스를 주요 버전으로 클러스터링합니다.</target>
        </trans-unit>
        <trans-unit id="972a5d24a8408b783c69c2ea8d49e34b9b7c8c94" translate="yes" xml:space="preserve">
          <source>New-style form:</source>
          <target state="translated">새로운 스타일 :</target>
        </trans-unit>
        <trans-unit id="66543c20a971108cd6769d66337b781595c7b81c" translate="yes" xml:space="preserve">
          <source>Newer releases of VOS (OpenVOS Release 17.0 or later) support a feature known as extended names. On these releases, file names can contain up to 255 characters, are prohibited from starting with a &lt;code&gt;-&lt;/code&gt; character, and the set of prohibited characters is reduced to &lt;code&gt;#%*&amp;lt;&amp;gt;?&lt;/code&gt;. There are restrictions involving spaces and apostrophes: these characters must not begin or end a name, nor can they immediately precede or follow a period. Additionally, a space must not immediately precede another space or hyphen. Specifically, the following character combinations are prohibited: space-space, space-hyphen, period-space, space-period, period-apostrophe, apostrophe-period, leading or trailing space, and leading or trailing apostrophe. Although an extended file name is limited to 255 characters, a path name is still limited to 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc90c268bb4cb375e6b7a75ff03116a6ae0e5fb9" translate="yes" xml:space="preserve">
          <source>Newer releases of VOS (OpenVOS Release 17.0 or later) support a feature known as extended names. On these releases, file names can contain up to 255 characters, are prohibited from starting with a &lt;code&gt;-&lt;/code&gt; character, and the set of prohibited characters is reduced to any character matching &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/#%*&amp;lt;&amp;gt;?//&lt;/a&gt;&lt;/code&gt;. There are restrictions involving spaces and apostrophes: these characters must not begin or end a name, nor can they immediately precede or follow a period. Additionally, a space must not immediately precede another space or hyphen. Specifically, the following character combinations are prohibited: space-space, space-hyphen, period-space, space-period, period-apostrophe, apostrophe-period, leading or trailing space, and leading or trailing apostrophe. Although an extended file name is limited to 255 characters, a path name is still limited to 256 characters.</source>
          <target state="translated">VOS의 최신 릴리스 (OpenVOS 릴리스 17.0 이상)는 확장 이름이라는 기능을 지원합니다. 이 릴리스에서 파일 이름은 최대 255자를 포함 할 수 있으며 &lt;code&gt;-&lt;/code&gt; 문자로 시작할 수 없으며 금지 문자 세트는 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/#%*&amp;lt;&amp;gt;?//&lt;/a&gt;&lt;/code&gt; 일치하는 문자로 줄어 듭니다.. 공백과 아포스트로피와 관련된 제한 사항이 있습니다.이 문자는 이름을 시작하거나 종료해서는 안되며 마침표 바로 앞이나 뒤에 올 수 없습니다. 또한 공백이 다른 공백이나 하이픈 바로 앞에 오지 않아야합니다. 특히 공백, 공백 하이픈, 기간 공백, 공백 기간, 아포스트로피, 아포스트로피 기간, 선행 또는 후행 공백 및 선행 또는 후행 아포스트로피와 같은 문자 조합이 금지됩니다. 확장 파일 이름은 255 자로 제한되지만 경로 이름은 여전히 ​​256 자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="048adf5652fc133a2fe5a581a0402744d96b2a3a" translate="yes" xml:space="preserve">
          <source>Newline (&lt;code&gt;\n&lt;/code&gt; ) is translated as &lt;code&gt;\015\012&lt;/code&gt; by STDIO when reading from and writing to files (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;). &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; will keep &lt;code&gt;\n&lt;/code&gt; translated as &lt;code&gt;\012&lt;/code&gt; for that filehandle. Since it is a no-op on other systems, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; should be used for cross-platform code that deals with binary data. That's assuming you realize in advance that your data is in binary. General-purpose programs should often assume nothing about their data.</source>
          <target state="translated">줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; )로 번역 &lt;code&gt;\015\012&lt;/code&gt; 에서 읽기 및 파일 (참조에 기록 할 때 STDIO으로 &lt;a href=&quot;#Newlines&quot;&gt;줄 바꿈&lt;/a&gt; ). &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; 는 해당 파일 핸들에 대해 &lt;code&gt;\n&lt;/code&gt; 을 &lt;code&gt;\012&lt;/code&gt; 로 번역 된 상태로 유지 합니다. 다른 시스템에서는 no-op이므로 바이너리 모드를 처리하는 크로스 플랫폼 코드 에는 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 를 사용해야합니다. 데이터가 이진 파일임을 미리 알고 있다고 가정합니다. 범용 프로그램은 종종 데이터에 대해 아무 것도 가정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="66fb8bba4fb56fb1ef583894abf671d1f75766b7" translate="yes" xml:space="preserve">
          <source>Newline (&lt;code&gt;\n&lt;/code&gt;) is translated as &lt;code&gt;\015\012&lt;/code&gt; by the I/O system when reading from and writing to files (see &lt;a href=&quot;#Newlines&quot;&gt;&quot;Newlines&quot;&lt;/a&gt;). &lt;code&gt;binmode($filehandle)&lt;/code&gt; will keep &lt;code&gt;\n&lt;/code&gt; translated as &lt;code&gt;\012&lt;/code&gt; for that filehandle. &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; should always be used for code that deals with binary data. That's assuming you realize in advance that your data is in binary. General-purpose programs should often assume nothing about their data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7903c1910fd26e6355fca4a3a2873689173f8fa4" translate="yes" xml:space="preserve">
          <source>Newlines</source>
          <target state="translated">Newlines</target>
        </trans-unit>
        <trans-unit id="627f688311b36f3c91aca584369635de1f066e06" translate="yes" xml:space="preserve">
          <source>News sites</source>
          <target state="translated">뉴스 사이트</target>
        </trans-unit>
        <trans-unit id="8647adb6fe19cc8d435873e6cfe947de3bf110fe" translate="yes" xml:space="preserve">
          <source>Newx</source>
          <target state="translated">Newx</target>
        </trans-unit>
        <trans-unit id="74cbf0dac5707f013f7b0492127e291cbd8676be" translate="yes" xml:space="preserve">
          <source>Newxc</source>
          <target state="translated">Newxc</target>
        </trans-unit>
        <trans-unit id="edf4fdc9f4f2d963ec2b67061be527eaa57619fb" translate="yes" xml:space="preserve">
          <source>Newxz</source>
          <target state="translated">Newxz</target>
        </trans-unit>
        <trans-unit id="3ad9cf64efb1ec1fd62f31a781211fbbae056b26" translate="yes" xml:space="preserve">
          <source>Next the fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; is transformed behind the scenes into a full Perl regular expression, with the additional step of wrapping each transformed wildcard metacharacter sequence in parenthesis.</source>
          <target state="translated">그런 다음 fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; 는 장면 뒤에서 전체 Perl 정규식으로 변환되며 변환 된 각 와일드 카드 메타 문자 시퀀스를 괄호로 묶는 추가 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f4446a1caaaf275974baec33a0412159413e91" translate="yes" xml:space="preserve">
          <source>Next time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91094329b9da103c7bf80abf3b096f03628711d7" translate="yes" xml:space="preserve">
          <source>Next to a lexicon full of shorthand code, that sort of sticks out like a sore thumb -- but this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd107a1441fbf81bd2a151e1d1ce3a7c6dd7ff9" translate="yes" xml:space="preserve">
          <source>Next we tell Perl to update the global stack pointer from our internal variable: &lt;code&gt;dSP&lt;/code&gt; only gave us a local copy, not a reference to the global.</source>
          <target state="translated">우리는 우리의 내부 변수에서 전역 스택 포인터를 업데이트 펄에게 다음 : &lt;code&gt;dSP&lt;/code&gt; 단지 우리에게 로컬 복사본이 아닌 세계에 대한 참조를했다.</target>
        </trans-unit>
        <trans-unit id="e906a80d642a9982295c053351051e5071216f8d" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;cx_popblock&lt;/code&gt; restores all the various interpreter vars to their previous values or previous high water marks; it expands to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783f6fb233a2d3b4a2bd0d885d732e1060c3e708" translate="yes" xml:space="preserve">
          <source>Next, both &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;filter_read_exact&lt;/code&gt; will append any source data that is read to the end of &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">다음으로, &lt;code&gt;filter_read&lt;/code&gt; 와 &lt;code&gt;filter_read_exact&lt;/code&gt; 는 &lt;code&gt;$_&lt;/code&gt; 의 끝에 읽힌 소스 데이터를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a0d5b889e71fbe2c1477c43e20c912e00d4c8342" translate="yes" xml:space="preserve">
          <source>Next, both &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;filter_read_exact&lt;/code&gt; will append any source data that is read to the end of &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398d2fa0903d1a4262e38cb8eb6340d631516bf9" translate="yes" xml:space="preserve">
          <source>Next, having examined the program for</source>
          <target state="translated">다음으로, 프로그램을 검토 한 후</target>
        </trans-unit>
        <trans-unit id="552813864fdd734e7d3907009afd77e400d86761" translate="yes" xml:space="preserve">
          <source>Next, in line 7, we construct the interpreter using perl_construct, also in</source>
          <target state="translated">다음으로 7 행에서 perl_construct를 사용하여 인터프리터를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f0e17f120e69b5b4b71c231b6f1b48ac0f7c5f87" translate="yes" xml:space="preserve">
          <source>Next, is an optional description of what the value means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b383b7fb30a64fd95b0ad32a79caca9dc933b0b1" translate="yes" xml:space="preserve">
          <source>Next, we come to EXTEND and PUSHs. This is where the parameters actually get pushed onto the stack. In this case we are pushing a string and an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8efbc1a7cdd184e2054cd4a6e7618c9a7c54c2" translate="yes" xml:space="preserve">
          <source>Next, we come to XPUSHs. This is where the parameters actually get pushed onto the stack. In this case we are pushing a string and an integer.</source>
          <target state="translated">다음으로 XPUSH에 왔습니다. 여기서 매개 변수가 실제로 스택으로 푸시됩니다. 이 경우 문자열과 정수를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="3a3933ffb575f6d148ec34824fe349c3e318f912" translate="yes" xml:space="preserve">
          <source>Next, we create the filter object and associate it with the source stream by defining the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. If you know Perl well enough, you know that &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is called automatically every time a module is included with a use statement. This makes &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; the ideal place to both create and install a filter object.</source>
          <target state="translated">다음으로 필터 객체를 작성하고 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 기능 을 정의하여 소스 스트림과 연관 시킵니다. Perl을 충분히 알고 있으면 모듈이 use 문에 포함될 때마다 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 가 자동으로 호출됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 통해 필터 개체를 만들고 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36703328150265b0a107cb522700c61245fb4fc9" translate="yes" xml:space="preserve">
          <source>Next, we create the filter object and associate it with the source stream by defining the &lt;code&gt;import&lt;/code&gt; function. If you know Perl well enough, you know that &lt;code&gt;import&lt;/code&gt; is called automatically every time a module is included with a use statement. This makes &lt;code&gt;import&lt;/code&gt; the ideal place to both create and install a filter object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79dac3470efd6c09749fb5bc8d5df733f8598af" translate="yes" xml:space="preserve">
          <source>Next. Executes over subroutine calls, until the beginning of the next statement. If an expression is supplied that includes function calls, those functions will be executed with stops before each statement.</source>
          <target state="translated">다음. 다음 명령문이 시작될 때까지 서브 루틴 호출을 통해 실행합니다. 함수 호출을 포함하는 표현식이 제공되면 해당 함수는 각 명령문 전에 중지와 함께 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f90871213344aaacc3e3fb157cf776edfa434b0" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">니콜라스 클라크 &amp;lt;nick@ccl4.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3593afcaf4055fb7e2ec7f9aa19266c706c63d66" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt; based on the code in &lt;code&gt;h2xs&lt;/code&gt; by Larry Wall and others</source>
          <target state="translated">Larry Wall 등의 &lt;code&gt;h2xs&lt;/code&gt; 코드에 기반한 Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a9782aaa85e48d0ee97008381a9233aaf9ea098e" translate="yes" xml:space="preserve">
          <source>Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;, collating wisdom supplied by Slaven Rezic and Tim Bunce.</source>
          <target state="translated">Slaven Rezic과 Tim Bunce가 제공 한 지혜를 조합 한 Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="cb93bd4a857943c414e6a9f67769487dd9d1e793" translate="yes" xml:space="preserve">
          <source>Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx Farrell. Pthreads Programming. O'Reilly &amp;amp; Associates, 1996, ISBN 156592-115-1 (covers POSIX threads).</source>
          <target state="translated">Nichols, Bradford, Dick Buttlar 및 Jacqueline Proulx Farrell. Pthreads 프로그래밍. O'Reilly &amp;amp; Associates, 1996, ISBN 156592-115-1 (POSIX 스레드 포함).</target>
        </trans-unit>
        <trans-unit id="dc9a977deb5f6413937851a1c224335497c37077" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;</source>
          <target state="translated">Nick Ing-Simmons &amp;lt;nick@ing-simmons.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67fa933da77de5810dcb7a6bcbb7b43316cb56e6" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &amp;lt;nik@tiuk.ti.com&amp;gt;</source>
          <target state="translated">닉 잉 시몬스 &amp;lt;nik@tiuk.ti.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eec2116258d414025ff37d21592a6d975d4f492d" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons &lt;code&gt;ni-s@cpan.org&lt;/code&gt;</source>
          <target state="translated">Nick Ing-Simmons &lt;code&gt;ni-s@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f536379f776769e044b6352a1f333a7395148608" translate="yes" xml:space="preserve">
          <source>Nick Ing-Simmons nik@tiuk.ti.com</source>
          <target state="translated">Nick Ing-Simmons nik@tiuk.ti.com</target>
        </trans-unit>
        <trans-unit id="709b6991a1fe1d878c07948361b2e8f12dee5b31" translate="yes" xml:space="preserve">
          <source>Nick.Williams (at) morganstanley.com</source>
          <target state="translated">Nick.Williams (at) morganstanley.com</target>
        </trans-unit>
        <trans-unit id="c68fbab1fadb081f9a95a30a672a1a93a454b4ea" translate="yes" xml:space="preserve">
          <source>Nicolas Rochelemagne &amp;lt;rochelemagne@cpanel.net&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99442825b1535fca48dbbe1edab7783b86c33c79" translate="yes" xml:space="preserve">
          <source>Nifty, eh?</source>
          <target state="translated">괜찮아?</target>
        </trans-unit>
        <trans-unit id="c659a5acee6e44f93f94ad48f57acb3d1dc6ea05" translate="yes" xml:space="preserve">
          <source>Nigel Horne &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9508051ab4a47301185b3c92aa1d0eff8cd51fe8" translate="yes" xml:space="preserve">
          <source>Niko Tyni &amp;lt;ntyni@debian.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f28e5786c054d1cc29342757d2fd0556c7c2dc7" translate="yes" xml:space="preserve">
          <source>No &quot;=over&quot; ... &quot;=back&quot; region can contain headings. Processors may treat such a heading as an error.</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역은 제목을 포함 할 수 없습니다. 프로세서는 이러한 제목을 오류로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257bfa82d8cf42d7832f32c10a9c968cb66e0342" translate="yes" xml:space="preserve">
          <source>No %s allowed while running setuid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773b9688face4b5d00611d86533f2b8de906c9b4" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;syslog&lt;/code&gt; before &lt;code&gt;openlog&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;openlog&lt;/code&gt; 전에 &lt;code&gt;syslog&lt;/code&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20e0c334622edbcaf17b23f27e4a533188f282bc" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;syslog&lt;/code&gt; before &lt;code&gt;openlog&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c40a7affe9719b4eddb6cf9132e5c95c3be4c0e" translate="yes" xml:space="preserve">
          <source>No C++ style (//) comments</source>
          <target state="translated">C ++ 스타일 (//) 주석이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c1f7459efad1e56358a8f99cd0450bb9959dbf6" translate="yes" xml:space="preserve">
          <source>No DB::DB routine defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6deb18052c4d43f8553cddaf3139898fd40cc7a9" translate="yes" xml:space="preserve">
          <source>No DB::sub routine defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fcbc48a21b7232a53284d0488360e346f1c2a5" translate="yes" xml:space="preserve">
          <source>No Parameters, Nothing Returned</source>
          <target state="translated">매개 변수 없음, 반환 된 내용 없음</target>
        </trans-unit>
        <trans-unit id="77806734f269492cff2094d83b8fd4035093622c" translate="yes" xml:space="preserve">
          <source>No Perl script found in input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6465b961ebcc64954b26f6b4f08d2a66881aca" translate="yes" xml:space="preserve">
          <source>No Unicode property value wildcard matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaba0fb2bb1fc76d3a62f4fc39307ed0a310b2d" translate="yes" xml:space="preserve">
          <source>No adjustments are needed to entries that are references to arrays; each such entry will have exactly one element in its range, so the offset is always 0.</source>
          <target state="translated">배열을 참조하는 항목은 조정할 필요가 없습니다. 이러한 각 항목의 범위에는 정확히 하나의 요소가 있으므로 오프셋은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="87c881d12dc16380a72b9169dc66bd4762923e70" translate="yes" xml:space="preserve">
          <source>No arbitrary limits (platforms, data sizes, cultures).</source>
          <target state="translated">임의의 제한 (플랫폼, 데이터 크기, 문화)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ef060e66ed128ce859a264cbcabcc9e8b4d72cd" translate="yes" xml:space="preserve">
          <source>No attempt is made to resolve formatting codes. This must be done after calling parselink() (since E&amp;lt;&amp;gt; formatting codes can be used to escape characters that would otherwise be significant to the parser and resolving them before parsing would result in an incorrect parse of a formatting code like:</source>
          <target state="translated">형식화 코드를 해결하려고 시도하지 않습니다. 이는 parselink ()를 호출 한 후에 수행해야합니다. E &amp;lt;&amp;gt; 형식화 코드는 구문 분석기에 중요한 문자를 이스케이프하고 구문 분석하기 전에이를 해결하여 형식화 코드를 올바르지 않게 구문 분석 할 수 있기 때문에 사용할 수 있으므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d91a990deb28c435bf7686103fcfb9b19073f56f" translate="yes" xml:space="preserve">
          <source>No attempt to call methods on a child after &lt;code&gt;finalize&lt;/code&gt; is called is guaranteed to succeed.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 가 호출 된 후 자식에 대한 메소드 호출 시도 는 성공할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25bf937dadf1f1511dd27eb2964f699a6c2252b1" translate="yes" xml:space="preserve">
          <source>No checks against the filesystem are made, so the result may not be correct if &lt;code&gt;$base&lt;/code&gt; contains symbolic links. (Apply &lt;a href=&quot;../../cwd#abs_path&quot;&gt;Cwd::abs_path()&lt;/a&gt; beforehand if that is a concern.) On VMS, there is interaction with the working environment, as logicals and macros are expanded.</source>
          <target state="translated">파일 시스템을 검사하지 않으므로 &lt;code&gt;$base&lt;/code&gt; 에 기호 링크가 있으면 결과가 정확하지 않을 수 있습니다. ( 관심이 있다면 사전에 &lt;a href=&quot;../../cwd#abs_path&quot;&gt;Cwd :: abs_path ()를&lt;/a&gt; 적용하십시오 .) VMS에서는 논리 및 매크로가 확장됨에 따라 작업 환경과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="924a5f2c43a3c20b93a69cf9c70b83b8e4efcd36" translate="yes" xml:space="preserve">
          <source>No checks against the filesystem are made, so the result may not be correct if &lt;code&gt;$base&lt;/code&gt; contains symbolic links. (Apply &lt;a href=&quot;cwd#abs_path&quot;&gt;Cwd::abs_path()&lt;/a&gt; beforehand if that is a concern.) On VMS, there is interaction with the working environment, as logicals and macros are expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4449b82a66db373f8a7a36f371aa0993e46c55c" translate="yes" xml:space="preserve">
          <source>No checks against the filesystem are made. On VMS, there is interaction with the working environment, as logicals and macros are expanded.</source>
          <target state="translated">파일 시스템을 검사하지 않습니다. VMS에서는 논리 및 매크로가 확장됨에 따라 작업 환경과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="8e162ffb3e51b730037429889b3555f0e4824d87" translate="yes" xml:space="preserve">
          <source>No code point in the sequence has the &lt;code&gt;Script_Extension&lt;/code&gt; property of &lt;code&gt;Unknown&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda4eef0bcf2e071e18d2c28df5df747da976497" translate="yes" xml:space="preserve">
          <source>No code specified for -%c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5daa6be83067035e57bf5c2fd3c41a90c6754e" translate="yes" xml:space="preserve">
          <source>No comma allowed after %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33577302f316f3e6136a0a32a2d27da82e7aa28" translate="yes" xml:space="preserve">
          <source>No comma allowed after filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8ae1e010afaaa612013df1fc3d51681796c4d1" translate="yes" xml:space="preserve">
          <source>No command into which to pipe on command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd6e1a656baa449584f887ae6f967424aeab84f" translate="yes" xml:space="preserve">
          <source>No compression at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaac15a67a04661b57950ea3d1e562feb72ebfaf" translate="yes" xml:space="preserve">
          <source>No dbm on this machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c47c4f4513295ff856929f10f81971d5188422" translate="yes" xml:space="preserve">
          <source>No digits found for %s literal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f1be4cbae2242886aa2e79dff8536922352e79" translate="yes" xml:space="preserve">
          <source>No directory specified for -I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784c301abbb8b0d6d45cf7e9b60c5e854fd2a0b2" translate="yes" xml:space="preserve">
          <source>No distinction is made between prefix and postfix forms of the increment and decrement operators: these differ only in the point at which Perl calls the associated subroutine when evaluating an expression.</source>
          <target state="translated">증분 및 감소 연산자의 접두사와 접미사 형식은 구별되지 않습니다. 이는 표현식을 평가할 때 Perl이 연관된 서브 루틴을 호출하는 지점에서만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fe03072df15677b80e2b39e339befe55f08f3cc8" translate="yes" xml:space="preserve">
          <source>No documentation on this IOCTL is included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0ccdbe7b9dcd4482123d0dad177e0f6173c899" translate="yes" xml:space="preserve">
          <source>No documentation on this IOCTL operation was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6edce8008bb98711417eae932baa49a0c5e02c" translate="yes" xml:space="preserve">
          <source>No environment variables are used.</source>
          <target state="translated">환경 변수가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="424de2cbb2d7cb32de24408734d57590a414971a" translate="yes" xml:space="preserve">
          <source>No error file after 2&amp;gt; or 2&amp;gt;&amp;gt; on command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f86db3043e1779cce556c8cbf2a9d92caf05f24" translate="yes" xml:space="preserve">
          <source>No error is given if the unlink fails.</source>
          <target state="translated">연결 해제에 실패하면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f69a0eca515ffc8689bce47b2e5c1980b8dcb25" translate="yes" xml:space="preserve">
          <source>No exception will be thrown if the load fails.</source>
          <target state="translated">로드에 실패하면 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec5c0c5034b1d315d5f20a472cd293a01e6c64e1" translate="yes" xml:space="preserve">
          <source>No filename, no open.</source>
          <target state="translated">파일 이름이없고 열려 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="516bbd1a4dbc145932d17998cd4fb493e8a92e9f" translate="yes" xml:space="preserve">
          <source>No flags are currently defined for this method.</source>
          <target state="translated">이 메소드에는 현재 플래그가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bcf29927f72d2beb73b0553554252e7ba739e8a" translate="yes" xml:space="preserve">
          <source>No fork(), pipe(), popen() etc.</source>
          <target state="translated">포크 (), 파이프 (), 포펜 () 등 없음</target>
        </trans-unit>
        <trans-unit id="eb3952fa65dd262eb5d0a75ebf9c58a5c763ba6c" translate="yes" xml:space="preserve">
          <source>No functions are exported by default. The export tag &quot;:all&quot; will export all functions listed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542ccfca3b47fd89c0284e2ac4365b2fc6d2c787" translate="yes" xml:space="preserve">
          <source>No group ending character '%c' found in template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb023c0b15d320b359bb7fbf2e9461b84b577b5f" translate="yes" xml:space="preserve">
          <source>No input file after &amp;lt; on command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2202e903484320e4049cc95c7fbf8fcc519882bb" translate="yes" xml:space="preserve">
          <source>No interpolation is performed at this stage. Any backslashed sequences including &lt;code&gt;\\&lt;/code&gt; are treated at the stage to &lt;a href=&quot;#parsing-regular-expressions&quot;&gt;&quot;parsing regular expressions&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54075ccfb2214779b34385a718da12658fca1c0e" translate="yes" xml:space="preserve">
          <source>No interpolation is performed at this stage. Any backslashed sequences including &lt;code&gt;\\&lt;/code&gt; are treated at the stage to &lt;a href=&quot;#parsing-regular-expressions&quot;&gt;parsing regular expressions&lt;/a&gt;.</source>
          <target state="translated">이 단계에서는 보간이 수행되지 않습니다. &lt;code&gt;\\&lt;/code&gt; 를 포함한 모든 백 슬래시 시퀀스 는 스테이지에서 &lt;a href=&quot;#parsing-regular-expressions&quot;&gt;정규 표현식&lt;/a&gt; 을 구문 분석 하는 것으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbb5249e03fe539ae8e45d7b163fcee5fc3ee51d" translate="yes" xml:space="preserve">
          <source>No interpolation is performed. Note that the combination &lt;code&gt;\\&lt;/code&gt; is left intact, since escaped delimiters are not available for here-docs.</source>
          <target state="translated">보간이 수행되지 않습니다. 이스케이프 구분 기호는 here-docs에서 사용할 수 없으므로 &lt;code&gt;\\&lt;/code&gt; 조합 은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1c98ecfcdfe42d74e5f6e59d6542fc5e55fe1a89" translate="yes" xml:space="preserve">
          <source>No known problems yet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f4729e4c84e612c4062db3d2ec599e7d12e2ffa" translate="yes" xml:space="preserve">
          <source>No longer used. &lt;b&gt;pod2man&lt;/b&gt; used to check its input for validity as a manual page, but this should now be done by</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;b&gt;pod2man&lt;/b&gt; 은 입력이 매뉴얼 페이지인지 유효성을 검사하는 데 사용되었지만 이제는</target>
        </trans-unit>
        <trans-unit id="900007b766747b3fcc23577a66bc51c090e9d1ff" translate="yes" xml:space="preserve">
          <source>No longer used. &lt;b&gt;pod2man&lt;/b&gt; used to check its input for validity as a manual page, but this should now be done by &lt;a href=&quot;http://man.he.net/man1/podchecker&quot;&gt;podchecker(1)&lt;/a&gt; instead. Accepted for backward compatibility; this option no longer does anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0629e5133982636c8b13ba7650a2f7adde66d5d2" translate="yes" xml:space="preserve">
          <source>No matter how many @methods you check, a single &lt;code&gt;can_ok()&lt;/code&gt; call counts as one test. If you desire otherwise, use:</source>
          <target state="translated">몇 개의 @ 메소드를 확인하더라도 단일 &lt;code&gt;can_ok()&lt;/code&gt; 호출은 하나의 테스트로 계산됩니다. 다른 방법을 원한다면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bfe1ac6dceccca23c12f88b98cb2baa17573ef5f" translate="yes" xml:space="preserve">
          <source>No matter how you look at it, Unicode support is going to be a pain in a regex engine. Tricks that might be fine when you have 256 possible characters often won't scale to handle the size of the UTF-8 character set. Things you can take for granted with ASCII may not be true with Unicode. For instance, in ASCII, it is safe to assume that &lt;code&gt;sizeof(char1) == sizeof(char2)&lt;/code&gt; , but in UTF-8 it isn't. Unicode case folding is vastly more complex than the simple rules of ASCII, and even when not using Unicode but only localised single byte encodings, things can get tricky (for example, &lt;b&gt;LATIN SMALL LETTER SHARP S&lt;/b&gt; (U+00DF, &amp;szlig;) should match 'SS' in localised case-insensitive matching).</source>
          <target state="translated">어떻게 보더라도 유니 코드 지원은 정규식 엔진에서 어려움이 될 것입니다. 256 개의 가능한 문자가있을 때 좋은 트릭은 종종 UTF-8 문자 세트의 크기를 처리하도록 확장되지 않습니다. ASCII로 당연한 것으로 받아 들일 수있는 것은 유니 코드에서는 사실이 아닐 수 있습니다. 예를 들어, ASCII에서는 &lt;code&gt;sizeof(char1) == sizeof(char2)&lt;/code&gt; 라고 가정하는 것이 안전 하지만 UTF-8에서는 그렇지 않습니다. 유니 코드 케이스 폴딩은 단순한 ASCII 규칙보다 훨씬 더 복잡하며 유니 코드를 사용하지 않고 지역화 된 단일 바이트 인코딩 만 사용하는 경우에도 까다로울 수 있습니다 (예 : &lt;b&gt;LATIN SMALL LETTER SHARP S&lt;/b&gt; (U + 00DF, &amp;szlig;)는 ' 지역화 된 대소 문자를 구분하지 않는 SS ').</target>
        </trans-unit>
        <trans-unit id="50eb93d4cd16792026ffb4dcb8756c8d0fe4e9fc" translate="yes" xml:space="preserve">
          <source>No matter how you look at it, Unicode support is going to be a pain in a regex engine. Tricks that might be fine when you have 256 possible characters often won't scale to handle the size of the UTF-8 character set. Things you can take for granted with ASCII may not be true with Unicode. For instance, in ASCII, it is safe to assume that &lt;code&gt;sizeof(char1) == sizeof(char2)&lt;/code&gt;, but in UTF-8 it isn't. Unicode case folding is vastly more complex than the simple rules of ASCII, and even when not using Unicode but only localised single byte encodings, things can get tricky (for example, &lt;b&gt;LATIN SMALL LETTER SHARP S&lt;/b&gt; (U+00DF, &amp;szlig;) should match 'SS' in localised case-insensitive matching).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3134867d7de86de77f76195077742723406df400" translate="yes" xml:space="preserve">
          <source>No matter which locale you are in, the alphabetic characters are the characters in \w without the digits and the underscore. As a regex, that looks like &lt;code&gt;/[^\W\d_]/&lt;/code&gt; . Its complement, the non-alphabetics, is then everything in \W along with the digits and the underscore, or &lt;code&gt;/[\W\d_]/&lt;/code&gt; .</source>
          <target state="translated">어떤 로케일에 있든지 알파벳 문자는 숫자와 밑줄이없는 \ w의 문자입니다. 정규식으로서 &lt;code&gt;/[^\W\d_]/&lt;/code&gt; . 알파벳이 아닌 그 보완은 \ W의 모든 숫자와 밑줄 또는 &lt;code&gt;/[\W\d_]/&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a25ec0405e5b5d24e77d78a07b478e9acd7704a" translate="yes" xml:space="preserve">
          <source>No matter which locale you are in, the alphabetic characters are the characters in \w without the digits and the underscore. As a regex, that looks like &lt;code&gt;/[^\W\d_]/&lt;/code&gt;. Its complement, the non-alphabetics, is then everything in \W along with the digits and the underscore, or &lt;code&gt;/[\W\d_]/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae36c800cf26b17c9be8f946b97ab972ec2e9993" translate="yes" xml:space="preserve">
          <source>No message is printed if there is a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler installed. It is the handler's responsibility to deal with the message as it sees fit (like, for instance, converting it into a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;). Most handlers must therefore arrange to actually display the warnings that they are not prepared to deal with, by calling &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; again in the handler. Note that this is quite safe and will not produce an endless loop, since &lt;code&gt;__WARN__&lt;/code&gt; hooks are not called from inside one.</source>
          <target state="translated">&lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러가 설치되어 있으면 메시지가 인쇄되지 않습니다 . 적합하다고 생각되면 메시지를 처리하는 것은 처리기의 책임입니다 (예 : 메시지를 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 변환 ). 따라서 대부분의 처리기는 처리기에서 다시 &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 호출하여 처리 할 준비가되지 않은 경고를 실제로 표시하도록 정렬해야 합니다. &lt;code&gt;__WARN__&lt;/code&gt; 후크는 내부에서 호출되지 않기 때문에 이것은 매우 안전하며 무한 루프를 생성 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b68ebf47dc665b9110abca7286c7dd8e3c6d25d" translate="yes" xml:space="preserve">
          <source>No message is printed if there is a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler installed. It is the handler's responsibility to deal with the message as it sees fit (like, for instance, converting it into a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;). Most handlers must therefore arrange to actually display the warnings that they are not prepared to deal with, by calling &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; again in the handler. Note that this is quite safe and will not produce an endless loop, since &lt;code&gt;__WARN__&lt;/code&gt; hooks are not called from inside one.</source>
          <target state="translated">&lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 핸들러가 설치되어 있으면 메시지가 인쇄되지 않습니다 . 적합하다고 생각되면 메시지를 처리하는 것은 처리기의 책임입니다 (예 : 메시지를 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 로 변환 ). 따라서 대부분의 처리기는 처리기에서 다시 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 를 호출하여 처리 할 준비가되지 않은 경고를 실제로 표시하도록 정렬해야 합니다. &lt;code&gt;__WARN__&lt;/code&gt; 후크는 내부에서 호출되지 않기 때문에 이것은 매우 안전하며 무한 루프를 생성 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e88b0403f1df2a8394109aa2ba7bcbd6c0d574ec" translate="yes" xml:space="preserve">
          <source>No method will be exported.</source>
          <target state="translated">메소드가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d078ad69ad4e54066f3d8eeb48aedf41afe43993" translate="yes" xml:space="preserve">
          <source>No modifiers may follow the final delimiter. Instead, use &lt;a href=&quot;perlre#%28%3Fadlupimnsx-imnsx%29&quot;&gt;&quot;(?adlupimnsx-imnsx)&quot; in perlre&lt;/a&gt; and/or &lt;a href=&quot;perlre#%28%3Fadluimnsx-imnsx%3Apattern%29&quot;&gt;&quot;(?adluimnsx-imnsx:pattern)&quot; in perlre&lt;/a&gt; to specify modifiers. However, certain modifiers are illegal in your wildcard subpattern. The only character set modifier specifiable is &lt;code&gt;/aa&lt;/code&gt;; any other character set, and &lt;code&gt;-m&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;s&lt;/code&gt; are all illegal. Specifying modifiers like &lt;code&gt;qr/.../gc&lt;/code&gt; that aren't legal in the &lt;code&gt;(?...)&lt;/code&gt; notation normally raise a warning, but with wildcard subpatterns, their use is an error. The &lt;code&gt;m&lt;/code&gt; modifier is ineffective; everything that matches will be a single line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d694e82f8f5a6aee789fdf7e0d9a4abdbee8361" translate="yes" xml:space="preserve">
          <source>No name for escape sequence %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8a43bbd5b6a7c0fc112cc5db753e74a2da2bd1" translate="yes" xml:space="preserve">
          <source>No need to upgrade, old versions work fine. Only new versions will install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3f29207dc255b3e7e3b93af35cd32bc4da582b" translate="yes" xml:space="preserve">
          <source>No nested {}</source>
          <target state="translated">중첩 된 {} 없음</target>
        </trans-unit>
        <trans-unit id="ff909a31829cee8eec6e3320155b1a9c5999f78e" translate="yes" xml:space="preserve">
          <source>No next::method '%s' found for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57520a87f790317d2f0f376605bf7645f164bef4" translate="yes" xml:space="preserve">
          <source>No non-core modules are required for normal use, except on os390, which requires Convert::EBCDIC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108ebc6ec894325dc5e51ade6db8ba3a4fcfc3e6" translate="yes" xml:space="preserve">
          <source>No one is actively supporting Perl 4. Ten years ago it was a dead camel carcass (according to this document). Now it's barely a skeleton as its whitewashed bones have fractured or eroded.</source>
          <target state="translated">아무도 Perl 4를 적극적으로지지하고 있지 않습니다. 10 년 전 (이 문서에 따르면) 죽은 낙타 시체였습니다. 이제는 씻은 뼈가 골절되거나 침식되면서 골격이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a0177133aa06d0ec25b9195df7c3b7470ebfb3e" translate="yes" xml:space="preserve">
          <source>No output file after &amp;gt; on command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa07cf51ee6af06ec7bc8d2a28b3053649cf1e2" translate="yes" xml:space="preserve">
          <source>No output file after &amp;gt; or &amp;gt;&amp;gt; on command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83aaf049c05b18617887d9ad1515bb3e2acc8422" translate="yes" xml:space="preserve">
          <source>No package name allowed for subroutine %s in &quot;our&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9c00e16e167b3d5795fd4551618c4957016cd5" translate="yes" xml:space="preserve">
          <source>No package name allowed for variable %s in &quot;our&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c3fd86cbf458846a9ad5dbc11cfba132cabd89" translate="yes" xml:space="preserve">
          <source>No parentheses are permitted. This feature is particularly useful for arrays-of-arrays, or arrays-of-hashes:</source>
          <target state="translated">괄호는 허용되지 않습니다. 이 기능은 배열 배열 또는 해시 배열에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="469f8dede736caee70cee54e55a8464dbb9835e1" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다.</target>
        </trans-unit>
        <trans-unit id="3f4690d39fc8f180a0deea49e5cf7ef07d678475" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminated successive slashes and successive &quot;/.&quot;.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 &quot;/.&quot;를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="3f5d3240e92f64678ad0b020e9e7b82b4f021ec1" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminated successive slashes and successive &quot;/.&quot;. On Win32 makes</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 &quot;/.&quot;를 제거했습니다. Win32에서</target>
        </trans-unit>
        <trans-unit id="3ec2594a24cace2c7fc57252c4edc36c0995f1d6" translate="yes" xml:space="preserve">
          <source>No physical check on the filesystem, but a logical cleanup of a path. On UNIX eliminates successive slashes and successive &quot;/.&quot;.</source>
          <target state="translated">파일 시스템을 물리적으로 검사하지 않고 경로를 논리적으로 정리합니다. UNIX에서는 연속적인 슬래시와 연속적인 &quot;/&quot;를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e71f35adbc662150aba2fe0b4ae6aabc10f19d44" translate="yes" xml:space="preserve">
          <source>No plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccab456a43b7cc16ce0b5bc93c2d11acc7820455" translate="yes" xml:space="preserve">
          <source>No root path(s) specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e49343d906c08823451bc90b39a76fd921c7fa" translate="yes" xml:space="preserve">
          <source>No separator between a directory path and a filename on VMS.</source>
          <target state="translated">VMS에서 디렉토리 경로와 파일 이름 사이에 구분 기호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="deb641c36c1d1b360c1445dd38da07338eff42a1" translate="yes" xml:space="preserve">
          <source>No setregid available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc74076701edde5eed33dc7a331eae09584ec9c" translate="yes" xml:space="preserve">
          <source>No setreuid available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752ae710f92402615f714f07f2df83c92aef3774" translate="yes" xml:space="preserve">
          <source>No space before the semicolon.</source>
          <target state="translated">세미콜론 앞에 공백이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a57f317b57b3c0adf52cf25451dee19e20c69fd1" translate="yes" xml:space="preserve">
          <source>No space between function name and its opening parenthesis.</source>
          <target state="translated">함수 이름과 여는 괄호 사이에 공백이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6856f52acb86fb9730291ce342f9738b29e5d3" translate="yes" xml:space="preserve">
          <source>No such build tool exists. Even make itself has wildly different dialects. So we have to build our own.</source>
          <target state="translated">이러한 빌드 도구가 없습니다. 심지어는 그 자체가 사투리를 크게 다르게 만듭니다. 그래서 우리는 우리 자신을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="15e013d77e0bfdb442901fc1a5e5329c3aeff0d9" translate="yes" xml:space="preserve">
          <source>No such class %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01c7790634300e5054808e3daf7120756002229" translate="yes" xml:space="preserve">
          <source>No such class field &quot;%s&quot; in variable %s of type %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8031546db88dae684facba1f1a76046472a3d87" translate="yes" xml:space="preserve">
          <source>No such hook: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b84f48942a0b7077d6c110e9d17f34aef30607" translate="yes" xml:space="preserve">
          <source>No such pipe open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350468219a6c2e14abe311fceae1778a933613c6" translate="yes" xml:space="preserve">
          <source>No such signal: SIG%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="983c1355341f06fa836a2941ebb4e0c8331361de" translate="yes" xml:space="preserve">
          <source>No such thing. Just use a &lt;b&gt;lexical variable&lt;/b&gt; in a scope larger than your &lt;b&gt;subroutine&lt;/b&gt;, or declare it with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; instead of with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;서브 루틴&lt;/b&gt; 보다 큰 범위에서 &lt;b&gt;어휘 변수&lt;/b&gt; 를 사용 하거나 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 로 선언하십시오 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6cb7128b800911ffad487de8e45d9be529b8a81e" translate="yes" xml:space="preserve">
          <source>No such thing. Just use a &lt;b&gt;lexical variable&lt;/b&gt; in a scope larger than your &lt;b&gt;subroutine&lt;/b&gt;, or declare it with &lt;code&gt;state&lt;/code&gt; instead of with &lt;code&gt;my&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfee1d82923df34ecbc3757eed0d1a71f22fdeb9" translate="yes" xml:space="preserve">
          <source>No such thing. See &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;class method를&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24ad36b7a10baca2137d3e182796c8fa973e83aa" translate="yes" xml:space="preserve">
          <source>No such thing. See &lt;b&gt;lexical scoping&lt;/b&gt;.</source>
          <target state="translated">그런 것은 없습니다. &lt;b&gt;어휘 범위 지정을&lt;/b&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f5436248a66b44ec28a7a07c44cb765383f5e61" translate="yes" xml:space="preserve">
          <source>No suspects left</source>
          <target state="translated">남은 용의자 없음</target>
        </trans-unit>
        <trans-unit id="0b0e3c47f8113fc69c5db2a844ca423a0b0e626d" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Compress::Bzip2 at present.</source>
          <target state="translated">현재이 IO :: Compress :: Bzip2에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="295b36facbdc6f1e39ae12ab91f921909acbf35a" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::AnyInflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: AnyInflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee09f98ed165e0824d6ef187752ca356d22dda0" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::AnyUncompress at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: AnyUncompress에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df24583254943b025a824682df0b1dfe399beb9d" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Bunzip2 at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Bunzip2에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a69b3bd42bb22135230da30e5fa338a580834d5c" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Gunzip at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Gunzip에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="035acb0d322011913fd5d41a102d38ed488eeb8f" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Inflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Inflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9be5deb4e19e7df3ae4108a6bf22723539a2cce" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::RawInflate at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: RawInflate에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c18d218923a1c749b134fb8b13b00be7f7f924f" translate="yes" xml:space="preserve">
          <source>No symbolic constants are required by this IO::Uncompress::Unzip at present.</source>
          <target state="translated">현재이 IO :: Uncompress :: Unzip에는 기호 상수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcc2fb4bb27ec2672711d61bc08c85f54dc43272" translate="yes" xml:space="preserve">
          <source>No user hints defined for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bdd65afd19146fdce8e8b2d5e32c005beea617" translate="yes" xml:space="preserve">
          <source>No user-serviceable parts inside.</source>
          <target state="translated">내부에는 사용자가 수리 할 수있는 부품이 없습니다.</target>
        </trans-unit>
        <trans-unit id="67d5beb85edfab150b561584afd043236d2bdfa9" translate="yes" xml:space="preserve">
          <source>No variable interpolation occurs. String modifying combinations for case and quoting such as &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , and &lt;code&gt;\E&lt;/code&gt; are not recognized. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are converted to appropriate literals. The character &lt;code&gt;&quot;-&quot;&lt;/code&gt; is treated specially and therefore &lt;code&gt;\-&lt;/code&gt; is treated as a literal &lt;code&gt;&quot;-&quot;&lt;/code&gt; .</source>
          <target state="translated">변수 보간이 발생하지 않습니다. &lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; 및 &lt;code&gt;\E&lt;/code&gt; 와 같이 대소 문자 및 따옴표에 대한 문자열 수정 조합 은 인식되지 않습니다. &lt;code&gt;\200&lt;/code&gt; 및 &lt;code&gt;\t&lt;/code&gt; 와 같은 다른 이스케이프 시퀀스와 &lt;code&gt;\\&lt;/code&gt; 및 &lt;code&gt;\-&lt;/code&gt; 와 같은 백 슬래시 문자 는 적절한 리터럴로 변환됩니다. 문자 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 는 특별하게 취급되므로 &lt;code&gt;\-&lt;/code&gt; 는 리터럴 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="79cca34834e9a9e4df88122379363c6b6f1e012f" translate="yes" xml:space="preserve">
          <source>No variable interpolation occurs. String modifying combinations for case and quoting such as &lt;code&gt;\Q&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, and &lt;code&gt;\E&lt;/code&gt; are not recognized. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are converted to appropriate literals. The character &lt;code&gt;&quot;-&quot;&lt;/code&gt; is treated specially and therefore &lt;code&gt;\-&lt;/code&gt; is treated as a literal &lt;code&gt;&quot;-&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344119823e9aa0a1230bde24e92b97b7e8c49b30" translate="yes" xml:space="preserve">
          <source>No, Data::Dumper's Unicode abilities are as they should be. There have been some complaints that it should restore the UTF8 flag when the data is read again with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. However, you should really not look at the flag, and nothing indicates that Data::Dumper should break this rule.</source>
          <target state="translated">아니요, Data :: Dumper의 유니 코드 기능은 그대로입니다. &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 을 사용 하여 데이터를 다시 읽을 때 UTF8 플래그를 복원해야한다는 불만이있었습니다 . 그러나 플래그를 실제로 보지 않아야하며 Data :: Dumper가이 규칙을 위반해야한다는 것을 나타내는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="802da19c5fa327b3ebbca0edd91baa43bc779ec6" translate="yes" xml:space="preserve">
          <source>No, Data::Dumper's Unicode abilities are as they should be. There have been some complaints that it should restore the UTF8 flag when the data is read again with &lt;code&gt;eval&lt;/code&gt;. However, you should really not look at the flag, and nothing indicates that Data::Dumper should break this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa78bf2c5971126192cb16bb6c588fba93270da" translate="yes" xml:space="preserve">
          <source>No, Perl is easy to start &lt;a href=&quot;http://learn.perl.org/&quot;&gt;learning&lt;/a&gt; --and easy to keep learning. It looks like most programming languages you're likely to have experience with, so if you've ever written a C program, an awk script, a shell script, or even a BASIC program, you're already partway there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a38c27dd7fd1fed994a63f940f365b3621c19f1" translate="yes" xml:space="preserve">
          <source>No, Perl is easy to start &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flearn.perl.org%2f&quot;&gt;learning&lt;/a&gt; --and easy to keep learning. It looks like most programming languages you're likely to have experience with, so if you've ever written a C program, an awk script, a shell script, or even a BASIC program, you're already partway there.</source>
          <target state="translated">아닙니다. Perl은 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flearn.perl.org%2f&quot;&gt;배우기&lt;/a&gt; 쉽고 배우기 쉽습니다. 대부분의 프로그래밍 언어에 익숙한 것처럼 보이므로 C 프로그램, awk 스크립트, 쉘 스크립트 또는 BASIC 프로그램을 작성한 적이 있다면 이미 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="88ee7d9b8720b881699420ad9ccfc4e5c84c1947" translate="yes" xml:space="preserve">
          <source>No, and this isn't really a Unicode FAQ.</source>
          <target state="translated">아니요, 이것은 실제로 유니 코드 FAQ가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5d6f02eea0d900b7bfb2780fc2df229ad5239d91" translate="yes" xml:space="preserve">
          <source>No-op, provided for OO compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15815b309727bddc8a8cd4e554a2b5a8e3e42f09" translate="yes" xml:space="preserve">
          <source>No-ops</source>
          <target state="translated">No-ops</target>
        </trans-unit>
        <trans-unit id="e12405068610495a8442e94ec628add88b178c22" translate="yes" xml:space="preserve">
          <source>Nobody else on the planet is going to talk your local data format, so we can ignore that. But what about the thing in the middle? Building tree structures from Perl variables and then traversing them is a nice, general problem, and if nobody's already written a module that does that, you might want to modularise that code too.</source>
          <target state="translated">지구상의 어느 누구도 귀하의 로컬 데이터 형식을 이야기하지 않으므로 무시할 수 있습니다. 그러나 중간에있는 것은 어떻습니까? Perl 변수에서 트리 구조를 작성하고 순회하는 것은 좋은 일반적인 문제이며, 아무도 그렇게하지 않는 모듈을 작성하지 않았다면 해당 코드도 모듈화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a1a9fd7bbb71ea26aa1056d5954e10f58509d69" translate="yes" xml:space="preserve">
          <source>Nokia is a registered trademark of Nokia Corporation. Nokia's product names are trademarks or registered trademarks of Nokia. Other product and company names mentioned herein may be trademarks or trade names of their respective owners.</source>
          <target state="translated">Nokia는 Nokia Corporation의 등록 상표입니다. Nokia의 제품 이름은 Nokia의 상표 또는 등록 상표입니다. 여기에 언급 된 기타 제품 및 회사 이름은 해당 소유자의 상표 또는 상표 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6966adb468edf0cb8841781f043cf41939dccf" translate="yes" xml:space="preserve">
          <source>Non-Existent Local Times (DST)</source>
          <target state="translated">존재하지 않는 현지 시간 (DST)</target>
        </trans-unit>
        <trans-unit id="c8c499b19de2058088ccd7be966c0ac655b7adf3" translate="yes" xml:space="preserve">
          <source>Non-Hash Objects</source>
          <target state="translated">비해시 객체</target>
        </trans-unit>
        <trans-unit id="dbe9b5da0fbf8db965c6a52c0c98ed30d89ee662" translate="yes" xml:space="preserve">
          <source>Non-Perl Tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d84799ce73e00b044c0d551ac1642ef91417672" translate="yes" xml:space="preserve">
          <source>Non-Perl libraries, such as &lt;code&gt;gtk&lt;/code&gt;, that call the system &lt;code&gt;setlocale&lt;/code&gt; can continue to work if this function is called before transferring control to the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a4443d65a9907e689a96dad2b964b32204f4cf" translate="yes" xml:space="preserve">
          <source>Non-Unix users should check their &lt;code&gt;&lt;i&gt;Your_OS&lt;/i&gt;::Process&lt;/code&gt; module for other possible solutions.</source>
          <target state="translated">Unix 이외의 사용자는 &lt;code&gt;&lt;i&gt;Your_OS&lt;/i&gt;::Process&lt;/code&gt; 모듈에서 다른 가능한 솔루션을 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8955048c10f602a8fbda2fd5207694abb568decd" translate="yes" xml:space="preserve">
          <source>Non-bracketing delimiters use the same character fore and aft, but the four sorts of ASCII brackets (round, angle, square, curly) all nest, which means that</source>
          <target state="translated">대괄호가 아닌 구분 기호는 앞뒤에 동일한 문자를 사용하지만 네 가지 종류의 ASCII 괄호 (둥근, 각, 사각형, 중괄호)는 모두 중첩됩니다. 즉,</target>
        </trans-unit>
        <trans-unit id="d5ef8c3ef4f33bed9ce030f3cbfb6a9e3e9cf03b" translate="yes" xml:space="preserve">
          <source>Non-capturing groupings</source>
          <target state="translated">비 캡처 그룹화</target>
        </trans-unit>
        <trans-unit id="0b0affcbcf3b94afc7fed13853a23ba9ca1bafd7" translate="yes" xml:space="preserve">
          <source>Non-capturing groupings are also useful for removing nuisance elements gathered from a split operation where parentheses are required for some reason:</source>
          <target state="translated">캡처하지 않은 그룹화는 어떤 이유로 괄호가 필요한 분할 작업에서 수집 된 방해 요소를 제거하는 데에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="250bef419b1cfb6fc542fb72d52ad8cf2ddb7b3e" translate="yes" xml:space="preserve">
          <source>Non-finite repeat count does nothing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e8c733eeb11ebeb19aea8f0c24bafd0dcd3b78" translate="yes" xml:space="preserve">
          <source>Non-function Keywords by Cross-reference</source>
          <target state="translated">상호 참조 별 기능이없는 키워드</target>
        </trans-unit>
        <trans-unit id="bac16ae68c3fce95782862eda51b6e1ede9d4aa1" translate="yes" xml:space="preserve">
          <source>Non-function keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cf0c88b13d5175fbcbe31d22f2ddf98ce0cabe" translate="yes" xml:space="preserve">
          <source>Non-hex character '%c' terminates \x early. Resolved as &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7211affd3147ea133275fa861a1710f2e9d110" translate="yes" xml:space="preserve">
          <source>Non-hex character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81f5fe242ea0b94d3fcd14bf1f47ecae7e89c34" translate="yes" xml:space="preserve">
          <source>Non-interpretive attribute handlers</source>
          <target state="translated">해석 할 수없는 속성 처리기</target>
        </trans-unit>
        <trans-unit id="e94d3362f237ca4afac6040875234c6b9fba0037" translate="yes" xml:space="preserve">
          <source>Non-lexical variables are quite difficult to track through a program. Sometimes the type of a non-lexical variable's use is impossible to determine. Introductions of non-lexical non-scalars don't seem to be reported properly.</source>
          <target state="translated">비 어휘 변수는 프로그램을 통해 추적하기가 매우 어렵습니다. 어휘 적이 지 않은 변수의 유형을 결정하기 어려운 경우가 있습니다. 비-음수의 비-스칼라 소개는 제대로보고되지 않은 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="26df9e297a4b74c0b4469dd88197da6ad0ee1647" translate="yes" xml:space="preserve">
          <source>Non-locale-aware XS code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143be0c9dacdb4569154158e9bf1f623b64c631f" translate="yes" xml:space="preserve">
          <source>Non-mutators with a mutator variant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9b68521b56058539894259cdc010e5c4cac590" translate="yes" xml:space="preserve">
          <source>Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea4a82548edbcd0b7bf7b3e51fdce2be0f6eed2" translate="yes" xml:space="preserve">
          <source>Non-octal character in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f78bf86e7669259f75fa7cb97ef1591cd4d731" translate="yes" xml:space="preserve">
          <source>Non-printable ASCII characters are represented by &lt;b&gt;escape sequences&lt;/b&gt;. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, and &lt;code&gt;\r&lt;/code&gt; for a carriage return. Arbitrary bytes are represented by octal escape sequences, e.g., &lt;code&gt;\033&lt;/code&gt; , or hexadecimal escape sequences, e.g., &lt;code&gt;\x1B&lt;/code&gt; :</source>
          <target state="translated">인쇄 할 수없는 ASCII 문자는 &lt;b&gt;이스케이프 시퀀스&lt;/b&gt; 로 표시됩니다 . 일반적인 예는 탭의 경우 &lt;code&gt;\t&lt;/code&gt; , 줄 바꾸기의 경우 &lt;code&gt;\n&lt;/code&gt; , 캐리지 리턴의 경우 &lt;code&gt;\r&lt;/code&gt; 입니다. 임의 바이트는 8 진 이스케이프 시퀀스 (예 : &lt;code&gt;\033&lt;/code&gt; ) 또는 16 진 이스케이프 시퀀스 (예 : &lt;code&gt;\x1B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7aa2075dd471079df2c9c642ea33c0317f23a7c" translate="yes" xml:space="preserve">
          <source>Non-printable ASCII characters are represented by &lt;b&gt;escape sequences&lt;/b&gt;. Common examples are &lt;code&gt;\t&lt;/code&gt; for a tab, &lt;code&gt;\n&lt;/code&gt; for a newline, and &lt;code&gt;\r&lt;/code&gt; for a carriage return. Arbitrary bytes are represented by octal escape sequences, e.g., &lt;code&gt;\033&lt;/code&gt;, or hexadecimal escape sequences, e.g., &lt;code&gt;\x1B&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b4a2658c61f47bf2140155001f1ef6dc9d6757" translate="yes" xml:space="preserve">
          <source>Non-string passed as bitmask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b7c71547427b5d091f6bdffa36d87329e206a0" translate="yes" xml:space="preserve">
          <source>Noncharacter code points</source>
          <target state="translated">문자가 아닌 코드 포인트</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="d6c380a4b3a4edf398e410e1086f1f7a11f8a811" translate="yes" xml:space="preserve">
          <source>None by default.</source>
          <target state="translated">기본적으로 없음</target>
        </trans-unit>
        <trans-unit id="6aa4e4ea6e7911634748f65dccefc73c860296f0" translate="yes" xml:space="preserve">
          <source>None by default. &lt;code&gt;process_file()&lt;/code&gt; and/or &lt;code&gt;report_error_count()&lt;/code&gt; may be exported upon request. Using the functional interface is discouraged.</source>
          <target state="translated">기본적으로 없음 &lt;code&gt;process_file()&lt;/code&gt; 및 / 또는 &lt;code&gt;report_error_count()&lt;/code&gt; 내보낼 수 있습니다. 기능적 인터페이스를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="453747b325cac90861900bdf70984ba34f620d00" translate="yes" xml:space="preserve">
          <source>None by default. The only method is &lt;code&gt;import&lt;/code&gt;, called by &lt;code&gt;use deprecate;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5cef6753554f631841c949a6101aca86cbd5e5" translate="yes" xml:space="preserve">
          <source>None known (guess what must have been used to report them?)</source>
          <target state="translated">알려진 바 없음 (보고에 사용 된 것이 무엇입니까?)</target>
        </trans-unit>
        <trans-unit id="e6ac3d9a04f7cfc73ad80a24e739c468d87c50d1" translate="yes" xml:space="preserve">
          <source>None known at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d9ea3fd95989745b48b0ee2bb0fc38ac4cacda" translate="yes" xml:space="preserve">
          <source>None of the Encode team knows Hebrew enough (ISO-8859-8, cp1255 and MacHebrew are supported because and just because there were mappings available at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;). Contributions welcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ceb44e5b6031a9fa60a1bf1ee64b77cc82126f1" translate="yes" xml:space="preserve">
          <source>None of the below. Often a special device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0fc5245472be853cebf2ae9c2cf90be56b5342" translate="yes" xml:space="preserve">
          <source>None of the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d59b0c28271db96f51f420982722cd9cd2649b" translate="yes" xml:space="preserve">
          <source>None of the make types being checked for is viable on VMS, plus our $self-&amp;gt;{MAKE} is an unexpanded (and unexpandable) macro whose value is known only to the make utility itself.</source>
          <target state="translated">확인 된 make 유형 중 어느 것도 VMS에서 실행 가능하지 않으며 $ self-&amp;gt; {MAKE}는 make 유틸리티 자체에만 알려진 값의 확장되지 않은 (및 확장 불가능한) 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="1e04720e675e287c291e140902461ae4e502fb52" translate="yes" xml:space="preserve">
          <source>None of these bugs exist when using block eval</source>
          <target state="translated">블록 평가를 사용할 때 이러한 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="033d96f0084981901aa9644004656c9d55ed0182" translate="yes" xml:space="preserve">
          <source>None of these methods modify the invocand object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479325aa8b63106a6d86ab16c8ede5f5349e0981" translate="yes" xml:space="preserve">
          <source>None of these methods modify the invocand object. Note that a &lt;code&gt;NaN&lt;/code&gt; is neither less than, greater than, or equal to anything else, even a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="a1e84bde07301b296b051f051ed1c0db0b32e4b4" translate="yes" xml:space="preserve">
          <source>None. Remember: this is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a6496ffa4e9b51040364dbe3fe4269ea990e40" translate="yes" xml:space="preserve">
          <source>Nonetheless, Storable deserializing documents from untrusted sources is expected to have other, yet undiscovered, security concerns such as allowing an attacker to cause the deserializer to crash hard.</source>
          <target state="translated">그럼에도 불구하고 신뢰할 수없는 출처의 저장 가능한 역 직렬화 문서에는 공격자가 역 직렬화기를 강제로 중지시키는 것과 같은 다른 보안 문제가있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="175ce5f240a3e9cb0cbb1e3f58683b52d7a97a1d" translate="yes" xml:space="preserve">
          <source>Nor is the &lt;code&gt;@&lt;i&gt;unicode_property&lt;/i&gt;@&lt;/code&gt; form implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839bc88d91700ba09e378d5076a26e3c444a4e70" translate="yes" xml:space="preserve">
          <source>Norbert Pueschel, pueschel@imsdd.meb.uni-bonn.de Jan-Erik Karlsson, trg@privat.utfors.se</source>
          <target state="translated">Norbert Pueschel, pueschel@imsdd.meb.uni-bonn.de Jan-Erik Karlsson, trg@privat.utfors.se</target>
        </trans-unit>
        <trans-unit id="752b74baffa89f2087b420babd0da41de66e9651" translate="yes" xml:space="preserve">
          <source>NormTest.txt</source>
          <target state="translated">NormTest.txt</target>
        </trans-unit>
        <trans-unit id="bef55c09b30ad44df2dca64de025b08519e931e8" translate="yes" xml:space="preserve">
          <source>Normal Form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398931fe08778e56fac4c793097af9f4ad258767" translate="yes" xml:space="preserve">
          <source>Normal errors are reported by having store() or retrieve() return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Such errors are usually I/O errors (or truncated stream errors at retrieval).</source>
          <target state="translated">store () 또는 retrieve ()가 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 리턴하면 정상 오류가보고됩니다 . 이러한 오류는 일반적으로 I / O 오류 (또는 검색시 잘린 스트림 오류)입니다.</target>
        </trans-unit>
        <trans-unit id="19b9796cc876c957170d078d2d8dfae36e72dc58" translate="yes" xml:space="preserve">
          <source>Normal errors are reported by having store() or retrieve() return &lt;code&gt;undef&lt;/code&gt;. Such errors are usually I/O errors (or truncated stream errors at retrieval).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe142dfc22c18bbee0c7f0e054d1e4fe9b2118c" translate="yes" xml:space="preserve">
          <source>Normal object destructor method.</source>
          <target state="translated">일반적인 객체 소멸자 방법.</target>
        </trans-unit>
        <trans-unit id="857c285210fd011f006ff55811d0ad93b45d7b73" translate="yes" xml:space="preserve">
          <source>Normal users of Perl should never care how Perl encodes any particular Unicode string (because the normal ways to get at the contents of a string with Unicode--via input and output--should always be via explicitly-defined I/O layers). But if you must, there are two ways of looking behind the scenes.</source>
          <target state="translated">Perl의 일반 사용자는 Perl이 특정 유니 코드 문자열을 인코딩하는 방법에 신경 쓰지 않아야합니다 (입력 및 출력을 통해 유니 코드로 문자열의 내용을 얻는 일반적인 방법은 항상 명시 적으로 정의 된 I / O 레이어를 통해 이루어져야 함). 그러나 필요한 경우 장면 뒤를 보는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="7f5151d9a184cfb6f6a7bdc53123078ee18e8e1e" translate="yes" xml:space="preserve">
          <source>Normalization Corrections</source>
          <target state="translated">정규화 수정</target>
        </trans-unit>
        <trans-unit id="3fc17160b371a2dd2ce5f321ad17046bc51f04ec" translate="yes" xml:space="preserve">
          <source>Normalization Form Composed</source>
          <target state="translated">정규화 양식 작성</target>
        </trans-unit>
        <trans-unit id="8b530c9dcdf01b0cc0b4fd91277cae625646ab23" translate="yes" xml:space="preserve">
          <source>Normalization Form Decomposed</source>
          <target state="translated">정규화 형식 분해</target>
        </trans-unit>
        <trans-unit id="d6a84c0a7366c74d8b600470740fa32f23cb1e8c" translate="yes" xml:space="preserve">
          <source>Normalization Forms</source>
          <target state="translated">정규화 양식</target>
        </trans-unit>
        <trans-unit id="857696fa6055a6a9182e520ffef5e8982e055460" translate="yes" xml:space="preserve">
          <source>NormalizationCorrections.txt</source>
          <target state="translated">NormalizationCorrections.txt</target>
        </trans-unit>
        <trans-unit id="25d1f6918ee145ecbeeb0b9fc5d04c8edf9a3980" translate="yes" xml:space="preserve">
          <source>Normalize all arguments for consistency of comparison.</source>
          <target state="translated">비교의 일관성을 위해 모든 인수를 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="92f0c15067179151994e0422d3b7e1bea19d957f" translate="yes" xml:space="preserve">
          <source>Normalize the number. This is a no-op and is provided only for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b201ba0d30952b489241e1c219c0da1ea9609ad3" translate="yes" xml:space="preserve">
          <source>Normally 'Test2::Formatter::' is prefixed to the value in the environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf527795f304857fa2e9475a64463f107fbdc96" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; handles the &lt;code&gt;=cut&lt;/code&gt; POD directive by itself and does not pass it on to the caller for processing. Setting this option to a non-empty, non-zero value will cause &lt;b&gt;Pod::Parser&lt;/b&gt; to pass the &lt;code&gt;=cut&lt;/code&gt; directive to the caller just like any other POD command (and hence it may be processed by the &lt;b&gt;command()&lt;/b&gt; method).</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 &lt;code&gt;=cut&lt;/code&gt; POD 지시문 자체를 처리하고 처리를 위해 호출자에게 전달하지 않습니다. 이 옵션을 0이 아닌 0이 아닌 값으로 설정하면 &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 다른 POD 명령과 마찬가지로 &lt;code&gt;=cut&lt;/code&gt; 지시문을 호출자 에게 전달합니다 (따라서 &lt;b&gt;command ()&lt;/b&gt; 메소드 로 처리 될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="e5bacef8258b5f77e0e8d77b6f8e1d3a5079db51" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; recognizes a bare minimum of pod syntax errors and warnings and issues diagnostic messages for errors, but not for warnings. (Use &lt;b&gt;Pod::Checker&lt;/b&gt; to do more thorough checking of POD syntax.) Setting this option to a non-empty, non-zero value will cause &lt;b&gt;Pod::Parser&lt;/b&gt; to issue diagnostics for the few warnings it recognizes as well as the errors.</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 최소한의 포드 구문 오류와 경고를 인식하고 오류에 대해서는 진단 메시지를 표시하지만 경고에 대해서는 표시하지 않습니다. ( &lt;b&gt;Pod :: Checker&lt;/b&gt; 를 사용 하여 POD 구문을보다 철저하게 검사하십시오.)이 옵션을 0이 아닌 값이 아닌 값으로 설정하면 &lt;b&gt;Pod :: Parser&lt;/b&gt; 가 인식하는 몇 가지 경고와 오류에 대해 진단을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f96de2f4de546b0b105bd31abd1df6be57d08d9b" translate="yes" xml:space="preserve">
          <source>Normally (by default) &lt;b&gt;Pod::Parser&lt;/b&gt; will only provide access to the POD sections of the input. Input paragraphs that are not part of the POD-format documentation are not made available to the caller (not even using &lt;b&gt;preprocess_paragraph()&lt;/b&gt;). Setting this option to a non-empty, non-zero value will allow &lt;b&gt;preprocess_paragraph()&lt;/b&gt; to see non-POD sections of the input as well as POD sections. The &lt;b&gt;cutting()&lt;/b&gt; method can be used to determine if the corresponding paragraph is a POD paragraph, or some other input paragraph.</source>
          <target state="translated">일반적으로 (기본적으로) &lt;b&gt;Pod :: Parser&lt;/b&gt; 는 입력의 POD 섹션에만 액세스 할 수 있습니다. POD 형식 문서에 포함되지 않은 입력 단락은 호출자가 사용할 수 없습니다 &lt;b&gt;(preprocess_paragraph ()&lt;/b&gt; 사용하지 않음 ). 이 옵션을 0이 아닌 비어 있지 않은 값으로 설정하면 &lt;b&gt;preprocess_paragraph ()&lt;/b&gt; 가 입력의 비 POD 섹션과 POD 섹션을 볼 수 있습니다. &lt;b&gt;절단 ()&lt;/b&gt; 메소드는 해당 단락이 POD 단락, 또는 다른 입력 단락 여부를 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="8aa7d9bed6b6de90e46aa497f1bf0c42b0003cae" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;context()&lt;/code&gt; looks at the global hub stack. If you are maintaining your own &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance you may pass it in to be used instead of the global one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37837c6debd1017a96cd617b60da42b547584ec0" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;cx_pushblock&lt;/code&gt; should be immediately followed by the appropriate &lt;code&gt;cx_pushfoo&lt;/code&gt;, with nothing between them; this is because if code in-between could die (e.g. a warning upgraded to fatal), then the context stack unwinding code in &lt;code&gt;dounwind&lt;/code&gt; would see (in the example above) a &lt;code&gt;CXt_SUB&lt;/code&gt; context frame, but without all the subroutine-specific fields set, and crashes would soon ensue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c59a8b8d40b03f188d8c8dc54d2e1ea05d392c2" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;intercept { ... }&lt;/code&gt; only intercepts events sent to the main hub (as added by intercept itself). Nested hubs, such as those created by subtests, will not be intercepted. This is normally what you will still see the nested events by inspecting the subtest event. However there are times where you want to verify each event as it is sent, in that case use &lt;code&gt;intercept_deep { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6752118c5629900bd2493b9fc622cf5fe1da59a3" translate="yes" xml:space="preserve">
          <source>Normally =head1 will become &amp;lt;h1&amp;gt;, =head2 will become &amp;lt;h2&amp;gt; etc. Using the html_h_level method will change these levels setting the h level of =head1 tags:</source>
          <target state="translated">일반적으로 = head1은 &amp;lt;h1&amp;gt;이되고 = head2는 &amp;lt;h2&amp;gt;가됩니다. html_h_level 메소드를 사용하면 이러한 레벨이 = head1 태그의 h 레벨을 설정하여 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="eb704595ff03db8550411015b5fd6f6b6a0da573" translate="yes" xml:space="preserve">
          <source>Normally CPAN.pm keeps config variables in memory and changes need to be saved in a separate 'o conf commit' command to make them permanent between sessions. If you set the 'auto_commit' option to true, changes to a config variable are always automatically committed to disk.</source>
          <target state="translated">일반적으로 CPAN.pm은 구성 변수를 메모리에 유지하며 변경 사항은 세션간에 영구적으로 유지되도록 별도의 'o conf commit'명령에 저장해야합니다. 'auto_commit'옵션을 true로 설정하면 구성 변수의 변경 사항은 항상 자동으로 디스크에 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="ffed2ba849f40bdabd5438b067027bdbe4e7e420" translate="yes" xml:space="preserve">
          <source>Normally File::Basename will assume a file path type native to your current operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...). With this function you can override that assumption.</source>
          <target state="translated">일반적으로 File :: Basename은 현재 운영 체제에 고유 한 파일 경로 유형을 가정합니다 (예 : Unix의 경우 / foo / bar 스타일, Windows의 경우 \ foo \ bar 등). 이 기능을 사용하면 해당 가정을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e8c2709805a9ae37b1070139ac3e090e7ff1f7" translate="yes" xml:space="preserve">
          <source>Normally SPACE and TAB characters have no special meaning inside a bracketed character class; they are just added to the list of characters matched by the class. But if the &lt;a href=&quot;perlre#%2Fx-and-%2Fxx&quot;&gt;&lt;code&gt;/xx&lt;/code&gt;&lt;/a&gt; pattern modifier is in effect, they are generally ignored and can be added to improve readability. They can't be added in the middle of a single construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc57384763197fbed7cd5d27f4bd79109621c483" translate="yes" xml:space="preserve">
          <source>Normally a skip-all plan event will cause a subtest to stop executing. This is accomplished via &lt;code&gt;last LABEL&lt;/code&gt; to a label inside the subtest code. Most of the time this is perfectly fine. There are times however where this flow control causes bad things to happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c08039a5c74ee4bad6cfd5f4c148fa8b9bc350" translate="yes" xml:space="preserve">
          <source>Normally all events inside and outside a subtest are sent to the formatter immediately by the hub. Sometimes it is desirable to hold off sending events within a subtest until the subtest is complete. This usually depends on the formatter being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6487841dbf7b431d256b64c2c684343b1b3e420" translate="yes" xml:space="preserve">
          <source>Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'), inet_aton('localhost') and inet_aton('255.255.255.255') respectively.</source>
          <target state="translated">일반적으로 inet_aton ( '0.0.0.0'), inet_aton ( '255.255.255.255'), inet_aton ( 'localhost') 및 inet_aton ( '255.255.255.255')에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="655db30b7d1bcb685e05fd4286f5335ffc8fceaf" translate="yes" xml:space="preserve">
          <source>Normally equivalent to inet_pton(AF_INET6, &quot;::&quot;) and inet_pton(AF_INET6, &quot;::1&quot;) respectively.</source>
          <target state="translated">일반적으로 inet_pton (AF_INET6, &quot;::&quot;) 및 inet_pton (AF_INET6, &quot;:: 1&quot;)과 각각 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7299c892c667dfb149d16517a44252ec066ea3a" translate="yes" xml:space="preserve">
          <source>Normally it is an error to attempt to run the same test twice. Aliases allow you to overcome this limitation by giving each run of the test a unique name.</source>
          <target state="translated">일반적으로 동일한 테스트를 두 번 실행하는 것은 오류입니다. 별명을 사용하면 각 테스트 실행에 고유 한 이름을 부여하여이 제한을 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c2859baa8c819a82e3a926f82e2ef06ec17886" translate="yes" xml:space="preserve">
          <source>Normally it is not necessarily to do this directly, because it suffices to use the implicit discarding behaviour of &lt;a href=&quot;#lex_next_chunk&quot;&gt;&quot;lex_next_chunk&quot;&lt;/a&gt; and things based on it. However, if a token stretches across multiple lines, and the lexing code has kept multiple lines of text in the buffer for that purpose, then after completion of the token it would be wise to explicitly discard the now-unneeded earlier lines, to avoid future multi-line tokens growing the buffer without bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b5278ad328e1d6dfb18e8dbc85851ab51d1e67" translate="yes" xml:space="preserve">
          <source>Normally it is not necessarily to do this directly, because it suffices to use the implicit discarding behaviour of &lt;a href=&quot;#lex_next_chunk&quot;&gt;lex_next_chunk&lt;/a&gt; and things based on it. However, if a token stretches across multiple lines, and the lexing code has kept multiple lines of text in the buffer for that purpose, then after completion of the token it would be wise to explicitly discard the now-unneeded earlier lines, to avoid future multi-line tokens growing the buffer without bound.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#lex_next_chunk&quot;&gt;lex_next_chunk&lt;/a&gt; 의 암시 적 삭제 동작과 그에 기반한 것들을 사용하기에 충분하기 때문에 반드시 직접 수행 할 필요는 없습니다 . 그러나 토큰이 여러 줄로 확장되고 어휘 코드가 해당 목적을 위해 버퍼에 여러 줄의 텍스트를 유지 한 경우 토큰이 완료된 후 미래를 피하기 위해 필요하지 않은 이전 줄을 명시 적으로 삭제하는 것이 좋습니다 바인딩없이 버퍼를 확장하는 여러 줄 토큰.</target>
        </trans-unit>
        <trans-unit id="dff81aba4927ad5db88d6aff8ddca6455f943273" translate="yes" xml:space="preserve">
          <source>Normally just returns an empty string.</source>
          <target state="translated">일반적으로 빈 문자열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee18c26e2f372d4c2e20c5f444a8a1eaa88e5a18" translate="yes" xml:space="preserve">
          <source>Normally listeners are not inherited by child hubs such as subtests. You can add the &lt;code&gt;inherit =&amp;gt; 1&lt;/code&gt; parameter to allow a listener to be inherited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7f43d14a04bad12a69a842e7552ac7eca4d422" translate="yes" xml:space="preserve">
          <source>Normally on unthreaded builds, the traditional &lt;code&gt;setlocale()&lt;/code&gt; is used and not the thread-safe locale functions. You can force the use of these on systems that have them by adding the &lt;code&gt;-Accflags='-DUSE_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e69d6153e5ec624b88e17bbddf91a6ba5ccd198" translate="yes" xml:space="preserve">
          <source>Normally one can install</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb00d3e7f7eb8b5f62db8fa28fecb9cae0387cd9" translate="yes" xml:space="preserve">
          <source>Normally the SV will be cleared before the escaped string is prepared, but when &lt;code&gt;PERL_PV_ESCAPE_NOCLEAR&lt;/code&gt; is set this will not occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97bb2716ea7192ed8237324e0bfeb22c949fe5dd" translate="yes" xml:space="preserve">
          <source>Normally the SV will be cleared before the escaped string is prepared, but when PERL_PV_ESCAPE_NOCLEAR is set this will not occur.</source>
          <target state="translated">일반적으로 SV는 이스케이프 된 문자열이 준비되기 전에 지워지지 만 PERL_PV_ESCAPE_NOCLEAR이 설정되면 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2167ce6cabaacc20aab8af72ad8f0a559278228a" translate="yes" xml:space="preserve">
          <source>Normally the subtest hub is pushed and the sub is allowed to generate its own root context for the hub. When this setting is turned on a root context will be created for the hub that shares the same trace as the current context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e27e79537ab43ff1cac36249dfeaf81b443e2f" translate="yes" xml:space="preserve">
          <source>Normally the values returned by &lt;code&gt;message()&lt;/code&gt; and &lt;code&gt;code()&lt;/code&gt; are obtained from the remote server, but in a few circumstances, as detailed below, &lt;code&gt;Net::Cmd&lt;/code&gt; will return values that it sets. You can alter this behavior by overriding DEF_REPLY_CODE() to specify a different default reply code, or overriding one of the specific error handling methods below.</source>
          <target state="translated">일반적으로 &lt;code&gt;message()&lt;/code&gt; 및 &lt;code&gt;code()&lt;/code&gt; 의해 반환 된 값 은 원격 서버에서 가져 오지만 아래에 설명 된대로 일부 환경에서는 &lt;code&gt;Net::Cmd&lt;/code&gt; 가 설정 한 값을 반환합니다. DEF_REPLY_CODE ()를 재정 의하여 다른 기본 응답 코드를 지정하거나 아래의 특정 오류 처리 방법 중 하나를 재정 의하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c29faef0eb7b590f52263e442441419daf42a3" translate="yes" xml:space="preserve">
          <source>Normally when a Perl program is run in taint mode the contents of the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable do not appear in &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">일반적으로 Perl 프로그램이 오염 모드에서 실행될 때 &lt;code&gt;PERL5LIB&lt;/code&gt; 환경 변수 의 내용은 &lt;code&gt;@INC&lt;/code&gt; 에 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="506d1f5f54dfc2b579811707472650864a3a3064" translate="yes" xml:space="preserve">
          <source>Normally when a Perl program is run in taint mode the contents of the &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable do not appear in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a7a995939729b0dabf635451424cb7aa8edddc" translate="yes" xml:space="preserve">
          <source>Normally when a quantified subpattern does not allow the rest of the overall pattern to match, Perl will backtrack. However, this behaviour is sometimes undesirable. Thus Perl provides the &quot;possessive&quot; quantifier form as well.</source>
          <target state="translated">일반적으로 정량화 된 하위 패턴으로 나머지 전체 패턴이 일치하지 않으면 Perl이 역 추적합니다. 그러나이 동작은 때때로 바람직하지 않습니다. 따라서 Perl은 &quot;possessive&quot;정량 자 양식도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c8104915beebb2ef8d901739c62a7755b75d714f" translate="yes" xml:space="preserve">
          <source>Normally you can just pass a list of Perl tests and the harness will know how to execute them. However, if your tests are not written in Perl or if you want all tests invoked exactly the same way, use the &lt;code&gt;-e&lt;/code&gt; , or &lt;code&gt;--&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; switch:</source>
          <target state="translated">일반적으로 Perl 테스트 목록을 전달하면 하네스가이를 실행하는 방법을 알게됩니다. 당신의 검사 결과가 Perl로 작성하거나 원하는 경우 모든 테스트가 정확히 같은 방식으로 호출하지 않는 경우, 사용 &lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 스위치 :</target>
        </trans-unit>
        <trans-unit id="37c9dbf2473eab18c207bdcb93ed8d71c95d2719" translate="yes" xml:space="preserve">
          <source>Normally you can just pass a list of Perl tests and the harness will know how to execute them. However, if your tests are not written in Perl or if you want all tests invoked exactly the same way, use the &lt;code&gt;-e&lt;/code&gt;, or &lt;code&gt;--exec&lt;/code&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e0d0fdb3d7e700b9e570e982fb103b1928fe84" translate="yes" xml:space="preserve">
          <source>Normally you don't need to know about the &lt;code&gt;dir_prefix&lt;/code&gt; option, but I include it in case it might prove useful for someone somewhere.</source>
          <target state="translated">일반적으로 &lt;code&gt;dir_prefix&lt;/code&gt; 옵션 에 대해 알 필요는 없지만 다른 사람에게 유용 할 수있는 경우를 대비하여 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="3126672cdab51b1480bf681d3edd48007efd3666" translate="yes" xml:space="preserve">
          <source>Normally you don't need to know about the &lt;code&gt;progress&lt;/code&gt; option, but I include it in case it might prove useful for someone somewhere.</source>
          <target state="translated">일반적으로 &lt;code&gt;progress&lt;/code&gt; 옵션 에 대해 알 필요는 없지만 다른 사람에게 유용 할 수있는 경우에 대비하여 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1572aaee7e8d3c88cefd57a173a8439b4c3cbe72" translate="yes" xml:space="preserve">
          <source>Normally you only need to edit</source>
          <target state="translated">일반적으로 편집 만하면됩니다</target>
        </trans-unit>
        <trans-unit id="c187e13441ab45730dcb9496c0aa29fc4a5d1bb8" translate="yes" xml:space="preserve">
          <source>Normally you would use a sequence of fields in a vertical stack associated with the same scalar variable to print out a block of text. You might wish to end the final field with the text &quot;...&quot;, which will appear in the output if the text was too long to appear in its entirety.</source>
          <target state="translated">일반적으로 동일한 스칼라 변수와 연관된 수직 스택에서 일련의 필드를 사용하여 텍스트 블록을 인쇄합니다. 텍스트 &quot;...&quot;로 최종 필드를 끝내고 싶을 수 있습니다. 텍스트가 너무 길어서 전체가 표시되지 않을 경우 출력에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5b98aa4ab9dd3cba97d78a9f5f31385d116bda6f" translate="yes" xml:space="preserve">
          <source>Normally, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; takes the next unused argument as the value to format for each format specification. If the format specification uses &lt;code&gt;*&lt;/code&gt; to require additional arguments, these are consumed from the argument list in the order they appear in the format specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7e48b2a8e18321d834351ce5ec861595531f41" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;Memoize&lt;/code&gt; caches your function's return values into an ordinary Perl hash variable. However, you might like to have the values cached on the disk, so that they persist from one run of your program to the next, or you might like to associate some other interesting semantics with the cached values.</source>
          <target state="translated">일반적으로 &lt;code&gt;Memoize&lt;/code&gt; 는 함수의 반환 값을 일반 Perl 해시 변수에 캐시합니다. 그러나 값을 디스크에 캐시하여 프로그램의 한 실행에서 다음 실행까지 지속 시키거나 다른 흥미로운 의미를 캐시 된 값과 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="156e8ed9e5335713b0637af915d308c508bc5496" translate="yes" xml:space="preserve">
          <source>Normally, B::Deparse deparses the main code of a program, and all the subs defined in the same file. To include subs defined in other files, pass the &lt;b&gt;-f&lt;/b&gt; option with the filename. You can pass the &lt;b&gt;-f&lt;/b&gt; option several times, to include more than one secondary file. (Most of the time you don't want to use it at all.) You can also use this option to include subs which are defined in the scope of a &lt;b&gt;#line&lt;/b&gt; directive with two parameters.</source>
          <target state="translated">일반적으로 B :: Deparse는 프로그램의 기본 코드와 동일한 파일에 정의 된 모든 하위 코드를 분리합니다. 다른 파일에 정의 된 서브를 포함 시키려면 파일 이름과 함께 &lt;b&gt;-f&lt;/b&gt; 옵션을 전달하십시오 . &lt;b&gt;-f&lt;/b&gt; 옵션을 여러 번 전달하여 둘 이상의 보조 파일을 포함시킬 수 있습니다. (대부분 사용하지 않으려는 경우도 있습니다.) 또한이 옵션을 사용 하여 두 개의 매개 변수 로 &lt;b&gt;#line&lt;/b&gt; 지시문 의 범위에 정의 된 하위를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d23245f6b2deb15ea54d8fbc52298acca654091b" translate="yes" xml:space="preserve">
          <source>Normally, CPAN.pm continues processing the full list of targets and dependencies, even if one of them fails. However, you can specify that CPAN should halt after the first failure. (Note that optional recommended or suggested modules that fail will not cause a halt.)</source>
          <target state="translated">일반적으로 CPAN.pm은 대상 및 종속성 중 하나가 실패하더라도 전체 목록과 대상을 계속 처리합니다. 그러나 첫 번째 실패 후 CPAN이 중지되도록 지정할 수 있습니다. (선택 사양 인 권장 또는 제안 된 모듈이 실패해도 중단되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="3d5ac60a26c28e14f1c99420243a6e5d21eaa6ab" translate="yes" xml:space="preserve">
          <source>Normally, L&amp;lt;&amp;gt; formatting codes with a URL but anchor text are formatted to show both the anchor text and the URL. In other words:</source>
          <target state="translated">일반적으로 URL이 있지만 앵커 텍스트가있는 L &amp;lt;&amp;gt; 형식 코드는 앵커 텍스트와 URL을 모두 표시하도록 형식이 지정됩니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="28696b8342bf721c125649c0d32db8869e990e70" translate="yes" xml:space="preserve">
          <source>Normally, Storable stores elements of hashes in the order they are stored internally by Perl, i.e. pseudo-randomly. If you set &lt;code&gt;$Storable::canonical&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value, Storable will store hashes with the elements sorted by their key. This allows you to compare data structures by comparing their frozen representations (or even the compressed frozen representations), which can be useful for creating lookup tables for complicated queries.</source>
          <target state="translated">일반적으로, Storable은 Perl에 의해 내부적으로 저장된 순서대로, 즉 의사 랜덤으로 해시 요소를 저장합니다. 를 설정하면 &lt;code&gt;$Storable::canonical&lt;/code&gt; 일부 &lt;code&gt;TRUE&lt;/code&gt; 값 요소가 핵심으로 분류하여, 보관 가능한이 해시를 저장합니다. 이를 통해 고정 된 표현 (또는 압축 된 고정 된 표현)을 비교하여 데이터 구조를 비교할 수 있습니다. 이는 복잡한 쿼리에 대한 조회 테이블을 만드는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf4331af4df94d60c4a0096eabf2c84288a8ec7" translate="yes" xml:space="preserve">
          <source>Normally, Test::Builder does some extra diagnostics when the test ends. It also changes the exit code as described below.</source>
          <target state="translated">일반적으로 Test :: Builder는 테스트가 끝나면 추가 진단을 수행합니다. 또한 아래 설명 된대로 종료 코드를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ce50c77261a5de00b7baaa95374b0bdfea3eac1d" translate="yes" xml:space="preserve">
          <source>Normally, a bareword doesn't need to be quoted, but in most cases probably should be (and must be under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ). But a hash key consisting of a simple word and the left-hand operand to the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator both count as though they were quoted:</source>
          <target state="translated">일반적으로, bareword는 인용 할 필요는 없지만 대부분의 경우 아마해야한다 (그리고 아래에 있어야합니다 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; ). 그러나 간단한 단어와 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자 의 왼쪽 피연산자로 구성된 해시 키는 모두 인용 된 것처럼 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ea17e68a421c03c4aafdafcd58cccf49cfa05f01" translate="yes" xml:space="preserve">
          <source>Normally, a bareword doesn't need to be quoted, but in most cases probably should be (and must be under &lt;code&gt;use strict&lt;/code&gt;). But a hash key consisting of a simple word and the left-hand operand to the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator both count as though they were quoted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5564f90094b9860ce4353ac60db255b073b15ab0" translate="yes" xml:space="preserve">
          <source>Normally, a lone dash &lt;code&gt;-&lt;/code&gt; on the command line will not be considered an option. Option processing will terminate (unless &quot;permute&quot; is configured) and the dash will be left in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">일반적으로, 고독한 대시 &lt;code&gt;-&lt;/code&gt; 명령 행에서이 옵션으로 간주되지 않습니다. 옵션 처리가 종료되고 ( &quot;permute&quot;가 구성되지 않은 경우) 대시는 &lt;code&gt;@ARGV&lt;/code&gt; 에 남아 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b48224b69ad031af88a5007831895e71150e793d" translate="yes" xml:space="preserve">
          <source>Normally, a lone dash &lt;code&gt;-&lt;/code&gt; on the command line will not be considered an option. Option processing will terminate (unless &quot;permute&quot; is configured) and the dash will be left in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad334551e4ade1c324bd799dc0f65766153d86ca" translate="yes" xml:space="preserve">
          <source>Normally, a test module (let's call it Test:MyStyle) calls Test::Builder-&amp;gt;new to get the Test::Builder object. Test::MyStyle calls methods on this object to record information about test results. When Test::Tester is loaded, it replaces Test::Builder's new() method with one which returns a Test::Tester::Delegate object. Most of the time this object behaves as the real Test::Builder object. Any methods that are called are delegated to the real Test::Builder object so everything works perfectly. However once we go into test mode, the method calls are no longer passed to the real Test::Builder object, instead they go to the Test::Tester::Capture object. This object seems exactly like the real Test::Builder object, except, instead of outputting test results and diagnostics, it just records all the information for later analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654422bdd7e927225f8155b32c99633ae1593b5f" translate="yes" xml:space="preserve">
          <source>Normally, accessing a hash key's value for a nonexistent key will</source>
          <target state="translated">일반적으로 존재하지 않는 키의 해시 키 값에 액세스하면</target>
        </trans-unit>
        <trans-unit id="8652ae91a77d4cb6b6ff7525f46e31e0b15fc723" translate="yes" xml:space="preserve">
          <source>Normally, array elements have the record separator removed, so that if the file contains the text</source>
          <target state="translated">일반적으로 배열 요소에는 레코드 구분 기호가 제거되어 파일에 텍스트가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="534654aa79245de47a873277e56a6292c36afdc7" translate="yes" xml:space="preserve">
          <source>Normally, colored() just puts attribute codes at the beginning and end of the string, but if you set $Term::ANSIColor::EACHLINE to some string, that string will be considered the line delimiter and the attribute will be set at the beginning of each line of the passed string and reset at the end of each line. This is often desirable if the output contains newlines and you're using background colors, since a background color that persists across a newline is often interpreted by the terminal as providing the default background color for the next line. Programs like pagers can also be confused by attributes that span lines. Normally you'll want to set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; to use this feature.</source>
          <target state="translated">일반적으로 colored ()는 문자열의 시작과 끝에 속성 코드를 넣지 만 $ Term :: ANSIColor :: EACHLINE을 일부 문자열로 설정하면 해당 문자열은 줄 구분 기호로 간주되고 속성은 전달 된 문자열의 각 줄 시작 및 각 줄 끝에서 재설정합니다. 출력에 줄 바꿈이 포함되어 있고 배경색을 사용하는 경우 종종 바람직합니다. 줄 바꿈을 통해 지속되는 배경색은 종종 터미널에서 다음 줄의 기본 배경색을 제공하는 것으로 해석되기 때문입니다. 호출기와 같은 프로그램은 여러 줄에 걸쳐있는 속성으로 인해 혼동 될 수도 있습니다. 일반적 으로이 기능을 사용하려면 $ Term :: ANSIColor :: EACHLINE을 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="47497939420b5b367cb1b2b4d46709150e929869" translate="yes" xml:space="preserve">
          <source>Normally, it uses the &lt;code&gt;failure_output()&lt;/code&gt; handle, but if this is for a TODO test, the &lt;code&gt;todo_output()&lt;/code&gt; handle is used.</source>
          <target state="translated">일반적으로 &lt;code&gt;failure_output()&lt;/code&gt; 핸들을 사용하지만 이것이 TODO 테스트 인 경우 &lt;code&gt;todo_output()&lt;/code&gt; 핸들이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="843f99e9f61b3167a92df62277ad684239edbee8" translate="yes" xml:space="preserve">
          <source>Normally, modifying a &lt;code&gt;Tie::File&lt;/code&gt; array writes to the underlying file immediately. Every assignment like &lt;code&gt;$a[3] = ...&lt;/code&gt; rewrites as much of the file as is necessary; typically, everything from line 3 through the end will need to be rewritten. This is the simplest and most transparent behavior. Performance even for large files is reasonably good.</source>
          <target state="translated">일반적으로 &lt;code&gt;Tie::File&lt;/code&gt; 배열을 수정 하면 기본 파일에 즉시 씁니다. &lt;code&gt;$a[3] = ...&lt;/code&gt; 와 같은 모든 할당 은 필요한만큼 파일을 다시 씁니다. 일반적으로 3 행부터 끝까지 모든 내용을 다시 작성해야합니다. 가장 단순하고 투명한 동작입니다. 큰 파일의 성능도 상당히 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e86bc5c5468300153e887bb030f8c8fafa55a91" translate="yes" xml:space="preserve">
          <source>Normally, parsing an S&amp;lt;...&amp;gt; sequence produces this event structure, just as if it were a B/C/F/I code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd66bc88fd481df4ac201aa91bfec31499d4ed47" translate="yes" xml:space="preserve">
          <source>Normally, parsing an X&amp;lt;...&amp;gt; sequence produces this event structure, just as if it were a B/C/F/I code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf97b0167156ea895f7910e3f3f52f1229f7b5f7" translate="yes" xml:space="preserve">
          <source>Normally, regexps are a part of Perl expressions.</source>
          <target state="translated">일반적으로 정규 표현식은 Perl 표현식의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="808fe9fa0be0d04a656a7ac7cd5c2d9d3734bad0" translate="yes" xml:space="preserve">
          <source>Normally, sprintf() takes the next unused argument as the value to format for each format specification. If the format specification uses &lt;code&gt;*&lt;/code&gt; to require additional arguments, these are consumed from the argument list in the order they appear in the format specification</source>
          <target state="translated">일반적으로 sprintf ()는 사용되지 않은 다음 인수를 각 형식 스펙에 대해 형식화 할 값으로 사용합니다. 형식 스펙에서 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 추가 인수가 필요한 경우 인수 스펙에서 형식 스펙에 나타나는 순서대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2826cc3c3bfda4c3b98bd6c44f0b50d829979efc" translate="yes" xml:space="preserve">
          <source>Normally, the following code will result in two calls to &lt;code&gt;complicated&lt;/code&gt; , even if &lt;code&gt;complicated&lt;/code&gt; is memoized:</source>
          <target state="translated">에 일반적으로, 다음 코드는 두 개의 통화가 발생합니다 &lt;code&gt;complicated&lt;/code&gt; 하더라도, &lt;code&gt;complicated&lt;/code&gt; memoized한다 :</target>
        </trans-unit>
        <trans-unit id="9a867eaf437cac7adb8353be42bd91789230ad0d" translate="yes" xml:space="preserve">
          <source>Normally, the following code will result in two calls to &lt;code&gt;complicated&lt;/code&gt;, even if &lt;code&gt;complicated&lt;/code&gt; is memoized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7283cc850a65d4273ec3f9787a8b552a33654732" translate="yes" xml:space="preserve">
          <source>Normally, the parse-tree returned by &lt;b&gt;parse_text()&lt;/b&gt; will contain a text-string for each contiguous sequence of characters outside of an interior-sequence. Specifying &lt;b&gt;-expand_text&lt;/b&gt; tells &lt;b&gt;parse_text()&lt;/b&gt; to &quot;preprocess&quot; every such text-string it sees by invoking the referenced function (or named method of the parser object) and using the return value as the preprocessed (or &quot;expanded&quot;) result. [Note that if the result is an interior-sequence, then it will</source>
          <target state="translated">일반적으로 &lt;b&gt;parse_text ()에&lt;/b&gt; 의해 반환 된 구문 분석 트리는 내부 시퀀스 외부의 각 연속 문자 시퀀스에 대한 텍스트 문자열을 포함합니다. &lt;b&gt;-expand_text를&lt;/b&gt; 지정 하면 참조 된 함수 (또는 구문 분석기 오브젝트의 이름 지정된 메소드)를 호출하고 리턴 값을 사전 처리 된 (또는 &quot;확장 된&quot;) 결과로 사용하여 표시되는 모든 텍스트 문자열을 &quot;전처리&quot;하도록 &lt;b&gt;parse_text ()&lt;/b&gt; 에 지시 합니다. [결과가 내부 순서이면 결과는</target>
        </trans-unit>
        <trans-unit id="4c74045d12862bbf5896977df13a2e8f10f61ef7" translate="yes" xml:space="preserve">
          <source>Normally, the parse-tree returned by &lt;b&gt;parse_text()&lt;/b&gt; will contain an unexpanded &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object for each interior-sequence encountered. Specifying &lt;b&gt;-expand_seq&lt;/b&gt; tells &lt;b&gt;parse_text()&lt;/b&gt; to &quot;expand&quot; every interior-sequence it sees by invoking the referenced function (or named method of the parser object) and using the return value as the expanded result.</source>
          <target state="translated">일반적으로 &lt;b&gt;parse_text ()에&lt;/b&gt; 의해 반환 된 구문 분석 트리 에는 발생한 각 내부 시퀀스에 대해 확장되지 않은 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 개체 가 포함 됩니다. &lt;b&gt;-expand_seq를&lt;/b&gt; 지정 하면 참조 된 함수 (또는 구문 분석기 오브젝트의 이름 지정된 메소드)를 호출하고 리턴 값을 확장 된 결과로 사용하여 표시되는 모든 내부 순서를 &lt;b&gt;parse_text ()&lt;/b&gt; 에 &quot;확장&quot;하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="16267da81502b322cffa728aa842c57f0b24ab0c" translate="yes" xml:space="preserve">
          <source>Normally, the resulting message is returned in a new mortal SV. During global destruction a single SV may be shared between uses of this function.</source>
          <target state="translated">일반적으로 결과 메시지는 새로운 필사자 SV로 반환됩니다. 전역 파괴 동안이 기능의 사용간에 단일 SV가 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ae485979ade17656e2e8127cce3420dca94e97" translate="yes" xml:space="preserve">
          <source>Normally, the resulting message is returned in a new mortal SV. During global destruction a single SV may be shared between uses of this function. If &lt;code&gt;consume&lt;/code&gt; is true, then the function is permitted (but not required) to modify and return &lt;code&gt;basemsg&lt;/code&gt; instead of allocating a new SV.</source>
          <target state="translated">일반적으로 결과 메시지는 새로운 필사자 SV로 반환됩니다. 전역 파괴 동안이 기능의 사용간에 단일 SV가 공유 될 수 있습니다. 경우 &lt;code&gt;consume&lt;/code&gt; 사실, 다음 함수는 수정 및 반환하도록 허용 (필수 사항은 아님)입니다 &lt;code&gt;basemsg&lt;/code&gt; 새로운 SV를 할당하는 대신.</target>
        </trans-unit>
        <trans-unit id="3699203fc3e3f9cdc9d573bca3286eccade605ca" translate="yes" xml:space="preserve">
          <source>Normally, the specified file will be opened for read and write access, and will be created if it does not exist. (That is, the flags &lt;code&gt;O_RDWR | O_CREAT&lt;/code&gt; are supplied in the &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call.) If you want to change this, you may supply alternative flags in the &lt;code&gt;mode&lt;/code&gt; option. See &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; for a listing of available flags. For example:</source>
          <target state="translated">일반적으로 지정된 파일은 읽기 및 쓰기 액세스를 위해 열리 며 존재하지 않는 경우 만들어집니다. 즉, &lt;code&gt;O_RDWR | O_CREAT&lt;/code&gt; 플래그 는 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 호출 에서 제공됩니다 .이를 변경하려면 &lt;code&gt;mode&lt;/code&gt; 옵션 에서 대체 플래그를 제공 할 수 있습니다. 사용 가능한 플래그 목록은 &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; 을 참조하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dfc63d426417838163eb863c3ff6f7e477ca3ff" translate="yes" xml:space="preserve">
          <source>Normally, the specified file will be opened for read and write access, and will be created if it does not exist. (That is, the flags &lt;code&gt;O_RDWR | O_CREAT&lt;/code&gt; are supplied in the &lt;code&gt;open&lt;/code&gt; call.) If you want to change this, you may supply alternative flags in the &lt;code&gt;mode&lt;/code&gt; option. See &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; for a listing of available flags. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f12084738c458e8b7000b7b9525558b4cfff47" translate="yes" xml:space="preserve">
          <source>Normally, writing out Unicode data</source>
          <target state="translated">일반적으로 유니 코드 데이터 작성</target>
        </trans-unit>
        <trans-unit id="247ce5d5d9158a1021672cfbc50ce69d843f7d14" translate="yes" xml:space="preserve">
          <source>North America</source>
          <target state="translated">북아메리카</target>
        </trans-unit>
        <trans-unit id="8ddbb9fd49d254aced9f96e6d5b82c3634fdf5d4" translate="yes" xml:space="preserve">
          <source>North Carolina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f11696f957b30cc16d9d6d3c2b53faa2bfa905a" translate="yes" xml:space="preserve">
          <source>Norton AntiVirus interferes with the build process, particularly if set to &quot;AutoProtect, All Files, when Opened&quot;. Unlike large applications the perl build process opens and modifies a lot of files. Having the AntiVirus scan each and every one slows build the process significantly. Worse, with PERLIO=stdio the build process fails with peculiar messages as the virus checker interacts badly with miniperl.exe writing configure files (it seems to either catch file part written and treat it as suspicious, or virus checker may have it &quot;locked&quot; in a way which inhibits miniperl updating it). The build does complete with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9226334f9ce44ad0f10ee80520f849c5fe4619" translate="yes" xml:space="preserve">
          <source>Norton AntiVirus interferes with the build process, particularly if set to &quot;AutoProtect, All Files, when Opened&quot;. Unlike large applications the perl build process opens and modifies a lot of files. Having the the AntiVirus scan each and every one slows build the process significantly. Worse, with PERLIO=stdio the build process fails with peculiar messages as the virus checker interacts badly with miniperl.exe writing configure files (it seems to either catch file part written and treat it as suspicious, or virus checker may have it &quot;locked&quot; in a way which inhibits miniperl updating it). The build does complete with</source>
          <target state="translated">Norton AntiVirus는 특히 &quot;열 때 모든 파일을 자동 보호&quot;로 설정 한 경우 빌드 프로세스를 방해합니다. 큰 응용 프로그램과 달리 perl 빌드 프로세스는 많은 파일을 열고 수정합니다. 안티 바이러스가 각각 검사 할 때마다 프로세스 속도가 크게 느려집니다. 더 나쁜 것은 PERLIO = stdio를 사용하면 바이러스 검사기가 구성 파일을 작성하는 miniperl.exe와 잘못 상호 작용하기 때문에 특이한 메시지로 빌드 프로세스가 실패합니다 (파일 부분을 작성하여 의심스러운 것으로 간주하거나 바이러스 검사기가 &quot;잠금&quot;상태 일 수 있음 miniperl 업데이트를 방해하는 방식으로). 빌드가 완료됩니다</target>
        </trans-unit>
        <trans-unit id="a416dbee324bb6347c195257a3461c9b547b428f" translate="yes" xml:space="preserve">
          <source>Norton T. Allen (allen@huarp.harvard.edu)</source>
          <target state="translated">Norton T. Allen (allen@huarp.harvard.edu)</target>
        </trans-unit>
        <trans-unit id="988455e67df7cd81d090ea4bacdc05f39fb7caa5" translate="yes" xml:space="preserve">
          <source>Norway</source>
          <target state="translated">Norway</target>
        </trans-unit>
        <trans-unit id="370767717b5bd720890c41261b1cdb6e02957025" translate="yes" xml:space="preserve">
          <source>Not Using AutoLoader</source>
          <target state="translated">오토로더를 사용하지 않음</target>
        </trans-unit>
        <trans-unit id="d37413af1038bf58c07742880e5a67dc70caa079" translate="yes" xml:space="preserve">
          <source>Not a CODE reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c01cc85dad0515e1920b0555382cfcb4e45014" translate="yes" xml:space="preserve">
          <source>Not a GLOB reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f3e6278403bcdf59b8152fac69e48864a5ba52" translate="yes" xml:space="preserve">
          <source>Not a HASH reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd98b3c6e90fca04f1dbcfd4de1cbca0a44a1f2" translate="yes" xml:space="preserve">
          <source>Not a SCALAR reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7c30886465e53cc15fb2f369c9a20de63a93cc" translate="yes" xml:space="preserve">
          <source>Not a number. The value Perl uses for certain invalid or inexpressible floating-point operations.</source>
          <target state="translated">숫자가 아닙니다. Perl 값은 유효하지 않거나 표현할 수없는 특정 부동 소수점 연산에 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9ce5f175f6ed52d752c1dc214624e2c550cee7d4" translate="yes" xml:space="preserve">
          <source>Not a stellar system with three stars, but an &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;ternary&lt;/b&gt;.</source>
          <target state="translated">별 3 개가있는 별 시스템은 아니지만 &lt;b&gt;연산자&lt;/b&gt; 3 개 &lt;b&gt;피연산자를 사용&lt;/b&gt; 합니다. 때로는 &lt;b&gt;삼원&lt;/b&gt; 발음 .</target>
        </trans-unit>
        <trans-unit id="c1b90e8290c5116a077f903a7e7316582eca91d7" translate="yes" xml:space="preserve">
          <source>Not a subroutine reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e81509b0f5a61c879c22f1e777758722a08a1c" translate="yes" xml:space="preserve">
          <source>Not a subroutine reference in overload table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34a61da084e0aa67824715ad65e41d6be635c1c" translate="yes" xml:space="preserve">
          <source>Not a tag for normal use.</source>
          <target state="translated">정상적인 사용을위한 태그가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6628bb792927eb17f7227a3d024523ff7f4ef26a" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;(key,value)&lt;/code&gt; s are allowed to be changed. See also &lt;code&gt;@Unicode::Collate::ChangeOK&lt;/code&gt; and &lt;code&gt;@Unicode::Collate::ChangeNG&lt;/code&gt; .</source>
          <target state="translated">모든 &lt;code&gt;(key,value)&lt;/code&gt; 를 변경할 수있는 것은 아닙니다 . &lt;code&gt;@Unicode::Collate::ChangeOK&lt;/code&gt; 및 &lt;code&gt;@Unicode::Collate::ChangeNG&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3ee77316d6142101f56620aa64696168bd3ffab" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;(key,value)&lt;/code&gt;s are allowed to be changed. See also &lt;code&gt;@Unicode::Collate::ChangeOK&lt;/code&gt; and &lt;code&gt;@Unicode::Collate::ChangeNG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ec939fa988aaea06d8cccbd3dfe26e8b7deec4" translate="yes" xml:space="preserve">
          <source>Not all Perl data types can be cloned (e.g., globs, code refs). By default, &lt;code&gt;shared_clone&lt;/code&gt; will &lt;a href=&quot;../carp&quot;&gt;croak&lt;/a&gt; if it encounters such items. To change this behaviour to a warning, then set the following:</source>
          <target state="translated">모든 Perl 데이터 유형을 복제 할 수있는 것은 아닙니다 (예 : glob, code refs). 기본적으로 &lt;code&gt;shared_clone&lt;/code&gt; 는 것이다 &lt;a href=&quot;../carp&quot;&gt;까악 까악&lt;/a&gt; 이 같은 항목을 발견합니다. 이 동작을 경고로 변경하려면 다음을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8dd49b520d2e25593cfad44814bb285779b091f5" translate="yes" xml:space="preserve">
          <source>Not all Perl data types can be cloned (e.g., globs, code refs). By default, &lt;code&gt;shared_clone&lt;/code&gt; will &lt;a href=&quot;carp&quot;&gt;croak&lt;/a&gt; if it encounters such items. To change this behaviour to a warning, then set the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f9f350740611366ed4fac1a55e30540aa5d5ab" translate="yes" xml:space="preserve">
          <source>Not all Perl programs have to be portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea270638e7bd76128d29c8152d0f28cca0f0cb30" translate="yes" xml:space="preserve">
          <source>Not all architectures (PA = PA-RISC, IPF = Itanium Processor Family) support all versions of HP-UX, here is a short list</source>
          <target state="translated">모든 아키텍처 (PA = PA-RISC, IPF = Itanium 프로세서 제품군)가 모든 버전의 HP-UX를 지원하는 것은 아닙니다. 여기에 간단한 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55e93ff6af987fcc062dba40c7d5f407a9f168d2" translate="yes" xml:space="preserve">
          <source>Not all characters can be used 'as is' in a match. Some characters, called &lt;b&gt;metacharacters&lt;/b&gt;, are considered special, and reserved for use in regex notation. The metacharacters are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c8890c57c81094971e9efbe9c79a62c905fdfd" translate="yes" xml:space="preserve">
          <source>Not all characters can be used 'as is' in a match. Some characters, called &lt;b&gt;metacharacters&lt;/b&gt;, are reserved for use in regex notation. The metacharacters are</source>
          <target state="translated">일치하는 모든 문자를 '있는 그대로'사용할 수있는 것은 아닙니다. &lt;b&gt;metacharacters&lt;/b&gt; 라는 일부 문자 는 정규식 표기법에 사용하도록 예약되어 있습니다. 메타 문자는</target>
        </trans-unit>
        <trans-unit id="3f2603de72efe0894bd7355a4fd5c7ad61e082bc" translate="yes" xml:space="preserve">
          <source>Not all errors are considered fatal, there is a &lt;code&gt;fail&lt;/code&gt; field that must be set for an error to cause the test to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2e7f1c3353c4588a12420d8ec357f219ec897c" translate="yes" xml:space="preserve">
          <source>Not all errors are fatal, some are displayed having already been handled. Set this to true if you want the error to cause the test to fail. Without this the error is simply a diagnostics message that has no effect on the overall pass/fail result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462cf763472459d9998ce2bfa0748c85a78850d0" translate="yes" xml:space="preserve">
          <source>Not all extensions available from CPAN may build or work properly in the Windows environment. See &lt;a href=&quot;#Building-Extensions&quot;&gt;&quot;Building Extensions&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c499fcc39ea462750d346f8328fb611fa8eafb9" translate="yes" xml:space="preserve">
          <source>Not all extensions available from CPAN may build or work properly in the Windows environment. See &lt;a href=&quot;#Building-Extensions&quot;&gt;Building Extensions&lt;/a&gt;.</source>
          <target state="translated">CPAN에서 사용 가능한 모든 확장이 Windows 환경에서 올바르게 빌드되거나 작동하지 않을 수 있습니다. &lt;a href=&quot;#Building-Extensions&quot;&gt;건물 확장&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="e06068c24945da55baa1c3c0c5d1c56745baf201" translate="yes" xml:space="preserve">
          <source>Not all fields are supported on all filesystem types. Here are the meanings of the fields:</source>
          <target state="translated">모든 파일 시스템 유형에서 모든 필드가 지원되는 것은 아닙니다. 필드의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d09a604d6ae3b0ff8d7d0a63321f6b716b05129" translate="yes" xml:space="preserve">
          <source>Not all methods indicated above need be implemented. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;../tie/hash&quot;&gt;Tie::Hash&lt;/a&gt;, &lt;a href=&quot;../tie/array&quot;&gt;Tie::Array&lt;/a&gt;, &lt;a href=&quot;../tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt;, and &lt;a href=&quot;../tie/handle&quot;&gt;Tie::Handle&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 모든 방법을 구현할 필요는 없습니다. 참조 &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; , &lt;a href=&quot;../tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; , &lt;a href=&quot;../tie/array&quot;&gt;타이 :: 배열&lt;/a&gt; , &lt;a href=&quot;../tie/scalar&quot;&gt;타이 :: 스칼라&lt;/a&gt; , 그리고 &lt;a href=&quot;../tie/handle&quot;&gt;타이 :: 핸들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fda0df4f36f3d624368039c7b50bfa7d47ccc5" translate="yes" xml:space="preserve">
          <source>Not all methods indicated above need be implemented. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt;, &lt;a href=&quot;Tie::Array&quot;&gt;Tie::Array&lt;/a&gt;, &lt;a href=&quot;Tie::Scalar&quot;&gt;Tie::Scalar&lt;/a&gt;, and &lt;a href=&quot;Tie::Handle&quot;&gt;Tie::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f9e8c5a0eef6b261c9851c73bf90d947557e17" translate="yes" xml:space="preserve">
          <source>Not all methods indicated above need be implemented. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;, &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt;, &lt;a href=&quot;tie/array&quot;&gt;Tie::Array&lt;/a&gt;, &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt;, and &lt;a href=&quot;tie/handle&quot;&gt;Tie::Handle&lt;/a&gt;.</source>
          <target state="translated">위에 표시된 모든 방법을 구현할 필요는 없습니다. 참조 &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; , &lt;a href=&quot;tie/hash&quot;&gt;타이 :: 해시&lt;/a&gt; , &lt;a href=&quot;tie/array&quot;&gt;타이 :: 배열&lt;/a&gt; , &lt;a href=&quot;tie/scalar&quot;&gt;타이 :: 스칼라&lt;/a&gt; , 그리고 &lt;a href=&quot;tie/handle&quot;&gt;타이 :: 핸들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2a6c0e385364fab2b337951897446173ad031c2" translate="yes" xml:space="preserve">
          <source>Not all modules that you might use are thread-safe, and you should always assume a module is unsafe unless the documentation says otherwise. This includes modules that are distributed as part of the core. Threads are a relatively new feature, and even some of the standard modules aren't thread-safe.</source>
          <target state="translated">사용할 수있는 모든 모듈이 스레드로부터 안전하지는 않으며 설명서에서 달리 명시하지 않는 한 항상 모듈이 안전하지 않은 것으로 가정해야합니다. 여기에는 코어의 일부로 배포 된 모듈이 포함됩니다. 스레드는 비교적 새로운 기능이며 일부 표준 모듈조차 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc116f0ff5686f14831a54addc98cc9a05b72b09" translate="yes" xml:space="preserve">
          <source>Not all of the methods below are overridable in a Makefile.PL. Overridable methods are marked as (o). All methods are overridable by a platform specific MM_*.pm file.</source>
          <target state="translated">아래의 모든 메소드가 Makefile.PL에서 대체 가능한 것은 아닙니다. 재정의 가능한 메서드는 (o)로 표시됩니다. 모든 메소드는 플랫폼 별 MM _ *. pm 파일로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d9265d57d6ec36dc8e3a9bed39f04863ac691e" translate="yes" xml:space="preserve">
          <source>Not all of the options currently have any useful effect. See &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf47163ed1a6a398998e1921423263683e08485" translate="yes" xml:space="preserve">
          <source>Not all of the options currently have any useful effect. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; for more details.</source>
          <target state="translated">현재 모든 옵션이 유용한 영향을주는 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;#BUGS&quot;&gt;버그&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a2bb2e7a36d3508362112d31fd091b4c7b1d74" translate="yes" xml:space="preserve">
          <source>Not all platforms provide a command line. These are usually platforms that rely primarily on a Graphical User Interface (GUI) for user interaction. A program requiring a command line interface might not work everywhere. This is probably for the user of the program to deal with, so don't stay up late worrying about it.</source>
          <target state="translated">모든 플랫폼이 명령 행을 제공하는 것은 아닙니다. 이들은 일반적으로 사용자 상호 작용을 위해 GUI (Graphical User Interface)를 주로 사용하는 플랫폼입니다. 명령 행 인터페이스가 필요한 프로그램은 모든 곳에서 작동하지 않을 수 있습니다. 이것은 아마도 프로그램 사용자가 다룰 것이므로 늦게 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0377a3bed66f53a36c6cc0f471dce14458aee134" translate="yes" xml:space="preserve">
          <source>Not all platforms support passing va_list to further varargs (stdarg) functions. The right thing to do is to copy the va_list using the Perl_va_copy() if the NEED_VA_COPY is defined.</source>
          <target state="translated">모든 플랫폼이 va_list를 추가 varargs (stdarg) 함수로 전달하는 것을 지원하지는 않습니다. NEED_VA_COPY가 정의 된 경우 Perl_va_copy ()를 사용하여 va_list를 복사하는 것이 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d7d5819e6b8154b84cfd521568df2f44e1277562" translate="yes" xml:space="preserve">
          <source>Not all scalar types are printable. Simple values certainly are: one of IV, UV, NV, or PV. Also, if the SV is a reference to some value, either it will be dereferenced and the value printed, or information about the type of that value and its address are displayed. The results of printing any other type of SV are undefined and likely to lead to an interpreter crash. NVs are printed using a &lt;code&gt;%g&lt;/code&gt;-ish format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3114af1185f39ddb11892070ce221fe5a6a78ef2" translate="yes" xml:space="preserve">
          <source>Not all shells will allow multiple &lt;code&gt;-e&lt;/code&gt; string arguments to perl to be concatenated together properly as recipes in this document 0, 2, 4, 5, and 6 might seem to imply.</source>
          <target state="translated">모든 쉘이 다중 &lt;code&gt;-e&lt;/code&gt; 를 허용하지는 않습니다이 문서에서 레시피 0, 2, 4, 5 및 6이 암시하는 것처럼 문자열 인수를 perl로 올바르게 연결할 .</target>
        </trans-unit>
        <trans-unit id="4304b60dda11c4080ba0d7af04669e7d3681ebb5" translate="yes" xml:space="preserve">
          <source>Not all these variables are necessarily considered &quot;public&quot; wrt. use in typemaps, so beware. Variables set up from the ExtUtils::ParseXS object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390f0fc324c35c457b6797e31cfc3992a7cb393c" translate="yes" xml:space="preserve">
          <source>Not an ARRAY reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2037b538368e39fec0d7f178aa255c4c901e6b71" translate="yes" xml:space="preserve">
          <source>Not being able to say &quot;no diagnostics&quot; is annoying, but may not be insurmountable.</source>
          <target state="translated">&quot;진단 없음&quot;이라고 말할 수없는 것은 성가 시지만 극복 할 수없는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0995003c36ab734a65b058b853402db6930f592e" translate="yes" xml:space="preserve">
          <source>Not compiling with -DDEBUGGING</source>
          <target state="translated">-DDEBUGGING으로 컴파일하지 않음</target>
        </trans-unit>
        <trans-unit id="ca400cb81537a6d172c2a30c8bb57fcb36d92286" translate="yes" xml:space="preserve">
          <source>Not compiling with threading</source>
          <target state="translated">스레딩으로 컴파일하지 않음</target>
        </trans-unit>
        <trans-unit id="350370904b27cc0af7789a292a507adc1a7bdacd" translate="yes" xml:space="preserve">
          <source>Not doing so may lead to surprises:</source>
          <target state="translated">그렇게하지 않으면 놀라움으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e70f97f83bebe0f2e20286e534122be1e62b93c9" translate="yes" xml:space="preserve">
          <source>Not end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f205c9fa4291a1adffc39f09e800a7bf1400fb" translate="yes" xml:space="preserve">
          <source>Not enough arguments for %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4960796cc14c02f19a88f95a3afd62e329c17f" translate="yes" xml:space="preserve">
          <source>Not enough format arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba394cd9d79ffbbc16d2bd64cd6fb94c4285df0" translate="yes" xml:space="preserve">
          <source>Not every event or Perl Mongers group is on that calendar, so don't lose heart if you don't see yours posted. To have your event or group listed, contact brian d foy (brian@theperlreview.com).</source>
          <target state="translated">모든 이벤트 또는 Perl Mongers 그룹이 해당 캘린더에있는 것은 아니므로 게시 된 내용이 보이지 않으면 마음을 잃지 마십시오. 이벤트 또는 그룹을 나열하려면 brian d foy (brian@theperlreview.com)에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="0a7f13c13fb3f26bce123ed94d7ecfbbffb8eb0c" translate="yes" xml:space="preserve">
          <source>Not every language tag really refers to a single language. Some language tags refer to conditions: i-default (system-message text in English plus maybe other languages), und (undetermined language). Others (notably lots of the three-letter codes) are bibliographic tags that classify whole groups of languages, as with cus &quot;Cushitic (Other)&quot; (i.e., a language that has been classed as Cushtic, but which has no more specific code) or the even less linguistically coherent sai for &quot;South American Indian (Other)&quot;. Though useful in bibliography, &lt;b&gt;SUCH TAGS ARE NOT FOR GENERAL USE&lt;/b&gt;. For further guidance, email me.</source>
          <target state="translated">모든 언어 태그가 실제로 단일 언어를 나타내는 것은 아닙니다. 일부 언어 태그는 i-default (영어로 된 시스템 메시지 텍스트와 다른 언어로) 및 und (확인되지 ​​않은 언어)와 같은 조건을 나타냅니다. 다른 것 (특히 많은 3 글자 코드)은 &quot;Cushitic (기타)&quot;(예 : Cushtic으로 분류되었지만 더 구체적인 코드가없는 언어)와 같이 전체 언어 그룹을 분류하는 서지 태그입니다. 또는 &quot;남아메리카 인디언 (기타)&quot;에 대해 언어 적으로 일관성이없는 sai. 참고 문헌에 유용하지만 &lt;b&gt;이러한 태그는 일반적인 용도로 사용되지 않습니다&lt;/b&gt; . 더 자세한 안내를 원하시면 저에게 이메일을 보내주십시오.</target>
        </trans-unit>
        <trans-unit id="3ea748e41042fae4b5e481a0f49f8953b1ba289f" translate="yes" xml:space="preserve">
          <source>Not every program has to go through each of the possible phases, but transition from one phase to another can only happen in the order described in the above list.</source>
          <target state="translated">모든 프로그램이 가능한 각 단계를 거쳐야하는 것은 아니지만 한 단계에서 다른 단계로의 전환은 위 목록에 설명 된 순서 대로만 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c816e7c42988c3d11d87bf96a910ccb79c57f32" translate="yes" xml:space="preserve">
          <source>Not everything is a simple eq check or regex. There are times you need to see if two data structures are equivalent. For these instances Test::More provides a handful of useful functions.</source>
          <target state="translated">모든 것이 단순한 EQ 체크 또는 정규식은 아닙니다. 두 데이터 구조가 동일한 지 확인해야 할 경우가 있습니다. 이러한 경우 Test :: More는 유용한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b40e711f20f038555af473ee4ac108274fa7f9c8" translate="yes" xml:space="preserve">
          <source>Not everything is documented yet.</source>
          <target state="translated">모든 것이 아직 문서화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e28ddb404a0041a3b2d909163038f64bb4a64a" translate="yes" xml:space="preserve">
          <source>Not exported by default.</source>
          <target state="translated">기본적으로 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d70d5556752165324a9545f2bca3001c5928ecb" translate="yes" xml:space="preserve">
          <source>Not exporting your new function</source>
          <target state="translated">새 기능을 내 보내지 않음</target>
        </trans-unit>
        <trans-unit id="3de6216a588bc2f1646686041b64658486a740c8" translate="yes" xml:space="preserve">
          <source>Not for normal use.</source>
          <target state="translated">정상적인 사용에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cb64bcbbd5a35d8290b9d42e26918a747698537" translate="yes" xml:space="preserve">
          <source>Not implemented (VMS, RISC OS, VOS).</source>
          <target state="translated">구현되지 않았습니다 (VMS, RISC OS, VOS).</target>
        </trans-unit>
        <trans-unit id="0d0f974626edbcbc3442249b1c5bedf691856c93" translate="yes" xml:space="preserve">
          <source>Not implemented yet, will fix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3254417362748be2bc014d24fafb5e5786cfb8" translate="yes" xml:space="preserve">
          <source>Not implemented, hence not useful for taint checking. (RISC OS)</source>
          <target state="translated">구현되지 않았으므로 오염 검사에 유용하지 않습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="3f95882d534087a6046525a2df4e776680013e1a" translate="yes" xml:space="preserve">
          <source>Not implemented. (AmigaOS, RISC OS, VMS)</source>
          <target state="translated">구현되지 않았습니다. (AmigaOS, RISC OS, VMS)</target>
        </trans-unit>
        <trans-unit id="9be2651d8f1db0033658f4a09b41f2967b03b1a2" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android)</source>
          <target state="translated">구현되지 않았습니다. (기계적 인조 인간)</target>
        </trans-unit>
        <trans-unit id="8764e205d719987502ecc5a1d14954350c06e36a" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, RISC OS, VMS, Win32)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, RISC OS, VMS, Win32)</target>
        </trans-unit>
        <trans-unit id="9b09c5fded531e5c65a40df94ba58b539af31cb9" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, VMS, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, VMS, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="db2cbf01d3edd364260719b49f0552da06074b32" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32)</target>
        </trans-unit>
        <trans-unit id="cfd9c1a9a91b792892f2a5fea52723a1f2e69940" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, Win32, 계획 9)</target>
        </trans-unit>
        <trans-unit id="b43f99dedb804d88539fc88ab6db0d0787e31419" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, Plan 9, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, 계획 9, RISC OS)</target>
        </trans-unit>
        <trans-unit id="0be4e159794a607b410794f39b0e3b8aaf22c83b" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="0d98f25d5507c35e363bc1c7b15a438bc954c58f" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS)</source>
          <target state="translated">구현되지 않았습니다. (안드로이드, Win32, VMS)</target>
        </trans-unit>
        <trans-unit id="7bc41074b764485b1508c998d3f3f1b06873a949" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS, Plan 9, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, VMS, Plan 9, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="dd10c5ee6bfcd93657131a710727b05972d81d34" translate="yes" xml:space="preserve">
          <source>Not implemented. (Android, Win32, VMS, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Android, Win32, VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="27455a44f0877f0471812763650eca083a756dc3" translate="yes" xml:space="preserve">
          <source>Not implemented. (For computing dividends of long integers.) &lt;code&gt;ldiv()&lt;/code&gt; is C-specific, use &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 긴 정수의 배당을 계산하려면 &lt;code&gt;ldiv()&lt;/code&gt; 는 C에 따라 다르며 &lt;code&gt;/&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32a90981ba3510445dbe102e793b68e3aa230e62" translate="yes" xml:space="preserve">
          <source>Not implemented. (For computing dividends of long integers.) &lt;code&gt;ldiv()&lt;/code&gt; is C-specific, use &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;int()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35c350e45ece5778366ababe31d410a0f9c7643" translate="yes" xml:space="preserve">
          <source>Not implemented. (For returning absolute values of long integers.) &lt;code&gt;labs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. (정수의 절대 값을 반환하는 경우) &lt;code&gt;labs()&lt;/code&gt; 는 C에 따라 다릅니다. &lt;a href=&quot;functions/abs&quot;&gt;abs를&lt;/a&gt; 참조하십시오. . 대신 를 .</target>
        </trans-unit>
        <trans-unit id="0e37bef308ba3bb37063dbfda0ed4d42102958b1" translate="yes" xml:space="preserve">
          <source>Not implemented. (For returning absolute values of long integers.) &lt;code&gt;labs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#abs&quot;&gt;&quot;abs&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0defed26024da4d1fed917bb2bf5601feb0b111c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Older versions of VMS)</source>
          <target state="translated">구현되지 않았습니다. (이전 버전의 VMS)</target>
        </trans-unit>
        <trans-unit id="44ca2b069b718c2e4157a5f59d1c825f895901fe" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (계획 9)</target>
        </trans-unit>
        <trans-unit id="1687754bd82bb4141221093b9e0016e67a352bef" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9, Win32)</source>
          <target state="translated">구현되지 않았습니다. (계획 9, Win32)</target>
        </trans-unit>
        <trans-unit id="a0c06eb1c0ea0d5c9ba352666d371d2a0ee60d0c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Plan 9, Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (계획 9, Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="ccbe418811577573c94ecd1f3f6fa886c5efa0c1" translate="yes" xml:space="preserve">
          <source>Not implemented. (RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="913cb5f5472a95b0b4bb5b0094468f9bd4a064d5" translate="yes" xml:space="preserve">
          <source>Not implemented. (RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="c7eb7af11eb0f7e9fd28bfd3a491ea52eea2602b" translate="yes" xml:space="preserve">
          <source>Not implemented. (VMS)</source>
          <target state="translated">구현되지 않았습니다. (VMS)</target>
        </trans-unit>
        <trans-unit id="8b09ce4b149875b133df47459bb650cb679175f6" translate="yes" xml:space="preserve">
          <source>Not implemented. (VMS, Plan 9, VOS)</source>
          <target state="translated">구현되지 않았습니다. (VMS, 플랜 9, VOS)</target>
        </trans-unit>
        <trans-unit id="0e4b18141256d3047c7405c5aca0f45f42b63f27" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32)</source>
          <target state="translated">구현되지 않았습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="1e142d21e64d53e23fa456f8c1dabbf0855e18ca" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, Plan 9)</source>
          <target state="translated">구현되지 않았습니다. (Win32, 계획 9)</target>
        </trans-unit>
        <trans-unit id="4df1791d2450fc70228c9ee024b8242b13ea6b2f" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, Plan 9, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, 계획 9, RISC OS)</target>
        </trans-unit>
        <trans-unit id="5e4a1a38936d3686e162500ce6f897394cef05d7" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, RISC OS)</target>
        </trans-unit>
        <trans-unit id="3be05ea3d75bc165c7f982935b70e66d5a771e41" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, Plan 9, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, Plan 9, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="a54f984df38f433357bf0966c3cbdd1b95a80f1c" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, RISC OS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, RISC OS)</target>
        </trans-unit>
        <trans-unit id="22e05018b6fdced9bdff0b7d0cfb5c24bf0dbae4" translate="yes" xml:space="preserve">
          <source>Not implemented. (Win32, VMS, RISC OS, VOS)</source>
          <target state="translated">구현되지 않았습니다. (Win32, VMS, RISC OS, VOS)</target>
        </trans-unit>
        <trans-unit id="df3ebac574a0d503f84cea64df9995482f545b78" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; is non-portable, see &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 는 이식성이 없으며 대신 &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d13a3e012a93a772c4609ee06162adf5d3f5482" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atexit()&lt;/code&gt; is C-specific: use &lt;code&gt;END {}&lt;/code&gt; instead, see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atexit()&lt;/code&gt; 은 C에 따라 다릅니다. 대신 &lt;code&gt;END {}&lt;/code&gt; 를 사용하십시오 ( &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="09f4af676353b27d015a55030f640e13fe428c8a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atof()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atof()&lt;/code&gt; 는 C 특정입니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="78bd80efc5684aaa0a6d2c976cfd9415957a93a7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atoi()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atoi()&lt;/code&gt; 는 C에 따라 다릅니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오. 정수 부분 만 필요한 경우 &lt;a href=&quot;functions/int&quot;&gt;int를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f00dfe9cb689976b534854484eee8f7dbf6f4bf" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atoi()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c185269174fefc8864fa2f033cc63f05493972d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atol()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;atol()&lt;/code&gt; 은 C에 따라 다릅니다. 펄은 문자열을 투명하게 숫자로 변환합니다. 스칼라를 숫자로 강제해야하는 경우 0을 추가하십시오. 정수 부분 만 필요한 경우 &lt;a href=&quot;functions/int&quot;&gt;int를&lt;/a&gt; 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="31277df803c7213e94495dddc89b89837974e70b" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;atol()&lt;/code&gt; is C-specific. Perl converts strings to numbers transparently. If you need to force a scalar to a number, add a zero to it. If you need to have just the integer part, see &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f186e9062bbcbeafdbb5188df478220b8fd34d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;calloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;calloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ff7eec59e29a378eef5b91c7e47dc4704c6ae3ed" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;div()&lt;/code&gt; is C-specific, use &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; on the usual &lt;code&gt;/&lt;/code&gt; division and the modulus &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;div()&lt;/code&gt; 는 C 에 따라 다르며, 보통 &lt;code&gt;/&lt;/code&gt; 나누기와 모듈러스 &lt;code&gt;%&lt;/code&gt; 에서 &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; 를 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="a9668934ab7ee888fcba5d1018df608d998bdfde" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;div()&lt;/code&gt; is C-specific, use &lt;a href=&quot;perlfunc#int&quot;&gt;&quot;int&quot; in perlfunc&lt;/a&gt; on the usual &lt;code&gt;/&lt;/code&gt; division and the modulus &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feba813e22b3e1ba2371da2a841ea2764df6b0c" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execl()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execl()&lt;/code&gt; 은 C에 따라 다릅니다. &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="b8cdcc2bc95ce16a401976480e4c0dd5d26d1551" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execl()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff7e7175b118c1234a7bdfd30d4510edaf63eb8" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execle()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execle()&lt;/code&gt; 은 C- 특정입니다. &lt;a href=&quot;functions/exec&quot;&gt;exec를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e612f96906af3d61e47a98a3b96ec9267a8ba5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execle()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55ec83b5578209872a8b8cd8fcb058c67f6c46a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execlp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execlp()&lt;/code&gt; 는 C에 따라 다릅니다. &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="714c6cc385b3d787feb8a075a8914079e9a683f0" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execlp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28abb99b1ca88a6e43303b5eacb4722165a49a2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execv()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execv()&lt;/code&gt; 는 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b67d5ef7bbf6b11e4c8131d65fd0b0d50cea3fa4" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execv()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5186c9f0054529cba073f427607f1822da899bdc" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execve()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execve()&lt;/code&gt; 는 C에 고유합니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="06bfc60d8dbd39342a046bab49edf5ee16062e08" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execve()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a36265f790509d75a62c2c319a843a4a40d7fd1" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execvp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;execvp()&lt;/code&gt; 는 C에 따라 다릅니다 ( &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3c41eeeac0050cd6ab2ec752535867c4b331c9b3" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;execvp()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d29c901ed53c6f9353f56b5387ce804863d40b2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02d74c5e78190921a07cba3e67691de9327d44e6" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#printf&quot;&gt;&quot;printf&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050fa3a8f5bd9b39de78e5fc9715f0e8bc48d1f5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fputc()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27f3f1356e0f2d2e897cadf71cc702ec5cf6b651" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6604c90e368654e682d80594f438dfbd8e6b3c87" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fputs()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b942ddfbeebd05264b5a1304515e8d5b6c258fd" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fputs()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe419a5536eab5825dd89321d048538aa71f3581" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fread()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fread()&lt;/code&gt; C-특정 참조 &lt;a href=&quot;functions/read&quot;&gt;읽기&lt;/a&gt; . 대신 를 .</target>
        </trans-unit>
        <trans-unit id="eb80e5d4e9f3e34554f9ec2247d5f30b5e39ecb0" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fread()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#read&quot;&gt;&quot;read&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc646b919b78b9528c2ca2fc3f6d528b7f17e528" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;free()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;free()&lt;/code&gt; 는 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f31c768b4ce793b6920a2fbc67aa875a3bad3ce7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;freopen()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;freopen()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ff06451b9d8800308bf4d85c0d2cb81711b1af7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;freopen()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6dd63a418b84ae3412075ba1a715748c59e650" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fscanf()&lt;/code&gt; is C-specific, use &amp;lt;&amp;gt; and regular expressions instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fscanf()&lt;/code&gt; 는 C에 따라 다르며 대신 &amp;lt;&amp;gt; 및 정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="803e59e7256268e04789245ab7cdd5f3b1b8ccea" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fwrite()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;fwrite()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2eb7a59ef7308efd57baee975752c73e9e09e718" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;fwrite()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009be5a018756df717aa5d027ee88dc34faf4f1e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;longjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;longjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;a href=&quot;functions/die&quot;&gt;die를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20a0777e409be90d3636e1854e98df3c8eb744c9" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;longjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;perlfunc#die&quot;&gt;&quot;die&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef9c813c13bfbed594dcbc5cb78558fb58b324e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;malloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;malloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="05a9fcc8dff8c195fa86d7e73fdbb1a70a26f9f6" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memchr()&lt;/code&gt; 은 C에 고유합니다. &lt;a href=&quot;functions/index&quot;&gt;색인&lt;/a&gt; 참조 . 대신 를 .</target>
        </trans-unit>
        <trans-unit id="d8b03690afc4782abe2d4eb7aa9e8fb3d6ca560f" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#index&quot;&gt;&quot;index&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77441742665123afa83b78530ce3a0ab326aeb65" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memcmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memcmp()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;eq&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="ef2d9a9129c1e4edee370c88c30737709c4b4ca5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memcpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; , see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memcpy()&lt;/code&gt; C-특정 용도이다 &lt;code&gt;=&lt;/code&gt; 참조 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 또는 참조 &lt;a href=&quot;functions/substr&quot;&gt;SUBSTR를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b28c8c3a19a27c6c25a1bd369ca8b66138675bd" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memcpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt;, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;perlfunc#substr&quot;&gt;&quot;substr&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df825da230687d219686874fba9a3cde9128b6b2" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memmove()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; , see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memmove()&lt;/code&gt; C-특정 용도이다 &lt;code&gt;=&lt;/code&gt; 참조 &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 또는 참조 &lt;a href=&quot;functions/substr&quot;&gt;SUBSTR를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1b0d19a886f2b51bef3354c44ddb3c2fdfc4ac" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memmove()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt;, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, or see &lt;a href=&quot;perlfunc#substr&quot;&gt;&quot;substr&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f209e2a77b56cbe0e8dab09f4f69003460ef5165" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;memset()&lt;/code&gt; is C-specific, use &lt;code&gt;x&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;memset()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;code&gt;x&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bb4ed6eef37f29c3a5ed63baa8372d65c75a7bd4" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;offsetof()&lt;/code&gt; is C-specific, you probably want to see &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;offsetof()&lt;/code&gt; 는 C에 따라 다르며 아마도 &lt;a href=&quot;functions/pack&quot;&gt;팩&lt;/a&gt; 을보고 싶을 것입니다. 것입니다.</target>
        </trans-unit>
        <trans-unit id="2678c36a3e7afb74108d32fad6b536b2c312fb34" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;offsetof()&lt;/code&gt; is C-specific, you probably want to see &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a56537761ef29ac46b64e624815032acfe09d5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;putc()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a837aa4d6a9085f7e08d3d9d5bed920b5d904982" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putc()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f78712fd0d6ef941365735d2d77cc01cb91842" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putchar()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;putchar()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a462bc7da9d7de2e2210ee6d9180556440425552" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;putchar()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4f9ab6e5a505c059b02d4f1e39653281c84079" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;puts()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;puts()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="486a94a26ebd7d06cab9d63aafb041166ffd8558" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;puts()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#print&quot;&gt;&quot;print&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f67ad74b3ec17c9d41e3b1afab51f5f541355a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;qsort()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;qsort()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58970081657eba957570efcb0024c21310623ca4" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;qsort()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5737e86392842d14972e36d022289166fd1215" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;rand()&lt;/code&gt; is non-portable, see &lt;a href=&quot;perlfunc#rand&quot;&gt;&quot;rand&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80417a7f52d6bce06bdc09d12e04679309282530" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;realloc()&lt;/code&gt; is C-specific. Perl does memory management transparently.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;realloc()&lt;/code&gt; 은 C에 따라 다릅니다. Perl은 메모리 관리를 투명하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b854623b0099f120c1f261738fcfb3b0e3dc6c43" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;scanf()&lt;/code&gt; is C-specific, use &amp;lt;&amp;gt; and regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;scanf()&lt;/code&gt; 는 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 &amp;lt;&amp;gt; 및 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="86b82e3463dd9eb13ab0f20876acdf2afce2a004" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;setjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; instead, see &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;setjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하십시오 ( &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="50f8aef85879178dec102b3280e027faa31a0fbc" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;setjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;eval {}&lt;/code&gt; instead, see &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa206dd3a3d7cd667dd32f0c3afaf7a818af84a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;siglongjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;siglongjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;a href=&quot;functions/die&quot;&gt;die를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e5ed221632f47a2af0000aec5b773670dcdd589c" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;siglongjmp()&lt;/code&gt; is C-specific: use &lt;a href=&quot;perlfunc#die&quot;&gt;&quot;die&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdcc330b8531baca8e2545556f293d068fb1ea6" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;sigsetjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; instead, see &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;sigsetjmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 을 사용하십시오 ( &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="37fd5b8db291420c97561c7d4f53a7442c39460a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;sigsetjmp()&lt;/code&gt; is C-specific: use &lt;code&gt;eval {}&lt;/code&gt; instead, see &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c268319591fc9206f5120b56c9b7a829b89f16" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;sscanf()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;sscanf()&lt;/code&gt; 는 C에 특정 합니다. 대신 정규 표현식을 사용하십시오 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="15a4e6249a6616df5c7fdb6def3ca7df12c8a726" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcat()&lt;/code&gt; is C-specific, use &lt;code&gt;.=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcat()&lt;/code&gt; 은 C에 따라 다릅니다 &lt;code&gt;.=&lt;/code&gt; 대신 . =를 사용하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4812ccf99744fab9351e2abe32d45f098e817477" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strchr()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2377c1e46d6925e7717ebcfb500224bd7e8fa3a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#index&quot;&gt;&quot;index&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97d0b60e52aa06d90e7b2e823428ad7860f8e8a" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; or &lt;code&gt;cmp&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcmp()&lt;/code&gt; 는 C에 따라 다릅니다. 대신 &lt;code&gt;eq&lt;/code&gt; 또는 &lt;code&gt;cmp&lt;/code&gt; 를 사용하십시오.&lt;a href=&quot;perlop&quot;&gt; perlop&lt;/a&gt; . .</target>
        </trans-unit>
        <trans-unit id="e88b009350740b83bff03725c96d491249d6cc12" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcpy()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;=&lt;/code&gt; 를 사용 하십시오 . &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a946232e34c698b1c18404aaa65fdcbbc90586e" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strcspn()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strcspn()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="ac1ea236189e44b7d18fc790ee5b8256e3811b01" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strlen()&lt;/code&gt; is C-specific, use &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; instead, see &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strlen()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 사용하십시오 . &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7243ed7908af6a010c57b54ba9ffdf8010dfa6eb" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strlen()&lt;/code&gt; is C-specific, use &lt;code&gt;length()&lt;/code&gt; instead, see &lt;a href=&quot;perlfunc#length&quot;&gt;&quot;length&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec098c49b2779aed7a7218ddc97a53cf81b8121" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncat()&lt;/code&gt; is C-specific, use &lt;code&gt;.=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncat()&lt;/code&gt; 은 C에 따라 다릅니다 &lt;code&gt;.=&lt;/code&gt; 대신 . =를 사용하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4679b5013101131fbb1f77170dbb3261921e3ac9" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncmp()&lt;/code&gt; is C-specific, use &lt;code&gt;eq&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncmp()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;eq&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="68b43540c2aaa3f23562e63d21cbb3d1f37d032d" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strncpy()&lt;/code&gt; is C-specific, use &lt;code&gt;=&lt;/code&gt; instead, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strncpy()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;code&gt;=&lt;/code&gt; 를 사용 하십시오 . &lt;a href=&quot;perlop&quot;&gt;perlop을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e613eff42bbb352539ebe134a02f9df651ee1788" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strpbrk()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strpbrk()&lt;/code&gt; 는 C에 특정 합니다. 대신 정규 표현식을 사용하십시오 ( &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6ec8b4e827e4723ad758e333ead45fa4a152ab56" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strrchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/rindex&quot;&gt;rindex&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strrchr()&lt;/code&gt; 은 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/rindex&quot;&gt;rindex&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d989a1989e58e594834a2c2dc1076104bdb3de8" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strrchr()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#rindex&quot;&gt;&quot;rindex&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc182b6d01cd132d49498bf46d317d05a13d5d37" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strspn()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strspn()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; 대신 정규 표현식을 사용하십시오 ( perlre 참조) .</target>
        </trans-unit>
        <trans-unit id="d5614594f22eb6178c164a089713817c648981e5" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strtok()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, or &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;strtok()&lt;/code&gt; 은 C에 따라 &lt;a href=&quot;perlre&quot;&gt;다르며&lt;/a&gt; , 대신 정규 표현식을 사용하십시오. perlre 또는 &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3b97f646be52a7c0b85640187f4568a1fa8af6c" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;strtok()&lt;/code&gt; is C-specific, use regular expressions instead, see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, or &lt;a href=&quot;perlfunc#split&quot;&gt;&quot;split&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80fdcacb3f3247028947287ced6c21eda7e4321b" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vfprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vfprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9215122814b90ecb3e477d3c15f5429bcad42bd7" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vfprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#printf&quot;&gt;&quot;printf&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90b40527e74f3653d4dd6b14250c134ce59f330" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bd973fd3341a07f7cd818193d4686826a45e553" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#printf&quot;&gt;&quot;printf&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08604cd1d6dad28e54ed2c86d8e61348b23d108b" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vsprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;vsprintf()&lt;/code&gt; 는 C에 따라 다릅니다 . 대신 &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc3d56b756e7df13ee494ac890642837179ebc81" translate="yes" xml:space="preserve">
          <source>Not implemented. &lt;code&gt;vsprintf()&lt;/code&gt; is C-specific, see &lt;a href=&quot;perlfunc#sprintf&quot;&gt;&quot;sprintf&quot; in perlfunc&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d102bc3eb40c72725daf568afa3e2114850dcc" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::new_tmpfile()&lt;/code&gt; instead, or see &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c9bc78a8aeb50498c091744a0a072e8663077c" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::new_tmpfile()&lt;/code&gt; instead, or see &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::File::new_tmpfile()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;file/temp&quot;&gt;File :: Temp를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb9ea04652178e89f71d95b0e26c4da58a6e3d57" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::open()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::File::open()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f6a6e959d35888331459ed390bce3c8516ae526" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::File::open()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133851d7093855036c645528e4109a7be1a3e820" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::close()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::close()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6c5b2cfc5eec40176e9a2daefbd3f1ebc5a9775" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::close()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#close&quot;&gt;&quot;close&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ba46f1c447a0143660b5cddf9fb1d25553fffb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::eof()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 메소드 &lt;code&gt;IO::Handle::eof()&lt;/code&gt; 사용하거나 &lt;a href=&quot;functions/eof&quot;&gt;eof를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b85b74139f7dd0ea579a4dad9aa4bdb958e7b2b" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::eof()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#eof&quot;&gt;&quot;eof&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8adccccd63977fb3c0fcacade58414e48926172" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::error()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::error()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1cf1a56225275921aede7048ae283bdae3ce190" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::fileno()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::fileno()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9696f13283acc9bdbd2e83addb3b28782209df38" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::fileno()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#fileno&quot;&gt;&quot;fileno&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaf3e3bac060d4e96a401f2f0634ced943fa15f" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::flush()&lt;/code&gt; instead. See also &lt;code&gt;&lt;a href=&quot;perlvar#%24OUTPUT_AUTOFLUSH&quot;&gt;&quot;$OUTPUT_AUTOFLUSH&quot; in perlvar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea09c7543753e43f0874eca405e18dbb7c8fbe5" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::flush()&lt;/code&gt; instead. See also &lt;code&gt;&lt;a href=&quot;perlvar#%24OUTPUT_AUTOFLUSH&quot;&gt;$OUTPUT_AUTOFLUSH in perlvar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::flush()&lt;/code&gt; 메소드를 사용하십시오 . &lt;code&gt;&lt;a href=&quot;perlvar#%24OUTPUT_AUTOFLUSH&quot;&gt;$OUTPUT_AUTOFLUSH in perlvar&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b6a85a170f35c7a103834e7c9ab729375c61940" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::getc()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::getc()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42ababc5d5162f6a63c30bd536ed8086eafd3641" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::getc()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#read&quot;&gt;&quot;read&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58770e0b79629739d1eacc20133618f4648e46ac" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::gets()&lt;/code&gt; instead. Similar to &amp;lt;&amp;gt;, also known as &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::gets()&lt;/code&gt; 메소드를 사용하십시오 . &amp;lt;&amp;gt;와 유사하며 &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; 라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="08418b376d6e2a51350cafa8345cc73ed8d4f24e" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::gets()&lt;/code&gt; instead. Similar to &amp;lt;&amp;gt;, also known as &lt;a href=&quot;perlfunc#readline&quot;&gt;&quot;readline&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3907a6c5c4412de4df54dbbf1b97cc9ee0b41c" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::new_from_fd()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::new_from_fd()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdda9a6ff09725998f29342f77d923d05475255b" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::new_from_fd()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34ae8702317852fa502a0298b0533b2d7a4471a" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::sync()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::sync()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9baea21503c08e99440dc4cb43bcdef6e777150" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Handle::ungetc()&lt;/code&gt; instead.</source>
          <target state="translated">구현되지 않았습니다. 대신 &lt;code&gt;IO::Handle::ungetc()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="211713d31d2112ee0f26a6608edadadbf58f4c80" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::getpos()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::getpos()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7a6c87195880febc276d87a3f6ab896650a4f21" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::getpos()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#seek&quot;&gt;&quot;seek&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49c926515a4700f695726ea107a0a6611a896eb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::seek()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::seek()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e22c70c9516f2dd39dfe39fe30636124f60a3b4" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::seek()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#seek&quot;&gt;&quot;seek&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e6ae0bbba38efd7d70699a4892e9d6f993a6ca" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::setpos()&lt;/code&gt; instead, or seek &lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::setpos()&lt;/code&gt; 메소드를 대신 사용하거나 seek을 &lt;a href=&quot;functions/seek&quot;&gt;찾으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d70e95cf413ff9992f93ac25f58aae24206141ae" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::setpos()&lt;/code&gt; instead, or seek &lt;a href=&quot;perlfunc#seek&quot;&gt;&quot;seek&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3d78054e07679018c7eb8a6898e917690c20bb" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::tell()&lt;/code&gt; instead, or see &lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Seekable::tell()&lt;/code&gt; 메소드를 대신 사용하거나 &lt;a href=&quot;functions/tell&quot;&gt;tell을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d008ff929665022b03b82862bb6c2f5c4eb1995f" translate="yes" xml:space="preserve">
          <source>Not implemented. Use method &lt;code&gt;IO::Seekable::tell()&lt;/code&gt; instead, or see &lt;a href=&quot;perlfunc#tell&quot;&gt;&quot;tell&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137c25f432a636a5b4fbe697952402c8c467df96" translate="yes" xml:space="preserve">
          <source>Not implemented. Use the method &lt;code&gt;IO::Handle::clearerr()&lt;/code&gt; instead, to reset the error state (if any) and EOF state (if any) of the given stream.</source>
          <target state="translated">구현되지 않았습니다. &lt;code&gt;IO::Handle::clearerr()&lt;/code&gt; 메소드를 대신 사용하여 지정된 스트림의 오류 상태 (있는 경우) 및 EOF 상태 (있는 경우)를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="58f06a0bbcce20a76f9bb983793e3d731cc5b4e7" translate="yes" xml:space="preserve">
          <source>Not import any functions (&lt;code&gt;load&lt;/code&gt; and &lt;code&gt;autoload&lt;/code&gt; are not imported).</source>
          <target state="translated">어떤 함수도 가져 오지 않습니다 ( &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;autoload&lt;/code&gt; 는 가져 오지 않습니다).</target>
        </trans-unit>
        <trans-unit id="96a4269aa601e675ab09221ec97b05a936fa8983" translate="yes" xml:space="preserve">
          <source>Not keen on YAML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48d80935038d565f7b6bee1373f0f551a681530" translate="yes" xml:space="preserve">
          <source>Not meaning the same thing everywhere. A global variable in Perl can be localized inside a &lt;b&gt;dynamic scope&lt;/b&gt; via the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">모든 곳에서 같은 것을 의미하지는 않습니다. Perl의 전역 변수 는 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 연산자 를 통해 &lt;b&gt;동적 범위&lt;/b&gt; 내에서 지역화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2dde05372413be6966263a334909914770e1ec" translate="yes" xml:space="preserve">
          <source>Not meaning the same thing everywhere. A global variable in Perl can be localized inside a &lt;b&gt;dynamic scope&lt;/b&gt; via the &lt;code&gt;local&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b939fb6a3591b14266d8d57a8e48e4faf1d2cee" translate="yes" xml:space="preserve">
          <source>Not much in there, lets have a look at our hash:</source>
          <target state="translated">그다지 중요하지는 않지만 해시를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="111014156b398a7e453286db5ba72b54a2a724dd" translate="yes" xml:space="preserve">
          <source>Not only does the &lt;code&gt;&amp;amp;&lt;/code&gt; form make the argument list optional, it also disables any prototype checking on arguments you do provide. This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you're doing. See &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9a725cbef013a6dd198484972ad2c467befeee" translate="yes" xml:space="preserve">
          <source>Not only does the &lt;code&gt;&amp;amp;&lt;/code&gt; form make the argument list optional, it also disables any prototype checking on arguments you do provide. This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you're doing. See &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 형식은 인수 목록을 옵션으로 만들 뿐만 아니라 제공 한 인수에 대한 프로토 타입 검사도 비활성화합니다. 이것은 부분적으로 역사적인 이유이며, 자신이하고있는 일을 알고 있다면 속임수를 쓸 수있는 편리한 방법입니다. 아래의 &lt;a href=&quot;#Prototypes&quot;&gt;프로토 타입을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a811cf50f735b2384cdcc3d6c15773eea2339670" translate="yes" xml:space="preserve">
          <source>Not really a function. Returns the value of the last command in the sequence of commands indicated by BLOCK. When modified by the &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; loop modifier, executes the BLOCK once before testing the loop condition. (On other statements the loop modifiers test the conditional first.)</source>
          <target state="translated">실제로는 기능이 아닙니다. BLOCK으로 표시되는 명령 순서에서 마지막 명령의 값을 리턴합니다. &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;until&lt;/code&gt; 루프 수정 자에 의해 수정되면 루프 조건을 테스트하기 전에 BLOCK을 한 번 실행합니다. 다른 문장에서는 루프 수정자가 조건부를 먼저 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7730f6df594c6de3b4d8613cf47cdce98b6f0a22" translate="yes" xml:space="preserve">
          <source>Not really needed since Perl can do this transparently, see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl이 투명하게 할 수 있기 때문에 실제로는 필요하지 않습니다 . &lt;a href=&quot;perllocale&quot;&gt;perllocale을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9d7a49b40d40ab0a0f9c9a3b98021fa838b1713" translate="yes" xml:space="preserve">
          <source>Not really. Just remember these things:</source>
          <target state="translated">실제로는 아닙니다. 다음 사항 만 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="564d2f25f68052a8b0d8264d398e1a270012d6dd" translate="yes" xml:space="preserve">
          <source>Not supported. (Cygwin, Win32)</source>
          <target state="translated">지원되지 않습니다. (Cygwin, Win32)</target>
        </trans-unit>
        <trans-unit id="44f0aabb090ea7bda69b4ec7e7feada441e65ecd" translate="yes" xml:space="preserve">
          <source>Not supported. (Symbian OS)</source>
          <target state="translated">지원되지 않습니다. (Symbian OS)</target>
        </trans-unit>
        <trans-unit id="09d97c142afe584c0633a63005929ca08c9b4ee3" translate="yes" xml:space="preserve">
          <source>Not surprisingly &lt;code&gt;POPi&lt;/code&gt; is used twice this time because we were retrieving 2 values from the stack. The important thing to note is that when using the &lt;code&gt;POP*&lt;/code&gt; macros they come off the stack in</source>
          <target state="translated">당연히 &lt;code&gt;POPi&lt;/code&gt; 우리가 스택에서 두 값을 검색하고 있었기 때문에 두 번이 시간을 사용한다. 중요한 점은 &lt;code&gt;POP*&lt;/code&gt; 매크로 를 사용할 때 스택에서 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="b02a8b9c9c34f815393af037fc94b1f6cd6d0270" translate="yes" xml:space="preserve">
          <source>Not to be confused with the older &lt;code&gt;sv_isa&lt;/code&gt; function, which does not use an overloaded &lt;code&gt;isa()&lt;/code&gt; method, nor will check subclassing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390165cd3f335a354cf23fafc424a48aba836996" translate="yes" xml:space="preserve">
          <source>Not useful. (RISC OS)</source>
          <target state="translated">유용하지 않다. (RISC OS)</target>
        </trans-unit>
        <trans-unit id="a2b7936ab62eebf457dc2154c2400025b89c2f6e" translate="yes" xml:space="preserve">
          <source>Not very consistent! We'll set a breakpoint in the code manually and run it under the debugger to see what's going on. A breakpoint is a flag, to which the debugger will run without interruption, when it reaches the breakpoint, it will stop execution and offer a prompt for further interaction. In normal use, these debugger commands are completely ignored, and they are safe - if a little messy, to leave in production code.</source>
          <target state="translated">매우 일관성이 없습니다! 코드에서 중단 점을 수동으로 설정하고 디버거에서 실행하여 진행 상황을 확인합니다. 중단 점은 디버거가 중단없이 실행되는 플래그이며 중단 점에 도달하면 실행을 중지하고 추가 상호 작용을위한 프롬프트를 제공합니다. 일반적으로 이러한 디버거 명령은 완전히 무시되며 약간 혼란 스러울 경우 프로덕션 코드에 그대로 두는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="eab16f7244993d7b0b2df071763a4f5fb807aa02" translate="yes" xml:space="preserve">
          <source>Not very popular yet. Needs Unicode Database or equivalent to implement encode() (because it includes JIS X 0208/0212, KSC5601, and GB2312 simultaneously, whose code points in Unicode overlap. So you need to lookup the database to determine to what character set a given Unicode character should belong).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bb046c0c657ec319718519db98f1b45069923b" translate="yes" xml:space="preserve">
          <source>Not very popular. Needs CNS 11643-1 and -2 which are not available in this module. CNS 11643 is supported (via euc-tw) in Encode::HanExtra. Audrey Tang may add support for this encoding in her module in future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9789ac6a8ac0f9e48e0dab47af13503fe088d2fd" translate="yes" xml:space="preserve">
          <source>Not yet implemented things (but with correct description) are marked with '!', things that need to be answered are marked with '?'.</source>
          <target state="translated">아직 구현되지 않은 것 (그러나 정확한 설명으로)은 '!'로 표시되고, 답변이 필요한 것은 '?'로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b412fb5dbbfd0d61738d57648437ed916775cf7f" translate="yes" xml:space="preserve">
          <source>Not yet implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a291a507a7fbe91670ac808a7268af277204d4" translate="yes" xml:space="preserve">
          <source>Not-so-symbolic references</source>
          <target state="translated">기호가 아닌 참조</target>
        </trans-unit>
        <trans-unit id="8c5f0dacad99093710a8cf34c11579156a106382" translate="yes" xml:space="preserve">
          <source>Notable forms: {az-Arab} Azerbaijani in Arabic script; {az-Cyrl} Azerbaijani in Cyrillic script; {az-Latn} Azerbaijani in Latin script.</source>
          <target state="translated">주목할만한 형태 : 아랍어로 된 {az-Arab} 아제르바이잔 어; 키릴 문자 {az-Cyrl} 아제르바이잔 어; 라틴어 스크립트 {az-Latn} 아제르바이잔 어.</target>
        </trans-unit>
        <trans-unit id="a21e204d71bcc963ab9acff0b78bac05301d8085" translate="yes" xml:space="preserve">
          <source>Notable forms: {cel-gaulish} Gaulish (Historical)</source>
          <target state="translated">주목할만한 형태 : {cel-gaulish} Gaulish (기록)</target>
        </trans-unit>
        <trans-unit id="81bb796e9401d7e29001c83b4296a2b3487ce033" translate="yes" xml:space="preserve">
          <source>Notable forms: {de-at} Austrian German; {de-be} Belgian German; {de-ch} Swiss German; {de-de} Germany German; {de-li} Liechtenstein German; {de-lu} Luxembourg German.</source>
          <target state="translated">주목할만한 형태 : {de-at} 오스트리아 독일어; {de-be} 벨기에 독일어; {de-ch} 스위스 독일어; {de-de} 독일 독일어; {de-li} 리히텐슈타인 독일어; {de-lu} 룩셈부르크 독일어.</target>
        </trans-unit>
        <trans-unit id="e6b6ae9f7027c22a91fb186261e25769dc159ea0" translate="yes" xml:space="preserve">
          <source>Notable forms: {en-au} Australian English; {en-bz} Belize English; {en-ca} Canadian English; {en-gb} UK English; {en-ie} Irish English; {en-jm} Jamaican English; {en-nz} New Zealand English; {en-ph} Philippine English; {en-tt} Trinidad English; {en-us} US English; {en-za} South African English; {en-zw} Zimbabwe English.</source>
          <target state="translated">주목할만한 형태 : {en-au} 호주 영어; {en-bz} 벨리즈 영어; {en-ca} 캐나다 영어; {en-gb} 영국 영어; {en-ie} 아일랜드 영어; {en-jm} 자메이카 영어; {en-nz} 뉴질랜드 영어; {en-ph} 필리핀 영어; {en-tt} 트리니다드 영어; {en-us} 미국 영어; {en-za} 남아프리카 영어; {en-zw} 짐바브웨 영어.</target>
        </trans-unit>
        <trans-unit id="2fdbbad9de5ba367ca84465b4854964747407c75" translate="yes" xml:space="preserve">
          <source>Notable forms: {es-ar} Argentine Spanish; {es-bo} Bolivian Spanish; {es-cl} Chilean Spanish; {es-co} Colombian Spanish; {es-do} Dominican Spanish; {es-ec} Ecuadorian Spanish; {es-es} Spain Spanish; {es-gt} Guatemalan Spanish; {es-hn} Honduran Spanish; {es-mx} Mexican Spanish; {es-pa} Panamanian Spanish; {es-pe} Peruvian Spanish; {es-pr} Puerto Rican Spanish; {es-py} Paraguay Spanish; {es-sv} Salvadoran Spanish; {es-us} US Spanish; {es-uy} Uruguayan Spanish; {es-ve} Venezuelan Spanish.</source>
          <target state="translated">주목할만한 형태 : {es-ar} 아르헨티나 스페인어; {es-bo} 볼리비아 스페인어; {es-cl} 칠레 식 스페인어; {es-co} 콜롬비아 스페인어; {es-do} 도미니카 스페인어; {es-ec} 에콰도르 스페인어; {es-es} 스페인 스페인어; {es-gt} 과테말라 스페인어; {es-hn} 온두라스 스페인어; {es-mx} 멕시코 스페인어; {es-pa} 파나마 스페인어; {es-pe} 페루 스페인어; {es-pr} 푸에르토 리코 스페인어; {es-py} 파라과이 스페인어; {es-sv} 살바도르 스페인어; {es-us} 미국 스페인어; {es-uy} 우루과이 스페인어; {es-ve} 베네수엘라 스페인어.</target>
        </trans-unit>
        <trans-unit id="4e12474051e941f83342ef3b43136d735d5afa0d" translate="yes" xml:space="preserve">
          <source>Notable forms: {fr-fr} France French; {fr-be} Belgian French; {fr-ca} Canadian French; {fr-ch} Swiss French; {fr-lu} Luxembourg French; {fr-mc} Monaco French.</source>
          <target state="translated">주목할만한 형태 : {fr-fr} France French; {fr-be} 벨기에 프랑스어; {fr-ca} 캐나다 프랑스어; {fr-ch} 스위스 프랑스어; {fr-lu} 룩셈부르크 프랑스어; {fr-mc} 모나코 프랑스어.</target>
        </trans-unit>
        <trans-unit id="1e7e0fa3b703bb74658f81aeaba2a665c1f48d5b" translate="yes" xml:space="preserve">
          <source>Notable forms: {it-it} Italy Italian; {it-ch} Swiss Italian.</source>
          <target state="translated">주목할만한 형태 : {it-it} 이탈리아 이탈리아어; {it-ch} 스위스 이탈리아어.</target>
        </trans-unit>
        <trans-unit id="1c5cef64e650e567672b7408d2454fe4584f664d" translate="yes" xml:space="preserve">
          <source>Notable forms: {sr-Cyrl} : Serbian in Cyrillic script; {sr-Latn} : Serbian in Latin script.</source>
          <target state="translated">주목할만한 형태 : {sr-Cyrl} : 키릴 문자의 세르비아어; {sr-Latn} : 라틴어 스크립트의 세르비아어.</target>
        </trans-unit>
        <trans-unit id="b08476354345271b609310a79c55d75e3d5fa7ed" translate="yes" xml:space="preserve">
          <source>Notable forms: {sv-se} Sweden Swedish; {sv-fi} Finland Swedish.</source>
          <target state="translated">주목할만한 형태 : {sv-se} 스웨덴 스웨덴어; {sv-fi} 핀란드 스웨덴어.</target>
        </trans-unit>
        <trans-unit id="e612fd18c10ae296220917b18468a0bab3558ba5" translate="yes" xml:space="preserve">
          <source>Notable forms: {uz-Cyrl} Uzbek in Cyrillic script; {uz-Latn} Uzbek in Latin script.</source>
          <target state="translated">주목할만한 형태 : 키릴 문자로 된 {uz-Cyrl} 우즈베크 어; 라틴어 스크립트로 {uz-Latn} 우즈베크 어.</target>
        </trans-unit>
        <trans-unit id="ccdcbff00a8c92eb11dc1da19032f524f994ea4d" translate="yes" xml:space="preserve">
          <source>Notable forms: {yi-latn} Yiddish in Latin script</source>
          <target state="translated">주목할만한 형태 : {yi-latn} 라틴어 이디시어</target>
        </trans-unit>
        <trans-unit id="ce063fbcb3861605804d4088b9e6f420c033d1af" translate="yes" xml:space="preserve">
          <source>Notably, when I say &quot;the parser should do Y&quot;, the parser may fail to do Y, if the calling application explicitly requests that the parser</source>
          <target state="translated">특히, &quot;파서가 Y를 수행해야한다&quot;라고 말하면 호출 응용 프로그램이 파서에 명시 적으로 요청하면 파서는 Y를 수행하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="dc28f0d8c7871400478b567d7beb2004cf42a815" translate="yes" xml:space="preserve">
          <source>Note - The UID &amp;amp; GID are stored as 16-bit integers in the &quot;Ux&quot; field. Use &lt;code&gt;exUnixN&lt;/code&gt; if your UID or GID are 32-bit.</source>
          <target state="translated">참고-UID 및 GID는 &quot;Ux&quot;필드에 16 비트 정수로 저장됩니다. UID 또는 GID가 32 비트 인 경우 &lt;code&gt;exUnixN&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aacd35ea4ac0d783d64f4c4f2704a7fd93edbfd6" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;xs&lt;/code&gt; is the file-extension. More possibilities may arise in the future. Note that object names are specified without their XS extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f25c29f636a35a4c90bd02e8d836521729b1940" translate="yes" xml:space="preserve">
          <source>Note For File::Spec::Win32 Maintainers</source>
          <target state="translated">File :: Spec :: Win32 관리자의 경우</target>
        </trans-unit>
        <trans-unit id="d61819593fe5205b29d4ef1cfda4d5a9bf3fa4b5" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; will refuse to overwrite part of a substitution that has already been replaced; so for example this will stop after the first iteration, rather than iterating its way backwards through the string:</source>
          <target state="translated">또한 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 는 이미 교체 된 교체의 일부를 덮어 쓰지 않습니다. 예를 들어 문자열을 거꾸로 반복하는 대신 첫 번째 반복 후에 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="d431b689d39a84be2048506411832e8ae02c23d4" translate="yes" xml:space="preserve">
          <source>Note also that &lt;code&gt;s///&lt;/code&gt; will refuse to overwrite part of a substitution that has already been replaced; so for example this will stop after the first iteration, rather than iterating its way backwards through the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e8c76e1346833c7579d9c295e9f07ddedb8870" translate="yes" xml:space="preserve">
          <source>Note also that a UTF-8 &quot;invariant&quot; character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51303d3d7fafd34353273486b77b3443cc1441d4" translate="yes" xml:space="preserve">
          <source>Note also that executable files on OS/2 can have an arbitrary extension, but</source>
          <target state="translated">OS / 2의 실행 파일은 임의의 확장자를 가질 수 있지만</target>
        </trans-unit>
        <trans-unit id="86274076d108976d6c7a6912c21fbe38fd3afb11" translate="yes" xml:space="preserve">
          <source>Note also that multiple IEEE &lt;code&gt;NaN&lt;/code&gt; values are treated as duplicates of each other, regardless of any differences in their payloads, and despite the fact that &lt;code&gt;0+'NaN' == 0+'NaN'&lt;/code&gt; yields false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c1277f883a5fd92bb92e168ada01f4ed8abbf3" translate="yes" xml:space="preserve">
          <source>Note also that representing piped-command arguments in list form like this doesn't work on every platform. It will work on any Unix-based OS that provides a real &lt;code&gt;fork&lt;/code&gt; function (e.g. macOS or Linux), as well as on Windows when running Perl 5.22 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef8e44dd4ec6271a5e9810987c5e736596eec8b" translate="yes" xml:space="preserve">
          <source>Note also that some interactions with the platform's operating system never use Unicode rules.</source>
          <target state="translated">또한 플랫폼 운영 체제와의 일부 상호 작용에는 유니 코드 규칙이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df6453c563c1a21c7c65cf6fa2f8db2ed6c94f59" translate="yes" xml:space="preserve">
          <source>Note also that some versions of &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; cannot lock things over the network; you would need to use the more system-specific &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt; for that. If you like you can force Perl to ignore your system's &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt; function, and so provide its own &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt;-based emulation, by passing the switch &lt;code&gt;-Ud_flock&lt;/code&gt; to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4edd6fd44da89a951836e2357c62c606b0748a9" translate="yes" xml:space="preserve">
          <source>Note also that some versions of &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; cannot lock things over the network; you would need to use the more system-specific &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; for that. If you like you can force Perl to ignore your system's flock(2) function, and so provide its own fcntl(2)-based emulation, by passing the switch &lt;code&gt;-Ud_flock&lt;/code&gt; to the</source>
          <target state="translated">또한 일부 버전의 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 는 네트워크를 통해 물건을 잠글 수 없습니다. 이를 위해 더 많은 시스템 별 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다. 원하는 경우 Perl이 시스템의 flock (2) 함수를 무시하도록 강제 할 수 있으므로 스위치 &lt;code&gt;-Ud_flock&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="9506516245f2a27d70f794e303e94668077d4724" translate="yes" xml:space="preserve">
          <source>Note also that some versions of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; cannot lock things over the network; you would need to use the more system-specific &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; for that. If you like you can force Perl to ignore your system's flock(2) function, and so provide its own fcntl(2)-based emulation, by passing the switch &lt;code&gt;-Ud_flock&lt;/code&gt; to the</source>
          <target state="translated">또한 일부 버전의 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 는 네트워크를 통해 물건을 잠글 수 없습니다. 이를 위해 더 많은 시스템 별 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 을 사용해야합니다. 원하는 경우 Perl이 시스템의 flock (2) 함수를 무시하도록 강제 할 수 있으므로 스위치 &lt;code&gt;-Ud_flock&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="31429c82fc67ac62603cde51ce1f5c6cd992a1a1" translate="yes" xml:space="preserve">
          <source>Note also that the</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="243c26e6057ac6e495579d70e250c605534bf93f" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;&quot;p&quot;&lt;/code&gt; modifier is special in that its presence anywhere in a pattern has a global effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c84d355b563eeba64d66feb2a9301f9ac3044ba" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;p&lt;/code&gt; modifier is special in that its presence anywhere in a pattern has a global effect.</source>
          <target state="translated">참고 또한 것을 &lt;code&gt;p&lt;/code&gt; 수정은 패턴의 존재 어디서나 글로벌 효과를 갖는 것을 특별하다.</target>
        </trans-unit>
        <trans-unit id="ee56fcf5b207af918e626e9bd28811c451155208" translate="yes" xml:space="preserve">
          <source>Note also that the C++ mode build currently fails with MinGW 3.4.5 and 4.7.2 or later, and with MinGW64 64-bit 6.3.0 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f63e7551b1c1b479c5f1d972a1f2245b31f7f2" translate="yes" xml:space="preserve">
          <source>Note also that the command &lt;code&gt;perldoc perllocal&lt;/code&gt; gives you a (possibly incomplete) list of the modules that have been further installed on your system. (The perllocal.pod file is updated by the standard MakeMaker install process.)</source>
          <target state="translated">또한 &lt;code&gt;perldoc perllocal&lt;/code&gt; 명령 은 시스템에 추가로 설치된 모듈의 목록 (불완전한 목록)을 제공합니다. perllocal.pod 파일은 표준 MakeMaker 설치 프로세스에 의해 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="974ae7d8c658ab7fcbda1dde2814ab3d89d6f088" translate="yes" xml:space="preserve">
          <source>Note also that the copy constructor (key &lt;code&gt;'='&lt;/code&gt; ) may be autogenerated, but only for objects based on scalars. See &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">또한 복사 생성자 (키 &lt;code&gt;'='&lt;/code&gt; )는 자동 생성 될 수 있지만 스칼라를 기반으로하는 오브젝트에 대해서만 가능합니다. &lt;a href=&quot;#Copy-Constructor&quot;&gt;복사 생성자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92361dff5e2f10f8592eb14b0f1c0a57e0423073" translate="yes" xml:space="preserve">
          <source>Note also that the copy constructor (key &lt;code&gt;'='&lt;/code&gt;) may be autogenerated, but only for objects based on scalars. See &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d1b08cb96b172739c41421853e346d699284ca" translate="yes" xml:space="preserve">
          <source>Note also that the differences between PM and VIO executables are only in the</source>
          <target state="translated">PM과 VIO 실행 파일의 차이점은</target>
        </trans-unit>
        <trans-unit id="8a0b196123450466a3bd0e991b94e36c4a2d4091" translate="yes" xml:space="preserve">
          <source>Note also that the interpolation code needs to make a decision on where the interpolated scalar ends. For instance, whether &lt;code&gt;&quot;a $x -&amp;gt; {c}&quot;&lt;/code&gt; really means:</source>
          <target state="translated">보간 코드는 보간 된 스칼라가 끝나는 위치를 결정해야합니다. 예를 들어 &lt;code&gt;&quot;a $x -&amp;gt; {c}&quot;&lt;/code&gt; 실제로 다음을 의미 하는지 여부 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="461724a83047bdefd7b18b66a849277d50c6ddf4" translate="yes" xml:space="preserve">
          <source>Note also that the perl command-line utilities (e.g. perldoc) and any that are added by modules that you install will be under /usr/perl5/bin, so that directory should be added to your PATH.</source>
          <target state="translated">또한 perl 명령 행 유틸리티 (예 : perldoc) 및 설치 한 모듈에 의해 추가 된 유틸리티는 / usr / perl5 / bin 아래에 있으므로 디렉토리가 PATH에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b1c8981415e4845f7fa3c8120b6871be02377a53" translate="yes" xml:space="preserve">
          <source>Note also that the variable is not visible until the following</source>
          <target state="translated">또한 변수는 다음까지 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da9eb4f7f742f4aab3f9b8b74e916fc9f5d30c44" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets, except for four situations that Perl handles specially. Any subset of the ranges &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; are guaranteed to match the expected subset of ASCII characters, no matter what character set the platform is running. The fourth portable way to specify ranges is to use the &lt;code&gt;\N{...}&lt;/code&gt; syntax to specify either end point of the range. For example, &lt;code&gt;[\N{U+04}-\N{U+07}]&lt;/code&gt; means to match the Unicode code points &lt;code&gt;\N{U+04}&lt;/code&gt; , &lt;code&gt;\N{U+05}&lt;/code&gt; , &lt;code&gt;\N{U+06}&lt;/code&gt; , and &lt;code&gt;\N{U+07}&lt;/code&gt; , whatever their native values may be on the platform. Under &lt;a href=&quot;re#'strict'-mode&quot;&gt;use re 'strict'&lt;/a&gt; or within a &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(?[ ])&lt;/a&gt;, a warning is raised, if enabled, and the other end point of a range which has a &lt;code&gt;\N{...}&lt;/code&gt; endpoint is not portably specified. For example,</source>
          <target state="translated">또한 Perl이 특별히 처리하는 네 가지 상황을 제외하고는 전체 범위 아이디어가 문자 세트간에 이동하기가 다소 어렵다는 점에 유의하십시오. &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; 및 &lt;code&gt;[0-9]&lt;/code&gt; 범위의 모든 하위 집합은 플랫폼에서 실행중인 문자 집합에 관계없이 예상되는 ASCII 문자 하위 집합과 일치하도록 보장됩니다. 범위를 지정하는 네 번째 이식 가능한 방법은 &lt;code&gt;\N{...}&lt;/code&gt; 구문을 사용하여 범위의 끝점을 지정하는 것입니다. 예를 들어 &lt;code&gt;[\N{U+04}-\N{U+07}]&lt;/code&gt; 은 유니 코드 코드 포인트 &lt;code&gt;\N{U+04}&lt;/code&gt; , &lt;code&gt;\N{U+05}&lt;/code&gt; , &lt;code&gt;\N{U+06}&lt;/code&gt; 과 일치 함을 의미합니다. 및 &lt;code&gt;\N{U+07}&lt;/code&gt; , 플랫폼에서 기본 값이 무엇이든간에. 아래에&lt;a href=&quot;re#'strict'-mode&quot;&gt;re 'strict'&lt;/a&gt; 또는 &lt;a href=&quot;#(%3f%5b-%5d)&quot;&gt;(? []) 내&lt;/a&gt;, 활성화 된 경우 경고가 발생하고 &lt;code&gt;\N{...}&lt;/code&gt; 엔드 포인트가 있는 범위의 다른 엔드 포인트를 이식 가능하게 지정하지 않았습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b3c1ad83c7446d82ad768f4c14cbc6cf2bb28a0e" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect. A sound principle is to use only ranges that begin from and end at either alphabets of equal case (a-e, A-E), or digits (0-4). Anything else is unsafe. If in doubt, spell out the character sets in full.</source>
          <target state="translated">또한 전체 범위 아이디어는 문자 세트간에 이식하기가 쉽지 않으며 심지어 문자 세트에서도 예상하지 못한 결과를 초래할 수 있습니다. 올바른 원칙은 동일한 대소 문자 (ae, AE) 또는 숫자 (0-4)의 알파벳으로 시작하고 끝나는 범위 만 사용하는 것입니다. 다른 것은 안전하지 않습니다. 확실하지 않은 경우 문자 세트를 모두 철자하십시오.</target>
        </trans-unit>
        <trans-unit id="e91fc700eef8c024136a19a3d1a25e4a4aec8312" translate="yes" xml:space="preserve">
          <source>Note also that there are some basic rules to using &quot;=over&quot; ... &quot;=back&quot; regions:</source>
          <target state="translated">&quot;= over&quot;... &quot;= back&quot;영역을 사용하기위한 몇 가지 기본 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f240a6fbb992211509f6bddbfc9324c218ab462f" translate="yes" xml:space="preserve">
          <source>Note also that this is a minimum setup; you might want to add other packages of &lt;b&gt;ADE&lt;/b&gt; (the</source>
          <target state="translated">또한 이것은 최소 설정입니다. &lt;b&gt;ADE의&lt;/b&gt; 다른 패키지를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f0a8f1a21849e70b5e894c297b75fbda2be2da8" translate="yes" xml:space="preserve">
          <source>Note also that you &lt;b&gt;must&lt;/b&gt; consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value. (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)</source>
          <target state="translated">당신이 것 또한주의 &lt;b&gt;해야한다&lt;/b&gt; 원자로 인코딩 된 값을 고려; 즉, 불투명하고 분석 할 수없는 문자열 값 이외의 것으로 간주해서는 안됩니다. 언어 태그 지정 표준이 시간이 지남에 따라 변경되므로 인코딩 방법의 내부가 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bce497daf670728bb21a4272ea4f02098c78b3e" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , combining concatenation with formatting.</source>
          <target state="translated">연결을 형식화와 결합하여 &lt;code&gt;sv_catpvf&lt;/code&gt; 및 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 의 존재에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="224cbc8c1a831f9514ed249fa0fe0c7401070694" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt;, combining concatenation with formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c03a1bb63438d075c735c239a360c45cd5c5f8e" translate="yes" xml:space="preserve">
          <source>Note especially that &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; is</source>
          <target state="translated">특히 &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="5984ffc263d935d0debbee07663c497020c0e0f9" translate="yes" xml:space="preserve">
          <source>Note event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329f3fa12538d44b63cb4bc769615094799f44fc" translate="yes" xml:space="preserve">
          <source>Note for BSD users: setting &lt;code&gt;$0&lt;/code&gt; does not completely remove &quot;perl&quot; from the ps(1) output. For example, setting &lt;code&gt;$0&lt;/code&gt; to &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; (whether both the &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; prefix and the &quot; (perl)&quot; suffix are shown depends on your exact BSD variant and version). This is an operating system feature, Perl cannot help it.</source>
          <target state="translated">BSD 사용자 참고 사항 : &lt;code&gt;$0&lt;/code&gt; 설정해도 ps (1) 출력에서 ​​&quot;perl&quot;이 완전히 제거되지는 않습니다. 예를 들어, &lt;code&gt;$0&lt;/code&gt; 을 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 로 설정 하면 &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; &quot; 이 발생할 수 있습니다 ( &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; 접두사와 &quot;(perl)&quot;접미사 표시 여부는 정확한 BSD 변형 및 버전에 따라 다름). 이것은 운영 체제 기능이므로 Perl이 도와 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7293fa6262cc45f7e2dbf5481215c1d362820f1d" translate="yes" xml:space="preserve">
          <source>Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl would emulate POSIX semantics on Linux systems using LinuxThreads, a partial implementation of POSIX Threads that has since been superseded by the Native POSIX Thread Library (NPTL).</source>
          <target state="translated">Linux 및 Debian GNU / kFreeBSD 사용자를위한 참고 사항 : Perl v5.16.0 이전에는 perl이 NPTL (Native POSIX Thread Library)로 대체 된 POSIX 스레드의 부분 구현 인 LinuxThreads를 사용하여 Linux 시스템에서 POSIX 시맨틱을 에뮬레이트했습니다.</target>
        </trans-unit>
        <trans-unit id="7aea9b8c7cfe32358e543467b0f84f66f59444bc" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux 사용자를위한 참고 사항 : v5.8.1과 v5.16.0 사이에서 Perl은 POSIX 이외의 스레드 의미 체계에서 LinuxThreads를 사용하는 소수의 Linux 시스템 (및 데비안 GNU / kFreeBSD 시스템)을 처리하므로이 에뮬레이션이 제거되었습니다. 자세한 내용은 &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="cbdce38416b294a5283ce0536b64d8889c65db49" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux 사용자를위한 참고 사항 : v5.8.1과 v5.16.0 사이에서 Perl은 POSIX 이외의 스레드 의미 체계에서 LinuxThreads를 사용하는 소수의 Linux 시스템 (및 데비안 GNU / kFreeBSD 시스템)을 처리하므로이 에뮬레이션이 제거되었습니다. 자세한 내용은 &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="eb69bfe72361defc6ffb1f69be5dc9409ce2ae2e" translate="yes" xml:space="preserve">
          <source>Note how the first and last entries are protected by quotes in order to protect the spaces.</source>
          <target state="translated">공백을 보호하기 위해 첫 번째 항목과 마지막 항목을 따옴표로 보호하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b9400fb5715aebae33791834189bda7b7f0594aa" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;. That is, if you say</source>
          <target state="translated">위 표의 마지막 세 가지 예가 구문 분석기에 의해 특별히 처리되는 방법에 유의하십시오. &lt;code&gt;mygrep()&lt;/code&gt; 실제리스트 연산자로 구문 분석, &lt;code&gt;myrand()&lt;/code&gt; 단항 우선 순위와 같은과 진정한 단항 연산자로 해석됩니다 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ,과 &lt;code&gt;mytime()&lt;/code&gt; 단지 같은 인수없이 진정으로 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; . 즉, 당신이 말하면</target>
        </trans-unit>
        <trans-unit id="cdc635a59a5a874516823dc99b8a94c5e05a2fb1" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;time()&lt;/code&gt;. That is, if you say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d61faf03809511f3cea1cbe82aa61f0b9ca92a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; being called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 가 호출 되지 않도록 사용자 pragma &lt;code&gt;myint&lt;/code&gt; 를 빈 목록 &lt;code&gt;()&lt;/code&gt; 으로 로드하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee3224d5b447023fa11e54a3bfa8eb9adee42e7a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;import&lt;/code&gt; being called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c06a27ee940fb1ce392065b6dccdd03fd73088" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">그러나 일부 내장 기능은 프로토 타입 ( &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 등)으로 표현 된 구문을 가질 수 없습니다 . 그것들을 재정의하면 원래 구문을 완전히 모방 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7efc6d20035a67bd96018a6137a333a9fd4a32a" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;chomp&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4aeaafb27edb37453c0434b81658b1a8e907549" translate="yes" xml:space="preserve">
          <source>Note however that these versions will not behave as nicely in scalar context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7440d14152f809ce4da1ad00d96fe84e5f29c7fb" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;&quot;Pdksh&quot;&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;&quot;Frequently asked questions&quot;&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210da70db6283ccd39e5584b10f4c87c0f89d9d6" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Frequently asked questions&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">그러나이 연산자 중 일부를 사용하려면 sh-syntax shell이 ​​설치되어 있어야하고 ( &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt; , &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;자주 묻는 질문 참조&lt;/a&gt; ) perl &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;이이&lt;/a&gt; 를 찾을 수 있어야합니다 ( PERL_SH_DIR 참조 ).</target>
        </trans-unit>
        <trans-unit id="6cd6d4fe1827d7816f9b8f3e1b0034bce7c56311" translate="yes" xml:space="preserve">
          <source>Note however, that this function does an exact match using &lt;code&gt;eq&lt;/code&gt; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</source>
          <target state="translated">그러나이 함수는 전체 경로에서 &lt;code&gt;eq&lt;/code&gt; 를 사용하여 정확하게 일치 합니다. 따라서 대소 문자를 구분하지 않는 파일 시스템을 보완하거나 2 개의 경로를 비교하여 동일한 기본 파일을 가리키는 지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e19273a97b7ee5052886f577d9a46a4421684819" translate="yes" xml:space="preserve">
          <source>Note however, that you need to have</source>
          <target state="translated">그러나, 당신은 가지고 있어야합니다</target>
        </trans-unit>
        <trans-unit id="507e6816311ba5923485459a746f4c205372d3f9" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">지정하면 주 &lt;code&gt;-&lt;/code&gt; 명령으로, 유사한 방식으로 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; 자식 프로세스 그냥 갈래 펄 처리가 아닌 외부 명령이 될 것입니다. 이 기능은 아직 Win32 플랫폼에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e2cd3813c47d5570ed4f20adb47fcd58c86c5c" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;open(my $fh, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9342b413d4bbcd1dc6fe59e3ee28645b823224" translate="yes" xml:space="preserve">
          <source>Note in the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">마지막 예에서 문자열의 끝은 단어 경계로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="07e19a6ca0b876d2709ab0ec0dfc79383c491dc1" translate="yes" xml:space="preserve">
          <source>Note on ISO-2022-JP(-1)?</source>
          <target state="translated">ISO-2022-JP (-1)에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4950ea862c3beae92921259b5ea2a7679f983598" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;&quot;BUGS AND PITFALLS&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88ed054c638a5f7768e2dd282a5e1b35bab783a" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;BUGS AND PITFALLS&lt;/a&gt;.</source>
          <target state="translated">7 단계 참고 사항 : 일부 연산자는 피연산자의 유형에 따라 다른 의미를 갖습니다. 예를 들어 문자열 대신 숫자로 피연산자를 처리하도록 Perl에 지시 할 수있는 방법이 없으므로 여기서 결과가 예상과 다를 수 있습니다. &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;버그와 함정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15bc1023efea2381a2db802c419cf3e98569e03f" translate="yes" xml:space="preserve">
          <source>Note on the format of the urllist parameter</source>
          <target state="translated">urllist 매개 변수의 형식에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="cc738b8cb2fe5493887c63f096423e4e822a4785" translate="yes" xml:space="preserve">
          <source>Note particularly that $x continues to refer to the value passed into newprint()</source>
          <target state="translated">특히 $ x는 newprint ()에 전달 된 값을 계속 참조합니다.</target>
        </trans-unit>
        <trans-unit id="977ff75717e2ad5549c27c1fec3fb1a8727cd2e9" translate="yes" xml:space="preserve">
          <source>Note several important features of this example. First of all, the</source>
          <target state="translated">이 예제의 몇 가지 중요한 기능에 유의하십시오. 우선,</target>
        </trans-unit>
        <trans-unit id="8d22a2ef918195af9fe48ae6fe3621002cfec585" translate="yes" xml:space="preserve">
          <source>Note specifically in the case that the list is already empty, &lt;code&gt;mark&lt;/code&gt; will equal &lt;code&gt;PL_stack_sp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e563f06c888e88271ecc5783df82aad24c908977" translate="yes" xml:space="preserve">
          <source>Note specifically that SV pointers on the value stack do not contribute to the overall reference count of the xVs being referred to. If newly-created xVs are being pushed to the stack you must arrange for them to be destroyed at a suitable time; usually by using one of the &lt;code&gt;mPUSH*&lt;/code&gt; macros or &lt;code&gt;sv_2mortal()&lt;/code&gt; to mortalise the xV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e506d24bb1d2d8c0953ced78837622f6175e3d" translate="yes" xml:space="preserve">
          <source>Note that &quot;&amp;lt;&amp;amp;STDIN&quot; makes a copy, but &quot;&amp;lt;&amp;amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</source>
          <target state="translated">&quot;&amp;lt;&amp;amp; STDIN&quot;은 복사본을 만들지 만 &quot;&amp;lt;&amp;amp; = STDIN&quot;은 별칭을 만듭니다. 즉, 별칭 처리 된 핸들을 닫으면 모든 별칭에 액세스 할 수 없게됩니다. 이것은 복사 된 것은 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8b99f4b81966ee04ac35bb63df371e65272f50e3" translate="yes" xml:space="preserve">
          <source>Note that &quot;alpha&quot; version objects (where the version string contains a trailing underscore segment) compare as less than the equivalent version without an underscore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760e35c71509b97a49875e6fc164a9d4be791312" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . E.g.,</source>
          <target state="translated">$ x는 여전히 정수가 아닌 5.8의 값으로 작동하지 않았으므로 여전히 인쇄됩니다. 그리고 가장 큰 양의 정수에서 가장 큰 음의 정수로의 랩 어라운드도 주목하십시오. 또한 함수에 전달 된 인수와 그에 의해 반환되는 값은 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;사용의&lt;/a&gt; 영향을받지 &lt;b&gt;않습니다 &lt;/b&gt;. . 예 :</target>
        </trans-unit>
        <trans-unit id="d8269433400ad0b6edc5ad3382abffca519f241b" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;use integer;&lt;/code&gt;. E.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e599f385e86c967c815cb5ac633fbf5c8b743e32" translate="yes" xml:space="preserve">
          <source>Note that &amp;lt;FILE&amp;gt; is</source>
          <target state="translated">&amp;lt;FILE&amp;gt;은</target>
        </trans-unit>
        <trans-unit id="ae365970981ca6f4f0ae8ce0570b2cbd5480afa9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; returns the last character. To return all but the last character, use &lt;code&gt;substr($string, 0, -1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4044113059cc30bd1d9822bf229d1fd6518f819" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9dcf768d88acd6e9245dc33c6d534334d98435" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt; raises an exception if used on a machine that doesn't implement &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt;. See the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module or your &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; manpage to learn what functions are available on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac11071b2447bfeff67f1ad413aafb72592d54ad" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;glob(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2247c7b4f4b47f7aa53f8ef346d558c46baa5e4f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;&quot;make_iterator&quot;&lt;/a&gt; has been</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28b0b3d67592306ce241a091fd7fa4b9b9390b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; has been</source>
          <target state="translated">참고 &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator가&lt;/a&gt; 있다</target>
        </trans-unit>
        <trans-unit id="d5449cbba5d5e7a82db88f55e4440d98e4342ea0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader는&lt;/a&gt; 그것을 호출해야합니다 특별한 케이스입니다 &lt;code&gt;boot_DynaLoader&lt;/code&gt; 을 직접.</target>
        </trans-unit>
        <trans-unit id="b80b3ef08be16efffcb210c1f8271336ce263029" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0526d5d85fc0534ff6f7d2f9105c957dadfacb23" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt;, &lt;a href=&quot;#map-BLOCK-LIST&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; or another &lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/a&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d74fe4c4d980bb13b58d3feb16b0acc19c76fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/a&gt; for a list composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b414b3045e4a13e62684509b81beee13f1a03b" translate="yes" xml:space="preserve">
          <source>Note that &lt;b&gt;-S&lt;/b&gt; switch supports scripts with additional extensions</source>
          <target state="translated">참고 &lt;b&gt;-S&lt;/b&gt; 추가 확장과 스위치가 지원하는 스크립트</target>
        </trans-unit>
        <trans-unit id="df5cabe56a3fab1a8dfd7142a90c482f8fae0efd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; has lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">하는 것으로는 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 그래서 예를 들어 괄호 같은 시험에 필수적이다, 관계 연산자보다 우선 순위가</target>
        </trans-unit>
        <trans-unit id="6fb0ba015a70a1ecbbac6efb61ce95fa86c8c327" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt; variable if scripts are not careful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522782427bfce1d8f14995dfc30aaa97199ffa5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;code&gt;$.&lt;/code&gt; if scripts are not careful.</source>
          <target state="translated">참고 &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; 과의 두 번째 단계 것을 &lt;code&gt;$&lt;/code&gt; 정규식에서 보간 파울의 떨어질 것이다 &lt;code&gt;$.&lt;/code&gt; 스크립트가주의하지 않으면</target>
        </trans-unit>
        <trans-unit id="12ecea42a6af74c63b7121532319090437ea634b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;|&quot;&lt;/code&gt; and &lt;code&gt;&quot;^&quot;&lt;/code&gt; have lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">참고 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 그래서 예를 들어 괄호 같은 시험에 필수적이다, 관계 연산자보다 우선 순위가</target>
        </trans-unit>
        <trans-unit id="79eafdbed824b09455353e30518fbddb877197c5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것은 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 마찬가지로 grep은 for 루프의 인덱스 변수가 목록 요소를 별칭으로 지정하는 것처럼 별칭을 원래 목록으로 반환합니다. 즉, grep에서 리턴 한 목록의 요소 (예 : &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 다른 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )를 수정하면 실제로 원래 목록의 요소가 수정됩니다. 이것은 일반적으로 명확한 코드를 작성할 때 피해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="922c04cd95d993e5139c2b97058698400e67f636" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">참고 것을 &lt;code&gt;$_&lt;/code&gt; 이 목록의 요소를 수정하는 데 사용할 수 있도록 목록 값의 별칭입니다. 이것은 유용하고 지원되지만 LIST의 요소가 변수가 아닌 경우 기괴한 결과가 발생할 수 있습니다. 마찬가지로 grep은 for 루프의 인덱스 변수가 목록 요소를 별칭으로 지정하는 것처럼 별칭을 원래 목록으로 반환합니다. 즉, grep에서 리턴 한 목록의 요소 (예 : &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 또는 다른 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )를 수정하면 실제로 원래 목록의 요소가 수정됩니다. 이것은 일반적으로 명확한 코드를 작성할 때 피해야 할 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
