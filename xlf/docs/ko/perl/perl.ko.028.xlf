<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="09e18333d92450e41ab304a7813502d7248c06a7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e2116155b494da50686ee8fd22c6f8af75259f" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;List::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">기본적으로 &lt;code&gt;List::Util&lt;/code&gt; 은 서브 루틴을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c8967b9c380cc8af7979a94b2f6e12071d5756c" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Scalar::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">기본적으로 &lt;code&gt;Scalar::Util&lt;/code&gt; 은 서브 루틴을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a85c45889f6bd96a07b3072c70fdac86872c8e7" translate="yes" xml:space="preserve">
          <source>By default CPAN Meta specification &lt;code&gt;1.4&lt;/code&gt; is used. In order to use CPAN Meta specification &lt;code&gt;2.0&lt;/code&gt; , indicate with &lt;code&gt;meta-spec&lt;/code&gt; the version you want to use.</source>
          <target state="translated">기본적으로 CPAN 메타 사양 &lt;code&gt;1.4&lt;/code&gt; 가 사용됩니다. CPAN 메타 사양 사용하려면 &lt;code&gt;2.0&lt;/code&gt; 으로 표시 &lt;code&gt;meta-spec&lt;/code&gt; 사용하려는 버전.</target>
        </trans-unit>
        <trans-unit id="ec5e42a7b49114e39a5cf2d863170e1a8e680a55" translate="yes" xml:space="preserve">
          <source>By default CPAN Meta specification &lt;code&gt;1.4&lt;/code&gt; is used. In order to use CPAN Meta specification &lt;code&gt;2.0&lt;/code&gt;, indicate with &lt;code&gt;meta-spec&lt;/code&gt; the version you want to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4b99182796026a411ed2b60fe38baf518d32a5" translate="yes" xml:space="preserve">
          <source>By default Perl assumes your source code is written in an 8-bit ASCII superset. To embed Unicode characters in your strings and regexes, you can use the &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&lt;code&gt;\x{HH}&lt;/code&gt; or (more portably) &lt;code&gt;\N{U+HH}&lt;/code&gt; notations&lt;/a&gt;. You can also use the &lt;a href=&quot;utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; pragma and write your code in UTF-8, which lets you use Unicode characters directly (not just in quoted constructs but also in identifiers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc161a96f1f3872cf0bfff0e6212dcccea74651" translate="yes" xml:space="preserve">
          <source>By default Perl does not use the &lt;code&gt;malloc()&lt;/code&gt; included with the Perl source, because it was slower and not entirely thread-safe. If you want to force Perl to build with the old -Dusemymalloc define this.</source>
          <target state="translated">기본적으로 Perl 은 느리고 전적으로 스레드 안전하지 않기 때문에 Perl 소스에 포함 된 &lt;code&gt;malloc()&lt;/code&gt; 사용하지 않습니다 . 펄이 이전 -Dusemymalloc으로 빌드하도록하려면 이것을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="1261dc25c0b95e8495b666b1c3497fb4bd944f86" translate="yes" xml:space="preserve">
          <source>By default Perl uses 64 bit integers. If you want to use smaller 32 bit integers, define this symbol.</source>
          <target state="translated">기본적으로 Perl은 64 비트 정수를 사용합니다. 더 작은 32 비트 정수를 사용하려면이 기호를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8741f41b3847fc8e6d6ed4c668a3b8923660d9" translate="yes" xml:space="preserve">
          <source>By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML. You can change it by calling</source>
          <target state="translated">기본적으로 Pod :: Simple :: HTML은 HTML 맨 위에 더미 앵커를 추가합니다. 전화로 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="85488345da8d50d7c72f406a26800d51eab1277e" translate="yes" xml:space="preserve">
          <source>By default an instance of &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt; is created and used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d675d5fb6fc8fe769b7759c86a5571aae789b8" translate="yes" xml:space="preserve">
          <source>By default floating point numbers substituted inside strings use the dot (&quot;.&quot;) as the decimal separator. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, and POSIX::setlocale() has been called, the character used for the decimal separator is affected by the LC_NUMERIC locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">기본적으로 문자열 안에서 대체되는 부동 소수점 숫자는 점 ( &quot;.&quot;)을 소수점 구분 기호로 사용합니다. 경우 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 효과이며, POSIX :: setlocale에 ()가 호출되어, 소수 세퍼레이터에 사용하는 문자는 LC_NUMERIC 로케일에 의해 영향을 받는다. &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; 및 &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c28be1fa0adbeea2fa914132ae148c766307022e" translate="yes" xml:space="preserve">
          <source>By default floating point numbers substituted inside strings use the dot (&quot;.&quot;) as the decimal separator. If &lt;code&gt;use locale&lt;/code&gt; is in effect, and POSIX::setlocale() has been called, the character used for the decimal separator is affected by the LC_NUMERIC locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dadc258ff54a1a05b69b778084fc2dfc7494a970" translate="yes" xml:space="preserve">
          <source>By default it does nothing.</source>
          <target state="translated">기본적으로 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4033d9fb012c9ab68d72ab1a3b85a5a59eb68724" translate="yes" xml:space="preserve">
          <source>By default it just prints the stubs, but you can set the global $Devel::SelfStubber::JUST_STUBS to 0 and it will print out the entire module with the stubs positioned correctly.</source>
          <target state="translated">기본적으로 스텁 만 인쇄하지만 전역 $ Devel :: SelfStubber :: JUST_STUBS를 0으로 설정하면 스텁이 올바르게 배치 된 전체 모듈이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cfe07b0874e5c860a9ad1e8fd1566639cad34f" translate="yes" xml:space="preserve">
          <source>By default it writes to &lt;code&gt;cwd()&lt;/code&gt; , but you can override that by specifying the &lt;code&gt;to&lt;/code&gt; argument:</source>
          <target state="translated">기본적으로 &lt;code&gt;cwd()&lt;/code&gt; 기록 하지만 다음을 지정하여이를 무시할 수 있습니다. &lt;code&gt;to&lt;/code&gt; 인수 이를 .</target>
        </trans-unit>
        <trans-unit id="134aa142740eea63e3f7d4209036922ec9993924" translate="yes" xml:space="preserve">
          <source>By default it writes to &lt;code&gt;cwd()&lt;/code&gt;, but you can override that by specifying the &lt;code&gt;to&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f383cfebdc1979faf03798a39be5be086b2b22" translate="yes" xml:space="preserve">
          <source>By default listeners are not inherited by child hubs. That means if you start a subtest, the subtest will not inherit the listener. You can change this behavior with the &lt;code&gt;inherit&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c6146d97f6523b1856790ae4b8a285b8e3db7e" translate="yes" xml:space="preserve">
          <source>By default no Unix2 extra field is created.</source>
          <target state="translated">기본적으로 Unix2 추가 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ab606593d4a9d45e75e4256f15600160e7bc2fa" translate="yes" xml:space="preserve">
          <source>By default no UnixN extra field is created.</source>
          <target state="translated">기본적으로 UnixN 추가 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee18fc042b3c569119417a51774089c404eb248f" translate="yes" xml:space="preserve">
          <source>By default no extended time field is created.</source>
          <target state="translated">기본적으로 확장 시간 필드는 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebb685a0031880a3b5e0df98008f367fed554c4e" translate="yes" xml:space="preserve">
          <source>By default no opmask is in effect and any code can be compiled.</source>
          <target state="translated">기본적으로 opmask는 적용되지 않으며 모든 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a6e64907872a01e02add6a8ea23d69c4a6e77e" translate="yes" xml:space="preserve">
          <source>By default only the &lt;code&gt;langinfo()&lt;/code&gt; function is exported.</source>
          <target state="translated">기본적으로 &lt;code&gt;langinfo()&lt;/code&gt; 함수 만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="05fbe13f9e04e93defd0bc70b90e12a9f8b88b6a" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;TAP::Parser::SourceHandler::Executable&quot;&gt;TAP::Parser::SourceHandler::Executable&lt;/a&gt; class will create a &lt;a href=&quot;TAP::Parser::Iterator::Process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; object to handle the source. This passes the array reference strings as command arguments to &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3::open3&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98ec28c38227dc5b1c1a5373143946764c67c67" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP::Parser::SourceHandler::Executable&lt;/a&gt; class will create a &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; object to handle the source. This passes the array reference strings as command arguments to &lt;a href=&quot;../ipc/open3&quot;&gt;IPC::Open3::open3&lt;/a&gt;:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP :: Parser :: SourceHandler :: Executable&lt;/a&gt; 클래스는 소스를 처리 할 &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt; 객체를 만듭니다. 이것은 배열 참조 문자열을 &lt;a href=&quot;../ipc/open3&quot;&gt;IPC :: Open3 :: open3에&lt;/a&gt; 명령 인수로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="a48220280114a78503f2a2001b0a32eddecb9d87" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; and &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">기본적으로 사용되는 &lt;code&gt;flush_type&lt;/code&gt; 은 &lt;code&gt;Z_FINISH&lt;/code&gt; 입니다. &lt;code&gt;flush_type&lt;/code&gt; 의 다른 유효한 값 은 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; 및 &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 입니다. &lt;code&gt;flush_type&lt;/code&gt; 매개 변수의 영향을 완전히 이해 한 경우 에만 flush_type 매개 변수를 설정하는 것이 좋습니다 . 자세한 내용은 &lt;code&gt;zlib&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61c7b1cbe3af3e79bbf82957644e90bd2966ab80" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt;. Other valid values for &lt;code&gt;flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt;, &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt;, &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; and &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt;. It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a328506dc208738ad9d028668747611624fc18" translate="yes" xml:space="preserve">
          <source>By default the Makefile produced includes all the static extensions in the perl library. (Purified versions of library files, e.g., DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)</source>
          <target state="translated">기본적으로 생성 된 Makefile에는 perl 라이브러리의 모든 정적 확장자가 포함됩니다. (링크 된 오류를 피하기 위해 DynaLoader_pure_p1_c0_032.a와 같은 라이브러리 파일의 정제 된 버전은 자동으로 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="72406ce9b9b1b9e64fd6ddb212ef0d9f15de7828" translate="yes" xml:space="preserve">
          <source>By default the debugger is called using &lt;code&gt;-d&lt;/code&gt; option to perl. If you want to specify some other option, set the &lt;code&gt;TESTDB_SW&lt;/code&gt; variable:</source>
          <target state="translated">기본적으로 디버거는 &lt;code&gt;-d&lt;/code&gt; 옵션을 사용 하여 perl에 호출됩니다 . 다른 옵션을 지정하려면 &lt;code&gt;TESTDB_SW&lt;/code&gt; 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2356cae1189c23be90e67a7d45b9477ad72051f" translate="yes" xml:space="preserve">
          <source>By default the directory is deleted when the object goes out of scope.</source>
          <target state="translated">기본적으로 개체가 범위를 벗어나면 디렉터리가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf770fbcc502baf26e331b84104d6aaf9126f59" translate="yes" xml:space="preserve">
          <source>By default the layers from the input side of the filehandle are returned; to get the output side, use the optional &lt;code&gt;output&lt;/code&gt; argument:</source>
          <target state="translated">기본적으로 파일 핸들의 입력 측에서 레이어가 반환됩니다. 출력 측을 얻으려면 선택적 &lt;code&gt;output&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c002101ab1a0ef760a6cd97c38ea179cd0ee30e5" translate="yes" xml:space="preserve">
          <source>By default this hash is only filled with the environment variables out of %ENV that start with &lt;code&gt;PERL&lt;/code&gt;, but you can pass the &lt;code&gt;env&lt;/code&gt; option to myconfig to get more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f25f3b77d3062c86a659cbc91ff07ea769bf59" translate="yes" xml:space="preserve">
          <source>By default this will include *.pm and *.pl and the files found in the PMLIBDIRS directories. Defining PM in the Makefile.PL will override PMLIBDIRS.</source>
          <target state="translated">기본적으로 여기에는 * .pm 및 * .pl과 PMLIBDIRS 디렉토리에있는 파일이 포함됩니다. Makefile.PL에서 PM을 정의하면 PMLIBDIRS가 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1c14ce64b17e700de893a0b00ad2e97e494dcfd4" translate="yes" xml:space="preserve">
          <source>By default verbose output is generated, setting the PERL_INSTALL_QUIET environment variable will silence this output.</source>
          <target state="translated">기본적으로 상세 출력이 생성되며 PERL_INSTALL_QUIET 환경 변수를 설정하면이 출력이 침묵합니다.</target>
        </trans-unit>
        <trans-unit id="4e63e74d2a508a1a33c3e1bb5754226ab9609082" translate="yes" xml:space="preserve">
          <source>By default your system's F_* and O_* constants (eg, F_DUPFD and O_CREAT) and the FD_CLOEXEC constant are exported into your namespace.</source>
          <target state="translated">기본적으로 시스템의 F_ * 및 O_ * 상수 (예 : F_DUPFD 및 O_CREAT)와 FD_CLOEXEC 상수는 네임 스페이스로 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="d7781baa84d2aa71913f24b53d017427c0b16792" translate="yes" xml:space="preserve">
          <source>By default zipdetails will output the details of the zip file in three columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44b2a95f6381a248195f00274a8435d100aaa35" translate="yes" xml:space="preserve">
          <source>By default,</source>
          <target state="translated">기본적으로,</target>
        </trans-unit>
        <trans-unit id="6d88a1aadef2616cc309d3135c3c0ad225e5d689" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; will be used for deserializing YAML data. If the &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; environment variable is defined, then it is interpreted as a module to use for deserialization. The given module must be installed, must load correctly and must implement the &lt;code&gt;Load()&lt;/code&gt; function or an exception will be thrown.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; 은 YAML 데이터를 직렬화 해제하는 데 사용됩니다. 는 IF &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; 의 환경 변수가 정의되고, 다음은 직렬화 복원에 사용하는 모듈로 해석됩니다. 주어진 모듈이 설치되어 있고 올바르게로드되어야하며 &lt;code&gt;Load()&lt;/code&gt; 함수를 구현해야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a9ce14085141d2bedbc81e908e7a8dd19fcc292a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../json/pp&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; . If &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../../json/pp&quot;&gt;JSON :: PP&lt;/a&gt; 는 JSON 데이터를 직렬화 해제하는 데 사용됩니다. 는 IF &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 의 환경 변수가 존재, 사실 다음 &quot;JSON :: PP&quot;아니다 &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON의&lt;/a&gt; 모듈 (버전 2.5 이상)로드하고 해석하는 데 사용됩니다 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 을 . 경우 &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON을&lt;/a&gt; 설치하거나 너무 오래되지 않은 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="babd48f1acbcf2cefafda1f4e072d38c1d9be88a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;CPAN::Meta::YAML&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; will be used for deserializing YAML data. If the &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; environment variable is defined, then it is interpreted as a module to use for deserialization. The given module must be installed, must load correctly and must implement the &lt;code&gt;Load()&lt;/code&gt; function or an exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91507ffd77a8c68ad696f119dae98dd6eab9b326" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; (the &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;send_or_die&lt;/code&gt; methods use this under the hood) will try &lt;code&gt;sendmail&lt;/code&gt; first, if it exists in your $PATH. This generally isn't the case. If there's a remote mail server you use to send mail, consider investigating one of the Transport classes. At time of writing, the available transports include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951a27293b21723e13facff91a05ad645f4b8b59" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; environment variable exists, this is expected to be the name of a loadable module that provides the &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; API, since downstream code expects to be able to call &lt;code&gt;new&lt;/code&gt; on this class. As such, while &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt;, &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt;, &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt; and &lt;a href=&quot;JSON::MaybeXS&quot;&gt;JSON::MaybeXS&lt;/a&gt; will work for this, to use &lt;a href=&quot;Mojo::JSON&quot;&gt;Mojo::JSON&lt;/a&gt; or &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt; for decoding requires setting &lt;a href=&quot;#CPAN_META_JSON_DECODER&quot;&gt;&quot;CPAN_META_JSON_DECODER&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2cca244c4dee51baa96e422675f44c6c00f8ee" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;CPAN_META_JSON_DECODER&lt;/code&gt; environment variable exists, this is expected to be the name of a loadable module that provides a &lt;code&gt;decode_json&lt;/code&gt; subroutine, which will then be used for deserialization. Relying only on the existence of said subroutine allows for maximum compatibility, since this API is provided by all of &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt;, &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt;, &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, &lt;a href=&quot;JSON::MaybeXS&quot;&gt;JSON::MaybeXS&lt;/a&gt;, &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, and &lt;a href=&quot;Mojo::JSON&quot;&gt;Mojo::JSON&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a294e48ade56dbe097d94ecb2d017b667469c8" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; will try `sendmail` first, if it exists in your $PATH. This generally isn't the case. If there's a remote mail server you use to send mail, consider investigating one of the Transport classes. At time of writing, the available transports include:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple&lt;/a&gt; 은 $ path에`sendmail`을 먼저 시도합니다. 일반적으로 그렇지 않습니다. 메일을 보내는 데 사용하는 원격 메일 서버가 있으면 Transport 클래스 중 하나를 조사하십시오. 작성 당시 사용 가능한 운송 수단은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d72ee058cb3ba5edce2a08b405dc90217d0eada0" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;Locale::Maketext::Simple&lt;/b&gt; draws its source from the calling package's</source>
          <target state="translated">기본적으로 &lt;b&gt;Locale :: Maketext :: Simple&lt;/b&gt; 은 호출 패키지의 소스에서 소스를 그립니다.</target>
        </trans-unit>
        <trans-unit id="35fc08f26016b44845e97a461120088a4d635511" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2man&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2man&lt;/b&gt; 은 POD 입력에서 오류가 감지되면 죽습니다. 경우 &lt;b&gt;--stderr이&lt;/b&gt; 주어지고 더있다 &lt;b&gt;--errors의&lt;/b&gt; 플래그가없는 오류가 표준 오류로 전송되지만 &lt;b&gt;pod2man은&lt;/b&gt; 중단하지 않습니다. 이것은 &lt;code&gt;--errors=stderr&lt;/code&gt; 와 동일 하며 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="30d3609c8a43f768f52510e95fef029cac6273de" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">기본적으로, &lt;b&gt; pod2man&lt;/b&gt; 은 가능한 많은 다른 * roff 구현과 작동하도록하기 위해 가장 보수적 인 * roff 출력을 생성합니다. 많은 * roff 구현은 비 ASCII 문자를 처리 할 수 ​​없으므로 모든 비 ASCII 문자가 올바르게 강조된 문자를 작성하는 (* 최소 troff 출력의 경우) * roff 이스케이프 시퀀스로 변환되거나 &lt;code&gt;X&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="6c802c27acda71e33b3944a76fe3f254627c5e35" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7337f82d45ceca3575dcc4fcaada9bab5f7a5ae" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2text&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">POD 입력에서 오류가 감지되면 기본적으로 &lt;b&gt;pod2text는&lt;/b&gt; 죽습니다. 경우 &lt;b&gt;--stderr이&lt;/b&gt; 주어지고 더있다 &lt;b&gt;--errors의&lt;/b&gt; 플래그가없는 오류가 표준 오류로 전송되지만,&lt;b&gt; pod2text은&lt;/b&gt; 중단하지 않습니다. 이것은 &lt;code&gt;--errors=stderr&lt;/code&gt; 와 동일 하며 이전 버전과의 호환성을 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d98831aaac5ae8bfa863600541ce748cdfa2ce" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; tries to use the same output encoding as its input encoding (to be backward-compatible with older versions). This option says to instead force the output encoding to UTF-8.</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2text&lt;/b&gt; 는 입력 인코딩과 동일한 출력 인코딩을 사용하려고합니다 (이전 버전과 역 호환 가능). 이 옵션은 출력 인코딩을 UTF-8로 강제 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f53f148127af7bd5af025188de73dc79a271f7fe" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2usage()&lt;/b&gt; will use &lt;code&gt;$0&lt;/code&gt; as the path to the pod input file. Unfortunately, not all systems on which Perl runs will set &lt;code&gt;$0&lt;/code&gt; properly (although if &lt;code&gt;$0&lt;/code&gt; isn't found, &lt;b&gt;pod2usage()&lt;/b&gt; will search &lt;code&gt;$ENV{PATH}&lt;/code&gt; or else the list specified by the &lt;code&gt;-pathlist&lt;/code&gt; option). If this is the case for your system, you may need to explicitly specify the path to the pod docs for the invoking script using something similar to the following:</source>
          <target state="translated">기본적으로 &lt;b&gt;pod2usage ()&lt;/b&gt; 는 &lt;code&gt;$0&lt;/code&gt; 를 포드 입력 파일의 경로로 사용 합니다. 불행히도 Perl이 실행되는 모든 시스템이 &lt;code&gt;$0&lt;/code&gt; 올바르게 설정 하지는 않습니다 ( &lt;code&gt;$0&lt;/code&gt; 찾을 수 없더라도 &lt;b&gt;pod2usage ()&lt;/b&gt; 는 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 또는 &lt;code&gt;-pathlist&lt;/code&gt; 옵션으로 지정된 목록을 검색합니다 ). 시스템에 해당하는 경우 다음과 유사한 것을 사용하여 호출 스크립트에 대한 포드 문서의 경로를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="139ad65b1f5c08871019f97feca04f36c4d7791f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &lt;code&gt;tar&lt;/code&gt; to store files. For paths greater than 100 characters, this is done using the &lt;code&gt;POSIX header prefix&lt;/code&gt; . Non-POSIX-compatible clients may not support this part of the specification, and may only support the &lt;code&gt;GNU Extended
Header&lt;/code&gt; functionality. To facilitate those clients, you can set the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; . See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section for details on this variable.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 완전히 POSIX 호환 모드에 있으며 파일의 저장 에 &lt;code&gt;tar&lt;/code&gt; 의 POSIX 사양 을 사용합니다. 100자를 초과하는 경로의 경우 &lt;code&gt;POSIX header prefix&lt;/code&gt; 사용하여 수행됩니다 . POSIX 호환이 아닌 클라이언트는이 사양 부분을 지원하지 않을 수 있으며 &lt;code&gt;GNU Extended Header&lt;/code&gt; 기능 만 지원할 수 있습니다. 이러한 클라이언트를 용이하게하기 위해 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 이 변수에 대한 자세한 내용은 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="22d3080e984d27612f64abae1b1cd500724525a5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &lt;code&gt;tar&lt;/code&gt; to store files. For paths greater than 100 characters, this is done using the &lt;code&gt;POSIX header prefix&lt;/code&gt;. Non-POSIX-compatible clients may not support this part of the specification, and may only support the &lt;code&gt;GNU Extended Header&lt;/code&gt; functionality. To facilitate those clients, you can set the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section for details on this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ce25419277d6adf6e0c4949f8ca8dca00cd62d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;-ing.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 파일을 아카이브의 특정 파일에 지정된 모드로 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 하려고 시도합니다 . 경우에 따라 원하지 않을 수도 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; -ing 을 비활성화 하려면이 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb67a5af923530004ebe769a16f96c44f7d23600" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;-ing, even if it were possible.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 가능한 경우 파일 을 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 시도 합니다. 경우에 따라 원하지 않을 수도 있습니다. 이 경우 가능하면 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; -ing 을 비활성화 하려면이 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="06e25549a7c661c31580c21cab9b2e4174ef8ab8" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;chmod&lt;/code&gt; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;chmod&lt;/code&gt;-ing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebe21c0c6c50ca514eb93d2e374500f1bce8cfb" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;chown&lt;/code&gt; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;chown&lt;/code&gt;-ing, even if it were possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46faa893a6a331982326586cd0db0d3a2c1dfbd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to put paths that are over 100 characters in the &lt;code&gt;prefix&lt;/code&gt; field of your tar header, as defined per POSIX-standard. However, some (older) tar programs do not implement this spec. To retain compatibility with these older or non-POSIX compliant versions, you can set the &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; variable to a true value, and &lt;code&gt;Archive::Tar&lt;/code&gt; will use an alternate way of dealing with paths over 100 characters by using the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature.</source>
          <target state="translated">기본적으로 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 POSIX 표준에 정의 된대로 tar 헤더 의 &lt;code&gt;prefix&lt;/code&gt; 필드에 100 자 이상의 경로를 넣으려고합니다 . 그러나 일부 (이전) tar 프로그램은이 사양을 구현하지 않습니다. 이러한 이전 또는 비 POSIX 호환 버전과의 호환성을 유지하기 위해 &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; 변수를 true로 설정 하고 &lt;code&gt;Archive::Tar&lt;/code&gt; 는 &lt;code&gt;GNU Extended Header&lt;/code&gt; 기능 을 사용하여 100 자 이상의 경로를 처리하는 다른 방법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ca08f9f1e5aebac60920c9f0bab0c8d5475cdd53" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Sys::Syslog&lt;/code&gt; exports the symbols from the &lt;code&gt;:standard&lt;/code&gt; tag.</source>
          <target state="translated">기본적으로 &lt;code&gt;Sys::Syslog&lt;/code&gt; 는 &lt;code&gt;:standard&lt;/code&gt; 태그 에서 기호를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="ea04cfd93bdf64370c1cc20e848935f755855d27" translate="yes" xml:space="preserve">
          <source>By default, CJK unified ideographs are ordered in Unicode codepoint order, but those in the CJK Unified Ideographs block are less than those in the CJK Unified Ideographs Extension A etc.</source>
          <target state="translated">기본적으로 CJK 통합 표의 문자는 유니 코드 코드 포인트 순서로 정렬되지만 CJK Unified Ideographs 블록의 번호는 CJK Unified Ideographs Extension A 등의 번호보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="c9fd4df55423b1ff0429c30297d024455fc09d6b" translate="yes" xml:space="preserve">
          <source>By default, CPAN will install the latest non-developer release of a module. If you want to install a dev release, you have to specify the partial path starting with the author id to the tarball you wish to install, like so:</source>
          <target state="translated">기본적으로 CPAN은 개발자가 아닌 최신 버전의 모듈을 설치합니다. 개발자 릴리스를 설치하려면 작성자 ID로 시작하여 설치하려는 tarball의 부분 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d31a5f0a0e7ac5c54379eb4d64385f193a7c7e78" translate="yes" xml:space="preserve">
          <source>By default, Data::Dumper builds up the &quot;seen&quot; hash of scalars that it has encountered during serialization. This is very expensive. This seen hash is necessary to support and even just detect circular references. It is exposed to the user via the &lt;code&gt;Seen()&lt;/code&gt; call both for writing and reading.</source>
          <target state="translated">기본적으로 Data :: Dumper는 직렬화 중에 발생한 스칼라의 &quot;본&quot;해시를 작성합니다. 이것은 매우 비싸다. 이 해시는 원형 참조를 지원하고 감지하는 데 필요합니다. 쓰기와 읽기를 위해 &lt;code&gt;Seen()&lt;/code&gt; 호출을 통해 사용자에게 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd1b6853947249bceb85a960748d4561e30fc8ae" translate="yes" xml:space="preserve">
          <source>By default, GetOptions parses the options that are present in the global array &lt;code&gt;@ARGV&lt;/code&gt; . A special entry &lt;code&gt;GetOptionsFromArray&lt;/code&gt; can be used to parse options from an arbitrary array.</source>
          <target state="translated">기본적으로 GetOptions는 전역 배열 &lt;code&gt;@ARGV&lt;/code&gt; 에있는 옵션을 구문 분석합니다 . 특별한 입장 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; 를 사용하여 임의 배열의 옵션을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4156072258fa02556fc1c5baacde7ddf6319893" translate="yes" xml:space="preserve">
          <source>By default, GetOptions parses the options that are present in the global array &lt;code&gt;@ARGV&lt;/code&gt;. A special entry &lt;code&gt;GetOptionsFromArray&lt;/code&gt; can be used to parse options from an arbitrary array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d8266281e8d2795ccf65d39f9f3a28ecacdd25" translate="yes" xml:space="preserve">
          <source>By default, HP-UX comes configured with a maximum data segment size of 64MB. This is too small to correctly compile Perl with the maximum optimization levels. You can increase the size of the maxdsiz kernel parameter through the use of SAM.</source>
          <target state="translated">기본적으로 HP-UX는 최대 데이터 세그먼트 크기가 64MB로 구성되어 제공됩니다. 최대 최적화 수준으로 Perl을 올바르게 컴파일하기에는 너무 작습니다. SAM을 사용하여 maxdsiz 커널 매개 변수의 크기를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3209602259bcaf280c37535cab25ba0fe2f1dc" translate="yes" xml:space="preserve">
          <source>By default, HTTP::Tiny does not make any assumptions about your trust model, threat level or risk tolerance. It just aims to give you an encrypted channel when you need one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137732db42e50a8e0a9c182ecd242a32825b115f" translate="yes" xml:space="preserve">
          <source>By default, Hangul syllables are decomposed into Hangul Jamo, even if &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; . But the mapping of Hangul syllables may be overridden.</source>
          <target state="translated">기본적으로 한글 음절은 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 경우에도 한글 자모로 분해됩니다 . 그러나 한글 음절의 매핑은 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac19ab911ba3ab14f7cbb62b29a9d3c7664d12cf" translate="yes" xml:space="preserve">
          <source>By default, Hangul syllables are decomposed into Hangul Jamo, even if &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;. But the mapping of Hangul syllables may be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7c37acde02f04a994a0fe2dce5847989bfb7ac" translate="yes" xml:space="preserve">
          <source>By default, JSON booleans will be decoded as overloaded &lt;code&gt;$JSON::PP::false&lt;/code&gt; and &lt;code&gt;$JSON::PP::true&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03358de26c8be966d378648ec79854e58778f9c" translate="yes" xml:space="preserve">
          <source>By default, Locale::Maketext blacklists all methods in the Locale::Maketext namespace that begin with the '_' character, and all methods which include Perl's namespace separator characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b45806d57c8440d5ef81fe98a720868522060d" translate="yes" xml:space="preserve">
          <source>By default, Perl assumes that it must do most of its arithmetic in floating point. But by saying</source>
          <target state="translated">기본적으로 Perl은 대부분의 산술을 부동 소수점으로 수행해야한다고 가정합니다. 그러나 말함으로써</target>
        </trans-unit>
        <trans-unit id="4de9fffb0ae0d357c4fcb6328d235687ad4441ca" translate="yes" xml:space="preserve">
          <source>By default, Perl does a depth-first left-to-right search for a method. That means it starts with the first parent in the &lt;code&gt;@ISA&lt;/code&gt; array, and then searches all of its parents, grandparents, etc. If it fails to find the method, it then goes to the next parent in the original class's &lt;code&gt;@ISA&lt;/code&gt; array and searches from there.</source>
          <target state="translated">기본적으로 Perl은 깊이 우선 왼쪽에서 오른쪽으로 메소드를 검색합니다. 그것은 첫 번째 부모에서 시작한다는 것을 의미합니다. &lt;code&gt;@ISA&lt;/code&gt; 배열 시작한 다음 모든 부모, 조부모 등을 검색합니다. 메서드를 찾지 못하면 원래 클래스의 &lt;code&gt;@ISA&lt;/code&gt; 배열 에서 다음 부모로 이동하여 검색합니다. 거기에서.</target>
        </trans-unit>
        <trans-unit id="b268ca20b85e7cb3d549ac0ab2d0251384881b6c" translate="yes" xml:space="preserve">
          <source>By default, Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) ignores the current locale. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma tells Perl to use the current locale for some operations. Starting in v5.16, there are optional parameters to this pragma, described below, which restrict which operations are affected by it.</source>
          <target state="translated">기본적으로 Perl 자체 ( &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; 외부) 모듈 )는 현재 로케일을 무시합니다. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma는 일부 작업에 대한 현재 로케일을 사용하는 펄을 알려줍니다. v5.16부터는이 pragma에 대한 선택적 매개 변수가 있으며이 매개 변수는 영향을받는 조작을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="aa94a8ccd3466368231cc76eb0e0e655562c87e1" translate="yes" xml:space="preserve">
          <source>By default, Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) ignores the current locale. The &lt;code&gt;use locale&lt;/code&gt; pragma tells Perl to use the current locale for some operations. Starting in v5.16, there are optional parameters to this pragma, described below, which restrict which operations are affected by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3796ef67591d4f35614b1eaeb5b1f668ac93c4c" translate="yes" xml:space="preserve">
          <source>By default, Perl's built-in OO system is very minimal, leaving you to do most of the work. This minimalism made a lot of sense in 1994, but in the years since Perl 5.0 we've seen a number of common patterns emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich ecosystem of Perl OO systems to flourish.</source>
          <target state="translated">기본적으로 Perl의 내장 OO 시스템은 매우 작으므로 대부분의 작업을 수행 할 수 있습니다. 이 미니멀리즘은 1994 년에 의미가 있었지만 Perl 5.0 이후 몇 년 동안 우리는 Perl OO에서 많은 공통 패턴이 등장하는 것을 보았습니다. 다행히도 Perl의 유연성으로 인해 Perl OO 시스템의 풍부한 생태계가 번창 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="fcb268259208b983d01ebd2fb8ea62f828af5570" translate="yes" xml:space="preserve">
          <source>By default, Pod::Escapes exports none of its symbols. But you can request any of them to be exported. Either request them individually, as with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; , or you can do &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; to get all exportable symbols.</source>
          <target state="translated">기본적으로 Pod :: Escapes는 해당 심볼을 내 보내지 않습니다. 그러나 내보내기를 요청할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; 을 &lt;a href=&quot;../functions/use&quot;&gt;사용&lt;/a&gt; 하여 개별적으로 요청하십시오 . 또는 당신이 할 수있는 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; 내보낼 수있는 모든 심볼을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1395433e5e722399b7b232764452499b218a2dda" translate="yes" xml:space="preserve">
          <source>By default, Pod::Escapes exports none of its symbols. But you can request any of them to be exported. Either request them individually, as with &lt;code&gt;use Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt;, or you can do &lt;code&gt;use Pod::Escapes qw(:ALL);&lt;/code&gt; to get all exportable symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42f3e93e67354db749eedfb3803802a7a1b163f" translate="yes" xml:space="preserve">
          <source>By default, Pod::Man produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">기본적으로 Pod :: Man은 최대한 많은 다른 * roff 구현과 작동하도록하기 위해 가장 보수적 인 * roff 출력을 생성합니다. 많은 * roff 구현은 비 ASCII 문자를 처리 할 수 ​​없으므로 모든 비 ASCII 문자가 올바르게 강조된 문자를 작성하는 (* 최소 troff 출력의 경우) * roff 이스케이프 시퀀스로 변환되거나 &lt;code&gt;X&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="1aff6e317b0c1cd918985cba32d252237ffac9cc" translate="yes" xml:space="preserve">
          <source>By default, Pod::Man produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98107783dba2f8c87d2092a6ced42a0827ce5268" translate="yes" xml:space="preserve">
          <source>By default, Pod::Text uses the same output encoding as the input encoding of the POD source (provided that Perl was built with PerlIO; otherwise, it doesn't encode its output). If this option is given, the output encoding is forced to UTF-8.</source>
          <target state="translated">기본적으로 Pod :: Text는 POD 소스의 입력 인코딩과 동일한 출력 인코딩을 사용합니다 (Perl이 PerlIO로 빌드 된 경우에는 그렇지 않으면 출력이 인코딩되지 않음). 이 옵션이 제공되면 출력 인코딩은 UTF-8로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="607468b061542c5fb308ea35e966138c590f5abc" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. This does not work well e.g. if the script was packed with &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;. The -noperldoc option suppresses the external call to &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; and uses the simple text formatter (&lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;) to output the POD.</source>
          <target state="translated">기본적으로 Pod :: Usage는 -verbose&amp;gt; = 2가 지정되면 &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; 을 호출 합니다. 예를 들어 스크립트가 &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt; 로 압축 된 경우에는 제대로 작동하지 않습니다 . -noperldoc 옵션은 &lt;a href=&quot;../perldoc&quot;&gt;perldoc에&lt;/a&gt; 대한 외부 호출을 억제하고 간단한 텍스트 포맷터 ( &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; )를 사용하여 POD를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3329bbc8b004125c8c5278e4dfc259a804cd3aa3" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. In case &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; is not installed where the &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; interpreter thinks it is (see &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;), the -perldoc option may be used to supply the correct path to &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22871ba1e750f95b09d8130a2d10b57dbadb7827" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. In case of special or unusual Perl installations, the -perlcmd option may be used to supply the path to a &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt; executable which should run &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1201c61be1212ca71fcfd8853a5004fc60c01a5a" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. The -perldocopt option may be used to supply options to &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. The string may contain several, space-separated options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1d3cbd9df1b34d43a284a1aea0a8c7b074f24c" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. This does not work well e.g. if the script was packed with &lt;a href=&quot;par&quot;&gt;PAR&lt;/a&gt;. The -noperldoc option suppresses the external call to &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; and uses the simple text formatter (&lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;) to output the POD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaf9130ce3cc364b8ff0d6d870dfc5f5e3ff5d9" translate="yes" xml:space="preserve">
          <source>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a &quot;?&quot;. Note that the meanings don't change, just the &quot;greediness&quot;:</source>
          <target state="translated">기본적으로, 정량화 된 하위 패턴은 &quot;욕심&quot;입니다. 즉, 패턴의 나머지 부분은 계속 일치시키면서 가능한 한 여러 번 (특정 시작 위치가 제공됨) 일치합니다. 가능한 최소 횟수와 일치 시키려면 &quot;?&quot;로 수량자를 따르십시오. 그 의미는 변하지 않고 단지 &quot;만족&quot;이라는 것에 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="0b6eec9c8bbe7a9df535a2212f50cb8ec43bdf1e" translate="yes" xml:space="preserve">
          <source>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a &lt;code&gt;&quot;?&quot;&lt;/code&gt;. Note that the meanings don't change, just the &quot;greediness&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48a9b04f7e394f8ae5c84a6badf024eee518a01" translate="yes" xml:space="preserve">
          <source>By default, all ftp connections are done in passive mode. To change that, see the &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; variable further down.</source>
          <target state="translated">기본적으로 모든 ftp 연결은 수동 모드로 수행됩니다. 이를 변경하려면 &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; 변수를 자세히 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="d7f764723d2b6f4e034b63502225f5115dfa076e" translate="yes" xml:space="preserve">
          <source>By default, all tests are eligible to be run in parallel. Specifying any of your own rules removes this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f80a56139fac5d67611619acae3e63a365a4381" translate="yes" xml:space="preserve">
          <source>By default, attribute handlers are called at the end of the compilation phase (in a &lt;code&gt;CHECK&lt;/code&gt; block). This seems to be optimal in most cases because most things that can be defined are defined by that point but nothing has been executed.</source>
          <target state="translated">기본적으로 속성 처리기는 컴파일 단계 종료시 ( &lt;code&gt;CHECK&lt;/code&gt; 블록에서) 호출됩니다 . 정의 할 수있는 대부분의 항목이 해당 지점에서 정의되었지만 실행 된 것이 없기 때문에 대부분의 경우에 최적 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="d92e033ccee030ae17ccf241ebba25503e925cbf" translate="yes" xml:space="preserve">
          <source>By default, but can be redefined.</source>
          <target state="translated">기본적으로 다시 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f90d660b6b88d20d5a032c88e00b0f974301c2b" translate="yes" xml:space="preserve">
          <source>By default, case-sensitive comparison (that is level 3 difference) won't ignore accents (that is level 2 difference).</source>
          <target state="translated">기본적으로 대소 문자 구분 비교 (레벨 3 차이)는 악센트 (레벨 2 차이)를 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b957d395a8a7eedebb03724489ebfa7e55174b9c" translate="yes" xml:space="preserve">
          <source>By default, classes in Perl only perform the &lt;code&gt;UNIVERSAL&lt;/code&gt; role, as well as the role of all classes in their inheritance. In other words, by default &lt;code&gt;DOES&lt;/code&gt; responds identically to &lt;code&gt;isa&lt;/code&gt; .</source>
          <target state="translated">기본적으로 Perl의 클래스는 &lt;code&gt;UNIVERSAL&lt;/code&gt; 역할과 상속시 모든 클래스의 역할 만 수행합니다 . 즉, 기본적으로 &lt;code&gt;DOES&lt;/code&gt; 는 &lt;code&gt;isa&lt;/code&gt; 에 동일하게 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="72b12f15b2704c72b2abbc49dd17fbafa2fd667f" translate="yes" xml:space="preserve">
          <source>By default, classes in Perl only perform the &lt;code&gt;UNIVERSAL&lt;/code&gt; role, as well as the role of all classes in their inheritance. In other words, by default &lt;code&gt;DOES&lt;/code&gt; responds identically to &lt;code&gt;isa&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09751b6a3dd219cd03f615c311b1588c0433a01" translate="yes" xml:space="preserve">
          <source>By default, each time the CPAN module is started, cache scanning is performed to keep the cache size in sync ('atstart'). Alternatively, scanning and cleanup can happen when CPAN exits ('atexit'). To prevent any cache cleanup, answer 'never'.</source>
          <target state="translated">기본적으로 CPAN 모듈이 시작될 때마다 캐시 크기를 동기화 ( 'atstart')로 유지하기 위해 캐시 스캔이 수행됩니다. 또는 CPAN이 종료되면 ( 'atexit') 스캔 및 정리가 발생할 수 있습니다. 캐시 정리를 방지하려면 'never'로 대답하십시오.</target>
        </trans-unit>
        <trans-unit id="a04a99ac495330cd07b871fc7a9618f7082ee169" translate="yes" xml:space="preserve">
          <source>By default, every base class needs to live in a file of its own. If you want to have a subclass and its parent class in the same file, you can tell &lt;code&gt;parent&lt;/code&gt; not to load any modules by using the &lt;code&gt;-norequire&lt;/code&gt; switch:</source>
          <target state="translated">기본적으로 모든 기본 클래스는 자체 파일에 있어야합니다. 서브 클래스와 그 상위 클래스를 같은 파일에 두려면 , &lt;code&gt;-norequire&lt;/code&gt; 스위치 를 사용하여 &lt;code&gt;parent&lt;/code&gt; 에게 모듈을로드하지 않도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="009314417d0e225d96e9c70c4f8a61f37cbd61fb" translate="yes" xml:space="preserve">
          <source>By default, file names are assumed to be case sensitive; this flag makes bsd_glob() treat case differences as not significant.</source>
          <target state="translated">기본적으로 파일 이름은 대소 문자를 구분하는 것으로 간주됩니다. 이 플래그는 bsd_glob ()가 대소 문자 차이를 중요하지 않은 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="f417fd8f43a3aea1715b95681c77c39ae15d3bda" translate="yes" xml:space="preserve">
          <source>By default, filters are not inherited by child hubs. That means if you start a subtest, the subtest will not inherit the filter. You can change this behavior with the &lt;code&gt;inherit&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e050dc7d694db5e9597e9b5666a97cb998c6670" translate="yes" xml:space="preserve">
          <source>By default, hiragana is before katakana. If the parameter is made true, this is reversed.</source>
          <target state="translated">기본적으로 히라가나는 가타카나 앞에 있습니다. 매개 변수가 true이면 반대입니다.</target>
        </trans-unit>
        <trans-unit id="f1a9fafb28afdf9312602001044d697513c2f742" translate="yes" xml:space="preserve">
          <source>By default, if a redispatch attempt fails to find another method elsewhere in the objects class hierarchy, it quietly gives up and does nothing (but see &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;&quot;Enforcing redispatch&quot;&lt;/a&gt;). This gracious acquiescence is also unlike the (generally annoying) behaviour of &lt;code&gt;SUPER&lt;/code&gt;, which throws an exception if it cannot redispatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68b6a00ff07db87e5b4fca637ec784a918f2f88" translate="yes" xml:space="preserve">
          <source>By default, if a redispatch attempt fails to find another method elsewhere in the objects class hierarchy, it quietly gives up and does nothing (but see &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;Enforcing redispatch&lt;/a&gt;). This gracious acquiescence is also unlike the (generally annoying) behaviour of &lt;code&gt;SUPER&lt;/code&gt; , which throws an exception if it cannot redispatch.</source>
          <target state="translated">기본적으로 재발견 시도가 객체 클래스 계층의 다른 곳에서 다른 방법을 찾지 못하면 조용히 포기하지 않습니다 (그러나 &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;재발 명 시행&lt;/a&gt; 참조 ). 이 은혜로운 욕설은 또한 &lt;code&gt;SUPER&lt;/code&gt; 의 (일반적으로 성가신) 행동과는 달리 재발견 할 수없는 경우 예외를 던집니다.</target>
        </trans-unit>
        <trans-unit id="622748004543277cac1eed24641a5d626b92e074" translate="yes" xml:space="preserve">
          <source>By default, it checks only ascii, utf8 and UTF-16/32 with BOM.</source>
          <target state="translated">기본적으로 BOM을 사용하여 ascii, utf8 및 UTF-16 / 32 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7d795357eb0370d795216bc893725d71f457449f" translate="yes" xml:space="preserve">
          <source>By default, it exports the functions cwd(), getcwd(), fastcwd(), and fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.</source>
          <target state="translated">기본적으로 cwd (), getcwd (), fastcwd () 및 fastgetcwd () (및 Win32의 경우 getdcwd ()) 함수를 호출자의 네임 스페이스로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bd57ef383f01461a26729aaf5bda1caeec29a44b" translate="yes" xml:space="preserve">
          <source>By default, lowercase is before uppercase. If the parameter is made true, this is reversed.</source>
          <target state="translated">기본적으로 소문자는 대문자 앞에 있습니다. 매개 변수가 true이면 반대입니다.</target>
        </trans-unit>
        <trans-unit id="bd52b1e53c314fe3c4b656aedbdea4b06daed47d" translate="yes" xml:space="preserve">
          <source>By default, no comment field is written to the zip file.</source>
          <target state="translated">기본적으로 주석 필드는 zip 파일에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d5b6fb015586b3864b9f25cf4e1c4322f8f41ee" translate="yes" xml:space="preserve">
          <source>By default, optional warnings are disabled, so any legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">기본적으로 선택적 경고는 비활성화되어 있으므로 경고를 제어하지 않는 레거시 코드는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56744be38bf9987fcb8b98dab67cef731ba84ab1" translate="yes" xml:space="preserve">
          <source>By default, perl handles file globbing using the File::Glob extension, which provides portable globbing.</source>
          <target state="translated">기본적으로 perl은 휴대용 globbing을 제공하는 File :: Glob 확장명을 사용하여 파일 globbing을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b252359c438a3c8369c5cbca58632d9664dd0131" translate="yes" xml:space="preserve">
          <source>By default, perl uses the large file compilation environment and relies on Solaris to do the underlying mapping of interfaces.</source>
          <target state="translated">기본적으로 perl은 큰 파일 컴파일 환경을 사용하며 기본 인터페이스 매핑을 수행하기 위해 Solaris를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95ea6d685281e6fc9b1246edd3de6ccbfbf85ecd" translate="yes" xml:space="preserve">
          <source>By default, perl will be compiled as a 32-bit application. Unless you want to allocate more than ~ 4GB of memory inside perl, or unless you need more than 255 open file descriptors, you probably don't need perl to be a 64-bit app.</source>
          <target state="translated">기본적으로 perl은 32 비트 응용 프로그램으로 컴파일됩니다. 펄 내에 ~ 4GB 이상의 메모리를 할당하지 않거나 255 개 이상의 열린 파일 디스크립터가 필요하지 않으면 펄이 64 비트 앱일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8beb3118174cbb4befcc9218c3e11ee8559a67ed" translate="yes" xml:space="preserve">
          <source>By default, perl-5.6.0 (or later) is compiled as a 32-bit application with largefile and long-long support.</source>
          <target state="translated">기본적으로 perl-5.6.0 이상은 큰 파일과 긴 지원을 가진 32 비트 응용 프로그램으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="c1d7d31b73907dcda6cd3ad0857aee8de05a33a3" translate="yes" xml:space="preserve">
          <source>By default, running out of memory is an untrappable, fatal error. However, if suitably built, Perl can use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency memory pool after &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;ing. Suppose that your Perl were compiled with &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; and used Perl's malloc. Then</source>
          <target state="translated">기본적으로 메모리 부족은 트래핑 할 수없고 치명적인 오류입니다. 그러나 적절하게 구축 된 경우 Perl은 &lt;code&gt;$^M&lt;/code&gt; 의 내용을 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 후 비상 메모리 풀로 사용할 수 있습니다 . Perl이 &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; 로 컴파일되고 Perl의 malloc을 사용 했다고 가정하십시오 . 그때</target>
        </trans-unit>
        <trans-unit id="6367e8a3e44bc0b4aac043c742b1314b3e53105a" translate="yes" xml:space="preserve">
          <source>By default, running out of memory is an untrappable, fatal error. However, if suitably built, Perl can use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency memory pool after &lt;code&gt;die()&lt;/code&gt;ing. Suppose that your Perl were compiled with &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; and used Perl's malloc. Then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4190ef76a4299cfe3e352f5cfeb999b38851b5f5" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt; in which case section 3 will be selected.</source>
          <target state="translated">파일이 &lt;code&gt;.pm&lt;/code&gt; 으로 끝나지 않는 한 기본적으로 섹션 1이 사용 되며이 경우 섹션 3이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8d9133733d7f7dcd376ecd3cd224e4dddd523774" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt;, in which case section 3 will be selected.</source>
          <target state="translated">파일이 &lt;code&gt;.pm&lt;/code&gt; 으로 끝나지 않으면 기본적으로 섹션 1이 사용되며 ,이 경우 섹션 3이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="961a8c7a3d78a4ba111b92d292c8ae5c80f7c1a1" translate="yes" xml:space="preserve">
          <source>By default, semaphores behave like locks, letting only one thread &lt;code&gt;down()&lt;/code&gt; them at a time. However, there are other uses for semaphores.</source>
          <target state="translated">기본적으로 세마포어는 잠금처럼 작동하여 한 번에 하나의 스레드 만 &lt;code&gt;down()&lt;/code&gt; 할 수 있습니다. 그러나 세마포어에는 다른 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed769cd67eb1346af1f13055d0984c3c18e8ed3" translate="yes" xml:space="preserve">
          <source>By default, strings whose weights are equal should be equal, even though their code points are not equal. Completely ignorable characters are ignored.</source>
          <target state="translated">코드 포인트가 동일하지 않더라도 기본적으로 가중치가 동일한 문자열은 동일해야합니다. 완전히 무시할 수있는 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="56921ea3749d0afb26fde19f34e5cd700c2dac28" translate="yes" xml:space="preserve">
          <source>By default, the &quot;^&quot; character is guaranteed to match only the beginning of the string, the &quot;$&quot; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line. Embedded newlines will not be matched by &quot;^&quot; or &quot;$&quot;. You may, however, wish to treat a string as a multi-line buffer, such that the &quot;^&quot; will match after any newline within the string (except if the newline is the last character in the string), and &quot;$&quot; will match before any newline. At the cost of a little more overhead, you can do this by using the /m modifier on the pattern match operator. (Older programs did this by setting &lt;code&gt;$*&lt;/code&gt; , but this option was removed in perl 5.10.)</source>
          <target state="translated">기본적으로 &quot;^&quot;문자는 문자열의 시작 부분 만 일치하고 &quot;$&quot;문자는 끝 부분 (또는 끝 부분의 줄 바꿈 이전)에만 일치하며 Perl은 문자열에 포함 된 것으로 가정하여 특정 최적화를 수행합니다. 한 줄. 포함 된 줄 바꿈은 &quot;^&quot;또는 &quot;$&quot;와 일치하지 않습니다. 그러나 문자열을 여러 줄 버퍼로 취급하여 문자열 내의 줄 바꿈 뒤에 &quot;^&quot;가 일치하도록하고 (줄 바꿈이 문자열의 마지막 문자 인 경우 제외) &quot;$&quot;는 개행 전에 일치합니다. 약간의 오버 헤드가 발생하지만 패턴 일치 연산자에서 / m 수정자를 사용하면됩니다. (이전 프로그램은 &lt;code&gt;$*&lt;/code&gt; 를 설정하여이 작업을 수행 했지만이 옵션은 perl 5.10에서 제거되었습니다.)</target>
        </trans-unit>
        <trans-unit id="346e0669eeb7d260c287822e0f04240653bff2d8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;&quot;^&quot;&lt;/code&gt; character is guaranteed to match only the beginning of the string, the &lt;code&gt;&quot;$&quot;&lt;/code&gt; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line. Embedded newlines will not be matched by &lt;code&gt;&quot;^&quot;&lt;/code&gt; or &lt;code&gt;&quot;$&quot;&lt;/code&gt;. You may, however, wish to treat a string as a multi-line buffer, such that the &lt;code&gt;&quot;^&quot;&lt;/code&gt; will match after any newline within the string (except if the newline is the last character in the string), and &lt;code&gt;&quot;$&quot;&lt;/code&gt; will match before any newline. At the cost of a little more overhead, you can do this by using the &lt;a href=&quot;#%2Fm&quot;&gt;&quot;&lt;code&gt;/m&lt;/code&gt;&quot;&lt;/a&gt; modifier on the pattern match operator. (Older programs did this by setting &lt;code&gt;$*&lt;/code&gt;, but this option was removed in perl 5.10.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492fc906b55f1b406ab710691a332ebe623491a7" translate="yes" xml:space="preserve">
          <source>By default, the check function is &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;, the SV parameter is &lt;code&gt;cv&lt;/code&gt; itself, and the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag is clear. This implements standard prototype processing. It can be changed, for a particular subroutine, by &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75c5443daebd3a0b513a176d080239244e192dd" translate="yes" xml:space="preserve">
          <source>By default, the exception derived from the operand LIST is stringified and printed to &lt;code&gt;STDERR&lt;/code&gt;. This behaviour can be altered by installing a &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__WARN__}&lt;/code&gt;&lt;/a&gt; handler. If there is such a handler then no message is automatically printed; it is the handler's responsibility to deal with the exception as it sees fit (like, for instance, converting it into a &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;). Most handlers must therefore arrange to actually display the warnings that they are not prepared to deal with, by calling &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt; again in the handler. Note that this is quite safe and will not produce an endless loop, since &lt;code&gt;__WARN__&lt;/code&gt; hooks are not called from inside one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a870bf9d52ad0a2c1a90186336492c4ae0aed3" translate="yes" xml:space="preserve">
          <source>By default, the function is &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;, and the SV parameter is</source>
          <target state="translated">기본적으로 함수는 &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt; 이고 SV 매개 변수는</target>
        </trans-unit>
        <trans-unit id="beeed48a59ea18c1b18a6cfda68d25973cd743b6" translate="yes" xml:space="preserve">
          <source>By default, the installed filter only filters up to a line consisting of one of the three standard source &quot;terminators&quot;:</source>
          <target state="translated">기본적으로 설치된 필터는 다음 세 가지 표준 소스 &quot;터미네이터&quot;중 하나로 구성된 라인까지만 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="e79e890007f8b504a54617ddbf05ff93a90734ba" translate="yes" xml:space="preserve">
          <source>By default, the only variables shared with compartments are the &quot;underscore&quot; variables $_ and @_ (and, technically, the less frequently used %_, the _ filehandle and so on). This is because otherwise perl operators which default to $_ will not work and neither will the assignment of arguments to @_ on subroutine entry.</source>
          <target state="translated">기본적으로 구획과 공유되는 유일한 변수는 &quot;밑줄&quot;변수 $ _ 및 _ (기술적으로 덜 자주 사용되는 % _, _ 파일 핸들 등)입니다. 그렇지 않으면 기본적으로 $ _로 설정된 perl 연산자가 작동하지 않으며 서브 루틴 항목에서 인수를 @_에 지정하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4eebbb2dfa043331a8ced51ef018a956d406180e" translate="yes" xml:space="preserve">
          <source>By default, the pathnames are sorted in ascending ASCII order; this flag prevents that sorting (speeding up bsd_glob()).</source>
          <target state="translated">기본적으로 경로 이름은 ASCII 오름차순으로 정렬됩니다. 이 플래그는 정렬을 방지합니다 (bsd_glob () 속도를 높입니다).</target>
        </trans-unit>
        <trans-unit id="cd52d7b7234ea4b8c1ee0272333575fae9c9ac61" translate="yes" xml:space="preserve">
          <source>By default, the string appended is assumed to be valid UTF-8 if the SV has the UTF-8 status set, and a string of bytes otherwise. One can force the appended string to be interpreted as UTF-8 by supplying the &lt;code&gt;SV_CATUTF8&lt;/code&gt; flag, and as bytes by supplying the &lt;code&gt;SV_CATBYTES&lt;/code&gt; flag; the SV or the string appended will be upgraded to UTF-8 if necessary.</source>
          <target state="translated">기본적으로 SV에 UTF-8 상태 세트가있는 경우 추가 된 문자열은 유효한 UTF-8이고 그렇지 않은 경우 바이트 문자열입니다. 하나는 첨부 된 문자열을 강제 공급으로 UTF-8로 해석 될 &lt;code&gt;SV_CATUTF8&lt;/code&gt; 의 플래그 및 공급함으로써 바이트로서 &lt;code&gt;SV_CATBYTES&lt;/code&gt; 의 플래그; 필요한 경우 SV 또는 추가 된 문자열이 UTF-8로 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="3c44da1fa54feaff13f3357da78bc5d189559610" translate="yes" xml:space="preserve">
          <source>By default, there is a fundamental asymmetry in Perl's unicode model: implicit upgrading from byte-strings to unicode-strings assumes that they were encoded in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d41f8d85e7a977c1704e0b6aa0d1e3446f200e7" translate="yes" xml:space="preserve">
          <source>By default, this module creates an &lt;code&gt;::I18N&lt;/code&gt; subclass under the caller's package (or the package specified by &lt;code&gt;Class&lt;/code&gt; ), and stores lexicon data in its subclasses. You can assign a name other than &lt;code&gt;I18N&lt;/code&gt; via this option.</source>
          <target state="translated">기본적으로이 모듈은 호출자의 패키지 (또는 &lt;code&gt;Class&lt;/code&gt; 에 의해 지정된 패키지) 아래에 &lt;code&gt;::I18N&lt;/code&gt; 서브 클래스를 작성하고 해당 서브 클래스에 어휘 데이터를 저장합니다. 이 옵션을 통해 &lt;code&gt;I18N&lt;/code&gt; 이외의 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39d93a161b8e818beee11c7a4375f2ab33e763db" translate="yes" xml:space="preserve">
          <source>By default, this module creates an &lt;code&gt;::I18N&lt;/code&gt; subclass under the caller's package (or the package specified by &lt;code&gt;Class&lt;/code&gt;), and stores lexicon data in its subclasses. You can assign a name other than &lt;code&gt;I18N&lt;/code&gt; via this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5949c007c079cc7a10f34781de30c09a225b6eca" translate="yes" xml:space="preserve">
          <source>By default, this module exports a single function, &lt;code&gt;loc&lt;/code&gt; , into its caller's namespace. You can set it to another name, or set it to an empty string to disable exporting.</source>
          <target state="translated">기본적으로이 모듈은 단일 함수 &lt;code&gt;loc&lt;/code&gt; 을 호출자의 네임 스페이스로 내 보냅니다 . 다른 이름으로 설정하거나 빈 문자열로 설정하여 내보내기를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712a00a33c605be8604c3834cdbcfab88be256ac" translate="yes" xml:space="preserve">
          <source>By default, this module exports a single function, &lt;code&gt;loc&lt;/code&gt;, into its caller's namespace. You can set it to another name, or set it to an empty string to disable exporting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad4115958f94effa9746305a9b0cb4cffc6bd7c" translate="yes" xml:space="preserve">
          <source>By default, this module uses the &lt;code&gt;maketext&lt;/code&gt; style of &lt;code&gt;[_1]&lt;/code&gt; and &lt;code&gt;[quant,_1]&lt;/code&gt; for interpolation. Alternatively, you can specify the &lt;code&gt;gettext&lt;/code&gt; style, which uses &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%quant(%1)&lt;/code&gt; for interpolation.</source>
          <target state="translated">기본적으로이 모듈은 &lt;code&gt;maketext&lt;/code&gt; 스타일 &lt;code&gt;[_1]&lt;/code&gt; 및 &lt;code&gt;[quant,_1]&lt;/code&gt; 을 사용합니다. 또는 보간에 &lt;code&gt;%1&lt;/code&gt; 및 &lt;code&gt;%quant(%1)&lt;/code&gt; 을 사용 하는 &lt;code&gt;gettext&lt;/code&gt; 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="252a3c80bb1e3517a1330d8a71715773619ce9ac" translate="yes" xml:space="preserve">
          <source>By default, variables are private to each thread, and each newly created thread gets a private copy of each existing variable. This module allows you to share variables across different threads (and pseudo-forks on Win32). It is used together with the &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">기본적으로 변수는 각 스레드에 대해 비공개이며 새로 작성된 각 스레드는 기존 변수 각각의 개인용 사본을 가져옵니다. 이 모듈을 사용하면 다른 스레드 (및 Win32의 유사 포크)간에 변수를 공유 할 수 있습니다. &lt;a href=&quot;../threads&quot;&gt;스레드&lt;/a&gt; 모듈 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f2757a28f882e9d7437545b7f1bd8e345152206" translate="yes" xml:space="preserve">
          <source>By default, variables are private to each thread, and each newly created thread gets a private copy of each existing variable. This module allows you to share variables across different threads (and pseudo-forks on Win32). It is used together with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c30bfb71acf5bab76a39a204b8f603e13c705d5" translate="yes" xml:space="preserve">
          <source>By default, warnings are output to STDERR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d154b38941f09ce6557f839a81a8eafedac239" translate="yes" xml:space="preserve">
          <source>By default, when a new interpreter is created as a copy of an existing one (eg via &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ), both interpreters share the same physical my_cxt_t structure. Calling &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (typically via the package's &lt;code&gt;CLONE()&lt;/code&gt; function), causes a byte-for-byte copy of the structure to be taken, and any future dMY_CXT will cause the copy to be accessed instead.</source>
          <target state="translated">기본적으로 새 인터프리터가 기존 인터프리터의 복사본으로 생성 된 경우 (예 : &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ) 두 인터프리터는 동일한 물리적 my_cxt_t 구조를 공유합니다. &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; 을 호출 하면 (일반적으로 패키지의 &lt;code&gt;CLONE()&lt;/code&gt; 함수를 통해) 구조의 바이트 별 바이트 사본이 작성되고 이후의 dMY_CXT는 대신 사본에 액세스하게됩니다.</target>
        </trans-unit>
        <trans-unit id="8b319a76707aa4f1f8b1be359984e02b7255e6a0" translate="yes" xml:space="preserve">
          <source>By default, when a new interpreter is created as a copy of an existing one (eg via &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt;), both interpreters share the same physical my_cxt_t structure. Calling &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (typically via the package's &lt;code&gt;CLONE()&lt;/code&gt; function), causes a byte-for-byte copy of the structure to be taken, and any future dMY_CXT will cause the copy to be accessed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffafaef14fbbfda71aa3c0226b07030f61fdd39" translate="yes" xml:space="preserve">
          <source>By default, your pattern is matched case-insensitively, as if &lt;code&gt;/i&lt;/code&gt; had been specified. You can change this by saying &lt;code&gt;(?-i)&lt;/code&gt; in your pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f023b47e4b490e5f3861a02400fb5ce0693a9fc" translate="yes" xml:space="preserve">
          <source>By default, your program starts in package &lt;code&gt;main&lt;/code&gt; , so you will always be in some package.</source>
          <target state="translated">기본적으로 프로그램은 &lt;code&gt;main&lt;/code&gt; 패키지에서 시작 하므로 항상 일부 패키지에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="e24e192b6da98e496fcb6606ff2b3e72e0f05fea" translate="yes" xml:space="preserve">
          <source>By default, your program starts in package &lt;code&gt;main&lt;/code&gt;, so you will always be in some package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc16f7e5e668d806fbde2fd531d2629a195bfd9c" translate="yes" xml:space="preserve">
          <source>By explicitly requiring a minimum Perl version number for your program, with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; construct. That is,</source>
          <target state="translated">프로그램에 대한 최소 Perl 버전 번호를 명시 적으로 요구함으로써 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 구문을 사용. 그건,</target>
        </trans-unit>
        <trans-unit id="d7932496508fde98a4b2f745f7c16a8938bd5c70" translate="yes" xml:space="preserve">
          <source>By explicitly requiring a minimum Perl version number for your program, with the &lt;code&gt;use VERSION&lt;/code&gt; construct. That is,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b496b26c66a41bb8b28e0a2591cb8dda23a4871c" translate="yes" xml:space="preserve">
          <source>By far the easiest way to build Perl for OS/400 is to use the PASE (Portable Application Solutions Environment), for more information see &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; This environment allows one to use AIX APIs while programming, and it provides a runtime that allows AIX binaries to execute directly on the PowerPC iSeries.</source>
          <target state="translated">OS / 400 용 Perl을 빌드하는 가장 쉬운 방법은 PASE (Portable Application Solutions Environment)를 사용하는 것입니다. 자세한 정보는 다음을 참조하십시오. &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt; http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; 이를 환경은 프로그래밍하는 동안 AIX API를 사용할 수 있도록하며 AIX 바이너리가 PowerPC iSeries에서 직접 실행될 수있는 런타임을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90b268ad6928ce9b139ce0bfe20e0ab522c5a230" translate="yes" xml:space="preserve">
          <source>By far the most common reason is that the locale has characters in it that are represented by more than one byte. The only such locales that Perl can handle are the UTF-8 locales. Most likely the specified locale is a non-UTF-8 one for an East Asian language such as Chinese or Japanese. If the locale is a superset of ASCII, the ASCII portion of it may work in Perl.</source>
          <target state="translated">가장 일반적인 이유는 로케일에 하나 이상의 바이트로 표시되는 문자가 포함되어 있기 때문입니다. Perl이 처리 할 수있는 유일한 로케일은 UTF-8 로케일입니다. 지정된 로케일은 중국어 나 일본어와 같은 동아시아 언어의 비 UTF-8이 아닌 것 같습니다. 로케일이 ASCII의 상위 세트 인 경우, ASCII 부분은 Perl에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be86ce403211ab50be3b7ce1f4f87ec5b6bd179" translate="yes" xml:space="preserve">
          <source>By first converting the FOO-encoded byte string to a text string, and then the text string to a BAR-encoded byte string:</source>
          <target state="translated">먼저 FOO 인코딩 된 바이트 문자열을 텍스트 문자열로 변환 한 다음 텍스트 문자열을 BAR 인코딩 된 바이트 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3456e5ab0f472be26a41623d10e3cc8ff953c769" translate="yes" xml:space="preserve">
          <source>By including Exporter in your &lt;code&gt;@ISA&lt;/code&gt; you inherit an Exporter's import() method but you also inherit several other helper methods which you probably don't want. To avoid this you can do:</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 에 Exporter를 포함 시키면 Exporter의 import () 메소드를 상속 받지만 원하지 않는 다른 도우미 메소드도 상속합니다. 이를 피하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="583ac2704011a6bdba33e0ae7763c40858b78828" translate="yes" xml:space="preserve">
          <source>By passing a reference to a hash you may set the configuration values. This works only for values that a marked with a &lt;code&gt;RW&lt;/code&gt; above, anything else is read-only.</source>
          <target state="translated">해시에 대한 참조를 전달하여 구성 값을 설정할 수 있습니다. 이것은 &lt;code&gt;RW&lt;/code&gt; 로 표시된 값에 대해서만 작동합니다위 합니다. 다른 것은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="ffc61b70d37b8dffa55761a98d33cd6f2e713e8c" translate="yes" xml:space="preserve">
          <source>By placing &lt;code&gt;-register&lt;/code&gt; in the import list, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; uses &lt;code&gt;IO::Socket::IP&lt;/code&gt; rather than &lt;code&gt;IO::Socket::INET&lt;/code&gt; as the class that handles &lt;code&gt;PF_INET&lt;/code&gt;. &lt;code&gt;IO::Socket&lt;/code&gt; will also use &lt;code&gt;IO::Socket::IP&lt;/code&gt; rather than &lt;code&gt;IO::Socket::INET6&lt;/code&gt; to handle &lt;code&gt;PF_INET6&lt;/code&gt;, provided that the &lt;code&gt;AF_INET6&lt;/code&gt; constant is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30293ddc7efc1598420ad5a32ac1415cea4ba8a" translate="yes" xml:space="preserve">
          <source>By running &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you ensure that your Mytest.t script runs and uses the correct version of your extension. If you have many test cases, save your test files in the &quot;t&quot; directory and use the suffix &quot;.t&quot;. When you run &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, all of these test files will be executed.</source>
          <target state="translated">&quot; &lt;code&gt;make test&lt;/code&gt; &quot; 를 실행 하면 Mytest.t 스크립트가 실행되고 올바른 확장 버전을 사용하게됩니다. 많은 테스트 사례가있는 경우 테스트 파일을 &quot;t&quot;디렉토리에 저장하고 접미 부 &quot;.t&quot;를 사용하십시오. &quot; &lt;code&gt;make test&lt;/code&gt; 를 실행하면 &quot; 이러한 모든 테스트 파일이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b012b405c2fff7730ead4df76d693c2db095ab5d" translate="yes" xml:space="preserve">
          <source>By running &quot;&lt;code&gt;make test&lt;/code&gt;&quot;, you ensure that your Mytest.t script runs and uses the correct version of your extension. If you have many test cases, save your test files in the &quot;t&quot; directory and use the suffix &quot;.t&quot;. When you run &quot;&lt;code&gt;make test&lt;/code&gt;&quot;, all of these test files will be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49d2ff2073c166abecd08a90ef566dc2e86a7f38" translate="yes" xml:space="preserve">
          <source>By setting and then using &lt;code&gt;$var&lt;/code&gt; in this way relieves you from having to worry about exactly which numbered set of parentheses they are.</source>
          <target state="translated">이런 식으로 &lt;code&gt;$var&lt;/code&gt; 를 설정하고 사용 하면 정확히 어떤 숫자의 괄호가 있는지 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="265fb107c25a0f703500d08dbe4e8f2787903896" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string you can generate a Makefile that prints all commands. Mainly used in debugging MakeMaker itself.</source>
          <target state="translated">빈 문자열로 설정하면 모든 명령을 인쇄하는 Makefile을 생성 할 수 있습니다. 주로 MakeMaker 자체를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="619bd2bab7e99a9933fcadbbac647cbc3917a48b" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;:loose&lt;/code&gt; , Unicode's &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;loose character name matching&lt;/a&gt; rules are selected instead of the strict exact match used otherwise. That means that</source>
          <target state="translated">&lt;code&gt;:loose&lt;/code&gt; 를 지정하면 , 달리 사용 된 정확한 완전 일치 대신 유니 코드의 &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;느슨한 문자 이름 일치&lt;/a&gt; 규칙이 선택됩니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="409281df47ba60298eba1ac37bc10f01f4eb2677" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;:loose&lt;/code&gt;, Unicode's &lt;a href=&quot;http://www.unicode.org/reports/tr44#Matching_Rules&quot;&gt;loose character name matching&lt;/a&gt; rules are selected instead of the strict exact match used otherwise. That means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4173811273acdfc3b518c06a8c9add11d80be073" translate="yes" xml:space="preserve">
          <source>By subclassing, you may end up overriding undocumented methods. That's not a bad thing per se, but be forewarned that undocumented methods may change without warning from one release to the next - we cannot guarantee backwards compatibility. If any</source>
          <target state="translated">서브 클래 싱을 통해 문서화되지 않은 메소드를 대체 할 수 있습니다. 그 자체로는 나쁜 것이 아니지만 문서화되지 않은 방법은 한 릴리스에서 다음 릴리스로 경고없이 변경 될 수 있습니다. 우리는 이전 버전과의 호환성을 보장 할 수 없습니다. 만약에 어떠한</target>
        </trans-unit>
        <trans-unit id="7963af28b4afe4fecf3771e6be636d3a37450528" translate="yes" xml:space="preserve">
          <source>By the time Perl 5 rolled around, we were already stuck with this design: Hash values must be scalars. The solution to this is references.</source>
          <target state="translated">Perl 5가 롤오버 될 때, 우리는 이미이 설계를 고수했습니다. 해시 값은 스칼라 여야합니다. 이에 대한 해결책은 참조입니다.</target>
        </trans-unit>
        <trans-unit id="92f8d8ab799211d118cdd3b80bc6282c36c18e07" translate="yes" xml:space="preserve">
          <source>By the time each of the &lt;code&gt;SaveSub1&lt;/code&gt; statements above has been executed, the SV*s which corresponded to the parameters will no longer exist. Expect an error message from Perl of the form</source>
          <target state="translated">위의 각 &lt;code&gt;SaveSub1&lt;/code&gt; 문이 실행될 때까지 매개 변수에 해당하는 SV *는 더 이상 존재하지 않습니다. 양식의 Perl에서 오류 메시지를 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="334c1508a5d779cb0c1040092154fbe0583ab19f" translate="yes" xml:space="preserve">
          <source>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run, in routines that read the &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; field which it populates.</source>
          <target state="translated">comp 콜백이 호출 될 때이 플래그 중 일부가 이미 적용되었습니다 (해당되는 경우 아래에 표시). 그러나 대부분의 효과는 comp 콜백이 실행 된 후 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 를 읽는 루틴에서 발생합니다. 필드를 .</target>
        </trans-unit>
        <trans-unit id="72795a79e31e2518cbd921d2bc0697a1bdbd6144" translate="yes" xml:space="preserve">
          <source>By tuning the stack size to more accurately reflect your application's needs, you may significantly reduce your application's memory usage, and increase the number of simultaneously running threads.</source>
          <target state="translated">애플리케이션의 요구를보다 정확하게 반영하도록 스택 크기를 조정하면 애플리케이션의 메모리 사용량을 크게 줄이고 동시에 실행중인 스레드 수를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd379fb72b0b513ca230e24dca7f155e46117288" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; , if there is no other &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the method call, an exception will be thrown (as usually happens in the absence of a suitable &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</source>
          <target state="translated">사용하여 &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; 다른이없는 경우, &lt;code&gt;AUTOLOAD&lt;/code&gt; (일반적으로 적당한의 부재에서 일어나는로 메서드 호출을 처리 할 수있는 예외가 발생합니다 &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc2a57a1ff280502a7e9bf05c718df68c27f204e" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;NEXT::ACTUAL&lt;/code&gt;, if there is no other &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the method call, an exception will be thrown (as usually happens in the absence of a suitable &lt;code&gt;AUTOLOAD&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f260eb29b6f0673bfdb6b907d310d5d3920f6717" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;-E&lt;/code&gt; switch on the Perl command-line instead of &lt;code&gt;-e&lt;/code&gt; . That will enable the feature bundle for that version of Perl in the main compilation unit (that is, the one-liner that follows &lt;code&gt;-E&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 대신 Perl 명령 행 에서 &lt;code&gt;-E&lt;/code&gt; 스위치 를 사용합니다 . 그러면 주 컴파일 단위 (즉, &lt;code&gt;-E&lt;/code&gt; 뒤에 오는 하나의 라이너)에서 해당 버전의 Perl에 대한 기능 번들이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="23fbc447da7d6e302f0723443cc59549d355126a" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;-E&lt;/code&gt; switch on the Perl command-line instead of &lt;code&gt;-e&lt;/code&gt;. That will enable the feature bundle for that version of Perl in the main compilation unit (that is, the one-liner that follows &lt;code&gt;-E&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfef463e4e713cbb716245b6be6a4856999a34d" translate="yes" xml:space="preserve">
          <source>By using the WWW interface you can ask the Upload Server to mirror your modules from your ftp or WWW site into your own directory on CPAN!</source>
          <target state="translated">WWW 인터페이스를 사용하면 ftp 또는 WWW 사이트에서 CPAN의 고유 디렉토리로 모듈을 미러링하도록 업로드 서버에 요청할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="4f37c6bc860992a71dc03ba0a6eb8583644d0eac" translate="yes" xml:space="preserve">
          <source>By using the backslash operator on a variable, subroutine, or value. (This works much like the &amp;amp; (address-of) operator in C.) This typically creates</source>
          <target state="translated">변수, 서브 루틴 또는 값에서 백 슬래시 연산자를 사용합니다. (이것은 C의 &amp;amp; (주소) 연산자와 매우 유사합니다.) 이것은 일반적으로</target>
        </trans-unit>
        <trans-unit id="4fea865bf2bc7c769f8247d0ffedba42a3ee67f2" translate="yes" xml:space="preserve">
          <source>By way of demonstration, we present below a laborious listing resulting from setting your &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable to the value &lt;code&gt;f=n N&lt;/code&gt; , and running</source>
          <target state="translated">설명을 위해 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 환경 변수를 값 &lt;code&gt;f=n N&lt;/code&gt; 으로 설정하고 실행 한 결과로 힘든 목록이 아래에 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="762b8206672bed376e88659055a2184381b41345" translate="yes" xml:space="preserve">
          <source>By way of demonstration, we present below a laborious listing resulting from setting your &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable to the value &lt;code&gt;f=n N&lt;/code&gt;, and running</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ff92e836fe1c104b327e3d41d6f42c1c2f68cf" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">Perl의 내장 getgr * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8701f0c6760ad255897a2adbc246d9e8608c8d7a" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">Perl의 내장 gethost * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8edbac978dbd72904307e2cc9662b26a10b3bd66" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">Perl의 내장 getnet * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="905cb97e8ed297dc43dcd08d2a9db1d9958b4ddc" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">Perl의 내장 getproto * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="7980958e534d59fc2ef012727304a32f6778bc74" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">Perl의 내장 getpw * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="8c13e6c841eee178cc9c90b3ec31731fb7b6e9d6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">Perl의 내장 getserv * () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="10bacc859a37b5cb2457a9867f2de200be21a6bd" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Perl의 내장 gmtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="827cbeee072a43490f322081b175fcaabf1286c6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Perl의 내장 localtime () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="34a637e08658f8356d26a5052ced9a5575ccaa48" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in stat() functions</source>
          <target state="translated">Perl의 내장 stat () 함수에 대한 이름 별 인터페이스</target>
        </trans-unit>
        <trans-unit id="00a7465e9ae8fc45cdd85380909fc57080f23c9d" translate="yes" xml:space="preserve">
          <source>Bypass shell script and produce qualifiers for CC directly (but warn user if a shell script for this extension exists). Fold multiple /Defines into one, since some C compilers pay attention to only one instance of this qualifier on the command line.</source>
          <target state="translated">쉘 스크립트를 무시하고 CC에 대한 규정자를 직접 생성하십시오 (그러나이 확장의 쉘 스크립트가 존재하면 사용자에게 경고하십시오). 일부 C 컴파일러는 명령 행에서이 규정 자의 한 인스턴스에만주의를 기울이므로 여러 개의 / Defines을 하나로 접으십시오.</target>
        </trans-unit>
        <trans-unit id="9f9d63573452a4bd55326feb5fe5283989ad472d" translate="yes" xml:space="preserve">
          <source>Byte and Character Semantics</source>
          <target state="translated">바이트 및 문자 의미</target>
        </trans-unit>
        <trans-unit id="1e6a3eac8ab6b01ca95c7c44eb60befc42854a50" translate="yes" xml:space="preserve">
          <source>Byte order is not compatible</source>
          <target state="translated">바이트 순서가 호환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="635424c9374984012107c0dd02fd2041e999753a" translate="yes" xml:space="preserve">
          <source>Byte-order modifiers</source>
          <target state="translated">바이트 순서 수정 자</target>
        </trans-unit>
        <trans-unit id="b0cb8dbe3d4ffe27cb86b68da21fae1475b9d341" translate="yes" xml:space="preserve">
          <source>Byteorders &lt;code&gt;&quot;1234&quot;&lt;/code&gt; and &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; are little-endian; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; and &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; are big-endian. Systems with multiarchitecture binaries will have &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; , signifying that static information doesn't work, one must use runtime probing.</source>
          <target state="translated">바이트 순서 &lt;code&gt;&quot;1234&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; 은 리틀 엔디안입니다. &lt;code&gt;&quot;4321&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; 은 빅 엔디안입니다. 멀티 아키텍처 바이너리가있는 시스템은 &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; 로 정적 정보가 작동하지 않음을 나타내며 런타임 프로빙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d6d1561fa64dc379f38a143df1bb4bb4ff06800" translate="yes" xml:space="preserve">
          <source>Byteorders &lt;code&gt;&quot;1234&quot;&lt;/code&gt; and &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; are little-endian; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; and &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; are big-endian. Systems with multiarchitecture binaries will have &lt;code&gt;&quot;ffff&quot;&lt;/code&gt;, signifying that static information doesn't work, one must use runtime probing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3272df7ee0cf3835350319a829ff6f62b6d4f831" translate="yes" xml:space="preserve">
          <source>Bytes in the source text that are not in the ASCII character set will be treated as being part of a literal UTF-8 sequence. This includes most literals such as identifier names, string constants, and constant regular expression patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf6c5677e50bfc87de6c08c11b4d2bd476a1535" translate="yes" xml:space="preserve">
          <source>Bytes in the source text that have their high-bit set will be treated as being part of a literal UTF-X sequence. This includes most literals such as identifier names, string constants, and constant regular expression patterns.</source>
          <target state="translated">상위 비트 세트가있는 소스 텍스트의 바이트는 리터럴 UTF-X 시퀀스의 일부로 처리됩니다. 여기에는 식별자 이름, 문자열 상수 및 상수 정규 표현식 패턴과 같은 대부분의 리터럴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ede17bae171156d89f14a0594c04dccf3d5c2c4c" translate="yes" xml:space="preserve">
          <source>Bytes that correspond to ASCII-range code points will have their normal meanings for operators in the string. The treatment of the other bytes depends on if the &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;'unicode_strings&quot;&lt;/code&gt; feature&lt;/a&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227fdfe21232054f75a3165f51d73d4e5aa71986" translate="yes" xml:space="preserve">
          <source>Bzip2</source>
          <target state="translated">Bzip2</target>
        </trans-unit>
        <trans-unit id="b72c1bfc3d1aa62c14107ddc13ff2beb37ac2390" translate="yes" xml:space="preserve">
          <source>Bzip2 (method 12)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bb7f85363a7a7907526dffcd31355e1e334924" translate="yes" xml:space="preserve">
          <source>Bzip2 Compression Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9aa98649ca48285f49e53319341c39216b042a" translate="yes" xml:space="preserve">
          <source>Bzip2 Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="129226dbff7ac0a26641ae86a93a3ce3ab2b8aca" translate="yes" xml:space="preserve">
          <source>C Operators Missing From Perl</source>
          <target state="translated">Perl에서 누락 된 C 연산자</target>
        </trans-unit>
        <trans-unit id="b810a5ecd150e1d0012428a848e5d769f60fea9b" translate="yes" xml:space="preserve">
          <source>C RTL</source>
          <target state="translated">C RTL</target>
        </trans-unit>
        <trans-unit id="17a5304c5884fe220f513c1c918ef7adab324995" translate="yes" xml:space="preserve">
          <source>C backtrace</source>
          <target state="translated">C 역 추적</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C 코드</target>
        </trans-unit>
        <trans-unit id="ebcfbca1a38de887c4893368cd463906e0bbe7b3" translate="yes" xml:space="preserve">
          <source>C code to place between the assignment of value (to a temporary) and the return from the function. This allows you to clear up anything in</source>
          <target state="translated">값 할당 (임시)과 함수 반환 사이에 배치 할 C 코드. 이것은 당신이 무엇이든을 정리할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="538185c3d7f303f06af9140ec0da107705c84d52" translate="yes" xml:space="preserve">
          <source>C code to use before the assignment of the value of the constant. This allows you to use temporary variables to extract a value from part of a &lt;code&gt;struct&lt;/code&gt; and return this as</source>
          <target state="translated">상수 값을 할당하기 전에 사용할 C 코드. 이를 통해 임시 변수를 사용하여 &lt;code&gt;struct&lt;/code&gt; 일부에서 값을 추출하여 다음과 같이 반환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0d6da997067e1b793fb43677b57abb70e6d14673" translate="yes" xml:space="preserve">
          <source>C doesn't have a concept of local scope, so perl provides one. We've seen that &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; are used as scoping braces; the save stack implements the C equivalent of, for example:</source>
          <target state="translated">C에는 로컬 범위 개념이 없으므로 perl이 제공합니다. 우리는 &lt;code&gt;ENTER&lt;/code&gt; 와 &lt;code&gt;LEAVE&lt;/code&gt; 가 범위 괄호로 사용되는 것을 보았습니다 . 저장 스택은 다음과 같은 C를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="062ffdd22a0d9502c039f8528f8150dbe0714cfe" translate="yes" xml:space="preserve">
          <source>C function parameters are normally initialized with their values from the argument stack (which in turn contains the parameters that were passed to the XSUB from Perl). The typemaps contain the code segments which are used to translate the Perl values to the C parameters. The programmer, however, is allowed to override the typemaps and supply alternate (or additional) initialization code. Initialization code starts with the first &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; on a line in the INPUT: section. The only exception happens if this &lt;code&gt;;&lt;/code&gt; terminates the line, then this &lt;code&gt;;&lt;/code&gt; is quietly ignored.</source>
          <target state="translated">C 함수 매개 변수는 일반적으로 인수 스택의 값으로 초기화됩니다 (Perl에서 XSUB로 전달 된 매개 변수가 포함됨). 유형 맵에는 Perl 값을 C 매개 변수로 변환하는 데 사용되는 코드 세그먼트가 포함됩니다. 그러나 프로그래머는 유형 맵을 대체하고 대체 (또는 추가) 초기화 코드를 제공 할 수 있습니다. 처음으로 초기화 코드 시작 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; 또는 INPUT : 섹션의 라인에서 &lt;code&gt;+&lt;/code&gt; 이 경우 유일한 예외가 발생합니다 &lt;code&gt;;&lt;/code&gt; 라인을 종료 한 다음 &lt;code&gt;;&lt;/code&gt; 조용히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="213fb315de520b456a3df78bdf4d7f2421cc02be" translate="yes" xml:space="preserve">
          <source>C function parameters are normally initialized with their values from the argument stack (which in turn contains the parameters that were passed to the XSUB from Perl). The typemaps contain the code segments which are used to translate the Perl values to the C parameters. The programmer, however, is allowed to override the typemaps and supply alternate (or additional) initialization code. Initialization code starts with the first &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; on a line in the INPUT: section. The only exception happens if this &lt;code&gt;;&lt;/code&gt; terminates the line, then this &lt;code&gt;;&lt;/code&gt; is quietly ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ca94bf1de4049e4f9bdaa005b019e6d57ed90a" translate="yes" xml:space="preserve">
          <source>C header file. This file contains a series of macros and, if explicitly requested, functions that allow XS modules to be built using older versions of Perl. Currently, Perl versions from 5.003 to 5.20 are supported.</source>
          <target state="translated">C 헤더 파일 이 파일에는 일련의 매크로와 명시 적으로 요청 된 경우 이전 버전의 Perl을 사용하여 XS 모듈을 빌드 할 수있는 기능이 포함되어 있습니다. 현재 5.003에서 5.20까지의 Perl 버전이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2d0d49f7751613335f0d49f8a0f5d1a5a2b15669" translate="yes" xml:space="preserve">
          <source>C header file. This file contains a series of macros and, if explicitly requested, functions that allow XS modules to be built using older versions of Perl. Currently, Perl versions from 5.003_07 to 5.31.6 are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90cbbad6ac1bd0dbc637e8984710d08b0d07f9c" translate="yes" xml:space="preserve">
          <source>C header file.)</source>
          <target state="translated">C 헤더 파일)</target>
        </trans-unit>
        <trans-unit id="c22974d869d3644dd5d37745dcc22b37d2c1793e" translate="yes" xml:space="preserve">
          <source>C implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6475b4e6bb646eb3e0b6202577ce4b2fb0cd180d" translate="yes" xml:space="preserve">
          <source>C keyword introducing a structure definition or name.</source>
          <target state="translated">구조 정의 또는 이름을 소개하는 C 키워드.</target>
        </trans-unit>
        <trans-unit id="399adcb6a34b5f69b459a531d78f258d2967e635" translate="yes" xml:space="preserve">
          <source>C library functions instead. In this case &lt;code&gt;memchr&lt;/code&gt; can be used to see if &lt;code&gt;c&lt;/code&gt; is in &lt;code&gt;&quot;list&quot;&lt;/code&gt; and works even if &lt;code&gt;c&lt;/code&gt; is &lt;code&gt;NUL&lt;/code&gt;. These functions need an additional parameter to give the string length. In the case of literal string parameters, perl has defined macros that calculate the length for you. See &lt;a href=&quot;perlapi#Miscellaneous-Functions&quot;&gt;&quot;Miscellaneous Functions&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e71f3bcd3ba5c06990be4ccb0628ea48bb58a61" translate="yes" xml:space="preserve">
          <source>C preprocessor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4b78bc2d00244d4f2291c70d25ad9ed10ec746" translate="yes" xml:space="preserve">
          <source>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions. Comments are allowed anywhere after the MODULE keyword. The compiler will pass the preprocessor directives through untouched and will remove the commented lines. POD documentation is allowed at any point, both in the C and XS language sections. POD must be terminated with a &lt;code&gt;=cut&lt;/code&gt; command; &lt;code&gt;xsubpp&lt;/code&gt; will exit with an error if it does not. It is very unlikely that human generated C code will be mistaken for POD, as most indenting styles result in whitespace in front of any line starting with &lt;code&gt;=&lt;/code&gt; . Machine generated XS files may fall into this trap unless care is taken to ensure that a space breaks the sequence &quot;\n=&quot;.</source>
          <target state="translated">C 프리 프로세서 지시문은 BOOT :, PREINIT : INIT :, CODE :, PPCODE :, POSTCALL : 및 CLEANUP : 블록 내 및 함수 외부에서 허용됩니다. MODULE 키워드 다음에 주석이 허용됩니다. 컴파일러는 수정되지 않은 채로 전 처리기 지시문을 전달하고 주석 처리 된 행을 제거합니다. POD 문서는 C 및 XS 언어 섹션에서 언제든지 허용됩니다. POD는 &lt;code&gt;=cut&lt;/code&gt; 명령 으로 종료해야합니다 . &lt;code&gt;xsubpp&lt;/code&gt; 가 없으면 오류와 함께 종료됩니다. 대부분의 들여 쓰기 스타일로 인해 &lt;code&gt;=&lt;/code&gt; 로 시작하는 행 앞에 공백이 생기기 때문에 사람이 생성 한 C 코드가 POD로 오인 될 가능성은 거의 없습니다 . 공간이 시퀀스 &quot;\ n =&quot;을 손상시키지 않도록주의를 기울이지 않으면 시스템 생성 XS 파일이이 트랩에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8020cdca86500f6da443db0c3bcae725eafd266" translate="yes" xml:space="preserve">
          <source>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions. Comments are allowed anywhere after the MODULE keyword. The compiler will pass the preprocessor directives through untouched and will remove the commented lines. POD documentation is allowed at any point, both in the C and XS language sections. POD must be terminated with a &lt;code&gt;=cut&lt;/code&gt; command; &lt;code&gt;xsubpp&lt;/code&gt; will exit with an error if it does not. It is very unlikely that human generated C code will be mistaken for POD, as most indenting styles result in whitespace in front of any line starting with &lt;code&gt;=&lt;/code&gt;. Machine generated XS files may fall into this trap unless care is taken to ensure that a space breaks the sequence &quot;\n=&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b72786c4e2763e287b454e5689b07155e0cdb40" translate="yes" xml:space="preserve">
          <source>C&amp;lt;_pc_chown_restricted&amp;gt; symbol (for example, Windows NT) it is assumed that ``chown() giveaway'' is possible and the recursive test is performed.</source>
          <target state="translated">C &amp;lt;_pc_chown_restricted&amp;gt; 기호 (예 : Windows NT)``chown () giveaway ''가 가능하고 재귀 테스트가 수행되는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1978f4f5f2811138c5f2f911584623110e67b626" translate="yes" xml:space="preserve">
          <source>C++-style one-line '//'-comments (JSON::PP only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d682623210c6b24f8d8f68ce43a83783f1b6c8af" translate="yes" xml:space="preserve">
          <source>C-style Logical And</source>
          <target state="translated">C 스타일 논리 및</target>
        </trans-unit>
        <trans-unit id="468d5b286c1316bc4a6baa7daaefae5e90272197" translate="yes" xml:space="preserve">
          <source>C-style Logical Or</source>
          <target state="translated">C 스타일 논리 또는</target>
        </trans-unit>
        <trans-unit id="737b024863913bee156948e275791da6eb8f4b38" translate="yes" xml:space="preserve">
          <source>C-style multiple-line '/* */'-comments (JSON::PP only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0403ad1f3298e7e9e68a2636bf42146ffa41b4ae" translate="yes" xml:space="preserve">
          <source>C. BUILD</source>
          <target state="translated">C. 빌딩</target>
        </trans-unit>
        <trans-unit id="253cf957599cb78b1482e6eb5a8fa9c3483eda97" translate="yes" xml:space="preserve">
          <source>C.UTF</source>
          <target state="translated">C.UTF</target>
        </trans-unit>
        <trans-unit id="624f656f2b44769e8027ab2f2c47b638fe6eea88" translate="yes" xml:space="preserve">
          <source>C/C++ Traps</source>
          <target state="translated">C / C ++ 트랩</target>
        </trans-unit>
        <trans-unit id="d8bdd8cfb0c27a9643fac03c57e2c9dde9e10b0d" translate="yes" xml:space="preserve">
          <source>C3 is the name of an algorithm which aims to provide a sane method resolution order under multiple inheritance. It was first introduced in the language Dylan (see links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; section), and then later adopted as the preferred MRO (Method Resolution Order) for the new-style classes in Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO for Perl 6 classes, and the default MRO for Parrot objects as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633490a93f1c6b59da0e4592f3c36f5d9d5fc276" translate="yes" xml:space="preserve">
          <source>C3 is the name of an algorithm which aims to provide a sane method resolution order under multiple inheritance. It was first introduced in the language Dylan (see links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section), and then later adopted as the preferred MRO (Method Resolution Order) for the new-style classes in Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO for Perl 6 classes, and the default MRO for Parrot objects as well.</source>
          <target state="translated">C3은 다중 상속에서 정상적인 메소드 해결 순서를 제공하는 것을 목표로하는 알고리즘의 이름입니다. 이 언어는 Dylan 언어로 처음 소개되었고 ( &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; 섹션의 링크 참조 ) 나중에 Python 2.3의 새 스타일 클래스에 대해 선호되는 MRO (Method Resolution Order)로 채택되었습니다. 가장 최근에는 Perl 6 클래스의 &quot;표준&quot;MRO로, Parrot 객체의 기본 MRO로 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="4aa8a8fa5eacc54ba9f8a4e755d8440833ba62a6" translate="yes" xml:space="preserve">
          <source>C3 works by always preserving local precedence ordering. This essentially means that no class will appear before any of its subclasses. Take, for instance, the classic diamond inheritance pattern:</source>
          <target state="translated">C3은 항상 로컬 우선 순위 순서를 유지하여 작동합니다. 이것은 본질적으로 어떤 클래스도 서브 클래스 앞에 나타나지 않음을 의미합니다. 예를 들어, 고전적인 다이아몬드 상속 패턴을 보자.</target>
        </trans-unit>
        <trans-unit id="1173dbb43313d07b70a93fae991af36789693f17" translate="yes" xml:space="preserve">
          <source>C:</source>
          <target state="translated">C:</target>
        </trans-unit>
        <trans-unit id="7a382120912440ea350318c064061d0e6ea8184a" translate="yes" xml:space="preserve">
          <source>C:/emx.add/bin/bash.exe</source>
          <target state="translated">C:/emx.add/bin/bash.exe</target>
        </trans-unit>
        <trans-unit id="519c5bd785564af1dec76cf3a5edc1bf3e894ac6" translate="yes" xml:space="preserve">
          <source>C:/emx/bin/foo.cmd</source>
          <target state="translated">C:/emx/bin/foo.cmd</target>
        </trans-unit>
        <trans-unit id="f6665c2627be2b969dcd410132185e0dd599f37b" translate="yes" xml:space="preserve">
          <source>CALLBACKS</source>
          <target state="translated">CALLBACKS</target>
        </trans-unit>
        <trans-unit id="3991ab584fec70130dcdb49fb4dbe4638d6f1b90" translate="yes" xml:space="preserve">
          <source>CALLING FROM PERL</source>
          <target state="translated">펄에서 전화</target>
        </trans-unit>
        <trans-unit id="5f0a327136ac9e42e9905406e9cf6ed2f2b8cdbf" translate="yes" xml:space="preserve">
          <source>CALLING FROM THE COMMAND LINE</source>
          <target state="translated">명령 줄에서 전화</target>
        </trans-unit>
        <trans-unit id="3b04e0388b12d5718ab0ab4fbeede800c9bdf464" translate="yes" xml:space="preserve">
          <source>CALL_BLOCK_HOOKS</source>
          <target state="translated">CALL_BLOCK_HOOKS</target>
        </trans-unit>
        <trans-unit id="aa884ac53759d984488c656f65f21f650359027e" translate="yes" xml:space="preserve">
          <source>CAN</source>
          <target state="translated">CAN</target>
        </trans-unit>
        <trans-unit id="5f05bf320ccd994a5b4376cbf772126d72a752e5" translate="yes" xml:space="preserve">
          <source>CANONICAL REPRESENTATION</source>
          <target state="translated">정식 표현</target>
        </trans-unit>
        <trans-unit id="ed877e5c7f10c31f466df09c23df16788f087cc2" translate="yes" xml:space="preserve">
          <source>CANONICAL_NAME</source>
          <target state="translated">CANONICAL_NAME</target>
        </trans-unit>
        <trans-unit id="7c383ee49414a970f2fefff09538765cce85b6f7" translate="yes" xml:space="preserve">
          <source>CAN_FORK</source>
          <target state="translated">CAN_FORK</target>
        </trans-unit>
        <trans-unit id="d89bfce77d1d10d8b67301ffcd86ad4a0fd51999" translate="yes" xml:space="preserve">
          <source>CAN_REALLY_FORK</source>
          <target state="translated">CAN_REALLY_FORK</target>
        </trans-unit>
        <trans-unit id="a10ef324dbcf8652446a083bde0eb77789137e55" translate="yes" xml:space="preserve">
          <source>CAN_THREAD</source>
          <target state="translated">CAN_THREAD</target>
        </trans-unit>
        <trans-unit id="e520869852c82bbce05b6c5dc47274d3b3a11987" translate="yes" xml:space="preserve">
          <source>CATEGORIES</source>
          <target state="translated">CATEGORIES</target>
        </trans-unit>
        <trans-unit id="980aeb7f8f581c6b66ed59bbbed49733515b10e6" translate="yes" xml:space="preserve">
          <source>CAVEAT</source>
          <target state="translated">CAVEAT</target>
        </trans-unit>
        <trans-unit id="b72f8eb839f7acede3b2ca8386d0ebe48e624e02" translate="yes" xml:space="preserve">
          <source>CAVEAT %A, %a, %B, %b, and friends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6567e0b0a7daf3c098913aa924483cfe44852131" translate="yes" xml:space="preserve">
          <source>CAVEAT FOR GREAT CIRCLE FORMULAS</source>
          <target state="translated">대순환 공식에 대한 경고</target>
        </trans-unit>
        <trans-unit id="8ae97560e6c967ffcb76f6cd835c75b45c6b2d57" translate="yes" xml:space="preserve">
          <source>CAVEAT ON PRECEDENCE</source>
          <target state="translated">우선주의</target>
        </trans-unit>
        <trans-unit id="1c968ba436040f2ef7532a90991da165ff0512dd" translate="yes" xml:space="preserve">
          <source>CAVEAT: The thread signalling capability provided by this module does not actually send signals via the OS. It</source>
          <target state="translated">주의 :이 모듈에서 제공하는 스레드 신호 기능은 실제로 OS를 통해 신호를 보내지 않습니다. 그것</target>
        </trans-unit>
        <trans-unit id="ce611c3a23df37ff734feee69c06233d5c9abfb4" translate="yes" xml:space="preserve">
          <source>CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless and as of this writing Encode suite just leave it as is (\x{FeFF}).</source>
          <target state="translated">주의 사항 : utf8 (\ xEF \ xBB \ xBF)의 BOM은 유효하지만 의미가 없으며이 코드 작성 당시에는 그대로 (\ x {FeFF}) 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="5ea0a6fefc9f66fb07ad0567375a2c4308c1f112" translate="yes" xml:space="preserve">
          <source>CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.</source>
          <target state="translated">경고 : UTF- (16 | 32)와 달리 utf8의 BOM은 자동으로 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0852d6090cb36f8c92fc678e7c0ed0101951986e" translate="yes" xml:space="preserve">
          <source>CAVEATS</source>
          <target state="translated">CAVEATS</target>
        </trans-unit>
        <trans-unit id="afa50a96d52c4af6173a5b3dcf9e10a0a47c02ab" translate="yes" xml:space="preserve">
          <source>CAVEATS AND LIMITATIONS</source>
          <target state="translated">주의 사항 및 제한 사항</target>
        </trans-unit>
        <trans-unit id="8db2d4672c0bb6f4ea12967ef5822987358da334" translate="yes" xml:space="preserve">
          <source>CAVEATS and NOTES</source>
          <target state="translated">주의 사항 및 참고</target>
        </trans-unit>
        <trans-unit id="2730fdc488249d7bafe77293689db04473acbaf2" translate="yes" xml:space="preserve">
          <source>CC0 1.0 Universal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e7743e5b77bff9708c13ccf20fcc50d9073b5e" translate="yes" xml:space="preserve">
          <source>CCFLAGS</source>
          <target state="translated">CCFLAGS</target>
        </trans-unit>
        <trans-unit id="34d724a57223d56ce5370f930a6de174ea64e793" translate="yes" xml:space="preserve">
          <source>CCTools</source>
          <target state="translated">CCTools</target>
        </trans-unit>
        <trans-unit id="422f720e7d72716b7017e69268406be073cfc7c1" translate="yes" xml:space="preserve">
          <source>CGI</source>
          <target state="translated">CGI</target>
        </trans-unit>
        <trans-unit id="41a4605be9cd5708c0812fcf96a67b02ae213ace" translate="yes" xml:space="preserve">
          <source>CGI.pm</source>
          <target state="translated">CGI.pm</target>
        </trans-unit>
        <trans-unit id="313c83d1d2e8c998d1416c76ceb327085bafcc5a" translate="yes" xml:space="preserve">
          <source>CHANGED IN PERL 5.6</source>
          <target state="translated">PERL 5.6에서 변경</target>
        </trans-unit>
        <trans-unit id="15a7fa79c2e880d7c668e6f0bb63190d52852647" translate="yes" xml:space="preserve">
          <source>CHANGED in 3.18</source>
          <target state="translated">3.18에서 변경</target>
        </trans-unit>
        <trans-unit id="a2feb6ed0257c21c6672793ee2f94eaadc10c72c" translate="yes" xml:space="preserve">
          <source>CHANGES</source>
          <target state="translated">CHANGES</target>
        </trans-unit>
        <trans-unit id="77e515bcbeea42a381522b3f02fc083d411a62f5" translate="yes" xml:space="preserve">
          <source>CHARACTER CLASSES</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="80ca0b224740835c619b09444159e57296b64d7e" translate="yes" xml:space="preserve">
          <source>CHARDEV</source>
          <target state="translated">CHARDEV</target>
        </trans-unit>
        <trans-unit id="a375cca9c609e8591d1c22cf8e8a8c4bbd0e6f6f" translate="yes" xml:space="preserve">
          <source>CHARMAP starts the character map section. Each line has a form as follows:</source>
          <target state="translated">CHARMAP은 문자표 섹션을 시작합니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd3cbf6697996c51d6a64a08ee8b874fefe67b" translate="yes" xml:space="preserve">
          <source>CHARNAME</source>
          <target state="translated">CHARNAME</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="0a228e95208b8ea7acb00589cdd0f311e92f3483" translate="yes" xml:space="preserve">
          <source>CHECKSUM FUNCTIONS</source>
          <target state="translated">체크섬 기능</target>
        </trans-unit>
        <trans-unit id="375b607411c5c81ce08dc5795ece2335113cdfb6" translate="yes" xml:space="preserve">
          <source>CJK.inf</source>
          <target state="translated">CJK.inf</target>
        </trans-unit>
        <trans-unit id="1f22ed2c7cd021c0f2f66309f2f05fa0c8cba3b9" translate="yes" xml:space="preserve">
          <source>CJK: Chinese, Japanese, Korean (Multibyte)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a149ba82f2f03dc5065a0af0c7f361f94591fd8e" translate="yes" xml:space="preserve">
          <source>CJKRadicals.txt</source>
          <target state="translated">CJKRadicals.txt</target>
        </trans-unit>
        <trans-unit id="1cd4dc2f81b0a6fdbbb287d0cb553f7eb2bc1256" translate="yes" xml:space="preserve">
          <source>CJKV Information Processing 1999 O'Reilly &amp;amp; Associates, ISBN : 1-56592-224-7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb95f17d9243e483e268617dbce738cf49527ccf" translate="yes" xml:space="preserve">
          <source>CLASS</source>
          <target state="translated">CLASS</target>
        </trans-unit>
        <trans-unit id="0d2dc3d6989d0491c087fdf8b26389f6609dba54" translate="yes" xml:space="preserve">
          <source>CLASS METHODS</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="dbf4163822f839bcdb88c4da697b65983c814143" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_1ex(N)</source>
          <target state="translated">CLASS-&amp;gt;_1ex(N)</target>
        </trans-unit>
        <trans-unit id="5e3cd43942de5bc55bb4b61dff2152defa5e665c" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_acmp(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fe5b11e664f45527c8cbf573b1b4a9111881ab" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_add(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe8e3c720a50c4d2a9750528931e93986936121" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_alen(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_alen(OBJ)</target>
        </trans-unit>
        <trans-unit id="9c0f693334bb3b43074ff7fb54e0a35e69585bdc" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_and(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373f5c07704d916c11b9458bafdf0b3c797ab20b" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_as_bin(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_as_bin(OBJ)</target>
        </trans-unit>
        <trans-unit id="ae3b000dcb18d4a9a9b9e0c641ae341959b8b1f3" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_as_bytes(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_as_bytes(OBJ)</target>
        </trans-unit>
        <trans-unit id="939aeb6ab73227e57772ccf8d1bbefe66e8960e7" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_as_hex(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_as_hex(OBJ)</target>
        </trans-unit>
        <trans-unit id="230ca81d0842013c25749d9d81db1f748148ed30" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_as_oct(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_as_oct(OBJ)</target>
        </trans-unit>
        <trans-unit id="aa47a54f32aa5d9aedfbc8b0516ffb16b4e8ad9b" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_check(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_check(OBJ)</target>
        </trans-unit>
        <trans-unit id="b76d89ef951323f62ea3d4f7e3bf6625216a664e" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_copy(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_copy(OBJ)</target>
        </trans-unit>
        <trans-unit id="7b316610efe595918ab265cc516b10525cb0a9e4" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_dec(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_dec(OBJ)</target>
        </trans-unit>
        <trans-unit id="eff86bbc5c81f0ef90c6a67839537dc95561de27" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_dfac(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_dfac(OBJ)</target>
        </trans-unit>
        <trans-unit id="65789515386f4257376ec8b095a149f8249a54c8" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_digit(OBJ, N)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0a5425bf5954e529e526265bbbe725dac5b692" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_digitsum(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_digitsum(OBJ)</target>
        </trans-unit>
        <trans-unit id="01cc9e41069c631dbebc0964cbf38d39d062d70c" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_div(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81104bf1f4830cc5d2f3062c9f17bb351dcea9e5" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_fac(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_fac(OBJ)</target>
        </trans-unit>
        <trans-unit id="9bebd4b16a3688a92b9ec1309e0093ef6c878a26" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_fib(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_fib(OBJ)</target>
        </trans-unit>
        <trans-unit id="9c38737454337b63e376846c30d93e58da737182" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_from_base(STR, BASE, COLLSEQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554065c0180a909fc6b23180a8a9cfc40b6e7245" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_from_bin(STR)</source>
          <target state="translated">CLASS-&amp;gt;_from_bin(STR)</target>
        </trans-unit>
        <trans-unit id="e0b67da5a286b962b5103b9d3a1b9a892b1ed509" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_from_bytes(STR)</source>
          <target state="translated">CLASS-&amp;gt;_from_bytes(STR)</target>
        </trans-unit>
        <trans-unit id="c243787e132d2a094d8a15627a1a7451a3814933" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_from_hex(STR)</source>
          <target state="translated">CLASS-&amp;gt;_from_hex(STR)</target>
        </trans-unit>
        <trans-unit id="bee67c462491c6f639f9d7df02ebc91914ba0651" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_from_oct(STR)</source>
          <target state="translated">CLASS-&amp;gt;_from_oct(STR)</target>
        </trans-unit>
        <trans-unit id="79947d07c35c8d7ca8fb7ab582580ad09f68a270" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_gcd(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf870d7b557e437ecc4f6df31048e61c1a766639" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_inc(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_inc(OBJ)</target>
        </trans-unit>
        <trans-unit id="57ef40818297d41ce5ae6dfe2935cbe10a948e55" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_even(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_even(OBJ)</target>
        </trans-unit>
        <trans-unit id="78e92a508444c9a4e153cb27dec44ce710d3fbfb" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_odd(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_odd(OBJ)</target>
        </trans-unit>
        <trans-unit id="4e20f7c171116a375cf13642bc296e79fa405fdc" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_one(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_one(OBJ)</target>
        </trans-unit>
        <trans-unit id="f88b575610df28090e82ca09cbc271fba882a984" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_ten(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_ten(OBJ)</target>
        </trans-unit>
        <trans-unit id="c073383626cbcb436b52f80e441e3525185a9c35" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_two(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_two(OBJ)</target>
        </trans-unit>
        <trans-unit id="0931755142c2e5061f082dcab3a8b3d06ee0d673" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_is_zero(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_is_zero(OBJ)</target>
        </trans-unit>
        <trans-unit id="52b59fb9ef6c768eaf71a7b4d2195bdd1507ba3e" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_lcm(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e0eb30c18735b72536d99d8876be0e0f45994a" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_len(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_len(OBJ)</target>
        </trans-unit>
        <trans-unit id="4c7950e347030db6d9cf7aeabf66a289e6d4957c" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_log_int(OBJ, B)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8371d73a223d5f3f24b060cd71a0b488611602" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_lsft(OBJ, N, B)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cba7fcab6b1e38e812527c51957fb448a1dfbd" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_lucas(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_lucas(OBJ)</target>
        </trans-unit>
        <trans-unit id="d1020b2df8e6bc65d3831c16910a186a6aedb167" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_mod(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c329275261c155dd0553c2b9d32d417c6fd959" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_modinv(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bd4b6eae9a7e994127aca1153ee769bb0a4fc5" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_modpow(OBJ1, OBJ2, OBJ3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d6ac0e0c4cf42a3b72e71957f069a23ecaca7a" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_mul(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b5e20b6fa3144b91ee9cc34948365f3de5f56" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_new(STR)</source>
          <target state="translated">CLASS-&amp;gt;_new(STR)</target>
        </trans-unit>
        <trans-unit id="8f05265514c627bfe1c1bb7fc447201ea3dc0844" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_nok(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8735ec3c7027990b743211f907d190471dab8b0d" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_num(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_num(OBJ)</target>
        </trans-unit>
        <trans-unit id="7063799ab7a1554372ab0077a85ae240ce398e0e" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_one()</source>
          <target state="translated">CLASS-&amp;gt;_one()</target>
        </trans-unit>
        <trans-unit id="6a5ee9d5848f3b7486015f8969d7466409265df6" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_or(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f28b295d6374c491c3fe35b78ae7b6181398402" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_pow(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db0025cc70599004bf6f7ce6450bde2b7750c10" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_root(OBJ, N)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383991a80a7684e88dc70dca994e1117d7ba4c8f" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_rsft(OBJ, N, B)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6829cafc5ea39d01bb87254edd352f6bc5503975" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sand(OBJ1, OBJ2, SIGN1, SIGN2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3a5c67db38b96d60ac6745a515a2bb726a9a22" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_set(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_set(OBJ)</target>
        </trans-unit>
        <trans-unit id="a57d527484c99992dbfe4499fffa9a173eb3f781" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sor(OBJ1, OBJ2, SIGN1, SIGN2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac0302a0996c0213583a493ee19dd407df00100" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sqrt(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_sqrt(OBJ)</target>
        </trans-unit>
        <trans-unit id="6789029e56909be438f25122aaab1a089e43ffe8" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_str(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_str(OBJ)</target>
        </trans-unit>
        <trans-unit id="2b0825027da9a54d42038acc8d5ba027d5c46cb3" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sub(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4950b9010a4834f9373708080b8e69ae8e9c5c49" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sub(OBJ1, OBJ2, FLAG)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77468e1908c6dafd5d2074208a664ae5e60f2dd1" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_sxor(OBJ1, OBJ2, SIGN1, SIGN2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c7c88b44890239ec86e544ab6611e5cd108682" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_ten()</source>
          <target state="translated">CLASS-&amp;gt;_ten()</target>
        </trans-unit>
        <trans-unit id="7329d1090c0993df5e9a2b709663faa1d6fcf49e" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_to_base(OBJ, BASE, COLLSEQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fcc2b13d1e0c8ebd7f8e44e49e356c78134165" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_to_bin(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_to_bin(OBJ)</target>
        </trans-unit>
        <trans-unit id="7027f3991415488985a9bd72f394eda651f4b3a8" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_to_bytes(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_to_bytes(OBJ)</target>
        </trans-unit>
        <trans-unit id="474f2351bc034f4e2dee67fde64fb9ecd0687fcd" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_to_hex(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_to_hex(OBJ)</target>
        </trans-unit>
        <trans-unit id="eda55669e9a413e319a52f38c9b97d2f80258723" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_to_oct(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_to_oct(OBJ)</target>
        </trans-unit>
        <trans-unit id="35f6b512f149fc5647d9be14d6c3696779666d7b" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_two()</source>
          <target state="translated">CLASS-&amp;gt;_two()</target>
        </trans-unit>
        <trans-unit id="6c043a16c1ce905dc69c182599a1ed3e1706644f" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_xor(OBJ1, OBJ2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1786e012068e0bce30f713c13983059095b9846e" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_zero()</source>
          <target state="translated">CLASS-&amp;gt;_zero()</target>
        </trans-unit>
        <trans-unit id="4427e6621d576c9b9544faafe160d613f16fd0a2" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;_zeros(OBJ)</source>
          <target state="translated">CLASS-&amp;gt;_zeros(OBJ)</target>
        </trans-unit>
        <trans-unit id="98c43027b56d54580ef0f278822b82fba3c6c7b0" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;api_version()</source>
          <target state="translated">CLASS-&amp;gt;api_version()</target>
        </trans-unit>
        <trans-unit id="3a8f000aa3840296550580880a88660b74717610" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;safe_quote ITEM</source>
          <target state="translated">CLASS-&amp;gt; safe_quote 항목</target>
        </trans-unit>
        <trans-unit id="2a5520b8514a16a64037e86c211cbd6b6bfdc1cb" translate="yes" xml:space="preserve">
          <source>CLASSES</source>
          <target state="translated">CLASSES</target>
        </trans-unit>
        <trans-unit id="cd6bd9f33c285fac5da62108d5afffde0dae96e5" translate="yes" xml:space="preserve">
          <source>CLDR - Unicode Common Locale Data Repository</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ec74fc0a433fb02e0d1f99b9c32251a3f73264" translate="yes" xml:space="preserve">
          <source>CLEAR</source>
          <target state="translated">CLEAR</target>
        </trans-unit>
        <trans-unit id="fac58dbcd72067a5f153ffc2c833d4355a2e9136" translate="yes" xml:space="preserve">
          <source>CLEAR this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3e5deafcdb3a6a27a65e5bfeaafad1584429f1" translate="yes" xml:space="preserve">
          <source>CLEAR_ERRSV</source>
          <target state="translated">CLEAR_ERRSV</target>
        </trans-unit>
        <trans-unit id="8c43ea9afe441832e3cd4c7b7273072cf89d4f36" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;cleanup()</source>
          <target state="translated">CLIENT-&amp;gt;cleanup()</target>
        </trans-unit>
        <trans-unit id="358d8a539f6516a3018cd971d1f7108ae888fd92" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;done()</source>
          <target state="translated">CLIENT-&amp;gt;done()</target>
        </trans-unit>
        <trans-unit id="362ae63f2520b0ac6a4a12fc77bc456bba0bbcc3" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;evalcode(STRING)</source>
          <target state="translated">CLIENT-&amp;gt;evalcode(STRING)</target>
        </trans-unit>
        <trans-unit id="ba2a51aebeb9cbe8ede2ee1f099eaf5f9c19efd0" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;idle()</source>
          <target state="translated">CLIENT-&amp;gt;idle()</target>
        </trans-unit>
        <trans-unit id="409e287a81847627c930dbd66e9d048b08e25d40" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;init()</source>
          <target state="translated">CLIENT-&amp;gt;init()</target>
        </trans-unit>
        <trans-unit id="beb8820f770c08f109a42da993198a2bf758e2af" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;next()</source>
          <target state="translated">CLIENT-&amp;gt;next()</target>
        </trans-unit>
        <trans-unit id="f4b64a7bfd435bce1098449143c22fafad1d5535" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;output(LIST)</source>
          <target state="translated">CLIENT-&amp;gt;output(LIST)</target>
        </trans-unit>
        <trans-unit id="02ff864bb0d3ac0d506e8664f9ec2249e935efca" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;poststop([STRING])</source>
          <target state="translated">CLIENT-&amp;gt;poststop([STRING])</target>
        </trans-unit>
        <trans-unit id="d623baf5484b0acf229ea866ad9e9a377eb16b8e" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;prestop([STRING])</source>
          <target state="translated">CLIENT-&amp;gt;prestop([STRING])</target>
        </trans-unit>
        <trans-unit id="1c7a7b82fce1e98c96aff13692c7449dfe17a4b2" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;register()</source>
          <target state="translated">CLIENT-&amp;gt;register()</target>
        </trans-unit>
        <trans-unit id="a0a32439f61153f1114c4f2cbb168b643a0c035f" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;run()</source>
          <target state="translated">CLIENT-&amp;gt;run()</target>
        </trans-unit>
        <trans-unit id="1644fd80139ae09888986e942a4b6aa717e134ed" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;skippkg('D::hide')</source>
          <target state="translated">CLIENT-&amp;gt;skippkg('D::hide')</target>
        </trans-unit>
        <trans-unit id="bc32722474d27f37fcd785205662e484073b7283" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;step()</source>
          <target state="translated">CLIENT-&amp;gt;step()</target>
        </trans-unit>
        <trans-unit id="dfdb07cd11971abb4934eabdc4e75a80161a4535" translate="yes" xml:space="preserve">
          <source>CLIENT-&amp;gt;stop()</source>
          <target state="translated">CLIENT-&amp;gt;stop()</target>
        </trans-unit>
        <trans-unit id="6a75d42526571d5f3b5ee3277f0f56033635d616" translate="yes" xml:space="preserve">
          <source>CLISYM_[LOCAL]</source>
          <target state="translated">CLISYM_[LOCAL]</target>
        </trans-unit>
        <trans-unit id="02511b0ef4c076e32b8ecf4a292ccc2e251c9180" translate="yes" xml:space="preserve">
          <source>CLOBBER</source>
          <target state="translated">CLOBBER</target>
        </trans-unit>
        <trans-unit id="eb2ed6b6d36f266377a9e30f6e145c7fdae07a3f" translate="yes" xml:space="preserve">
          <source>CLONEf_CLONE_HOST - This is a win32 thing, it is ignored on unix, it tells perls win32host code (which is c++) to clone itself, this is needed on win32 if you want to run two threads at the same time, if you just want to do some stuff in a separate perl interpreter and then throw it away and return to the original one, you don't need to do anything.</source>
          <target state="translated">CLONEf_CLONE_HOST-이것은 win32 일이며, 유닉스에서는 무시되고 perls win32host 코드 (c ++)에게 스스로 복제하도록 지시합니다. 이것은 두 스레드를 동시에 실행하려는 경우 win32에서 필요합니다. 별도의 펄 통역사에서 몇 가지 일을 한 다음 버리고 원래의 것으로 돌아 가면 아무것도 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dd06954f8504852be625e8b13f9f38ba4df5c2d" translate="yes" xml:space="preserve">
          <source>CLONEf_COPY_STACKS - is used to, well, copy the stacks also, without it we only clone the data and zero the stacks, with it we copy the stacks and the new perl interpreter is ready to run at the exact same point as the previous one. The pseudo-fork code uses COPY_STACKS while the threads-&amp;gt;create doesn't.</source>
          <target state="translated">CLONEf_COPY_STACKS-스택을 복사하지 않고 데이터를 복제하고 스택을 0으로 만드는 데 사용됩니다. 스택을 복사하면 새로운 perl 인터프리터가 이전과 정확히 같은 시점에서 실행될 수 있습니다. 의사 포크 코드는 COPY_STACKS를 사용하지만 쓰레드-&amp;gt; 만들기는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="496d69294e21b9e9459d9ae5f134da2961a69331" translate="yes" xml:space="preserve">
          <source>CLONEf_KEEP_PTR_TABLE - perl_clone keeps a ptr_table with the pointer of the old variable as a key and the new variable as a value, this allows it to check if something has been cloned and not clone it again but rather just use the value and increase the refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill the ptr_table using the function &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; , reason to keep it around is if you want to dup some of your own variable who are outside the graph perl scans, example of this code is in threads.xs create.</source>
          <target state="translated">CLONEf_KEEP_PTR_TABLE-perl_clone은 이전 변수의 포인터를 키로 사용하고 새 변수를 값으로 사용하여 ptr_table을 유지합니다. 이는 무언가가 복제되었는지 다시 확인하지 않고 값을 사용하고 오히려 값을 사용하고 참조 횟수를 증가시킵니다. KEEP_PTR_TABLE을 설정하지 않으면 perl_clone은 &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; 함수를 사용하여 ptr_table을 종료합니다. PL_ptr_table = NULL; , 그것을 유지하는 이유는 그래프 perl 스캔 외부에있는 자신의 변수 중 일부를 두 드리려는 경우이 코드의 예는 threads.xs create에 있습니다.</target>
        </trans-unit>
        <trans-unit id="07801b8767211109091edb84bc973192295d0f01" translate="yes" xml:space="preserve">
          <source>CLONING THE REPOSITORY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03722f59b0c28be7ddc35c91bb350d9e0cf0b45b" translate="yes" xml:space="preserve">
          <source>CLOSE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e4da4e4f3b9df4371883c2c534d94c9bbb7158" translate="yes" xml:space="preserve">
          <source>CMD</source>
          <target state="translated">CMD</target>
        </trans-unit>
        <trans-unit id="439fbcbebff5d3e18e9cd1652b960a8b5958c8fb" translate="yes" xml:space="preserve">
          <source>CMD.EXE</source>
          <target state="translated">CMD.EXE</target>
        </trans-unit>
        <trans-unit id="b7f8b1aaa4e3518d65a63cc4b574d3a502b21354" translate="yes" xml:space="preserve">
          <source>CMD_ERROR</source>
          <target state="translated">CMD_ERROR</target>
        </trans-unit>
        <trans-unit id="b9c1aaaf65573c7e15b93b6d826729e7711cf242" translate="yes" xml:space="preserve">
          <source>CNAME</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="16de25af888480da1af57a71855f3e8c515dcb61" translate="yes" xml:space="preserve">
          <source>CODE</source>
          <target state="translated">CODE</target>
        </trans-unit>
        <trans-unit id="8a81c4f5d7ebf0af1540db862699627a91092359" translate="yes" xml:space="preserve">
          <source>CODE EXAMPLES</source>
          <target state="translated">코드 예</target>
        </trans-unit>
        <trans-unit id="e00c531b83778b8e9867578bc4976f46546c5a61" translate="yes" xml:space="preserve">
          <source>CODE REFERENCES</source>
          <target state="translated">코드 참조</target>
        </trans-unit>
        <trans-unit id="440677eb0b9f2ced4b57b4cf4a1f2a4041acaf2f" translate="yes" xml:space="preserve">
          <source>CODE reference. The subroutine should return a hash reference. The hash may contain further attributes, e.g. {LIBS =&amp;gt; ...}, that have to be determined by some evaluation method.</source>
          <target state="translated">코드 참조. 서브 루틴은 해시 참조를 리턴해야합니다. 해시는 일부 평가 방법으로 결정해야하는 추가 속성 (예 : {LIBS =&amp;gt; ...})을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f975202aa1b4783c29e4937429d2b66fab5169e" translate="yes" xml:space="preserve">
          <source>CODE: directive is used which sets ST(0) explicitly.</source>
          <target state="translated">CODE : ST (0)을 명시 적으로 설정하는 지시문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a057830a61bb847750f9a416ef2afe8f0db78c7a" translate="yes" xml:space="preserve">
          <source>COLOUR</source>
          <target state="translated">COLOUR</target>
        </trans-unit>
        <trans-unit id="2d5c5615b998898e7768ec56433dbebafc08a4d0" translate="yes" xml:space="preserve">
          <source>COLUMNS</source>
          <target state="translated">COLUMNS</target>
        </trans-unit>
        <trans-unit id="8a9cbc4396b103e6b251b294230c1bb9eed38e2f" translate="yes" xml:space="preserve">
          <source>COM1</source>
          <target state="translated">COM1</target>
        </trans-unit>
        <trans-unit id="3a38ee1d9bd08c8be0112c20a3c4f3c5309ce957" translate="yes" xml:space="preserve">
          <source>COMMAND.COM</source>
          <target state="translated">COMMAND.COM</target>
        </trans-unit>
        <trans-unit id="c13bbfcc6932afed8045a8c6d2be122bbea2f4a3" translate="yes" xml:space="preserve">
          <source>COMMON CHARACTER CODE SETS</source>
          <target state="translated">공통 문자 코드 세트</target>
        </trans-unit>
        <trans-unit id="3565dc34b7a16c1ebb52c1be4a3b9554d589b634" translate="yes" xml:space="preserve">
          <source>COMMON MISTAKES</source>
          <target state="translated">흔한 실수</target>
        </trans-unit>
        <trans-unit id="d3bd9328431af889713253c0fe82cf459fd62fdd" translate="yes" xml:space="preserve">
          <source>COMMON PITFALLS</source>
          <target state="translated">공통의 사소</target>
        </trans-unit>
        <trans-unit id="3b75e36fb6f8799ec17d763957648965ceb0bf19" translate="yes" xml:space="preserve">
          <source>COMMON PROBLEMS</source>
          <target state="translated">일반적인 문제</target>
        </trans-unit>
        <trans-unit id="3631d60b3c3dad75e7023cf75ede2d8db90dced0" translate="yes" xml:space="preserve">
          <source>COMMON QUESTIONS</source>
          <target state="translated">일반적인 질문</target>
        </trans-unit>
        <trans-unit id="34c150933a6aa70510a6417b9f759a880de15e63" translate="yes" xml:space="preserve">
          <source>COMMON TASKS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5931c475df95ba4c0e69e8680b4b2746d7dcadbd" translate="yes" xml:space="preserve">
          <source>COMPATIBILITY</source>
          <target state="translated">COMPATIBILITY</target>
        </trans-unit>
        <trans-unit id="abe070716581f0b619231b1ebef8e7055b0ca326" translate="yes" xml:space="preserve">
          <source>COMPILE</source>
          <target state="translated">COMPILE</target>
        </trans-unit>
        <trans-unit id="1b93c2f6af1a728937d801492e8514e231fe859d" translate="yes" xml:space="preserve">
          <source>COMPILING AND INSTALLING PERL ON PLAN 9</source>
          <target state="translated">계획 9에서 Perl 컴파일 및 설치</target>
        </trans-unit>
        <trans-unit id="a3dbb0f2d743369125c33547e4a98f6e69c718ea" translate="yes" xml:space="preserve">
          <source>COMPRESS/UNCOMPRESS</source>
          <target state="translated">COMPRESS/UNCOMPRESS</target>
        </trans-unit>
        <trans-unit id="7679a072c92896a2f8b38c43a6b6959d5d9cd9c5" translate="yes" xml:space="preserve">
          <source>CON</source>
          <target state="translated">CON</target>
        </trans-unit>
        <trans-unit id="dbbd6e677093ab33626116ddbe95a8116b822da0" translate="yes" xml:space="preserve">
          <source>CONCEPTS</source>
          <target state="translated">CONCEPTS</target>
        </trans-unit>
        <trans-unit id="ce2288334f1137f427c025bf4db30086aa2e6ccd" translate="yes" xml:space="preserve">
          <source>CONCLUSION</source>
          <target state="translated">CONCLUSION</target>
        </trans-unit>
        <trans-unit id="54b45ea0b830c111f200238254cbe142d992ceb9" translate="yes" xml:space="preserve">
          <source>CONCURRENT ACCESS TO FILES</source>
          <target state="translated">파일에 대한 동시 액세스</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="b6e52e4d80314fc8a5ba1a7faeb4aa6cd672bec0" translate="yes" xml:space="preserve">
          <source>CONFIGURATION</source>
          <target state="translated">CONFIGURATION</target>
        </trans-unit>
        <trans-unit id="d5e00d8ba45995ef9ab303972f7c1a6cae02996a" translate="yes" xml:space="preserve">
          <source>CONFIGURATION VARIABLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4267ae349f13bd1612b2ef41ef2fe7a1e068f48" translate="yes" xml:space="preserve">
          <source>CONFIGURE</source>
          <target state="translated">CONFIGURE</target>
        </trans-unit>
        <trans-unit id="0bcdf5cc47cad9c41938edcc7524d271413daa98" translate="yes" xml:space="preserve">
          <source>CONFIGURE PERL ON CYGWIN</source>
          <target state="translated">CYGWIN에서 PERL 구성</target>
        </trans-unit>
        <trans-unit id="22733669b75038bbdd66305b9f339bad99694375" translate="yes" xml:space="preserve">
          <source>CONFIGURE_REQUIRES</source>
          <target state="translated">CONFIGURE_REQUIRES</target>
        </trans-unit>
        <trans-unit id="86446751ae319594b5e453b782ebdfc8c4bf543b" translate="yes" xml:space="preserve">
          <source>CONFIGURING</source>
          <target state="translated">CONFIGURING</target>
        </trans-unit>
        <trans-unit id="a0e4619a67d77836e15c84ab1f7acbadf6b5e068" translate="yes" xml:space="preserve">
          <source>CONSTANT ONLY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65df4be803801cf76d0b33102b49347c0f49a265" translate="yes" xml:space="preserve">
          <source>CONSTANTS</source>
          <target state="translated">CONSTANTS</target>
        </trans-unit>
        <trans-unit id="9d4cd9e346a27cff016ae855f03e070521487596" translate="yes" xml:space="preserve">
          <source>CONSTRUCT</source>
          <target state="translated">CONSTRUCT</target>
        </trans-unit>
        <trans-unit id="6ed66fd18a1b175704db533d3865fa2679863e6d" translate="yes" xml:space="preserve">
          <source>CONSTRUCTOR</source>
          <target state="translated">CONSTRUCTOR</target>
        </trans-unit>
        <trans-unit id="a8bbeb234bce1b12584f91c5efbcf549dcdfea50" translate="yes" xml:space="preserve">
          <source>CONSTRUCTOR ARGUMENTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81e8ee10f05992e9990c024071dc9ef826e1cd3" translate="yes" xml:space="preserve">
          <source>CONSTRUCTORS</source>
          <target state="translated">CONSTRUCTORS</target>
        </trans-unit>
        <trans-unit id="740fabb870d6ed652cd56a6f6b4cabc2048431f9" translate="yes" xml:space="preserve">
          <source>CONTACT</source>
          <target state="translated">CONTACT</target>
        </trans-unit>
        <trans-unit id="27c8094199d30ca2b1fd54cbe86c56a5369fe808" translate="yes" xml:space="preserve">
          <source>CONTACTING US</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238a131a3e8eb98d1fc5b27d882ca40b7618fd2a" translate="yes" xml:space="preserve">
          <source>CONTENT</source>
          <target state="translated">CONTENT</target>
        </trans-unit>
        <trans-unit id="c7fb4a1c86b7fc71a83ddb8d52b446a1a692bd4f" translate="yes" xml:space="preserve">
          <source>CONTENTS</source>
          <target state="translated">CONTENTS</target>
        </trans-unit>
        <trans-unit id="6eb1660530253dbbb9bc0adce6c7c2db98f6c11e" translate="yes" xml:space="preserve">
          <source>CONTRIBUTED MODULES</source>
          <target state="translated">기여한 모듈</target>
        </trans-unit>
        <trans-unit id="378eb0be276c8f7e7ce971475f7e96915511bccb" translate="yes" xml:space="preserve">
          <source>CONTRIBUTING</source>
          <target state="translated">CONTRIBUTING</target>
        </trans-unit>
        <trans-unit id="c00c0afca84109e3fb2b98c8209ef559a912b256" translate="yes" xml:space="preserve">
          <source>CONTRIBUTORS</source>
          <target state="translated">CONTRIBUTORS</target>
        </trans-unit>
        <trans-unit id="3c270e7e648d60e989f665180ac5841d2f501b46" translate="yes" xml:space="preserve">
          <source>CONTROLLING LOOKUP FAILURE</source>
          <target state="translated">루킹 실패 제어</target>
        </trans-unit>
        <trans-unit id="56e1ec5824af8dff3fb44acbb1f5889b6031d924" translate="yes" xml:space="preserve">
          <source>CONVENTIONS</source>
          <target state="translated">CONVENTIONS</target>
        </trans-unit>
        <trans-unit id="bb5de08378fdc79cf1e8f681e4066f1cb85bb028" translate="yes" xml:space="preserve">
          <source>CONVERSIONS</source>
          <target state="translated">CONVERSIONS</target>
        </trans-unit>
        <trans-unit id="e1146aff355e08a86787f760b889571c858e8593" translate="yes" xml:space="preserve">
          <source>COOKBOOK</source>
          <target state="translated">COOKBOOK</target>
        </trans-unit>
        <trans-unit id="9510141c24a403496c1dfba8b0ab986988f95879" translate="yes" xml:space="preserve">
          <source>COORDINATE SYSTEMS</source>
          <target state="translated">코디네이트 시스템</target>
        </trans-unit>
        <trans-unit id="c51ce576d0d85de4e554620a3b7e0dd309045090" translate="yes" xml:space="preserve">
          <source>COP Hint Hashes</source>
          <target state="translated">순경 힌트 해시</target>
        </trans-unit>
        <trans-unit id="22ad88b10bee537423c13139a4d2b08d579efc3e" translate="yes" xml:space="preserve">
          <source>COP Hint Reading</source>
          <target state="translated">경찰 힌트 읽기</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="9c7e4e94b44caac6a4f40ca3467d6883ed67cf24" translate="yes" xml:space="preserve">
          <source>COPYRIGHT &amp;amp; LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="fd93171470739cb1a4e64e6ea953d8c1dd9e7c3a" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMER</source>
          <target state="translated">저작권 및 부인</target>
        </trans-unit>
        <trans-unit id="aed47af09308ae3a4fa8a24efc25bc20b8d6091d" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMERS</source>
          <target state="translated">저작권 및 면책 조항</target>
        </trans-unit>
        <trans-unit id="0524ce058903ad04ed18326112dd9695f4ac4f56" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENCE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="d7f1de266854e2b8d4c927372f1242e7739925ed" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="8c9b991a9d45dee993d0ee634ba8eafd7815c6a3" translate="yes" xml:space="preserve">
          <source>COPYRIGHT and LICENSE</source>
          <target state="translated">저작권 및 라이센스</target>
        </trans-unit>
        <trans-unit id="b2adcad6cf0cf6a066258c4fd1d02420f1966a91" translate="yes" xml:space="preserve">
          <source>COP_SEQ_RANGE_HIGH</source>
          <target state="translated">COP_SEQ_RANGE_HIGH</target>
        </trans-unit>
        <trans-unit id="a9b392a8220f4c5f1bcb88a16ab6a09829f1ffc1" translate="yes" xml:space="preserve">
          <source>COP_SEQ_RANGE_LOW</source>
          <target state="translated">COP_SEQ_RANGE_LOW</target>
        </trans-unit>
        <trans-unit id="6d917c2df32bb3f8fb6b5f8e529bb779c3dca6f7" translate="yes" xml:space="preserve">
          <source>CORE</source>
          <target state="translated">CORE</target>
        </trans-unit>
        <trans-unit id="9f2a7e4446d753ffa86ebd32d2855d851f9cf12a" translate="yes" xml:space="preserve">
          <source>CORE - Namespace for Perl's core routines</source>
          <target state="translated">핵심-Perl의 핵심 루틴을위한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="497675c86e638bfe224cc68e3f05d28dcf571f18" translate="yes" xml:space="preserve">
          <source>CORE::%s is not a keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="a6110e98d6d5509cfa9c7e73794ab71e46a695de" translate="yes" xml:space="preserve">
          <source>CPAN - query, download and build perl modules from CPAN sites</source>
          <target state="translated">CPAN-CPAN 사이트에서 펄 모듈 조회, 다운로드 및 빌드</target>
        </trans-unit>
        <trans-unit id="640c7f36ffad456a54e80bb77b215b4df80f86d4" translate="yes" xml:space="preserve">
          <source>CPAN Ratings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cb991183e9576ae99c7af8774c4d59270235f0" translate="yes" xml:space="preserve">
          <source>CPAN TESTERS AND PERL SMOKERS</source>
          <target state="translated">CPAN 테스터 및 펄 스모커</target>
        </trans-unit>
        <trans-unit id="b04380d2ad945f75e3aa967dafb36ed58ba766cd" translate="yes" xml:space="preserve">
          <source>CPAN Testers</source>
          <target state="translated">CPAN 테스터</target>
        </trans-unit>
        <trans-unit id="863161d001f9ccb830b592052aeebdcb0078239b" translate="yes" xml:space="preserve">
          <source>CPAN Testers Matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01505e76b90321ebd4493c61034cb8a884911e63" translate="yes" xml:space="preserve">
          <source>CPAN also keeps track of what it has done within the current session and doesn't try to build a package a second time regardless of whether it succeeded or not. It does not repeat a test run if the test has been run successfully before. Same for install runs.</source>
          <target state="translated">CPAN은 또한 현재 세션 내에서 수행 한 작업을 추적하며 성공 여부에 관계없이 패키지를 다시 빌드하려고 시도하지 않습니다. 테스트가 이전에 성공적으로 실행 된 경우 테스트 실행을 반복하지 않습니다. 설치 실행과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d978419581e9be6ec9c55f53ba43e4e7f68766bd" translate="yes" xml:space="preserve">
          <source>CPAN can now help you select a &quot;good&quot; mirror, based on which ones have the lowest 'ping' round-trip times. From the shell, use the command 'o conf init urllist' and allow CPAN to automatically select mirrors for you.</source>
          <target state="translated">CPAN은 왕복 시간이 가장 적은 '핑'미러를 기준으로 &quot;좋은&quot;미러를 선택하는 데 도움을 줄 수 있습니다. 쉘에서 'o conf init urllist'명령을 사용하고 CPAN이 자동으로 미러를 선택하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef4af0178192ba3f8dbe6d0b6def5f18be1c055" translate="yes" xml:space="preserve">
          <source>CPAN can provide the best examples. &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, &lt;a href=&quot;Test::Exception&quot;&gt;Test::Exception&lt;/a&gt; and &lt;a href=&quot;Test::Differences&quot;&gt;Test::Differences&lt;/a&gt; all use Test::Builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f419c26e2ea47eba870171b0304a0f12d770bcb" translate="yes" xml:space="preserve">
          <source>CPAN can provide the best examples. &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;, &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test::Exception&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test::Differences&lt;/a&gt; all use Test::Builder.</source>
          <target state="translated">CPAN이 가장 좋은 예를 제공 할 수 있습니다. &lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt; , &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test :: Exception&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test :: Differences는&lt;/a&gt; 모두 Test :: Builder를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9b25cd0f5375c5eab72f3ffe3e62897e52e03cea" translate="yes" xml:space="preserve">
          <source>CPAN checks whether an install is needed and prints</source>
          <target state="translated">CPAN은 설치가 필요한지 확인하고 인쇄</target>
        </trans-unit>
        <trans-unit id="d5ac7dd05001d7d37e2f43d1797c997c4df20e68" translate="yes" xml:space="preserve">
          <source>CPAN has several JAPH programs at &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh&lt;/a&gt;.</source>
          <target state="translated">CPAN에는 &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh에&lt;/a&gt; 여러 JAPH 프로그램이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02833bc73787fea6b5bfa63c891711c6ecf458e5" translate="yes" xml:space="preserve">
          <source>CPAN module &lt;code&gt;&lt;a href=&quot;Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73829bcf0ad0c4b896f34810c840c5f0243a137e" translate="yes" xml:space="preserve">
          <source>CPAN module &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">CPAN 모듈 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec0e8e76dd47186c4a257a69793cc4b0fbd9812e" translate="yes" xml:space="preserve">
          <source>CPAN packages can be digitally signed by authors and thus verified with the security provided by strong cryptography. The exact mechanism is defined in the Module::Signature module. While this is generally considered a good thing, it is not always convenient to the end user to install modules that are signed incorrectly or where the key of the author is not available or where some prerequisite for Module::Signature has a bug and so on.</source>
          <target state="translated">CPAN 패키지는 작성자가 디지털 서명하여 강력한 암호화가 제공하는 보안으로 확인할 수 있습니다. 정확한 메커니즘은 Module :: Signature 모듈에 정의되어 있습니다. 이것은 일반적으로 좋은 것으로 간주되지만 최종 사용자가 서명이 잘못되었거나 작성자의 키를 사용할 수 없거나 Module :: Signature의 전제 조건에 버그가있는 모듈을 설치하는 것이 항상 편리한 것은 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="b51337fb370844b9eff5cf2f0d2334791161629e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network, a multi-gigabyte archive replicated on hundreds of machines all over the world. CPAN contains tens of thousands of modules and extensions, source code and documentation, designed for</source>
          <target state="translated">CPAN은 전 세계 수백 대의 머신에 복제 된 멀티 기가 바이트 아카이브 인 포괄적 인 Perl Archive Network의 약자입니다. CPAN에는 수만 개의 모듈과 확장, 소스 코드 및 설명서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a083d1c70360c499c212a22f42c02ebc10a2b7e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network; it's a globally replicated trove of Perl materials, including documentation, style guides, tricks and traps, alternate ports to non-Unix systems and occasional binary distributions for these. Search engines for CPAN can be found at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</source>
          <target state="translated">CPAN은 포괄적 인 Perl Archive Network의 약자입니다. 문서, 스타일 가이드, 트릭 및 트랩, 비 Unix 시스템의 대체 포트 및 때때로 바이너리 배포를 포함하여 전 세계적으로 복제 된 Perl 자료입니다. CPAN의 검색 엔진은 &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db4a7f495a75e5647a60a515b464cd126cd6fe2f" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network; it's a globally replicated trove of Perl materials, including documentation, style guides, tricks and traps, alternate ports to non-Unix systems and occasional binary distributions for these. Search engines for CPAN can be found at https://www.cpan.org/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b7513cf5ed0783e222931555703c39249404ca" translate="yes" xml:space="preserve">
          <source>CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be asked any questions at all (assuming the modules you are installing are nice about obeying that variable as well):</source>
          <target state="translated">CPAN은 ExtUtils :: MakeMaker의 prompt () 함수를 사용하여 질문을합니다. 따라서 PERL_MM_USE_DEFAULT 환경 변수를 설정하면 전혀 질문하지 않아도됩니다 (설치중인 모듈이 해당 변수를 준수하는 것이 좋다고 가정). :</target>
        </trans-unit>
        <trans-unit id="763ab2cd14f13622b64f1d364ae89ff5e930c5e0" translate="yes" xml:space="preserve">
          <source>CPAN version is currently maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;.</source>
          <target state="translated">CPAN 버전은 현재 S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;에서 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d022fca84f913595d0e465957aa3ec07aa26e29a" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden이 제작 한 CPAN 버전 &amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="df1b7ad617e594d1fcea7ef95394577f7d4285ee" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</source>
          <target state="translated">Jerry D. Hedden이 제작 한 CPAN 버전 &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="deb6d0c2ba6a1e511bb2a73b69254f1705154545" translate="yes" xml:space="preserve">
          <source>CPAN, &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487de831d21a908d502622e00613c7b641cb5b29" translate="yes" xml:space="preserve">
          <source>CPAN, or the Comprehensive Perl Archive Network &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, is a replicated, worldwide repository of Perl software. See &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3F-What-is-CPAN%3F&quot;&gt;What is CPAN?&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c7ec93761c4b99669cfe3abe56f987f4d86e7b" translate="yes" xml:space="preserve">
          <source>CPAN, or the Comprehensive Perl Archive Network &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, is a replicated, worldwide repository of Perl software. See &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;What is CPAN?&lt;/a&gt;.</source>
          <target state="translated">CPAN (Comprehensive Perl Archive Network) &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; 는 전 세계적으로 복제 된 Perl 소프트웨어 저장소입니다. &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;CPAN이란 무엇입니까?를&lt;/a&gt; 참조하십시오 . .</target>
        </trans-unit>
        <trans-unit id="d24df83c42548921d5e891bad0ec265b58c5632b" translate="yes" xml:space="preserve">
          <source>CPAN.pm</source>
          <target state="translated">CPAN.pm</target>
        </trans-unit>
        <trans-unit id="df07d81df98f66bb5cc686dd3a7b7369a164da96" translate="yes" xml:space="preserve">
          <source>CPAN.pm can introduce some randomness when using hosts for download that are configured in the urllist parameter. Enter a numeric value between 0 and 1 to indicate how often you want to let CPAN.pm try a random host from the urllist. A value of one specifies to always use a random host as the first try. A value of zero means no randomness at all. Anything in between specifies how often, on average, a random host should be tried first.</source>
          <target state="translated">CPAN.pm은 urllist 매개 변수에 구성된 다운로드 용 호스트를 사용할 때 임의성을 유발할 수 있습니다. CPAN.pm이 urllist에서 임의의 호스트를 시도하는 빈도를 표시하려면 0과 1 사이의 숫자 값을 입력하십시오. 값 1은 항상 첫 번째 시도로 임의 호스트를 사용하도록 지정합니다. 값이 0이면 임의성이 없음을 의미합니다. 중간에있는 것은 평균적으로 임의 호스트를 먼저 시도해야하는 빈도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8be548e1857808a4c33f06e8483679790bde10ef" translate="yes" xml:space="preserve">
          <source>CPAN.pm can limit the size of the disk area for keeping the build directories with all the intermediate files.</source>
          <target state="translated">CPAN.pm은 빌드 디렉토리를 모든 중간 파일과 함께 유지하기 위해 디스크 영역의 크기를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21743f9fae507577e1ebe77ee42077c588936ab" translate="yes" xml:space="preserve">
          <source>CPAN.pm can store customized build environments based on regular expressions for distribution names. These are YAML files where the default options for CPAN.pm and the environment can be overridden and dialog sequences can be stored that can later be executed by an Expect.pm object. The CPAN.pm distribution comes with some prefab YAML files that cover sample distributions that can be used as blueprints to store your own prefs. Please check out the distroprefs/ directory of the CPAN.pm distribution to get a quick start into the prefs system.</source>
          <target state="translated">CPAN.pm은 배포 이름에 대한 정규식을 기반으로 사용자 정의 된 빌드 환경을 저장할 수 있습니다. 이들은 CPAN.pm 및 환경에 대한 기본 옵션을 대체하고 나중에 Expect.pm 오브젝트가 실행할 수있는 대화 상자 순서를 저장할 수있는 YAML 파일입니다. CPAN.pm 배포판에는 자체 사전 설정을 저장하기위한 청사진으로 사용할 수있는 샘플 배포판을 포괄하는 일부 조립식 YAML 파일이 제공됩니다. prefs 시스템을 빠르게 시작하려면 CPAN.pm 배포판의 distroprefs / 디렉토리를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fe8999832e8cb3e24c5ee5786438c2eb7045f528" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. By default it uses Cwd::cwd, but if for some reason this doesn't work on your system, configure alternatives according to the following table:</source>
          <target state="translated">CPAN.pm은 현재 작업 디렉토리를 자주 변경하며 자체 현재 작업 디렉토리를 결정해야합니다. 기본적으로 Cwd :: cwd를 사용하지만 어떤 이유로 시스템에서 작동하지 않으면 다음 표에 따라 대안을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="110953d17daedc5ab884b800e79aa6017f230c3c" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. Per default it uses Cwd::cwd but if this doesn't work on your system for some reason, alternatives can be configured according to the following table:</source>
          <target state="translated">CPAN.pm은 현재 작업 디렉토리를 자주 변경하며 자체 현재 작업 디렉토리를 결정해야합니다. 기본적으로 Cwd :: cwd를 사용하지만 어떤 이유로 시스템에서 작동하지 않으면 다음 표에 따라 대안을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316ae9b3e749a01c06c792f2cfcc80c4846f19f6" translate="yes" xml:space="preserve">
          <source>CPAN.pm ignores SIGPIPE. If the user sets &lt;code&gt;inactivity_timeout&lt;/code&gt; , a SIGALRM is used during the run of the &lt;code&gt;perl Makefile.PL&lt;/code&gt; or &lt;code&gt;perl
Build.PL&lt;/code&gt; subprocess. A SIGALRM is also used during module version parsing, and is controlled by &lt;code&gt;version_timeout&lt;/code&gt; .</source>
          <target state="translated">CPAN.pm은 SIGPIPE를 무시합니다. 사용자가 &lt;code&gt;inactivity_timeout&lt;/code&gt; 을 설정 하면 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 또는 &lt;code&gt;perl Build.PL&lt;/code&gt; 서브 프로세스 실행 중에 SIGALRM이 사용됩니다 . SIGALRM은 모듈 버전 구문 분석 중에도 사용되며 &lt;code&gt;version_timeout&lt;/code&gt; 에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="190c010b5387bba4ea2b42cb563bd4dbf19face7" translate="yes" xml:space="preserve">
          <source>CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are in the cpan-shell, it is intended that you can press &lt;code&gt;^C&lt;/code&gt; anytime and return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell to clean up and leave the shell loop. You can emulate the effect of a SIGTERM by sending two consecutive SIGINTs, which usually means by pressing &lt;code&gt;^C&lt;/code&gt; twice.</source>
          <target state="translated">CPAN.pm은 SIGINT 및 SIGTERM에 대한 신호 핸들러를 설치합니다. cpan-shell에있는 동안 언제든지 &lt;code&gt;^C&lt;/code&gt; 누르고 cpan-shell 프롬프트로 돌아갈 수 있습니다. SIGTERM은 cpan-shell을 정리하고 쉘 루프를 떠나게합니다. 두 개의 연속 SIGINT를 보내서 SIGTERM의 효과를 에뮬레이션 할 수 있습니다. 일반적으로 &lt;code&gt;^C&lt;/code&gt; 두 번 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="74c9de97c18d0f26d42b5dbeeae85623299ae97e" translate="yes" xml:space="preserve">
          <source>CPAN.pm is regularly tested to run under 5.005 and assorted newer versions. It is getting more and more difficult to get the minimal prerequisites working on older perls. It is close to impossible to get the whole Bundle::CPAN working there. If you're in the position to have only these old versions, be advised that CPAN is designed to work fine without the Bundle::CPAN installed.</source>
          <target state="translated">CPAN.pm은 정기적으로 5.005 및 최신 버전으로 실행되도록 테스트되었습니다. 오래된 perls에서 최소한의 전제 조건을 작동시키는 것이 점점 어려워지고 있습니다. 전체 Bundle :: CPAN을 작동시키는 것은 거의 불가능합니다. 이러한 이전 버전 만 사용할 수있는 위치에있는 경우 CPAN은 번들 :: CPAN을 설치하지 않아도 제대로 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf1353490c4d7670619296c8008a7613115046dd" translate="yes" xml:space="preserve">
          <source>CPAN.pm sends all the good stuff either to STDOUT, or to a temp file if $CPAN::Be_Silent is set. I have to intercept that output so I can find out what happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dede3b8abe89d4a573f74c512265cae8a956106" translate="yes" xml:space="preserve">
          <source>CPAN.pm will then fetch the index files from one of the CPAN sites that come at the beginning of urllist. It will later check for each module to see whether there is a local copy of the most recent version.</source>
          <target state="translated">그러면 CPAN.pm은 urllist의 시작 부분에있는 CPAN 사이트 중 하나에서 색인 파일을 가져옵니다. 나중에 각 모듈에서 최신 버전의 로컬 사본이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2867ea997c1ecbeaa882b9d340cc76b94bdae145" translate="yes" xml:space="preserve">
          <source>CPAN.pm works nicely without network access, too. If you maintain machines that are not networked at all, you should consider working with &lt;code&gt;file:&lt;/code&gt; URLs. You'll have to collect your modules somewhere first. So you might use CPAN.pm to put together all you need on a networked machine. Then copy the $CPAN::Config-&amp;gt;{keep_source_where} (but not $CPAN::Config-&amp;gt;{build_dir}) directory on a floppy. This floppy is kind of a personal CPAN. CPAN.pm on the non-networked machines works nicely with this floppy. See also below the paragraph about CD-ROM support.</source>
          <target state="translated">CPAN.pm은 네트워크 액세스 없이도 잘 작동합니다. 네트워크로 연결되지 않은 시스템을 유지 관리하는 경우 &lt;code&gt;file:&lt;/code&gt; URL 작업을 고려해야 합니다. 먼저 어딘가에 모듈을 수집해야합니다. 따라서 CPAN.pm을 사용하여 네트워크 컴퓨터에 필요한 모든 것을 구성 할 수 있습니다. 그런 다음 $ CPAN :: Config-&amp;gt; {keep_source_where} ($ CPAN :: Config-&amp;gt; {build_dir} 아님) 디렉토리를 플로피에 복사하십시오. 이 플로피는 일종의 개인 CPAN입니다. 네트워크에 연결되지 않은 컴퓨터의 CPAN.pm은이 플로피와 잘 작동합니다. CD-ROM 지원에 관한 아래 단락도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b58516423735ce2c3f324d8402c003fc36fbed0f" translate="yes" xml:space="preserve">
          <source>CPAN/Config.pm</source>
          <target state="translated">CPAN/Config.pm</target>
        </trans-unit>
        <trans-unit id="6faef7e4f766e6858ddfbab08e842e5664c02d4a" translate="yes" xml:space="preserve">
          <source>CPAN::API::HOWTO</source>
          <target state="translated">CPAN::API::HOWTO</target>
        </trans-unit>
        <trans-unit id="7d13c1f45959303dde93846efab68b723f0e1350" translate="yes" xml:space="preserve">
          <source>CPAN::API::HOWTO - a recipe book for programming with CPAN.pm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b36001560d3fac13b876398b3f1a59def99f26" translate="yes" xml:space="preserve">
          <source>CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution inherit this method. It prints the data structure associated with an object. Useful for debugging. Note: the data structure is considered internal and thus subject to change without notice.</source>
          <target state="translated">CPAN :: Author, CPAN :: Bundle, CPAN :: Module 및 CPAN :: Distribution은이 메소드를 상속합니다. 객체와 관련된 데이터 구조를 인쇄합니다. 디버깅에 유용합니다. 참고 : 데이터 구조는 내부로 간주되므로 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2446a32cd0ff78f16b4c1f3133beeac56c5f5898" translate="yes" xml:space="preserve">
          <source>CPAN::Debug</source>
          <target state="translated">CPAN::Debug</target>
        </trans-unit>
        <trans-unit id="3cc1933835ca0280363968e304f73c0a15112e4c" translate="yes" xml:space="preserve">
          <source>CPAN::Debug - internal debugging for CPAN.pm</source>
          <target state="translated">CPAN :: Debug-CPAN.pm의 내부 디버깅</target>
        </trans-unit>
        <trans-unit id="8d7cc75d89d8c3bb9bd4511533d5eed2ec9484af" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs</source>
          <target state="translated">CPAN::Distroprefs</target>
        </trans-unit>
        <trans-unit id="80ea37d944a5515b88dd77f972d31b6df3134129" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs -- read and match distroprefs</source>
          <target state="translated">CPAN :: Distroprefs-분산 참조를 읽고 일치</target>
        </trans-unit>
        <trans-unit id="5bcd04a88f701c432b5a1ff104f6c8a0d02960ee" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs::Pref objects represent individual distroprefs documents. They are constructed automatically as part of &lt;code&gt;success&lt;/code&gt; results from &lt;code&gt;find()&lt;/code&gt; .</source>
          <target state="translated">CPAN :: Distroprefs :: Pref 객체는 개별 distroprefs 문서를 나타냅니다. &lt;code&gt;find()&lt;/code&gt; 의 &lt;code&gt;success&lt;/code&gt; 결과의 일부로 자동 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a80c4fbbd0b304da11de451846a67216c923a02" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs::Pref objects represent individual distroprefs documents. They are constructed automatically as part of &lt;code&gt;success&lt;/code&gt; results from &lt;code&gt;find()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f3edd9da9fa97ece6eafd83608b4b243b452a0" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime</source>
          <target state="translated">CPAN::FirstTime</target>
        </trans-unit>
        <trans-unit id="78dc35292a9ffa84e8778b2bc228974b2a98a06d" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime - Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN :: FirstTime-CPAN :: Config 파일 초기화 유틸리티</target>
        </trans-unit>
        <trans-unit id="e737cd6e08d40b3a667635e5cb83727e8679bd6f" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime::init()</source>
          <target state="translated">CPAN::FirstTime::init()</target>
        </trans-unit>
        <trans-unit id="85ea935cb2e14666fd64cb017917705b1d6fede5" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig</source>
          <target state="translated">CPAN::HandleConfig</target>
        </trans-unit>
        <trans-unit id="24310cde90de0fb64790326e96a727677d4e7601" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig - internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN :: HandleConfig-CPAN.pm의 내부 구성 처리</target>
        </trans-unit>
        <trans-unit id="64057ceb28c792089f8152cbd3da3bcade5223e9" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify</source>
          <target state="translated">CPAN::Kwalify</target>
        </trans-unit>
        <trans-unit id="a2e5f91adff087cfa00a37e97d84ee7727243629" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify - Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN :: Kwalify-CPAN.pm과 Kwalify.pm 사이의 인터페이스</target>
        </trans-unit>
        <trans-unit id="4b8f36fffdfa53be5f4b115ae8913d434ac5c6b1" translate="yes" xml:space="preserve">
          <source>CPAN::Meta</source>
          <target state="translated">CPAN::Meta</target>
        </trans-unit>
        <trans-unit id="48ad65740fe63343931a8656187eafec5955c57f" translate="yes" xml:space="preserve">
          <source>CPAN::Meta - the distribution metadata for a CPAN dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73001d880b33350252b208c4e0748fe317bc1a14" translate="yes" xml:space="preserve">
          <source>CPAN::Meta provides a simple class to represent this distribution metadata (or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf488c14acf7130238ab7ab864400d15606e4dcc" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Converter</source>
          <target state="translated">CPAN::Meta::Converter</target>
        </trans-unit>
        <trans-unit id="3a44aacfd90649473b04272bf68b167438021597" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Converter - Convert CPAN distribution metadata structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74c7b35ace25f98dcab7adda6d087e4d41138b2" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Feature</source>
          <target state="translated">CPAN::Meta::Feature</target>
        </trans-unit>
        <trans-unit id="e77a117c65ccb9a682ea3baf643ba394032f0657" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Feature - an optional feature provided by a CPAN distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05ed4b2cca8e77098c550bdf2e7803252cf0419" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History</source>
          <target state="translated">CPAN::Meta::History</target>
        </trans-unit>
        <trans-unit id="3d4ef469c0a2fd520f2668dcee9d50b4a92831af" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History - history of CPAN Meta Spec changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a20178ce03327fd7ce61d35e3d28cf7389d57e" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_0</source>
          <target state="translated">CPAN::Meta::History::Meta_1_0</target>
        </trans-unit>
        <trans-unit id="4c76496897217f6b28f34a5999470faf19da7f33" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_0 - Version 1.0 metadata specification for META.yml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba913709397d694384cad42b5967ba97f7017dea" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_1</source>
          <target state="translated">CPAN::Meta::History::Meta_1_1</target>
        </trans-unit>
        <trans-unit id="7d8f39c866aada4c5c7c3961949f6bc55fb8974c" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_1 - Version 1.1 metadata specification for META.yml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f20c5ce694247d2eb820323008522888c093e8d" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_2</source>
          <target state="translated">CPAN::Meta::History::Meta_1_2</target>
        </trans-unit>
        <trans-unit id="1ac83fedd5492a444b000b4073f44de3c7919193" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_2 - Version 1.2 metadata specification for META.yml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b035ec656582b467956149f35002359f79c8e55" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_3</source>
          <target state="translated">CPAN::Meta::History::Meta_1_3</target>
        </trans-unit>
        <trans-unit id="d7ae7add4211fafefa6b4e8776cab276f84dcc89" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_3 - Version 1.3 metadata specification for META.yml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab69aa6faceb5500a76eace17ff9300c464214e" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_4</source>
          <target state="translated">CPAN::Meta::History::Meta_1_4</target>
        </trans-unit>
        <trans-unit id="c4026439639f237a4b2722822cbe43bc68b0f0a4" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::History::Meta_1_4 - Version 1.4 metadata specification for META.yml</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93049ddccd3b5964f6ccdc08c6a2888e17af001" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Merge</source>
          <target state="translated">CPAN::Meta::Merge</target>
        </trans-unit>
        <trans-unit id="4fe7d2aec8f5226d2a8a01d5327d50b15e085cf1" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Merge - Merging CPAN Meta fragments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a4bf767d93cb4558936ab83a63cbc35d95b95d" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Prereqs</source>
          <target state="translated">CPAN::Meta::Prereqs</target>
        </trans-unit>
        <trans-unit id="05ec9fad7ede51b61fe7feb474e02adc2a6d4635" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Prereqs - a set of distribution prerequisites by phase and type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd64823a6e9d665af8461e2c27c91e2bebb3182" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Requirements</source>
          <target state="translated">CPAN::Meta::Requirements</target>
        </trans-unit>
        <trans-unit id="f0f14af6a21fdfef215ec198ceb71c2f5ca2993d" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Requirements - a set of version requirements for a CPAN dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ae05af348305875670e0df393908708ee5c284" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Spec</source>
          <target state="translated">CPAN::Meta::Spec</target>
        </trans-unit>
        <trans-unit id="72c4f43258ec93a850621e0bf7f50c5239b4a882" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Spec - specification for CPAN distribution metadata</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53b9ec4780637887d4c02075a461cedf9448d3f" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Validator</source>
          <target state="translated">CPAN::Meta::Validator</target>
        </trans-unit>
        <trans-unit id="86eb5e58240b2848f6d3ea2d072260021ef84be0" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::Validator - validate CPAN distribution metadata structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208f6e92b224465a177e744e188b4255cd284c6e" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::YAML</source>
          <target state="translated">CPAN::Meta::YAML</target>
        </trans-unit>
        <trans-unit id="626d1c9831b7c2685adada5e5c8869b4c0685b60" translate="yes" xml:space="preserve">
          <source>CPAN::Meta::YAML - Read and write a subset of YAML for CPAN Meta files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcc2e6edc3eadab9e78355482bf7252fe18e3ff" translate="yes" xml:space="preserve">
          <source>CPAN::Nox</source>
          <target state="translated">CPAN::Nox</target>
        </trans-unit>
        <trans-unit id="0b944fc036709f45e2abf674dd21a2de916a71a8" translate="yes" xml:space="preserve">
          <source>CPAN::Nox - Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">CPAN :: Nox-XS 모듈을 사용하지 않고 CPAN.pm을 감싸는 래퍼</target>
        </trans-unit>
        <trans-unit id="4f10b5cd1bc0cc808fb08d652fc8dc5ab07aa1e6" translate="yes" xml:space="preserve">
          <source>CPAN::Plugin</source>
          <target state="translated">CPAN::Plugin</target>
        </trans-unit>
        <trans-unit id="90b38b9fb846cae383975af3b4f6fd3cabdc24ab" translate="yes" xml:space="preserve">
          <source>CPAN::Plugin - Base class for CPAN shell extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b3c1c1427c579ea6cd5b109622ba6ef3a76785" translate="yes" xml:space="preserve">
          <source>CPAN::Plugin::Specfile</source>
          <target state="translated">CPAN::Plugin::Specfile</target>
        </trans-unit>
        <trans-unit id="a0e2ea8376440c75cc98c1ad8457bb4032bf2103" translate="yes" xml:space="preserve">
          <source>CPAN::Plugin::Specfile - Proof of concept implementation of a trivial CPAN::Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff38ba28ab3cfea4d0464d49309db8969faf6ef" translate="yes" xml:space="preserve">
          <source>CPAN::Queue</source>
          <target state="translated">CPAN::Queue</target>
        </trans-unit>
        <trans-unit id="e3a09726a6ba57409ab3f10ea87af46541484c9f" translate="yes" xml:space="preserve">
          <source>CPAN::Queue - internal queue support for CPAN.pm</source>
          <target state="translated">CPAN :: Queue-CPAN.pm에 대한 내부 큐 지원</target>
        </trans-unit>
        <trans-unit id="349e923ec9cc993c3c5c400728886a4cd805bc87" translate="yes" xml:space="preserve">
          <source>CPAN::SQLite is a layer between the index files that are downloaded from the CPAN and CPAN.pm that speeds up metadata queries and reduces memory consumption of CPAN.pm considerably.</source>
          <target state="translated">CPAN :: SQLite는 CPAN과 CPAN.pm에서 다운로드 한 인덱스 파일 사이의 계층으로 메타 데이터 쿼리 속도를 높이고 CPAN.pm의 메모리 소비를 상당히 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b47dcd8919f1f65cec06b9c2d7f965e75c2b1219" translate="yes" xml:space="preserve">
          <source>CPAN::Shell</source>
          <target state="translated">CPAN::Shell</target>
        </trans-unit>
        <trans-unit id="23798a7b15a5d75dd8c6bdfc98d7078c277c16e8" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip</source>
          <target state="translated">CPAN::Tarzip</target>
        </trans-unit>
        <trans-unit id="814fdd5396978409421856089181c07c58c4c4cf" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip - internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN :: Tarzip-CPAN.pm에 대한 tar 아카이브의 내부 처리</target>
        </trans-unit>
        <trans-unit id="4901e7156541948e262f8f5d98071d2c7b3b87e3" translate="yes" xml:space="preserve">
          <source>CPAN::Version</source>
          <target state="translated">CPAN::Version</target>
        </trans-unit>
        <trans-unit id="30cd4b0821f4765c0d8295e7726cfae9b7fab40e" translate="yes" xml:space="preserve">
          <source>CPAN::Version - utility functions to compare CPAN versions</source>
          <target state="translated">CPAN :: Version-CPAN 버전을 비교하는 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="ec4a1634792e6ece098aa09e476bc1d9ef4268d0" translate="yes" xml:space="preserve">
          <source>CPAN::anycwd($path): Note on config variable getcwd</source>
          <target state="translated">CPAN :: anycwd ($ path) : 구성 변수 getcwd에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="6bf4457df819c8d2b082c5c17c609ae27bb6a63b" translate="yes" xml:space="preserve">
          <source>CPAN::shell([$prompt, $command]) Starting Interactive Mode</source>
          <target state="translated">CPAN :: shell ([$ prompt, $ command]) 대화식 모드 시작</target>
        </trans-unit>
        <trans-unit id="4ffdbed7690fc2f38db76dd54cf504d79c06ee88" translate="yes" xml:space="preserve">
          <source>CPANMINUS</source>
          <target state="translated">CPANMINUS</target>
        </trans-unit>
        <trans-unit id="0300a08f28f15d52b8c0f31d868e80fadb408109" translate="yes" xml:space="preserve">
          <source>CPANPLUS</source>
          <target state="translated">CPANPLUS</target>
        </trans-unit>
        <trans-unit id="cddd63a37f15517811274317a3521885c8465e0c" translate="yes" xml:space="preserve">
          <source>CPANSCRIPT_LOGLEVEL</source>
          <target state="translated">CPANSCRIPT_LOGLEVEL</target>
        </trans-unit>
        <trans-unit id="596893c7ae353e11febbdfc549493341b79250bd" translate="yes" xml:space="preserve">
          <source>CPAN_META_JSON_BACKEND</source>
          <target state="translated">CPAN_META_JSON_BACKEND</target>
        </trans-unit>
        <trans-unit id="56630007ce8f6ea01649aae19d31614ccb2fcfb1" translate="yes" xml:space="preserve">
          <source>CPAN_META_JSON_DECODER</source>
          <target state="translated">CPAN_META_JSON_DECODER</target>
        </trans-unit>
        <trans-unit id="ca1237679e72b0e6f4c9e40aa693972b89e6005f" translate="yes" xml:space="preserve">
          <source>CPAN_OPTS</source>
          <target state="translated">CPAN_OPTS</target>
        </trans-unit>
        <trans-unit id="ff221d4752ce05f5a91bbf1d28b78a7bf7e2ddaa" translate="yes" xml:space="preserve">
          <source>CPU</source>
          <target state="translated">CPU</target>
        </trans-unit>
        <trans-unit id="4a2648ee2c7cdfe4f04963290c94c0f73b1a0296" translate="yes" xml:space="preserve">
          <source>CPU seconds is, in UNIX terms, the user time plus the system time of the process itself, as opposed to the real (wallclock) time and the time spent by the child processes. Less than 0.1 seconds is not accepted (-0.01 as the count, for example, will cause a fatal runtime exception).</source>
          <target state="translated">CPU 초는 UNIX 용어로, 사용자 시간과 프로세스 자체의 시스템 시간을 더한 것입니다 (실시간 (벽시계) 시간 및 하위 프로세스가 소비 한 시간). 0.1 초 미만은 허용되지 않습니다 (예 : -0.01을 카운트로하면 치명적인 런타임 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="8eabeaf9c51703b78032cab60996509e2a9fbc29" translate="yes" xml:space="preserve">
          <source>CPU time</source>
          <target state="translated">CPU 시간</target>
        </trans-unit>
        <trans-unit id="ceae75038d81d55818f9c7099cc499bef29e500c" translate="yes" xml:space="preserve">
          <source>CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE</source>
          <target state="translated">별도의 실행 파일로 소스 필터 생성</target>
        </trans-unit>
        <trans-unit id="440025df559c6a5653bcee40ea212abfedca608a" translate="yes" xml:space="preserve">
          <source>CREATING FORMATTERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5fc61f95a802dc2f2c87590b81afa3dc2d9f36" translate="yes" xml:space="preserve">
          <source>CREATION</source>
          <target state="translated">CREATION</target>
        </trans-unit>
        <trans-unit id="338f52baadf832c435e6693a6b1e770c010b5681" translate="yes" xml:space="preserve">
          <source>CREDITS</source>
          <target state="translated">CREDITS</target>
        </trans-unit>
        <trans-unit id="e455615ff19fea236c13c0cc8cc42e9a1fb0de9b" translate="yes" xml:space="preserve">
          <source>CRITICAL DETAILS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b79357f1f7c4a8b8c01c419e8cd32de82816fa7" translate="yes" xml:space="preserve">
          <source>CROSS-COMPILATION</source>
          <target state="translated">CROSS-COMPILATION</target>
        </trans-unit>
        <trans-unit id="a3d5ec7e72504ad29b8a4c994f24267617037161" translate="yes" xml:space="preserve">
          <source>CRTL_ENV</source>
          <target state="translated">CRTL_ENV</target>
        </trans-unit>
        <trans-unit id="4dd4581105bbe8d44425ee07bb7bb229d812b848" translate="yes" xml:space="preserve">
          <source>CUR</source>
          <target state="translated">CUR</target>
        </trans-unit>
        <trans-unit id="5ff3994b10db2ad29d009f4ea60878f1dbf5c21e" translate="yes" xml:space="preserve">
          <source>CURRENT BUILD INSTRUCTIONS</source>
          <target state="translated">현재 건물 지침</target>
        </trans-unit>
        <trans-unit id="d7a2114fe29992707c06bdf0e24dd4971a33ab14" translate="yes" xml:space="preserve">
          <source>CURRENT MAINTAINER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f132b454c07ac52e508f217f0add8bd7ce5fa710" translate="yes" xml:space="preserve">
          <source>CUSTOM ALIASES</source>
          <target state="translated">고객 별명</target>
        </trans-unit>
        <trans-unit id="457857075253f90b422c3d6ec94b4e07bc6c17a8" translate="yes" xml:space="preserve">
          <source>CUSTOM DATA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566216bf858af2148e9f96bcf3257d2d54bc9983" translate="yes" xml:space="preserve">
          <source>CUSTOM TRANSLATORS</source>
          <target state="translated">커스텀 번역기</target>
        </trans-unit>
        <trans-unit id="8963b0f409c3a3fda6cdee265e282d666bc239f6" translate="yes" xml:space="preserve">
          <source>CV</source>
          <target state="translated">CV</target>
        </trans-unit>
        <trans-unit id="095d16308375c60700e556f5b8f5796ca1925951" translate="yes" xml:space="preserve">
          <source>CV Manipulation Functions</source>
          <target state="translated">CV 조작 기능</target>
        </trans-unit>
        <trans-unit id="2b943e6acf60a6fb581a6a5d00e315120f0f582e" translate="yes" xml:space="preserve">
          <source>CV reference counts and CvOUTSIDE</source>
          <target state="translated">CV 기준 카운트 및 CvOUTSIDE</target>
        </trans-unit>
        <trans-unit id="0c42c13d714fd16e36f14c85f7c7898781594d12" translate="yes" xml:space="preserve">
          <source>CV's can have CvPADLIST(cv) set to point to a PADLIST. This is the CV's scratchpad, which stores lexical variables and opcode temporary and per-thread values.</source>
          <target state="translated">CV는 CvPADLIST (cv)를 PADLIST를 가리 키도록 설정할 수 있습니다. 이것은 CV의 스크래치 패드로 어휘 변수와 opcode 임시 및 스레드 당 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="92b37c5475ec1dea78f404618ece63a8a92e114e" translate="yes" xml:space="preserve">
          <source>CVGEN</source>
          <target state="translated">CVGEN</target>
        </trans-unit>
        <trans-unit id="72f361fd5a33f48e600af7873c367abc9b77f221" translate="yes" xml:space="preserve">
          <source>CVs use the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag to indicate that the CV has a reference count on the slab. When this flag is set, the slab is accessible via &lt;code&gt;CvSTART&lt;/code&gt; when &lt;code&gt;CvROOT&lt;/code&gt; is not set, or by subtracting two pointers &lt;code&gt;(2*sizeof(I32 *))&lt;/code&gt; from &lt;code&gt;CvROOT&lt;/code&gt; when it is set. The alternative to this approach of sneaking the slab into &lt;code&gt;CvSTART&lt;/code&gt; during compilation would be to enlarge the &lt;code&gt;xpvcv&lt;/code&gt; struct by another pointer. But that would make all CVs larger, even though slab-based op freeing is typically of benefit only for programs that make significant use of string eval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e51fb7a6114d481c1d0f93a37fb30c3e241a73" translate="yes" xml:space="preserve">
          <source>CX_CURPAD_SAVE</source>
          <target state="translated">CX_CURPAD_SAVE</target>
        </trans-unit>
        <trans-unit id="10bc4b4585dd74c80d037efe480f5a15cf760875" translate="yes" xml:space="preserve">
          <source>CX_CURPAD_SV</source>
          <target state="translated">CX_CURPAD_SV</target>
        </trans-unit>
        <trans-unit id="66460a3b93b78bfb0555774b761ce7dd073e8855" translate="yes" xml:space="preserve">
          <source>C_ARRAY_END</source>
          <target state="translated">C_ARRAY_END</target>
        </trans-unit>
        <trans-unit id="04a5223afc068c1c13a4c5f27ca78e5b10db53fb" translate="yes" xml:space="preserve">
          <source>C_ARRAY_LENGTH</source>
          <target state="translated">C_ARRAY_LENGTH</target>
        </trans-unit>
        <trans-unit id="3db0016459bc32ecd5a2abfda4e4b4eb9544e81d" translate="yes" xml:space="preserve">
          <source>C_FH</source>
          <target state="translated">C_FH</target>
        </trans-unit>
        <trans-unit id="ddb00c36c6d4c35daa72fdd0b44d9c728b39bcfa" translate="yes" xml:space="preserve">
          <source>C_FILE</source>
          <target state="translated">C_FILE</target>
        </trans-unit>
        <trans-unit id="575569dbcc2f1973e29e715e813fbf5f343f083a" translate="yes" xml:space="preserve">
          <source>C_SUBNAME</source>
          <target state="translated">C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="dec4c830b8ddb5dccb4f7473e2780b24256aed99" translate="yes" xml:space="preserve">
          <source>C_constant arg_hashref, ITEM...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a704c039a062759c68107bf491f441821b6748f3" translate="yes" xml:space="preserve">
          <source>C_string()</source>
          <target state="translated">C_string()</target>
        </trans-unit>
        <trans-unit id="c9a4bfcb48afedb38aac0a493b9bba80f14b49d8" translate="yes" xml:space="preserve">
          <source>C_stringify NAME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dd0ee71a9f8c8e59007d14c22f8f02a232442a" translate="yes" xml:space="preserve">
          <source>Cache Manager</source>
          <target state="translated">캐시 관리자</target>
        </trans-unit>
        <trans-unit id="a9fca3e43fd40d529fa1de2b124c4181a70bcb17" translate="yes" xml:space="preserve">
          <source>Cache metadata (yes/no)?</source>
          <target state="translated">캐시 메타 데이터 (예 / 아니요)?</target>
        </trans-unit>
        <trans-unit id="36e2cd82188ed6fa0e4b613f6e68c50033b4f7eb" translate="yes" xml:space="preserve">
          <source>Cache size for build directory (in MB)?</source>
          <target state="translated">빌드 디렉토리의 캐시 크기 (MB)?</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="4216adaca29295eaea61f0fa24c35227b02c6845" translate="yes" xml:space="preserve">
          <source>Caching and deferred writing are inappropriate if you want the same file to be accessed simultaneously from more than one process. Other optimizations performed internally by this module are also incompatible with concurrent access. A future version of this module will support a &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; option that enables safe concurrent access.</source>
          <target state="translated">동일한 파일에 둘 이상의 프로세스에서 동시에 액세스하려면 캐싱 및 지연된 쓰기가 부적절합니다. 이 모듈에서 내부적으로 수행 된 다른 최적화도 동시 액세스와 호환되지 않습니다. 이 모듈의 향후 버전 은 안전한 동시 액세스를 가능하게 하는 &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="66d425679370669a060d7b12eda4e17f2fb01bea" translate="yes" xml:space="preserve">
          <source>Caching is off by default, as it can (usually slightly) decrease accuracy and does not usually noticeably affect runtimes.</source>
          <target state="translated">캐싱은 기본적으로 꺼져 있습니다. 정확도는 (일반적으로 약간) 저하 될 수 있으며 일반적으로 런타임에 눈에 띄게 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81c8c72b5e27066945946d422a802165663f5930" translate="yes" xml:space="preserve">
          <source>Caesarean ciphers</source>
          <target state="translated">제왕 절개 암호</target>
        </trans-unit>
        <trans-unit id="f76942716d4c2528f7cd94b85c359f606e3e15f5" translate="yes" xml:space="preserve">
          <source>Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to &quot;even&quot;.</source>
          <target state="translated">PI를 N 자리로 계산합니다 (점 앞의 3을 포함). 결과는 현재 반올림 모드에 따라 반올림되며 기본값은 &quot;짝수&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ba16d2dfddf095e54ae25bc218255c71ce5afa48" translate="yes" xml:space="preserve">
          <source>Calculate digests of files</source>
          <target state="translated">파일 요약 계산</target>
        </trans-unit>
        <trans-unit id="6edac12b6f864eee888f0c08f462e84fff153f20" translate="yes" xml:space="preserve">
          <source>Calculate the N'th root of $x.</source>
          <target state="translated">$ x의 N 번째 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f7dc98fbb7b43c855859dedd630f45c56ad2bc12" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하여 $ x의 아크 루스 탄젠을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="49fd3457ed632359ca2520e72d6632cb278658b7" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place.</source>
          <target state="translated">의 ARCUS의 tangens 계산 &lt;code&gt;$y&lt;/code&gt; 나눈 &lt;code&gt;$x&lt;/code&gt; 대신 $ Y 수정.</target>
        </trans-unit>
        <trans-unit id="5bbe8238807ec8d47bbbcc6d01cee7e8f992583a" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt;, modifying $y in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8171f0ff6bd907f4503e20866134c76966e85b6f" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of $x, modifying $x in place. See also &lt;a href=&quot;#batan2%28%29&quot;&gt;&quot;batan2()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f94eb38f838a42af1307713af2f7a6e7542c447" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of $x, modifying $x in place. See also &lt;a href=&quot;#batan2()&quot;&gt;batan2()&lt;/a&gt;.</source>
          <target state="translated">$ x를 수정하여 $ x의 arcus tanges를 계산하십시오. &lt;a href=&quot;#batan2()&quot;&gt;batan2 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="982777a50f0c3516dc7b84208808f54a3e72dbea" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place. See also &lt;a href=&quot;#batan()&quot;&gt;batan()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$y&lt;/code&gt; 를 &lt;code&gt;$x&lt;/code&gt; 로 나눈 값을 계산 하여 $ y를 수정합니다. &lt;a href=&quot;#batan()&quot;&gt;batan ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d6fb13adb7bf3184a3048bb0dff7cf77ccc8226" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt;, modifying $y in place. See also &lt;a href=&quot;#batan%28%29&quot;&gt;&quot;batan()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac94229d27fcaa835b1ec1d88cf3594ca1121397" translate="yes" xml:space="preserve">
          <source>Calculate the cosine of $x, modifying $x in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8312c24fc6c367f7ba0626e0df9859355b1ba267" translate="yes" xml:space="preserve">
          <source>Calculate the cosinus of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하여 $ x의 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="961da91820feb8c98ca20b69e6e93c1fe53ffbb7" translate="yes" xml:space="preserve">
          <source>Calculate the sine of $x, modifying $x in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c8c185c9d12673e45f702a2f9d36653ab1f38e" translate="yes" xml:space="preserve">
          <source>Calculate the sinus of $x, modifying $x in place.</source>
          <target state="translated">$ x를 수정하고 $ x를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="049cf6157b6ee1c242c2800800be8ef0165625bc" translate="yes" xml:space="preserve">
          <source>Calculate the square root of $x.</source>
          <target state="translated">$ x의 제곱근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="f4820fe9e03a7c976939a8cebecd9d08b353aa30" translate="yes" xml:space="preserve">
          <source>Calculated means the facet was generated from another facet. Calculated facets may be cleared and regenerated whenever the event state changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c08bd3d571674414934d46e315d05c1e757d23" translate="yes" xml:space="preserve">
          <source>Calculates the N'th root of &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x&lt;/code&gt; 의 N 번째 근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b37e44d0a686e2ca230fb786ab85e288a1c54529" translate="yes" xml:space="preserve">
          <source>Calculates the N'th root of &lt;code&gt;$x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60ccc2f19222914da87593fea9f1afb62ee5252" translate="yes" xml:space="preserve">
          <source>Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function, which is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2470f12a5e304e7422bd1a2f8c0e1abfd2982a1d" translate="yes" xml:space="preserve">
          <source>Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:</source>
          <target state="translated">&quot;선택&quot;함수라고도하는 k에 대한 이항 계수 n을 계산합니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34e97fbd408b8eed5635c834b2854c0be8cb6dbf" translate="yes" xml:space="preserve">
          <source>Calculates the expression &lt;code&gt;e ** $x&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">식 &lt;code&gt;e ** $x&lt;/code&gt; 계산합니다. 여기서 &lt;code&gt;e&lt;/code&gt; 는 오일러의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="416b7a310945db184afb57b971e8e098dac1fa18" translate="yes" xml:space="preserve">
          <source>Calculates the factorial of $x. For instance:</source>
          <target state="translated">$ x의 계승을 계산합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="62fb105cdba4cb5918fb1ee8f5656956e6874fed" translate="yes" xml:space="preserve">
          <source>Calculates the maximum command size the OS can exec. Effectively, this is the max size of a shell command line.</source>
          <target state="translated">OS가 실행할 수있는 최대 명령 크기를 계산합니다. 사실상 이것은 쉘 명령 행의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="fd42bdc4343d55afb259e24e240b92c18465e03e" translate="yes" xml:space="preserve">
          <source>Calculates two integers A and B so that A/B is equal to &lt;code&gt;e ** $x&lt;/code&gt; , where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">A / B가 &lt;code&gt;e ** $x&lt;/code&gt; (여기서 &lt;code&gt;e&lt;/code&gt; 는 오일러 수)가 되도록 두 개의 정수 A와 B를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="f2ca019b0d59ea6f0382ac9b50f298aadf929274" translate="yes" xml:space="preserve">
          <source>Calculates two integers A and B so that A/B is equal to &lt;code&gt;e ** $x&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0037c314d771bc8eaa4953dbcb986cc7bf547ac0" translate="yes" xml:space="preserve">
          <source>Calendar of Perl Events</source>
          <target state="translated">펄 행사 일정</target>
        </trans-unit>
        <trans-unit id="afd632ce2019ef9ec38232fb5195ec297239dcfa" translate="yes" xml:space="preserve">
          <source>Calendar time for December 12, 1995, at 10:30 am.</source>
          <target state="translated">1995 년 12 월 12 일 오전 10시 30 분의 달력 시간.</target>
        </trans-unit>
        <trans-unit id="cf386e5831516538d6deaa1383a8556be7abbcc0" translate="yes" xml:space="preserve">
          <source>California</source>
          <target state="translated">California</target>
        </trans-unit>
        <trans-unit id="a7a5d5cba867fa341140666997ab9bfd6cadc129" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; and return a list of two sockets created, or an empty list on failure.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 를 호출 하고 작성된 두 개의 소켓 목록 또는 실패시 빈 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="35dfe1234c2b3035ee2b40e6c30d2b36aabfe8c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;abort()&lt;/code&gt; on exit. This is used internally by perl itself to abort if exit is called while processing exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6b5d06a5f85554364bcd897b8c29e92093294d" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start&lt;/code&gt; immediately before adding any results to the aggregator. Among other times it records the start time for the test run.</source>
          <target state="translated">통화 &lt;code&gt;start&lt;/code&gt; 게이터에 어떤 결과를 추가하기 전에 즉시. 다른 경우에는 테스트 실행의 시작 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bab90a1ca7bed318a773f1cd868353d680619794" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;stop&lt;/code&gt; immediately after adding all test results to the aggregator.</source>
          <target state="translated">모든 테스트 결과를 수집기에 추가 한 후 즉시 호출을 &lt;code&gt;stop&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b397d3a007d888457eb1a3db65426142f2a1211a" translate="yes" xml:space="preserve">
          <source>Call Pod::Perldoc::GetOptsOO::getopts($object, \@ARGV, $truth)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f1fdfb2231f4e8ba5ad2172306eb394d414cf5" translate="yes" xml:space="preserve">
          <source>Call all the registered block hooks for type</source>
          <target state="translated">유형에 대해 등록 된 모든 블록 후크를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6d7e2e0ddf774eeed37f22e407552d0937049ad2" translate="yes" xml:space="preserve">
          <source>Call all the registered block hooks for type &lt;code&gt;which&lt;/code&gt;. &lt;code&gt;which&lt;/code&gt; is a preprocessing token; the type of &lt;code&gt;arg&lt;/code&gt; depends on &lt;code&gt;which&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409c307d19d683a501410b5ff5a68b6c8bd9aca3" translate="yes" xml:space="preserve">
          <source>Call the custom callback if one is set, otherwise this does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63876fa9d1b98c3c63563764cf54bc05c244034" translate="yes" xml:space="preserve">
          <source>Call the system level poll routine. If TIMEOUT is not specified then the call will block. Returns the number of handles which had events happen, or -1 on error.</source>
          <target state="translated">시스템 레벨 폴 루틴을 호출하십시오. TIMEOUT을 지정하지 않으면 호출이 차단됩니다. 이벤트가 발생한 핸들 수 또는 오류시 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="707d41981449a7ac1f49727761a071399e9047fa" translate="yes" xml:space="preserve">
          <source>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. &lt;code&gt;stash&lt;/code&gt; is the stash that has been assigned. &lt;code&gt;oldstash&lt;/code&gt; is the stash it replaces, if any. &lt;code&gt;gv&lt;/code&gt; is the glob that is actually being assigned to.</source>
          <target state="translated">이 기능을 호출하여 숨김 계층 구조의 다른 스팟에 지정되었음을 숨김에 신호합니다. &lt;code&gt;stash&lt;/code&gt; 는 할당 된 숨김입니다. &lt;code&gt;oldstash&lt;/code&gt; 는 대체되는 숨김입니다. &lt;code&gt;gv&lt;/code&gt; 는 실제로 할당되는 glob입니다.</target>
        </trans-unit>
        <trans-unit id="897a2466922f6de52dc65c0d77a98544c7fb349a" translate="yes" xml:space="preserve">
          <source>CallSubPV</source>
          <target state="translated">CallSubPV</target>
        </trans-unit>
        <trans-unit id="ade75b74553b436dc4fbae17ff916436ba41a1b5" translate="yes" xml:space="preserve">
          <source>CallSubSV</source>
          <target state="translated">CallSubSV</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="c60c17f100badf24e67226833a550c8cb29e67d2" translate="yes" xml:space="preserve">
          <source>Callback called exit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="e2492d7f90f5ff291923cb9e3820556cd26e7081" translate="yes" xml:space="preserve">
          <source>Callbacks may also be added like this:</source>
          <target state="translated">콜백은 다음과 같이 추가 될 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0b30b959e54d6077a0087fde2fbe95f232d8abe1" translate="yes" xml:space="preserve">
          <source>Called after debug API inits itself.</source>
          <target state="translated">디버그 API 자체가 초기화 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7ce9b93a40160290fff58c32f9bc646588fa275b" translate="yes" xml:space="preserve">
          <source>Called before &lt;code&gt;process_args&lt;/code&gt; to prepend the contents of an rc file to the options.</source>
          <target state="translated">rc 파일의 내용을 옵션 앞에 추가 하기 위해 &lt;code&gt;process_args&lt;/code&gt; 전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="01b1a27618644b64f84f4ae78cca932070236cdf" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt; so that the class has a chance to initialize the converter. Internally it sets the &lt;code&gt;batch_mode&lt;/code&gt; property to true and sets &lt;code&gt;batch_mode_current_level()&lt;/code&gt;, but Pod::Simple::XHTML does not currently use those features. Subclasses might, though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712b31fe99457d34e411f45757dac056dcd534cd" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt; so that the class has a chance to initialize the converter. Internally it sets the &lt;code&gt;batch_mode&lt;/code&gt; property to true and sets &lt;code&gt;batch_mode_current_level()&lt;/code&gt; , but Pod::Simple::XHTML does not currently use those features. Subclasses might, though.</source>
          <target state="translated">클래스가 변환기를 초기화 할 수 있도록 &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch에&lt;/a&gt; 의해 호출됩니다 . 내부적으로 &lt;code&gt;batch_mode&lt;/code&gt; 속성을 true로 설정하고 &lt;code&gt;batch_mode_current_level()&lt;/code&gt; 설정 하지만 Pod :: Simple :: XHTML은 현재 이러한 기능을 사용하지 않습니다. 그래도 서브 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44d9ba6e8c865877532df9753c9657e69186427" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;close_test&lt;/code&gt; to clear the line showing test progress, or the parallel test ruler, prior to printing the final test result.</source>
          <target state="translated">최종 테스트 결과를 인쇄하기 전에 &lt;code&gt;close_test&lt;/code&gt; 에 의해 호출되어 테스트 진행 상황을 표시하는 행 또는 병렬 테스트 눈금자를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="83de9bce1b7b2bd7be455db4ac0ff451b79c596a" translate="yes" xml:space="preserve">
          <source>Called by Perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. This is only responsible for freeing private data; Perl will handle releasing anything else contained in the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">정규식 패턴을 해제 할 때 Perl에 의해 호출되어 엔진 이 &lt;code&gt;regexp&lt;/code&gt; 구조 의 &lt;code&gt;pprivate&lt;/code&gt; 구성원이 가리키는 자원을 해제 할 수 있습니다 . 개인 정보를 확보하는 것만 책임집니다. 펄은 &lt;code&gt;regexp&lt;/code&gt; 구조에 포함 된 다른 것들의 공개를 처리 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="192f5069ea69d61876f992ae04cbfebd42365fdf" translate="yes" xml:space="preserve">
          <source>Called by Test::Harness before any test output is generated.</source>
          <target state="translated">테스트 출력이 생성되기 전에 Test :: Harness에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd42467897ffdba4f9319dfefbd20551429ca89" translate="yes" xml:space="preserve">
          <source>Called by a utility method of makeaperl. Checks whether a given file is an XS library by seeing whether it defines any symbols starting with &lt;code&gt;boot_&lt;/code&gt; (with an optional leading underscore - needed on MacOS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252637df9babf3148f5feaeda72912f2045c6976" translate="yes" xml:space="preserve">
          <source>Called by init_main.</source>
          <target state="translated">init_main에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdb9b50857f3ef3652ef325b6cf3d72fa3622a7" translate="yes" xml:space="preserve">
          <source>Called by init_main. Initializes PERL_*</source>
          <target state="translated">init_main에 의해 호출됩니다. PERL_ *를 초기화합니다</target>
        </trans-unit>
        <trans-unit id="803f7311292b6dbe520d9001028a74a3740ad58e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up ABSPERL, PERL, FULLPERL and all the *PERLRUN* permutations.</source>
          <target state="translated">init_main에 의해 호출됩니다. ABSPERL, PERL, FULLPERL 및 모든 * PERLRUN * 순열을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3f68bdd2c8090ffda024fb7a301dcec75150221e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INSTALL_* variables (except INSTALLDIRS) and *PREFIX.</source>
          <target state="translated">init_main에 의해 호출됩니다. 모든 INSTALL_ * 변수 (INSTALLDIRS 제외) 및 * PREFIX를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e5e9ec66a22e81bfffe8ba34ae133177fa3495b6" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INST_* variables except those related to XS code. Those are handled in init_xs.</source>
          <target state="translated">init_main에 의해 호출됩니다. XS 코드와 관련된 변수를 제외한 모든 INST_ * 변수를 설정합니다. 그것들은 init_xs에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6dfa9b16abbbe06ab0d5e00e013cd050e482cced" translate="yes" xml:space="preserve">
          <source>Called by init_others, and calls ext ExtUtils::Liblist. See &lt;a href=&quot;ExtUtils::Liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0c75a0f13f487e51a8d6aa8f296a671eded4fd" translate="yes" xml:space="preserve">
          <source>Called by init_others, and calls ext ExtUtils::Liblist. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">init_others에 의해 호출되고 ext ExtUtils :: Liblist를 호출합니다. 자세한 내용은 &lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa989d1b35e9dfa1af106d6dbfbb5e0924c7a182" translate="yes" xml:space="preserve">
          <source>Called by staticmake. Defines how to write the Makefile to produce a static new perl.</source>
          <target state="translated">staticmake에 의해 호출됩니다. 정적 새 펄을 생성하기 위해 Makefile을 작성하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a7da98d82f41c03c342a989f11faab94693c6c57" translate="yes" xml:space="preserve">
          <source>Called by the harness for each line of TAP it receives.</source>
          <target state="translated">받는 TAP의 각 라인에 대한 하네스에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0521bfafa9ba37410f99fe5ff1bf683133d1cd71" translate="yes" xml:space="preserve">
          <source>Called by the harness when it needs to create a &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. Override in a subclass to provide an alternative scheduler. &lt;code&gt;make_scheduler&lt;/code&gt; is passed the list of tests that was passed to &lt;code&gt;aggregate_tests&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567cd3e87bf8931281fcaa23e35e2da3fe139b11" translate="yes" xml:space="preserve">
          <source>Called by the harness when it needs to create a &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. Override in a subclass to provide an alternative scheduler. &lt;code&gt;make_scheduler&lt;/code&gt; is passed the list of tests that was passed to &lt;code&gt;aggregate_tests&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt; 를 생성해야 할 때 하네스에 의해 호출됩니다 . 대체 스케줄러를 제공하기 위해 서브 클래스에서 대체하십시오. &lt;code&gt;make_scheduler&lt;/code&gt; 에는 &lt;code&gt;aggregate_tests&lt;/code&gt; 에 전달 된 테스트 목록이 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="496f62a4d27b344cea2367c44afc046f7d3e616c" translate="yes" xml:space="preserve">
          <source>Called in list context, returns a list consisting of all the keys of the named hash, or in Perl 5.12 or later only, the indices of an array. Perl releases prior to 5.12 will produce a syntax error if you try to use an array argument. In scalar context, returns the number of keys or indices.</source>
          <target state="translated">목록 컨텍스트에서 호출되며 명명 된 해시의 모든 키로 구성되거나 Perl 5.12 이상에서만 배열의 인덱스로 구성된 목록을 반환합니다. 5.12 이전의 Perl 릴리스에서는 배열 인수를 사용하려고하면 구문 오류가 발생합니다. 스칼라 컨텍스트에서 키 또는 인덱스 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="467bfe2c2b5fcadd2c658d71f62e583886879a81" translate="yes" xml:space="preserve">
          <source>Called just before exit.</source>
          <target state="translated">종료 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="56f111d681d8f9bb2b8ea3bbe2cb68fe1cbd1b6b" translate="yes" xml:space="preserve">
          <source>Called to close a test session.</source>
          <target state="translated">테스트 세션을 종료하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0fea40ea6e66a6d129222181dca9ffffa1dc50aa" translate="yes" xml:space="preserve">
          <source>Called to create a new test session. A test session looks like this:</source>
          <target state="translated">새로운 테스트 세션을 만들기 위해 호출됩니다. 테스트 세션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bec535037f1a075b8ca545622477cf0f336b95f2" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...).</source>
          <target state="translated">번호가 매겨진 캡처 그룹 ( &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; 뿐만 아니라 &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; 및 그와 동등한 이름 ​​인 $ {^ PREMATCH}, $ {^ POSTMATCH} 및 $ {^ MATCH} 의 값을 가져 오거나 설정하기 위해 호출됩니다. ...).</target>
        </trans-unit>
        <trans-unit id="28c2d939a2818d842c409238148056a468e80c26" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05cab34d068a722bc12f2e226cde25cd9659c30" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , as well as by some utility functions in &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;re&quot;&gt;re의&lt;/a&gt; 일부 유틸리티 함수뿐만 아니라 &lt;code&gt;%+&lt;/code&gt; 및 &lt;code&gt;%-&lt;/code&gt; 값을 가져 오거나 설정하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="172a2008c9c9bfdccd10398a4900cd9074f2930c" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt;, as well as by some utility functions in &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca1fbe0a0f38d437dca54b642d9f31c3ccb8f90" translate="yes" xml:space="preserve">
          <source>Called when API must show a message (warnings, errors etc.).</source>
          <target state="translated">API가 메시지 (경고, 오류 등)를 표시해야 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f94cf1c0617789052abd6d872abe927053b4b0cd" translate="yes" xml:space="preserve">
          <source>Called when a job is complete to unlock it. If a callback has been registered with &lt;code&gt;on_finish&lt;/code&gt; , it calls it. Otherwise, it does nothing.</source>
          <target state="translated">잠금 해제를 위해 작업이 완료되면 호출됩니다. 콜백이 &lt;code&gt;on_finish&lt;/code&gt; 로 등록 된 경우 호출됩니다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="529d993616ad651bd31b98b890f1161f3ca2f07f" translate="yes" xml:space="preserve">
          <source>Called when a job is complete to unlock it. If a callback has been registered with &lt;code&gt;on_finish&lt;/code&gt;, it calls it. Otherwise, it does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5516c9265ba63c86e3ef82397e79274838607cf" translate="yes" xml:space="preserve">
          <source>Called when execution stops (w/ args file, line).</source>
          <target state="translated">실행이 중지 될 때 호출됩니다 (args 파일, 행 포함).</target>
        </trans-unit>
        <trans-unit id="145748d07108bcdb9c427172d1270877727239ed" translate="yes" xml:space="preserve">
          <source>Called when the layer is popped from the stack. A layer will normally be popped after &lt;code&gt;Close()&lt;/code&gt; is called. But a layer can be popped without being closed if the program is dynamically managing layers on the stream. In such cases &lt;code&gt;Popped()&lt;/code&gt; should free any resources (buffers, translation tables, ...) not held directly in the layer's struct. It should also &lt;code&gt;Unread()&lt;/code&gt; any unconsumed data that has been read and buffered from the layer below back to that layer, so that it can be re-provided to what ever is now above.</source>
          <target state="translated">스택에서 레이어가 튀어 나올 때 호출됩니다. 일반적으로 &lt;code&gt;Close()&lt;/code&gt; 가 호출 된 후 레이어가 나타납니다 . 그러나 프로그램이 스트림에서 레이어를 동적으로 관리하는 경우 레이어를 닫지 않고 팝업 할 수 있습니다. 이러한 경우 &lt;code&gt;Popped()&lt;/code&gt; 는 레이어의 구조체에 직접 보유되지 않은 모든 리소스 (버퍼, 변환 테이블 등 ) 를 해제해야합니다. 또한 아래 계층에서 해당 계층으로 다시 읽혀지고 버퍼링 된 소비되지 않은 데이터를 &lt;code&gt;Unread()&lt;/code&gt; 해야합니다 . 따라서 현재 위의 항목으로 다시 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="939127156e81551fd5a7e818b4482a513aebb0f8" translate="yes" xml:space="preserve">
          <source>Called while stopped (can be a client event loop).</source>
          <target state="translated">중지 된 동안 호출됩니다 (클라이언트 이벤트 루프 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="aac1bcb8d7dddba4603f778cf3da3d2bb22b9d64" translate="yes" xml:space="preserve">
          <source>Called without parameters, or with the first argument false, hash marks are suppressed. If the first argument is true but not a reference to a file handle glob, then \*STDERR is used. The second argument is the number of bytes per hash mark printed, and defaults to 1024. In all cases the return value is a reference to an array of two: the filehandle glob reference and the bytes per hash mark.</source>
          <target state="translated">매개 변수없이 또는 첫 번째 인수가 false 인 경우 해시 표시가 억제됩니다. 첫 번째 인수가 true이지만 파일 핸들 glob에 대한 참조가 아닌 경우 \ * STDERR이 사용됩니다. 두 번째 인수는 인쇄 된 해시 마크 당 바이트 수이며 기본값은 1024입니다. 모든 경우에 반환 값은 파일 핸들 글로브 참조와 해시 마크 당 바이트의 두 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e216eb70c5a18b158cc8c755c284c444b41dcf38" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt; inside a thread causes the whole application to terminate. Because of this, the use of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside threaded code, or in modules that might be used in threaded applications, is strongly discouraged.</source>
          <target state="translated">스레드 내에서 &lt;a href=&quot;functions/exit&quot;&gt;종료 EXPR을&lt;/a&gt; 호출 하면 전체 애플리케이션이 종료됩니다. 이 때문에 스레드 코드 내에서 또는 스레드 응용 프로그램에서 사용될 수있는 모듈에서 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2d2e77d4a5966924f91b9000c9d77963f423bb14" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;perlfunc#exit-EXPR&quot;&gt;exit()&lt;/a&gt; inside a thread causes the whole application to terminate. Because of this, the use of &lt;code&gt;exit()&lt;/code&gt; inside threaded code, or in modules that might be used in threaded applications, is strongly discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1f81bd75479e40b9c0318383b0b5ea0cddb02d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;flush&lt;/code&gt; returns the array to immediate-write mode. If you wish to discard the deferred writes, you may call &lt;code&gt;-&amp;gt;discard&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;flush&lt;/code&gt; . Note that in some cases, some of the data will have been written already, and it will be too late for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; to discard all the changes. Support for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; may be withdrawn in a future version of &lt;code&gt;Tie::File&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-&amp;gt;flush&lt;/code&gt; 를 호출 하면 배열이 즉시 쓰기 모드로 돌아갑니다. 지연된 쓰기를 삭제하려면 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 대신 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 를 호출 하십시오 . 경우에 따라 일부 데이터가 이미 작성되었으며 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 가 모든 변경 사항을 삭제 하기에는 너무 늦습니다 . 향후 버전의 &lt;code&gt;Tie::File&lt;/code&gt; 에서 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 지원 이 철회 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76255ff12e8b31dd1faa9b3a8f1af6ce261a3237" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;flush&lt;/code&gt; returns the array to immediate-write mode. If you wish to discard the deferred writes, you may call &lt;code&gt;-&amp;gt;discard&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;flush&lt;/code&gt;. Note that in some cases, some of the data will have been written already, and it will be too late for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; to discard all the changes. Support for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; may be withdrawn in a future version of &lt;code&gt;Tie::File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b218ac14d28e4eba90c2438d62379a52be6547e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already detached thread will cause an error to be thrown.</source>
          <target state="translated">이미 분리 된 스레드에서 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b0f01a2dc8c4ec0ab9ed2203d7fa7fc14d740a" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already joined thread will cause an error to be thrown.</source>
          <target state="translated">이미 결합 된 스레드에서 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 또는 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5013e17c5c2bf4d76b64a60f93a3e6d87ce580e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; in a thread indicates an abnormal exit for the thread. Any &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler in the thread will be called first, and then the thread will exit with a warning message that will contain any arguments passed in the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">스레드에서 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 스레드가 비정상적으로 종료되었음을 나타냅니다. 모든 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 스레드의 핸들러가 먼저 호출되고, 다음 스레드는 전달 된 인수가 포함됩니다 경고 메시지와 함께 종료됩니다 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="432a891f5fe2a318db5e9ee1a582e0b88a0dccd1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;attributes::get()&lt;/code&gt; from within the scope of a null package declaration &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; for an unblessed variable reference will not provide any starting package name for the 'fetch' method lookup. Thus, this circumstance will not result in a method call for package-defined attributes. A named subroutine knows to which symbol table entry it belongs (or originally belonged), and it will use the corresponding package. An anonymous subroutine knows the package name into which it was compiled (unless it was also compiled with a null package declaration), and so it will use that package name.</source>
          <target state="translated">호출 &lt;code&gt;attributes::get()&lt;/code&gt; 널 패키지 선언의 범위 내에서 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; 축복되지 않은 변수 참조의 경우 'fetch'메소드 검색을위한 시작 패키지 이름을 제공하지 않습니다. 따라서이 상황에서는 패키지 정의 속성에 대한 메소드 호출이 발생하지 않습니다. 명명 된 서브 루틴은 자신이 속한 (또는 원래 속한) 심볼 테이블 항목을 알고 있으며 해당 패키지를 사용합니다. 익명 서브 루틴은 패키지가 널 패키지 선언으로 컴파일되지 않은 경우 컴파일 된 패키지 이름을 알고 있으므로 해당 패키지 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7a2534c30975c1b087b49471bb8e69b1192ea93" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;attributes::get()&lt;/code&gt; from within the scope of a null package declaration &lt;code&gt;package ;&lt;/code&gt; for an unblessed variable reference will not provide any starting package name for the 'fetch' method lookup. Thus, this circumstance will not result in a method call for package-defined attributes. A named subroutine knows to which symbol table entry it belongs (or originally belonged), and it will use the corresponding package. An anonymous subroutine knows the package name into which it was compiled (unless it was also compiled with a null package declaration), and so it will use that package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c282790e74cecc249727d08376e623e8df58ac" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;die()&lt;/code&gt; in a thread indicates an abnormal exit for the thread. Any &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler in the thread will be called first, and then the thread will exit with a warning message that will contain any arguments passed in the &lt;code&gt;die()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dcc202c1bcd283c8d27205afa6c8a664424d57" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;finalize&lt;/code&gt; on a Prereqs object will close it for further modification. Attempting to make any changes that would actually alter the prereqs will result in an exception being thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bb3644bf1e13b2cbec6a1bd85b13b8d5473401" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;finalize&lt;/code&gt; on a child with open children will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">호출 &lt;code&gt;finalize&lt;/code&gt; 열고 아이들과 아이에하는 것입니다 &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d102d9d7899bae3b5de4db95f96142eba91cc591" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;open&lt;/code&gt; with one argument via global variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05e36379b2d12e2a61d8dca60e3236620cfbdd1" translate="yes" xml:space="preserve">
          <source>Calling Configure</source>
          <target state="translated">호출 구성</target>
        </trans-unit>
        <trans-unit id="858cb737d2c8f0a72b951ab4ea78b7b78f817737" translate="yes" xml:space="preserve">
          <source>Calling Conventions and Magic Autogeneration</source>
          <target state="translated">전화 컨벤션 및 매직 자동 생성</target>
        </trans-unit>
        <trans-unit id="007c7c3c00863b6f6eeae212582075fcbcd68f99" translate="yes" xml:space="preserve">
          <source>Calling POSIX::%s() is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a077d29f5340a5b715ff2d0b7446d09abed736c" translate="yes" xml:space="preserve">
          <source>Calling Perl Routines from within C Programs</source>
          <target state="translated">C 프로그램 내에서 Perl 루틴 호출</target>
        </trans-unit>
        <trans-unit id="da4bd907e548514c9e5225dea46a70baeae7e05d" translate="yes" xml:space="preserve">
          <source>Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is complete. It is removed from the list of 'exported' FILE *s, and the associated PerlIO * should revert to its original behaviour.</source>
          <target state="translated">PerlIO_releaseFILE을 호출하면 모든 FILE * 사용이 완료되었음을 PerlIO에 알립니다. '내 보낸'FILE * 목록에서 제거되며 관련 PerlIO *는 원래 동작으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="4f10f9c81f6874964032fb54a94909bb2041ccaa" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;find(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;find(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Pod :: Simple :: Search-&amp;gt; find (...) 호출은 Pod :: Simple :: Search-&amp;gt; new-&amp;gt; find (...)의 줄임말입니다. 즉, 기본 속성 값을 가진 폐기 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63b53fa8f0a187ed1ffd0c16a376efb544cfcb62" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;search(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;search(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">Pod :: Simple :: Search-&amp;gt; search (...) 호출은 Pod :: Simple :: Search-&amp;gt; new-&amp;gt; search (...)의 줄임말입니다. 즉, 기본 속성 값을 가진 폐기 객체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae570393756fa33aae649a93468e74ad3aa690b1" translate="yes" xml:space="preserve">
          <source>Calling a Perl method from C is fairly straightforward. The following things are required:</source>
          <target state="translated">C에서 Perl 메소드를 호출하는 것은 매우 간단합니다. 다음 사항이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4f751357fb4ae38f84e904fc36d9db5113b5aaaf" translate="yes" xml:space="preserve">
          <source>Calling a Perl subroutine from your C program</source>
          <target state="translated">C 프로그램에서 Perl 서브 루틴 호출</target>
        </trans-unit>
        <trans-unit id="c40cbac274b56e1beac728d697b23cc2ad8b3e30" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is written as &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; .</source>
          <target state="translated">객체에서 메소드를 호출하는 것은 &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b9ba46d6edef1a3ad04cd36813abba303e920d0" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is written as &lt;code&gt;$object-&amp;gt;method&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effd5ea5d1271fcf8d367de7457fffef004c2411" translate="yes" xml:space="preserve">
          <source>Calling a subroutine as &lt;code&gt;&amp;amp;foo&lt;/code&gt; with no trailing parentheses ignores the prototype of &lt;code&gt;foo&lt;/code&gt; and passes it the current value of the argument list, &lt;code&gt;@_&lt;/code&gt; . Here's an example; the &lt;code&gt;bar&lt;/code&gt; subroutine calls &lt;code&gt;&amp;amp;foo&lt;/code&gt; , which prints its arguments list:</source>
          <target state="translated">같은 서브 루틴을 호출 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 전혀 뒤 괄호가의 프로토 타입 무시 &lt;code&gt;foo&lt;/code&gt; 는 그것에게 인수 목록의 현재 값을 전달 &lt;code&gt;@_&lt;/code&gt; . 다음은 예입니다. &lt;code&gt;bar&lt;/code&gt; 서브 루틴 호출 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 인수 목록을 인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="5f2e994dab175c56f2b3036cb967b87cd73f7dc9" translate="yes" xml:space="preserve">
          <source>Calling a subroutine as &lt;code&gt;&amp;amp;foo&lt;/code&gt; with no trailing parentheses ignores the prototype of &lt;code&gt;foo&lt;/code&gt; and passes it the current value of the argument list, &lt;code&gt;@_&lt;/code&gt;. Here's an example; the &lt;code&gt;bar&lt;/code&gt; subroutine calls &lt;code&gt;&amp;amp;foo&lt;/code&gt;, which prints its arguments list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a5a40c5745b90b08565729f9c8b41d859bfba5" translate="yes" xml:space="preserve">
          <source>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle &lt;code&gt;_&lt;/code&gt; . It still refers to the result of the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; or unoverloaded filetest.</source>
          <target state="translated">오버로드 된 파일 테스트 연산자를 호출해도 특수 파일 핸들 &lt;code&gt;_&lt;/code&gt; 과 관련된 통계 값에는 영향을 미치지 않습니다 . 여전히 마지막 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 또는 오버로드되지 않은 파일 테스트 의 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="deea643f059aedfd6a8b872cf539a132679beee6" translate="yes" xml:space="preserve">
          <source>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle &lt;code&gt;_&lt;/code&gt;. It still refers to the result of the last &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt; or unoverloaded filetest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b56c65ecc7ed881027be8fe2d912f5b6a36243" translate="yes" xml:space="preserve">
          <source>Calling any of the dequeue methods with &lt;code&gt;COUNT&lt;/code&gt; greater than a queue's &lt;code&gt;limit&lt;/code&gt; will generate an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013392383aeb8f3aaeaada77da8e78bbc103974c" translate="yes" xml:space="preserve">
          <source>Calling either function on a string that already is in the desired state is a no-op.</source>
          <target state="translated">이미 원하는 상태에있는 문자열에서 함수를 호출하는 것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac9d89d6b846180f08777572deb7332f87bf19f8" translate="yes" xml:space="preserve">
          <source>Calling exec() within a pseudo-process actually spawns the requested executable in a separate process and waits for it to complete before exiting with the same exit status as that process. This means that the process ID reported within the running executable will be different from what the earlier Perl fork() might have returned. Similarly, any process manipulation functions applied to the ID returned by fork() will affect the waiting pseudo-process that called exec(), not the real process it is waiting for after the exec().</source>
          <target state="translated">의사 프로세스 내에서 exec ()를 호출하면 실제로 요청 된 실행 파일이 별도의 프로세스로 생성되고 해당 프로세스와 동일한 종료 상태로 종료하기 전에 해당 프로세스가 완료되기를 기다립니다. 이는 실행중인 실행 파일 내에보고 된 프로세스 ID가 이전 Perl fork ()가 리턴 한 것과 다릅니다. 마찬가지로 fork ()에 의해 반환 된 ID에 적용된 프로세스 조작 함수는 exec () 이후에 대기중인 실제 프로세스가 아니라 exec ()를 호출 한 대기 의사 프로세스에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b3da6d792b23555ef8d68fd44a37624b5388c7ec" translate="yes" xml:space="preserve">
          <source>Calling methods from a package means it must be loaded, of course, so you will often want to load a module and add it to &lt;code&gt;@ISA&lt;/code&gt; at the same time. You can do so in a single step using the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma. (In older code you may encounter the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma, which is nowadays discouraged except when you have to work with the equally discouraged &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb763801b922c32e04d2d797853c7083dee141b" translate="yes" xml:space="preserve">
          <source>Calling the &lt;code&gt;truncate&lt;/code&gt; method returns a copy of the object but with the time truncated to the start of the supplied unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ade94f7a99e61011be8ace5918982f9630cfc9" translate="yes" xml:space="preserve">
          <source>Calling the Debugger</source>
          <target state="translated">디버거 호출</target>
        </trans-unit>
        <trans-unit id="2ca81641ec6217e87de3fa52de37358174c935e6" translate="yes" xml:space="preserve">
          <source>Calling the subroutine with trailing parentheses, with or without arguments, does not use the current &lt;code&gt;@_&lt;/code&gt; . Changing the example to put parentheses after the call to &lt;code&gt;foo&lt;/code&gt; changes the program:</source>
          <target state="translated">인수가 있거나없는 후행 괄호로 서브 루틴을 호출하면 현재 &lt;code&gt;@_&lt;/code&gt; 가 사용되지 않습니다 . &lt;code&gt;foo&lt;/code&gt; 를 호출 한 후 괄호를 넣도록 예제를 변경하면 프로그램이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="422d0af8c5eb261d34cbbb96d682bb4067741230" translate="yes" xml:space="preserve">
          <source>Calling the subroutine with trailing parentheses, with or without arguments, does not use the current &lt;code&gt;@_&lt;/code&gt;. Changing the example to put parentheses after the call to &lt;code&gt;foo&lt;/code&gt; changes the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492d320490c0c1bea0a0670c56d499e8b857ba1c" translate="yes" xml:space="preserve">
          <source>Calling this function repeatedly will create a FILE * on each call (and will push an :stdio layer each time as well).</source>
          <target state="translated">이 함수를 반복해서 호출하면 각 호출마다 FILE *가 생성됩니다 (또한 매번 : stdio 계층을 푸시합니다).</target>
        </trans-unit>
        <trans-unit id="bc6008c1e7f7d9345b7132b8abf50b8ba6fadc50" translate="yes" xml:space="preserve">
          <source>Calling this function will cause any temp files or temp directories that are registered for removal to be removed. This happens automatically when the process exits but can be triggered manually if the caller is sure that none of the temp files are required. This method can be registered as an Apache callback.</source>
          <target state="translated">이 함수를 호출하면 제거를 위해 등록 된 임시 파일 또는 임시 디렉토리가 제거됩니다. 프로세스가 종료되면 자동으로 발생하지만 호출자가 임시 파일이 필요하지 않은 것으로 확인되면 수동으로 트리거 할 수 있습니다. 이 메소드는 Apache 콜백으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a047a5a40f59a3fe1e8072e49516ca5ef89a11" translate="yes" xml:space="preserve">
          <source>Calling this method without any arguments will reset the booleans to their default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c554dbf8d391703907c916da0c8b2d2b667cbb" translate="yes" xml:space="preserve">
          <source>Calling this on the root builder is a no-op.</source>
          <target state="translated">루트 빌더에서 이것을 호출하는 것은 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="2e765d5d5aa54eb2d852bc799f3a264f32d02c18" translate="yes" xml:space="preserve">
          <source>Calling with ampersand syntax and through references does not work for the following functions, as they have special syntax that cannot always be translated into a simple list (e.g., &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">앰퍼샌드 구문 및 참조를 통한 호출은 항상 간단한 목록으로 변환 될 수없는 특수 구문 (예 : &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; ) 을 가지므로 다음 함수에는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="572ae6ad378888078239d3f0fa7d20957b159547" translate="yes" xml:space="preserve">
          <source>Calling with ampersand syntax and through references does not work for the following functions, as they have special syntax that cannot always be translated into a simple list (e.g., &lt;code&gt;eof&lt;/code&gt; vs &lt;code&gt;eof()&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d2f00d0a68b61567b5869949b9613e61d77b2e" translate="yes" xml:space="preserve">
          <source>Callon, Ross, editor. 1996.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4be13ee9b6c0119a6fc3735504c657f3d22aba3" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; locking, or &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt;. &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4f026ec1a5607feec9a1e107752900730638f9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; turning off the ending tests. This is needed as otherwise it will trip out because we've run more tests than we strictly should have and it'll register any failures we had that we were testing for as real failures.</source>
          <target state="translated">&lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; 호출 하여 종료 테스트를 끕니다. 이는 엄격히해야하는 것보다 더 많은 테스트를 실행하고 실제 실패로 테스트하고 있던 모든 실패를 등록하므로 트립되기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e2d11676efd2bea34999087c58d58b6f570aee40" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;sv_setsv&lt;/code&gt; if &lt;code&gt;dsv&lt;/code&gt; is not the same as &lt;code&gt;ssv&lt;/code&gt;. May evaluate arguments more than once. Does not handle 'set' magic on the destination SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590c7d6e88adb5bddf3d8f642e0126b6c862bc26" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once. Does not handle 'set' magic on the destination SV.</source>
          <target state="translated">dsv가 ssv와 &lt;code&gt;sv_setsv&lt;/code&gt; 않으면 sv_setsv를 호출 합니다. 인수를 두 번 이상 평가할 수 있습니다. 대상 SV에서 '세트'마법을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecc1c1a42047512bf4698d979850ea62424810ba" translate="yes" xml:space="preserve">
          <source>Calls Cwd::cwd</source>
          <target state="translated">Cwd :: cwd 호출</target>
        </trans-unit>
        <trans-unit id="c904982ef90b628587f5e1c223b066f40097484e" translate="yes" xml:space="preserve">
          <source>Calls Cwd::fastcwd</source>
          <target state="translated">Cwd :: fastcwd 호출</target>
        </trans-unit>
        <trans-unit id="8c1ba5cb44af7e4a4c20a5047a781fc7e8a8fc22" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getcwd</source>
          <target state="translated">Cwd :: getcwd 호출</target>
        </trans-unit>
        <trans-unit id="206e7aa2eb36edf2b309bbc5748aac00256c2321" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getdcwd</source>
          <target state="translated">Cwd :: getdcwd 호출</target>
        </trans-unit>
        <trans-unit id="2af7df6efbe8d09524c66413aabddc70ce66b453" translate="yes" xml:space="preserve">
          <source>Calls a non-destructive version of &lt;code&gt;sv_setsv&lt;/code&gt; if &lt;code&gt;dsv&lt;/code&gt; is not the same as &lt;code&gt;ssv&lt;/code&gt;. May evaluate arguments more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780a41207facdbbb71db04db90d90ec1fa2163f5" translate="yes" xml:space="preserve">
          <source>Calls a non-destructive version of &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once.</source>
          <target state="translated">dsv가 ssv와 동일하지 않은 경우 비파괴 버전의 &lt;code&gt;sv_setsv&lt;/code&gt; 를 호출합니다 . 인수를 두 번 이상 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ff2ef8b2188043c87a9c12a3c9cbf04635b332b" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">FILEHANDLE에서 flock (2) 또는 에뮬레이션을 호출합니다. 성공하면 true를, 실패하면 false를 반환합니다. flock (2), fcntl (2) 잠금 또는 lockf (3)를 구현하지 않는 시스템에서 사용하면 치명적인 오류가 발생합니다. &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 은 Perl의 휴대용 파일 잠금 인터페이스이지만 레코드가 아닌 전체 파일 만 잠급니다.</target>
        </trans-unit>
        <trans-unit id="bb35c1fa57137cad992f4edf7e56c85897367e17" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">FILEHANDLE에서 flock (2) 또는 에뮬레이션을 호출합니다. 성공하면 true를, 실패하면 false를 반환합니다. flock (2), fcntl (2) 잠금 또는 lockf (3)를 구현하지 않는 시스템에서 사용하면 치명적인 오류가 발생합니다. &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 은 Perl의 휴대용 파일 잠금 인터페이스이지만 레코드가 아닌 전체 파일 만 잠급니다.</target>
        </trans-unit>
        <trans-unit id="773f4cafc0f3777dd34c2b664ecf08fdcad62645" translate="yes" xml:space="preserve">
          <source>Calls install() with arguments to copy a module from blib/ to the default site installation location.</source>
          <target state="translated">인수와 함께 install ()을 호출하여 blib /에서 기본 사이트 설치 위치로 모듈을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="f72e847b0819bcbc3ab49dbf4b9ab2bb349a665c" translate="yes" xml:space="preserve">
          <source>Calls makeaperl.</source>
          <target state="translated">makeaperl을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="37943b6a726d9d0c50758cce3c190484f78dfe2c" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a list context.</source>
          <target state="translated">리스트 컨텍스트에서 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bb7f57720f3817b40ff0bbe8ea59e47c2d2ab29e" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a scalar context. This is the default context flag setting for all the</source>
          <target state="translated">스칼라 컨텍스트에서 Perl 서브 루틴을 호출합니다. 이것은 모든 기본 컨텍스트 플래그 설정입니다</target>
        </trans-unit>
        <trans-unit id="73962f3f75b41688efacfc0da40dee4461b9fec3" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a void context.</source>
          <target state="translated">빈 컨텍스트에서 Perl 서브 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a917066a2b971e1883f106f1c39848e3431a241f" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function &lt;a href=&quot;http://man.he.net/man2/msgctl&quot;&gt;msgctl(2)&lt;/a&gt;. You'll probably have to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e4fe26c30e1fa24204f31776f0762d325e8b11" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function &lt;a href=&quot;http://man.he.net/man2/msgget&quot;&gt;msgget(2)&lt;/a&gt;. Returns the message queue id, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Msg&quot;&gt;&lt;code&gt;IPC::Msg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed1326cac6665ddf6fabcb783d39b2410699c9f" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function &lt;a href=&quot;http://man.he.net/man2/semctl&quot;&gt;semctl(2)&lt;/a&gt;. You'll probably have to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f6b9cf3287200835df80787252ceca2e3e01f3" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function &lt;a href=&quot;http://man.he.net/man2/semget&quot;&gt;semget(2)&lt;/a&gt;. Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Semaphore&quot;&gt;&lt;code&gt;IPC::Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f45ddf4f5072f6080434b7d93e3b080f31d293" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function &lt;a href=&quot;http://man.he.net/man2/semop&quot;&gt;semop(2)&lt;/a&gt; for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;pack(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt;. The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29d60ee63be0b6e387efbeaa174ef5a3adf4ba4" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgctl(2). You'll probably have to say</source>
          <target state="translated">System V IPC 함수 msgctl (2)를 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="be9988a6d42da7c4020e6a5f954992f1c4491de0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">System V IPC 함수 msgget (2)를 호출합니다. 메시지 큐 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98b9f73da86e0e6b472bbcb69f309820842a2666" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">System V IPC 함수 msgget (2)를 호출합니다. 메시지 큐 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc2abfdb7a6e8deeeb37c01f08b5371f84b9260b" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">최대 메시지 크기가 SIZE 인 메시지 큐 ID에서 변수 VAR로 메시지를 수신하기 위해 System V IPC 함수 msgrcv를 호출합니다. 메시지가 수신되면 VAR에서 가장 긴 정수인 메시지 유형이 실제 메시지 다음에 오게됩니다. 이 포장은 포장 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 로 열 수 있습니다 . 변수를 오염시킵니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="948f348f6fa98a8010bd8fc9ae4ccc04726f6c57" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">최대 메시지 크기가 SIZE 인 메시지 큐 ID에서 변수 VAR로 메시지를 수신하기 위해 System V IPC 함수 msgrcv를 호출합니다. 메시지가 수신되면 VAR에서 가장 긴 정수인 메시지 유형이 실제 메시지 다음에 오게됩니다. 이 포장은 포장 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 로 열 수 있습니다 . 변수를 오염시킵니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85d31b1b6ccaa6ed03aaac494aa638c440797b62" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;unpack(&quot;l! a*&quot;)&lt;/code&gt;. Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Msg&quot;&gt;&lt;code&gt;IPC::Msg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5afcee05064a60e928b37ea8427c6294d37aba0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">메시지 MSG를 메시지 큐 ID로 보내기 위해 System V IPC 기능 msgsnd를 호출합니다. MSG는 기본 정수 정수 메시지 유형으로 시작하고 그 뒤에 실제 메시지 길이가오고 마지막으로 메시지 자체가 있어야합니다. 이런 종류의 패킹은 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 으로 달성 할 수 있습니다 . 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 설명서 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11394b0f70e6027e810e867a48b7248721c79467" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">메시지 MSG를 메시지 큐 ID로 보내기 위해 System V IPC 기능 msgsnd를 호출합니다. MSG는 기본 정수 정수 메시지 유형으로 시작하고 그 뒤에 실제 메시지 길이가오고 마지막으로 메시지 자체가 있어야합니다. 이런 종류의 패킹은 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 으로 달성 할 수 있습니다 . 성공하면 true를, 오류가 발생하면 false를 반환합니다. &lt;code&gt;IPC::SysV&lt;/code&gt; 및 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 설명서 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8851b56288c91863a6d17483301ecf8e41e3ecfb" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;pack(&quot;l! a*&quot;, $type, $message)&lt;/code&gt;. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Msg&quot;&gt;&lt;code&gt;IPC::Msg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6019e00f804cda82d4ccc726e831f656c990eb13" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semctl(2). You'll probably have to say</source>
          <target state="translated">System V IPC 함수 semctl (2)를 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="5f610b5b4eaf02b0f729a98fdbc4342fbee172a9" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 semget (2)을 호출합니다. 세마포어 ID 또는 오류시 정의되지 않은 값을 반환합니다. 참조 &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;시스템 V IPC가 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="315be1c7490d0b06d562bb984c8930c31052ce5c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 semget (2)을 호출합니다. 세마포어 ID 또는 오류시 정의되지 않은 값을 반환합니다. 참조 &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;시스템 V IPC가 perlipc에서&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef274fb91ef606897494225538343bd9782c7288" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">시그널링 및 대기와 같은 세마포어 작업을 위해 System V IPC 함수 semop (2)를 호출합니다. OPSTRING은 semop 구조의 팩형 배열이어야합니다. 각 semop 구조는 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 으로 생성 할 수 있습니다 . OPSTRING의 길이는 세마포어 조작의 수를 의미합니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. 예를 들어 다음 코드는 세마포어 ID $ semid의 세마포어 $ semnum에서 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e0c44ed833fa28db0acecadac8e6a6c1fb4ee6ed" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">시그널링 및 대기와 같은 세마포어 작업을 위해 System V IPC 함수 semop (2)를 호출합니다. OPSTRING은 semop 구조의 팩형 배열이어야합니다. 각 semop 구조는 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 으로 생성 할 수 있습니다 . OPSTRING의 길이는 세마포어 조작의 수를 의미합니다. 성공하면 true를, 오류가 발생하면 false를 반환합니다. 예를 들어 다음 코드는 세마포어 ID $ semid의 세마포어 $ semnum에서 대기합니다.</target>
        </trans-unit>
        <trans-unit id="c7ffce30c16d2adb19634cb73edd07b139d51d58" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmctl. You'll probably have to say</source>
          <target state="translated">System V IPC 함수 shmctl을 호출합니다. 아마 말해야 할 것입니다</target>
        </trans-unit>
        <trans-unit id="ccef605f2e6df70fde49a59cc497d30196bec568" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bc62f7fa862b27b2de307fc455c072f03da35c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 shmget을 호출합니다. 공유 메모리 세그먼트 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c305f2b321c34aa679da0caad314dcb3d11fcda" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">System V IPC 함수 shmget을 호출합니다. 공유 메모리 세그먼트 ID를 반환하거나 오류시 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc의 SysV IPC&lt;/a&gt; 및 &lt;code&gt;IPC::SysV&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="171e1908f8052943b22ba1224601d2782bb8861e" translate="yes" xml:space="preserve">
          <source>Calls the external command cwd.</source>
          <target state="translated">외부 명령 cwd를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3c0dfe2a93186d77d26e8574e4df98dbb4f6b11b" translate="yes" xml:space="preserve">
          <source>Calls the reports() method on the associated distribution object.</source>
          <target state="translated">연관된 분배 오브젝트에서 reports () 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="96cd064be72718f49bf44f8c4387cf9595674530" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;syswrite&lt;/code&gt;&lt;/a&gt; function (or vice versa):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80219f44739d96f5e20c3cf29ed7bd7ff8e792b" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">목록의 첫 번째 요소로 지정된 시스템 호출을 호출하고 나머지 요소는 시스템 호출에 인수로 전달합니다. 구현되지 않은 경우 예외가 발생합니다. 인수는 다음과 같이 해석됩니다. 주어진 인수가 숫자 인 경우 인수는 int로 전달됩니다. 그렇지 않으면 문자열 값에 대한 포인터가 전달됩니다. 문자열에 기록 될 수있는 결과를 수신 할 수있을 정도로 문자열이 미리 확장되어 있는지 확인해야합니다. Perl은 문자열 포인터가 작성 될 수 있다고 가정해야하므로 문자열 리터럴 (또는 다른 읽기 전용 문자열)을 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 의 인수로 사용할 수 없습니다 . 정수 인수가 리터럴이 아니며 숫자 컨텍스트에서 해석되지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 추가해야 할 수도 있습니다.그들에게 숫자처럼 보이도록 강요합니다. 이것은 에뮬레이트합니다 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 기능 (또는 그 반대) :</target>
        </trans-unit>
        <trans-unit id="14adf48ff5b79cf02eb35e0df8ee02d1dedea8a0" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">목록의 첫 번째 요소로 지정된 시스템 호출을 호출하고 나머지 요소는 시스템 호출에 인수로 전달합니다. 구현되지 않은 경우 예외가 발생합니다. 인수는 다음과 같이 해석됩니다. 주어진 인수가 숫자 인 경우 인수는 int로 전달됩니다. 그렇지 않으면 문자열 값에 대한 포인터가 전달됩니다. 문자열에 기록 될 수있는 결과를 수신 할 수있을 정도로 문자열이 미리 확장되어 있는지 확인해야합니다. Perl은 문자열 포인터가 작성 될 수 있다고 가정해야하므로 문자열 리터럴 (또는 다른 읽기 전용 문자열)을 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 의 인수로 사용할 수 없습니다 . 정수 인수가 리터럴이 아니며 숫자 컨텍스트에서 해석되지 않은 경우 &lt;code&gt;0&lt;/code&gt; 을 추가해야 할 수도 있습니다. 처럼 보이 합니다. 이것은 에뮬레이션 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 함수를(또는 그 반대).</target>
        </trans-unit>
        <trans-unit id="4689606e99f2e0dc6a1ba0af906a041a8988cfda" translate="yes" xml:space="preserve">
          <source>Calls to external programs</source>
          <target state="translated">외부 프로그램으로 전화</target>
        </trans-unit>
        <trans-unit id="b9f578265a3254a0619351c53e86631e90149c66" translate="yes" xml:space="preserve">
          <source>Calls user-supplied functions for conversion. For &lt;code&gt;OUTPUT&lt;/code&gt; (XSUB to Perl), a function named &lt;code&gt;XS_pack_$ntype&lt;/code&gt; is called with the output Perl scalar and the C variable to convert from. &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type that is to be mapped to Perl. Normalized means that all &lt;code&gt;*&lt;/code&gt; are replaced by the string &lt;code&gt;Ptr&lt;/code&gt; . The return value of the function is ignored.</source>
          <target state="translated">변환을 위해 사용자 제공 함수를 호출합니다. 들면 &lt;code&gt;OUTPUT&lt;/code&gt; (펄 XSUB)라는 함수 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 출력 펄 스칼라로부터 변환하는 C 변수로 불린다. &lt;code&gt;$ntype&lt;/code&gt; 은 Perl에 매핑 될 정규화 된 C 유형입니다. 정규화는 모든 &lt;code&gt;*&lt;/code&gt; 가 문자열 &lt;code&gt;Ptr&lt;/code&gt; 로 대체 됨을 의미합니다 . 함수의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5713c56b79a368245b2288e1a9373414b6001e42" translate="yes" xml:space="preserve">
          <source>Calls user-supplied functions for conversion. For &lt;code&gt;OUTPUT&lt;/code&gt; (XSUB to Perl), a function named &lt;code&gt;XS_pack_$ntype&lt;/code&gt; is called with the output Perl scalar and the C variable to convert from. &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type that is to be mapped to Perl. Normalized means that all &lt;code&gt;*&lt;/code&gt; are replaced by the string &lt;code&gt;Ptr&lt;/code&gt;. The return value of the function is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c8dd3e8e14ad4f27432158bf7160979db0ce6b" translate="yes" xml:space="preserve">
          <source>CamelBones</source>
          <target state="translated">CamelBones</target>
        </trans-unit>
        <trans-unit id="adb92c1608308898a1811cd12d916df49f9c32f4" translate="yes" xml:space="preserve">
          <source>CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; ) is a Perl interface to Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that CPAN.pm doesn't know how to install, but installation is via the standard OSX package installer. The Perl API is, again, very close to the ObjC API it's wrapping, and the documentation just tells you how to translate from one to the other.</source>
          <target state="translated">CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; )는 Mac OS X의 Cocoa GUI 툴킷에 대한 Perl 인터페이스이며, Mac OS X에서 고유 GUI를 생성하는 데 사용될 수 있습니다. CPAN에는 CPAN의 프레임 워크가 필요하므로 CPAN에는 없습니다. .pm은 설치 방법을 모르지만 표준 OSX 패키지 설치 프로그램을 통해 설치됩니다. Perl API는 다시 랩핑하는 ObjC API와 매우 유사하며 문서는 서로간에 변환하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="80701e22e30b3906cffd903f13b0b88b4269184d" translate="yes" xml:space="preserve">
          <source>CamelGrayBig.BMP</source>
          <target state="translated">CamelGrayBig.BMP</target>
        </trans-unit>
        <trans-unit id="80c61bba9e87f80092474b3e9f8694f40db54332" translate="yes" xml:space="preserve">
          <source>Camelcade plugin provides Perl5 support in IntelliJ IDEA and other JetBrains IDEs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e35891916ef0cba1da028aae28377672d4e03bd" translate="yes" xml:space="preserve">
          <source>Can I Read/Write Zip files larger the 4 Gig?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06a2487ce9da8707485d167c86e4cec108412be" translate="yes" xml:space="preserve">
          <source>Can I do [task] in Perl?</source>
          <target state="translated">Perl에서 [작업]을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="36ad0cba0b89c07f07180ff1037ede0187a0e666" translate="yes" xml:space="preserve">
          <source>Can I do a reget operation like the ftp command ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17260f8bf54a1e0a6921ffbe29352d30c7eb0d7e" translate="yes" xml:space="preserve">
          <source>Can I get a BNF/yacc/RE for the Perl language?</source>
          <target state="translated">Perl 언어에 대한 BNF / yacc / RE를받을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3a800859ea9403fd88df5aa63fab2b1ed9bba4be" translate="yes" xml:space="preserve">
          <source>Can I use Perl regular expressions to match balanced text?</source>
          <target state="translated">균형 잡힌 텍스트와 일치시키기 위해 Perl 정규식을 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2289a974ae52b9e29f0b401490ee2c25637b7437" translate="yes" xml:space="preserve">
          <source>Can I use Unicode in my Perl sources?</source>
          <target state="translated">Perl 소스에서 유니 코드를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="32e50e864db1746776899a01caf14e13d2d4a291" translate="yes" xml:space="preserve">
          <source>Can I use perl to run a telnet or ftp session?</source>
          <target state="translated">펄을 사용하여 텔넷 또는 ftp 세션을 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="7a4618a13feffae59b70603845a943f2cb759ba6" translate="yes" xml:space="preserve">
          <source>Can I write more that 64K entries is a Zip files?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d0ae1165be9b8566f8406ca14230c7961f4848" translate="yes" xml:space="preserve">
          <source>Can I write useful Perl programs on the command line?</source>
          <target state="translated">명령 행에 유용한 Perl 프로그램을 작성할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="35df49ce9c972c29af7bf8e861531cb5efb30472" translate="yes" xml:space="preserve">
          <source>Can also be called as an instance method.</source>
          <target state="translated">인스턴스 메소드로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ba8c255d770ca0f7b72beded6916ada06108fbe" translate="yes" xml:space="preserve">
          <source>Can also be used to set &lt;code&gt;$TODO&lt;/code&gt; to a new value while returning the old value:</source>
          <target state="translated">이전 값을 반환하면서 &lt;code&gt;$TODO&lt;/code&gt; 를 새 값 으로 설정하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a763feb2abeeeb1f5fc314f6396d5ecb0b67e0b" translate="yes" xml:space="preserve">
          <source>Can be called as either an object or a class method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cc357ede21e8f86848e6eae7e811a215ba08ce" translate="yes" xml:space="preserve">
          <source>Can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pod2latex&lt;/code&gt; 를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4965933ed8a498358e075e20abc688b166f9b286" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether code references are turned into perl source code. If set to a true value, &lt;code&gt;B::Deparse&lt;/code&gt; will be used to get the source of the code reference. In older versions, using this option imposed a significant performance penalty when dumping parts of a data structure other than code references, but that is no longer the case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa58e7bcf2882cbd00cc88fa0dc03c0cd52468bb" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether code references are turned into perl source code. If set to a true value, &lt;code&gt;B::Deparse&lt;/code&gt; will be used to get the source of the code reference. Using this option will force using the Perl implementation of the dumper, since the fast XSUB implementation doesn't support it.</source>
          <target state="translated">코드 참조가 펄 소스 코드로 변환되는지 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. true 값으로 설정하면 &lt;code&gt;B::Deparse&lt;/code&gt; 가 코드 참조의 소스를 가져 오는 데 사용됩니다. 빠른 XSUB 구현이이를 지원하지 않기 때문에이 옵션을 사용하면 덤퍼의 Perl 구현을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c627856437742bf2a91768641f29dacbba9c49e" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are dumped in sorted order. A true value will cause the keys of all hashes to be dumped in Perl's default sort order. Can also be set to a subroutine reference which will be called for each hash that is dumped. In this case &lt;code&gt;Data::Dumper&lt;/code&gt; will call the subroutine once for each hash, passing it the reference of the hash. The purpose of the subroutine is to return a reference to an array of the keys that will be dumped, in the order that they should be dumped. Using this feature, you can control both the order of the keys, and which keys are actually used. In other words, this subroutine acts as a filter by which you can exclude certain keys from being dumped. Default is 0, which means that hash keys are not sorted.</source>
          <target state="translated">해시 키가 정렬 된 순서로 덤프되는지 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. 값이 true이면 모든 해시의 키가 Perl의 기본 정렬 순서로 덤프됩니다. 덤프되는 각 해시마다 호출되는 서브 루틴 참조로 설정할 수도 있습니다. 이 경우 &lt;code&gt;Data::Dumper&lt;/code&gt; 는 각 해시마다 서브 루틴을 한 번 호출하여 해시 참조를 전달합니다. 서브 루틴의 목적은 덤프 될 순서대로 덤프 될 키 배열에 대한 참조를 리턴하는 것입니다. 이 기능을 사용하면 키 순서와 실제로 사용되는 키를 모두 제어 할 수 있습니다. 즉,이 서브 루틴은 특정 키가 덤프되지 않도록 제외시키는 필터 역할을합니다. 기본값은 0이며, 이는 해시 키가 정렬되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7fb27ddb4917ba511f5c8620ff526bf1f7bf1e63" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are quoted. A defined false value will avoid quoting hash keys when it looks like a simple string. Default is 1, which will always enclose hash keys in quotes.</source>
          <target state="translated">해시 키의 인용 여부를 제어하기 위해 부울 값으로 설정할 수 있습니다. 정의 된 false 값은 간단한 문자열처럼 보일 때 해시 키를 인용하지 않습니다. 기본값은 1이며 항상 해시 키를 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="88c46add64294e8210c672da2183abe0ed447bfc" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to enable deep copies of structures. Cross-referencing will then only be done when absolutely essential (i.e., to break reference cycles). Default is 0.</source>
          <target state="translated">구조의 깊은 사본을 사용하기 위해 부울 값으로 설정할 수 있습니다. 상호 참조는 절대적으로 필요한 경우에만 수행됩니다 (예 : 기준 사이클을 중단). 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="67a33f1bf6a1de539cc6aeb590a56729f0fa737c" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value which controls whether the pure Perl implementation of &lt;code&gt;Data::Dumper&lt;/code&gt; is used. The &lt;code&gt;Data::Dumper&lt;/code&gt; module is a dual implementation, with almost all functionality written in both pure Perl and also in XS ('C'). Since the XS version is much faster, it will always be used if possible. This option lets you override the default behavior, usually for testing purposes only. Default is 0, which means the XS implementation will be used if possible.</source>
          <target state="translated">&lt;code&gt;Data::Dumper&lt;/code&gt; 의 순수 Perl 구현 사용 여부를 제어하는 ​​부울 값으로 설정할 수 있습니다 . &lt;code&gt;Data::Dumper&lt;/code&gt; 모듈은 모두 순수 Perl로도 XS ( 'C')에 기록 된 거의 모든 기능을, 듀얼 구현입니다. XS 버전이 훨씬 빠르므로 가능하면 항상 사용됩니다. 이 옵션을 사용하면 일반적으로 테스트 목적으로 만 기본 동작을 무시할 수 있습니다. 기본값은 0이며, 가능하면 XS 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb22428de8a3ede5e563a5e4f65611da085b8c2a" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will emit a method call for any objects that are to be dumped using the syntax &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; . Note that this means that the method specified will have to perform any modifications required on the object (like creating new state within it, and/or reblessing it in a different package) and then return it. The client is responsible for making sure the method can be called via the object, and that it returns a valid object. Defaults to an empty string.</source>
          <target state="translated">기능을 비활성화하기 위해 메소드 이름 또는 빈 문자열로 설정할 수 있습니다. Data :: Dumper는 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; 구문을 사용하여 덤프 할 객체에 대한 메소드 호출을 생성합니다 . 이는 지정된 메소드가 오브젝트에 필요한 수정을 수행하고 (예 : 오브젝트 내에 새 상태 작성 및 / 또는 다른 패키지에서이를 재 축제하는 것과 같이) 리턴해야 함을 의미합니다. 클라이언트는 메소드를 오브젝트를 통해 호출 할 수 있는지 확인하고 유효한 오브젝트를 리턴해야합니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b11825cf8d5444285d0f3fd94a8c3dfc7f09ab85" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will emit a method call for any objects that are to be dumped using the syntax &lt;code&gt;bless(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt;. Note that this means that the method specified will have to perform any modifications required on the object (like creating new state within it, and/or reblessing it in a different package) and then return it. The client is responsible for making sure the method can be called via the object, and that it returns a valid object. Defaults to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585673e874a0b17703c1a10f7dfc47aff5c9f0ec" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will invoke that method via the object before attempting to stringify it. This method can alter the contents of the object (if, for instance, it contains data allocated from C), and even rebless it in a different package. The client is responsible for making sure the specified method can be called via the object, and that the object ends up containing only perl data types after the method has been called. Defaults to an empty string.</source>
          <target state="translated">기능을 비활성화하기 위해 메소드 이름 또는 빈 문자열로 설정할 수 있습니다. Data :: Dumper는 문자열 화를 시도하기 전에 객체를 통해 해당 메소드를 호출합니다. 이 메소드는 오브젝트의 컨텐츠를 변경하고 (예를 들어, C에서 할당 된 데이터를 포함하는 경우), 다른 패키지로 다시 만들 수도 있습니다. 클라이언트는 지정된 메소드가 오브젝트를 통해 호출 될 수 있는지 확인하고 메소드가 호출 된 후 오브젝트에 펄 데이터 유형 만 포함되도록합니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6ee2759a6426aff4b67b4db8b27a81f5748f17a4" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which recursion into a structure will throw an exception. This is intended as a security measure to prevent perl running out of stack space when dumping an excessively deep structure. Can be set to 0 to remove the limit. Default is 1000.</source>
          <target state="translated">구조로의 재귀가 예외를 발생시키는 깊이를 지정하는 양의 정수로 설정할 수 있습니다. 이는 지나치게 깊은 구조를 덤프 할 때 스택 공간에서 펄이 부족 해지는 것을 방지하기위한 보안 조치입니다. 한계를 제거하기 위해 0으로 설정할 수 있습니다. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="4bf42f1af137c40c87a30e672fa92d800507f75f" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which we don't venture into a structure. Has no effect when &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; is set. (Useful in debugger when we often don't want to see more than enough). Default is 0, which means there is no maximum depth.</source>
          <target state="translated">구조로 들어 가지 않는 깊이를 지정하는 양의 정수로 설정할 수 있습니다. &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; 가 설정되어 있으면 효과가 없습니다 . (우리가 종종 더 이상보고 싶지 않은 디버거에 유용합니다). 기본값은 0이며 최대 깊이가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1b8ab4925558b8a13bc55bec7e3f47e1da66a3e2" translate="yes" xml:space="preserve">
          <source>Can be set to a regular expression. Only files with names that match the expression will be read.</source>
          <target state="translated">정규식으로 설정할 수 있습니다. 식과 일치하는 이름을 가진 파일 만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b4c1fc7bc4091447e126bb9cbc6311ac8f682f2f" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies an alternative to the &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; builtin operator used to create objects. A function with the specified name should exist, and should accept the same arguments as the builtin. Default is &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">객체를 만드는 데 사용되는 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 내장 연산자 의 대안을 지정하는 문자열로 설정할 수 있습니다 . 지정된 이름의 함수가 존재해야하며 내장 함수와 동일한 인수를 허용해야합니다. 기본값은 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8d696a13fbd3787a71fb1fa50c88e46886ad09" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies an alternative to the &lt;code&gt;bless&lt;/code&gt; builtin operator used to create objects. A function with the specified name should exist, and should accept the same arguments as the builtin. Default is &lt;code&gt;bless&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a994c4b88b43caa5b752fd46ef7324627d9d83c6" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies the separator between hash keys and values. To dump nested hash, array and scalar values to JavaScript, use: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . Implementing &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; in JavaScript is left as an exercise for the reader. A function with the specified name exists, and accepts the same arguments as the builtin.</source>
          <target state="translated">해시 키와 값 사이의 구분 기호를 지정하는 문자열로 설정할 수 있습니다. 중첩 해시, 배열 및 스칼라 값을 JavaScript로 덤프하려면 다음을 사용하십시오. &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . JavaScript로 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 을 구현 하는 것은 독자의 연습으로 남아 있습니다. 지정된 이름의 함수가 존재하며 내장과 동일한 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4da48067bcb9ac7f05cdf30f4157e26c1703a27f" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies the separator between hash keys and values. To dump nested hash, array and scalar values to JavaScript, use: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt;. Implementing &lt;code&gt;bless&lt;/code&gt; in JavaScript is left as an exercise for the reader. A function with the specified name exists, and accepts the same arguments as the builtin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e933a47e6aaf6dd73210fa86f1269378f8318bc" translate="yes" xml:space="preserve">
          <source>Can be trimmed if you compile for one access method.</source>
          <target state="translated">하나의 액세스 방법으로 컴파일하면 다듬을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="521dc350b83fb9d0aef450c7bd8ea71637ecc134" translate="yes" xml:space="preserve">
          <source>Can be used to get/set the filehandles. Indexes are identified by the &lt;code&gt;OUT_STD&lt;/code&gt; and &lt;code&gt;OUT_ERR&lt;/code&gt; constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717d201646a10747b3a920b5eaa1592483e5445b" translate="yes" xml:space="preserve">
          <source>Can call croak() if an error occurs.</source>
          <target state="translated">에러가 발생하면 croak ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="610ece97ddb84d598c6d8556f131f1844efd48bc" translate="yes" xml:space="preserve">
          <source>Can call croak() if there is a security anomaly during the stat() comparison.</source>
          <target state="translated">stat () 비교 중에 보안 이상이있는 경우 croak ()을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512d893f80ec4605f408cd9d8d3b090f641b1bc5" translate="yes" xml:space="preserve">
          <source>Can only be applied to process handles returned for processes spawned using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; or pseudo processes created with &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 작성된 의사 프로세스를 사용하여 생성 된 프로세스에 대해 리턴 된 프로세스 핸들에만 적용 할 수 있습니다 . (Win32)</target>
        </trans-unit>
        <trans-unit id="3d551e22f31cb9e7a6e87242c04142cacdd9e085" translate="yes" xml:space="preserve">
          <source>Can only compress unsigned integers in pack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc17adc87dae58e0d71e7b8a46715c51db69dd0" translate="yes" xml:space="preserve">
          <source>Can use any of the methods described above but for further customization one needs to override some of the methods:</source>
          <target state="translated">위에서 설명한 방법 중 하나를 사용할 수 있지만 추가 사용자 정의를 위해서는 일부 방법을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e5e0a8f8265c585a4f386242ed86595f0f740c3" translate="yes" xml:space="preserve">
          <source>Can we do the same with an XSUB</source>
          <target state="translated">XSUB로도 같은 작업을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="464a528d25f15fcc413cccaa9039a519f971ff35" translate="yes" xml:space="preserve">
          <source>Can you describe the bug in plain English?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e89781235664711abeb12b27bdbc2f29b3b339" translate="yes" xml:space="preserve">
          <source>Can you fix the bug yourself?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5608d8974ae07992c56822675bbd6ac88c79a5cd" translate="yes" xml:space="preserve">
          <source>Can you lazy-load data instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed62fc194f3937ce4d71415ddacb324ed399936b" translate="yes" xml:space="preserve">
          <source>Can you use &lt;code&gt;perlbug&lt;/code&gt; to submit a thank-you note?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610efb240abaf3ea2c7896188006719e64b149b7" translate="yes" xml:space="preserve">
          <source>Can't &quot;break&quot; in a loop topicalizer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5267bb8010bbb7a6db4a6906e8693b63a95a10" translate="yes" xml:space="preserve">
          <source>Can't &quot;break&quot; outside a given block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f6eee861c1cd353015b8f99633849b2ad8b6b" translate="yes" xml:space="preserve">
          <source>Can't &quot;continue&quot; outside a when block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5031122e389e2a8f51436eefc4fd6c303a7874ef" translate="yes" xml:space="preserve">
          <source>Can't &quot;default&quot; outside a topicalizer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54adaebe96f6f14efea9928fcb70d70ab7208530" translate="yes" xml:space="preserve">
          <source>Can't &quot;goto&quot; into a &quot;given&quot; block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97ed9e79dff848024195e1d17df569a0614b7f9" translate="yes" xml:space="preserve">
          <source>Can't &quot;goto&quot; into a binary or list expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c96689798d1e5eb721e92be82b1e85d192e746" translate="yes" xml:space="preserve">
          <source>Can't &quot;goto&quot; into the middle of a foreach loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292e527849b890fe71de8d1ef37b93db73abdc02" translate="yes" xml:space="preserve">
          <source>Can't &quot;goto&quot; out of a pseudo block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e4e8a631a4dace6462765b61586a6f3818bfb3" translate="yes" xml:space="preserve">
          <source>Can't &quot;last&quot; outside a loop block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af20848c94f970db6efca5a1f1a68ee5eef163f" translate="yes" xml:space="preserve">
          <source>Can't &quot;next&quot; outside a loop block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1a6b4b5d7807286b0352e400757a27d6c53dde" translate="yes" xml:space="preserve">
          <source>Can't &quot;redo&quot; outside a loop block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30706871a36ddc9aa4e542689a79fed92550b9d4" translate="yes" xml:space="preserve">
          <source>Can't &quot;when&quot; outside a topicalizer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739fbf3b991aa3306484c95541d74ac6110799ac" translate="yes" xml:space="preserve">
          <source>Can't %s %s-endian %ss on this platform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1856a75618797a18a668ad5c56fdb6cfb907772d" translate="yes" xml:space="preserve">
          <source>Can't be used by more than one module in a single program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91995835d674b3cf661c8f37ab1798b89b1ab9d6" translate="yes" xml:space="preserve">
          <source>Can't bless non-reference value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52b07474c6248623ee044575ad79260817dc732" translate="yes" xml:space="preserve">
          <source>Can't call method &quot;%s&quot; on an undefined value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31eb8ca46c20a63468e96d0119fe4b0ab2ed41d7" translate="yes" xml:space="preserve">
          <source>Can't call method &quot;%s&quot; on unblessed reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21aa3f9f11a962d5a8136b0d22220a88232f9eb4" translate="yes" xml:space="preserve">
          <source>Can't call method &quot;%s&quot; without a package or object reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f99c38d16202cb1e5238364ba2e015191f0def4" translate="yes" xml:space="preserve">
          <source>Can't call mro_isa_changed_in() on anonymous symbol table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c73f04ff81e18f8b075ff1e7ca12ddbe0cf71d" translate="yes" xml:space="preserve">
          <source>Can't call mro_method_changed_in() on anonymous symbol table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f185fa80d16db103831be6732bec2cbdb876c17" translate="yes" xml:space="preserve">
          <source>Can't chdir to %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39f3e5fc2bc595191631ac64e0110e379c05120" translate="yes" xml:space="preserve">
          <source>Can't check filesystem of script &quot;%s&quot; for nosuid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab029356c1dcdb7ddd4db17e3ca26c3bdea04cd" translate="yes" xml:space="preserve">
          <source>Can't coerce %s to %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8135be232e0c989a972d3285dca8e1be94c89bb" translate="yes" xml:space="preserve">
          <source>Can't create pipe mailbox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39be791b64076f438fc4fc4549ff16a866b21a3c" translate="yes" xml:space="preserve">
          <source>Can't declare %s in &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421bf40bef9b904ca19bbc43b0b6e304e13c7d0c" translate="yes" xml:space="preserve">
          <source>Can't determine class of operator %s, assuming BASEOP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5525dd98465276b549436a7aaaea773a34e12cdb" translate="yes" xml:space="preserve">
          <source>Can't do %s(&quot;%s&quot;) on non-UTF-8 locale; resolved to &quot;%s&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799ebf7552897604edfb655ee73cb4aa2e65564f" translate="yes" xml:space="preserve">
          <source>Can't do inplace edit on %s: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fc86196418f4eb47afc83791341c1d2b02409e" translate="yes" xml:space="preserve">
          <source>Can't do inplace edit: %s is not a regular file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d201f1f315a2780544f8f13e1bff7ab0d04f47da" translate="yes" xml:space="preserve">
          <source>Can't do inplace edit: %s would not be unique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751fce6dbbda7a1efa0473b4e1db461c754d4012" translate="yes" xml:space="preserve">
          <source>Can't do waitpid with flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c543ce903975d4c46285e7ba8ab13dba08720d" translate="yes" xml:space="preserve">
          <source>Can't emulate -%s on #! line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba565a6c185898b9c853d8b41dcdb7df64dd77d" translate="yes" xml:space="preserve">
          <source>Can't exec &quot;%s&quot;: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98aff00df7fc28c9118a56e889015f548c3b1d6f" translate="yes" xml:space="preserve">
          <source>Can't exec %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbb83283103d369cd009d2fb09d0c3027047de0" translate="yes" xml:space="preserve">
          <source>Can't execute %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e673e894256ce8258644963ba449cc08a696f2a0" translate="yes" xml:space="preserve">
          <source>Can't find %s on PATH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a347039c959afcde3039f1cc543cdf77eaf343" translate="yes" xml:space="preserve">
          <source>Can't find %s on PATH, '.' not in PATH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04925a28f7de74ca3260ac8009169ca793b7dd6c" translate="yes" xml:space="preserve">
          <source>Can't find Unicode property definition &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f919f1e0dd48452dd3f3007d95a278f883d55cb" translate="yes" xml:space="preserve">
          <source>Can't find Unicode property definition &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6b6abc3119c565999617ad82811d11e9cf74ef" translate="yes" xml:space="preserve">
          <source>Can't find an opnumber for &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a073bbd2adfee099a38ce1cf48da9ea06d14cc2" translate="yes" xml:space="preserve">
          <source>Can't find label %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8674cca3540f909a6e7d1746f8ab0e906443ddea" translate="yes" xml:space="preserve">
          <source>Can't find string terminator %s anywhere before EOF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9902ded7245ba58492e826cbd78144be6e0b082" translate="yes" xml:space="preserve">
          <source>Can't fork, trying again in 5 seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc12510e515931da96c92c3dd9822d024879c4f" translate="yes" xml:space="preserve">
          <source>Can't fork: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc95c76e34bbcb3ac3e2167785800bfaa08082f0" translate="yes" xml:space="preserve">
          <source>Can't get SYSGEN parameter value for MAXBUF</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e898aa48bf2a4ad6e3a66e4a25fc752d5790eb8b" translate="yes" xml:space="preserve">
          <source>Can't get filespec - stale stat buffer?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5157e1d5ceb8c44b0381792927b7f6ed6e6fe6" translate="yes" xml:space="preserve">
          <source>Can't get pipe mailbox device name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af789fc6df03d085c7560c168207188bd089f808" translate="yes" xml:space="preserve">
          <source>Can't goto subroutine from a sort sub (or similar callback)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e4c16930673bb4bd17a46bef3956985f35c783" translate="yes" xml:space="preserve">
          <source>Can't goto subroutine from an eval-%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08685649c3b554522c303b64206695490b2a9a75" translate="yes" xml:space="preserve">
          <source>Can't goto subroutine outside a subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bc53813367f15ad7fd5e6c473cbf45b7508af4" translate="yes" xml:space="preserve">
          <source>Can't have a 0 in =over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95b4238378329e0e66b3fe87b93480ed8c0163b" translate="yes" xml:space="preserve">
          <source>Can't ignore signal CHLD, forcing to default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209c1dd1d198f15260ea9fe2d0267cd749d13fec" translate="yes" xml:space="preserve">
          <source>Can't kill a non-numeric process ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854b58a1a74b2ff5f09474ec8360292927417069" translate="yes" xml:space="preserve">
          <source>Can't linearize anonymous symbol table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68326ac4a2b948a26636891b3172cd7613dd16c5" translate="yes" xml:space="preserve">
          <source>Can't load '%s' for module %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad118a840973578048304da9e4f67b2ef09cc96" translate="yes" xml:space="preserve">
          <source>Can't localize lexical variable %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059add3be3b6631cfa466485a4d59ae6847384df" translate="yes" xml:space="preserve">
          <source>Can't localize through a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8190ac1f225c43a3c6b431f272c0cf6c8d766378" translate="yes" xml:space="preserve">
          <source>Can't locate %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff9d0dd46a0f6d96b6530672a1def705c7eb5e2" translate="yes" xml:space="preserve">
          <source>Can't locate PerlIO%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701d024514e4834bd8f733a06e64983615b22bb" translate="yes" xml:space="preserve">
          <source>Can't locate auto/%s.al in @INC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0531eadde3f1644d3d81f08ad68828d1732f8d" translate="yes" xml:space="preserve">
          <source>Can't locate loadable object for module %s in @INC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ddc2b5284a6658ec4c35b32361ad5e6843ab5a" translate="yes" xml:space="preserve">
          <source>Can't locate object method &quot;%s&quot; via package &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856d71e2ccc5dc0179b30be00df48a3fa3ef5c5c" translate="yes" xml:space="preserve">
          <source>Can't locate object method &quot;%s&quot; via package &quot;%s&quot; (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcada84613fcdc78cb7459bdc0bce32dec0040f8" translate="yes" xml:space="preserve">
          <source>Can't locate package %s for @%s::ISA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fe9c70fde31d15a48884094e607d19f244c906" translate="yes" xml:space="preserve">
          <source>Can't make list assignment to %ENV on this system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56650e531c219b96060d691972076b7f3b4cfc1d" translate="yes" xml:space="preserve">
          <source>Can't make loaded symbols global on this platform while loading %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5de11f11ab44c9f3c84eacc2234354d9e240cc" translate="yes" xml:space="preserve">
          <source>Can't modify %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b6e3af4990589e685062c8af185ee22cda18ff" translate="yes" xml:space="preserve">
          <source>Can't modify non-lvalue subroutine call of &amp;amp;%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb212950718e9340d89c5b19f9133919e1ebc2e" translate="yes" xml:space="preserve">
          <source>Can't modify non-lvalue subroutine call of &amp;amp;%s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaca9b0920afd252b3807162e97466ed7ed772db" translate="yes" xml:space="preserve">
          <source>Can't modify nonexistent substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de526e2b2dd17c16062ddd0b3be1faf0a4c95c35" translate="yes" xml:space="preserve">
          <source>Can't modify reference to %s in %s assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece864afd296053aeb27646df351d85f71c1b9d3" translate="yes" xml:space="preserve">
          <source>Can't modify reference to localized parenthesized array in list assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28041854196266225e06dfeccf3445cf97ae0dbf" translate="yes" xml:space="preserve">
          <source>Can't modify reference to parenthesized hash in list assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71b162349ad8d3cc1b62ad26a21aad2924ff2d2" translate="yes" xml:space="preserve">
          <source>Can't move directories between directories on different logical volumes. (Win32)</source>
          <target state="translated">다른 논리 볼륨의 디렉토리간에 디렉토리를 이동할 수 없습니다. (Win32)</target>
        </trans-unit>
        <trans-unit id="253802c668bb989a5f22bd3eea83b1824d4e2d9b" translate="yes" xml:space="preserve">
          <source>Can't msgrcv to read-only var</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcb71bfd86c0e91cb932afa6693beaf3db80849" translate="yes" xml:space="preserve">
          <source>Can't open %s for reading: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7e82ecbec319db3ac48476c8fc988603922b0f" translate="yes" xml:space="preserve">
          <source>Can't open %s: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b47e9fcf4d99f67f18ab23bd218159eef9c13ab" translate="yes" xml:space="preserve">
          <source>Can't open a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60024d188cd4d4c0c0003e45a5fe98eb9c7c162" translate="yes" xml:space="preserve">
          <source>Can't open bidirectional pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eec28bc4405ab30736402c536493a71e47fcb7" translate="yes" xml:space="preserve">
          <source>Can't open error file %s as stderr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac08c0c69b1481a6aa69fc6e2f4f533733680442" translate="yes" xml:space="preserve">
          <source>Can't open input file %s as stdin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f088e61191d284ee060f7fe01fec6eaf20763a7" translate="yes" xml:space="preserve">
          <source>Can't open output file %s as stdout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a90fd6697b09b852cb1e1dc935296753b45b29" translate="yes" xml:space="preserve">
          <source>Can't open output pipe (name: %s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b90f250fc3ac9a20c74a55a9e9facc489fa13f" translate="yes" xml:space="preserve">
          <source>Can't open perl script &quot;%s&quot;: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee64cedb1a1cb1d91b6a178a0a9832c207890bd4" translate="yes" xml:space="preserve">
          <source>Can't read CRTL environ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ede2d9d86cf67fb629f074ca78e860d0d9fab7b" translate="yes" xml:space="preserve">
          <source>Can't redeclare &quot;%s&quot; in &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f166bacef5e5597fa942abc67b168e62388fc153" translate="yes" xml:space="preserve">
          <source>Can't remove %s: %s, skipping file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb937d4de08be950c9ecb1762c96ed8cb9686b9" translate="yes" xml:space="preserve">
          <source>Can't rename %s to %s: %s, skipping file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a43d9553c530ca2509d37b700b01eb470c061b" translate="yes" xml:space="preserve">
          <source>Can't rename in-place work file '%s' to '%s': %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7b6fde3e21c351e61def567bf76e539f3ee923" translate="yes" xml:space="preserve">
          <source>Can't reopen input pipe (name: %s) in binary mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6f4901930125b8629e6d241783f853c1bea7a0" translate="yes" xml:space="preserve">
          <source>Can't represent character for Ox%X on this platform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad6b52932458c7860a5ae1bcb97c00e6ca48303" translate="yes" xml:space="preserve">
          <source>Can't reset %ENV on this system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84979537cfd0f0f071043caf043519cf175f8a9d" translate="yes" xml:space="preserve">
          <source>Can't resolve method &quot;%s&quot; overloading &quot;%s&quot; in package &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7ad0aea6bd0cd26a1e94b76e26f86df3b41437" translate="yes" xml:space="preserve">
          <source>Can't return %s from lvalue subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b80012b0e6e81d9e1151ca353b9114e7b547900" translate="yes" xml:space="preserve">
          <source>Can't return %s to lvalue scalar context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bae2a960d0856237b1216bdb7d3ad590d492c4" translate="yes" xml:space="preserve">
          <source>Can't return outside a subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75abc33a50ebc04bfeb2b56f56de0f4c6ae6f515" translate="yes" xml:space="preserve">
          <source>Can't stat script &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab99670ff8d8c85bbe295cfe5d78b7f827e2119" translate="yes" xml:space="preserve">
          <source>Can't take log of %g</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c0e313c42bf88914a90e5c2d2eb26e959f394c" translate="yes" xml:space="preserve">
          <source>Can't take sqrt of %g</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c5445fbb928768e9353ec9d999709b2b9bb549" translate="yes" xml:space="preserve">
          <source>Can't undef active subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6abe1792db906a52a11913bac927ca38a44773" translate="yes" xml:space="preserve">
          <source>Can't unweaken a nonreference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1f35ef7c4d401308e222d3fcffb9e9800d53a8" translate="yes" xml:space="preserve">
          <source>Can't upgrade %s (%d) to %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53faef17d768ab26e821e73ada78af65179f649b" translate="yes" xml:space="preserve">
          <source>Can't use &quot;my %s&quot; in sort comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa22ab8ff7d152243a8346dc02c35c3f3d6a0255" translate="yes" xml:space="preserve">
          <source>Can't use %! because Errno.pm is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6684f9ea9fdadb65c8a9421996c2f4d55e1886d" translate="yes" xml:space="preserve">
          <source>Can't use %s for loop variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333bebbc7a920a463ca900f63e0743d16fa2dcaa" translate="yes" xml:space="preserve">
          <source>Can't use %s ref as %s ref</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a115c0048e134e9d76b1b13d8d33deda087969e" translate="yes" xml:space="preserve">
          <source>Can't use '%c' after -mname</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8514b194f05ef85fa88cca4412220afbd285624" translate="yes" xml:space="preserve">
          <source>Can't use '%c' in a group with different byte-order in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5a99a4242c6abb3e04494187a05fa6dab2f31e" translate="yes" xml:space="preserve">
          <source>Can't use 'defined(%hash)' (Maybe you should just omit the defined()?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5b68a194b050b383eccd6adc4efdc6eb5b79b1" translate="yes" xml:space="preserve">
          <source>Can't use 'defined(@array)' (Maybe you should just omit the defined()?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bde597b32693d0abe304e3d13a90adaa98bc45f" translate="yes" xml:space="preserve">
          <source>Can't use \%c to mean $%c in expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a8e1b2b59fdc4a706c4e31cfd579bb62fc5939" translate="yes" xml:space="preserve">
          <source>Can't use a hash as a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02178331a38ef34753ddbf17cea7391d706e6790" translate="yes" xml:space="preserve">
          <source>Can't use an array as a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde94c5e75cb6a1b33b4f1f13580799044318cb5" translate="yes" xml:space="preserve">
          <source>Can't use an undefined value as %s reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a036bd3b8575d03e44627689d24be7dcde134126" translate="yes" xml:space="preserve">
          <source>Can't use anonymous symbol table for method lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0b3aa696da09b074406deb7fc50d8ab957d558" translate="yes" xml:space="preserve">
          <source>Can't use bareword (&quot;%s&quot;) as %s ref while &quot;strict refs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56529a2d10a3e25a4653ab805b6f80a460e185f" translate="yes" xml:space="preserve">
          <source>Can't use both '&amp;lt;' and '&amp;gt;' after type '%c' in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa0a9174c821771fb82e978bd7ff74664934902" translate="yes" xml:space="preserve">
          <source>Can't use global %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b34439935b436b9bdf4fc1f5a9d24c9f5d99b7" translate="yes" xml:space="preserve">
          <source>Can't use string (&quot;%s&quot;) as %s ref while &quot;strict refs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b456bf1b39c98c040555f540d4f0340908ea32f3" translate="yes" xml:space="preserve">
          <source>Can't use string (&quot;%s&quot;...) as %s ref while &quot;strict refs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2293fb91bfc92728008a30e736f71da35facbe9e" translate="yes" xml:space="preserve">
          <source>Can't use subscript on %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48413b1da81af0e8f787539b259fb7717aff54aa" translate="yes" xml:space="preserve">
          <source>Can't weaken a nonreference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9df7c794e4239f8fcf34bc70d062eaaffbe40aa" translate="yes" xml:space="preserve">
          <source>Can't x= to read-only value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6a7b8768528485a0dbcd459185091e80dc28ad" translate="yes" xml:space="preserve">
          <source>Canada</source>
          <target state="translated">Canada</target>
        </trans-unit>
        <trans-unit id="ab7cfc5e3e1575ef731dc8a192764717c39a667f" translate="yes" xml:space="preserve">
          <source>Cancel Ctrl/O (used with Terminal I/O).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c61e930ba2ace5562dbc01d87ff2dccd871bad" translate="yes" xml:space="preserve">
          <source>Cancel output to the file handle. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">파일 핸들로의 출력을 취소하십시오. &lt;code&gt;$parser&lt;/code&gt; 가 읽은 POD 는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c9d54018682f033ce26d5d28cbd53bef40aa76" translate="yes" xml:space="preserve">
          <source>Cancel output to the output string. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">출력 문자열로 출력을 취소하십시오. &lt;code&gt;$parser&lt;/code&gt; 가 읽은 POD 는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf5ab48928c6227aa52c3d012c2701389449d7d8" translate="yes" xml:space="preserve">
          <source>Canned Filters</source>
          <target state="translated">통조림 필터</target>
        </trans-unit>
        <trans-unit id="3482894db317b46f89fa72afa818ad64a07e0cd6" translate="yes" xml:space="preserve">
          <source>Cannot alias standard color %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41090d32ebd650b4d2771c985fed201051cdf9f4" translate="yes" xml:space="preserve">
          <source>Cannot alias standard color %s in %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b787d73f05383dd7a48896f2443da8e9275458d4" translate="yes" xml:space="preserve">
          <source>Cannot change stack size of an existing thread</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef73c44f87ca55aebbbb4209f8f165a3e8be29c" translate="yes" xml:space="preserve">
          <source>Cannot chr %f</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf6d2093d7aa9c2c96446dc6c579ae60a287418" translate="yes" xml:space="preserve">
          <source>Cannot complete in-place edit of %s: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf733aeab99894ab43126f5e6d2b81d874d7490" translate="yes" xml:space="preserve">
          <source>Cannot compress %f in pack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514769805856ccf2c5763fdcef436c3bc2222351" translate="yes" xml:space="preserve">
          <source>Cannot compress integer in pack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361040636e91d3798203704d51c1d95c2661e25" translate="yes" xml:space="preserve">
          <source>Cannot compress negative numbers in pack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb52553b7290c44cfad6769b7861a447ee417c5" translate="yes" xml:space="preserve">
          <source>Cannot convert a reference to %s to typeglob</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04f97c847ac18aa6024c06c265705e7cdd27488" translate="yes" xml:space="preserve">
          <source>Cannot copy to %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d38515cb4d649e479170b074991ec1a54930262" translate="yes" xml:space="preserve">
          <source>Cannot find encoding &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d97b2ab5bc100700978cd436d6f1a92e70266" translate="yes" xml:space="preserve">
          <source>Cannot make the non-overridable %s fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92329d5518a4d680c08de477d5613e4f5e2514d" translate="yes" xml:space="preserve">
          <source>Cannot open %s as a dirhandle: it is already open as a filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9a75fa08d6758b781cf39ffd1bc9a76df03b2e" translate="yes" xml:space="preserve">
          <source>Cannot open %s as a filehandle: it is already open as a dirhandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b6e672bb47f36ee70fad76d1b0ecf405f7492f" translate="yes" xml:space="preserve">
          <source>Cannot pack %f with '%c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b549c12495891c4212e9462b575ce7219f4b851" translate="yes" xml:space="preserve">
          <source>Cannot printf %f with '%c'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c599f856ba4af6fad2820148768283781cec70" translate="yes" xml:space="preserve">
          <source>Cannot set tied @DB::args</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2a221f5e04eff6e5d2aa76ebeee66ff6fcd159" translate="yes" xml:space="preserve">
          <source>Cannot signal threads without safe signals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbd1f5144cc25ff3e79e713323aaa5805fc1bb3" translate="yes" xml:space="preserve">
          <source>Cannot start &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt; 시작할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="4f9378da13e876924853515ac330a0589ab874eb" translate="yes" xml:space="preserve">
          <source>Cannot start find.exe &quot;pattern&quot; file</source>
          <target state="translated">find.exe &quot;pattern&quot;파일을 시작할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="914952aefbce09e1cf83c26cf3520aab7f64751c" translate="yes" xml:space="preserve">
          <source>Cannot tie unreifiable array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c959a875f14ef6a8cba2e5d7d5f89eb5b0c49a03" translate="yes" xml:space="preserve">
          <source>Cannot yet reorder sv_vcatpvfn() arguments from va_list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f4ae991f88e569288a303eea482424b54e133d" translate="yes" xml:space="preserve">
          <source>Canonical Equivalence in Applications - UTN #5</source>
          <target state="translated">응용에서의 정식 동등성-UTN # 5</target>
        </trans-unit>
        <trans-unit id="b8dabeba508ec88a0783430634fb6a91f3d06c7d" translate="yes" xml:space="preserve">
          <source>Canonical order does not imply network order; those are two orthogonal settings.</source>
          <target state="translated">정식 순서는 네트워크 순서를 의미하지 않습니다. 그것들은 두 개의 직교 설정입니다.</target>
        </trans-unit>
        <trans-unit id="4d54bf792a185de045beb26ac6e2d8cc01e21726" translate="yes" xml:space="preserve">
          <source>Capitalizes characters on a read from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70958560117660215c678a65a317f69cf291f71f" translate="yes" xml:space="preserve">
          <source>Capture STDOUT and STDERR output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e45233bca1ff9d51fe1747e5a3f80383b6f972" translate="yes" xml:space="preserve">
          <source>Capture an arrayref of warnings from the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41cbe379826efcfbfa4c8d79aa79ece89ec2bf7" translate="yes" xml:space="preserve">
          <source>Capture an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022667ded0755ea18f63880b563578c05902ec8e" translate="yes" xml:space="preserve">
          <source>Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;&quot;Compound Statements&quot; in perlsyn&lt;/a&gt;.) You can refer to them by absolute number (using &lt;code&gt;&quot;$1&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747ae3c9036b2b9d0c1bdc3f6a1c392c7794eed3" translate="yes" xml:space="preserve">
          <source>Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.) You can refer to them by absolute number (using &lt;code&gt;&quot;$1&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , etc); or by name via the &lt;code&gt;%+&lt;/code&gt; hash, using &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt;.</source>
          <target state="translated">캡처 그룹 내용은 동적으로 범위가 지정되며 둘러싸는 블록이 끝날 때까지 또는 다음 성공적인 일치 중 하나가 될 때까지 패턴 외부에서 사용할 수 있습니다. ( &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn의 복합 명령문을&lt;/a&gt; 참조하십시오 .) 절대 번호 ( &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 대신 &lt;code&gt;&quot;$1&quot;&lt;/code&gt; 사용 등)로 참조 할 수 있습니다 . 또는 &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt; &lt;i&gt;name&lt;/i&gt; }&quot;을 사용하여 &lt;code&gt;%+&lt;/code&gt; 해시 를 통해 이름별로 지정할 수 있습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">캡처 그룹</target>
        </trans-unit>
        <trans-unit id="17d5baafa6da919c16c090df56e9fd9d7a565715" translate="yes" xml:space="preserve">
          <source>Capture groups are numbered from left to right, but inside this construct the numbering is restarted for each branch.</source>
          <target state="translated">캡처 그룹은 왼쪽에서 오른쪽으로 번호가 매겨 지지만이 구성에서는 번호가 각 분기에 대해 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0771c31053343949dda6efc584e44e5297b9a9" translate="yes" xml:space="preserve">
          <source>Captured groups are numbered according to their</source>
          <target state="translated">캡처 된 그룹은</target>
        </trans-unit>
        <trans-unit id="f7b4920b8aa7c1586544c28d9c8886e52d98ca56" translate="yes" xml:space="preserve">
          <source>Capturing parenthesis that work just like perl</source>
          <target state="translated">펄처럼 작동하는 괄호 캡처</target>
        </trans-unit>
        <trans-unit id="307f83eae2041bdf7a5d0e4d4039929292abf689" translate="yes" xml:space="preserve">
          <source>Care has been taken to make all flags symmetrical with respect to &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;, that is, texts encoded with any combination of these flag values will be correctly decoded when the same flags are used - in general, if you use different flag settings while encoding vs. when decoding you likely have a bug somewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea8cbac41ff9a96e8d9db8e075354ecd6a9f99e" translate="yes" xml:space="preserve">
          <source>Care must be taken when making changes to make sure that you handle UTF-8 properly, both at compile time and at execution time, including when the string and pattern are mismatched.</source>
          <target state="translated">문자열과 패턴이 일치하지 않는 경우를 포함하여 컴파일 타임과 실행 시간에 UTF-8을 올바르게 처리 할 수 ​​있도록 변경시주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="04617e457add86a7b016a256cae6724b67e05962" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용할 때주의해야합니다 버전 의 형태로 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . 그것은</target>
        </trans-unit>
        <trans-unit id="f12898eb208465f617f9b5c3dd913e72b7c63a92" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 사용할 때주의해야합니다 버전 의 형태로 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; . 그것은</target>
        </trans-unit>
        <trans-unit id="662a10769a4851c5fa85f39275e3a20db3254277" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;no VERSION&lt;/code&gt; form of &lt;a href=&quot;#no-MODULE-VERSION-LIST&quot;&gt;&lt;code&gt;no&lt;/code&gt;&lt;/a&gt;. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00ed6d0c5ac45de00f179782815edeefadfc67b" translate="yes" xml:space="preserve">
          <source>Carp</source>
          <target state="translated">Carp</target>
        </trans-unit>
        <trans-unit id="d88a6c87d4e1376b298c703f4fc38df13d24c117" translate="yes" xml:space="preserve">
          <source>Carp - alternative warn and die for modules</source>
          <target state="translated">잉어-모듈에 대한 대체 경고 및 다이</target>
        </trans-unit>
        <trans-unit id="4cac758eff9ae8b1951cfa88daf6efd8e4c9f9dd" translate="yes" xml:space="preserve">
          <source>Carp gives two ways to control this.</source>
          <target state="translated">잉어는 이것을 제어하는 ​​두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9cdaea1be30b41a257f3e74ca5f04da906b26010" translate="yes" xml:space="preserve">
          <source>Carriage-return control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca0e3c0ab768e90d91b7158f9afa5173ab39d46" translate="yes" xml:space="preserve">
          <source>Case 2 is also deceptive in that you're accessing a variable called %hashref, not dereferencing through $hashref to the hash it's presumably referencing. That would be case 3.</source>
          <target state="translated">사례 2는 또한 $ hashref를 통해 아마도 참조하는 해시로 역 참조하지 않고 % hashref라는 변수에 액세스한다는 점에서 기만적입니다. 그것은 사례 3입니다.</target>
        </trans-unit>
        <trans-unit id="298d6337ccd66315823554fe2294fb2258cef971" translate="yes" xml:space="preserve">
          <source>Case Mappings/SpecialCasing</source>
          <target state="translated">사례 매핑 / 특별한 사건</target>
        </trans-unit>
        <trans-unit id="12c50192a130e9814d8ea8606bd466ad9981e92e" translate="yes" xml:space="preserve">
          <source>Case and abbreviations</source>
          <target state="translated">대소 문자 및 약어</target>
        </trans-unit>
        <trans-unit id="71820be5979516bbf68abefb91861f6a5f447350" translate="yes" xml:space="preserve">
          <source>Case translation operators use the Unicode case translation tables.</source>
          <target state="translated">대 / 소문자 변환 연산자는 유니 코드 대 / 소문자 변환 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9fc0b2fddd3396951a95310fbd8003b367dba5dd" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input parameters (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">대소 문자, 공백, 하이픈 및 밑줄은 입력 매개 변수에서 무시됩니다 (구형 일반 범주 속성 값 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 표시됨) ).</target>
        </trans-unit>
        <trans-unit id="5dc22b379cca8577f46f5a98f71105a90b33e0a9" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input parameters (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c97ea35c0c010d6bc3fa3e2766ca1eeed20cb95" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input property name (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">대소 문자, 공백, 하이픈 및 밑줄은 입력 속성 이름에서 무시됩니다 (구형 일반 범주 속성 값 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 의 후행 밑줄은 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; 로 더 잘 작성 됨 ).</target>
        </trans-unit>
        <trans-unit id="cdb95a78fe8cf5fb324342e8050f8f838eaf6255" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input property name (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5913a3e508c3f58147c3a7ea4922d97aeb2d10bc" translate="yes" xml:space="preserve">
          <source>Casefolding is the process of mapping strings to a form where case differences are erased; comparing two strings in their casefolded form is effectively a way of asking if two strings are equal, regardless of case.</source>
          <target state="translated">Casefolding은 대소 문자 차이가 지워지는 형태로 문자열을 매핑하는 프로세스입니다. 대소 문자를 구분 한 형태로 두 문자열을 비교하는 것은 대소 문자에 관계없이 두 문자열이 동일한 지 묻는 효과적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3efae3773aea3e6418118bae37722e49dd2d43fd" translate="yes" xml:space="preserve">
          <source>Cases 1 and 2 above behave identically: they run the code contained in the variable $x. (Although case 2 has misleading double quotes making the reader wonder what else might be happening (nothing is).) Cases 3 and 4 likewise behave in the same way: they run the code &lt;code&gt;'$x'&lt;/code&gt; , which does nothing but return the value of $x. (Case 4 is preferred for purely visual reasons, but it also has the advantage of compiling at compile-time instead of at run-time.) Case 5 is a place where normally you</source>
          <target state="translated">위의 사례 1과 2는 동일하게 작동합니다. 변수 $ x에 포함 된 코드를 실행합니다. (경우 2는 큰 따옴표를 잘못 사용하지만 독자는 다른 일이 일어나지 않을지 궁금해합니다.) 사례 3과 4도 같은 방식으로 작동합니다. 코드 &lt;code&gt;'$x'&lt;/code&gt; 아무것도하지 않는다, 그러나 값을 반환을 $ x (사례 4는 순수한 시각적 이유로 선호되지만 런타임 대신 컴파일 타임에 컴파일 할 수 있다는 장점도 있습니다.) 사례 5는 일반적으로</target>
        </trans-unit>
        <trans-unit id="b06e162aa03a647b4812343dc3da5daa182fbaff" translate="yes" xml:space="preserve">
          <source>Cases 1 and 2 above behave identically: they run the code contained in the variable $x. (Although case 2 has misleading double quotes making the reader wonder what else might be happening (nothing is).) Cases 3 and 4 likewise behave in the same way: they run the code &lt;code&gt;'$x'&lt;/code&gt;, which does nothing but return the value of $x. (Case 4 is preferred for purely visual reasons, but it also has the advantage of compiling at compile-time instead of at run-time.) Case 5 is a place where normally you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5505c412fd66a6e2bea57031fd55f4c6fd701c28" translate="yes" xml:space="preserve">
          <source>Cast-to-bool. A simple &lt;code&gt;(bool) &lt;i&gt;expr&lt;/i&gt;&lt;/code&gt; cast may not do the right thing: if &lt;code&gt;bool&lt;/code&gt; is defined as &lt;code&gt;char&lt;/code&gt;, for example, then the cast from &lt;code&gt;int&lt;/code&gt; is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce28c3834b46c5817fa1ba652ddba28baf2570f" translate="yes" xml:space="preserve">
          <source>Casting between function pointers and data pointers</source>
          <target state="translated">함수 포인터와 데이터 포인터 사이의 캐스트</target>
        </trans-unit>
        <trans-unit id="6f9e423b5bc8680aa5b16ed1908f25312d66ad7e" translate="yes" xml:space="preserve">
          <source>Casting pointers to integers or casting integers to pointers</source>
          <target state="translated">포인터를 정수로 캐스트하거나 정수를 포인터로 캐스트</target>
        </trans-unit>
        <trans-unit id="499253af5f67ae889bc3aabf24d35d8ba82de0e2" translate="yes" xml:space="preserve">
          <source>Casts I to the internal I32 type used by that perl.</source>
          <target state="translated">해당 perl에서 사용하는 내부 I32 유형으로 I을 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="59979146f46a040b0a7e911c02c1492a2329f87e" translate="yes" xml:space="preserve">
          <source>Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf602a375c078eea9d4f26e60690e565125dbf72" translate="yes" xml:space="preserve">
          <source>Catalyst</source>
          <target state="translated">Catalyst</target>
        </trans-unit>
        <trans-unit id="c174d6be41280356a91ddfdde65f079878120639" translate="yes" xml:space="preserve">
          <source>Catch stopped child processes.</source>
          <target state="translated">자식 프로세스가 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2d335ad7e81fdf6a55a7304c8fd31f60f0fc162" translate="yes" xml:space="preserve">
          <source>Catchall routine to clean up problem MM[SK]/Make macros. Expands macros in any directory specification, in order to avoid juxtaposing two VMS-syntax directories when MM[SK] is run. Also expands expressions which are all macro, so that we can tell how long the expansion is, and avoid overrunning DCL's command buffer when MM[KS] is running.</source>
          <target state="translated">문제 MM [SK] / 매크로를 정리하는 Catchall 루틴. MM [SK]가 실행될 때 두 개의 VMS 구문 디렉토리를 병렬 처리하지 않도록 모든 디렉토리 스펙에서 매크로를 확장합니다. 또한 모든 매크로 인 표현식을 확장하여 확장 시간을 알 수 있으며 MM [KS]가 실행될 때 DCL의 명령 버퍼가 오버런되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="8ebd028848b2a2942ac465614616f32324230d21" translate="yes" xml:space="preserve">
          <source>Catching signals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b5024a9f7f3c46574351ad45dcdeceef2016767" translate="yes" xml:space="preserve">
          <source>Categories of modules range from text manipulation to network protocols to database integration to graphics. A categorized list of modules is also available from CPAN.</source>
          <target state="translated">모듈 범주는 텍스트 조작에서 네트워크 프로토콜, 데이터베이스 통합 및 그래픽에 이르기까지 다양합니다. CPAN에서 분류 된 모듈 목록도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="337a8f7bd3bdbf4fe42f0b9d4b42a95657d8e9f9" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt; : Collation</source>
          <target state="translated">&lt;code&gt;LC_COLLATE&lt;/code&gt; 카테고리 : 콜 레이션</target>
        </trans-unit>
        <trans-unit id="63bd78675cb869e7c134fbca3753e02f0edb2b92" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt;: Collation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919d3be1151a8a62ff3f509b3510742d344c2496" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt;: Collation: Text Comparisons and Sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beec9c5a8a3b1200e13a31c08cab20f387038371" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_CTYPE&lt;/code&gt; : Character Types</source>
          <target state="translated">카테고리 &lt;code&gt;LC_CTYPE&lt;/code&gt; : 문자 유형</target>
        </trans-unit>
        <trans-unit id="011933a95f9a8627bd8a8b00900841623f871c86" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_CTYPE&lt;/code&gt;: Character Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d237153062484cd9db84eb0e31d1a90b2c50d7ab" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MESSAGES&lt;/code&gt;: Error and other messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38233af031be21177bea3a81f92c8363621b4861" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MONETARY&lt;/code&gt; : Formatting of monetary amounts</source>
          <target state="translated">&lt;code&gt;LC_MONETARY&lt;/code&gt; 카테고리 : 금액 서식</target>
        </trans-unit>
        <trans-unit id="56775ec2542f69ddf365702c3138f3ad177fd92b" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MONETARY&lt;/code&gt;: Formatting of monetary amounts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19550402e5a1f045b848054b7a9e298b524aa833" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt; : Numeric Formatting</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; 카테고리 : 숫자 형식</target>
        </trans-unit>
        <trans-unit id="5e8cd7df31bcad9a7460bcc56674a80279c7718f" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt;: Numeric Formatting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef0947154dc11f8df87c645f41aa4495ea0e052" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt;: Numeric formatting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55751e3a0413fc5462344716ab71e2bd8275874c" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_TIME&lt;/code&gt;: Date/Time formatting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf487ce36806c29e5298812ba0b7582489033c6" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_TIME&lt;/code&gt;: Respresentation of time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6caa2ce2c0ba347d49ead269d4ac916346dc572" translate="yes" xml:space="preserve">
          <source>Category Hierarchy</source>
          <target state="translated">카테고리 계층</target>
        </trans-unit>
        <trans-unit id="ad6f8c0088808eee492b45306c0d1b94608c6f08" translate="yes" xml:space="preserve">
          <source>Category LC_COLLATE: Collation</source>
          <target state="translated">LC_COLLATE 카테고리 : 콜 레이션</target>
        </trans-unit>
        <trans-unit id="0bdd88741c1732953327ff657fadb93b2ae039be" translate="yes" xml:space="preserve">
          <source>Category LC_COLLATE: Collation: Text Comparisons and Sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51fd3f6ab56831c7fdec8dd63db4d84c5e5ddfb" translate="yes" xml:space="preserve">
          <source>Category LC_CTYPE: Character Types</source>
          <target state="translated">카테고리 LC_CTYPE : 문자 유형</target>
        </trans-unit>
        <trans-unit id="7682ad4955d10f9cf4cc9354213c179454f72007" translate="yes" xml:space="preserve">
          <source>Category LC_MONETARY: Formatting of monetary amounts</source>
          <target state="translated">LC_MONETARY 카테고리 : 화폐 금액 형식</target>
        </trans-unit>
        <trans-unit id="07571e7937ae3f96671e4cd556a4abc903111a57" translate="yes" xml:space="preserve">
          <source>Category LC_NUMERIC: Numeric Formatting</source>
          <target state="translated">LC_NUMERIC 카테고리 : 숫자 형식</target>
        </trans-unit>
        <trans-unit id="df2ca5e8366f7d90f63b83096b599541b20211a0" translate="yes" xml:space="preserve">
          <source>Category LC_TIME: Respresentation of time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5815523127907cea055a8c75d152a5931bf9635a" translate="yes" xml:space="preserve">
          <source>Causes records to be flushed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351f03ebcae4fdf4e90e88c26a354b4fb738e5ad" translate="yes" xml:space="preserve">
          <source>Causes symbolic links to be followed. Since directory trees with symbolic links (followed) may contain files more than once and may even have cycles, a hash has to be built up with an entry for each file. This might be expensive both in space and time for a large directory tree. See &lt;a href=&quot;#follow_fast&quot;&gt;&quot;follow_fast&quot;&lt;/a&gt; and &lt;a href=&quot;#follow_skip&quot;&gt;&quot;follow_skip&quot;&lt;/a&gt; below. If either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85dc017dda24f39d24e2b45c927b49e37ad2e173" translate="yes" xml:space="preserve">
          <source>Causes symbolic links to be followed. Since directory trees with symbolic links (followed) may contain files more than once and may even have cycles, a hash has to be built up with an entry for each file. This might be expensive both in space and time for a large directory tree. See &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; and &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt; below. If either</source>
          <target state="translated">심볼릭 링크를 따르도록합니다. 심볼릭 링크가있는 디렉토리 트리 (다음에 오는)는 파일을 두 번 이상 포함 할 수 있으며주기가있을 수 있으므로 각 파일에 대한 항목으로 해시를 작성해야합니다. 큰 디렉토리 트리의 경우 공간과 시간이 모두 비쌀 수 있습니다. 아래의 &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; 및 &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip를&lt;/a&gt; 참조하십시오 . 어느 쪽이든</target>
        </trans-unit>
        <trans-unit id="d8a6af2ce96fea0e83364432bebd24ee2a299a63" translate="yes" xml:space="preserve">
          <source>Causes the script to sleep for (integer) EXPR seconds, or forever if no argument is given. Returns the integer number of seconds actually slept.</source>
          <target state="translated">스크립트가 (정수) EXPR 초 동안 또는 인수가 제공되지 않으면 영원히 휴면 상태가됩니다. 실제로 잤던 정수 (초)를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="adc5b4e7301cfc17b319d4424a90aed30a644658" translate="yes" xml:space="preserve">
          <source>Causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">이 모듈이 Time :: HiRes 모듈을 사용하게하여 ping ()에 대한 후속 호출에서 밀리 초를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
